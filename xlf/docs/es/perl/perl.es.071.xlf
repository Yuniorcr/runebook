<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">Advierte con &lt;code&gt;@message&lt;/code&gt; pero el mensaje parecer&amp;aacute; provenir del punto donde se llam&amp;oacute; a la funci&amp;oacute;n de prueba original ( &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d24c39aea457b02505102a29c905de4cac82e99" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27a6644654593ac9e5d122b1155ff23752c8073" translate="yes" xml:space="preserve">
          <source>Washington</source>
          <target state="translated">Washington</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">Wayne Thompson</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">Apoyamos &quot;oficialmente&quot; las dos series de lanzamiento estable más recientes.5.16.x y anteriores están ahora fuera de soporte.A partir del lanzamiento de 5.22.0,terminaremos &quot;oficialmente&quot; el soporte para Perl 5.18.x,aparte de proporcionar actualizaciones de seguridad como se describe a continuación.</target>
        </trans-unit>
        <trans-unit id="6d4d00accf40364d9a03449bdf5ad7e154d1f316" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.26.x and earlier are now out of support. As of the release of 5.32.0, we will &quot;officially&quot; end support for Perl 5.28.x, other than providing security updates as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">Ya hablamos sobre la matriz especial &lt;code&gt;@ISA&lt;/code&gt; y el pragma &lt;a href=&quot;parent&quot;&gt;principal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">Tambi&amp;eacute;n recomendamos utilizar este m&amp;eacute;todo para comprobar si un m&amp;oacute;dulo tiene una versi&amp;oacute;n suficiente. La implementaci&amp;oacute;n interna utiliza el m&amp;oacute;dulo de &lt;a href=&quot;version&quot;&gt;versi&amp;oacute;n&lt;/a&gt; para asegurarse de que los diferentes tipos de n&amp;uacute;meros de versi&amp;oacute;n se comparen correctamente.</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">Estamos al final de la regexp,así que hemos terminado! Hemos coincidido con &quot;abcd&quot; de la cadena &quot;abcde&quot;.</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">¡Hemos terminado!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">Estamos realizando solo una operaci&amp;oacute;n hash en esta funci&amp;oacute;n, que est&amp;aacute; almacenando un nuevo escalar bajo una clave usando &lt;code&gt;hv_store&lt;/code&gt; . Un hash est&amp;aacute; representado por un puntero HV *. Al igual que las matrices, las funciones para manipular hashes desde un XSUB reflejan la funcionalidad disponible en Perl. Vea &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; y &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3c6308f6a80327169a668ffa81bc777a5db0a8f1" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt;. A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d6aa4a367d4b3962d66c4c93f795d417974b93" translate="yes" xml:space="preserve">
          <source>We are used to using the term (character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">No estamos interesados en nada devuelto de</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">No estamos pasando ningún parámetro a</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">Construimos perl usando GNU make.Probamos el make nativo una vez y también funcionó.</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n podemos volcar esta &lt;code&gt;PL_op&lt;/code&gt; : la operaci&amp;oacute;n actual siempre se almacena en PL_op , y podemos volcarla con &lt;code&gt;Perl_op_dump&lt;/code&gt; . Esto nos dar&amp;aacute; una salida similar a &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a951916387170e99fc981f4b1d58e4dc7bd8c60" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt;, and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt;. This'll give us similar output to CPAN module B::Debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar &lt;code&gt;@&lt;/code&gt; para saltar a un desplazamiento, siendo 0 la posici&amp;oacute;n en la que est&amp;aacute;bamos cuando se encontr&amp;oacute; el &amp;uacute;ltimo &lt;code&gt;(&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">También podemos usar una variable para almacenar una referencia a la estructura de datos que está siendo bendecida como nuestro objeto:</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">Tambi&amp;eacute;n podemos usar el operador de transliteraci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . En este ejemplo, el lado de la lista de b&amp;uacute;squeda de nuestro &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; no contiene nada, pero la opci&amp;oacute;n &lt;code&gt;c&lt;/code&gt; complementa eso, por lo que contiene todo. La lista de reemplazo tampoco contiene nada, por lo que la transliteraci&amp;oacute;n es casi una operaci&amp;oacute;n no operativa ya que no har&amp;aacute; ning&amp;uacute;n reemplazo (o m&amp;aacute;s exactamente, reemplazar&amp;aacute; el car&amp;aacute;cter por s&amp;iacute; mismo). Sin embargo, la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; aplasta los caracteres duplicados y consecutivos en la cadena para que un car&amp;aacute;cter no aparezca junto a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="0bc5ebb55ff053059629cd57779115c15a2ccce5" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;tr///&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;tr///&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;s&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5deb5cdcf6e21e86d4cfa078a33ffd7c085ef4" translate="yes" xml:space="preserve">
          <source>We can ask autodie to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbd56817858a9e2d4db427c7f1f11d2cf2d4b00" translate="yes" xml:space="preserve">
          <source>We can combine the last 3 lines of the above like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">Podemos lidiar con esto usando tanto una afirmación como una negación.Diremos que la primera parte en 1 dólar debe ser seguida tanto por un dígito como por algo que no sea &quot;123&quot;.Recuerde que las miradas son expresiones de ancho cero...sólo miran,pero no consumen ninguna de las cuerdas de su correspondencia.Así que reescribir de esta manera produce lo que se esperaría;es decir,el caso 5 fallará,pero el caso 6 tendrá éxito:</target>
        </trans-unit>
        <trans-unit id="337b65de98d527cb6d5b86fba92bc577466c5413" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in &lt;code&gt;$1&lt;/code&gt; must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">Podemos ampliar el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">Tambi&amp;eacute;n podemos manipular a &lt;code&gt;@_&lt;/code&gt; de otras formas:</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">Podemos hacer coincidir diferentes cadenas de caracteres con el metacar&amp;aacute;cter de &lt;b&gt;alternancia &lt;/b&gt; &lt;code&gt;'|'&lt;/code&gt; . Para que coincida con &lt;code&gt;dog&lt;/code&gt; o &lt;code&gt;cat&lt;/code&gt; , formamos la expresi&amp;oacute;n regular &lt;code&gt;dog|cat&lt;/code&gt; . Como antes, Perl intentar&amp;aacute; hacer coincidir la expresi&amp;oacute;n regular en el punto m&amp;aacute;s temprano posible de la cadena. En cada posici&amp;oacute;n de personaje, Perl primero intentar&amp;aacute; hacer coincidir la primera alternativa, &lt;code&gt;dog&lt;/code&gt; . Si el &lt;code&gt;dog&lt;/code&gt; no coincide, Perl probar&amp;aacute; la siguiente alternativa, &lt;code&gt;cat&lt;/code&gt; . Si &lt;code&gt;cat&lt;/code&gt; tampoco coincide, la coincidencia falla y Perl pasa a la siguiente posici&amp;oacute;n en la cadena. Algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="d6a0febb21ee098abccab9c8a03b765fef08617d" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt;. To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt;, we form the regex &lt;code&gt;dog|cat&lt;/code&gt;. As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt;. If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt;. If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">Podemos modificar el principio 3 anterior para tener en cuenta los cuantificadores no grasos:</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">Ahora podemos usar &lt;code&gt;Perl_sv_dump&lt;/code&gt; para investigar el SV:</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">Podemos anular el m&amp;eacute;todo de un padre en una clase secundaria. Cuando lo hacemos, a&amp;uacute;n podemos llamar al m&amp;eacute;todo de la clase padre con la &lt;code&gt;SUPER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">Podemos poner otro punto de ruptura en cualquier línea que empiece por un colon,usaremos la línea 17 ya que es justo cuando salimos de la subrutina,y nos gustaría hacer una pausa allí más tarde:</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">Podemos poner eso en un archivo de prueba que podemos ejecutar para verificar qu&amp;eacute; enfoque es el m&amp;aacute;s r&amp;aacute;pido, usando una variable &lt;code&gt;$STR&lt;/code&gt; global para asignar a la variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; para evitar que Perl intente optimizar el trabajo al notar que es asignado solo una vez.</target>
        </trans-unit>
        <trans-unit id="3216d8a5e6dc84b8bbaa513843a9c89d95b551dc" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;my $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">Podemos reducir algunos de los bucles a través de las rebanadas</target>
        </trans-unit>
        <trans-unit id="e5d25f7f85d18366ec3d6895017e423d452f3199" translate="yes" xml:space="preserve">
          <source>We can see on line 4 that our token type is &lt;code&gt;ASSIGNOP&lt;/code&gt; (&lt;code&gt;OPERATOR&lt;/code&gt; is a macro, defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1ace8b9cc4168efa6505ff7ef438700e9bd607" translate="yes" xml:space="preserve">
          <source>We cannot predict how long the database ping will take so we use Test::More's like() test to check that the diagnostic string is of the right form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a62faa91fec217313353690ec40805d724e81" translate="yes" xml:space="preserve">
          <source>We check for duplicate entries in the typemap, but do not check for missing &lt;code&gt;TYPEMAP&lt;/code&gt; entries for &lt;code&gt;INPUTMAP&lt;/code&gt; or &lt;code&gt;OUTPUTMAP&lt;/code&gt; entries since these might be hidden in a different typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">Sin embargo, podr&amp;iacute;amos ser m&amp;aacute;s elegantes en el bloque &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . En lugar de comparar las claves, podemos calcular un valor con ellas y usar ese valor como comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1bcc7cd7b768900689b6b050ac1c7aac10dad46e" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;sort()&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">Podr&amp;iacute;amos tener ambas clases heredadas de un padre com&amp;uacute;n, como &lt;code&gt;Machine&lt;/code&gt; , pero no todas las m&amp;aacute;quinas tienen interruptores de encendido / apagado. Podr&amp;iacute;amos crear una clase padre llamada &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , pero eso es muy artificial. Las radios y las computadoras no son especializaciones de este padre. Este padre es realmente una creaci&amp;oacute;n bastante rid&amp;iacute;cula.</target>
        </trans-unit>
        <trans-unit id="859c345eb5fe4bc62f73981c70642999b8e4b03c" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt;, but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt;, but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">Tambi&amp;eacute;n podr&amp;iacute;amos haber utilizado una plantilla de desempaquetado &lt;code&gt;'b12'&lt;/code&gt; , ya que los &amp;uacute;ltimos 4 bits pueden ignorarse de todos modos.</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">Hacemos esto usando la directiva PPCODE:, en lugar de la directiva CODE :. Esto le dice a &lt;b&gt;xsubpp&lt;/b&gt; que administraremos los valores de retorno que pondremos nosotros mismos en la pila de argumentos.</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">No tenemos mucha experiencia en esto todavía,pero intenta lo siguiente:</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">No tenemos que codificar los patrones en el operador de coincidencia (o cualquier otra cosa que funcione con expresiones regulares).Podemos poner el patrón en una variable para su uso posterior.</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">Animamos a usar esto en lugar de llamar directamente a la imprenta.</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">Animamos a los vendedores a enviar la última versión respaldada de Perl en el momento de su congelación de código.</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">Le recomendamos que juegue y eval&amp;uacute;e &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt; y &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt; para ver qu&amp;eacute; sistema OO es el adecuado para usted.</target>
        </trans-unit>
        <trans-unit id="f6dd2243ed823c9d407fa450eaf7b53699b60af0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;, &lt;a href=&quot;Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">Arreglamos nuestra cita: 'tom' =&amp;gt; q (y jerry), y lo ejecutamos nuevamente, esta vez obtenemos nuestro resultado esperado:</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">Ya hemos introducido el operador de coincidencia en su predeterminado &lt;code&gt;/regexp/&lt;/code&gt; y el delimitador arbitrario &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; formas. Hemos utilizado el operador de enlace &lt;code&gt;=~&lt;/code&gt; y su negaci&amp;oacute;n &lt;code&gt;!~&lt;/code&gt; Para probar las coincidencias de cadenas. Asociado con el operador de coincidencia, hemos discutido los modificadores &lt;code&gt;//s&lt;/code&gt; de l&amp;iacute;nea &amp;uacute;nica , &lt;code&gt;//m&lt;/code&gt; de l&amp;iacute;nea m&amp;uacute;ltiple , &lt;code&gt;//i&lt;/code&gt; que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas y &lt;code&gt;//x&lt;/code&gt; extendido . Hay algunas cosas m&amp;aacute;s que quiz&amp;aacute;s desee saber sobre los operadores de coincidencia.</target>
        </trans-unit>
        <trans-unit id="4ec0698febe8baf604343239295eca801edc1950" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;m!regexp!&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;/s&lt;/code&gt;, multi-line &lt;code&gt;/m&lt;/code&gt;, case-insensitive &lt;code&gt;/i&lt;/code&gt; and extended &lt;code&gt;/x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">No tenemos ningún nroff en el BS2000 POSIX (aún),así que ignoramos cualquier error al instalar la documentación.</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">Tenemos que usar una secci&amp;oacute;n &lt;code&gt;CODE&lt;/code&gt; porque &lt;code&gt;PerlIO_puts()&lt;/code&gt; tiene los argumentos invertidos en comparaci&amp;oacute;n con &lt;code&gt;fputs()&lt;/code&gt; , y queremos mantener los mismos argumentos.</target>
        </trans-unit>
        <trans-unit id="094b6bf4440df57d740fc419f243cfd8a6cfc13d" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt;, and we want to keep the arguments the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">Hemos intentado que Perl conozca las especificaciones de los archivos de estilo VMS y Unix siempre que sea posible.Puedes usar cualquiera de los estilos,o ambos,en la línea de comandos y en los scripts,pero no puedes combinar los dos estilos dentro de una sola especificación de archivo.VMS Perl interpreta los nombres de ruta de Unix de manera muy similar a la del CRTL (</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">Desalentamos mucho este método.Sólo debe usarse si sabes lo que haces y necesitas específicamente el comportamiento PREFIX.El algoritmo de PREFIX es complicado y está enfocado a coincidir con la instalación del sistema.</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">Recomendamos encarecidamente el método install_base,es el más simple y el que más se aproxima al comportamiento esperado de un prefijo de instalación.</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">Esperamos que estas notas le eviten la confusión y la pérdida de sueño al escribir los guiones de Perl en el VMS.Si encuentra que nos hemos perdido algo que cree que debería aparecer aquí,por favor no dude en escribirnos a vmsperl@perl.org.</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">Implementamos nuestro propio patrón de estilo global que se ajusta a las reglas.Aquí están los patrones soportados:</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">Implementamos nuestro propio patrón de coincidencia de estilo global.Aquí están los patrones que soporta:</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">Sabemos que obtendremos &lt;code&gt;6&lt;/code&gt; de esto, as&amp;iacute; que terminemos la subrutina:</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">Vimos este fragmento de c&amp;oacute;digo antes, y dijimos que &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arregla para que dos &lt;code&gt;NV&lt;/code&gt; se coloquen en la &lt;code&gt;left&lt;/code&gt; y la &lt;code&gt;right&lt;/code&gt; ; expand&amp;aacute;moslo ligeramente:</target>
        </trans-unit>
        <trans-unit id="5ca3334b72be201a6a79c8d27231d9f82fb916a8" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt;s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">Mantenemos la incompatibilidad binaria.</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">Manipulamos varias matrices en este XSUB. Tenga en cuenta que una matriz se representa internamente mediante un puntero AV *. Las funciones y macros para manipular matrices son similares a las funciones en Perl: &lt;code&gt;av_top_index&lt;/code&gt; devuelve el &amp;iacute;ndice m&amp;aacute;s alto en un AV *, muy parecido a $ # matriz; &lt;code&gt;av_fetch&lt;/code&gt; obtiene un &amp;uacute;nico valor escalar de una matriz, dado su &amp;iacute;ndice; &lt;code&gt;av_push&lt;/code&gt; empuja un valor escalar al final de la matriz, extendiendo autom&amp;aacute;ticamente la matriz seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">Podemos cambiarlo para que las cosas que siguen siendo usos legales en las clases de caracteres entre corchetes normales se vuelvan ilegales dentro de esta construcci&amp;oacute;n experimental. Una propuesta, por ejemplo, es prohibir usos adyacentes del mismo car&amp;aacute;cter, como en &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . La motivaci&amp;oacute;n para tal cambio es que este uso es probablemente un error tipogr&amp;aacute;fico, ya que la segunda &quot;a&quot; no agrega nada.</target>
        </trans-unit>
        <trans-unit id="6f8e2edefd5e426a509917090b4bcf0d615987a3" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt;. The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">Mencionamos antes que la mayoría de los objetos Perl se implementan como hachas bajo el capó.El principio de encapsulación nos dice que no debemos confiar en esto.En su lugar,debemos utilizar métodos de acceso para acceder a los datos en ese hash.Los sistemas de objetos que recomendamos más abajo automatizan la generación de métodos de acceso.Si se utiliza uno de ellos,nunca se debería tener que acceder al objeto como un hash directamente.</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">Anteriormente mencionamos la herencia m&amp;uacute;ltiple. El principal problema de la herencia m&amp;uacute;ltiple es que complica enormemente la resoluci&amp;oacute;n del m&amp;eacute;todo. Consulte &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">Debemos saber cuánto leer.</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">Ahora compilamos Perl,y lo pasamos por la sala de pruebas.Nuestras nuevas pruebas pasan,¡hurra!</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">Ahora sabemos cómo crear opciones entre las clases de personajes en un regexp.¿Qué hay de las opciones entre las palabras o las cadenas de caracteres? Tales elecciones se describen en la siguiente sección.</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">A menudo nos referimos a las relaciones de herencia como relaciones &lt;b&gt;padre-hijo&lt;/b&gt; o de &lt;code&gt;superclass/subclass&lt;/code&gt; . A veces decimos que el ni&amp;ntilde;o tiene una relaci&amp;oacute;n &lt;b&gt;is-a&lt;/b&gt; con su clase padre.</target>
        </trans-unit>
        <trans-unit id="99514bb04979cf0a47e2cf2b143ea1390fb7e139" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass&lt;/code&gt;/&lt;code&gt;subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">Reconocemos que el núcleo de Perl,definido como el software distribuido con el corazón del propio Perl,es un proyecto conjunto de todos nosotros.De vez en cuando,un guión,un módulo o un conjunto de módulos (en adelante denominados simplemente &quot;módulo&quot;)resultará tan ampliamente útil y/o tan integral para el correcto funcionamiento del propio Perl que debería ser distribuido con el núcleo de Perl.Esto no debe hacerse nunca sin el consentimiento explícito del autor,y un reconocimiento claro por todas las partes de que esto significa que el módulo se está distribuyendo bajo los mismos términos que el propio Perl.El autor de un módulo debe darse cuenta de que la inclusión de un módulo en el núcleo de Perl significará necesariamente cierta pérdida de control sobre él,ya que en ocasiones puede ser necesario introducir cambios con poca antelación o para mantener la coherencia con el resto de Perl.</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">Recomendamos InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">Recomendamos ptar del Archivo::Tar no mayor de 1.66 con la opción '-C'.</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">Le recomendamos que evite esta sintaxis,por varias razones.</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">Es recomendable que s&amp;oacute;lo el acceso a trav&amp;eacute;s de los atributos &lt;b&gt;de descriptor de acceso&lt;/b&gt; m&amp;eacute;todos. Estos son m&amp;eacute;todos que pueden obtener o establecer el valor de cada atributo. Vimos esto anteriormente en el ejemplo &lt;code&gt;print_info()&lt;/code&gt; , que llama a &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c3f8a0812714182851aed9fbbd140faf18d7041" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">Le recomendamos que utilice este m&amp;eacute;todo para acceder a la versi&amp;oacute;n de otro paquete, en lugar de mirar directamente &lt;code&gt;$Package::VERSION&lt;/code&gt; . El paquete que est&amp;aacute; viendo podr&amp;iacute;a haber anulado el m&amp;eacute;todo &lt;code&gt;VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6418d5ecc21157f156342ad6f603ad1e78f241b1" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt;. The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">Dijimos que las referencias surgen como necesarias si no están definidas,pero no dijimos qué sucede si un valor utilizado como referencia ya está definido,pero</target>
        </trans-unit>
        <trans-unit id="66792931fda90822c58a9263a870978d6e867c09" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;'\'&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;']'&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;'$'&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;'\'&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">Vimos en la secci&amp;oacute;n anterior que hab&amp;iacute;a caracteres ordinarios, que se representaban a s&amp;iacute; mismos, y caracteres especiales, que necesitaban una barra invertida &lt;code&gt;\&lt;/code&gt; para representarse a s&amp;iacute; mismos. Lo mismo ocurre en una clase de caracteres, pero los conjuntos de caracteres ordinarios y especiales dentro de una clase de caracteres son diferentes a los que est&amp;aacute;n fuera de una clase de caracteres. Los caracteres especiales para una clase de caracteres son &lt;code&gt;-]\^$&lt;/code&gt; (y el delimitador de patr&amp;oacute;n, cualquiera que sea). &lt;code&gt;]&lt;/code&gt; es especial porque denota el final de una clase de caracteres. &lt;code&gt;$&lt;/code&gt; es especial porque denota una variable escalar. &lt;code&gt;\&lt;/code&gt; es especial porque se usa en secuencias de escape, como arriba. As&amp;iacute; es como se manejan los caracteres especiales &lt;code&gt;]$\&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">Vimos que la norma de &lt;code&gt;z&lt;/code&gt; se anot&amp;oacute; &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; y se defini&amp;oacute; como la distancia al origen, tambi&amp;eacute;n conocida como:</target>
        </trans-unit>
        <trans-unit id="e2c4be4000d0f7dd961c043239fc9f3b3b2b02bf" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;abs(z)&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">A continuaci&amp;oacute;n, mostramos la forma &quot;poner&quot; de los descriptores de acceso (es decir, la sintaxis que utiliza para configurar el descriptor de acceso en un valor espec&amp;iacute;fico). Pero tambi&amp;eacute;n puede llamar a cada m&amp;eacute;todo sin par&amp;aacute;metros para obtener su valor actual. Por ejemplo, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; devuelve el valor actual del atributo content_file.</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">Especificamos un puerto local en el argumento &lt;code&gt;LocalPort&lt;/code&gt; , lo que no hicimos para el cliente. Este es el nombre del servicio o el n&amp;uacute;mero de puerto para el que desea ser el servidor. (En Unix, los puertos por debajo de 1024 est&amp;aacute;n restringidos al superusuario). En nuestro ejemplo, usaremos el puerto 9000, pero puede usar cualquier puerto que no est&amp;eacute; actualmente en uso en su sistema. Si intenta utilizar uno que ya est&amp;aacute; en uso, obtendr&amp;aacute; un mensaje de &quot;Direcci&amp;oacute;n ya en uso&quot;. En Unix, el comando &lt;code&gt;netstat -a&lt;/code&gt; mostrar&amp;aacute; qu&amp;eacute; servicios tienen servidores actualmente.</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">Todav&amp;iacute;a tenemos algunos errores durante la &lt;code&gt;make test&lt;/code&gt; . Algunos de ellos son el resultado del uso de bisontes. Impresiones de bisontes</target>
        </trans-unit>
        <trans-unit id="caf05cb06344b1573e32848467a1dff2088a1df3" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt;. Some of them are the result of using bison. Bison prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">¡¡Todavía usamos el yacc normal para a2p.y sin embargo!! Hicimos un enlace suave llamado byacc para distinguir entre las dos versiones:</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">Le recomendamos encarecidamente que use git si es posible.Hará tu vida más fácil,y la nuestra también.</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">Le recomendamos encarecidamente que utilice uno de estos sistemas.Incluso el más mínimo de ellos elimina una gran cantidad de repeticiones.Realmente no hay una buena razón para escribir sus clases desde cero en Perl.</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">Tendemos a evitar este t&amp;eacute;rmino porque significa muchas cosas. Puede significar una l&amp;iacute;nea de comandos &lt;b&gt;interruptor&lt;/b&gt; que lleva ning&amp;uacute;n argumento en s&amp;iacute; (por ejemplo, de Perl &lt;code&gt;&amp;ndash;n&lt;/code&gt; y &lt;code&gt;&amp;ndash;p&lt;/code&gt; banderas) o, menos frecuentemente, un indicador de un bit (como los &lt;code&gt;O_CREAT&lt;/code&gt; y &lt;code&gt;O_EXCL&lt;/code&gt; banderas utilizadas en &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ). A veces se usa informalmente para referirse a ciertos modificadores de expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="4d3626274dd1f26da66510777516b4ddde9437ec" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;sysopen&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">Entonces hacemos (siempre es una buena idea)un chequeo de sintaxis antes de intentar ejecutarlo de nuevo:</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">Usamos el t&amp;eacute;rmino &quot;casi&quot;, porque &lt;code&gt;:not_characters&lt;/code&gt; tambi&amp;eacute;n activa la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; 'unicode_strings' dentro de su alcance. Esta forma es menos &amp;uacute;til en v5.20 y posteriores, y se describe completamente en &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode y UTF-8&lt;/a&gt; , pero brevemente, le dice a Perl que no use las partes de caracteres de la definici&amp;oacute;n de configuraci&amp;oacute;n regional, es &lt;code&gt;LC_COLLATE&lt;/code&gt; categor&amp;iacute;as &lt;code&gt;LC_CTYPE&lt;/code&gt; y LC_COLLATE . En su lugar, utilizar&amp;aacute; el juego de caracteres nativo (ampliado por Unicode). Al usar este par&amp;aacute;metro, usted es responsable de traducir el juego de caracteres externos al nativo / Unicode (que ya ser&amp;aacute; si es una de las configuraciones regionales UTF-8 cada vez m&amp;aacute;s populares). Hay formas convenientes de hacer esto, como se describe en &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode y UTF-8&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ff19ea46c35bfebd3ad06b673f58043424fd7951" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">Usamos la versión 1.2.4,que pudo ser instalada fuera de la caja con un fallo durante el &quot;make check&quot;.</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">Queremos ser capaces de atrapar al</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">Queremos asegurarnos de que el Perl siga creciendo y floreciendo en los próximos años y décadas,pero no a expensas de nuestra comunidad de usuarios.</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">Queríamos una lista de contexto,así que se usó G_ARRAY.</target>
        </trans-unit>
        <trans-unit id="8da0820534457147c458ba35d650b1d2014dcd98" translate="yes" xml:space="preserve">
          <source>We will accept 1.00 and 1.75 but not 0.50 or 2.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">Llamaremos al script de prueba a trav&amp;eacute;s del comando &quot; &lt;code&gt;make test&lt;/code&gt; &quot;. Deber&amp;iacute;a ver una salida que se parece a esto:</target>
        </trans-unit>
        <trans-unit id="bed8e3523336143bfae3d838324a0aad3e70112e" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt;&quot;. You should see output that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">No proporcionaremos actualizaciones de seguridad o correcciones de errores para las versiones de desarrollo de Perl.</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">Ahora crearemos los principales archivos de alto nivel de Mytest2.Cambie al directorio sobre Mytest2 y ejecute el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">A todos nos encantaría deshacer algunos errores que hemos cometido en las últimas décadas.Vivir con cada error de diseño que hemos hecho puede llevarnos a un doloroso estancamiento.Desenvolver nuestros errores es muy,muy difícil.Hacerlo sin dañar activamente a nuestros usuarios es casi imposible.</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">Volveremos a este problema de la ciudad-campo más tarde,después de que hayamos visto alguna sintaxis para el manejo de las referencias.</target>
        </trans-unit>
        <trans-unit id="25d0051932de21aa64fc90927fc210fd1faca62f" translate="yes" xml:space="preserve">
          <source>We'll get to testing the contents of lists later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">Llegaremos al significado de esas variables de aspecto perlista dentro de un rato.</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">Tendremos otro puntero de cuerda ahí:</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">Primero miraremos la salida.Suponiendo que ya tenemos esta estructura,¿cómo la imprimimos?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">Veremos un ejemplo m&amp;aacute;s complicado de esto cuando consideremos las macros de Perl a continuaci&amp;oacute;n. &lt;code&gt;POPn&lt;/code&gt; le da el NV (valor de punto flotante) del SV superior en la pila: el &lt;code&gt;$x&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; . Luego calculamos el coseno y enviamos el resultado como un NV. La &lt;code&gt;X&lt;/code&gt; en &lt;code&gt;XPUSHn&lt;/code&gt; significa que la pila debe extenderse si es necesario; no puede ser necesario aqu&amp;iacute;, porque sabemos que hay espacio para un elemento m&amp;aacute;s en la pila, &amp;iexcl;ya que acabamos de eliminar uno! Las macros &lt;code&gt;XPUSH*&lt;/code&gt; garantizan al menos la seguridad.</target>
        </trans-unit>
        <trans-unit id="56f64cd868fbb648df894ffa687bba0fcd06f58c" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;cos($x)&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">Simplemente continuaremos hasta nuestro punto de interrupci&amp;oacute;n preestablecido con una ' &lt;b&gt;c&lt;/b&gt; ':</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">Usaremos &lt;code&gt;gdb&lt;/code&gt; para nuestros ejemplos aqu&amp;iacute;; los principios se aplicar&amp;aacute;n a cualquier depurador (muchos proveedores llaman a su depurador &lt;code&gt;dbx&lt;/code&gt; ), pero consulte el manual del que est&amp;aacute; utilizando.</target>
        </trans-unit>
        <trans-unit id="59bfed3e1550313113be0311ae2b9d42ec0cb5e3" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt;), but check the manual of the one you're using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Usaremos Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">Somos Netware además de ser Windows.</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">Somos Unix y Cygwin.</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">Vamos a agregar dos elementos m&amp;aacute;s a la pila de argumentos: cuando tiene una matriz vinculada, la subrutina &lt;code&gt;PUSH&lt;/code&gt; recibe el objeto y el valor que se va a insertar , y eso es exactamente lo que tenemos aqu&amp;iacute;: el objeto vinculado, recuperado con &lt;code&gt;SvTIED_obj&lt;/code&gt; , y el valor, el SV &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85ee9a622e2cfbf55a87677c4c0c5ab7baea463" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt;, and the value, the SV &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81984db06bb6ffc7cc8657839e60eed19d2e59d4" translate="yes" xml:space="preserve">
          <source>We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases. Does it work before 1970? After 2038? Before 1904? Do years after 10,000 give it trouble? Does it get leap years right? We could keep repeating the code above, or we could set up a little try/expect loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">Vamos a concentrarnos principalmente en los módulos de sólo Perl,en lugar de los módulos XS.Los módulos XS sirven a un propósito bastante diferente,y deberías considerar diferentes cosas antes de distribuirlos-la popularidad de la biblioteca que estás pegando,la portabilidad a otros sistemas operativos,y así sucesivamente.Sin embargo,las notas sobre la preparación del lado Perl del módulo y el empaquetado y distribución del mismo se aplicarán igual de bien a un módulo XS que a uno de Perl puro.</target>
        </trans-unit>
        <trans-unit id="017f7465d1bdb163c7a89743859d67e419fc8784" translate="yes" xml:space="preserve">
          <source>We've added more detail about what we're testing and the ICal string itself we're trying out to the name. So you get results like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">Ya hemos visto c&amp;oacute;mo imprimir en salida est&amp;aacute;ndar usando &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; . Sin embargo, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; tambi&amp;eacute;n puede tomar un primer argumento opcional que especifique en qu&amp;eacute; identificador de archivo imprimir:</target>
        </trans-unit>
        <trans-unit id="a86cb468eaa36ca78f91ded52784d1ac7c3b8af3" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;print()&lt;/code&gt;. However, &lt;code&gt;print()&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">Tambi&amp;eacute;n le hemos contado a Perl sobre la biblioteca que construimos en el subdirectorio mylib. Eso requiri&amp;oacute; solo la adici&amp;oacute;n de la variable &lt;code&gt;MYEXTLIB&lt;/code&gt; a la llamada WriteMakefile y el reemplazo de la subrutina postamble para cd en el subdirectorio y ejecutar make. El Makefile.PL para la biblioteca es un poco m&amp;aacute;s complicado, pero no excesivamente. Nuevamente reemplazamos la subrutina de post&amp;aacute;mbulo para insertar nuestro propio c&amp;oacute;digo. Este c&amp;oacute;digo simplemente especificaba que la biblioteca que se crear&amp;iacute;a aqu&amp;iacute; era una biblioteca de archivos est&amp;aacute;tica (a diferencia de una biblioteca cargable din&amp;aacute;micamente) y proporcion&amp;oacute; los comandos para construirla.</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">Hemos cubierto las partes de trabajo del paquete de hilos de Perl,y con estas herramientas deberías estar bien encaminada para escribir código y paquetes de hilos.Hay algunas pequeñas piezas útiles que no encajaban en ningún otro lugar.</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">Hemos pasado nuestro cheque (donde se imprimió &quot;Todo bien&quot;)y nos hemos detenido justo antes de la carne de nuestra tarea.Podríamos tratar de imprimir un par de variables para ver qué está pasando:</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">Hemos tenido el traductor de h2ph de Larry,que ayudó,pero que sólo funciona con símbolos cpp,no con la C real,que también era muy necesaria.Lo que les ofrezco es una forma simbólica de llegar a todas las estructuras C.Las he formulado en términos de paquetes y funciones.Considere el siguiente programa:</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">Hemos hecho algunos cambios en Makefile.PL.En este caso,hemos especificado una biblioteca extra para ser enlazada a la biblioteca compartida de la extensión,la biblioteca de matemáticas libm en este caso.Hablaremos más tarde de cómo escribir XSUBs que puedan llamar a cada rutina de una biblioteca.</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">Hemos visto c&amp;oacute;mo fomentar las buenas pr&amp;aacute;cticas de codificaci&amp;oacute;n con el &lt;b&gt;uso estricto&lt;/b&gt; y &lt;b&gt;-w&lt;/b&gt; . Podemos ejecutar el depurador Perl &lt;b&gt;perl -d scriptname&lt;/b&gt; para inspeccionar sus datos desde dentro del depurador Perl con el &lt;b&gt;p&lt;/b&gt; y &lt;b&gt;x&lt;/b&gt; comandos. Puede recorrer su c&amp;oacute;digo, establecer puntos de interrupci&amp;oacute;n con &lt;b&gt;by&lt;/b&gt; recorrer ese c&amp;oacute;digo con &lt;b&gt;s&lt;/b&gt; o &lt;b&gt;n&lt;/b&gt; , continuar con &lt;b&gt;cy&lt;/b&gt; regresar de un sub con &lt;b&gt;r&lt;/b&gt; . Cosas bastante intuitivas cuando te pones manos a la obra.</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">Nos hemos esforzado en construir la plantilla para que coincida con el contenido de nuestro b&amp;uacute;fer de tramas. De lo contrario, obtendr&amp;iacute;amos valores indefinidos o &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; no podr&amp;iacute;a descomprimir todo. Si el &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; queda sin elementos, proporcionar&amp;aacute; cadenas nulas (que se convierten en ceros siempre que el c&amp;oacute;digo del paquete lo indique).</target>
        </trans-unit>
        <trans-unit id="f58946de758298d15363eecb7f69802745a7c62d" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;unpack&lt;/code&gt; could not unpack all. If &lt;code&gt;pack&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">Hemos intentado que esto también funcione con la sintaxis TODO:pero no está garantizado y su uso también se desaconseja:</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">Hemos tratado de minimizar la dependencia de los módulos de la biblioteca Perl de la sintaxis de Unix,pero es posible que algunos de ellos,así como algunos scripts escritos para sistemas Unix,requieran que se utilice la sintaxis de Unix,ya que asumirán que '/' es el separador de directorios,</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">Hemos utilizado un trozo de hash para manejar f&amp;aacute;cilmente los campos de cada fila. Almacenar las claves en una matriz hace que sea f&amp;aacute;cil operarlas en grupo o recorrerlas con &lt;code&gt;for&lt;/code&gt; . Tambi&amp;eacute;n evita contaminar el programa con variables globales y utilizar referencias simb&amp;oacute;licas.</target>
        </trans-unit>
        <trans-unit id="bf3e9bec5bbd0148b6e7d79050e64cd6c33fa0da" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt;. It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3244b33262d5fd2e0388c2e8910db847842e8800" translate="yes" xml:space="preserve">
          <source>Weak references are not implemented in the version of perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">Debilitar una referencia: establezca la bandera &lt;code&gt;SvWEAKREF&lt;/code&gt; en este RV; dar la magia SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; referida si a&amp;uacute;n no lo ha hecho; y empujar una referencia inversa a este RV en la serie de referencias inversas asociadas con esa magia. Si el RV es m&amp;aacute;gico, se llamar&amp;aacute; a set magic despu&amp;eacute;s de que se despeje el RV.</target>
        </trans-unit>
        <trans-unit id="1b546f1ca2e1f3276683dab2157d9406b01bfa5c" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on already-weak references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">Los débiles llaman a la magia uvar</target>
        </trans-unit>
        <trans-unit id="d99719368087fdb5886c0da04e1ec7aa5bb1e097" translate="yes" xml:space="preserve">
          <source>Web::Simple</source>
          <target state="translated">Web::Simple</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">Descarta los argumentos que no están apoyados y advierte sobre ellos al usuario</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">Número de la semana</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">Ponderando los Idearios Unificados de CJK</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">Ponderación de JIS KANJI para el Unicode::Compaginar</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">La ponderaci&amp;oacute;n puede variar seg&amp;uacute;n la tabla de elementos de clasificaci&amp;oacute;n. Por lo tanto, aseg&amp;uacute;rese de que los pesos definidos en la &lt;code&gt;entry&lt;/code&gt; sean consistentes con los de la tabla de elementos de clasificaci&amp;oacute;n cargada a trav&amp;eacute;s de la &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782d47b6879e710497644ef8bf508107805123e1" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">Pesos en orden inverso; ex. nivel 2 (orden diacr&amp;iacute;tico) en franc&amp;eacute;s. Si se omite (o &lt;code&gt;$levelNumber&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;\@levelNumbers&lt;/code&gt; es &lt;code&gt;[]&lt;/code&gt; ), se reenv&amp;iacute;a en todos los niveles.</target>
        </trans-unit>
        <trans-unit id="07918c7bf0f5c02def4accb22b2496ee08472e26" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;), forwards at all the levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfee8775f2eb957a8724a08c2efd8dbdd2166cc" translate="yes" xml:space="preserve">
          <source>Well it may seem that way, but it does not. The verify method returns true if the command succeeded. If you pass verify an address which the server would normally have to forward to another machine, the command will succeed with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">Bueno, aparte de un &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , no deber&amp;iacute;as tratarlos especialmente. (El modo bin es necesario porque, de lo contrario, Perl puede convertir los finales de l&amp;iacute;nea en sistemas Win32).</target>
        </trans-unit>
        <trans-unit id="48bbf4d297e0c1ca5f48035948fb4a98aa2511d6" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;binmode $fh&lt;/code&gt;, you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">Bueno,tener varios ejecutables enlazados dinámicamente a la misma enorme biblioteca tiene sus ventajas,pero esto no justificaría el trabajo adicional para hacerla compilar.La razón es la complicada pero muy rápida y conveniente vinculación dinámica &quot;dura&quot; para los usuarios utilizada por OS/2.</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">Bueno, si puede, actualice a la versi&amp;oacute;n m&amp;aacute;s reciente, pero ciertamente &lt;code&gt;5.8.1&lt;/code&gt; o m&amp;aacute;s reciente. El tutorial y las preguntas frecuentes asumen la &amp;uacute;ltima versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">Bueno, tal vez no. De todos modos, cada operaci&amp;oacute;n contiene un puntero de funci&amp;oacute;n, que estipula la funci&amp;oacute;n que realmente llevar&amp;aacute; a cabo la operaci&amp;oacute;n. Esta funci&amp;oacute;n devolver&amp;aacute; la siguiente operaci&amp;oacute;n en la secuencia; esto permite cosas como &lt;code&gt;if&lt;/code&gt; elige la siguiente operaci&amp;oacute;n din&amp;aacute;micamente en tiempo de ejecuci&amp;oacute;n. El &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; se asegura de que cosas como se&amp;ntilde;ales de interrupci&amp;oacute;n de ejecuci&amp;oacute;n si es necesario.</target>
        </trans-unit>
        <trans-unit id="d89d9b138049ae3cace1b14aa62a037a00f5fd6b" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">Bueno, hoy en d&amp;iacute;a la DLL de Perl tambi&amp;eacute;n deber&amp;iacute;a ser utilizable desde un programa compilado de manera diferente ... Si puede ejecutar c&amp;oacute;digo Perl desde scripts REXX (ver &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; ), entonces hay alg&amp;uacute;n otro aspecto de la interacci&amp;oacute;n que el c&amp;oacute;digo hackish actual pasa por alto para apoyar programas principales compilados de manera diferente.</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">Bueno,vale,no del todo como las matrices de C,en realidad.C no sabe cómo hacer crecer sus matrices a pedido.Perl sí sabe.</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">Bueno,eso es</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">Bueno,todo eso está bien si quieres enviar un comando y obtener una respuesta,pero ¿qué hay de la creación de algo totalmente interactivo,algo así como la forma</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">Bueno,eso es porque la regla es que sólo en los paréntesis adyacentes (ya sean cuadrados o rizados),eres libre de omitir la flecha de derivación del puntero.Pero no puedes hacerlo para el primero si es un escalar que contiene una referencia,lo que significa que $ref_to_AoA siempre lo necesita.</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">Bueno, esto no es muy f&amp;aacute;cil de leer, y usando el &amp;uacute;til manual ( &lt;b&gt;hh&lt;/b&gt; ), el comando ' &lt;b&gt;x&lt;/b&gt; ' parece prometedor:</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">Bueno,podrías mantenerlos sincronizados,pero no hay garantía de que siempre se mantenga en las clases que alguien más escribió.Además,hay poco que ganar al hacerlo:un gancho de serialización podría mantener sólo un atributo de un objeto,que probablemente no es lo que debería ocurrir durante una clonación profunda de ese mismo objeto.</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">¿Qué es el Unicode,de todos modos?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; &lt;b&gt;es&lt;/b&gt; Unicode, de todos modos?</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">Lo &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n hace</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">Lo que &lt;code&gt;\n&lt;/code&gt; representa depende del tipo de archivo abierto. Por lo general, representa &lt;code&gt;\012&lt;/code&gt; pero tambi&amp;eacute;n podr&amp;iacute;a ser &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; o nada, seg&amp;uacute;n la organizaci&amp;oacute;n del archivo y el formato de registro. El m&amp;oacute;dulo &lt;code&gt;VMS::Stdio&lt;/code&gt; proporciona acceso a los requisitos &lt;code&gt;fopen()&lt;/code&gt; especiales de archivos con atributos inusuales en VMS.</target>
        </trans-unit>
        <trans-unit id="87fe5c683c90e3c088c772e3615a1786c72c1f86" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, &lt;code&gt;\015\012&lt;/code&gt;, &lt;code&gt;\000&lt;/code&gt;, &lt;code&gt;\040&lt;/code&gt;, or nothing depending on the file organization and record format. The &lt;a href=&quot;VMS::Stdio&quot;&gt;&lt;code&gt;VMS::Stdio&lt;/code&gt;&lt;/a&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">Lo que significa &lt;code&gt;\p{Digit}&lt;/code&gt; (y por lo tanto &lt;code&gt;\d&lt;/code&gt; excepto bajo el modificador &lt;code&gt;/a&lt;/code&gt; ) es &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , o como sin&amp;oacute;nimo, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . A partir de la versi&amp;oacute;n 4.1 de Unicode, este es el mismo conjunto de caracteres que coincide con &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . Pero Unicode tambi&amp;eacute;n tiene una propiedad diferente con un nombre similar, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , que coincide con un conjunto de caracteres completamente diferente. Estos caracteres son cosas como &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; o sub&amp;iacute;ndices, o son de sistemas de escritura que carecen de los diez d&amp;iacute;gitos.</target>
        </trans-unit>
        <trans-unit id="7b5cbb478fdd2453286ebc21496037447f26240f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt;, or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt;. Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt;. But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b14251f22912eca5254f7b79c2a9d632504f9a" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;import&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d8154ba31035b162983151d8a78e2e2dc45b35" translate="yes" xml:space="preserve">
          <source>What Compression Types do IO::Compress::Zip &amp;amp; IO::Uncompress::Unzip support?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">¿Qué es un hilo,de todos modos?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">Lo que no se debe exportar</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">¿En qué hilo estoy?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">¿Qué hilos están corriendo?</target>
        </trans-unit>
        <trans-unit id="39c91a7f2718b3f82718fcf2f41024f714a5a84f" translate="yes" xml:space="preserve">
          <source>What Unix would call a &quot;character special file&quot;, that is, a device that works on character streams such as a printer port or a console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Lo que ves, es lo que tienes. Usualmente se usa cuando algo que aparece en la pantalla coincide con c&amp;oacute;mo se ver&amp;aacute; eventualmente, como las declaraciones de &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; o de Perl . Tambi&amp;eacute;n se usa para significar lo opuesto a magia porque todo funciona exactamente como aparece, como en la forma de tres argumentos de &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed80ac1751c25893f1267129f7e46c8160dfe9c8" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">Qu&amp;eacute; hace un &lt;b&gt;proceso&lt;/b&gt; cuando tiene que esperar algo: &quot;Mi proceso se bloque&amp;oacute; esperando el disco&quot;. Como sustantivo no relacionado, se refiere a una gran cantidad de datos, de un tama&amp;ntilde;o con el que al &lt;b&gt;sistema operativo&lt;/b&gt; le gusta tratar (normalmente una potencia de 2, como 512 u 8192). Por lo general, se refiere a una parte de los datos que provienen o van a un archivo de disco.</target>
        </trans-unit>
        <trans-unit id="2467e6e88d448cacf4a87d364e42c63b7d44c7b4" translate="yes" xml:space="preserve">
          <source>What a Unicode property matches is never subject to locale rules, and if locale rules are not otherwise in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con &lt;code&gt;pp_add&lt;/code&gt; , la funci&amp;oacute;n que examinamos anteriormente para implementar el operador &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f1dc37cecc054d5c9ec7a5642d37fabf7ece164" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt;, the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">¿Qué hay de los datos binarios,como las imágenes?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con el modo de lectura y escritura? Probablemente deber&amp;iacute;a fingir que no existe, porque es poco probable que abrir archivos de texto en modo lectura-escritura haga lo que le gustar&amp;iacute;a. Consulte &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</target>
        </trans-unit>
        <trans-unit id="7033c56c28fec8ae85e45a62981e3d9e75105d87" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use bytes&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1190a2bf44048aa0cb955f799592720f84eed32" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use encoding&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">¿Qué pasa con el uso de bytes pragmáticos?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">¿Qué hay del uso de la codificación pragmática?</target>
        </trans-unit>
        <trans-unit id="9087ece8c32ed3f277ff1480139f31375b459572" translate="yes" xml:space="preserve">
          <source>What about v-strings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; son &lt;code&gt;decode_utf8&lt;/code&gt; y &lt;code&gt;encode_utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eb35e14132d10d4b0ffea38066499e7c90c13f72" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">¿Qué son los Perl 4,Perl 5 o Perl 6?</target>
        </trans-unit>
        <trans-unit id="e6127384bd4c0a0328dc9c0ebe31629d55231702" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; son todos estos signos de puntuaci&amp;oacute;n $ @% &amp;amp; * y c&amp;oacute;mo s&amp;eacute; cu&amp;aacute;ndo usarlos?</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">¿Qué son decode_utf8 y encode_utf8?</target>
        </trans-unit>
        <trans-unit id="29ffaa3b6cfc90d26e4503a77c7175830b80edb8" translate="yes" xml:space="preserve">
          <source>What are hints?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9717f99f8d2c332a1631b34f3cf973229add73" translate="yes" xml:space="preserve">
          <source>What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">¿Qué puedes hacer con una referencia una vez que la tienes? Es un valor escalar,y hemos visto que puedes almacenarlo como un escalar y recuperarlo como cualquier escalar.Sólo hay dos formas más de usarlo:</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">¿Qué codificación de caracteres admite Perl?</target>
        </trans-unit>
        <trans-unit id="b31fdc311186d7b04a093fc56872b567ad32984f" translate="yes" xml:space="preserve">
          <source>What distribution contains a particular module?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7467059fbc01c8f7e5073d6a60b1174890e226" translate="yes" xml:space="preserve">
          <source>What do you do with unsupported filetypes in an archive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es lo que realmente quieres saber? Si simplemente desea saber si uno de sus identificadores de archivo est&amp;aacute; conectado a una terminal, puede probar la prueba de archivo &lt;code&gt;-t&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; crees que ser&amp;aacute; &lt;code&gt;$x&lt;/code&gt; ? La respuesta, lamentablemente, es</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">¿Qué significa &quot;Bareword 'DB_File' no está permitido&quot;?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">¿Qué significa &quot;Argumento Inválido&quot;?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">¿Qué significa &quot;mal intérprete&quot;?</target>
        </trans-unit>
        <trans-unit id="128188e5871787fd7e8d0d232b299acadbde54ca" translate="yes" xml:space="preserve">
          <source>What does &quot;wide character in subroutine entry&quot; mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">¿Qué significa que los regexes son codiciosos? ¿Cómo puedo evitarlo?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; significa esto para las expresiones regulares? Bueno, los usuarios de regexp no necesitan saber mucho sobre la representaci&amp;oacute;n interna de cadenas de Perl. Pero necesitan saber 1) c&amp;oacute;mo representar caracteres Unicode en una expresi&amp;oacute;n regular y 2) que una operaci&amp;oacute;n de coincidencia tratar&amp;aacute; la cadena que se buscar&amp;aacute; como una secuencia de caracteres, no como bytes. La respuesta a 1) es que los caracteres Unicode mayores que &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; se representan usando la notaci&amp;oacute;n &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; , porque \ x hex (sin llaves) no va m&amp;aacute;s all&amp;aacute; de 255. (A partir de Perl 5.14, si eres un fan octal, tambi&amp;eacute;n puedes usar &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="975aae02ca21ed8ec96fd5f4735831339586ec7e" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;chr(255)&lt;/code&gt; are represented using the &lt;code&gt;\x{hex}&lt;/code&gt; notation, because &lt;code&gt;\x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fa5db720a03edc1fcba3370635f4d2d4adabe0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;&quot;PERLIO&quot; in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">Las capas exactas que hay en esta pila predeterminada dependen de muchas cosas: su sistema operativo, versi&amp;oacute;n de Perl, configuraci&amp;oacute;n de tiempo de compilaci&amp;oacute;n de Perl y configuraci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n de Perl. Consulte &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; , &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt; y &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">Lo que sigue son las capacidades más avanzadas,menos utilizadas,o a veces esotéricas de Perl regexps.En la segunda parte,asumiremos que se siente cómodo con lo básico y se concentrará en las características avanzadas.</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">Lo que sigue es una guía detallada de estos pasos.</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">Lo que sigue es una declaración sobre el control artístico,definido como la capacidad de los autores de paquetes para guiar el futuro de su código y mantener el control sobre su trabajo.Es un reconocimiento de que los autores deben tener control sobre su trabajo,y que es responsabilidad del resto de la comunidad de Perl asegurarse de que mantienen este control.Es un intento de documentar los estándares a los que nosotros,como desarrolladores de Perl,pretendemos atenernos.Es un intento de escribir unas directrices generales sobre el respeto que nos debemos unos a otros como desarrolladores de Perl.</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">Lo que sigue está sujeto a cambios RSN.</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">Qu&amp;eacute; formatos se imprimen como formulario de alimentaci&amp;oacute;n. El valor predeterminado es &lt;code&gt;\f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f6f4d84ea57e45f2ca17815f8c029206bd9132" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">Lo que se devuelve depende de varios factores:</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">&amp;iquest;De qu&amp;eacute; sirve &lt;code&gt;\G&lt;/code&gt; en una expresi&amp;oacute;n regular?</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">¿Qué tiene de bueno una expresión regular?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">¿Qué pasa si añado o quito llaves de un hachís mientras iteramos sobre él?</target>
        </trans-unit>
        <trans-unit id="ff08f48f056287d25a3dc5672938a653f78c0ce3" translate="yes" xml:space="preserve">
          <source>What happens is that after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630083c407aaeb1fdb11b2f5b1e425a9f1a5879d" translate="yes" xml:space="preserve">
          <source>What happens when &lt;code&gt;JSON::PP&lt;/code&gt; encounters a Perl object depends on the &lt;code&gt;allow_blessed&lt;/code&gt;, &lt;code&gt;convert_blessed&lt;/code&gt;, &lt;code&gt;allow_tags&lt;/code&gt; and &lt;code&gt;allow_bignum&lt;/code&gt; settings, which are used in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">¿Qué ha pasado?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">¿Qué ha pasado aquí?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">Lo que ha sucedido es que &lt;code&gt;fred&lt;/code&gt; accede a la matriz &lt;code&gt;@_&lt;/code&gt; que pertenece a &lt;code&gt;joe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4495f64a5a5a99cc3a0b71199a99723a37e9ed87" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">¿Y si no lo descifro?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">¿Y si no codifico?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">¿Y si no sé qué codificación se utilizó?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">¿Qué pasa si mi pregunta no se responde en el FAQ?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa si la interfaz proporcionada por la devoluci&amp;oacute;n de llamada de C no contiene un par&amp;aacute;metro que permita el manejo del archivo a la asignaci&amp;oacute;n de subrutinas de Perl? Digamos que en el paquete de E / S asincr&amp;oacute;nico, la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada se pasa solo el par&amp;aacute;metro de &lt;code&gt;buffer&lt;/code&gt; como este</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">Lo que importa</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">¿Qué es &quot;la bandera UTF8&quot;?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">¿Para qué es /o realmente?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">&amp;iquest;Para qu&amp;eacute; es realmente &lt;code&gt;/o&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">¿Qué es el C3?</target>
        </trans-unit>
        <trans-unit id="3f1ecd4984feb033599a0b8b92a1a9741f5b5e8e" translate="yes" xml:space="preserve">
          <source>What is Module::Build and how does it relate to MakeMaker?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">¿Qué es el Perl 6?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">¿Qué es Perl?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">¿Qué es Plack y PSGI?</target>
        </trans-unit>
        <trans-unit id="234e64d864b7e4e19b7d995b815d4db958366917" translate="yes" xml:space="preserve">
          <source>What is Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c878af8c7031f81a5ddca206fc60a5a12f9ad1d" translate="yes" xml:space="preserve">
          <source>What is Unicode, anyway?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">¿Qué es un &quot;personaje amplio&quot;?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es un 'r&amp;eacute;cord'? Por defecto, el significado es el mismo que para el operador &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; : es una cadena terminada en &lt;code&gt;$/&lt;/code&gt; , que probablemente sea &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Excepci&amp;oacute;n menor: en los sistemas DOS y Win32, un 'registro' es una cadena terminada por &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) Puede cambiar la definici&amp;oacute;n de &quot;registro&quot; proporcionando la opci&amp;oacute;n &lt;code&gt;recsep&lt;/code&gt; en la llamada de &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="046dcad9c1b5d6658ae493e5f69f47ba914f7843" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt;, which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;.) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;tie&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">¿Qué es un filtro DBM?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">¿Qué es un JAPH?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">¿Qué es un motor de expresión regular?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es una expresi&amp;oacute;n regular? Una expresi&amp;oacute;n regular es simplemente una cadena que describe un patr&amp;oacute;n. Los patrones son de uso com&amp;uacute;n en estos d&amp;iacute;as; los ejemplos son los patrones escritos en un motor de b&amp;uacute;squeda para encontrar p&amp;aacute;ginas web y los patrones usados ​​para listar archivos en un directorio, por ejemplo, &lt;code&gt;ls *.txt&lt;/code&gt; o &lt;code&gt;dir *.*&lt;/code&gt; . En Perl, los patrones descritos por expresiones regulares se utilizan para buscar cadenas, extraer las partes deseadas de cadenas y para realizar operaciones de b&amp;uacute;squeda y reemplazo.</target>
        </trans-unit>
        <trans-unit id="ad1619062d7422922f56678f7cf58c8d2f19d36b" translate="yes" xml:space="preserve">
          <source>What is a regular expression? At its most basic, a regular expression is a template that is used to determine if a string has certain characteristics. The string is most often some text, such as a line, sentence, web page, or even a whole book, but less commonly it could be some binary data as well. Suppose we want to determine if the text in variable, &lt;code&gt;$var&lt;/code&gt; contains the sequence of characters &lt;code&gt;m u s h r o o m&lt;/code&gt; (blanks added for legibility). We can write in Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">¿Qué es una &quot;IV&quot;?</target>
        </trans-unit>
        <trans-unit id="778b266015494167ffcfb5699798ca074f01e4ed" translate="yes" xml:space="preserve">
          <source>What is libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">Lo que se quiere decir aqu&amp;iacute; no est&amp;aacute; claro, ya que el escape &lt;code&gt;\N{...}&lt;/code&gt; es una secuencia de puntos de c&amp;oacute;digo, por lo que se trata de un error.</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">Lo que es mucho peor,algunas DLLs cambian las banderas de punto flotante cuando en _DLLInitTerm()(por ejemplo,</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">¿Qué es perl.com? ¿Perl Mongers? ¿Pm.org? ¿Perl.org? ¿Cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">¿Qué es socket.ph y dónde lo consigo?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">¿Cuál es la diferencia entre &quot;estado&quot; subs y &quot;mi&quot; subs? Cada vez que la ejecución entra en un bloque cuando se declaran &quot;mis&quot; subs,se crea una nueva copia de cada subs.Las subrutinas &quot;state&quot; persisten de una ejecución del bloque que las contiene a la siguiente.</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">¿Cuál es la diferencia entre $array[1]y @array[1]?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">¿Cuál es la diferencia entre :codificación y :utf8?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre &lt;code&gt;:encoding&lt;/code&gt; y &lt;code&gt;:utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="aa686143aeb2276da66fe372809de6163adbd5d8" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">¿Cuál es la diferencia entre una lista y una matriz?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">&amp;iquest;De qu&amp;eacute; se trata esta declaraci&amp;oacute;n de Perl? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; es una cadena simple entre comillas dobles. &lt;code&gt;World&lt;/code&gt; es la expresi&amp;oacute;n regular y &lt;code&gt;//&lt;/code&gt; que encierra &lt;code&gt;/World/&lt;/code&gt; le dice a Perl que busque una cadena para encontrar una coincidencia. El operador &lt;code&gt;=~&lt;/code&gt; asocia la cadena con la expresi&amp;oacute;n regular coincidente y produce un valor verdadero si la expresi&amp;oacute;n regular coincide, o falso si la expresi&amp;oacute;n regular no coincide. En nuestro caso, &lt;code&gt;World&lt;/code&gt; coincide con la segunda palabra en &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , por lo que la expresi&amp;oacute;n es verdadera. Expresiones como esta son &amp;uacute;tiles en condicionales:</target>
        </trans-unit>
        <trans-unit id="8288a589c4caf7bd2276d185a7bd5fbf595dc73f" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">¿Qué es el suicidio variable y cómo puedo prevenirlo?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">¿Cuál es tu programa de bíper favorito?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">¿Cuál es tu concha favorita?</target>
        </trans-unit>
        <trans-unit id="7a785a8e58c6a9e20c1539582a1a9c97e125374e" translate="yes" xml:space="preserve">
          <source>What kind of stuff is contained in this distribution. Most things on CPAN are &lt;code&gt;module&lt;/code&gt;s (which can also mean a collection of modules), but some things are &lt;code&gt;script&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdeb97ea551b504f3da8bf43202e9fd344363cd" translate="yes" xml:space="preserve">
          <source>What kind of test? Possibilities include, skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">¿Qué tipo de hilos son los hilos de Perl?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">¿Qué biblioteca usar?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">¿Qué máquinas apoyan a Perl? ¿Dónde lo consigo?</target>
        </trans-unit>
        <trans-unit id="f891fe8a2be3f1ffe86b5a80057ef4ca6da1223d" translate="yes" xml:space="preserve">
          <source>What machines support libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">¿Qué listas de correo hay para Perl?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">Lo que hace que un método sea especial es</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">Lo que hace que todo esto sea importante es que el módulo de exportación utiliza el &quot;glob aliasing&quot; como mecanismo de importación/exportación.El hecho de que se pueda o no localizar correctamente una variable que ha sido exportada desde un módulo depende de cómo se haya exportado:</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">¿Qué es lo que hace a un buen parche?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">Lo que hace que este pase sea interesante para los desarrolladores de perl es que se puede realizar alguna optimización en este pase.Esta es la optimización por las llamadas &quot;rutinas de verificación&quot;.La correspondencia entre los nombres de los nodos y las correspondientes rutinas de comprobación se describe en</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">¿Qué módulos y extensiones están disponibles para Perl? ¿Qué es el CPAN?</target>
        </trans-unit>
        <trans-unit id="5eca61ede7bdc9f4a1c178015ba2713ba5ace84a" translate="yes" xml:space="preserve">
          <source>What modules does a particular distribution contain?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">¿Qué módulos enviados con versiones de perl</target>
        </trans-unit>
        <trans-unit id="bbb49ac4107bc251bf787f21f8a88fe7e30321ce" translate="yes" xml:space="preserve">
          <source>What most people need to know (superclasses on top.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01351f5f724ad044096c916ace26f9169184a3" translate="yes" xml:space="preserve">
          <source>What other modules do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">¿Qué regop es lo siguiente?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">Lo que parece una estrategia exitosa es la combinaci&amp;oacute;n de &lt;code&gt;reload cpan&lt;/code&gt; de recarga y los conmutadores de depuraci&amp;oacute;n. Agregue una nueva declaraci&amp;oacute;n de depuraci&amp;oacute;n mientras se ejecuta en el shell y luego emita un &lt;code&gt;reload cpan&lt;/code&gt; y vea los nuevos mensajes de depuraci&amp;oacute;n inmediatamente sin perder el contexto actual.</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">¿Qué debo hacer en un módulo?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">Lo que hizo alg&amp;uacute;n &lt;b&gt;proceso&lt;/b&gt; auxiliar para transformar los datos entrantes en una forma m&amp;aacute;s adecuada para el proceso actual. A menudo se hace con una &lt;b&gt;tuber&amp;iacute;a&lt;/b&gt; entrante . V&amp;eacute;ase tambi&amp;eacute;n &lt;b&gt;C preprocesador&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">Lo que el programa o la función devuelve,si tiene éxito.Esta sección puede omitirse en los programas cuyos códigos de salida precisos no son importantes,siempre que devuelvan 0 en caso de éxito y no cero en caso de fracaso como es habitual.Siempre debe estar presente para las funciones.En el caso de los módulos,puede ser útil resumir aquí los valores de retorno de la interfaz del módulo,o puede ser más útil discutir los valores de retorno por separado en la documentación de cada función o método que el módulo proporciona.</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">Lo que hace es crear una nueva operaci&amp;oacute;n binaria y la alimenta con una serie de variables. Las variables se refieren a los tokens: &lt;code&gt;$1&lt;/code&gt; es el primer token en la entrada, &lt;code&gt;$2&lt;/code&gt; el segundo, y as&amp;iacute; sucesivamente; piense en las referencias inversas de expresiones regulares. &lt;code&gt;$$&lt;/code&gt; es la operaci&amp;oacute;n devuelta de esta reducci&amp;oacute;n. Entonces, llamamos a &lt;code&gt;newBINOP&lt;/code&gt; para crear un nuevo operador binario. El primer par&amp;aacute;metro de &lt;code&gt;newBINOP&lt;/code&gt; , una funci&amp;oacute;n en</target>
        </trans-unit>
        <trans-unit id="b67434e808539a7f62532e0f74741a29eeb423fa" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt;, a function in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">Lo que esto significa es que si usted tiene datos escritos por el Storable 1.x corriendo en perl 5.6.0 o 5.6.1 configurado con enteros de 64 bits en Unix o Linux entonces por defecto este Storable se negará a leerlo,dando el error</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">Lo que esto significa es que, a menos que el modificador &lt;code&gt;/a&lt;/code&gt; est&amp;eacute; en efecto, &lt;code&gt;\d&lt;/code&gt; no solo coincide con los d&amp;iacute;gitos '0' - '9', sino tambi&amp;eacute;n con el &amp;aacute;rabe, el devanagari y los d&amp;iacute;gitos de otros idiomas. Esto puede causar cierta confusi&amp;oacute;n y algunos problemas de seguridad.</target>
        </trans-unit>
        <trans-unit id="024bfa55bc6c90f99bae14081b1ca78d49501b2e" translate="yes" xml:space="preserve">
          <source>What this says is: &lt;code&gt;1..1&lt;/code&gt; &quot;I'm going to run one test.&quot; [1] &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed&quot;. And that's about all magic there is to testing. Your basic unit of testing is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">Qué poner después de &quot;1/crontab&quot; en el URL.Esta opción no está configurada de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">Qué poner después de &quot;Foo%3a%3aBar&quot; en la URL.Esta opción no está establecida por defecto.</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">Qu&amp;eacute; poner antes y despu&amp;eacute;s del t&amp;iacute;tulo en la cabeza. Los valores ya deber&amp;iacute;an tener &amp;amp; -escaped.</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">¿Qué utilidades se envían con las versiones de perl</target>
        </trans-unit>
        <trans-unit id="41d1f562b44341deaff0802951db706e407b9e33" translate="yes" xml:space="preserve">
          <source>What version of Perl you are running?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; hab&amp;iacute;a en este trozo de memoria? &amp;iquest;N&amp;uacute;meros, caracteres o una mezcla de ambos? Suponiendo que estamos en una computadora donde se usa codificaci&amp;oacute;n ASCII (o algo similar): los valores hexadecimales en el rango &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indican una letra may&amp;uacute;scula y &lt;code&gt;0x20&lt;/code&gt; codifica un espacio. As&amp;iacute; que podr&amp;iacute;amos asumir que es un fragmento de texto, que algunos pueden leer como un tabloide; pero otros tendr&amp;aacute;n que hacerse con una tabla ASCII y revivir ese sentimiento de primer grado. Sin preocuparse demasiado por la forma de leer esto, observamos que &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; con el c&amp;oacute;digo de plantilla &lt;code&gt;H&lt;/code&gt; convierte el contenido de una secuencia de bytes en la notaci&amp;oacute;n hexadecimal habitual. Dado que &quot;una secuencia de&quot; es una indicaci&amp;oacute;n bastante vaga de la cantidad, &lt;code&gt;H&lt;/code&gt; se ha definido para convertir solo un d&amp;iacute;gito hexadecimal a menos que vaya seguido de un recuento repetido. Un asterisco para el recuento de repeticiones significa usar lo que quede.</target>
        </trans-unit>
        <trans-unit id="0db88274915aa193b8762de0b1150e4497a2898f" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;unpack&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">Lo que realmente necesitamos hacer es expandir el ancho de los campos. El formato &lt;code&gt;A&lt;/code&gt; rellena los caracteres no existentes con espacios, por lo que podemos usar los espacios adicionales para alinear nuestros campos, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="b18ad647190599dbc6f89a0be950252c58677d5e" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt;, &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt;, &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt;, and &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">Lo que hemos descrito hasta ahora es la forma &amp;uacute;nica de las clases de caracteres &lt;code&gt;\p{...}&lt;/code&gt; . Tambi&amp;eacute;n hay una forma compuesta con la que puede encontrarse. Estos se ven como &lt;code&gt;\p{name=value}&lt;/code&gt; o &lt;code&gt;\p{name:value}&lt;/code&gt; (el signo igual y los dos puntos se pueden usar indistintamente). Estos son m&amp;aacute;s generales que la forma &amp;uacute;nica y, de hecho, la mayor&amp;iacute;a de las formas individuales son solo atajos definidos por Perl para formas compuestas comunes. Por ejemplo, los ejemplos de secuencias de comandos del p&amp;aacute;rrafo anterior podr&amp;iacute;an escribirse de forma equivalente como &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; y &lt;code&gt;\P{script=balinese}&lt;/code&gt; (el caso es irrelevante entre &lt;code&gt;{}&lt;/code&gt; tirantes). Es posible que nunca tenga que usar las formas compuestas, pero a veces es necesario, y su uso puede hacer que su c&amp;oacute;digo sea m&amp;aacute;s f&amp;aacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">Lo que se te dice cuando alguien piensa que debes leer el Manual de Bellas Artes.</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">Lo que puedes hacer es calcular la suma de comprobación MD5 de la representación UTF-8 de tales cadenas.Esto se logra filtrando la cadena a través de la función encode_utf8():</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">Lo que obtienes de tus ancestros, gen&amp;eacute;ticamente o de otra manera. Si eres una &lt;b&gt;clase&lt;/b&gt; , tus antepasados ​​se denominan &lt;b&gt;clases base&lt;/b&gt; y tus descendientes se denominan &lt;b&gt;clases derivadas&lt;/b&gt; . Vea &lt;b&gt;herencia &amp;uacute;nica&lt;/b&gt; y &lt;b&gt;herencia m&amp;uacute;ltiple&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">Lo que obtienes cuando haces &lt;code&gt;Perl++&lt;/code&gt; dos veces. Hacerlo solo una vez te rizar&amp;aacute; el cabello. Tienes que incrementarlo ocho veces para lavar tu cabello con champ&amp;uacute;. Enjabonar, enjuagar, iterar.</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">Lo que probablemente quieras en su lugar es esto:</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">Lo que quieres usar en su lugar es:</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">¿Qué es MakeMaker?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">¿Qué se almacena realmente en un SV?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">¿Qué es un cierre?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">¿Qué es una extensión?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">¿Qué hay en el Plan 9 Perl?</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">¿Qué hay en un nombre?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">¿Qué hay de nuevo aquí?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Lo que no está en el Plan 9 Perl</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es ese &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ? Bueno, los argumentos de una subrutina est&amp;aacute;n disponibles para nosotros como una matriz especial llamada &lt;code&gt;@_&lt;/code&gt; (ver &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n). El argumento predeterminado de la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;@_&lt;/code&gt; . Entonces &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; saca el primer elemento de la lista de argumentos y lo asigna a &lt;code&gt;$logmessage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f547a820f19e246c5a238efacc444f158add7954" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;shift&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;shift&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt;. So &lt;code&gt;my $logmessage = shift;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">¿Cuál es la diferencia entre &quot;borrar&quot; y &quot;indefinir&quot; con hashes?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">¿Cuál es la diferencia entre &quot;perl&quot; y &quot;Perl&quot;?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre &lt;code&gt;UTF-8&lt;/code&gt; y &lt;code&gt;utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="80de415750b641663470a45e8ab912ba377dfdef" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">¿Cuál es la diferencia entre UTF-8 y utf8?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre llamar a una funci&amp;oacute;n como &amp;amp; foo y foo ()?</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">¿Cuál es la diferencia entre las ataduras profundas y las superficiales?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">¿Cuál es la diferencia entre el alcance dinámico y léxico (estático)? ¿Entre local()y mi()?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">¿Cuál es la diferencia entre requerir y usar?</target>
        </trans-unit>
        <trans-unit id="623db2e6cf92d9577f09035416d4d1ab6a554bc6" translate="yes" xml:space="preserve">
          <source>What's the minimum perl version required to run Archive::Tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6475c25e2b2e180b098b671e2a15d671e687b92e" translate="yes" xml:space="preserve">
          <source>What's this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cf3a0e365c639b428e364b59520ed78e55a70c" translate="yes" xml:space="preserve">
          <source>What's wrong the with gettext-using code like this...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">¿Qué hay de malo con *-w*y $^W</target>
        </trans-unit>
        <trans-unit id="0d7b30ea762ee4ef5180cde544a82675165a0f09" translate="yes" xml:space="preserve">
          <source>What's wrong with -w and $^W</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa con &lt;b&gt;-w&lt;/b&gt; y &lt;code&gt;$^W&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">¿Qué hay de malo en citar siempre &quot;$vars&quot;?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">¿Qué hay de malo en usar palos de espalda en un contexto de vacío?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">¿Qué hay de malo en usar grep en un contexto de vacío?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">¿Qué es lo que pasa?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">Cualquiera que sea la referencia a la que se refiera,que puede o no tener un nombre.Los tipos comunes de referencias incluyen escalares,arreglos,hashes y subrutinas.</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">Lo que sea que suceda en el motor RE podr&amp;iacute;a ser mejor discutido en &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; , pero en aras de la continuidad, lo haremos aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="1858f2d67aca21222e3d2c00cfe67bcfdc61e6f3" translate="yes" xml:space="preserve">
          <source>Whatever the distribution configured with on the releaser's machine at release time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">Sea lo que sea lo que quiera hacer con una referencia, &lt;b&gt;Use Rule 1&lt;/b&gt; le indica c&amp;oacute;mo hacerlo. Simplemente escriba el c&amp;oacute;digo Perl que habr&amp;iacute;a escrito para hacer lo mismo en una matriz o hash normal, y luego reemplace la matriz o el nombre de la matriz con &lt;code&gt;{$reference}&lt;/code&gt; . &quot;&amp;iquest;C&amp;oacute;mo hago un bucle sobre una matriz cuando todo lo que tengo es una referencia?&quot; Bueno, para recorrer una matriz, escribir&amp;iacute;as</target>
        </trans-unit>
        <trans-unit id="b5090b0a0f33f56f40ebfa24d96ae2ad1f9f57a8" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt;. &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">Cuando &quot; &lt;code&gt;::&lt;/code&gt; &quot; no est&amp;aacute; en el nombre, se asume &quot; &lt;code&gt;Encode::&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="8cc9e35707e78514053d0fbc759ccaa1c9412305" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt;&quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt;&quot; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">Cuando $data está presente,establece los datos de la instancia a $data y devuelve el objeto mismo.De lo contrario,se devuelven los datos de la instancia actual.</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">Cuando se omite $encoding,se pasa a utf8 si $data ya está en utf8 o &quot;&quot;.(cadena vacía)de lo contrario.</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">Cuando $encoding está presente,establece la codificación de la instancia a $encoding y devuelve el objeto mismo.De lo contrario,se devuelve la codificación de la instancia actual.</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">Cuando se llama $walker,atraviesa las subrutinas suministradas cuando fue creado,y las renderiza usando el estilo actual.Puedes cambiar el estilo después de varias maneras diferentes:</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">Cuando se ejecute 'make clean' o similar,el $(FIRST_MAKEFILE)será respaldado en esta ubicación.</target>
        </trans-unit>
        <trans-unit id="0abdf7ca0a208a27b487c4c9ab6758614a97566c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; had a host option, this host will be used. Without &lt;code&gt;$host&lt;/code&gt; argument, all hosts are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e0d783eb05bd44a60d48045d09e1ab76b77d53" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a194e79d9bd84bd7e1d0517e4cb70b910eba34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (but not &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect, &lt;code&gt;sort LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7a9b507455bc0f46d9bdf6728d0f728b33492c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, when &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; subsequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">Cuando &lt;b&gt;--compat-version&lt;/b&gt; ( &lt;b&gt;-b&lt;/b&gt; ) est&amp;aacute; presente, las pruebas generadas usar&amp;aacute;n &lt;code&gt;Test::More&lt;/code&gt; lugar de &lt;code&gt;Test&lt;/code&gt; , que es el valor predeterminado para las versiones anteriores a 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; agregar&amp;aacute;n m&amp;aacute;s a PREREQ_PM en el &lt;code&gt;Makefile.PL&lt;/code&gt; generado .</target>
        </trans-unit>
        <trans-unit id="0c72e13c5aa4ae0a2cebdd6d17deca3e4c332c7a" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d44d0dc017c71b0f6cb1ffd43c417d3ee2ebe5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;S&quot;&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;&quot;T&quot;&lt;/code&gt; can match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">Cuando &lt;code&gt;$/&lt;/code&gt; se establece en &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , cuando &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; est&amp;aacute; en contexto escalar (es decir, en modo slurp de archivo) y cuando se lee un archivo vac&amp;iacute;o, devuelve &lt;code&gt;''&lt;/code&gt; la primera vez, seguido de &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; posteriormente.</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">Cuando &lt;code&gt;$/&lt;/code&gt; se establece en &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , cuando &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; est&amp;aacute; en contexto escalar (es decir, en modo slurp de archivo) y cuando se lee un archivo vac&amp;iacute;o, devuelve &lt;code&gt;''&lt;/code&gt; la primera vez, seguido de &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; posteriormente.</target>
        </trans-unit>
        <trans-unit id="a000e25ad164b5a4e8e6e794f33b40196ef9e9c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, any existing callback will be removed and &lt;code&gt;decode&lt;/code&gt; will not change the deserialised hash in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cdec40a0b802970de3c22418f7ef1894e05ac3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is specified, it will be called from &lt;code&gt;decode&lt;/code&gt; each time it decodes a JSON object. The only argument is a reference to the newly-created hash. If the code references returns a single scalar (which need not be a reference), this value (or rather a copy of it) is inserted into the deserialised data structure. If it returns an empty list (NOTE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">Cuando &lt;code&gt;$input_filename_or_reference&lt;/code&gt; asigna a varios archivos / b&amp;uacute;feres comprimidos y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; es un solo archivo / b&amp;uacute;fer, despu&amp;eacute;s de la descompresi&amp;oacute;n &lt;code&gt;$output_filename_or_reference&lt;/code&gt; contendr&amp;aacute; una concatenaci&amp;oacute;n de todos los datos sin comprimir de cada uno de los archivos / b&amp;uacute;feres de entrada.</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">Cuando &lt;code&gt;$input_filename_or_reference&lt;/code&gt; asigna a varios archivos / b&amp;uacute;feres y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; es un solo archivo / b&amp;uacute;fer, los archivos de entrada / b&amp;uacute;fer se almacenar&amp;aacute;n en &lt;code&gt;$output_filename_or_reference&lt;/code&gt; como una serie concatenada de flujos de datos comprimidos.</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">Cuando &lt;code&gt;$input_filename_or_reference&lt;/code&gt; asigna a varios archivos / b&amp;uacute;feres y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; es un solo archivo / b&amp;uacute;fer, los archivos de entrada / b&amp;uacute;feres se almacenar&amp;aacute;n en &lt;code&gt;$output_filename_or_reference&lt;/code&gt; como una entrada distinta.</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">Cuando &lt;code&gt;$output_filename_or_reference&lt;/code&gt; es una cadena de fileglob, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; tambi&amp;eacute;n debe ser una cadena de fileglob. Cualquier otra cosa es un error.</target>
        </trans-unit>
        <trans-unit id="d2909a9438238d7274c21eee7293fc99c88b23e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;&lt;code&gt;${^UNICODE}&lt;/code&gt;&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;&lt;code&gt;-C&lt;/code&gt;&quot; in perlrun&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">Cuando &lt;code&gt;${^UNICODE}&lt;/code&gt; (disponible a partir de v5.8.2) existe y no es cero, estas opciones se ignorar&amp;aacute;n por completo. Consulte &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE} en perlvar&lt;/a&gt; y &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C en perlrun&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">Cuando los argumentos del &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; son ejecutados indirectamente por el shell, los resultados y los c&amp;oacute;digos de retorno est&amp;aacute;n sujetos a sus peculiaridades. Consulte &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;STRING&quot; en perlop&lt;/a&gt; y &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (pero no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) est&amp;aacute; en efecto, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; ordena LIST de acuerdo con la locale de clasificaci&amp;oacute;n actual. Ver &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">Cuando se especifica &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; , las banderas dadas se agregan autom&amp;aacute;ticamente a cada expresi&amp;oacute;n regular hasta el final del &amp;aacute;mbito l&amp;eacute;xico.</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; est&amp;aacute; en efecto, perl emite mensajes de depuraci&amp;oacute;n al compilar y usar expresiones regulares. La salida es la misma que se obtiene al ejecutar un &lt;code&gt;-DDEBUGGING&lt;/code&gt; Perl habilitado para -DDEBUGGING con el modificador &lt;b&gt;-Dr&lt;/b&gt; . Puede ser bastante voluminoso dependiendo de la complejidad del partido. El uso de &lt;code&gt;debugcolor&lt;/code&gt; en lugar de &lt;code&gt;debug&lt;/code&gt; habilita una forma de salida que se puede usar para obtener una pantalla colorida en terminales que comprenden las secuencias de colores de termcap. Establezca &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; en una lista separada por comas de propiedades &lt;code&gt;termcap&lt;/code&gt; para usar para resaltar cadenas de encendido / apagado, pre-punto encendido / apagado. Ver &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Depurar expresiones regulares en perldebug&lt;/a&gt; para obtener informaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">Cuando el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; est&amp;aacute; en vigor, una expresi&amp;oacute;n regular puede contener &lt;code&gt;(?{ ... })&lt;/code&gt; aserciones de ancho cero y &lt;code&gt;(??{ ... })&lt;/code&gt; subexpresiones pospuestas que se derivan de la interpolaci&amp;oacute;n de variables, en lugar de aparecer literalmente dentro de la expresi&amp;oacute;n regular. Eso normalmente no est&amp;aacute; permitido, ya que es un riesgo potencial para la seguridad. Tenga en cuenta que este pragma se ignora cuando la expresi&amp;oacute;n regular se obtiene a partir de datos contaminados, es decir, la evaluaci&amp;oacute;n siempre se rechaza con expresiones regulares contaminadas. Vea &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(? {Code}) en perlre&lt;/a&gt; y &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(?? {code}) en perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; est&amp;aacute; en efecto, se aplican comprobaciones m&amp;aacute;s estrictas que de otra manera al compilar patrones de expresiones regulares. Estos pueden causar que se generen m&amp;aacute;s advertencias que de otra manera, y que m&amp;aacute;s cosas sean fatales en lugar de solo advertencias. El prop&amp;oacute;sito de esto es encontrar e informar en tiempo de compilaci&amp;oacute;n algunas cosas, que pueden ser legales, pero tienen una posibilidad razonable de no ser la intenci&amp;oacute;n real del programador. Esto activa autom&amp;aacute;ticamente la categor&amp;iacute;a de advertencias &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; (si a&amp;uacute;n no est&amp;aacute; activada) dentro de su alcance.</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; est&amp;aacute; en efecto, y una cadena contaminada es el objetivo de una expresi&amp;oacute;n regular, las memorias de expresiones regulares (o los valores devueltos por el operador m // en el contexto de la lista) est&amp;aacute;n contaminadas. Esta funci&amp;oacute;n es &amp;uacute;til cuando las operaciones de expresiones regulares en datos contaminados no est&amp;aacute;n destinadas a extraer subcadenas seguras, sino a realizar otras transformaciones.</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">Cuando los argumentos del &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; son ejecutados indirectamente por el shell, los resultados y los c&amp;oacute;digos de retorno est&amp;aacute;n sujetos a sus peculiaridades. Consulte &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;&quot;STRING&quot; en perlop&lt;/a&gt; y &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (pero no &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) est&amp;aacute; en efecto, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; ordena LIST de acuerdo con la locale de clasificaci&amp;oacute;n actual. Ver &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">Cuando se especifica &lt;code&gt;Append&lt;/code&gt; y se establece en true,</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">Cuando no se especifica &lt;code&gt;LimitOutout&lt;/code&gt; &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; utilizar&amp;aacute; tanta memoria como sea necesario para escribir todos los datos sin comprimir que crea descomprimiendo el b&amp;uacute;fer de entrada.</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">Cuando no se especifica &lt;code&gt;LimitOutout&lt;/code&gt; , &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; usar&amp;aacute; tanta memoria como sea necesario para escribir todos los datos descomprimidos que crea descomprimiendo el b&amp;uacute;fer de entrada.</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">Cuando se usa &lt;code&gt;LimitOutput&lt;/code&gt; , el tama&amp;ntilde;o del b&amp;uacute;fer de salida usado ser&amp;aacute; 16k o la cantidad de memoria ya asignada a &lt;code&gt;$output&lt;/code&gt; , lo que sea mayor. Predecir el tama&amp;ntilde;o de salida disponible es complicado, as&amp;iacute; que no conf&amp;iacute;e en obtener un tama&amp;ntilde;o de b&amp;uacute;fer de salida exacto.</target>
        </trans-unit>
        <trans-unit id="378bab7c46fb87434a4a31e87bab949c33fee48d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">Cuando se usa &lt;code&gt;LimitOutput&lt;/code&gt; , el tama&amp;ntilde;o del b&amp;uacute;fer de salida usado ser&amp;aacute; el valor de la opci&amp;oacute;n &lt;code&gt;Bufsize&lt;/code&gt; o la cantidad de memoria ya asignada a &lt;code&gt;$output&lt;/code&gt; , lo que sea mayor. Predecir el tama&amp;ntilde;o de salida disponible es complicado, as&amp;iacute; que no conf&amp;iacute;e en obtener un tama&amp;ntilde;o de b&amp;uacute;fer de salida exacto.</target>
        </trans-unit>
        <trans-unit id="e109cef898586b284816d1d609f442757d09d9a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3a312e83feddf95b646900a17ece38db487898" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3F&quot;&gt;&quot;$?&quot;&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;die&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">Cuando &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; est&amp;aacute; activo (ver &lt;a href=&quot;#%24%3f&quot;&gt;$? A&lt;/a&gt; continuaci&amp;oacute;n), el valor del estado de salida del VMS nativo tendr&amp;aacute; uno de los &lt;code&gt;$!&lt;/code&gt; o &lt;code&gt;$?&lt;/code&gt; o &lt;code&gt;$^E&lt;/code&gt; o el valor 255 de Unix codificado en &amp;eacute;l de manera que el valor original efectivo pueda ser decodificado por otros programas escritos en C, incluyendo Perl y el paquete GNV. De acuerdo con el comportamiento normal no VMS de &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;$!&lt;/code&gt; o &lt;code&gt;$?&lt;/code&gt; son distintos de cero, uno de esos valores se codificar&amp;aacute; en un valor de estado de VMS nativo. Si ambos valores de estado de Unix son 0, y el valor de &lt;code&gt;$^E&lt;/code&gt; se establece en uno de gravedad ERROR o SEVERE_ERROR, entonces &lt;code&gt;$^E&lt;/code&gt; value se utilizar&amp;aacute; como c&amp;oacute;digo de salida tal cual. Si no se aplica nada de lo anterior, el valor Unix de 255 se codificar&amp;aacute; en un valor de estado de salida de VMS nativo.</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">Cuando &lt;code&gt;S&lt;/code&gt; puede coincidir, es mejor que cuando solo &lt;code&gt;T&lt;/code&gt; puede coincidir.</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">Cuando &lt;code&gt;Strict&lt;/code&gt; est&amp;aacute; deshabilitado, se controlar&amp;aacute; el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="db687c97fb2b33423a8768bd320e4711c5ad7257" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Time::Local&lt;/code&gt; was first written, it was a common practice to represent years as a two-digit value like &lt;code&gt;99&lt;/code&gt; for &lt;code&gt;1999&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;2001&lt;/code&gt;. This caused all sorts of problems (google &quot;Y2K problem&quot; if you're very young) and developers eventually realized that this was a terrible idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">Cuando &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22, las ponderaciones de los valores fuera de rango se pueden anular. Aunque la &lt;code&gt;table&lt;/code&gt; o la &lt;code&gt;entry&lt;/code&gt; est&amp;aacute;n disponibles para ellos, los valores fuera de rango son demasiados.</target>
        </trans-unit>
        <trans-unit id="a8376390a3e85be3e6ac52a52161522985c10ab7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allow_bignum&lt;/code&gt; is enabled, big integer values and any numeric values will be converted into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects respectively, without becoming string scalars or losing precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">Cuando la &lt;code&gt;base&lt;/code&gt; intenta &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; un m&amp;oacute;dulo, no morir&amp;aacute; si no puede encontrar el archivo del m&amp;oacute;dulo, pero morir&amp;aacute; por cualquier otro error. Despu&amp;eacute;s de todo esto, si su clase base est&amp;aacute; vac&amp;iacute;a, sin s&amp;iacute;mbolos, la &lt;code&gt;base&lt;/code&gt; morir&amp;aacute;. Esto es &amp;uacute;til para heredar de clases en el mismo archivo que usted, pero donde el nombre del archivo no coincide con el nombre del m&amp;oacute;dulo base, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7e10e7af3fdfd7341808494145f96d758dfe5848" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;require&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801ac03d31183f16ba294ce4fa7c937f1f41d11" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dynamic_config&lt;/code&gt; is true, it is an error to presume that the prerequisites given in distribution metadata will have any relationship whatsoever to the actual prerequisites of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">Cuando &lt;code&gt;follow&lt;/code&gt; o &lt;code&gt;follow_fast&lt;/code&gt; est&amp;aacute;n en vigor, tambi&amp;eacute;n hay un &lt;code&gt;$File::Find::fullname&lt;/code&gt; . La funci&amp;oacute;n puede configurar &lt;code&gt;$File::Find::prune&lt;/code&gt; para podar el &amp;aacute;rbol a menos que se especifique &lt;code&gt;bydepth&lt;/code&gt; . A menos que se especifique &lt;code&gt;follow&lt;/code&gt; o &lt;code&gt;follow_fast&lt;/code&gt; , por razones de compatibilidad (find.pl, find2perl) hay adem&amp;aacute;s los siguientes globales disponibles: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; y &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e21f0f2ae6a786fecac14190bdb286ef45b2801" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt;. The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt;, &lt;code&gt;$File::Find::topdev&lt;/code&gt;, &lt;code&gt;$File::Find::topino&lt;/code&gt;, &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">Cuando se llama a &lt;code&gt;get_handle&lt;/code&gt; con una lista de par&amp;aacute;metros vac&amp;iacute;a, ocurre magia:</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">Cuando &lt;code&gt;remove_tree&lt;/code&gt; regres&amp;oacute; de eliminar archivos en un directorio secundario, una verificaci&amp;oacute;n revel&amp;oacute; que el directorio principal al que regres&amp;oacute; no era desde el que comenz&amp;oacute;. Esto se considera un signo de actividad maliciosa.</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">Cuando se utiliza el recurso &lt;code&gt;share&lt;/code&gt; en matrices, hashes, referencias de matriz o referencias de hash, se perder&amp;aacute;n los datos que contengan.</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;test_test&lt;/code&gt; y la salida que generan sus pruebas no coincide con la que declar&amp;oacute;, &lt;code&gt;test_test&lt;/code&gt; imprimir&amp;aacute; informaci&amp;oacute;n de depuraci&amp;oacute;n que muestra las dos versiones en conflicto. Como esta salida en s&amp;iacute; misma es informaci&amp;oacute;n de depuraci&amp;oacute;n, puede resultar confuso qu&amp;eacute; parte de la salida es de &lt;code&gt;test_test&lt;/code&gt; y cu&amp;aacute;l era la salida original de sus pruebas originales. Adem&amp;aacute;s, puede ser dif&amp;iacute;cil detectar cosas como espacios en blanco extra&amp;ntilde;os al final de las l&amp;iacute;neas que pueden hacer que la prueba falle aunque la salida sea similar.</target>
        </trans-unit>
        <trans-unit id="100cf02e094db7d3754b0f2bd62e72f796e0a652" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; is specified, the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e437612ab773128746c34ed5e2418f0d2432e87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebug&lt;/a&gt; for additional info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdd2a4a70c97e6482142a6afb44a0c24ab7f2c4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;(?{ code })&quot; in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;&quot;(??{ code })&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8ac1a2fdcf9c532880e4f21577de40d0e705a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d597df9736b57e5c279970bfb89c7002422580" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea81caddf6f1e1e3901216d09988417e561f49ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;utf8&lt;/code&gt; is disabled (the default), then &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; generate and expect Unicode strings, that is, characters with high ordinal Unicode values (&amp;gt; 255) will be encoded as such characters, and likewise such characters are decoded as-is, no changes to them will be done, except &quot;(re-)interpreting&quot; them as Unicode codepoints or Unicode characters, respectively (to Perl, these are the same thing in strings unless you do funny/weird/dumb stuff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">Cuando BE o LE se indica explícitamente como el nombre de la codificación,BOM se trata simplemente como un carácter normal (ANCHO CERO SIN ESPACIO DE FRACASO).</target>
        </trans-unit>
        <trans-unit id="68ea7ed2b7146d8c990e48756af545235a644f6f" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">Cuando BE o LE se omite durante la decodificación(),comprueba si el BOM está al principio de la cadena;si se encuentra uno,la endianidad se ajusta a lo que dice el BOM.Si no se encuentra ningún BOM,la rutina muere.</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">Cuando BE o LE se omite durante la codificación(),devuelve una cadena codificada en BE con la lista de materiales preparada.Así que cuando quieras codificar un archivo de texto completo,asegúrate de codificar()todo el texto de una vez,no línea por línea o cada línea,no archivo,tendrá una lista de materiales preparada.</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">Cuando el CPAN se ejecuta,establece la variable de entorno PERL5_CPAN_IS_RUNNING al ID del proceso en ejecución.También establece PERL5_CPANPLUS_IS_RUNNING para prevenir procesos en ejecución que podrían ocurrir con versiones antiguas del Módulo::Install.</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">Cuando CPAN.pm se extiende @INC a través de PERL5LIB,imprime una lista de los directorios añadidos (o un resumen de cuántos directorios se añaden).Elija &quot;v&quot; para obtener este mensaje,&quot;none&quot; para suprimirlo.</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">Cuando CPAN.pm carga un módulo que necesita para alguna característica opcional,normalmente informa sobre el nombre del módulo y la versión.Elija 'v' para obtener este mensaje,'none' para suprimirlo.</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">Cuando CPAN.pm usa el comando tar,¿qué interruptor para la verbosidad se usará? Elija &quot;none&quot; para la operación silenciosa,&quot;v&quot; para el listado de nombres de archivos,&quot;vv&quot; para el listado completo.</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">Cuando Configurar pregunta por las extensiones,sugiero IO y Fcntl,y si quieres manejar la base de datos entonces SDBM_File o GDBM_File (necesitas instalar gdbm para esta).Si quieres usar la extensión POSIX (esta es la predeterminada),asegúrate de que el tamaño de la pila de tu</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">Cuando Dem&amp;oacute;crito le dio la palabra &quot;&amp;aacute;tomo&quot; a los fragmentos indivisibles de materia, se refer&amp;iacute;a literalmente a algo que no se pod&amp;iacute;a cortar:</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">Cuando se usa G_KEEPERR, cualquier error en el c&amp;oacute;digo llamado terminar&amp;aacute; la llamada como de costumbre y el error no se propagar&amp;aacute; m&amp;aacute;s all&amp;aacute; de la llamada (como es habitual para G_EVAL), pero no entrar&amp;aacute; en &lt;code&gt;$@&lt;/code&gt; . En su lugar, el error se convertir&amp;aacute; en una advertencia, con el prefijo &quot;\ t (en limpieza)&quot;. Esto se puede desactivar &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . Si no hay ning&amp;uacute;n error, &lt;code&gt;$@&lt;/code&gt; no se borrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="bd0879b5780d10481d395ff78c94006ad9de4758" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt;. Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;no warnings 'misc'&lt;/code&gt;. If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">Cuando instalo paquetes o múltiples módulos con un solo comando,hay demasiada salida para seguir la pista.</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">Cuando ejecuto el shell de CPAN, &lt;code&gt;/etc/inputrc&lt;/code&gt; un mensaje de error sobre cosas en mi archivo / etc / inputrc (o &lt;code&gt;~/.inputrc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc4c433cebf4d4f4606a91e341dbbd967898b31d" translate="yes" xml:space="preserve">
          <source>When I run my tests TAP::Harness creates a scheduler (TAP::Parser::Scheduler) to work out the running order for the tests, an aggregator (TAP::Parser::Aggregator) to collect and analyse the test results and a formatter (TAP::Formatter::Console) to display those results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712f9e473dcc2ba74a4ec66b73d3e2f5bccede0e" translate="yes" xml:space="preserve">
          <source>When I run prove it processes its arguments, figures out which test scripts to run and then passes control to TAP::Harness to run the tests, parse, analyse and present the results. By subclassing TAP::Harness I can customise many aspects of the test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1064c03f1fc4073f4165a39d84f0e0127c6dd155" translate="yes" xml:space="preserve">
          <source>When I tell prove to save state it writes a file called '.prove' ('_prove' on Windows) in the current directory. It's a YAML document so it's quite easy to write tools of your own that work on the saved test state - but the format isn't officially documented so it might change without (much) warning in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">Cuando intenté ejecutar mi guión,recibí este mensaje.¿Qué significa?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">Cuando se solicita una E/S,por ejemplo &quot;leer&quot;,la solicitud va de Perl primero hacia abajo de la pila usando funciones de &quot;lectura&quot; de cada capa,luego en la parte inferior se solicita la entrada a los servicios del sistema operativo,luego el resultado se devuelve hacia arriba de la pila,siendo finalmente interpretado como datos de Perl.</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Cuando Memoize necesita verificar si una entrada ya est&amp;aacute; en el cach&amp;eacute;, invocar&amp;aacute; &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; es el argumento de la funci&amp;oacute;n normalizada. MyExpirePolicy :: EXISTS deber&amp;iacute;a devolver 0 si la clave no est&amp;aacute; en la cach&amp;eacute;, o si ha expirado, y 1 si hay un valor no expirado en la cach&amp;eacute;. Deber&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="de4b7c34cbf176c69c5c8a01cb2f47a2ef49c9de" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt;. &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">Cuando Perl 5.12 o posterior encuentra una declaraci&amp;oacute;n de puntos suspensivos, la analiza sin error, pero si debe intentar ejecutarla, Perl arroja una excepci&amp;oacute;n con el texto &lt;code&gt;Unimplemented&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b63aa2881910e0e5509ac7fb04463269b672b02" translate="yes" xml:space="preserve">
          <source>When Perl 5.6.0 was released, the decision was made to provide a transformation between the old-style decimal versions and new-style dotted-decimal versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">Cuando Perl compila la expresión regular,trata el paréntesis como el inicio de un encuentro de memoria.Cuando no encuentra el paréntesis de cierre,se queja:</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">Cuando Perl destruya el objeto al que se refiere $netconf enviará el objeto a la función XSUB DESTROY suministrada.Perl no puede determinar,y no le importa,que este objeto sea una estructura C y no un objeto Perl.En este sentido,no hay diferencia entre el objeto creado por el getnetconfigent()XSUB y un objeto creado por una subrutina Perl normal.</target>
        </trans-unit>
        <trans-unit id="954a1b48bf7dbf510303237ceeb967daf1def196" translate="yes" xml:space="preserve">
          <source>When Perl encounters a wildcard subpattern, (see &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;), it suspends compilation of the main pattern, compiles the subpattern, and then matches that against all legal possibilities to determine the actual code points the subpattern matches. After that it adds these to the main pattern, and continues its compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">Cuando Perl intercambia datos con una extensión,ésta debe ser capaz de entender la bandera UTF8 y actuar en consecuencia.Si la extensión no reconoce esa bandera,es probable que la extensión devuelva datos marcados incorrectamente.</target>
        </trans-unit>
        <trans-unit id="4850373be99ff07c49bae45c8a4c6f5b91630080" translate="yes" xml:space="preserve">
          <source>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">Cuando Perl se construye con PERL_IMPLICIT_CONTEXT,las extensiones que llamen a cualquier función en la API de Perl necesitarán pasar el argumento de contexto inicial de alguna manera.El truco es que necesitarás escribirlo de tal manera que la extensión aún compila cuando Perl no ha sido construido con PERL_IMPLICIT_CONTEXT habilitado.</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">Cuando Perl se construye sin las opciones que establecen PERL_IMPLICIT_CONTEXT,no hay un primer argumento que contenga el contexto del intérprete.El subrayado final en la macro pTHX_indica que la expansión de la macro necesita una coma después del argumento de contexto porque le siguen otros argumentos.Si PERL_IMPLICIT_CONTEXT no está definido,pTHX_será ignorado,y la subrutina no está prototipada para tomar el argumento extra.La forma de la macro sin el subrayado de seguimiento se utiliza cuando no hay argumentos explícitos adicionales.</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">Cuando Perl se compila para una plataforma,mira todos estos caracteres para adivinar qué conjunto de caracteres EBCDIC utiliza la plataforma,y se adapta en consecuencia a esa plataforma.Si la plataforma usa un conjunto de caracteres que no es uno de los tres que Perl conoce,Perl o bien fallará en la compilación,o bien elegirá errónea y silenciosamente uno de los tres.</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">Cuando Perl est&amp;aacute; configurado para usar ithreads, usar&amp;aacute; llamadas de biblioteca reentrantes en lugar de versiones no reentrantes. Existe una incompatibilidad en la funci&amp;oacute;n &lt;code&gt;getprotobyname_r&lt;/code&gt; y &lt;code&gt;getservbyname_r&lt;/code&gt; de OpenBSD en las versiones 3.7 y posteriores que provocar&amp;aacute; una SEGV cuando se llame sin hacer un &lt;code&gt;bzero&lt;/code&gt; en sus estructuras de retorno antes de llamar a estas funciones. Los Perl actuales deber&amp;iacute;an manejar este problema correctamente. Perls con subprocesos m&amp;aacute;s antiguos (5.8.6 o anterior) se encontrar&amp;aacute; con este problema. Si desea ejecutar un Perl con subprocesos en OpenBSD 3.7 o superior, deber&amp;aacute; actualizar al menos a Perl 5.8.7.</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">Cuando Perl está procesando &quot;datos binarios&quot;,el programador quiere que Perl procese &quot;secuencias de bytes&quot;.Esto no es un problema para Perl:debido a que un byte tiene 256 valores posibles,encaja fácilmente en el &quot;carácter lógico&quot; mucho más grande de Perl.</target>
        </trans-unit>
        <trans-unit id="317f1e48aa507068045f8759d8c8badef1389fb8" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Cuando Perl se ejecuta en modo de depuraci&amp;oacute;n, con la &lt;b&gt;opci&amp;oacute;n -d&lt;/b&gt; , este GV contiene el SV que contiene el nombre del sub que se est&amp;aacute; depurando. Esta es la variable C que corresponde a la subvariable $ DB :: de Perl. Consulte &lt;code&gt;PL_DBsingle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3d6fd090f13b8b7228c62f6dd0eea36d1d1e84" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">Cuando Perl se ejecuta en modo de depuraci&amp;oacute;n, con el &lt;b&gt;modificador -d&lt;/b&gt; , este SV es un booleano que indica si los subs est&amp;aacute;n siendo de un solo paso. El paso &amp;uacute;nico se activa autom&amp;aacute;ticamente despu&amp;eacute;s de cada paso. Esta es la variable C que corresponde a la variable $ DB :: &amp;uacute;nica de Perl. Consulte &lt;code&gt;PL_DBsub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">Cuando Perl se ejecuta con el interruptor &lt;b&gt;-Do&lt;/b&gt; o su equivalente, la sobrecarga induce mensajes de diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="0c8a95fea35938379cf32ffa88d674c595c3842a" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system with &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; enabled, a wild card directory name of &lt;code&gt;[...]&lt;/code&gt; cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied &quot;.dir;1&quot; removed, and a trailing &lt;code&gt;.&lt;/code&gt; character indicating a null extension will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba82f7be76137263de4d2fc5ab0c4a2f7bd88ccf" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, &lt;code&gt;./.../&lt;/code&gt;, will be converted to &lt;code&gt;[.^.^.^.]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180489f22e9451652052bb264b159682d8729956" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the &lt;code&gt;?&lt;/code&gt; character will be converted to a &lt;code&gt;%&lt;/code&gt; character, if a conversion is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207a022d8cbd197e2ed92d3189e5fa31c10891e3" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, the following &lt;code&gt;DECC$&lt;/code&gt; feature settings will control how the filename is converted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">Cuando Perl busca un método,almacena en caché la búsqueda para que las futuras llamadas al método no tengan que volver a buscarlo.Cambiar la clase padre de una clase o añadir subrutinas a una clase invalidará la caché de esa clase.</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Cuando Perl ve una &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; ; , busca un archivo con el mismo nombre que la extensi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd que tenga un sufijo .pm. Si ese archivo no se puede encontrar, Perl muere con un error fatal. La ruta de b&amp;uacute;squeda predeterminada est&amp;aacute; contenida en la matriz &lt;code&gt;@INC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8000e169764f8e2a593f5f0dac76f4976f5abd8f" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;use extension;&lt;/code&gt;, it searches for a file with the same name as the &lt;code&gt;use&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733cf2ae6a9ab4b9666de0ca99b049c5b762772" translate="yes" xml:space="preserve">
          <source>When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">Cuando Pod::Simple ve un &quot;=head1 Hi there&quot;,por ejemplo,básicamente hace esto:</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">Cuando STDERR est&amp;aacute; vinculado, se llamar&amp;aacute; a su m&amp;eacute;todo PRINT para emitir advertencias y mensajes de error. Esta funci&amp;oacute;n se deshabilita temporalmente durante la llamada, lo que significa que puede usar &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; dentro de PRINT sin iniciar un bucle recursivo. Y al igual que los &lt;code&gt;__WARN__&lt;/code&gt; y &lt;code&gt;__DIE__&lt;/code&gt; , el m&amp;eacute;todo PRINT de STDERR se puede llamar para informar errores del analizador, por lo que se aplican las advertencias mencionadas en &lt;a href=&quot;perlvar#%25SIG&quot;&gt;% SIG en perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22d03f9253db06fc5a737726d6333d6b64f0247b" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;warn()&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">Cuando Storable croa, intenta informar del error a trav&amp;eacute;s de la rutina &lt;code&gt;logcroak()&lt;/code&gt; del paquete &lt;code&gt;Log::Agent&lt;/code&gt; , si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="b63f06de34cfd6fe1d49dc6c54c0e1ae5c2131fc" translate="yes" xml:space="preserve">
          <source>When Storable throws the &quot;Max. recursion depth with nested structures exceeded&quot; error we are already out of stack space. Unfortunately on some earlier perl versions cleaning up a recursive data structure recurses into the free calls, which will lead to stack overflows in the cleanup. This data structure is not properly cleaned up then, it will only be destroyed during global destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dc1e20be879a4646c74d93b6d6dde474c28168" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">Cuando el UTF-8 se convierta en el formato estándar de la fuente,este pragmatismo se convertirá efectivamente en un no-op.Por conveniencia en lo que sigue al término</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">Cuando el Unicode no ocurre</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">Cuando las reglas de Unicode están en vigor:</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">Cuando se concibi&amp;oacute; Unicode por primera vez, se pens&amp;oacute; que todos los caracteres del mundo pod&amp;iacute;an representarse utilizando una palabra de 16 bits; es decir, se &lt;code&gt;0x10000&lt;/code&gt; un m&amp;aacute;ximo de 0x10000 (o 65,536) caracteres, de &lt;code&gt;0x0000&lt;/code&gt; a &lt;code&gt;0xFFFF&lt;/code&gt; . Esto pronto result&amp;oacute; ser incorrecto, y desde Unicode 2.0 (julio de 1996), Unicode se ha definido hasta 21 bits ( &lt;code&gt;0x10FFFF&lt;/code&gt; ) y Unicode 3.1 (marzo de 2001) defini&amp;oacute; los primeros caracteres por encima de &lt;code&gt;0xFFFF&lt;/code&gt; . Los primeros caracteres &lt;code&gt;0x10000&lt;/code&gt; se denominan</target>
        </trans-unit>
        <trans-unit id="235280477a8ab02cc7856eb55d9945ecaf55e478" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt;. This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt;), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt;. The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31ae8f51bc97ba41c3c0ff630526d3a83b94c44" translate="yes" xml:space="preserve">
          <source>When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">Cuando se destruye un &lt;code&gt;SelectSaver&lt;/code&gt; , vuelve a seleccionar el identificador de archivo que se seleccion&amp;oacute; cuando se cre&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">Cuando una declaraci&amp;oacute;n &lt;code&gt;given&lt;/code&gt; tambi&amp;eacute;n es una expresi&amp;oacute;n v&amp;aacute;lida (por ejemplo, cuando es la &amp;uacute;ltima declaraci&amp;oacute;n de un bloque), se eval&amp;uacute;a como:</target>
        </trans-unit>
        <trans-unit id="a06437bb92809b351f6a5100b5739a7e2454e5a6" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (&lt;code&gt;CvSLABBED&lt;/code&gt;), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and &lt;code&gt;CvROOT&lt;/code&gt; attached, it has finished its job, so it can forget the slab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">Cuando un CV tiene un conteo de referencia en su losa (CvSLABBED),es responsable de asegurarse de que se libere.(Por lo tanto,ningún CV debe tener un conteo de referencia en la misma losa.)El CV sólo necesita hacer referencia a la losa durante la compilación.Una vez que es compilado y adjuntado el CvROOT,ha terminado su trabajo,así que puede olvidarse de la losa.</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">Cuando un cambio en la DST hace que un reloj local se salte una hora más adelante,habrá una hora de horas locales que no existen.De nuevo,para la zona horaria de &quot;Europa/París&quot;,el reloj local saltó de 2001-03-25 01:59:59 a 2001-03-25 03:00:00.</target>
        </trans-unit>
        <trans-unit id="711842f215653a7ad792c5b86c0dd5c2fc228aee" translate="yes" xml:space="preserve">
          <source>When a L&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34b3c17b138dcee1edbc75a046c702f3a8b9a07" translate="yes" xml:space="preserve">
          <source>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b5f7b3a10fd426ef30c3ec83c6b8baa679be4" translate="yes" xml:space="preserve">
          <source>When a block is preceded by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, or &lt;code&gt;UNITCHECK&lt;/code&gt;, then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">Cuando un bloque est&amp;aacute; precedido por una palabra clave de fase de compilaci&amp;oacute;n como &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; o &lt;code&gt;UNITCHECK&lt;/code&gt; , el bloque se ejecutar&amp;aacute; solo durante la fase de ejecuci&amp;oacute;n correspondiente. Consulte &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">Cuando una clase tiene varios padres,el orden de búsqueda del método se complica.</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">Cuando una clase hereda de otra clase,cualquier método definido en la clase padre está disponible para la clase hijo.Si intenta llamar a un método en un objeto que no está definido en su propia clase,Perl también buscará ese método en cualquier clase padre que pueda tener.</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">Cuando se da una lista separada por comas de nombres de subrutinas como opciones,Showlex imprime las variables léxicas utilizadas en esas subrutinas.De lo contrario,imprime los léxicos del alcance del archivo.</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">Cuando se usa una constante en una expresi&amp;oacute;n, Perl la reemplaza con su valor en tiempo de compilaci&amp;oacute;n y luego puede optimizar la expresi&amp;oacute;n a&amp;uacute;n m&amp;aacute;s. En particular, cualquier c&amp;oacute;digo en un bloque &lt;code&gt;if (CONSTANT)&lt;/code&gt; se optimizar&amp;aacute; si la constante es falsa.</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">Cuando se conoce el contexto de una parte del árbol de compilación,se propaga a través del árbol.En este momento el contexto puede tener 5 valores (en lugar de 2 para el contexto en tiempo de ejecución):void,boolean,scalar,list,y lvalue.En contraste con el paso 1 este paso se procesa de arriba a abajo:el contexto de un nodo determina el contexto para sus hijos.</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">Cuando una funci&amp;oacute;n principal llama a otra, debe pasar el contexto. Esto normalmente se oculta mediante macros. Considere &lt;code&gt;sv_setiv&lt;/code&gt; . Se expande en algo como esto:</target>
        </trans-unit>
        <trans-unit id="89bb7cb6afe2aeb318bc31219fdbcf9684114fa1" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt;. It expands into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">Cuando se especifica un diccionario</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">Cuando una distribución ya ha sido probada por el CPAN::Reportero en esta máquina,el CPAN puede saltarse la fase de prueba y sólo confiar en el historial del informe de la prueba en su lugar.</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">Cuando se abre un archivo, est&amp;aacute; en modo texto o binario. En el modo de texto, un archivo est&amp;aacute; sujeto a traducciones CR / LF / Ctrl-Z. Con Cygwin, el modo predeterminado para un &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; est&amp;aacute; determinado por el modo de montaje que subyace al archivo. Consulte &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt; (). Perl proporciona una funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; para establecer el modo binario en archivos que de otro modo ser&amp;iacute;an tratados como texto. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; con el indicador &lt;code&gt;O_TEXT&lt;/code&gt; establece el modo de texto en archivos que de otra manera ser&amp;iacute;an tratados como binarios:</target>
        </trans-unit>
        <trans-unit id="77b5bb5939b31598184beb720f013a6b65e23bf1" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;open()&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;&quot;Cygwin::is_binmount&quot;&lt;/a&gt;(). Perl provides a &lt;code&gt;binmode()&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;sysopen()&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">Cuando una manija se abre así,entonces lee obtiene bytes del valor de la cadena de</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">Cuando se maneja una palabra clave, la funci&amp;oacute;n de complemento debe construir un &amp;aacute;rbol de estructuras &lt;code&gt;OP&lt;/code&gt; , que represente el c&amp;oacute;digo que se analiz&amp;oacute;. La ra&amp;iacute;z del &amp;aacute;rbol debe almacenarse en &lt;code&gt;*op_ptr&lt;/code&gt; . Luego, la funci&amp;oacute;n devuelve una constante que indica la funci&amp;oacute;n sint&amp;aacute;ctica de la construcci&amp;oacute;n que ha analizado: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; si es una declaraci&amp;oacute;n completa, o &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; si es una expresi&amp;oacute;n. Tenga en cuenta que una construcci&amp;oacute;n de instrucci&amp;oacute;n no se puede usar dentro de una expresi&amp;oacute;n (excepto a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; y similar), y una expresi&amp;oacute;n no es una declaraci&amp;oacute;n completa (requiere al menos un punto y coma final).</target>
        </trans-unit>
        <trans-unit id="a9174fe1323f2a0785f91a3ab7751748b2c8cde0" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt;. The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;do BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">Cuando se maneja una palabra clave, la funci&amp;oacute;n del complemento tambi&amp;eacute;n puede tener efectos secundarios (en tiempo de compilaci&amp;oacute;n). Puede modificar &lt;code&gt;%^H&lt;/code&gt; , definir funciones, etc. Por lo general, si los efectos secundarios son el objetivo principal de un controlador, no desea generar ninguna operaci&amp;oacute;n para incluirla en la compilaci&amp;oacute;n normal. En este caso, todav&amp;iacute;a es necesario proporcionar un &amp;aacute;rbol de operaciones, pero es suficiente para generar una sola operaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="96150c30b3160f65ac137db96b6444cc4c0b5dee" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt;, define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d37ded835c420c7b9a32e56975a37c7bb1fd7d" translate="yes" xml:space="preserve">
          <source>When a lexical var hasn't yet been introduced, it already exists from the perspective of duplicate declarations, but not for variable lookups, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">Cuando se renderiza una línea,se copia el formato correcto y se escanea para los siguientes elementos;se sustituyen los datos y se realizan otras manipulaciones,como la sangría básica,para cada opcode renderizado.</target>
        </trans-unit>
        <trans-unit id="a843fab343a403fdde443c4b37520ec7d2e838fc" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">Cuando una coincidencia ha fallado, y a menos que otro verbo haya estado involucrado en la falla de la coincidencia y haya proporcionado su propio nombre para usar, la variable &lt;code&gt;$REGERROR&lt;/code&gt; se establecer&amp;aacute; con el nombre de la &amp;uacute;ltima ejecuci&amp;oacute;n ejecutada &lt;code&gt;(*MARK:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e6f28f32721a0addc83e91cf8c10e71bc456ee" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; that was involved in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">Cuando una coincidencia es exitosa, la variable &lt;code&gt;$REGMARK&lt;/code&gt; se configurar&amp;aacute; con el nombre de la &amp;uacute;ltima ejecuci&amp;oacute;n &lt;code&gt;(*MARK:NAME)&lt;/code&gt; que estuvo involucrada en la coincidencia.</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">Cuando un módulo declara otro como un prerrequisito de 'build_requires' esto significa que el otro módulo sólo es necesario para construir o probar el módulo pero no necesita ser instalado permanentemente.En este caso puede que desee instalar ese otro módulo de todas formas o simplemente mantenerlo en el directorio 'build_dir' para tenerlo disponible sólo temporalmente.La instalación ahorra tiempo en futuras instalaciones pero hace que la instalación de perl sea más grande.</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">Cuando se codifica un nuevo idioma, Unicode generalmente elegir&amp;aacute; un &lt;code&gt;block&lt;/code&gt; de puntos de c&amp;oacute;digo consecutivos no asignados para sus caracteres. Hasta ahora, el n&amp;uacute;mero de puntos de c&amp;oacute;digo en estos bloques siempre ha sido uniformemente divisible por 16. Los extras de un bloque, que no se necesitan actualmente, se dejan sin asignar para el crecimiento futuro. Pero ha habido ocasiones en las que una versi&amp;oacute;n posterior necesitaba m&amp;aacute;s puntos de c&amp;oacute;digo que los extras disponibles, y un nuevo bloque ten&amp;iacute;a que asignarse en otro lugar, no contiguo al inicial, para manejar el desbordamiento. Por lo tanto, se hizo evidente desde el principio que &quot;bloque&quot; no era un principio de organizaci&amp;oacute;n adecuado, por lo que se cre&amp;oacute; la propiedad &lt;code&gt;Script&lt;/code&gt; . (M&amp;aacute;s tarde tambi&amp;eacute;n se agreg&amp;oacute; una propiedad de script mejorada, el &lt;code&gt;Script_Extensions&lt;/code&gt; propiedad.) Esos puntos de c&amp;oacute;digo que est&amp;aacute;n en bloques de desbordamiento a&amp;uacute;n pueden tener el mismo script que los originales. El concepto de escritura encaja mejor con el lenguaje natural: hay escritura &lt;code&gt;Latin&lt;/code&gt; , escritura &lt;code&gt;Greek&lt;/code&gt; , etc. y hay varios scripts artificiales, como &lt;code&gt;Common&lt;/code&gt; para caracteres que se utilizan en varios scripts, como s&amp;iacute;mbolos matem&amp;aacute;ticos. Los guiones suelen abarcar partes variadas de varios bloques. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los scripts, consulte &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts en perlunicode.&lt;/a&gt;. La divisi&amp;oacute;n en bloques existe, pero es casi completamente accidental: un artefacto de c&amp;oacute;mo se han asignado y a&amp;uacute;n se asignan los personajes. (Tenga en cuenta que este p&amp;aacute;rrafo ha simplificado demasiado las cosas en aras de que sea una introducci&amp;oacute;n. Unicode realmente no codifica los idiomas, sino los sistemas de escritura para ellos: sus scripts; y muchos idiomas pueden usar un script. Unicode tambi&amp;eacute;n codifica cosas que no se trata realmente de idiomas, como s&amp;iacute;mbolos como &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7bd752f648e1f1f371051489dc3b8a7639c7fc7" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principle, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">Cuando se compila un paquete,una línea como esta</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">Cuando un script de perl asigna un valor a $ 0, el tiempo de ejecuci&amp;oacute;n de perl intentar&amp;aacute; que este valor se muestre como el nombre del programa informado por &quot;ps&quot; actualizando la memoria apuntada por el argv pasado a perl_parse () y tambi&amp;eacute;n llamando a funciones de API como setproctitle () donde est&amp;eacute; disponible. Este comportamiento puede no ser apropiado cuando se incrusta perl y se puede deshabilitar asignando el valor &lt;code&gt;1&lt;/code&gt; a la variable &lt;code&gt;PL_origalen&lt;/code&gt; antes de llamar a perl_parse ().</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">Cuando un regexp puede hacer coincidir una cadena de varias maneras diferentes,podemos utilizar los principios anteriores para predecir de qué manera coincidirá el regexp:</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">Cuando se compila una expresi&amp;oacute;n regular , su campo de &lt;code&gt;engine&lt;/code&gt; se establece para que apunte a la estructura adecuada, de modo que cuando sea necesario, Perl pueda encontrar las rutinas correctas para hacerlo.</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">Cuando una señal es entregada (por ejemplo,SIGINT de un control-C)el sistema operativo entra en operaciones IO como</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">Cuando un espacio y un signo más se dan como banderas a la vez,se utiliza un signo más para prefijar un número positivo.</target>
        </trans-unit>
        <trans-unit id="545ab55cd7ca990a06b2c4cf5e80c654c6ee269f" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, the space is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74001a7284f9d1373e15b508cdd1efa8fda60fc2" translate="yes" xml:space="preserve">
          <source>When a user-defined subroutine is wrapped by &lt;code&gt;autodie&lt;/code&gt;, it will use hints if they are available, and otherwise reverts to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3497a2701b51a3e1bca0e706937a383957b3a809" translate="yes" xml:space="preserve">
          <source>When a value is returned from a thread through a &lt;code&gt;join&lt;/code&gt; operation, the value and everything that it references is copied across to the joining thread, in much the same way that values are copied upon thread creation. This works fine for most kinds of value, including arrays, hashes, and subroutines. The copying recurses through array elements, reference scalars, variables closed over by subroutines, and other kinds of reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">Cuando una variable está ligada,se asocia con el objeto que es el valor de retorno de la función TIESCALAR,TIEARRAY o TIEHASH.Este objeto normalmente tiene una sola referencia,a saber,la referencia implícita de la variable ligada.Cuando se llama untie(),esa referencia se destruye.Entonces,como en el primer ejemplo anterior,se llama al destructor del objeto (DESTROY),lo que es normal para los objetos que no tienen más referencias válidas;y así se cierra el archivo.</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">Cuando se almacena una referencia d&amp;eacute;bil en un &lt;code&gt;SV&lt;/code&gt; que tiene magia &quot;uvar&quot;, se llama a &lt;code&gt;set&lt;/code&gt; magic despu&amp;eacute;s de que la referencia se ha vuelto obsoleta. Este gancho se puede utilizar para desencadenar m&amp;aacute;s actividades de recolecci&amp;oacute;n de basura asociadas con el objeto al que se hace referencia.</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">Cuando todos los analizadores se agoten,se devolverá una lista vacía.</target>
        </trans-unit>
        <trans-unit id="4475cbc9efc3f925a7d535afa9908fb989684e90" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ffe1c99de4f1b7f522c65bdd9eecb591a526c" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9420e774841a86eb3869701949ed03c728fe1309" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; enabled function fails, it generates an &lt;code&gt;autodie::exception&lt;/code&gt; object. This can be interrogated to determine further information about the error that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">Cuando una matriz o un segmento de matriz se interpola en una cadena entre comillas dobles o un contexto similar como &lt;code&gt;/.../&lt;/code&gt; , sus elementos est&amp;aacute;n separados por este valor. El valor predeterminado es un espacio. Por ejemplo, esto:</target>
        </trans-unit>
        <trans-unit id="1cef7d16c561803c2f66d1c8d9b2d86bf2638f56" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt;, its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ada78738410600725bc97a1fe2d577a540f0ef9" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">Cuando una lista de atributos est&amp;aacute; presente en una declaraci&amp;oacute;n, se realiza una verificaci&amp;oacute;n para ver si un controlador 'modificar' de atributo est&amp;aacute; presente en el paquete apropiado (o en su &amp;aacute;rbol de herencia @ISA). De manera similar, cuando se llama a &lt;code&gt;attributes::get&lt;/code&gt; en una referencia v&amp;aacute;lida, se realiza una verificaci&amp;oacute;n para un controlador de atributo apropiado 'fetch'. Consulte &lt;a href=&quot;#EXAMPLES&quot;&gt;EJEMPLOS&lt;/a&gt; para ver c&amp;oacute;mo funciona la determinaci&amp;oacute;n del &quot;paquete apropiado&quot;.</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">Cuando se lee un elemento de &lt;code&gt;%ENV&lt;/code&gt; , las ubicaciones a las que</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">Cuando un elemento de &lt;code&gt;%ENV&lt;/code&gt; se establece en &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , el elemento se busca como si se estuviera leyendo y, si se encuentra, se elimina. (Un elemento &quot;eliminado&quot; de la matriz de entorno &lt;code&gt;environ&lt;/code&gt; se establece en la cadena vac&amp;iacute;a). El uso de &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; para eliminar un elemento de &lt;code&gt;%ENV&lt;/code&gt; tiene un efecto similar, pero despu&amp;eacute;s de eliminar el elemento, se hace otro intento de buscar el elemento, por lo que un nombre l&amp;oacute;gico en modo interno o un nombre en otra ubicaci&amp;oacute;n reemplazar&amp;aacute; el nombre l&amp;oacute;gico que acaba de eliminar. En cualquier caso, solo se modifica el primer valor encontrado al buscar PERL_ENV_TABLES. En la actualidad, no es posible definir un nombre l&amp;oacute;gico de lista de b&amp;uacute;squeda mediante% ENV.</target>
        </trans-unit>
        <trans-unit id="0c072f9ffbeb43d95b6bbc690c50b27ac90e561f" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;delete&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">Cuando un elemento de &lt;code&gt;%ENV&lt;/code&gt; se establece en una cadena definida, la definici&amp;oacute;n correspondiente se realiza en la ubicaci&amp;oacute;n a la que se realiz&amp;oacute; la primera traducci&amp;oacute;n de</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">Cuando una instalaci&amp;oacute;n falla por alg&amp;uacute;n motivo y luego corrijo la condici&amp;oacute;n de error y lo vuelvo a intentar, CPAN.pm se niega a instalar el m&amp;oacute;dulo, diciendo &lt;code&gt;Already tried without success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">Cuando se encuentra una capa indefinida 'foo' en una especificaci&amp;oacute;n de capa &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; , el c&amp;oacute;digo C realiza el equivalente a:</target>
        </trans-unit>
        <trans-unit id="40fb6d5dfd2c6aa613f88a6e49dba73d8dca4cc3" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">Cuando un camino de ascenso como &quot;:::lib::&quot; se pasa como argumento,el número de directorios para subir se maneja correctamente,no quitando los colones de entrada o salida cuando es necesario.Por ejemplo.</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">Cuando en el cuadro existen tanto una letra mayúscula como una minúscula,entonces la letra mayúscula se utiliza típicamente para representar algún tipo de tipo compuesto (una lista o un hash),y la letra minúscula se utiliza para representar un elemento de ese tipo compuesto.Algunos códigos internos utilizan esta relación de casos.Sin embargo,&quot;v&quot; y &quot;V&quot; (vec y v-string)no están relacionados de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">Cuándo y si usar o no las cápsulas pequeñas es algo complicado,y Pod::El hombre no necesariamente lo hace bien.</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">Cuando se aplica a la siguiente línea de comando:</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">Al detectar autom&amp;aacute;ticamente el formato comprimido, intente probar el contenido lzma_alone usando el &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">Cuando detecte autom&amp;aacute;ticamente el formato comprimido, intente probar el contenido sin desinflar (RFC 1951) utilizando el &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2cde96752e55bde69311a35423f2dcc59f8d7b" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, this option can be used to turn on verbosity during the selection process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884ba24d0a86a83e3adb2e1fb93cb3394961f06" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, turn on the use of the external ping via Net::Ping::External. This is recommended in the case the local network has a transparent proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fe69040aadcae108c71d87a32f8d5b0102ff6a" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">Cuando se usan &lt;code&gt;^&lt;/code&gt; y &lt;code&gt;$&lt;/code&gt; al mismo tiempo, la expresi&amp;oacute;n regular tiene que coincidir con el principio y el final de la cadena, es decir, la expresi&amp;oacute;n regular coincide con toda la cadena. Considerar</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">Cuando tanto la A como la P están indefinidas,esto se utiliza como una precisión de reserva al dividir los números.</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">Al compilar m&amp;oacute;dulos de 64 bits, es su responsabilidad asegurarse de que las bibliotecas y los marcos externos vinculados brinden soporte de 64 bits: si no lo hacen, la compilaci&amp;oacute;n del m&amp;oacute;dulo puede parecer exitosa, pero los intentos de usar el m&amp;oacute;dulo dar&amp;aacute;n como resultado un tiempo de ejecuci&amp;oacute;n din&amp;aacute;mico errores de vinculaci&amp;oacute;n y fallos de prueba posteriores. Puede utilizar el &lt;code&gt;file&lt;/code&gt; para descubrir las arquitecturas compatibles con una biblioteca:</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">Cuando se construya Perl,siempre volverá a ser cierto,ya que todavía no se ha instalado nada.</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">Cuando se crea en un volumen ODS-5 con enlaces simb&amp;oacute;licos habilitados, Perl admite enlaces simb&amp;oacute;licos de forma predeterminada cuando el soporte necesario est&amp;aacute; disponible en el sistema de archivos y CRTL (generalmente OpenVMS v8.3 de 64 bits y posterior). Hay una serie de limitaciones y advertencias que debe tener en cuenta al trabajar con enlaces simb&amp;oacute;licos en VMS. En particular, el destino de un enlace simb&amp;oacute;lico v&amp;aacute;lido debe expresarse como una ruta de estilo Unix y debe existir en un volumen visible desde su ra&amp;iacute;z POSIX (consulte el comando &lt;code&gt;SHOW ROOT&lt;/code&gt; en la ayuda de DCL). Para obtener m&amp;aacute;s detalles sobre las capacidades y los requisitos de los enlaces simb&amp;oacute;licos, consulte el cap&amp;iacute;tulo 12 del manual CRTL que se env&amp;iacute;a con OpenVMS v8.3 o posterior.</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">Cuando la agrupación está en efecto,el caso se ignora también en las opciones de un solo carácter.</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">Cuando se calculan tiempos específicos,como en el caso de las pruebas en módulos de tiempo o fecha,puede ser apropiado calcular un desfase para la época.</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">Cuando se llama desde un hilo, esto se comporta como &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (es decir, se ignora el c&amp;oacute;digo de estado de salida).</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">Cuando se le llamó desde el</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">Cuando se llama en un contexto escalar, &lt;code&gt;strtod&lt;/code&gt; devuelve el n&amp;uacute;mero analizado.</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">Cuando se llama en un contexto escalar, &lt;code&gt;strtol&lt;/code&gt; devuelve el n&amp;uacute;mero analizado.</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">Cuando se llama en el contexto de la lista,se devuelve un filehandle al archivo abierto y un nombre de archivo.Esto se logra llamando a mkstemp()después de construir una plantilla adecuada.</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">Cuando se llama en contexto escalar,devuelve el nombre completo (incluyendo la ruta)de un archivo temporal (usa mktemp()).La única comprobación es que el archivo no existe ya,pero no hay garantía de que esa condición continúe aplicándose.</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">Cuando se llama a un hash en el contexto de una lista,devuelve una lista de 2 elementos que consiste en la clave y el valor del siguiente elemento de un hash.En Perl 5.12 y posteriores solamente,también devolverá el índice y el valor para el siguiente elemento de una matriz para que pueda iterar sobre él;los Perls más antiguos consideran que esto es un error de sintaxis.Cuando se llama en contexto escalar,devuelve sólo la clave (no el valor)en un hash,o el índice en una matriz.</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">Cuando se llama con un n&amp;uacute;mero de puerto, el n&amp;uacute;mero de puerto utilizado para hacer ping se establece en $ n&amp;uacute;mero_puerto en lugar de utilizar el puerto de eco. Tambi&amp;eacute;n tiene el efecto de llamar a &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; haciendo que un ping devuelva una respuesta exitosa solo si ese puerto espec&amp;iacute;fico es accesible. Esta funci&amp;oacute;n devuelve el valor del puerto al que se conectar&amp;aacute; &lt;code&gt;ping()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2e5aa5eca539163667dc50950bd9be7faf4a0e" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to &lt;code&gt;$port_number&lt;/code&gt; rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; will connect to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">Cuando se llama con una propiedad que es una extensi&amp;oacute;n de Perl que no se puede expresar en forma compuesta, esta funci&amp;oacute;n actualmente devuelve &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , ya que los &amp;uacute;nicos dos valores posibles son</target>
        </trans-unit>
        <trans-unit id="2e2733df3349090a28007f289ac824ddf07cc93b" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;undef&lt;/code&gt;, as the only two possible values are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">Al llamar a &lt;code&gt;Mksymlists&lt;/code&gt; , siempre se debe especificar el atributo NAME. En la mayor&amp;iacute;a de los casos, esto es todo lo que se necesita. Sin embargo, en el caso de extensiones inusuales, los otros atributos se pueden utilizar para proporcionar informaci&amp;oacute;n adicional al enlazador.</target>
        </trans-unit>
        <trans-unit id="07b982cff05e80c95f9bd4378e83247343baa2a1" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt;, one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af437b4f9240cadad3ac33b8f68ddc8397121022" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;open&lt;/code&gt; with three or more arguments, the second argument -- labeled MODE here -- defines the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">Al elegir un idioma, tambi&amp;eacute;n debe estar influenciado por los &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;recursos&lt;/a&gt; , la &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;cultura de prueba&lt;/a&gt; y la &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;comunidad&lt;/a&gt; que lo rodea.</target>
        </trans-unit>
        <trans-unit id="951b540f9fcad327b03714e446667ac4225ce0b0" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">Al elegir un nuevo salt, cree una cadena aleatoria de dos caracteres cuyos caracteres provengan del conjunto &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (como &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). Este conjunto de caracteres es solo una recomendaci&amp;oacute;n; los caracteres permitidos en la sal dependen &amp;uacute;nicamente de la biblioteca de criptas de su sistema, y ​​Perl no puede restringir lo que acepta la &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; sales () .</target>
        </trans-unit>
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">Al elegir un nuevo salt, cree una cadena aleatoria de dos caracteres cuyos caracteres provengan del conjunto &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (como &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). Este conjunto de caracteres es solo una recomendaci&amp;oacute;n; los caracteres permitidos en la sal dependen &amp;uacute;nicamente de la biblioteca de criptas de su sistema, y ​​Perl no puede restringir lo que acepta la &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; sales () .</target>
        </trans-unit>
        <trans-unit id="e49bb7c565d73664ea0f3cf904e4a0b82673adbe" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt;). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; accepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45013cd9275f891a2dc688887309ce7d0907108" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple assignment to &lt;code&gt;state&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt;) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to &lt;code&gt;state&lt;/code&gt; declarations where the left hand side of the assignment involves any parentheses is currently undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">Cuando se combina con la declaraci&amp;oacute;n de variable, la asignaci&amp;oacute;n escalar simple a &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables de estado (como en el &lt;code&gt;state $x = 42&lt;/code&gt; ) se ejecuta solo la primera vez. Cuando tales declaraciones se eval&amp;uacute;an en ocasiones posteriores, la asignaci&amp;oacute;n se ignora. El comportamiento de este tipo de asignaci&amp;oacute;n a variables no escalares no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">Al comparar &lt;code&gt;$]&lt;/code&gt; , se &lt;b&gt;recomiendan los&lt;/b&gt; operadores de comparaci&amp;oacute;n de cadenas . Las limitaciones inherentes de la representaci&amp;oacute;n de coma flotante binaria a veces pueden conducir a comparaciones incorrectas para algunos n&amp;uacute;meros en algunas arquitecturas.</target>
        </trans-unit>
        <trans-unit id="d63ec10981e83d5b4bca0c38c0d5eae2039c39d3" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt;, numeric comparison operators should be used, but the variable should be stringified first to avoid issues where its original numeric value is inaccurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db1f7efa45a9d6174eb5b40e9d8d8f3e843e34" translate="yes" xml:space="preserve">
          <source>When compiled within the scope of &lt;code&gt;use locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier), this construct assumes that the execution-time locale will be a UTF-8 one, and the generated pattern always uses Unicode rules. What gets matched or not thus isn't dependent on the actual runtime locale, so tainting is not enabled. But a &lt;code&gt;locale&lt;/code&gt; category warning is raised if the runtime locale turns out to not be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">Al compilar Perl en Tru64 puede (dependiendo de la versión del compilador)ver dos advertencias como esta</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">Cuando se compila Perl,se debe usar un compilador ANSI C.AIX no envía por defecto un compilador de C compatible con ANSI con AIX,pero las construcciones binarias de gcc para AIX están ampliamente disponibles.Una versión de gcc también está incluida en la caja de herramientas de AIX que se envía con AIX.</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">Cuando se compila Perl,se debe usar un compilador ANSI C.AIX no envía un compilador C compatible con ANSI con AIX por defecto,pero las construcciones binarias de gcc para AIX están ampliamente disponibles.</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">Al compilar Perl, debe utilizar un compilador ANSI C. El compilador de C que se incluye con todos los sistemas HP-UX es un compilador de K&amp;amp;R que solo debe usarse para construir nuevos n&amp;uacute;cleos.</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">Al compilar en PASE,no hay un comando &quot;oslevel&quot;.Por lo tanto,es posible que desee crear un script llamado &quot;oslevel&quot; que se haga eco del nivel de AIX que su versión de tiempo de ejecución de PASE soporta.Si no está seguro,consulte su documentación o use &quot;4.3.3.0&quot;.</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">Al complementar cadenas, si todos los caracteres tienen valores ordinales por debajo de 256, sus complementos tambi&amp;eacute;n lo tendr&amp;aacute;n. Pero si no es as&amp;iacute;, todos los caracteres estar&amp;aacute;n en complementos de 32 o 64 bits, seg&amp;uacute;n su arquitectura. As&amp;iacute;, por ejemplo, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; es &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; en m&amp;aacute;quinas de 32 bits y &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; en m&amp;aacute;quinas de 64 bits.</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">Cuando se configuran para la agrupación,las opciones de un solo carácter son sensibles a las mayúsculas y minúsculas,mientras que las opciones largas son insensibles a las mayúsculas y minúsculas.Para que las opciones de un solo carácter también coincidan con las mayúsculas y minúsculas,utilice:</target>
        </trans-unit>
        <trans-unit id="0832ec483e29be38d2d70bb452597a0c3e196f7f" translate="yes" xml:space="preserve">
          <source>When converting POD source from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">Al crear y ampliar las interfaces de programación de aplicaciones (API)para Symbian o la serie 60 o la serie 80 o la serie 90,se sugiere que no se utilicen marcas comerciales,marcas registradas o nombres comerciales en los nombres de las API.En su lugar,los desarrolladores deberían considerar la posibilidad de basar la denominación de la API en el componente público y la denominación de la API existentes (C++,o quizás Java),modificados según corresponda por las reglas del lenguaje de programación para el que sirven las nuevas API.</target>
        </trans-unit>
        <trans-unit id="6e1a716be153bacd455cdea13693b585d200816e" translate="yes" xml:space="preserve">
          <source>When data are cleaned and standardized, missing or invalid fields will be replaced with sensible defaults when possible. This may be lossy or imprecise. For example, some badly structured META.yml files on CPAN have prerequisite modules listed as both keys and values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">Cuando se trata de estructuras C, se debe seleccionar &lt;b&gt;T_PTROBJ&lt;/b&gt; o &lt;b&gt;T_PTRREF&lt;/b&gt; para el tipo XS. Ambos tipos est&amp;aacute;n dise&amp;ntilde;ados para manejar punteros a objetos complejos. El tipo T_PTRREF permitir&amp;aacute; que el objeto Perl no sea bendecido mientras que el tipo T_PTROBJ requiere que el objeto sea bendecido. Al usar T_PTROBJ, se puede lograr una forma de verificaci&amp;oacute;n de tipos porque XSUB intentar&amp;aacute; verificar que el objeto Perl es del tipo esperado.</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando trabaje con archivos binarios (o archivos de texto en modo binario) aseg&amp;uacute;rese de establecer expl&amp;iacute;citamente $ / en el valor apropiado para su formato de archivo antes de usar &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2eed87ac3725b6497a344941a7436efeb6e56a3" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; to the appropriate value for your file format before using &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">Al tratar con referencias, es importante manejarlas con precauci&amp;oacute;n. El bloque &lt;code&gt;INIT:&lt;/code&gt; primero llama a SvGETMAGIC (rutas), en caso de que las rutas sean una variable vinculada. Luego, verifica que &lt;code&gt;SvROK&lt;/code&gt; devuelva verdadero, lo que indica que las rutas son una referencia v&amp;aacute;lida. (La simple verificaci&amp;oacute;n de &lt;code&gt;SvROK&lt;/code&gt; no activar&amp;aacute; FETCH en una variable vinculada). Luego verifica que el objeto al que hacen referencia las rutas es una matriz, utilizando &lt;code&gt;SvRV&lt;/code&gt; para eliminar las referencias de las rutas y &lt;code&gt;SvTYPE&lt;/code&gt; para descubrir su tipo. Como prueba adicional, verifica que la matriz a la que hacen referencia las rutas no est&amp;eacute; vac&amp;iacute;a, utilizando el &lt;code&gt;av_top_index&lt;/code&gt; funci&amp;oacute;n (que devuelve -1 si la matriz est&amp;aacute; vac&amp;iacute;a). La macro XSRETURN_UNDEF se usa para abortar el XSUB y devolver el valor indefinido siempre que no se cumplan las tres condiciones.</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">Cuando se trata de cadenas que contienen caracteres que no se pueden representar mediante un conjunto de caracteres de ocho bits, perl utiliza una representaci&amp;oacute;n interna que es una versi&amp;oacute;n permisiva de la codificaci&amp;oacute;n UTF-8 de Unicode [2]. Utiliza bytes individuales para representar caracteres del juego de caracteres ASCII y secuencias de dos o m&amp;aacute;s bytes para todos los dem&amp;aacute;s caracteres. (Consulte &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la relaci&amp;oacute;n entre UTF-8 y la codificaci&amp;oacute;n de perl, utf8. La diferencia no es importante para esta discusi&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">Al depurar un script que usa #! y, por lo tanto, normalmente se encuentra en $ PATH, la opci&amp;oacute;n -S hace que perl busque $ PATH, por lo que no tiene que escribir la ruta o &lt;code&gt;which $scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defb50e120fb7902c1ad7735f710efb52d461bf8" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c091d3205ab1a4db30cd1f652d642a63585b86ed" translate="yes" xml:space="preserve">
          <source>When defined, remove the legacy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd1aac87a1a4ead57eced3127ad85f26b16823a" translate="yes" xml:space="preserve">
          <source>When defining hints, you can either supply both &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; keywords,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">Cuando se definen múltiples constantes,no se pueden utilizar los valores de otras constantes definidas en la misma declaración.Esto se debe a que el paquete de llamada no conoce ninguna constante dentro de ese grupo hasta que</target>
        </trans-unit>
        <trans-unit id="ffb15fb0d6730c3726c9bf86322c62258c95b95a" translate="yes" xml:space="preserve">
          <source>When deleting a definition, this bit causes each &lt;code&gt;$sTargetPath&lt;/code&gt; to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then &lt;code&gt;$sTargetPath&lt;/code&gt; only needs to match a prefix of the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777270f296102b587f7b9de510c0b0ddda1bbd9" translate="yes" xml:space="preserve">
          <source>When describing the merge commit, explain the purpose of the branch, and keep in mind that this description will probably be used by the eventual release engineer when reviewing the next perldelta document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9045da0fde8e0464c72a9687c675b21416ee8e" translate="yes" xml:space="preserve">
          <source>When designing Maketext, I chose to plan its main features in terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">Al dise&amp;ntilde;ar una interfaz entre Perl y una biblioteca C, una traducci&amp;oacute;n directa de C a XS (como la creada por &lt;code&gt;h2xs -x&lt;/code&gt; ) suele ser suficiente. Sin embargo, a veces la interfaz se ver&amp;aacute; muy similar a C y en ocasiones no intuitiva, especialmente cuando la funci&amp;oacute;n C modifica uno de sus par&amp;aacute;metros o devuelve un error en banda (como en &quot;los valores de retorno negativos significan un error&quot;). En los casos en los que el programador desee crear una interfaz m&amp;aacute;s similar a Perl, la siguiente estrategia puede ayudar a identificar las partes m&amp;aacute;s cr&amp;iacute;ticas de la interfaz.</target>
        </trans-unit>
        <trans-unit id="aa2910d5c8edb2a11952d853cabc19faa12f6ab8" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt;) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">Cuando se desarrollan aplicaciones interactivas y/o potencialmente de larga duración,es una buena idea mantener un intérprete persistente en lugar de asignar y construir un nuevo intérprete varias veces.La razón principal es la velocidad:ya que Perl sólo se cargará en la memoria una vez.</target>
        </trans-unit>
        <trans-unit id="fbc30eeb77b449fcef99048d57b0caf5a9160153" translate="yes" xml:space="preserve">
          <source>When do I use SKIP vs. TODO?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">Al hacer la programación en XS/Symbian C++incluye primero las cabeceras Symbian,luego cualquier cabecera estándar de C/POSIX,luego las cabeceras de Perl,y finalmente cualquier cabecera de aplicación.</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">Al descargar de CPAN, guarde su archivo con una extensi&amp;oacute;n &lt;code&gt;.tgz&lt;/code&gt; en lugar de &lt;code&gt;.tar.gz&lt;/code&gt; . Todos los dem&amp;aacute;s puntos del nombre del archivo deben reemplazarse por guiones bajos. Por ejemplo, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; debe descargarse como &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Cuando Perl llama a cada filtro, una copia local de &lt;code&gt;$_&lt;/code&gt; contendr&amp;aacute; la clave o el valor a filtrar. El filtrado se logra modificando el contenido de &lt;code&gt;$_&lt;/code&gt; . Se ignora el c&amp;oacute;digo de retorno del filtro.</target>
        </trans-unit>
        <trans-unit id="37bc6f2fee508f42f859a937c741e1314dc47c4d" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt;. The return code from the filter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">Cuando se cuantifica el código incrustado,las coincidencias exitosas llamarán al código una vez por cada iteración coincidente del cuantificador.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">Cuando se eval&amp;uacute;a, typeglob produce un valor escalar que representa todos los objetos de ese nombre, incluido cualquier identificador de archivo, formato o subrutina. Cuando se asigna a, hace que el nombre mencionado se refiera a cualquier &lt;code&gt;*&lt;/code&gt; valor que se le haya asignado. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">Cuando se llama exec()dentro de un pseudo-proceso entonces los métodos DESTROY y los bloques END seguirán siendo llamados después de que el proceso externo regrese.</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">Cuando la ejecuci&amp;oacute;n del programa llega a una llamada de subrutina, una llamada a &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="e34ca66c0a813d790613eb9e5cc3ba8d52f5c3fa" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">Cuando la ejecuci&amp;oacute;n del programa usa &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; para ingresar una subrutina que no es XS y el bit 0x80 se establece en &lt;code&gt;$^P&lt;/code&gt; , se realiza una llamada a &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; , con &lt;code&gt;$DB::sub&lt;/code&gt; sosteniendo el nombre de la subrutina que se ingresa.</target>
        </trans-unit>
        <trans-unit id="46697cf78f9bb3bd5dc8972ced50ec3e3d6c90ea" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;goto&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt;, a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the subroutine being entered. The call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; does not replace the &lt;code&gt;goto&lt;/code&gt;; the requested subroutine will still be entered once &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; has returned. &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the subroutine being entered, if it has one. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the subroutine being entered. Unlike when &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is called, it is not guaranteed that &lt;code&gt;$DB::sub&lt;/code&gt; can be used as a reference to operate on the subroutine being entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">Cuando el código de salida no es cero,aparece un cuadro de mensaje,de lo contrario la consola se cierra,por lo que es posible que tengas que coger una salida con estado 0 en tu programa para ver cualquier salida.</target>
        </trans-unit>
        <trans-unit id="6f3c5ccbe8b2049e627d85f2a9ec69ec19650c45" translate="yes" xml:space="preserve">
          <source>When false the information is not considered critical and may not be rendered in less-verbose modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">Cuando se utilizan hashes de campo, la estructura b&amp;aacute;sica sigue siendo la misma. Cada hash l&amp;eacute;xico se convertir&amp;aacute; en un hash de campo. La llamada a &lt;code&gt;refaddr&lt;/code&gt; se puede omitir de los m&amp;eacute;todos de acceso. Los m&amp;eacute;todos DESTROY y CLONE no son necesarios.</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">Al encontrar un programa para ejecutar, Perl primero le pide al SO que busque ejecutables en &lt;code&gt;PATH&lt;/code&gt; (OS / 2 agrega la extensi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">Cuando termine, &lt;code&gt;$input&lt;/code&gt; se procesar&amp;aacute; completamente (asumiendo que no hubo errores). Si la deflaci&amp;oacute;n fue exitosa, escribe los datos desinflados en &lt;code&gt;$output&lt;/code&gt; y devuelve un valor de estado &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98115fd081a8900c4523336f3adbeaa8265d8ece" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcfed4a8d779393f6607570b9bb7471da1de1d1" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is actually a flow control statement rather than a function. If there is a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; statement (which is similar to the C &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Cuando le sigue un BLOQUE, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; es en realidad una declaraci&amp;oacute;n de control de flujo en lugar de una funci&amp;oacute;n. Si hay un BLOQUE &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; adjunto a un BLOQUE (generalmente en un &lt;code&gt;while&lt;/code&gt; o &lt;code&gt;foreach&lt;/code&gt; ), siempre se ejecuta justo antes de que el condicional est&amp;eacute; a punto de ser evaluado nuevamente, al igual que la tercera parte de un bucle &lt;code&gt;for&lt;/code&gt; en C. Por lo tanto, puede ser se utiliza para incrementar una variable de ciclo, incluso cuando el ciclo ha continuado mediante la &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; instrucci&amp;oacute;n (que es similar a la instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; de C ).</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Cuando le sigue un BLOQUE, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; es en realidad una declaraci&amp;oacute;n de control de flujo en lugar de una funci&amp;oacute;n. Si hay un BLOQUE &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; adjunto a un BLOQUE (generalmente en un &lt;code&gt;while&lt;/code&gt; o &lt;code&gt;foreach&lt;/code&gt; ), siempre se ejecuta justo antes de que el condicional est&amp;eacute; a punto de ser evaluado nuevamente, al igual que la tercera parte de un bucle &lt;code&gt;for&lt;/code&gt; en C. Por lo tanto, puede ser se utiliza para incrementar una variable de ciclo, incluso cuando el ciclo ha continuado mediante la &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; instrucci&amp;oacute;n (que es similar a la instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; de C ).</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">Cuando las funciones dentro de un archivo fuente XS deben ser separadas en paquetes la palabra clave PAQUETE debe ser usada.Esta palabra clave se utiliza con la palabra clave MÓDULO y debe seguir inmediatamente después de ella cuando se utiliza.</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">Cuando se le da una hora local ambigua,la función timelocal()siempre debe devolver la época para la</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">Cuando maneje los par&amp;aacute;metros de salida con una secci&amp;oacute;n PPCODE, aseg&amp;uacute;rese de manejar correctamente la magia 'set'. Consulte &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; para obtener detalles sobre la magia 'set'.</target>
        </trans-unit>
        <trans-unit id="5bd61549e044c4efead59e04ed6605311709e2f3" translate="yes" xml:space="preserve">
          <source>When in doubt, before you do anything else, check your status and read it carefully, many questions are answered directly by the git status output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">En caso de duda, entre par&amp;eacute;ntesis. Como m&amp;iacute;nimo, permitir&amp;aacute; que un pobre idiota rebote en la tecla% en &lt;b&gt;vi&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">En caso de duda, ejecute la construcci&amp;oacute;n &lt;b&gt;awk a&lt;/b&gt; trav&amp;eacute;s de &lt;b&gt;a2p&lt;/b&gt; y vea qu&amp;eacute; le ofrece.</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">En caso de duda,puedes usar</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">Cuando se invoca como &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; se reconocen las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">Cuando se invoca como &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; se reconocen las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">Cuando se invoca con una sola cadena, &lt;b&gt;parseopts&lt;/b&gt; trata la cadena como el nombre de una opci&amp;oacute;n de an&amp;aacute;lisis y devuelve su valor correspondiente si existe (devuelve &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si no es as&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">Cuando se invoca con varios argumentos, &lt;b&gt;parseopts los&lt;/b&gt; trata como pares clave / valor y los nombres de opciones de an&amp;aacute;lisis especificados se establecen en los valores dados. Las opciones de an&amp;aacute;lisis no especificadas no se ven afectadas.</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">Cuando se invoca sin argumentos adicionales, &lt;b&gt;parseopts&lt;/b&gt; devuelve una tabla hash de todas las opciones de an&amp;aacute;lisis actuales.</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">Cuando se invoca con parámetros,lo siguiente se acepta y es opcional:</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">¿Cuándo no es un &quot;bool&quot; un &quot;bool&quot;?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">Cuando aparece individualmente, hace que las secuencias &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; y las clases de caracteres Posix coincidan solo en el rango ASCII. Por lo tanto, vuelven a sus significados anteriores a 5.6 y anteriores a Unicode. Bajo &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; siempre significa exactamente los d&amp;iacute;gitos &lt;code&gt;&quot;0&quot;&lt;/code&gt; a &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; significa los cinco caracteres &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , y comenzando en Perl v5.18, la pesta&amp;ntilde;a vertical; &lt;code&gt;\w&lt;/code&gt; significa los 63 caracteres &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; e igualmente, todas las clases Posix como &lt;code&gt;[[:print:]]&lt;/code&gt; coinciden solo con los caracteres apropiados del rango ASCII.</target>
        </trans-unit>
        <trans-unit id="1727801b4e8e5e0fc9f27e13c40d768e93c5839d" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt;; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt;, and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e96b083a5b2fe4b1dd3f7bbb3653cb24d7adf0" translate="yes" xml:space="preserve">
          <source>When it comes to altering the behaviour of the test harness there's more than one way to do it. Which way is best depends on my requirements. In general if I only want to observe test execution without changing the harness' behaviour (for example to log test results to a database) I choose callbacks. If I want to make the harness behave differently subclassing gives me more control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">Cuando se trata de equilibrios espacio-temporales,Perl casi siempre prefiere arrojar la memoria a un problema.Las escalas en Perl usan más memoria que las cuerdas en C,los arreglos toman más que eso,y los hashes usan aún más.Aunque todavía queda mucho por hacer,los últimos lanzamientos han abordado estos problemas.Por ejemplo,a partir de 5.004,las claves de hash duplicadas se comparten entre todos los hashes que las usan,así que no requieren reasignación.</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">Cuando se trata de variables no definidas que desencadenar&amp;iacute;an una advertencia en &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; , puede promover la advertencia a un error.</target>
        </trans-unit>
        <trans-unit id="f4053c4973cee39e429495f57f5734c7c3b59da1" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;use warnings&lt;/code&gt;, you can promote the warning to an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">Cuando converge,tienes una variante funcional de</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">Cuando comienza,el depurador lee tu archivo rc (</target>
        </trans-unit>
        <trans-unit id="ab2f1658320564cc0ad685bee8d4cc13fa19d54b" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">Cuando los elementos chocan en un cubo de hash dado, el orden en que se almacenan en la cadena ya no es predecible en Perl 5.18. Esto tiene la intenci&amp;oacute;n de dificultar la observaci&amp;oacute;n de una colisi&amp;oacute;n. Este comportamiento se puede anular utilizando la variable de entorno PERL_PERTURB_KEYS, consulte &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS en perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">Al cargar &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt; , debe &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; antes de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (los &lt;code&gt;threads&lt;/code&gt; emitir&amp;aacute;n una advertencia si lo haces al rev&amp;eacute;s).</target>
        </trans-unit>
        <trans-unit id="ad743799b7c94d4ac0b3c71cf0ab2ce52219a004" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541e2da58c9337557a4530af689d0206150a39ea" translate="yes" xml:space="preserve">
          <source>When local patches are applied with smoke testing, the test driver will automatically request regeneration of certain tables after the patches are applied. The Synology supplied Perl 5.8.6 (at least on the DS413) &lt;b&gt;is NOT capable&lt;/b&gt; of generating these tables. It will generate opcodes with bogus values, causing the build to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">Al buscar &lt;code&gt;DBD::Oracle&lt;/code&gt; relativo a una ruta de b&amp;uacute;squeda, deber&amp;iacute;amos encontrar</target>
        </trans-unit>
        <trans-unit id="e429da2f9f9d1870d8a34d9bf7c8fc15e19b17ad" translate="yes" xml:space="preserve">
          <source>When matching files are extracted, ignore the directory path from the archive and write to the current directory using the basename of the file from the archive. Beware: if two matching files in the archive have the same basename, the second file extracted will overwrite the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeb796371e192f654f19b82f3385e933e7f2600" translate="yes" xml:space="preserve">
          <source>When moving backward it will not move before &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3206ee6854b0880fdd3279a57398bcb52c78786" translate="yes" xml:space="preserve">
          <source>When moving forward it will not move beyond &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">Al nombrar su módulo,considere lo siguiente:</target>
        </trans-unit>
        <trans-unit id="52dec4ed188cfa5b52a02969dbe527c5dc433e3b" translate="yes" xml:space="preserve">
          <source>When no BOM is found, Encode 2.76 and blow croaked. Since Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode Standard version 8.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">Cuando no se especifica un destino para una opci&amp;oacute;n, GetOptions almacenar&amp;aacute; el valor resultante en una variable global llamada &lt;code&gt;opt_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">Cuando no es &lt;code&gt;NULL&lt;/code&gt; , la funci&amp;oacute;n apuntada por esta variable ser&amp;aacute; llamada cada vez que se libere un OP con el correspondiente OP como argumento. Esto permite que las extensiones liberen cualquier atributo adicional que hayan adjuntado localmente a un OP. Tambi&amp;eacute;n est&amp;aacute; seguro de disparar primero para el OP principal y luego para sus hijos.</target>
        </trans-unit>
        <trans-unit id="ff599e171f439dd0c6a6547247e21662b9941e75" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt;, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">Cuando no sea cero,estas opciones harán que el bzip2 utilice un algoritmo de descompresión que utiliza menos memoria a expensas de aumentar la cantidad de tiempo necesario para la descompresión.</target>
        </trans-unit>
        <trans-unit id="0ddf8b539ea05fcfe6aec1dc58d559038d4a8742" translate="yes" xml:space="preserve">
          <source>When not using &lt;code&gt;\o{...}&lt;/code&gt;, you wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. The resolution is as indicated, with all but the last digit treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">Cuando open () recibe una lista expl&amp;iacute;cita de capas (con la sintaxis de tres argumentos), anulan la lista declarada usando este pragma. open () tambi&amp;eacute;n puede tener dos puntos (:) para un nombre de capa, para anular este pragma y usar el predeterminado ( &lt;code&gt;:raw&lt;/code&gt; en Unix &lt;code&gt;:crlf&lt;/code&gt; en Windows).</target>
        </trans-unit>
        <trans-unit id="c34ab00add652f226c09c30c65ec7e49ad76d8a0" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default as detailed in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">Cuando se abre para escribir,las partes vacías del archivo tendrán NULL (0x00)bytes escritos.</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">Al abrir un archivo, rara vez es una buena idea continuar si la solicitud falla, por lo que &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; se usa con frecuencia con &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Incluso si &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; no hace lo que quiere (digamos, en un script CGI, donde quiere formatear un mensaje de error adecuado (pero hay m&amp;oacute;dulos que pueden ayudar con ese problema)) siempre verifique el valor de retorno al abrir un archivo.</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">Al abrir un archivo, rara vez es una buena idea continuar si la solicitud falla, por lo que &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; se usa con frecuencia con &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Incluso si &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; no hace lo que quiere (digamos, en un script CGI, donde quiere formatear un mensaje de error adecuado (pero hay m&amp;oacute;dulos que pueden ayudar con ese problema)) siempre verifique el valor de retorno al abrir un archivo.</target>
        </trans-unit>
        <trans-unit id="162aabd310aabb9968a3811cefafecae90daf2da" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;open&lt;/code&gt; is frequently used with &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. Even if you want your code to do something other than &lt;code&gt;die&lt;/code&gt; on a failed open, you should still always check the return value from opening a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892216513454a34d10fa999d477dbcc5ddbab374" translate="yes" xml:space="preserve">
          <source>When opening a handle, it will be opened with any layers specified explicitly in the open() call (or the platform defaults, if specified as a colon with no following layers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">Cuando se pasa un solo hash-ref, &lt;b&gt;parseopts&lt;/b&gt; usa ese hash para restablecer por completo las opciones de an&amp;aacute;lisis existentes, todos los valores de opciones de an&amp;aacute;lisis anteriores se pierden.</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">Cuando perl comienza a analizar cualquier construcci&amp;oacute;n de bloque que proporcione un alcance l&amp;eacute;xico (por ejemplo, cuerpo de evaluaci&amp;oacute;n, archivo requerido, cuerpo de subrutina, cuerpo de bucle o bloque condicional), el valor existente de &lt;code&gt;$^H&lt;/code&gt; se guarda, pero su valor se deja sin cambios. Cuando se completa la compilaci&amp;oacute;n del bloque, recupera el valor guardado. Entre los puntos donde se guarda su valor y restaurado, c&amp;oacute;digo que se ejecuta dentro de COMIENZAN bloques es libre de cambiar el valor de &lt;code&gt;$^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5f7f62c62b7d34f56ec3574375a08840be5dee" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">Cuando perl ejecuta algo como &lt;code&gt;addop&lt;/code&gt; , &amp;iquest;c&amp;oacute;mo pasa sus resultados a la siguiente operaci&amp;oacute;n? La respuesta es mediante el uso de pilas. Perl tiene una serie de pilas para almacenar cosas en las que est&amp;aacute; trabajando actualmente, y veremos las tres m&amp;aacute;s importantes aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="0ad42676f2cea160c10d6e67d7270b962893b05d" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt;, how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">Cuando perl ejecuta la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , traduce las llamadas &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; en la biblioteca de tiempo de ejecuci&amp;oacute;n de C y, de ah&amp;iacute;, al kernel del sistema operativo. conjuntos de perl &lt;code&gt;$!&lt;/code&gt; al &lt;code&gt;errno&lt;/code&gt; de la biblioteca de C si falla una de estas llamadas.</target>
        </trans-unit>
        <trans-unit id="36c7954ee59f65366eedb8f27e4e9a6ca8de87ae" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;eval()&lt;/code&gt; expression, it translates the &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce54f632d505238352e1c6b81e21cf7c3c75f1" translate="yes" xml:space="preserve">
          <source>When perl is built with debugging enabled, there is a second part to this stack storing human-readable string names describing the type of stack context. Each push operation saves the name as well as the height of the save stack, and each pop operation checks the topmost name with what is expected, causing an assertion failure if the name does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">Cuando perl se compila con soporte para depuración de huellas de memoria (por defecto con malloc())de Perl,Devel::Peek proporciona un acceso a esta API.</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">Cuando perl est&amp;aacute; configurado para usar ithreads, usar&amp;aacute; llamadas de biblioteca reentrantes en lugar de versiones no reentrantes. Hay un error en la funci&amp;oacute;n &lt;code&gt;readdir_r&lt;/code&gt; de FreeBSD en las versiones 4.5 y anteriores que puede causar una SEGV al leer directorios grandes. Hay disponible un parche para FreeBSD libc (consulte &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) que se ha integrado en FreeBSD 4.6.</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">Cuando est&amp;aacute; presente, esta opci&amp;oacute;n limitar&amp;aacute; el n&amp;uacute;mero de bytes comprimidos le&amp;iacute;dos del archivo / b&amp;uacute;fer de entrada a &lt;code&gt;$size&lt;/code&gt; . Esta opci&amp;oacute;n se puede utilizar en situaciones en las que hay datos &amp;uacute;tiles directamente despu&amp;eacute;s del flujo de datos comprimidos y usted conoce de antemano la longitud exacta del flujo de datos comprimidos.</target>
        </trans-unit>
        <trans-unit id="000c8ae4987a475c6136e4e54de88628f059caa6" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt;. This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">Cuando se le presenta algo que puede tener varias interpretaciones diferentes, Perl usa el &lt;b&gt;principio DWIM&lt;/b&gt; (que es &quot;Haz lo que quiero decir&quot;) para elegir la interpretaci&amp;oacute;n m&amp;aacute;s probable. Esta estrategia tiene tanto &amp;eacute;xito que los programadores de Perl a menudo no sospechan la ambivalencia de lo que escriben. Pero de vez en cuando, las nociones de Perl difieren sustancialmente de lo que el autor quiso decir honestamente.</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">Cuando se imprime,un número complejo suele aparecer bajo su estilo cartesiano</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">Cuando se le solicite,elija un tema que resuma sus cambios.</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">Al colocar elementos en &lt;code&gt;%^H&lt;/code&gt; , para evitar conflictos con otros usuarios del hash, existe una convenci&amp;oacute;n sobre qu&amp;eacute; claves usar. Un m&amp;oacute;dulo debe usar solo claves que comiencen con el nombre del m&amp;oacute;dulo (el nombre de su paquete principal) y un car&amp;aacute;cter &quot;/&quot;. Por ejemplo, un m&amp;oacute;dulo &lt;code&gt;Foo::Bar&lt;/code&gt; deber&amp;iacute;a usar claves como &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9430143108ce24dc19010d3dec0a88276a16a9" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt;, in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">Al leer de un archivo o &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; archivo, configure binmode antes de leer.</target>
        </trans-unit>
        <trans-unit id="0711f567d0b9b4a99904ebf4ffdf5f0a6e3dd27c" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;\n&lt;/code&gt;, but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">Al leer desde un socket, recuerde que el separador de registro de entrada predeterminado &lt;code&gt;$/&lt;/code&gt; es &lt;code&gt;\n&lt;/code&gt; , pero el c&amp;oacute;digo de socket robusto reconocer&amp;aacute; como &lt;code&gt;\012&lt;/code&gt; o &lt;code&gt;\015\012&lt;/code&gt; como final de l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: AnyInflate los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: AnyUncompress los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: Bunzip2 los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: Gunzip los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: Inflate los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: RawInflate los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">Al leer los datos de entrada comprimidos, IO :: Uncompress :: Unzip los leer&amp;aacute; en bloques de &lt;code&gt;$num&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">Cuando se hace referencia, &lt;code&gt;$!&lt;/code&gt; recupera el valor actual de la variable entera C &lt;code&gt;errno&lt;/code&gt; . Si &lt;code&gt;$!&lt;/code&gt; se le asigna un valor num&amp;eacute;rico, ese valor se almacena en &lt;code&gt;errno&lt;/code&gt; . Cuando se hace referencia a ella como una cadena, &lt;code&gt;$!&lt;/code&gt; produce la cadena de error del sistema correspondiente a &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a6f2c4dbed65f11dd2dadedd0a40b92fb0de8b" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt;. When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">Cuando se hace referencia a caracteres mediante el uso de un c&amp;oacute;digo num&amp;eacute;rico E &amp;lt;n&amp;gt;, los n&amp;uacute;meros en el rango 32-126 se refieren a los conocidos caracteres US-ASCII (tambi&amp;eacute;n definidos all&amp;iacute; por Unicode, con el mismo significado), que todos los formateadores de Pod deben representar fielmente . Los caracteres cuyos n&amp;uacute;meros E &amp;lt;&amp;gt; est&amp;aacute;n en los rangos 0-31 y 127-159 no deben usarse (ni como literales ni como c&amp;oacute;digos E &amp;lt;number&amp;gt;), excepto para las secuencias de bytes literales para la nueva l&amp;iacute;nea (ASCII 13, ASCII 13 10 o ASCII 10) y tabulaci&amp;oacute;n (ASCII 9).</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">Al registrar nuevas categorías de advertencia,puede dar más nombres a las advertencias::regístrese así:</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">Cuando se eliminan los árboles de directorios,si se quiere examinar cada archivo para decidir si se debe eliminar (y posiblemente dejar grandes franjas de ellos solos),</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">Cuando se presenta el Pod a un formato que permite comentarios (es decir,a casi cualquier formato que no sea de texto plano),un formateador de Pod debe insertar un texto de comentario que identifique su nombre y número de versión,y el nombre y los números de versión de cualquier módulo que pueda estar utilizando para procesar el Pod.Ejemplos mínimos:</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">Cuando se renderiza Pod a un formato que tiene dos tipos de guiones (-),uno que es un guión no rompible y otro que es un guión rompible (como en &quot;orientado a un objeto&quot;,que puede dividirse en líneas como &quot;objeto&quot;,línea nueva,&quot;orientado&quot;),se alienta a los formateadores a traducir generalmente &quot;-&quot; a guión no rompible,pero pueden aplicar heurísticas para convertir algunos de ellos en guiones rompibles.</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">Cuando reporte un error,por favor revise esta lista:</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">Cuando informe de errores/problemas,por favor,incluya tanta información como sea posible.Puede ser difícil para mí reproducir el problema ya que casi cada configuración es diferente.</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">Cuando se resuelve una solicitud de una DLL global,se ignora (efectivamente)la tabla de DLL específicas ya cargadas;además,las DLL específicas son</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">Al devolver una matriz C a Perl, el escritor XS debe proporcionar una variable entera llamada &lt;code&gt;size_$var&lt;/code&gt; contenga el n&amp;uacute;mero de elementos de la matriz. Esto se usa para determinar cu&amp;aacute;ntos elementos deben insertarse en la pila de argumentos de retorno. Esto no es necesario en la entrada ya que Perl sabe cu&amp;aacute;ntos argumentos hay en la pila cuando se llama a la rutina. Normalmente, esta variable se llamar&amp;iacute;a &lt;code&gt;size_RETVAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977e07d16b270182693f540dd1711d684d80c08a" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">Cuando se devuelve un resultado no nulo,el tipo de devolución es relevante.Si es un AV,entonces los elementos del AV son los RVs de referencia débiles que apuntan a este elemento.Si es de cualquier otro tipo entonces el elemento en sí mismo es la referencia débil.</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">Cuando se redondea un número,es posible que haya diferentes &quot;estilos&quot; o &quot;tipos&quot; de redondeo.(Nótese que el redondeo aleatorio,como en Matemáticas::Redondeo,no se implementa).</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">Cuando se ejecuta produce esta salida</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">Cuando se ejecute,el guión producirá este mensaje de error:</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">Cuando se ejecuta &lt;code&gt;perl Makefile.PL&lt;/code&gt; , la variable de entorno &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; se establece en la ruta completa del &lt;code&gt;Makefile.PL&lt;/code&gt; que se est&amp;aacute; ejecutando. Esto evita los procesos fuera de control con versiones m&amp;aacute;s recientes de Module :: Install.</target>
        </trans-unit>
        <trans-unit id="89350694f65316ce98eae1ce7d3a0891e9c042c8" translate="yes" xml:space="preserve">
          <source>When running as the superuser, don't attempt drop privileges for security. This option is implied with &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04666da2a46dba8c376f71b404386c5bd13c8146" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was specified, neither PERL5LIB nor &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is consulted. The program should instead say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">Al ejecutar comprobaciones de taint, ya sea porque el programa estaba ejecutando setuid o setgid, o porque se especific&amp;oacute; el modificador &lt;b&gt;-T&lt;/b&gt; o &lt;b&gt;-t&lt;/b&gt; , no se consulta PERL5LIB ni PERLLIB. En cambio, el programa deber&amp;iacute;a decir:</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">Al ejecutar este programa, redirija &lt;code&gt;STDOUT&lt;/code&gt; para que sea posible verificar que la salida sea correcta de las siguientes ejecuciones de prueba y use la utilidad de &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; del sistema para verificar el tiempo de ejecuci&amp;oacute;n general.</target>
        </trans-unit>
        <trans-unit id="206d7f06e0a05581fe8e0f140b59c4f2ebd75b9b" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;time&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">Cuando se ejecuta bajo Eunice esta variable contiene un comando que convertirá un script de shell a la forma apropiada de archivo de texto para que sea ejecutable por el shell.En otros sistemas es un no-op.</target>
        </trans-unit>
        <trans-unit id="e969971baf41c84189fecb4a510a18aaa7b43b6a" translate="yes" xml:space="preserve">
          <source>When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6a46b32d19b77f807e82e4b0a5dbfd16227ea7" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;&quot;Unsafe signals&quot;&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">Cuando las se&amp;ntilde;ales seguras est&amp;aacute;n en efecto (el comportamiento predeterminado; consulte &lt;a href=&quot;#Unsafe-signals&quot;&gt;Se&amp;ntilde;ales no&lt;/a&gt; seguras para obtener m&amp;aacute;s detalles), las se&amp;ntilde;ales pueden ser enviadas y procesadas por subprocesos individuales.</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">Cuando &lt;code&gt;installcmd&lt;/code&gt; satisfecho con los resultados, vuelva a ejecutar el destino installcmd . Ahora puede copiar &lt;code&gt;perl5.8.2.exe&lt;/code&gt; a &lt;code&gt;perl.exe&lt;/code&gt; e instalar los otros ejecutables de OMF-build: &lt;code&gt;perl__.exe&lt;/code&gt; etc. Est&amp;aacute;n listos para ser utilizados.</target>
        </trans-unit>
        <trans-unit id="f3274597eb7d5805f670851614bcfbd7d2f840a5" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt;, and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">Cuando guarde la fuente,incluya las evoluciones que no generen subrutinas.</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">Cuando guarde la fuente,incluya la fuente que no compiló.</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">Al buscar delimitadores de un solo car&amp;aacute;cter, se omiten los delimitadores de escape y &lt;code&gt;\\&lt;/code&gt; . Por ejemplo, al buscar la terminaci&amp;oacute;n &lt;code&gt;/&lt;/code&gt; , se omiten las combinaciones de &lt;code&gt;\\&lt;/code&gt; y &lt;code&gt;\/&lt;/code&gt; . Si los delimitadores est&amp;aacute;n entre corchetes, tambi&amp;eacute;n se omiten los pares anidados. Por ejemplo, al buscar un cierre &lt;code&gt;]&lt;/code&gt; emparejado con la apertura &lt;code&gt;[&lt;/code&gt; , las combinaciones de &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; y &lt;code&gt;\[&lt;/code&gt; se omiten, y las anidadas &lt;code&gt;[&lt;/code&gt; y &lt;code&gt;]&lt;/code&gt; tambi&amp;eacute;n se omiten. Sin embargo, cuando se usan barras diagonales inversas como delimitadores (como &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ), no se omite nada. Durante la b&amp;uacute;squeda del final, se eliminan las barras invertidas que escapan a los delimitadores u otras barras invertidas (hablando exactamente, no se copian en la ubicaci&amp;oacute;n segura).</target>
        </trans-unit>
        <trans-unit id="15bd46317800c6a271d171bbf86328e23d6c92d4" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;qq\\&lt;/code&gt; and &lt;code&gt;tr\\\&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680861791c99e55f56913fa6b0dc2bd7ba150950" translate="yes" xml:space="preserve">
          <source>When sending an initial request to the security email address, please don't Cc any other parties, because if they reply to all, the reply will generate yet another new ticket. Once you have received an initial reply with a &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; ticket number in the headline, it's okay to Cc subsequent replies to third parties: all emails to the perl5-security-report address with the ticket number in the subject line will be added to the ticket; without it, a new ticket will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">Cuando se establece en &lt;code&gt;&quot;1&quot;&lt;/code&gt; o &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; , las teclas de desplazamiento ser&amp;aacute;n aleatorias. Cada vez que se inserta un hash en el orden de la clave, cambiar&amp;aacute; de forma aleatoria. Es posible que el orden no se pueda repetir en la siguiente ejecuci&amp;oacute;n del programa, incluso si se ha especificado PERL_HASH_SEED. Este es el modo predeterminado de perl.</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">Cuando se establece en &lt;code&gt;&quot;2&quot;&lt;/code&gt; o &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; , la inserci&amp;oacute;n de claves en un hash har&amp;aacute; que cambie el orden de las claves, pero de una manera que sea repetible de ejecuci&amp;oacute;n de programa a ejecuci&amp;oacute;n de programa.</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">Cuando se establece en un valor verdadero, &lt;code&gt;remove_tree&lt;/code&gt; omitir&amp;aacute; los archivos para los cuales el proceso carece de los privilegios necesarios para eliminar archivos, como eliminar privilegios en VMS. En otras palabras, el c&amp;oacute;digo no intentar&amp;aacute; alterar los permisos de los archivos. Por lo tanto, si se interrumpe el proceso, ning&amp;uacute;n objeto del sistema de archivos quedar&amp;aacute; en un modo m&amp;aacute;s permisivo.</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">Cuando se establece un valor verdadero,hará que se eliminen todos los archivos y subdirectorios,excepto los directorios inicialmente especificados.Esto es muy útil cuando se limpia el directorio de rascado de una aplicación.</target>
        </trans-unit>
        <trans-unit id="a98ff16a4db26e40074379a02c1ac4736cef2e29" translate="yes" xml:space="preserve">
          <source>When set to true (default is false) this will reject any facets where a facet class cannot be found. Normally facets without classes are assumed to be custom and are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Cuando se establece, Data :: Dumper emitir&amp;aacute; valores &amp;uacute;nicos no autorreferenciales como &amp;aacute;tomos / t&amp;eacute;rminos en lugar de declaraciones. Esto significa que el &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">Cuando está configurado,controla el tiempo de espera de la red (contado en segundos).</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">Cuando se establece, habilita el uso de comillas dobles para representar valores de cadena. Los espacios en blanco que no sean espacios se representar&amp;aacute;n como &lt;code&gt;[\n\t\r]&lt;/code&gt; , los caracteres &quot;inseguros&quot; se mostrar&amp;aacute;n con barra invertida y los caracteres no imprimibles se mostrar&amp;aacute;n como enteros octales entre comillas. El valor predeterminado es 0.</target>
        </trans-unit>
        <trans-unit id="9d1d9ef1336068db5d1ba9928d2591d51c52c62c" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt;, &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">¿Cuándo debo decodificar o codificar?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">¿Cuándo no debería programar en Perl?</target>
        </trans-unit>
        <trans-unit id="ab11b33195a0de9ef0d3f4bb14477223addc7e28" translate="yes" xml:space="preserve">
          <source>When some mandatory fields are missing or invalid, the conversion will attempt to provide a sensible default or will fill them with a value of 'unknown'. For example a missing or unrecognized &lt;code&gt;license&lt;/code&gt; field will result in a &lt;code&gt;license&lt;/code&gt; field of 'unknown'. Fields that may get an 'unknown' include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">Cuando algo est&amp;aacute; contenido en otra cosa, particularmente cuando eso podr&amp;iacute;a considerarse sorprendente: &quot;&amp;iexcl;He incorporado un int&amp;eacute;rprete de Perl completo en mi editor!&quot;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">Cuando hablamos de regexes necesitamos distinguir entre su forma de código fuente y su forma interna.En este documento usaremos el término &quot;patrón&quot; cuando hablemos de su forma textual,código fuente,y el término &quot;programa&quot; cuando hablemos de su representación interna.Estos corresponden a los términos</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">Cuando se especifica (localizado)en un módulo</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">Al iniciar scripts directamente, Perl usa exactamente el mismo algoritmo que para la b&amp;uacute;squeda del script dada por la opci&amp;oacute;n de l&amp;iacute;nea de comandos &lt;b&gt;-S&lt;/b&gt; : buscar&amp;aacute; en el directorio actual, luego en los componentes de &lt;code&gt;$ENV{PATH}&lt;/code&gt; usando el siguiente orden de extensiones agregadas : no hay extensi&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">Cuando se almacenan dobles en orden de red,su valor se almacena como texto.Sin embargo,tampoco debe esperarse que los valores de coma flotante no numéricos,como el infinito y &quot;no un número&quot;,pasen con éxito por un par nstore()/retrieve().</target>
        </trans-unit>
        <trans-unit id="4e11b655699381504305f7887609ab8d634e504a" translate="yes" xml:space="preserve">
          <source>When stringified, &lt;code&gt;autodie::exception::system&lt;/code&gt; objects currently use the message generated by &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85058aaefb4d2e0a77cba44540a9a1fa5a2d7ef7" translate="yes" xml:space="preserve">
          <source>When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">Al probar aplicaciones, a menudo se encuentra en la necesidad de proporcionar una funcionalidad en su entorno de prueba que normalmente ser&amp;iacute;a proporcionada por m&amp;oacute;dulos externos. En lugar de manipular el &lt;code&gt;%INC&lt;/code&gt; a mano para marcar estos m&amp;oacute;dulos externos como cargados, de modo que perl no intente cargarlos, este m&amp;oacute;dulo le ofrece una forma muy sencilla de marcar m&amp;oacute;dulos como cargados y / o descargados.</target>
        </trans-unit>
        <trans-unit id="2ecf844cc9f858984bae81698225ab3522c9600d" translate="yes" xml:space="preserve">
          <source>When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event: &quot;I just LOVE hot apple pie!&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">Cuando esa cuerda se compila a partir de la notación de paréntesis en un verdadero submarino de Perl,se convierte básicamente en:</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">Cuando la bandera#y una precisión se dan en la conversión %o,la precisión se incrementa si es necesario para el &quot;0&quot; inicial.</target>
        </trans-unit>
        <trans-unit id="aa880a320400827152fdc9bea63191360399d514" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag is set, the CV takes responsibility for freeing the slab. If &lt;code&gt;CvROOT&lt;/code&gt; is not set when the CV is freed or undeffed, it is assumed that a compilation error has occurred, so the op slab is traversed and all the ops are freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">Cuando el par&amp;aacute;metro &lt;code&gt;all&lt;/code&gt; se omite o es falso, los elementos hash vinculados ser&amp;aacute;n el contenido del b&amp;uacute;fer definido m&amp;aacute;s a la izquierda con el nombre de la clave hash asociada. En otras palabras, el hash vinculado se comportar&amp;aacute; como &lt;code&gt;%+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92065de5607bb0c7a77a48e1cfce97eed7a26ac" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">Cuando se proporciona el par&amp;aacute;metro &lt;code&gt;all&lt;/code&gt; , los elementos hash vinculados ser&amp;aacute;n referencias de matriz que enumeran el contenido de cada b&amp;uacute;fer de captura cuyo nombre es el mismo que el de la clave hash asociada. Si ninguno de estos b&amp;uacute;feres estuvo involucrado en la coincidencia, el contenido de esa referencia de matriz ser&amp;aacute; tantos valores &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; como b&amp;uacute;feres de captura hay con ese nombre. En otras palabras, el hash vinculado se comportar&amp;aacute; como &lt;code&gt;%-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2197c6d3b3d6c61f6564ab44ac2b44c0344d23" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;undef&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">Cuando la opci&amp;oacute;n &lt;code&gt;exUnix2&lt;/code&gt; est&amp;aacute; presente, activar&amp;aacute; la creaci&amp;oacute;n de un campo adicional de Unix2 (el ID es &quot;Ux&quot;) en el encabezado zip local. Esto se completar&amp;aacute; con &lt;code&gt;$uid&lt;/code&gt; y &lt;code&gt;$gid&lt;/code&gt; . Tambi&amp;eacute;n se crear&amp;aacute; un campo adicional de Unix2 vac&amp;iacute;o en el encabezado del zip central.</target>
        </trans-unit>
        <trans-unit id="0db2965770fe8514e3fb9dd21cb17bd93496e99e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">Cuando la opci&amp;oacute;n &lt;code&gt;exUnixN&lt;/code&gt; est&amp;aacute; presente, activar&amp;aacute; la creaci&amp;oacute;n de un campo extra de UnixN (el ID es &quot;ux&quot;) en los encabezados zip locales y centrales. Esto se completar&amp;aacute; con &lt;code&gt;$uid&lt;/code&gt; y &lt;code&gt;$gid&lt;/code&gt; . El UID y GID se almacenan como enteros de 32 bits.</target>
        </trans-unit>
        <trans-unit id="f94a510aaa8dc7a162e9738895fa3812cc690de5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">Cuando se establece la opci&amp;oacute;n de &lt;code&gt;frame&lt;/code&gt; , el depurador imprime subrutinas ingresadas (y opcionalmente salidas) en diferentes estilos. Consulte &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; para ver ejemplos incre&amp;iacute;blemente largos de estos.</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">Cuando se utiliza el m&amp;oacute;dulo CPAN por primera vez, un di&amp;aacute;logo de configuraci&amp;oacute;n intenta determinar un par de opciones espec&amp;iacute;ficas del sitio. El resultado del di&amp;aacute;logo se almacena en una referencia hash &lt;code&gt; $CPAN::Config &lt;/code&gt; en un archivo CPAN / Config.pm.</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">Cuando el shell del CPAN entra en una subcapa mediante el comando look,establece el entorno CPAN_SHELL_LEVEL en 1,o incrementa esa variable si ya está establecida.</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">Cuando el shell del CPAN se inicia,normalmente muestra un mensaje de saludo que contiene la versión que se está ejecutando y el estado del soporte de la línea de lectura.</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">Cuando se lee o escribe en &lt;code&gt;uf_val&lt;/code&gt; &lt;code&gt;uf_set&lt;/code&gt; funci&amp;oacute;n uf_val o uf_set con &lt;code&gt;uf_index&lt;/code&gt; como primer argumento y un puntero al SV como segundo. A continuaci&amp;oacute;n se muestra un ejemplo simple de c&amp;oacute;mo agregar magia &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; . Tenga en cuenta que la estructura de ufuncs es copiada por sv_magic, por lo que puede asignarla de forma segura en la pila.</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Cuando el motor Storable no encuentra ninguna rutina de gancho &lt;code&gt;STORABLE_thaw&lt;/code&gt; , intenta cargar la clase requiriendo el paquete din&amp;aacute;micamente (usando el nombre del paquete bendecido) y luego vuelve a intentar la b&amp;uacute;squeda. Si en ese momento no se puede ubicar el gancho, el motor croa. Tenga en cuenta que este mecanismo fallar&amp;aacute; si define varias clases en el mismo archivo, pero &lt;a href=&quot;perlmod&quot;&gt;perlmod le&lt;/a&gt; advirti&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="d71b47dffe6d13e95919a44f8b1aab3c74c9a2ad" translate="yes" xml:space="preserve">
          <source>When the Windows and Arm DLLs are built do not be scared by a very long messages whizzing by: it is the &quot;export freeze&quot; phase where the whole (rather large) API of Perl is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">Cuando el estado real de terminaci&amp;oacute;n de VMS del ni&amp;ntilde;o es un error, internamente el &lt;code&gt;$!&lt;/code&gt; El valor se establecer&amp;aacute; en el valor de errno de Unix m&amp;aacute;s cercano a ese error para que los scripts de Perl que prueban los mensajes de error vean el mensaje de error de estilo Unix esperado en lugar de un mensaje de VMS.</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Cuando los argumentos se ejecutan a trav&amp;eacute;s del shell del sistema, los resultados est&amp;aacute;n sujetos a sus peculiaridades y capacidades. Vea &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;&quot;STRING&quot; en perlop&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="ca28137b7d4a24f80f2a308158da006f7dc35dce" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Cuando los argumentos se ejecutan a trav&amp;eacute;s del shell del sistema, los resultados est&amp;aacute;n sujetos a sus peculiaridades y capacidades. Vea &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;STRING&quot; en perlop&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="7a639b80ea13083bb656ad3ace22f1641521ba99" translate="yes" xml:space="preserve">
          <source>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569274b14b45a92ddaed7462d32bdd3f4354e2b9" translate="yes" xml:space="preserve">
          <source>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ba3a0afa8ccd6c06c8d4acfe9a1d04b1ddc937" translate="yes" xml:space="preserve">
          <source>When the build environment has been set up, building and testing Perl is straightforward. The only thing you need to do is download the sources as usual, and add a file Policy.sh as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ca0edd57c85a2b69cd25fb457d6653721de135" translate="yes" xml:space="preserve">
          <source>When the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">Cuando la clase debe coincidir sin may&amp;uacute;sculas &lt;code&gt;/i&lt;/code&gt; min&amp;uacute;sculas en las reglas de coincidencia / i , y un car&amp;aacute;cter que se menciona expl&amp;iacute;citamente dentro de la clase coincide con una secuencia de varios caracteres sin may&amp;uacute;sculas en las reglas Unicode, la clase tambi&amp;eacute;n coincidir&amp;aacute; con esa secuencia. Por ejemplo, Unicode dice que la letra &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; debe coincidir con la secuencia &lt;code&gt;ss&lt;/code&gt; bajo las reglas &lt;code&gt;/i&lt;/code&gt; . As&amp;iacute;,</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">Cuando el código se ejecute en sólo dos o tres sistemas operativos,puede que sea necesario considerar sólo las diferencias de esos sistemas en particular.Lo importante es decidir dónde se ejecutará el código y ser deliberado en su decisión.</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">Cuando la variable de configuración ftp_passive se establece,todas las descargas se ejecutarán con la variable de entorno FTP_PASSIVE establecida en este valor.Esto es en general una buena idea ya que influye tanto en las conexiones basadas en Net::FTP y LWP.El mismo efecto se puede lograr iniciando el shell de cpan con esta variable de entorno establecida.Para Net::FTP solamente,uno puede siempre establecer el modo pasivo ejecutando libnetcfg.</target>
        </trans-unit>
        <trans-unit id="b1c69bf3ddadf947bad50c1663c482207ed7bb54" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;dbi&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">Cuando la base de datos contiene solo UTF-8, una funci&amp;oacute;n o m&amp;eacute;todo contenedor es una forma conveniente de reemplazar todas sus llamadas &lt;code&gt;fetchrow_array&lt;/code&gt; y &lt;code&gt;fetchrow_hashref&lt;/code&gt; . Una funci&amp;oacute;n de contenedor tambi&amp;eacute;n facilitar&amp;aacute; la adaptaci&amp;oacute;n a futuras mejoras en el controlador de su base de datos. Tenga en cuenta que en el momento de escribir este art&amp;iacute;culo (enero de 2012), el DBI no tiene una forma estandarizada de tratar los datos UTF-8. Consulte la &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;documentaci&amp;oacute;n de DBI&lt;/a&gt; para verificar si eso sigue siendo cierto.</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">Cuando la ejecuci&amp;oacute;n de su programa alcanza un punto que puede contener un punto de interrupci&amp;oacute;n, se llama a la subrutina &lt;code&gt;DB::DB()&lt;/code&gt; si alguna de las variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; o &lt;code&gt;$DB::signal&lt;/code&gt; es verdadera . Estas variables no son &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; es izable. Esta caracter&amp;iacute;stica est&amp;aacute; deshabilitada cuando se ejecuta dentro de &lt;code&gt;DB::DB()&lt;/code&gt; , incluidas las funciones llamadas desde ella, a menos que &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; sea ​​verdadero.</target>
        </trans-unit>
        <trans-unit id="203a255f166a15d5d314005ac0db0ee5bd633f84" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt;, &lt;code&gt;$DB::single&lt;/code&gt;, or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;local&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt;, including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">Cuando el archivo</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">Cuando los archivos que estás procesando son pequeños,no importa mucho de qué manera lo hagas,pero hace una gran diferencia cuando empiezan a ser más grandes.</target>
        </trans-unit>
        <trans-unit id="d42ad95e8f7eb1ea8f7a7febcc136ac0e51ac7e9" translate="yes" xml:space="preserve">
          <source>When the first bad commit is isolated, &lt;code&gt;git bisect&lt;/code&gt; will tell you so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc397f7438e86b99c564236153e8faa95f5c6e3" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbrlen&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f6d7004331625d3362cc91973ffa26e2885b63" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar, the code point contained in the scalar second parameter is converted into a multi-byte string and stored into the first parameter scalar. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. The return value is the number of bytes stored; or negative if the code point isn't representable in the current locale. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;wctomb&lt;/code&gt; and &lt;code&gt;wcrtomb&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67993cdc0054c70b8cf1f3b164eab66d68fabca" translate="yes" xml:space="preserve">
          <source>When the hash is tied dispatches through to the SCALAR method, otherwise returns a mortal SV containing the number of keys in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">Cuando se llame la subrutina interna,verá el valor de la subrutina léxica de la subrutina externa como lo fue antes y durante la *primera*llamada a la subrutina externa;en este caso,después de que se complete la primera llamada a la subrutina externa,las subrutinas interna y externa ya no compartirán un valor común para la subrutina léxica.En otras palabras,ya no se compartirán.Esto será especialmente importante si la subrutina léxica accede a las variables léxicas declaradas en su ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">Cuando se llame la subrutina interna,verá el valor de la variable de la subrutina externa como antes y durante la *primera*llamada a la subrutina externa;en este caso,después de que se complete la primera llamada a la subrutina externa,las subrutinas interna y externa ya no compartirán un valor común para la variable.En otras palabras,la variable ya no será compartida.</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">Cuando la última referencia a un objeto desaparece,el objeto es destruido.Si sólo se tiene una referencia a un objeto almacenado en un escalar léxico,el objeto se destruye cuando ese escalar se sale del ámbito de aplicación.Si almacena el objeto en un paquete global,ese objeto no puede salir de su alcance hasta que el programa salga.</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">Cuando la capa es empujada como parte de una &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; llamada, &lt;code&gt;PUSHED&lt;/code&gt; ser&amp;aacute;n llamados</target>
        </trans-unit>
        <trans-unit id="01a59251b1866e239efdc75d52f126badadf6773" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;open&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">Cuando se empuja la capa, el valor actual de &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; se guarda y se usa como el argumento CHECK al llamar a los m&amp;eacute;todos Encode encode () y decode ().</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">Cuando el m&amp;oacute;dulo lib se carga por primera vez, registra el valor actual de @INC en una matriz &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . Para restaurar @INC a ese valor, puede decir</target>
        </trans-unit>
        <trans-unit id="e9f47c78a4b7c6bf48658f90ad7bb90a6f2c2f03" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt;. To restore @INC to that value you can say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">Cuando se ejecuta la coincidencia, la primera parte de la expresi&amp;oacute;n regular ( &lt;code&gt;\b(foo)&lt;/code&gt; ) encuentra una posible coincidencia justo al principio de la cadena y carga $ 1 con &quot;Foo&quot;. Sin embargo, tan pronto como el motor de b&amp;uacute;squeda ve que no hay espacios en blanco despu&amp;eacute;s del &quot;Foo&quot; que hab&amp;iacute;a guardado en $ 1, se da cuenta de su error y comienza de nuevo un car&amp;aacute;cter despu&amp;eacute;s de donde ten&amp;iacute;a la coincidencia tentativa. Esta vez va todo el camino hasta la pr&amp;oacute;xima aparici&amp;oacute;n de &quot;foo&quot;. La expresi&amp;oacute;n regular completa coincide esta vez y obtiene el resultado esperado de &quot;la tabla sigue a foo&quot;.</target>
        </trans-unit>
        <trans-unit id="59438c31be63ed00a2828de2f2dbb82ccfc7a3c2" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt;) finds a possible match right at the beginning of the string, and loads up &lt;code&gt;$1&lt;/code&gt; with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in &lt;code&gt;$1&lt;/code&gt;, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a3d6c13049ca137ffa9c8c06a835f3079e4b4a" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &lt;a href=&quot;#unlink1&quot;&gt;unlink1&lt;/a&gt;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">Cuando el objeto se sale del alcance,se llama al destructor.Este destructor intentará desvincular el archivo (usando L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">Cuando se cumplen los criterios de optimizaci&amp;oacute;n, se llama a &lt;code&gt;reg_try()&lt;/code&gt; para realizar la coincidencia.</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">Cuando la salida es un nombre de archivo,truncará el contenido del archivo antes de escribir cualquier dato comprimido.Si la salida es un nombre de archivo,su posición no se modificará.Si la salida es un buffer,se borrará antes de que se produzca cualquier dato comprimido.</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">Cuando la salida es un nombre de archivo,truncará el contenido del archivo antes de escribir cualquier dato sin comprimir.Si la salida es un nombre de archivo,su posición no se modificará.Si la salida es un búfer,se borrará antes de que se produzca cualquier dato sin comprimir.</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">Cuando el programa ha terminado,la salida puede ser examinada y clasificada usando cualquier utilidad de filtrado de texto estándar.Algo como lo siguiente puede ser suficiente:</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">Cuando el guión termine,y quieras cambiar algunos valores en el generado</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">Cuando el script termina, el generador de perfiles crear&amp;aacute; una base de datos de la informaci&amp;oacute;n del perfil que puede convertir en informes utilizando las herramientas del generador de perfiles. Consulte &amp;lt;perlperf&amp;gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="bd423c011519f7f605565c27b285e9b7433164a6" translate="yes" xml:space="preserve">
          <source>When the second parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mbtowc&lt;/code&gt; and &lt;code&gt;mbrtowc&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">Cuando la cadena contiene un punto de c&amp;oacute;digo llamado Unicode &lt;code&gt;\N{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">Cuando la cadena contiene un punto de código sólo de Unicode</target>
        </trans-unit>
        <trans-unit id="dff4dc2cfa7ab4f3143ca1c8cea9659a2fba0df1" translate="yes" xml:space="preserve">
          <source>When the string has been upgraded to UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">Cuando la cadena ha venido de una fuente externa marcada como Unicode</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">Cuando el modo de mancha ( &lt;code&gt;-T&lt;/code&gt; ) est&amp;aacute; en efecto, el &quot;.&quot; El directorio se elimina de &lt;code&gt;@INC&lt;/code&gt; y Perl ignora las variables de entorno &lt;code&gt;PERL5LIB&lt;/code&gt; y &lt;code&gt;PERLLIB&lt;/code&gt; . A&amp;uacute;n puede ajustar &lt;code&gt;@INC&lt;/code&gt; desde fuera del programa usando la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;-I&lt;/code&gt; como se explica en &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; . Las dos variables de entorno se ignoran porque est&amp;aacute;n oscurecidas y un usuario que ejecuta un programa podr&amp;iacute;a no darse cuenta de que est&amp;aacute;n configuradas, mientras que la opci&amp;oacute;n &lt;code&gt;-I&lt;/code&gt; es claramente visible y, por lo tanto, est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="e34514e5e3372fed96ae586191867c70ca14aae4" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt;) is in effect, the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">Cuando el archivo de la prueba termine,se saca el resumen,juntos.</target>
        </trans-unit>
        <trans-unit id="5d3ce74817cdede8942c8b771dd9c729dbff5404" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; was only available when the &lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt;&lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature&lt;/a&gt; was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Cuando no hay BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; es una funci&amp;oacute;n que cae a trav&amp;eacute;s de la corriente &lt;code&gt;when&lt;/code&gt; o &lt;code&gt;default&lt;/code&gt; de bloques en lugar de iterar una din&amp;aacute;mica que encierra &lt;code&gt;foreach&lt;/code&gt; o salir de un l&amp;eacute;xico que encierra &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; . En Perl 5.14 y versiones anteriores, esta forma de &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; solo estaba disponible cuando la funci&amp;oacute;n &lt;code&gt;&quot;switch&quot;&lt;/code&gt; estaba habilitada. Consulte las &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;declaraciones de &lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;funciones&lt;/a&gt; y conmutadores en perlsyn para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Cuando no hay BLOQUE, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; es una funci&amp;oacute;n que cae a trav&amp;eacute;s del bloque &lt;code&gt;when&lt;/code&gt; actual o &lt;code&gt;default&lt;/code&gt; lugar de iterar un &lt;code&gt;foreach&lt;/code&gt; que encierra din&amp;aacute;micamente o salir de un &lt;code&gt;given&lt;/code&gt; encierra l&amp;eacute;xicamente . En Perl 5.14 y anteriores, esta forma de &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; solo estaba disponible cuando la funci&amp;oacute;n &lt;code&gt;&quot;switch&quot;&lt;/code&gt; estaba habilitada. Consulte las &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;declaraciones de &lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;funciones&lt;/a&gt; y conmutadores en perlsyn para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">Cuando no hay método,toma el nombre del método como el nombre de la codificación y codifica la instancia</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">Cuando estos están incrustados en otro patrón,lo que coinciden no cambia,independientemente de la paréntesis o de los modificadores que están en efecto en ese patrón exterior.</target>
        </trans-unit>
        <trans-unit id="dc5872b9a322af5576c1ac03e71331c1716252c8" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern. If you fail to compile the subcomponents, you can get some nasty surprises. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1810832e010e811c7366d9b862298011ff2e0aa6" translate="yes" xml:space="preserve">
          <source>When this bit is set, &lt;code&gt;$sNewName&lt;/code&gt; can be &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt;] to indicate that &lt;code&gt;$sOldName&lt;/code&gt; should be deleted during the next boot rather than renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">Cuando este código se ejecuta no hay salida.Aquí está el porqué:</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">Cuando se ejecuta este c&amp;oacute;digo, solo el objeto &lt;code&gt;Derived&lt;/code&gt; , &lt;code&gt;$b&lt;/code&gt; , generar&amp;aacute; una advertencia.</target>
        </trans-unit>
        <trans-unit id="9309453554803d7d3570d025f7e35cec80cda5d1" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt;, will generate a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">Cuando este c&amp;oacute;digo se ejecuta con la bandera &lt;b&gt;-w&lt;/b&gt; , se producir&amp;aacute; una advertencia para la l&amp;iacute;nea &lt;code&gt;$a&lt;/code&gt; : &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2388e2ced3b75ec3bd369e3152eae13dfe498282" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">Cuando se usa esta forma del pragma, Perl solo usa las partes sin caracteres de las configuraciones regionales, por ejemplo &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl asume que ha traducido todos los caracteres sobre los que va a operar a Unicode (en realidad, el juego de caracteres nativo de la plataforma (ASCII o EBCDIC) m&amp;aacute;s Unicode). Para datos en archivos, esto se puede hacer convenientemente especificando tambi&amp;eacute;n</target>
        </trans-unit>
        <trans-unit id="db1567ebb35e094978d64dee42e25f3b2f3257aa" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt;. Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">Cuando se llama esta función,la función referida por</target>
        </trans-unit>
        <trans-unit id="e9e65ea3d452091e9942f0f5039cb9a617322586" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_checker&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_checker_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_checker&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_checker_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_checker&lt;/code&gt; is called. If &lt;code&gt;new_checker&lt;/code&gt; decides not to do anything special with an op that it is given (which is the usual case for most uses of op check hooking), it must chain the check function referenced by &lt;code&gt;*old_checker_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4ee6516decf05e05dd9bd8fd17984cd79424b" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_plugin&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_plugin_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_plugin&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_plugin_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_plugin&lt;/code&gt; is called. If &lt;code&gt;new_plugin&lt;/code&gt; decides not to do anything special with the identifier that it is given (which is the usual case for most calls to a keyword plugin), it must chain the plugin function referenced by &lt;code&gt;*old_plugin_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa02f2fe554bd2a9b6a103fe9beb89d9b4e4476" translate="yes" xml:space="preserve">
          <source>When this happens, you can just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">Cuando se establece en &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; se derivar&amp;aacute; &lt;code&gt;O_FILES&lt;/code&gt; de O_FILES .</target>
        </trans-unit>
        <trans-unit id="447329d526fb82114543e70fb22d4772337fe346" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4611cd8d92449087862ca322a574ebe794802885" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, multiple XS files may be placed under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">Cuando esto sea cierto,el CPAN establecerá PERL_MM_USE_DEFAULT a un valor verdadero.Esto hace que ExtUtils::MakeMaker (y compatible)solicite el uso de los valores por defecto en lugar de detenerse para pedirle que responda a las preguntas.También establece NONINTERACTIVE_TESTING a un valor verdadero para indicar de manera más general que las distribuciones no deben tratar de interactuar con usted.</target>
        </trans-unit>
        <trans-unit id="e48ad08805e823db4cab572ed48a495b3413c960" translate="yes" xml:space="preserve">
          <source>When this option is set to true AND the zip archive being read has the &quot;Language Encoding Flag&quot; (EFS) set, the member name is assumed to be encoded in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">Cuándo usar el local()</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">Cuándo usar OO</target>
        </trans-unit>
        <trans-unit id="7fe9c30c4e2d69806274da4a183bd0637abe22d6" translate="yes" xml:space="preserve">
          <source>When true the entire test should be skipped. This is usually paired with an explanation in the &lt;code&gt;details&lt;/code&gt; field, and a &lt;code&gt;control&lt;/code&gt; facet that has &lt;code&gt;terminate&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">Cuando sea cierto,este parámetro pondrá el bit FLG.FHCRC a 1 en el encabezado gzip y pondrá el campo de encabezado CRC16 en el CRC del encabezado gzip completo,excepto el propio campo CRC16.</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">Cuando sea cierto,realice la generación y adición al MANIFIESTO del archivo de FIRMA en el distdir durante &quot;make distdir&quot;,a través de &quot;cpansign -s&quot;.</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">Cuando es verdadero, suprime la adici&amp;oacute;n de instalaciones a &lt;code&gt;perllocal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5bff80188d068a00e6b218733a6d5345f2c3a2" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">Cuando es cierto,suprime la generación y adición al MANIFIESTO de los archivos de metadatos de los módulos META.yml y META.json durante &quot;make distdir&quot;.</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">Cuando es cierto,suprime la generación de los archivos de metadatos de los módulos MYMETA.yml y MYMETA.json durante el 'perl Makefile.PL'.</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">Cuando es verdadero, suprime la escritura de archivos de &lt;code&gt;packlist&lt;/code&gt; de paquetes para instalaciones.</target>
        </trans-unit>
        <trans-unit id="72af2071def396f7be81fd1ce806195fb7b786b5" translate="yes" xml:space="preserve">
          <source>When true, the tempdir used by the IPC driver will not be deleted when the test is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">Al tratar de explicar las pilas,la mayoría de los libros de informática murmuran algo sobre columnas de platos de cafetería con resortes:lo último que empujas en la pila es lo primero que se desprende.Eso servirá para nuestros propósitos:su programa C empujará algunos argumentos a la &quot;pila de Perl&quot;,cerrará los ojos mientras ocurre algo de magia,y luego hará saltar los resultados -el valor de retorno de su subrutina de Perl-de la pila.</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">Al atar un asa, el primer argumento para &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; debe comenzar con un asterisco. Entonces, si est&amp;aacute; vinculando STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . Si lo ha asignado a una variable escalar, diga &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ata la variable escalar &lt;code&gt;$handle&lt;/code&gt; , no el identificador dentro de ella.</target>
        </trans-unit>
        <trans-unit id="db73b1d8c34ba44728cad3d2b1f319f02e5b59fc" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;tie&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt;. If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt;, use &lt;code&gt;*$handle&lt;/code&gt;. &lt;code&gt;tie $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt;, not the handle inside it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ae376ab632badfb7a32a894228e134f3e11c" translate="yes" xml:space="preserve">
          <source>When uncompressing with &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt;, it will automatically detect if the zip file is zip64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">Cuando se usa como m&amp;eacute;todo de clase ( &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , a veces denominado m&amp;eacute;todo est&amp;aacute;tico), &lt;code&gt;isa&lt;/code&gt; devuelve</target>
        </trans-unit>
        <trans-unit id="1f0c66833fbe6e1b03af60ec0fe15b9334c1979b" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt;, sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75a54bcbf3526f0df59166b3d1ecbeabab7eb5" translate="yes" xml:space="preserve">
          <source>When used as a class method the &lt;code&gt;\%facet_data&lt;/code&gt; argument is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">Cuando se usa como filtro queremos invocarlo así:</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">Cuando se usa como una instancia o m&amp;eacute;todo de clase ( &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; devuelve</target>
        </trans-unit>
        <trans-unit id="0c835a1bdea740af7b69e93efd47e9739cc62c50" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt;), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee80d9e31f7273254ea3de17e8c9cb461c0c08a0" translate="yes" xml:space="preserve">
          <source>When used as an object method the &lt;code&gt;\%facet_data&lt;/code&gt; argument may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac020145ba791bbcde686e21207104ab4efac0" translate="yes" xml:space="preserve">
          <source>When used as methods, all these subroutines call &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt;. The default &lt;code&gt;facet_data()&lt;/code&gt; method in &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; relies on the legacy methods this module emulates in order to work. As a result of this it is very easy to create infinite recursion bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">Cuando se usa as&amp;iacute;, las opciones y sus posibles valores se eliminan de &lt;code&gt;@myopts&lt;/code&gt; , el &lt;code&gt;@ARGV&lt;/code&gt; global no se toca en absoluto.</target>
        </trans-unit>
        <trans-unit id="80c8f7c123cd2630d333f7d9131c53ccb92cec1a" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">Cuando se usa así:</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">Cuando se usa en un elemento hash, le dice si el valor est&amp;aacute; definido, no si la clave existe en el hash. El uso &lt;a href=&quot;#exists&quot;&gt;existe&lt;/a&gt; para este &amp;uacute;ltimo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="3ea5744253b0aebebea0a675efdda097478c50c9" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; for the latter purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">Cuando se usa en un elemento hash, le dice si el valor est&amp;aacute; definido, no si la clave existe en el hash. El uso &lt;a href=&quot;exists&quot;&gt;existe&lt;/a&gt; para este &amp;uacute;ltimo prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">Cuando se usa en un elemento de una matriz o hash, &lt;code&gt;is_shared&lt;/code&gt; comprueba si el elemento especificado pertenece a una matriz compartida o hash. (No comprueba el contenido de ese elemento).</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">Cuando se usa para pasar una lista de Perl a C, el escritor XS debe proporcionar una funci&amp;oacute;n (nombrada despu&amp;eacute;s del tipo de matriz pero con 'Ptr' sustituido por '*') para asignar la memoria requerida para contener la lista. Se debe devolver un puntero. Depende del escritor XS liberar la memoria al salir de la funci&amp;oacute;n. La variable &lt;code&gt;ix_$var&lt;/code&gt; se establece en el n&amp;uacute;mero de elementos de la nueva matriz.</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">Cuando se usa con &lt;code&gt;.&lt;/code&gt; , el recuento de repeticiones determina la posici&amp;oacute;n inicial para calcular el valor de compensaci&amp;oacute;n de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">Cuando se usa con &lt;code&gt;@&lt;/code&gt; , el recuento de repeticiones representa un desplazamiento desde el inicio del grupo m&amp;aacute;s interno &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452ac7244192f1d1049652316194fb25f11bd124" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt;, the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">Cuando se usa con &lt;code&gt;Z&lt;/code&gt; , se garantiza que un &lt;code&gt;*&lt;/code&gt; como el recuento de repeticiones agregar&amp;aacute; un byte nulo al final, por lo que la cadena resultante siempre es un byte m&amp;aacute;s larga que la longitud del byte del elemento en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">Cuando se usa con m&amp;eacute;todos de clase, el problema es a&amp;uacute;n peor. Debido a que Perl permite que los nombres de las subrutinas se escriban como palabras simples, Perl tiene que adivinar si la palabra clave despu&amp;eacute;s del m&amp;eacute;todo es un nombre de clase o un nombre de subrutina. En otras palabras, Perl puede resolver la sintaxis como &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;o &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">Cuando se usa con opciones de línea de comando:</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">Cuando userelocatableinc es verdadera,esta variable contiene la ubicación a la que make install debería copiar el binario de perl,con todas las rutas reubicables en tiempo de ejecución calculadas a partir de éste en el momento de la instalación.Cuando se utiliza,se inicializa con el valor original de binexp,y luego binexp se establece en</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">Cuando se usa &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;lt;&lt;/code&gt; en un grupo &lt;code&gt;()&lt;/code&gt; , esto afecta a todos los tipos dentro del grupo que aceptan modificadores de orden de bytes, incluidos todos los subgrupos. Se ignora silenciosamente para todos los dem&amp;aacute;s tipos. No se le permite anular el orden de bytes dentro de un grupo que ya tiene un sufijo modificador de orden de bytes.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">Cuando se utiliza &lt;code&gt;Exporter&lt;/code&gt; con los pragmas est&amp;aacute;ndar &lt;code&gt;strict&lt;/code&gt; y de &lt;code&gt;warnings&lt;/code&gt; , la palabra clave &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; es necesaria para declarar las variables del paquete &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">Al usar &lt;code&gt;IPC::Open3&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , si proporciona una cadena como argumento de &lt;code&gt;command&lt;/code&gt; , se asume que se ha escapado adecuadamente. Puede usar la constante &lt;code&gt;QUOTE&lt;/code&gt; para usarla como un car&amp;aacute;cter de cita port&amp;aacute;til (ver arriba). Sin embargo, si proporciona una referencia de matriz, se aplican reglas especiales:</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">Al usar &lt;code&gt;IPC::Run&lt;/code&gt; , si proporciona una cadena como argumento del &lt;code&gt;command&lt;/code&gt; , la cadena se dividir&amp;aacute; en espacios en blanco para determinar los elementos individuales de su comando. Aunque esto generalmente solo har&amp;aacute; lo que quiere decir, puede fallar si tiene archivos o comandos con espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">Al usar &lt;code&gt;autodie&lt;/code&gt; o &lt;code&gt;Fatal&lt;/code&gt; con subrutinas de usuario, la declaraci&amp;oacute;n de esas subrutinas debe aparecer antes del primer uso de &lt;code&gt;Fatal&lt;/code&gt; o &lt;code&gt;autodie&lt;/code&gt; , o haber sido exportadas desde un m&amp;oacute;dulo. Si intenta utilizar &lt;code&gt;Fatal&lt;/code&gt; o &lt;code&gt;autodie&lt;/code&gt; en otras subrutinas de usuario, se producir&amp;aacute; un error en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">Cuando se usa &lt;code&gt;fd_retrieve&lt;/code&gt; , los objetos se recuperan en secuencia, un objeto (es decir, un &amp;aacute;rbol recursivo) por &lt;code&gt;store_fd&lt;/code&gt; asociado .</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">Cuando se usa GCC, esa entrada especifica que MakeMaker debe buscar primero &lt;code&gt;libgl.a&lt;/code&gt; (seguido de &lt;code&gt;gl.a&lt;/code&gt; ) en todas las ubicaciones especificadas por &lt;code&gt;$Config{libpth}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">Cuando se usa el Módulo::Construir,esto suele ser:</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">Al usar PUSHCOLOR,POPCOLOR y LOCALCOLOR,es particularmente importante no poner comas entre las constantes.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">Cuando se usa el término::ReadLine,puedes encender los adornos para que tu entrada se destaque frente a la salida de CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">Cuando se usa la sintaxis Unix o MSDOS, esto emula la funci&amp;oacute;n de shell &lt;code&gt;dirname(1)&lt;/code&gt; que es sutilmente diferente de c&amp;oacute;mo funciona &lt;code&gt;fileparse()&lt;/code&gt; . Devuelve todo menos el &amp;uacute;ltimo nivel de una ruta de archivo, incluso si el &amp;uacute;ltimo nivel es claramente un directorio. En efecto, no est&amp;aacute; devolviendo la parte del directorio, sino simplemente la ruta un nivel m&amp;aacute;s arriba actuando como &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; para las rutas de archivo.</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">Cuando use un compilador que no sea GCC, la entrada anterior buscar&amp;aacute; &lt;code&gt;gl.lib&lt;/code&gt; (seguido de &lt;code&gt;libgl.lib&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">Cuando se usa un motor personalizado que no admite la construcci&amp;oacute;n &lt;code&gt;(?:)&lt;/code&gt; para modificadores en l&amp;iacute;nea, probablemente sea mejor hacer &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify al patr&amp;oacute;n proporcionado, tenga en cuenta que esto crear&amp;aacute; patrones no deseados en casos como:</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">Cuando se usa una firma, los argumentos siguen estando disponibles en la variable de matriz especial &lt;code&gt;@_&lt;/code&gt; , adem&amp;aacute;s de las variables l&amp;eacute;xicas de la firma. Hay una diferencia entre las dos formas de acceder a los argumentos: &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">Al usar cualquiera de estas rutinas (excepto &lt;code&gt;call_argv&lt;/code&gt; ), el programador debe manipular la pila de Perl. Estos incluyen las siguientes macros y funciones:</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">Cuando se usan afirmaciones y negaciones de la vista,todo esto puede ser aún más complicado.Imagine que le gustaría encontrar una secuencia de no-dígitos no seguida por &quot;123&quot;.Podrías tratar de escribir eso como</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">Al usar perl en OS/390 por favor tenga en cuenta que los conjuntos de caracteres EBCDIC y ASCII son diferentes.Ver perlebcdic.pod para más información sobre este tipo de cuestiones de conjuntos de caracteres.Las funciones incorporadas de perl que pueden comportarse de manera diferente bajo EBCDIC también se mencionan en el documento perlport.pod.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">Al usar perldoc en su modo &lt;code&gt;-m&lt;/code&gt; (mostrar el c&amp;oacute;digo fuente del m&amp;oacute;dulo), &lt;code&gt;perldoc&lt;/code&gt; intentar&amp;aacute; usar el paginador configurado en &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . Una configuraci&amp;oacute;n &amp;uacute;til para este comando es su editor favorito como en &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (No me juzgues.)</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">Al utilizar el protocolo &quot;syn&quot;,utilice este método para determinar la accesibilidad del anfitrión remoto.Este método está pensado para ser llamado hasta tantas veces como se haya llamado a ping().Cada llamada devuelve el host (como pasó a ping())que regresó con el TCP ACK.El orden en el que los hosts son devueltos puede no ser necesariamente el mismo orden en el que fueron puestos en cola SYN usando el método ping().Si se alcanza el timeout antes de que se reciba el TCP ACK,o si el host remoto no está escuchando en el puerto intentado,entonces la conexión TCP no se establecerá y ack()devolverá undef.En el contexto de la lista,el host,el tiempo de ack y la cadena ip punteada se devolverán en lugar de sólo el host.Si se especifica el argumento opcional $host,el valor de retorno será correspondiente sólo a ese host.Esta llamada simplemente no hace nada si se utiliza cualquier otro protocolo que no sea syn.</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">Al usar el prototipo &lt;code&gt;+&lt;/code&gt; , su funci&amp;oacute;n debe verificar que el argumento sea de un tipo aceptable.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">Cuando se usa el compilador de Borland, el segundo elemento se devuelve como &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; , y MakeMaker se encarga de mover &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; al lugar correcto en la l&amp;iacute;nea de comandos del enlazador.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">Cuando use la versión GUI de SAM,haga clic en el icono de configuración del núcleo y luego en el icono de parámetros configurables.Desplácese hacia abajo y seleccione la línea de tamaño máximo.En el menú Acciones,seleccione el elemento Modificar parámetros configurables.Inserte la nueva fórmula en el cuadro Fórmula/Valor.Luego siga las instrucciones para reconstruir el núcleo y reiniciar el sistema.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">Cuando se utiliza el compilador Visual C, el segundo elemento se devuelve como &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">Al usar las constantes, si no quiere tener que recordar agregar el &lt;code&gt;, RESET&lt;/code&gt; al final de cada l&amp;iacute;nea de impresi&amp;oacute;n, puede establecer $ Term :: ANSIColor :: AUTORESET en un valor verdadero. Entonces, el modo de visualizaci&amp;oacute;n se restablecer&amp;aacute; autom&amp;aacute;ticamente si no hay coma despu&amp;eacute;s de la constante. En otras palabras, con ese conjunto de variables:</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">Cuando se utiliza este compilador para construir Perl,hay que asegurarse de que la bandera -Aa se añade a las variables cpprun y cppstdin en el archivo config.sh (aunque véase la sección sobre perl de 64 bits más abajo).Si está usando una versión reciente de la distribución Perl,estas banderas se establecen automáticamente.</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">Al verificar una cadena de resumen existente, debe usar el resumen como la sal (como &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). La SAL utilizada para crear el resumen es visible como parte del resumen. Esto asegura que crypt () procesar&amp;aacute; la nueva cadena con la misma sal que el resumen. Esto permite que su c&amp;oacute;digo funcione con la &lt;a href=&quot;crypt&quot;&gt;cripta&lt;/a&gt; est&amp;aacute;ndar y con implementaciones m&amp;aacute;s ex&amp;oacute;ticas. En otras palabras, no asuma nada sobre la cadena devuelta en s&amp;iacute; ni sobre cu&amp;aacute;ntos bytes de SALT pueden importar.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">Al verificar una cadena de resumen existente, debe usar el resumen como la sal (como &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). La SAL utilizada para crear el resumen es visible como parte del resumen. Esto asegura que crypt () procesar&amp;aacute; la nueva cadena con la misma sal que el resumen. Esto permite que su c&amp;oacute;digo funcione con la &lt;a href=&quot;#crypt&quot;&gt;cripta&lt;/a&gt; est&amp;aacute;ndar y con implementaciones m&amp;aacute;s ex&amp;oacute;ticas. En otras palabras, no asuma nada sobre la cadena devuelta en s&amp;iacute; ni sobre cu&amp;aacute;ntos bytes de SALT pueden importar.</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">Cuando bendecimos algo,no estamos bendiciendo la variable que contiene una referencia a esa cosa,ni estamos bendiciendo la referencia que la variable almacena;estamos bendiciendo la cosa a la que la variable se refiere (a veces conocida como la</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">Cuando llamamos a &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; una variable, en realidad estamos bendiciendo la estructura de datos subyacente a la que se refiere la variable. No estamos bendiciendo la referencia en s&amp;iacute;, ni la variable que contiene esa referencia. Es por eso que la segunda llamada a &lt;code&gt;blessed( $bar )&lt;/code&gt; devuelve falso. En ese momento, &lt;code&gt;$bar&lt;/code&gt; ya no almacena una referencia a un objeto.</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">Cuando hacemos una llamada a un m&amp;eacute;todo, Perl organiza que el &lt;b&gt;invocador&lt;/b&gt; del m&amp;eacute;todo se pase como primer argumento. &lt;b&gt;Invocante&lt;/b&gt; es un nombre elegante para la cosa en el lado izquierdo de la flecha. El invocante puede ser un nombre de clase o un objeto. Tambi&amp;eacute;n podemos pasar argumentos adicionales al m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">Cuando decimos &quot;Mac OS&quot; abajo,nos referimos a Mac OS 7,8 y 9,y</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">Cuando queremos colocar los valores a devolver al llamante en la pila,usamos la serie de macros que comienzan con &quot;XPUSH&quot;.Hay cinco versiones diferentes,para colocar números enteros,números enteros sin signo,dobles,cadenas y escalares de Perl en la pila.En nuestro ejemplo,colocamos un escalar de Perl en la pila.(De hecho,esta es la única macro que puede ser usada para devolver múltiples valores).</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">Cuando se encuentran palabras que tienen m&amp;aacute;s de &lt;code&gt;$columns&lt;/code&gt; , se dividen. &lt;code&gt;wrap()&lt;/code&gt; agrega un &lt;code&gt;&quot;\n&quot;&lt;/code&gt; en la columna &lt;code&gt;$columns&lt;/code&gt; . Este comportamiento se puede anular configurando &lt;code&gt;$huge&lt;/code&gt; en 'morir' o en 'desbordar'. Cuando se establece en 'morir', las palabras grandes har&amp;aacute;n que se llame a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . Cuando se establece en 'desbordamiento', las palabras grandes se dejar&amp;aacute;n intactas.</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">Cuando se escribe un filtro DBM es</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">Cuando se escribe una extensión de Perl para consumo general,se debe esperar que la extensión se utilice con versiones de Perl diferentes de la versión disponible en su máquina.Ya que está leyendo este documento,la versión de Perl en su máquina es probablemente la 5.005 o posterior,pero los usuarios de su extensión pueden tener versiones más antiguas.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">Al escribir un car&amp;aacute;cter UV en una cadena UTF-8, utilice &lt;b&gt;siempre &lt;/b&gt; &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , a menos que &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; en cuyo caso puede utilizar &lt;code&gt;*s = uv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">Al escribir un archivo gzip esta interfaz</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">Al escribir en un archivo o &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; archivo, configure binmode antes de escribir en el archivo.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">Cuando tú</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">Cuando te conformes con la lista de sospechosos,ahora puedes</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">Cuando termines,el proceso de instalación del módulo XS habrá añadido información a tu información &quot;perllocal&quot; diciendo que el binario perl ha sido reemplazado,y qué módulo fue instalado.Puedes ver esta información en cualquier momento usando el comando:</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">Cuando vaya a utilizar el compilador GNU C (gcc) y a&amp;uacute;n no tenga gcc, puede compilarlo usted mismo a partir de las fuentes (disponibles en, por ejemplo, &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) o busque un archivo binario predise&amp;ntilde;ado del centro de migraci&amp;oacute;n de HP en &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; o del DSPP (debe ser miembro) en &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r1002_usen_lec-&lt;/a&gt; lista de versiones disponibles del mismo paquete, porque a menudo hay varias versiones disponibles del paquete.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">Cuando se crea manualmente un archivo UCM,se debe copiar ascii.ucm o una codificación existente cercana a la suya,en lugar de escribir la suya propia desde cero.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">Cuando esté satisfecho con los resultados de las pruebas,instale las bibliotecas de construcción C para las extensiones:</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">Cuando est&amp;eacute; seguro de que s&amp;oacute;lo unos pocos subdirectorios producir fallos, es posible que desee agregar &lt;code&gt;-j4&lt;/code&gt; opci&amp;oacute;n de &lt;code&gt;make&lt;/code&gt; para acelerar saltar subdirectorios con la construcci&amp;oacute;n ya terminada.</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">Cuando est&amp;aacute; utilizando el protocolo &quot;stream&quot;, esta llamada abre previamente el socket tcp. Solo es necesario hacer esto si desea proporcionar un tiempo de espera diferente al crear la conexi&amp;oacute;n o eliminar la sobrecarga de establecer la conexi&amp;oacute;n desde el primer ping. Si no llama a &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , la conexi&amp;oacute;n se abre autom&amp;aacute;ticamente la primera vez que se llama a &lt;code&gt;ping()&lt;/code&gt; . Esta llamada simplemente no hace nada si est&amp;aacute; utilizando un protocolo que no sea stream.</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">Cuando construya módulos,dígale a Perl dónde instalarlos.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">Cuando llamas a &lt;code&gt;bar&lt;/code&gt; con argumentos, ves que &lt;code&gt;foo&lt;/code&gt; tiene el mismo &lt;code&gt;@_&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">Cuando llama a un m&amp;eacute;todo, lo que est&amp;aacute; en el lado izquierdo de la flecha se pasa como el primer argumento del m&amp;eacute;todo. Eso significa que cuando llamamos &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;new()&lt;/code&gt; recibe la cadena &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; como su primer argumento. Cuando llamamos a &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , la variable &lt;code&gt;$fred&lt;/code&gt; se pasa como el primer argumento para &lt;code&gt;speak()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">Cuando cambia un &lt;b&gt;valor&lt;/b&gt; mientras se est&amp;aacute; copiando. [Del franc&amp;eacute;s &quot;de paso&quot;, como en la ex&amp;oacute;tica maniobra de captura de peones en el ajedrez.]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">Cuando cortas un objeto matemático,se convierte en una cuerda y se pierden sus propiedades matemáticas.Lo mismo puede suceder con otras operaciones también.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">Cuando se combinan datos heredados y Unicode,los datos heredados deben actualizarse a Unicode.Normalmente,se supone que los datos heredados son ISO 8859-1 (o EBCDIC,si procede).</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">Cuando crea un mapa, DEBE hacer que sus asignaciones de ida y vuelta sean seguras. Es decir, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; representa todos los caracteres que est&amp;aacute;n marcados como &lt;code&gt;|0&lt;/code&gt; . He aqu&amp;iacute; c&amp;oacute;mo asegurarse:</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">Cuando declara una constante como &lt;code&gt;PI&lt;/code&gt; usando el m&amp;eacute;todo que se muestra arriba, cada m&amp;aacute;quina en la que se ejecuta su script puede tener tantos d&amp;iacute;gitos de precisi&amp;oacute;n como pueda usar. Adem&amp;aacute;s, su programa ser&amp;aacute; m&amp;aacute;s f&amp;aacute;cil de leer, ser&amp;aacute; m&amp;aacute;s probable que se mantenga (y se mantenga correctamente) y mucho menos probable que env&amp;iacute;e una sonda espacial al planeta equivocado porque nadie not&amp;oacute; la &amp;uacute;nica ecuaci&amp;oacute;n en la que escribi&amp;oacute; &lt;code&gt;3.14195&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">Cuando descifras(=?)</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">Cuando decodifica, se inserta &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; para un car&amp;aacute;cter con formato incorrecto, donde</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">Cuando haces $ parser-&amp;gt; get_token en un objeto &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , es posible que obtengas un objeto de esta clase.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">Cuando haces $ parser-&amp;gt; get_token en un &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , es posible que obtengas un objeto de esta clase.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">Cuando haces $ parser-&amp;gt; get_token en un &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , debes obtener un objeto de una subclase de Pod :: Simple :: PullParserToken.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">Cuando haces un open()y especificas capas extra de PerlIO para ser desplegadas,las capas que especificas son &quot;empujadas&quot; sobre la pila ya existente por defecto.Una forma de verlo es que &quot;el sistema operativo está a la izquierda&quot; y &quot;Perl está a la derecha&quot;.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">Cuando lo haga, aseg&amp;uacute;rese de dejar al menos &lt;b&gt;U0000&lt;/b&gt; a &lt;b&gt;U0020&lt;/b&gt; como est&amp;aacute;, a menos que su entorno sea EBCDIC.</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">Cuando hace esto, reemplaza las operaciones de Perl ordinarias con operaciones personalizadas creando operaciones con el tipo &lt;code&gt;OP_CUSTOM&lt;/code&gt; y el &lt;code&gt;op_ppaddr&lt;/code&gt; de su propia funci&amp;oacute;n PP. Esto se debe definir en el c&amp;oacute;digo XS, y debe ser similar a las operaciones del PP en &lt;code&gt;pp_*.c&lt;/code&gt; . Usted es responsable de asegurarse de que su operaci&amp;oacute;n tome la cantidad adecuada de valores de la pila, y es responsable de agregar marcas de pila si es necesario.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">Cuando codificas,sólo codifica la cadena UTF-8 con</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">Cuando ejecutas este guión,Perl crea un flujo de origen para el archivo.Antes de que el analizador procese cualquiera de las líneas del archivo,el flujo fuente tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">Cuando se canse de escribir una impresi&amp;oacute;n personalizada para sus estructuras de datos, puede mirar los &lt;a href=&quot;dumpvalue&quot;&gt;m&amp;oacute;dulos Dumpvalue&lt;/a&gt; o &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; est&amp;aacute;ndar . El primero es lo que utiliza el depurador de Perl, mientras que el segundo genera c&amp;oacute;digo Perl analizable. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Cuando tienes el Módulo::Build instalado y un módulo viene con un Makefile.PL y un Build.PL,que tendrán prioridad...</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Cuando tienes instalado Term::ANSIColor,puedes activar la salida coloreada para tener algunas diferencias visuales entre la salida normal del CPAN.pm,las advertencias,la salida de depuración y la salida de los módulos que se están instalando.Establezca sus colores favoritos después de experimentar con el módulo Term::ANSIColor.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">Cuando tiene una cadena &lt;code&gt;$normalized&lt;/code&gt; y una cadena &lt;code&gt;$unnormalized&lt;/code&gt; continuaci&amp;oacute;n, una simple concatenaci&amp;oacute;n es incorrecta:</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">Cuando tenga una entrada duplicada,marque una con '|1' o '|3'.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">Cuando enumeras los argumentos del XSUB en el archivo &lt;b&gt;.xs&lt;/b&gt; , eso le dice a &lt;b&gt;xsubpp&lt;/b&gt; qu&amp;eacute; argumento corresponde a cu&amp;aacute;l de la pila de argumentos (es decir, el primero en la lista es el primer argumento, y as&amp;iacute; sucesivamente). Invita al desastre si no los enumera en el mismo orden en que la funci&amp;oacute;n los espera.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">Cuando crea un script ejecutable, para que se pueda usar como comando, el sistema pasar&amp;aacute; los conmutadores a perl desde el # del script. l&amp;iacute;nea. Perl verifica que cualquier cambio de l&amp;iacute;nea de comando dado a un script setuid (o setgid) realmente coincida con los establecidos en el #! l&amp;iacute;nea. Algunos entornos Unix y similares a Unix imponen un l&amp;iacute;mite de un interruptor en el #! line, por lo que es posible que deba usar algo como &lt;code&gt;-wU&lt;/code&gt; en lugar de &lt;code&gt;-w -U&lt;/code&gt; en tales sistemas. (Este problema solo deber&amp;iacute;a surgir en entornos Unix o similares a Unix que admitan los scripts #! Y setuid o setgid).</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">Cuando anula una funci&amp;oacute;n incorporada, su reemplazo debe ser coherente (si es posible) con la sintaxis nativa incorporada. Puede lograrlo utilizando un prototipo adecuado. Para obtener el prototipo de un incorporado reemplazable, use la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; con un argumento de &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (ver &lt;a href=&quot;functions/prototype&quot;&gt;prototipo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">Cuando se reemplaza esta variable,se considera una buena práctica almacenar el gancho posiblemente instalado previamente y que lo recuerde dentro del suyo propio.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Cuando ejecutas Makefile.PL,se hace un Makefile.Ese es el objetivo de MakeMaker.El Makefile.PL es un simple programa que carga ExtUtils::MakeMaker y ejecuta la función WriteMakefile()para generar un Makefile.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Cuando ejecutas un script Perl,algo más está ejecutando el script por ti,y ese algo más puede producir mensajes de error.El script puede emitir sus propias advertencias y mensajes de error.La mayoría de las veces no puedes saber quién dijo qué.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">Cuando ejecutas este programa,deberías obtener algo que se parezca a esto:</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">Cuando dices &quot;hacer la prueba&quot;,Perl usa el</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">Cuando ve &lt;code&gt;charset=gb2312&lt;/code&gt; en correos electr&amp;oacute;nicos y p&amp;aacute;ginas web, realmente se &lt;code&gt;euc-cn&lt;/code&gt; codificaciones euc-cn . Para solucionarlo, &lt;code&gt;gb2312&lt;/code&gt; tiene el alias &lt;code&gt;euc-cn&lt;/code&gt; . Utilice &lt;code&gt;gb2312-raw&lt;/code&gt; cuando realmente lo diga .</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">Cuando vea &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; en correos electr&amp;oacute;nicos y p&amp;aacute;ginas web, realmente significan codificaciones &quot;cp949&quot;. Para solucionarlo, se establecen los siguientes alias;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
