<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">Voorbeelden van hiërarchische vragen</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">Hoge betrouwbaarheid</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">Vraagtaal op hoog niveau</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">Hoogbeveiligde waarde</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">Logica op een hoger niveau binnen SQLite zal normaal gesproken de foutcode onderscheppen en een tijdelijk in-memory gedeeld geheugengebied creëren,zodat het huidige proces op zijn minst de inhoud van de database kan lezen.Deze resultaatcode mag de applicatie-interfacelaag niet bereiken.</target>
        </trans-unit>
        <trans-unit id="c3470dae18bb2ebd19bfc00c07871d83ad9669f4" translate="yes" xml:space="preserve">
          <source>Higher order bits of the mFlags parameter must all be zero for now, though they may be used in future enhancements. The definitions for the constants that specify the datatype and a prototype for the sqlite3_carray_bind() function are both available in the auxiliary header file &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.h&quot;&gt;ext/misc/carray.h&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">Hoogste prioriteit (strakste groepering).</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">Sugerencia: las aplicaciones pueden generar identificadores &amp;uacute;nicos a nivel mundial usando esta funci&amp;oacute;n junto con &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex ()&lt;/a&gt; y / o &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower () de&lt;/a&gt; esta manera:</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">Tips voor het debuggen van SQLite</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">Los casos de prueba hist&amp;oacute;ricos de &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt; , &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt; y &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; se recopilan en un conjunto de archivos de base de datos en el &amp;aacute;rbol de fuentes principal de SQLite y luego el programa de utilidad &quot;fuzzcheck&quot; los vuelve a ejecutar cada vez que se ejecuta &quot;make test&quot;. Fuzzcheck s&amp;oacute;lo ejecuta unos pocos miles de casos &quot;interesantes&quot; de los cientos de millones de casos que los distintos fuzzers han examinado a lo largo de los a&amp;ntilde;os. Los casos &quot;interesantes&quot; son casos que exhiben un comportamiento nunca antes visto. Los errores reales encontrados por fuzzers siempre se incluyen entre los casos de prueba interesantes, pero la mayor&amp;iacute;a de los casos ejecutados por fuzzcheck nunca fueron errores reales.</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">Historisch gezien zijn back-ups (kopieën)van SQLite databases gemaakt met behulp van de volgende methode:</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">Historisch gezien wordt de bytecode-engine in SQLite de &quot;Virtual DataBase Engine&quot; of &quot;VDBE&quot; genoemd.Deze website gebruikt de termen &quot;bytecode engine&quot;,&quot;VDBE&quot;,&quot;virtual machine&quot; en &quot;bytecode virtual machine&quot; door elkaar,omdat ze allemaal hetzelfde betekenen.</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">Hist&amp;oacute;ricamente, el valor de retorno de xFindFunction () era cero o uno. Cero significa que la funci&amp;oacute;n no est&amp;aacute; sobrecargada y uno significa que est&amp;aacute; sobrecargada. La capacidad de devolver valores de &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; o superior se agreg&amp;oacute; en la versi&amp;oacute;n 3.25.0 (2018-09-15). Si xFindFunction devuelve &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; o mayor, significa que la funci&amp;oacute;n toma dos argumentos y la funci&amp;oacute;n se puede usar como un booleano en la cl&amp;aacute;usula WHERE de una consulta y que la tabla virtual puede explotar esa funci&amp;oacute;n para acelerar el resultado de la consulta. Cuando xFindFunction devuelve &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; o mayor, el valor devuelto se convierte en el valor sqlite3_index_info.aConstraint.op para una de las restricciones pasadas a &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt;y el segundo argumento se convierte en el valor correspondiente a esa restricci&amp;oacute;n que se pasa a &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter ()&lt;/a&gt; . Esto permite que las implementaciones de xBestIndex () / xFilter usen la funci&amp;oacute;n para acelerar su b&amp;uacute;squeda.</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">Historisch gezien werd dit niet als een bedreiging beschouwd.Het argument was dat als een vijandige agent in staat is om willekeurige SQL-tekst in de applicatie te injecteren,dan is die agent al de volledige controle over de applicatie,dus als de vijandige agent een aanwijzer laat smeden,geeft dat de agent geen nieuwe mogelijkheden.</target>
        </trans-unit>
        <trans-unit id="edbba65b70f80d24828e3ecb61299d246e18a100" translate="yes" xml:space="preserve">
          <source>Honor all people.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">Eer alles.</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">Honre el indicador &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; , que se describi&amp;oacute; anteriormente en la documentaci&amp;oacute;n, pero anteriormente no era operativo .</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">Eer de ORDER BY en LIMIT clausule van een SELECT,zelfs als de resultatenset wordt gebruikt voor een INSERT.</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">Hostparameternamen kunnen beginnen met '@' voor compatibiliteit met SQL Server.</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">Hot Journal Detectie</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">Hot Journal terugdraaien</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">Hot journal-bestanden</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">Terugdraaiing van het warmtedagboek</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">C&amp;oacute;mo funciona la &lt;a href=&quot;queryplanner&quot;&gt;indexaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">Hoe Memory-Gemapte I/O werkt</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">Hoe SQLite wordt getest</target>
        </trans-unit>
        <trans-unit id="bc4f776f31c05645db10ae6924aaa639f110450f" translate="yes" xml:space="preserve">
          <source>How SQLite Works</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">Hoe SQLite te compileren</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">Hoe te corrigeren</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">Hoe kan ik een SQLite databestand corrigeren?</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">Hoe corrigeert u uw databasebestanden?</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">Hoe kan ik de Canonical SQLite broncode downloaden?</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">Hoe VACUUM werkt</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">Hoe worden de syntaxisdiagrammen (a.k.a.&quot;railroad&quot; diagrammen)voor SQLite gegenereerd?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">Hoe wordt de collatie bepaald?</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">Hoe voeg ik kolommen toe of verwijder ik ze uit een bestaande tabel in SQLite.</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">Hoe maak ik een AUTOINCREMENT-veld aan?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">Hoe kan ik alle tabellen/indices in een SQLite database opsommen?</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">Hoe gebruik ik letterlijk een string die een ingesloten single-quote (')karakter bevat?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">Hoeveel uitvoerbare bestanden bevinden zich in het archief?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">Hoe het vacuüm werkt</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">Echter,client/server database engines (zoals PostgreSQL,MySQL,of Oracle)ondersteunen meestal een hoger niveau van gelijktijdigheid en staan toe dat meerdere processen tegelijkertijd naar dezelfde database schrijven.Dit is mogelijk in een client/server-database omdat er altijd één goed gecontroleerd serverproces beschikbaar is om de toegang te coördineren.Als uw applicatie veel gelijktijdigheid nodig heeft,dan moet u overwegen om een client/server-database te gebruiken.Maar de ervaring leert dat de meeste applicaties veel minder gelijktijdigheid nodig hebben dan hun ontwerpers zich voorstellen.</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">Bij een query in &quot;ingeperkt-in&quot; stijl kan het afronden van de begrenzingsvakken naar buiten toe ertoe leiden dat sommige vermeldingen niet in het resultaat worden opgenomen als de rand van het invoervak overeenkomt met de rand van het invoervak dat wordt begrensd door een query.Om dit te voorkomen,moeten de toepassingen hun inhoudsopgave in de queryboxen iets uitbreiden (met 0,000012%)door de onderste coördinaten naar beneden af te ronden en de bovenste coördinaten naar boven af te ronden,in elke dimensie.</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">Het is echter mogelijk dat sterk afgestemde en gespecialiseerde toepassingen sommige van de ingebouwde systeeminterfaces van SQLite willen of moeten vervangen door alternatieve implementaties die meer geschikt zijn voor de behoeften van de applicatie.SQLite is ontworpen om gemakkelijk opnieuw te worden geconfigureerd tijdens de compileertijd om te voldoen aan de specifieke behoeften van individuele projecten.Onder de compile-time-configuratieopties voor SQLite zijn deze:</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">Echter,als een</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">Sin embargo, si una implementaci&amp;oacute;n de &lt;a href=&quot;vtab&quot;&gt;tabla virtual&lt;/a&gt; crea tablas reales (a veces denominadas tablas &quot;sombra&quot;) dentro de la base de datos para almacenar sus datos, entonces sqldiff.exe calcula la diferencia entre ellas. Esto puede tener efectos sorprendentes si el script SQL resultante se ejecuta en una base de datos que no</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">Echter,als een database veel gelijktijdige overlappende lezers heeft en er altijd minstens één actieve lezer is,dan zal geen enkel controlepunt in staat zijn om te voltooien en dus zal het WAL-bestand onbeperkt groeien.</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">Als echter in-memory database pInMemory net is geopend (en dus volledig leeg is)voordat het wordt doorgegeven aan de functie loadOrSaveDb(),dan is het nog steeds mogelijk om de paginagrootte te wijzigen met behulp van een SQLite &quot;PRAGMA page_size&quot; commando.Functie loadOrSaveDb()zou dit geval kunnen detecteren,en proberen de paginagrootte van de in-memory database in te stellen op de paginagrootte van de database zFilename voordat de online backup API functies worden aangeroepen.</target>
        </trans-unit>
        <trans-unit id="c8346bf2feca974b5d3d774b0dd2cf9e7396c3aa" translate="yes" xml:space="preserve">
          <source>However, most CVEs written against SQLite flippantly assume that an attacker is free to run any arbitrary SQL in the database engine. So to a good approximation, this means most CVEs written against SQLite really only apply to SQLite as it is used in Chrome and Safari. Or, in other words, most CVEs for SQLite do not apply to you unless you are one of the developers of Chrome or Safari.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39757386af6ee77e7f7c27742f0c4303b1680cd5" translate="yes" xml:space="preserve">
          <source>However, the SQLite developers do not track CVEs. There are various reasons for this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">Sin embargo, la aplicaci&amp;oacute;n debe garantizar que la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino no se pase a ninguna otra API (por ning&amp;uacute;n hilo) despu&amp;eacute;s de que se llame a sqlite3_backup_init () y antes de la llamada correspondiente a sqlite3_backup_finish (). Actualmente, SQLite no verifica si la aplicaci&amp;oacute;n accede incorrectamente a la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino y, por lo tanto, no se informa ning&amp;uacute;n c&amp;oacute;digo de error, pero las operaciones pueden funcionar mal. El uso de la conexi&amp;oacute;n de la base de datos de destino mientras se realiza una copia de seguridad tambi&amp;eacute;n puede causar un interbloqueo de mutex.</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">Sin embargo, la aplicaci&amp;oacute;n debe garantizar que la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino no se pase a ninguna otra API (por ning&amp;uacute;n hilo) despu&amp;eacute;s de que se llame a sqlite3_backup_init () y antes de la llamada correspondiente a sqlite3_backup_finish (). Actualmente, SQLite no verifica si la aplicaci&amp;oacute;n accede incorrectamente a la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino y, por lo tanto, no se informa ning&amp;uacute;n c&amp;oacute;digo de error, pero las operaciones pueden funcionar mal. El uso de la conexi&amp;oacute;n de la base de datos de destino mientras se realiza una copia de seguridad tambi&amp;eacute;n puede causar un interbloqueo de mutex.</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">Sin embargo, el &amp;aacute;rbol b para una tabla &lt;a href=&quot;withoutrowid&quot;&gt;SIN ROWID&lt;/a&gt; tiene el mismo formato que un &amp;aacute;rbol b de &amp;iacute;ndice. Por lo tanto, se puede acceder a un &amp;aacute;rbol b de &amp;iacute;ndice como si fuera una tabla SIN ROWID.</target>
        </trans-unit>
        <trans-unit id="587a4ce8c5eaeede93486cce8a7a8544b112f279" translate="yes" xml:space="preserve">
          <source>However, there are some occasions where an application does need to be able to safely run untrusted SQL. The SQLite developers work hard to make SQLite safe for this purpose, though there are occasional slip-ups. It is good to keep up-to-date with the latest patches in this case. The separate &lt;a href=&quot;security&quot;&gt;defense against dark arts&lt;/a&gt; document contains additional suggestions that can help prevent zero-day attacks in cases where SQLite is given inputs that come directly from untrusted sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">Cientos de tablas virtuales que publican varios aspectos de la computadora host, como la tabla de procesos, listas de usuarios, conexiones de red activas, etc. OsQuery es un proyecto separado, iniciado por Facebook, alojado en &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt; y destinado al an&amp;aacute;lisis de seguridad y la detecci&amp;oacute;n de intrusiones OsQuery no es parte del proyecto SQLite, pero est&amp;aacute; incluido en esta lista porque demuestra c&amp;oacute;mo el lenguaje SQL y la tabla virtual SQLite El mecanismo se puede aprovechar para proporcionar soluciones elegantes a problemas importantes del mundo real.</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">Ik heb per ongeluk wat belangrijke informatie uit mijn SQLite database verwijderd.Hoe kan ik het herstellen?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">Me han dicho que los usuarios de Git suelen instalar visores gr&amp;aacute;ficos de terceros para Git, muchos de los cuales muestran mejor la actividad reciente del proyecto. Eso es genial, pero estas son a&amp;uacute;n m&amp;aacute;s aplicaciones de terceros que deben instalarse y administrarse por separado. Muchos son espec&amp;iacute;ficos de la plataforma. (Uno de los mejores, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt; , solo funciona en Mac, por ejemplo). Todos requieren que primero sincronices tu repositorio local y luego muestres su interfaz gr&amp;aacute;fica en tu escritorio. E incluso con todo eso, todav&amp;iacute;a no puedo ver lo que normalmente quiero ver sin varios clics. Verificar el estado del proyecto desde un tel&amp;eacute;fono mientras est&amp;aacute; fuera de la oficina no es una opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">Me dicen que la configuración por defecto de PostgreSQL en RedHat 7.3 es innecesariamente conservadora (está diseñada para trabajar en una máquina con 8MB de RAM)y que PostgreSQL podría ser hecho para correr mucho más rápido con algún ajuste de configuración bien informado.Matt Sergeant reporta que ha afinado su instalación de PostgreSQL y ha vuelto a ejecutar las pruebas que se muestran a continuación.Sus resultados muestran que PostgreSQL y MySQL se ejecutan más o menos a la misma velocidad.Para ver los resultados de Matt,visite</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">Borré muchos datos,pero el archivo de la base de datos no se redujo.¿Esto es un error?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">Me da un error de compilación si uso las opciones de tiempo de compilación de SQLITE_OMIT_...cuando construyo SQLite.</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">Recibo algunas advertencias del compilador cuando compilo SQLite.¿No es esto un problema? ¿No indica una mala calidad del código?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">La prueba de error de E / S es similar en concepto a la prueba OOM; Los errores de E / S se simulan y se realizan comprobaciones para verificar que SQLite responde correctamente a los errores simulados. Los errores de E / S se simulan en los arneses de prueba de TCL y TH3 insertando un nuevo &lt;a href=&quot;c3ref/vfs&quot;&gt;objeto de sistema de archivos virtual&lt;/a&gt; que est&amp;aacute; especialmente dise&amp;ntilde;ado para simular un error de E / S despu&amp;eacute;s de un n&amp;uacute;mero determinado de operaciones de E / S. Al igual que con las pruebas de errores OOM, los simuladores de errores de E / S se pueden configurar para que fallen solo una vez o para que fallen continuamente despu&amp;eacute;s del primer fallo. Las pruebas se ejecutan en un bucle, aumentando lentamente el punto de falla hasta que el caso de prueba se completa sin errores. El bucle se ejecuta dos veces, una vez con el simulador de errores de E / S configurado para simular solo una falla y una segunda vez configurada para fallar todas las operaciones de E / S despu&amp;eacute;s de la primera falla.</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">Las pruebas de error de E/S buscan verificar que SQLite responde sanamente a las operaciones de E/S fallidas.Los errores de E/S pueden deberse a una unidad de disco llena,a un mal funcionamiento del hardware del disco,a interrupciones en la red al utilizar un sistema de archivos de red,a cambios en la configuración del sistema o en los permisos que se producen en medio de una operación de SQL,o a otros fallos del hardware o del sistema operativo.Cualquiera que sea la causa,es importante que SQLite sea capaz de responder correctamente a estos errores y las pruebas de errores de E/S tratan de verificar que así sea.</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">Pruebas de error de E/S</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">Los errores de E/S en la interfaz del sistema operativo generan eventos de registro de errores.El mensaje a estos eventos da el número de línea en el código fuente donde se originó el error y el nombre de archivo asociado al evento cuando hay un archivo correspondiente.</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">El rendimiento de E / S se mide utilizando el programa &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; del &amp;aacute;rbol de fuentes de SQLite. Para compilar este programa de prueba, primero re&amp;uacute;na el archivo fuente kvtest.c en un directorio con los archivos fuente de &lt;a href=&quot;amalgamation&quot;&gt;fusi&amp;oacute;n de SQLite&lt;/a&gt; &quot;sqlite3.c&quot; y &quot;sqlite3.h&quot;. Luego, en Unix, ejecute un comando como el siguiente:</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">El rendimiento de E/S varía mucho dependiendo del sistema operativo y el hardware.Haga sus propias mediciones antes de sacar conclusiones.</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">si existen y si no existen cláusulas sobre CREAR/ELIMINAR TABLA/INDICE.</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="3b63a4da1415c242da17f132d0e00d086153fa66" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">INMEDIATO hace que la conexi&amp;oacute;n a la base de datos comience una nueva escritura inmediatamente, sin esperar una instrucci&amp;oacute;n de escritura. BEGIN IMMEDIATE puede fallar con &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; si otra transacci&amp;oacute;n de escritura ya est&amp;aacute; activa en otra conexi&amp;oacute;n de base de datos.</target>
        </trans-unit>
        <trans-unit id="a4db76ad8831e1ebbbc52031b1ae484c99975878" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f10a7701656ba82f20f9690db33f263b9944c35" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">IMPORTANTE: El campo EstimadoRows se agreg&amp;oacute; a la estructura sqlite3_index_info para SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;versi&amp;oacute;n 3.8.2&lt;/a&gt; (2013-12-06). Si se utiliza una extensi&amp;oacute;n de tabla virtual con una versi&amp;oacute;n de SQLite anterior a la 3.8.2, los resultados de intentar leer o escribir el campo EstimadasRows no est&amp;aacute;n definidos (pero es probable que incluyan el bloqueo de la aplicaci&amp;oacute;n). Por lo tanto, el campo EstimadoRows solo debe usarse si &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; devuelve un valor mayor o igual que 3008002. De manera similar, el campo idxFlags se agreg&amp;oacute; para la &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;versi&amp;oacute;n 3.9.0&lt;/a&gt; (2015-10-14). Por lo tanto, solo se puede usar si sqlite3_libversion_number () devuelve un valor mayor o igual que 3009000.</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">IMPORTANTE: El campo EstimadoRows se agreg&amp;oacute; a la estructura sqlite3_index_info para SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;versi&amp;oacute;n 3.8.2&lt;/a&gt; (2013-12-06). Si se utiliza una extensi&amp;oacute;n de tabla virtual con una versi&amp;oacute;n de SQLite anterior a la 3.8.2, los resultados de intentar leer o escribir el campo EstimadasRows no est&amp;aacute;n definidos (pero es probable que incluyan el bloqueo de la aplicaci&amp;oacute;n). Por lo tanto, el campo EstimadoRows solo debe usarse si &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; devuelve un valor mayor o igual que 3008002. De manera similar, el campo idxFlags se agreg&amp;oacute; para la &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;versi&amp;oacute;n 3.9.0&lt;/a&gt; (2015-10-14). Por lo tanto, solo se puede usar si sqlite3_libversion_number () devuelve un valor mayor o igual que 3009000.</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">Operador IN</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">INDICADO POR</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">INSERTE los cambios</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERTA EN LOS VALORES DE DEMO2(comando)(&quot;reset&quot;);</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">INSERTAR EN t1 SELECCIONAR b,a,c DE t2;</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">INSERTAR EN VALORES t1 (1.10719,'diez mil setecientos diecinueve');</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">INSERTAR EN VALORES t1 (1.13153,'trece mil ciento cincuenta y tres');</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">INSERTAR EN VALORES t1 (1000,94142,'noventa y cuatro mil ciento cuarenta y dos');</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">INSERTAR EN VALORES t1 (11999,72836,'setenta y dos mil ochocientos treinta y seis');</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">INSERTAR EN VALORES t1 (12000,64231,'sesenta y cuatro mil doscientos treinta y uno');</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">INSERTAR EN VALORES t1 (2.75560,'setenta y cinco mil quinientos sesenta');</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">INSERTAR EN VALORES t1 (998,66289,'sesenta y seis mil doscientos ochenta y nueve');</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">INSERTAR EN VALORES t1 (999.24322,'veinticuatro mil trescientos veintidós');</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">INSERTAR EN t2 SELECCIONAR*DE t1;</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">INSERTAR EN t2 SELECCIONAR b,a,c DE t1;</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">INSERTAR EN VALORES t2 (1.59672,'cincuenta y nueve mil seiscientos setenta y dos');</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">INSERTAR EN VALORES t2 (24999,89569,'ochenta y nueve mil quinientos sesenta y nueve');</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">INSERTAR EN VALORES t2 (25000,94666,'noventa y cuatro mil seiscientos sesenta y seis');</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">INSERTAR EN VALORES t3 (24999,88509,'ochenta y ocho mil quinientos nueve');</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">INSERTAR EN VALORES t3 (25000,84791,'ochenta y cuatro mil setecientos noventa y uno');</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">INSERTA EN LA PESTAÑA 1 VALORES (?,?,?);</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERTAR EN VALORES xyz(xyz)('automerge=N');</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">INSERTAR EN VALORES xyz(xyz)('comprobación de integridad');</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERTAR EN VALORES xyz(xyz)('fusionar=X,Y');</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERTAR EN VALORES xyz(xyz)('optimizar');</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERTAR EN VALORES xyz(xyz)('reconstruir');</target>
        </trans-unit>
        <trans-unit id="631e931c19e40aa3da1ce6f0902d43d9a508af25" translate="yes" xml:space="preserve">
          <source>INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERTAR es muy lento.Sólo puedo hacer unas pocas docenas de INSERTARES por segundo.</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">INSERTAR se ejecuta un poco más rápido cuando la fuente es una declaración SELECT.</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">INSTALACIÓN DEL DISPOSITIVO</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">ENTRADA DE LOS DESACTIVADORES</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">Las columnas INTEGER PRIMARY KEY se pueden utilizar para implementar el equivalente de AUTOINCREMENT. Si intenta insertar un NULL en una columna INTEGER PRIMARY KEY, la columna en realidad se llenar&amp;aacute; con un n&amp;uacute;mero entero mayor que la clave m&amp;aacute;s grande que ya est&amp;aacute; en la tabla. O si la clave m&amp;aacute;s grande es 2147483647, la columna se llenar&amp;aacute; con un n&amp;uacute;mero entero aleatorio. De cualquier manera, a la columna INTEGER PRIMARY KEY se le asignar&amp;aacute; un n&amp;uacute;mero entero &amp;uacute;nico. Puede recuperar este entero utilizando la funci&amp;oacute;n de API &lt;b&gt;sqlite_last_insert_rowid ()&lt;/b&gt; o utilizando la funci&amp;oacute;n de SQL &lt;b&gt;last_insert_rowid ()&lt;/b&gt; en una sentencia SELECT posterior.</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">NO ES</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">Operador de IS</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">Lo ideal es que todos los cambios de una transacción de escritura completa se almacenen en la memoria intermedia de la página hasta el final de la transacción.Cuando el usuario confirma la transacción,todos los cambios se aplican al archivo de la base de datos de la forma más eficiente posible,teniendo en cuenta los supuestos enumerados en la sección</target>
        </trans-unit>
        <trans-unit id="3aa28748de853653631eccc0d256aed420f0eed1" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a04cc62fe27e532be18f141495602f090fc2e2" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">Identifique todos los m&amp;eacute;todos para objetos importantes en la documentaci&amp;oacute;n de la interfaz. ( &lt;a href=&quot;c3ref/context&quot;&gt;ejemplo&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Si el objeto &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; V se inicializ&amp;oacute; usando &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer (S, I, P, X, D)&lt;/a&gt; o &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; y si X e Y son cadenas que se comparan iguales seg&amp;uacute;n strcmp (X, Y), entonces sqlite3_value_pointer (V, Y) devolver&amp;aacute; el puntero P. De lo contrario, sqlite3_value_pointer (V, Y) devolver&amp;aacute; un NULL. La rutina sqlite3_bind_pointer () es parte de la &lt;a href=&quot;bindptr&quot;&gt;interfaz de paso de puntero&lt;/a&gt; agregada para SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Si la interpretaci&amp;oacute;n del &lt;a href=&quot;../uri&quot;&gt;nombre de archivo URI&lt;/a&gt; est&amp;aacute; habilitada y el argumento del nombre de archivo comienza con &quot;archivo:&quot;, entonces el nombre de archivo se interpreta como un URI. La interpretaci&amp;oacute;n del nombre de archivo URI est&amp;aacute; habilitada si el indicador &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; se establece en el tercer argumento en sqlite3_open_v2 (), o si se ha habilitado globalmente usando la opci&amp;oacute;n &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; con el m&amp;eacute;todo &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; o mediante la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; . La interpretaci&amp;oacute;n del nombre de archivo URI est&amp;aacute; desactivada de forma predeterminada, pero las versiones futuras de SQLite pueden habilitar la interpretaci&amp;oacute;n del nombre de archivo URI de forma predeterminada. Consulte &quot; &lt;a href=&quot;../uri&quot;&gt;Nombres de archivo URI&lt;/a&gt; &quot; para obtener informaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">Si &lt;a href=&quot;foreignkeys&quot;&gt;las restricciones de clave externa&lt;/a&gt; est&amp;aacute;n &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;habilitadas&lt;/a&gt; y se agrega una columna con una &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;cl&amp;aacute;usula REFERENCES&lt;/a&gt; , la columna debe tener un valor predeterminado de NULL.</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">Si &lt;a href=&quot;foreignkeys&quot;&gt;las restricciones de clave externa&lt;/a&gt; est&amp;aacute;n habilitadas, un comando DROP TABLE realiza un comando &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; impl&amp;iacute;cito antes de eliminar la tabla del esquema de la base de datos. Cualquier desencadenante adjunto a la tabla se elimina del esquema de la base de datos antes de que se ejecute DELETE FROM impl&amp;iacute;cito, por lo que esto no puede provocar que se active ning&amp;uacute;n desencadenante. Por el contrario, un DELETE FROM impl&amp;iacute;cito provoca cualquier &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;acci&amp;oacute;n de clave externa&lt;/a&gt; configuradatomar lugar. Si el DELETE FROM impl&amp;iacute;cito ejecutado como parte de un comando DROP TABLE viola cualquier restricci&amp;oacute;n de clave externa inmediata, se devuelve un error y la tabla no se elimina. Si el DELETE FROM impl&amp;iacute;cito hace que se viole cualquier restricci&amp;oacute;n de clave externa diferida, y las violaciones a&amp;uacute;n existen cuando se confirma la transacci&amp;oacute;n, se devuelve un error en el momento de la confirmaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">Si &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; se establece en OFF (deshabilitando as&amp;iacute; el archivo de diario de reversi&amp;oacute;n), entonces el comportamiento del comando ROLLBACK no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">Si el &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;modo de bloqueo EXCLUSIVO&lt;/a&gt; se establece antes del primer acceso a la base de datos en modo WAL, entonces SQLite nunca intenta llamar a ninguno de los m&amp;eacute;todos de memoria compartida y, por lo tanto, nunca se crea ning&amp;uacute;n &amp;iacute;ndice de memoria compartida. En ese caso, la conexi&amp;oacute;n de la base de datos permanece en modo EXCLUSIVO siempre que el modo diario sea WAL; los intentos de cambiar el modo de bloqueo usando &quot; &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; &quot; son no-ops. La &amp;uacute;nica forma de salir del modo de bloqueo EXCLUSIVO es salir primero del modo de diario WAL.</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Si la interpretaci&amp;oacute;n del &lt;a href=&quot;uri&quot;&gt;nombre de archivo URI&lt;/a&gt; est&amp;aacute; habilitada y el argumento del nombre de archivo comienza con &quot;archivo:&quot;, entonces el nombre de archivo se interpreta como un URI. La interpretaci&amp;oacute;n del nombre de archivo URI est&amp;aacute; habilitada si el indicador &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; se establece en el tercer argumento en sqlite3_open_v2 (), o si se ha habilitado globalmente usando la opci&amp;oacute;n &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; con el m&amp;eacute;todo &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; o mediante la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; . La interpretaci&amp;oacute;n del nombre de archivo URI est&amp;aacute; desactivada de forma predeterminada, pero las versiones futuras de SQLite pueden habilitar la interpretaci&amp;oacute;n del nombre de archivo URI de forma predeterminada. Consulte &quot; &lt;a href=&quot;uri&quot;&gt;Nombres de archivo URI&lt;/a&gt; &quot; para obtener informaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Si el objeto &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; V se inicializ&amp;oacute; usando &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer (S, I, P, X, D)&lt;/a&gt; o &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; y si X e Y son cadenas que se comparan iguales seg&amp;uacute;n strcmp (X, Y), entonces sqlite3_value_pointer (V, Y) devolver&amp;aacute; el puntero P. De lo contrario, sqlite3_value_pointer (V, Y) devolver&amp;aacute; un NULL. La rutina sqlite3_bind_pointer () es parte de la &lt;a href=&quot;../bindptr&quot;&gt;interfaz de paso de puntero&lt;/a&gt; agregada para SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">Si A &amp;lt;B ENTONCES B&amp;gt; A.</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">Si A &amp;lt;B y B &amp;lt;C, entonces A &amp;lt;C.</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">Si A==B y B==C entonces A==C.</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">Si A==B entonces B==A.</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">Si se activa el AUTOVACUUM,es posible que se mueva otra página raíz a la página raíz recién borrada para mantener todas las páginas raíz contiguas al principio de la base de datos.El valor anterior de la página raíz que se movió-su valor antes de que se produjera el movimiento-se almacena en el registro P2.Si no se requirió ningún movimiento de página (porque la tabla que se eliminó ya era la última de la base de datos)entonces se almacena un cero en el registro P2.Si AUTOVACUUM está desactivado,entonces se almacena un cero en el registro P2.</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">Si CHANGESET_REPLACE es devuelto por un manejador de conflictos SQLITE_CHANGESET_CONFLICT,entonces la fila de conflicto se elimina de la base de datos y se hace un segundo intento de aplicar el cambio.Si este segundo intento falla,la fila original se restaura en la base de datos antes de continuar.</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">Si CHANGESET_REPLACE es devuelto por un manejador de conflictos SQLITE_CHANGESET_DATA,entonces la fila de conflicto es actualizada o eliminada,dependiendo del tipo de cambio.</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">Si F es un puntero NULL,entonces sqlite3_uri_parameter(F,P)devuelve NULL y sqlite3_uri_boolean(F,P,B)devuelve B.Si F no es un puntero NULL y no es un puntero de ruta de archivo de base de datos que SQLite pasó al método xOpen VFS,entonces el comportamiento de esta rutina es indefinido y probablemente indeseable.</target>
        </trans-unit>
        <trans-unit id="7f60624c5c0f9adef9d93c9ed8179bc298264376" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that the SQLite core passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4646f7a7f8236532256725ec4112b997f511c7d6" translate="yes" xml:space="preserve">
          <source>If F is a suitable filename (as described in the previous paragraph) and if P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F and it has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">Si F es el puntero del nombre de archivo de la base de datos pasado al m&amp;eacute;todo xOpen () de una implementaci&amp;oacute;n de VFS cuando el par&amp;aacute;metro flags de xOpen () tiene uno o m&amp;aacute;s de los bits &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; o &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; establecidos y P es el nombre del par&amp;aacute;metro de consulta, entonces sqlite3_uri_parameter ( F, P) devuelve el valor del par&amp;aacute;metro P si existe o un puntero NULL si P no aparece como un par&amp;aacute;metro de consulta en F. Si P es un par&amp;aacute;metro de consulta de F no tiene un valor expl&amp;iacute;cito, entonces sqlite3_uri_parameter (F, P) devuelve un puntero a una cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">Si F es el puntero del nombre de archivo de la base de datos pasado al m&amp;eacute;todo xOpen () de una implementaci&amp;oacute;n de VFS cuando el par&amp;aacute;metro flags de xOpen () tiene uno o m&amp;aacute;s de los bits &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; o &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; establecidos y P es el nombre del par&amp;aacute;metro de consulta, entonces sqlite3_uri_parameter ( F, P) devuelve el valor del par&amp;aacute;metro P si existe o un puntero NULL si P no aparece como un par&amp;aacute;metro de consulta en F. Si P es un par&amp;aacute;metro de consulta de F no tiene un valor expl&amp;iacute;cito, entonces sqlite3_uri_parameter (F, P) devuelve un puntero a una cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="96db4246a2920821a0342bd0eb3ee7ac297124f4" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9e2b4e3e6dbb59da8102c1398e68c7ec62ce69" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5222d2f3de406b301b9d249247c656c5b47394f" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, then sqlite3_filename_database(F) returns the name of the corresponding database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbd8f58db83b28c968f4a1fd0df5ad504ea9fa0" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c242ec5d087c241619851f20f12670680d93e197" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">Si FILE es un archivo ZIP en lugar de SQLite Archive, el comando &quot;.archive&quot; y la opci&amp;oacute;n de l&amp;iacute;nea de comandos &quot;-A&quot; a&amp;uacute;n funcionan. Esto se logra utilizando la extensi&amp;oacute;n &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; . Por lo tanto, los siguientes comandos son aproximadamente equivalentes, y solo difieren en el formato de salida:</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">Si M es -1 en el encabezado inicial del diario,entonces el número de registros de páginas que siguen se calcula calculando cuántos registros de páginas caben en el espacio disponible del resto del archivo del diario.</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">Si el modo de bloqueo NORMAL está en efecto para el primer acceso a la base de datos en modo WAL,entonces se crea el wal-index de memoria compartida.Esto significa que el VFS subyacente debe soportar la &quot;versión 2&quot; de shared-memory.Si el VFS no es compatible con los métodos de memoria compartida,entonces fallará el intento de abrir una base de datos que ya esté en modo WAL,o el intento de convertir una base de datos en modo WAL.Siempre y cuando haya exactamente una conexión que utilice un wal-index de memoria compartida,el modo de bloqueo puede cambiarse libremente entre NORMAL y EXCLUSIVO.Sólo cuando se omite el wal-index de memoria compartida,cuando el modo de bloqueo es EXCLUSIVO antes del primer acceso a la base de datos en modo WAL,el modo de bloqueo queda atascado en EXCLUSIVO.</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">Si se inserta NULL en la columna de modo,entonces el modo de la nueva entrada de archivo se establece automáticamente en 33188 (-rw-r--r--)o 16877 (drwxr-xr-x),dependiendo de si los valores especificados para las columnas &quot;sz&quot;,&quot;data&quot; y &quot;rawdata&quot; indican o no que la nueva entrada es un directorio.</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">Si se inserta NULL en la columna de tiempo m,entonces la marca de tiempo de la nueva entrada se ajusta a la hora actual.De lo contrario,el valor especificado se interpreta como un número entero y se utiliza tal cual.</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">Si P es un polígono,entonces geopoly_area(P)devuelve el área delimitada por ese polígono.Si P no es un polígono,geopoly_area(P)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">Si P es un polígono,entonces geopoly_bbox(P)devuelve un nuevo polígono que es el rectángulo más pequeño (alineado con el eje)que encierra completamente a P.Si P no es un polígono,geopoly_bbox(P)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">Si P es un polígono,entonces geopoly_blob(P)devuelve la codificación binaria de ese polígono como BLOB.Si P no es un polígono,geopoly_blob(P)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">Si P es un polígono,entonces geopoly_contains_point(P,X,Y)devuelve un número entero distinto de cero si y sólo si la coordenada X,Y está dentro o en el límite del polígono P.Si P no es un polígono,geopoly_contains_point(P,X,Y)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">Si P es un polígono,entonces geopoly_json(P)devuelve la representación GeoJSON de ese polígono como una cadena de TEXTO.Si P no es un polígono,geopoly_json(P)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">Si P es un pol&amp;iacute;gono, geopoly_svg (P, ...) devuelve una cadena de texto que es una representaci&amp;oacute;n de &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;gr&amp;aacute;ficos vectoriales escalables (SVG)&lt;/a&gt; de ese pol&amp;iacute;gono. Si hay m&amp;aacute;s de un argumento, el segundo argumento y los siguientes se agregan como atributos a cada glifo SVG. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">Si P no es un polígono,geopoly_svg(P,...)devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">Si P&amp;gt; X y K&amp;gt; X, los primeros M bytes de P se almacenan en la p&amp;aacute;gina del &amp;aacute;rbol b y los bytes PM restantes se almacenan en las p&amp;aacute;ginas de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">Si P&amp;gt; X y K &amp;lt;= X, entonces los primeros K bytes de P se almacenan en la p&amp;aacute;gina del &amp;aacute;rbol b y los bytes PK restantes se almacenan en las p&amp;aacute;ginas de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">Si P &amp;lt;= X, todos los P bytes de carga &amp;uacute;til se almacenan directamente en la p&amp;aacute;gina btree sin desbordamiento.</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">Si P1 y P2 son ambos polígonos,entonces la función geopoly_overlap(P1,P2)devuelve un número entero distinto de cero si hay alguna superposición entre P1 y P2,o devuelve cero si P1 y P2 se desarticulan completamente.Si P1 o P2 no es un polígono,esta rutina devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="3222b98590b837273b0d4239ca32f6bb0d30ac83" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P1 is completely contained within P2, or it returns zero if any part of P1 is outside of P2. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">Si P1 y P2 son ambos polígonos,entonces la función geopoly_within(P1,P2)devuelve un número entero distinto de cero si P2 está completamente contenido dentro de P1,o devuelve cero si alguna parte de P2 está fuera de P1.Si P1 y P2 son el mismo polígono,esta rutina devuelve un número distinto de cero.Si P1 o P2 no es un polígono,esta rutina devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">Si P1 es 0,entonces todas las sentencias SQL expiran.Si P1 es distinto de cero,entonces sólo la sentencia que se está ejecutando actualmente caduca.</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">Si P1 es distinto de cero,el salto se realiza si el contador de restricciones de la base de datos es cero (el que cuenta las violaciones de restricciones diferidas).Si P1 es cero,el salto se realiza si el contador de restricciones de la sentencia es cero (violaciones de restricciones de clave externa inmediata).</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">Si P1 no es cero,entonces es un registro que un agregado posterior min()o max()se fijará en 1 si la fila actual no es el mínimo o el máximo.El registro P1 se inicializa a 0 por esta instrucción.</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">Si P2 es 0,entonces las sentencias SQL expiran inmediatamente.Si P2 es 1,entonces se permite que las sentencias SQL en ejecución continúen ejecutándose hasta su finalización.El caso P2==1 se produce cuando se produce un cambio en el esquema de CREATE INDEX o similar que puede ayudar a que la sentencia se ejecute más rápidamente pero que no afecta a la corrección de la operación.</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">Si P2 no es cero,salta a la instrucción P2.</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">Si P2 no es cero,entonces es un registro que contiene una cadena que es el archivo en el que se debe escribir el resultado del vacío.Cuando P2 es cero,el vacío sobrescribe la base de datos original.</target>
        </trans-unit>
        <trans-unit id="7f685a86b5e506b77efdf72c9ec8070a39f8b40d" translate="yes" xml:space="preserve">
          <source>If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal schema version is set to P3-P5. The &quot;PRAGMA schema_version=N&quot; statement has P5 set to 1, so that the internal schema version will be different from the database schema version, resulting in a schema reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">Si P2!=0 entonces la implementación de la corutina sigue inmediatamente a este opcode.Así que salta sobre la implementación de la rutina para dirigir P2.</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">Si P2==1 entonces no se realiza ninguna inserción.argv[0]es el rowid de una fila a eliminar.</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">Si P3 no es cero y el contenido del registro P3 es igual a P5,entonces el tipo de datos del registro P2 se convierte en BLOB.El contenido es la misma secuencia de bytes,se interpreta simplemente como un BLOB en lugar de una cadena,como si hubiera sido CAST.En otras palabras:</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">Si P3 no es cero,entonces es una dirección a la que saltar si se encuentra un error SQLITE_CORRUPT.</target>
        </trans-unit>
        <trans-unit id="fb1bf816dbb55169e5b2d71bf5d2b1c16bfeaa50" translate="yes" xml:space="preserve">
          <source>If P3 is positive, then reg[P3] is modified slightly so that it can be used as zero-length data for &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;. This is an optimization that avoids an extra &lt;a href=&quot;opcode#Blob&quot;&gt;Blob&lt;/a&gt; opcode to initialize that register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">Si P3! = 0, entonces el contenido del registro P2 no es adecuado para su uso en OP_Result y cualquier OP_Result invalidar&amp;aacute; el contenido del registro P2. El contenido del registro P2 es invalidado por c&amp;oacute;digos de operaci&amp;oacute;n como &lt;a href=&quot;opcode#Function&quot;&gt;Funci&amp;oacute;n&lt;/a&gt; o por cualquier uso de otro cursor que apunte a la misma tabla.</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">Si P3!=0 entonces este opcode puede hacer un puntero efímero en la página de la base de datos.Esto significa que el contenido del registro de salida será invalidado tan pronto como el cursor se mueva-incluyendo los movimientos causados por otros cursores que &quot;guardan&quot; la posición actual de los cursores para que puedan escribir en la misma tabla.Si P3==0 entonces se hace una copia de los datos en la memoria.¡P3!=0 es más rápido,pero P3==0 es más seguro.</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">Si P3&amp;gt; 0, entonces P3 es un registro en el marco ra&amp;iacute;z de este VDBE que contiene el mayor n&amp;uacute;mero de registro generado previamente. No se permite que los nuevos n&amp;uacute;meros de registro sean inferiores a este valor. Cuando este valor alcanza su m&amp;aacute;ximo, se genera un error SQLITE_FULL. El registro P3 se actualiza con el 'n&amp;uacute;mero de registro generado. Este mecanismo P3 se utiliza para ayudar a implementar la funci&amp;oacute;n AUTOINCREMENT.</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">Si P3==0 y P4==0 entonces r[P2]:=r[P1]ES VERDADERO</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">Si P3==0 y P4==1 entonces r[P2]:=r[P1]NO ES CIERTO</target>
        </trans-unit>
        <trans-unit id="dffd9f3f7dcda52e1f25f401261075e7728503f3" translate="yes" xml:space="preserve">
          <source>If P3==0, then an exact count is obtained, which involves visiting every btree page of the table. But if P3 is non-zero, an estimate is returned based on the current cursor position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">Si P3==1 y P4==0 entonces r[P2]:=r[P1]NO ES FALSO</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">Si P3==1 y P4==1 entonces r[P2]:=r[P1]ES FALSO</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">Si P4 es NULL entonces todos los campos de índice tienen la afinidad BLOB.</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">Si P4 no es NULL, entonces apunta a un objeto Table. En este caso, se puede invocar el enlace de actualizaci&amp;oacute;n o pre-actualizaci&amp;oacute;n, o ambos. El cursor P1 debe haberse posicionado utilizando &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; antes de invocar este c&amp;oacute;digo de operaci&amp;oacute;n en este caso. Espec&amp;iacute;ficamente, si hay uno configurado, el gancho de pre-actualizaci&amp;oacute;n se invoca si P4 no es NULL. El gancho de actualizaci&amp;oacute;n se invoca si hay uno configurado, P4 no es NULL y el indicador OPFLAG_NCHANGE se establece en P2.</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">Si P4 no es nulo,entonces es una cadena de mensajes de error.</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">Si P4 no es cero,entonces es el número de valores en la clave desempacada de reg(P2).En ese caso,P3 es el índice del primer registro de la clave descomprimida.La disponibilidad de la clave descomprimida puede ser a veces una optimización.</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">Si P4 == 0, el registro P3 contiene un blob construido por &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; . Si P4&amp;gt; 0, el registro P3 es el primero de los registros P4 que forman un registro desempaquetado.</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">Si P5 tiene el conjunto de bits OPFLAG_APPEND,eso es un indicio para la capa de árbol B de que esta inserción es probable que sea un apéndice.</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">Si P5 tiene el bit OPFLAG_NCHANGE activado,entonces el contador de cambios se incrementa con esta instrucción.Si el bit OPFLAG_NCHANGE está libre,entonces el contador de cambios no se modifica.</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">Si P5 tiene el bit OPFLAG_PERMUTE establecido, entonces el orden de comparaci&amp;oacute;n lo determina el operador de &lt;a href=&quot;opcode#Permutation&quot;&gt;permutaci&amp;oacute;n&lt;/a&gt; m&amp;aacute;s reciente . Si el bit OPFLAG_PERMUTE est&amp;aacute; limpio, los registros se comparan en orden secuencial.</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">Si P5 es distinto de cero,entonces se habilita la invocación recursiva del programa.</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">Si P5 no es cero y P4 es NULL,entonces todo lo que va después del &quot;:&quot; se omite.</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">Si P5 no es cero,la comprobación se hace en el archivo de la base de datos auxiliar,no en el archivo de la base de datos principal.</target>
        </trans-unit>
        <trans-unit id="4031180a3fa926570f402abdb205aa9088ecbac2" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">Si P5 es positivo y se da el salto,entonces se incrementa el contador de eventos número P5-1 en la declaración preparada.</target>
        </trans-unit>
        <trans-unit id="e77300f272721b16413737d1f5909b28a7b7a6ee" translate="yes" xml:space="preserve">
          <source>If P5 is set, then all released registers have their type set to MEM_Undefined so that any subsequent attempt to read the released register (before it is reinitialized) will generate an assertion fault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">Si P5!=0 entonces este opcode también comprueba la cookie de esquema contra P3 y el contador de generación de esquema contra P4.La cookie cambia su valor cada vez que cambia el esquema de la base de datos.Esta operación se utiliza para detectar cuando la cookie ha cambiado y que el proceso actual necesita releer el esquema.Si la cookie del esquema en P3 difiere de la cookie del esquema en el encabezado de la base de datos o si el contador de generación del esquema en P4 difiere del contador de generación actual,entonces se produce un error SQLITE_SCHEMA y se detiene la ejecución.La función sqlite3_step()wrapper podría entonces preparar de nuevo la sentencia y volver a ejecutarla desde el principio.</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">Si se utiliza la UBR para actualizar un valor grande de BLOB dentro de una base de datos de objetivos,puede ser más eficiente almacenar un parche o delta que se puede utilizar para modificar el BLOB existente en lugar de un valor completamente nuevo dentro de la base de datos de la UBR.La RBU permite especificar los deltas de dos maneras:</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">Si SQLITE_DEFAULT_WAL_SYNCHRONOUS difiere de SQLITE_DEFAULT_SYNCHRONOUS, y si la aplicaci&amp;oacute;n no ha modificado la configuraci&amp;oacute;n s&amp;iacute;ncrona para el archivo de base de datos utilizando la declaraci&amp;oacute;n &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;s&amp;iacute;ncrona PRAGMA&lt;/a&gt; , entonces la configuraci&amp;oacute;n s&amp;iacute;ncrona se cambia al valor definido por SQLITE_DEFAULT_WAL_SYNCHRONOUS por primera vez cuando el modo de conexi&amp;oacute;n cambia a la hora WALNCHRONOUS. Si el valor de SQLITE_DEFAULT_WAL_SYNCHRONOUS no se anula en tiempo de compilaci&amp;oacute;n, siempre ser&amp;aacute; el mismo que &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; y, por lo tanto, nunca se producir&amp;aacute;n cambios de configuraci&amp;oacute;n s&amp;iacute;ncronos autom&amp;aacute;ticos.</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">Si se establece SQLITE_NULLEQ en P5,el resultado de la comparación es siempre verdadero o falso y nunca es NULL.Si ambos operandos son NULL entonces el resultado de la comparación es verdadero.Si cualquiera de los operandos es NULL entonces el resultado es falso.Si ninguno de los operandos es NULL el resultado es el mismo que si se omitiera el indicador SQLITE_NULLEQ en P5.</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">Si SQLite descubre que la tabla sqlite_sequence tiene cualquier otro formato,devuelve el error SQLITE_CORRUPT_SEQUENCE.</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">Si SQLite devuelve alguna vez SQLITE_MISUSE desde cualquier interfaz,significa que la aplicación está mal codificada y necesita ser reparada.No envíe una aplicación que a veces devuelve SQLITE_MISUSE desde una interfaz estándar de SQLite porque esa aplicación contiene errores potencialmente graves.</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">Si SQLite se ha compilado con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , entonces el pragma parser_trace se puede utilizar para activar el seguimiento del analizador SQL utilizado internamente por SQLite. Esta funci&amp;oacute;n se utiliza para depurar el propio SQLite.</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Si SQLite se ha compilado con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , entonces el pragma vdbe_addoptrace se puede usar para hacer que se muestren c&amp;oacute;digos de operaci&amp;oacute;n VDBE completos a medida que se crean durante la generaci&amp;oacute;n del c&amp;oacute;digo. Esta funci&amp;oacute;n se utiliza para depurar el propio SQLite. Consulte la &lt;a href=&quot;vdbe#trace&quot;&gt;documentaci&amp;oacute;n de VDBE&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Si SQLite se ha compilado con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , entonces el pragma vdbe_debug es una abreviatura de otros tres pragmas de solo depuraci&amp;oacute;n: vdbe_addoptrace, vdbe_listing y vdbe_trace. Esta funci&amp;oacute;n se utiliza para depurar el propio SQLite. Consulte la &lt;a href=&quot;vdbe#trace&quot;&gt;documentaci&amp;oacute;n de VDBE&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Si SQLite se ha compilado con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , entonces el pragma vdbe_listing puede usarse para hacer que aparezca una lista completa de los c&amp;oacute;digos de operaci&amp;oacute;n de la m&amp;aacute;quina virtual en la salida est&amp;aacute;ndar a medida que se eval&amp;uacute;a cada declaraci&amp;oacute;n. Con el listado activado, todo el contenido de un programa se imprime justo antes de comenzar la ejecuci&amp;oacute;n. La declaraci&amp;oacute;n se ejecuta normalmente despu&amp;eacute;s de que se imprime la lista. Esta funci&amp;oacute;n se utiliza para depurar el propio SQLite. Consulte la &lt;a href=&quot;vdbe#trace&quot;&gt;documentaci&amp;oacute;n de VDBE&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Si SQLite se ha compilado con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , entonces el pragma vdbe_trace se puede utilizar para hacer que los c&amp;oacute;digos de operaci&amp;oacute;n de la m&amp;aacute;quina virtual se impriman en la salida est&amp;aacute;ndar a medida que se eval&amp;uacute;an. Esta funci&amp;oacute;n se utiliza para depurar SQLite. Consulte la &lt;a href=&quot;vdbe#trace&quot;&gt;documentaci&amp;oacute;n de VDBE&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">Si SQLite no se ha inicializado usando &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; antes de invocar sqlite3_complete16 (), entonces sqlite3_complete16 () invoca autom&amp;aacute;ticamente sqlite3_initialize (). Si esa inicializaci&amp;oacute;n falla, entonces el valor de retorno de sqlite3_complete16 () ser&amp;aacute; distinto de cero independientemente de si el SQL de entrada est&amp;aacute; completo o no.</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">Si SQLite no se ha inicializado usando &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; antes de invocar sqlite3_complete16 (), entonces sqlite3_complete16 () invoca autom&amp;aacute;ticamente sqlite3_initialize (). Si esa inicializaci&amp;oacute;n falla, entonces el valor de retorno de sqlite3_complete16 () ser&amp;aacute; distinto de cero independientemente de si el SQL de entrada est&amp;aacute; completo o no.</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">Si SQLite se &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;crea&lt;/a&gt; con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n SQLITE_ENABLE_UPDATE_DELETE_LIMIT , entonces la sintaxis de la declaraci&amp;oacute;n UPDATE se extiende con cl&amp;aacute;usulas opcionales ORDER BY y LIMIT de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">Si SQLite se compila para Windows con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; , entonces se usa una envoltura delgada diferente alrededor de HeapAlloc (), HeapReAlloc () y HeapFree (). El contenedor delgado usa el mont&amp;oacute;n de SQLite configurado, que ser&amp;aacute; diferente del mont&amp;oacute;n de proceso predeterminado si se usa la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; . Adem&amp;aacute;s, cuando se realiza o se libera una asignaci&amp;oacute;n, se llamar&amp;aacute; a HeapValidate () si SQLite se compila con assert () habilitado y la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">Si SQLite se compila con &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; , otro asignador de memoria de cero malloc, similar a memsys5, se incluye en el &amp;aacute;rbol de origen. El asignador memsys3, como memsys5, debe activarse mediante una llamada a &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;, ...). Memsys3 utiliza el b&amp;uacute;fer de memoria suministrado como fuente para todas las asignaciones de memoria. La diferencia entre memsys3 y memsys5 es que memsys3 utiliza un algoritmo de asignaci&amp;oacute;n de memoria diferente que parece funcionar bien en la pr&amp;aacute;ctica, pero que no proporciona garant&amp;iacute;as matem&amp;aacute;ticas contra la fragmentaci&amp;oacute;n y el colapso de la memoria. Memsys3 fue un predecesor de memsys5. Los desarrolladores de SQLite ahora creen que memsys5 es superior a memsys3 y que todas las aplicaciones que necesitan un asignador de memoria zero-malloc deber&amp;iacute;an usar memsys5 en lugar de memsys3. Memsys3 se considera tanto experimental como obsoleto y es probable que se elimine del &amp;aacute;rbol de fuentes en una versi&amp;oacute;n futura de SQLite.</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">Si SQLite se compila con la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; , entonces la sintaxis de la declaraci&amp;oacute;n DELETE se extiende mediante la adici&amp;oacute;n de cl&amp;aacute;usulas opcionales ORDER BY y LIMIT:</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">Si SQLite est&amp;aacute; compilado con &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;opci&amp;oacute;n en tiempo de compilaci&amp;oacute;n, entonces se usa un contenedor pesado diferente alrededor del sistema malloc (), realloc () y free (). El contenedor pesado asigna alrededor de 100 bytes de espacio adicional con cada asignaci&amp;oacute;n. El espacio adicional se utiliza para colocar valores centinela en ambos extremos de la asignaci&amp;oacute;n devuelta al n&amp;uacute;cleo de SQLite. Cuando se libera una asignaci&amp;oacute;n, estos centinelas se verifican para asegurarse de que el n&amp;uacute;cleo de SQLite no invadi&amp;oacute; el b&amp;uacute;fer en ninguna direcci&amp;oacute;n. Cuando la biblioteca del sistema es GLIBC, el contenedor pesado tambi&amp;eacute;n hace uso de la funci&amp;oacute;n GNU backtrace () para examinar la pila y registrar las funciones ancestrales de la llamada malloc (). Cuando se ejecuta el conjunto de pruebas de SQLite, el contenedor pesado tambi&amp;eacute;n registra el nombre del caso de prueba actual. Estas dos &amp;uacute;ltimas caracter&amp;iacute;sticas son &amp;uacute;tiles para rastrear el origen de las p&amp;eacute;rdidas de memoria detectadas por el conjunto de pruebas.</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">Si SQLite se compila con la opci&amp;oacute;n &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; , el &lt;a href=&quot;malloc#defaultalloc&quot;&gt;asignador de memoria predeterminado&lt;/a&gt; se omite y se reemplaza por un asignador de memoria auxiliar que nunca asigna memoria. Cualquier llamada al asignador de memoria auxiliar informar&amp;aacute; que no hay memoria disponible.</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">Si SQLite se compila con la macro del preprocesador SQLITE_MUTEX_APPDEF definida (con &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;), entonces no se incluye ninguna implementaci&amp;oacute;n de mutex con la biblioteca. En este caso, la aplicaci&amp;oacute;n debe proporcionar una implementaci&amp;oacute;n mutex personalizada utilizando la opci&amp;oacute;n &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; de la funci&amp;oacute;n sqlite3_config () antes de llamar a sqlite3_initialize () o cualquier otra funci&amp;oacute;n p&amp;uacute;blica sqlite3_ que llame a sqlite3_initialize ().</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">Si SQLite se compila con la macro del preprocesador SQLITE_MUTEX_APPDEF definida (con &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;), entonces no se incluye ninguna implementaci&amp;oacute;n de mutex con la biblioteca. En este caso, la aplicaci&amp;oacute;n debe proporcionar una implementaci&amp;oacute;n mutex personalizada utilizando la opci&amp;oacute;n &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; de la funci&amp;oacute;n sqlite3_config () antes de llamar a sqlite3_initialize () o cualquier otra funci&amp;oacute;n p&amp;uacute;blica sqlite3_ que llame a sqlite3_initialize ().</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">Si SQLite se compila con la macro del preprocesador THREADSAFE establecida en 1, entonces es seguro usar SQLite de dos o m&amp;aacute;s subprocesos del mismo proceso al mismo tiempo. Pero cada hilo debe tener su propio puntero &lt;b&gt;sqlite *&lt;/b&gt; devuelto desde &lt;b&gt;sqlite_open&lt;/b&gt; . Nunca es seguro que dos o m&amp;aacute;s subprocesos accedan al mismo puntero &lt;b&gt;sqlite *&lt;/b&gt; al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">Si SQLite est&amp;aacute; trabajando con varias bases de datos al mismo tiempo (usando el comando &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; ), entonces cada base de datos tiene su propio diario de reversi&amp;oacute;n. Pero tambi&amp;eacute;n hay un diario agregado separado llamado &lt;em&gt;diario maestro&lt;/em&gt; . El diario principal no contiene datos de p&amp;aacute;gina utilizados para deshacer cambios. En cambio, el diario principal contiene los nombres de los diarios de reversi&amp;oacute;n de la base de datos individuales para cada una de las bases de datos ADJUNTADAS. Cada uno de los diarios de reversi&amp;oacute;n de bases de datos individuales tambi&amp;eacute;n contiene el nombre del diario principal. Si no hay bases de datos ADJUNTAS (o si ninguna de las bases de datos ADJUNTAS participa en la transacci&amp;oacute;n actual) no se crea ning&amp;uacute;n diario maestro y el diario de reversi&amp;oacute;n normal contiene una cadena vac&amp;iacute;a en el lugar normalmente reservado para registrar el nombre del diario principal.</target>
        </trans-unit>
        <trans-unit id="e3d682297850435cbed4a4f23333530d1946cfd2" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">Si SQLite necesita una entrada en la caché de página que sea mayor que los bytes &quot;sz&quot; o si necesita más de N entradas,recurre al uso del asignador de memoria de propósito general.</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">Si SQLite reconoce una tabla como una tabla de sombra, y si se establece la &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;marca SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; , entonces la tabla de sombra es de solo lectura para declaraciones SQL ordinarias. La tabla de sombra todav&amp;iacute;a se puede escribir, pero solo mediante SQL que se invoca desde uno de los m&amp;eacute;todos de alguna implementaci&amp;oacute;n de tabla virtual.</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">Si los nombres de archivo URI se reconocen cuando se abre originalmente la conexi&amp;oacute;n a la base de datos, los nombres de archivo URI tambi&amp;eacute;n se reconocer&amp;aacute;n en las instrucciones &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Del mismo modo, si los nombres de fichero URI no se reconocen cuando se abre por primera vez la conexi&amp;oacute;n de base de datos, no ser&amp;aacute;n reconocidos por &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">Si W es un término conectado a AND y X es un término conectado a OR y si algún término de W aparece como un término de X,entonces el índice parcial es utilizable.</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">Si X es una asignación de memoria obtenida previamente de sqlite3_malloc(),sqlite3_malloc64(),sqlite3_realloc(),o sqlite3_realloc64(),entonces sqlite3_msize(X)devuelve el tamaño de esa asignación de memoria en bytes.El valor devuelto por sqlite3_msize(X)puede ser mayor que el número de bytes solicitados cuando se asignó X.Si X es un puntero NULL,entonces sqlite3_msize(X)devuelve cero.Si X apunta a algo que no es el comienzo de la asignación de memoria,o si apunta a una asignación de memoria anteriormente válida que ahora ha sido liberada,entonces el comportamiento de sqlite3_msize(X)es indefinido y posiblemente dañino.</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">Si X es mayor o igual a cero,vuelve al paso 3.</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Si X es distinto de cero, entonces la implementaci&amp;oacute;n de la tabla virtual garantiza que si &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; devuelve &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , lo har&amp;aacute; antes de que se hayan realizado modificaciones en las estructuras de datos internas o persistentes. Si el modo &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; es ABORT, FAIL, IGNORE o ROLLBACK, SQLite puede revertir una declaraci&amp;oacute;n o transacci&amp;oacute;n de base de datos y abandonar o continuar procesando la declaraci&amp;oacute;n SQL actual seg&amp;uacute;n corresponda. Si el modo ON CONFLICT es REPLACE y el m&amp;eacute;todo &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; devuelve &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , SQLite maneja esto como si el modo ON CONFLICT hubiera sido ABORT.</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Si X es distinto de cero, entonces la implementaci&amp;oacute;n de la tabla virtual garantiza que si &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , lo har&amp;aacute; antes de que se hayan realizado modificaciones en las estructuras de datos internas o persistentes. Si el modo &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; es ABORT, FAIL, IGNORE o ROLLBACK, SQLite puede revertir una declaraci&amp;oacute;n o transacci&amp;oacute;n de base de datos y abandonar o continuar procesando la declaraci&amp;oacute;n SQL actual seg&amp;uacute;n corresponda. Si el modo ON CONFLICT es REPLACE y el m&amp;eacute;todo &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , SQLite maneja esto como si el modo ON CONFLICT hubiera sido ABORT.</target>
        </trans-unit>
        <trans-unit id="30772a96ac944f5d807fde7afed09facbb4c72a3" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9128fc14e46c56850f1f42883590144b2c54fddf" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Si X inicia una transacci&amp;oacute;n que inicialmente solo leer&amp;aacute; pero X sabe que eventualmente querr&amp;aacute; escribir y no quiere tener problemas con posibles errores SQLITE_BUSY_SNAPSHOT que surgen porque otra conexi&amp;oacute;n salt&amp;oacute; por delante de ella en la l&amp;iacute;nea, entonces X puede emitir &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN INMEDIATE&lt;/a&gt; para comenzar su transacci&amp;oacute;n en lugar de un BEGIN ordinario. El comando &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; sigue adelante e inicia una transacci&amp;oacute;n de escritura y, por lo tanto, bloquea a todos los dem&amp;aacute;s escritores. Si la operaci&amp;oacute;n &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE se realiza&lt;/a&gt; correctamente, ninguna operaci&amp;oacute;n posterior de esa transacci&amp;oacute;n fallar&amp;aacute; con un error &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">Si un car&amp;aacute;cter &quot;*&quot; sigue a una cadena dentro de una expresi&amp;oacute;n FTS, entonces el token final extra&amp;iacute;do de la cadena se marca como un &lt;b&gt;token de prefijo&lt;/b&gt; . Como era de esperar, un token de prefijo coincide con cualquier token de documento del que sea un prefijo. Por ejemplo, las dos primeras consultas del siguiente bloque coincidir&amp;aacute;n con cualquier documento que contenga el token &quot;uno&quot; seguido inmediatamente por el token &quot;dos&quot; y luego cualquier token que comience con &quot;thr&quot;.</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">Si se ejecuta un comando SQL &quot;DROP TABLE&quot; o &quot;DROP INDEX&quot;, y la misma conexi&amp;oacute;n de base de datos tiene actualmente una o m&amp;aacute;s sentencias SELECT en ejecuci&amp;oacute;n activa, se devuelve SQLITE_LOCKED. Si se llama a &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; en este caso, la devoluci&amp;oacute;n de llamada especificada se invocar&amp;aacute; inmediatamente. Reintentar la instrucci&amp;oacute;n &quot;DROP TABLE&quot; o &quot;DROP INDEX&quot; devolver&amp;aacute; otro error SQLITE_LOCKED. En la implementaci&amp;oacute;n de sqlite3_blocking_step () que se muestra a la izquierda, esto podr&amp;iacute;a causar un bucle infinito.</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">Si aparece un car&amp;aacute;cter &quot;^&quot; inmediatamente antes de una frase que no forma parte de una consulta NEAR, esa frase solo coincide con un documento solo si comienza en el primer token de una columna. La sintaxis &quot;^&quot; se puede combinar con un &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;filtro de columna&lt;/a&gt; , pero no se puede insertar en el medio de una frase.</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">Si se ejecuta una operación de &quot;crear archivo&quot; por SQLite,y luego el archivo creado</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">Si una operación de &quot;archivo truncado&quot; es ejecutada por SQLite,y luego el archivo truncado</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Si un &lt;a href=&quot;../wal#walfile&quot;&gt;archivo WAL&lt;/a&gt; permanece en el disco despu&amp;eacute;s de que se cierran todas las conexiones de la base de datos (ya sea mediante el uso del &lt;a href=&quot;file_control&quot;&gt;control de archivo &lt;/a&gt;&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; o porque el &amp;uacute;ltimo proceso en el que se abri&amp;oacute; la base de datos sali&amp;oacute; sin llamar a &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; ) y posteriormente se abre una nueva conexi&amp;oacute;n en esa base de datos y &lt;a href=&quot;../wal#walfile&quot;&gt;WAL&lt;/a&gt; , la interfaz &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; solo podr&amp;aacute; abrir la &amp;uacute;ltima transacci&amp;oacute;n agregada al archivo WAL aunque el archivo WAL contenga otras transacciones v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">Si se genera una &lt;a href=&quot;c3ref/stmt&quot;&gt;declaraci&amp;oacute;n preparada a&lt;/a&gt; partir de &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , la declaraci&amp;oacute;n se vuelve a preparar autom&amp;aacute;ticamente si el esquema cambia, hasta &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; veces (predeterminado: 50). La interfaz &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; solo devolver&amp;aacute; SQLITE_SCHEMA a la aplicaci&amp;oacute;n si la falla persiste despu&amp;eacute;s de estos muchos reintentos.</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">Si se produce una operaci&amp;oacute;n &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; en la misma &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexi&amp;oacute;n de base de datos&lt;/a&gt; que una lectura o escritura pendiente, entonces la lectura o escritura pendiente puede fallar con un error SQLITE_ABORT o &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Si un &lt;a href=&quot;wal#walfile&quot;&gt;archivo WAL&lt;/a&gt; permanece en el disco despu&amp;eacute;s de que se cierran todas las conexiones de la base de datos (ya sea mediante el uso del &lt;a href=&quot;#sqlite3_file_control&quot;&gt;control de archivo &lt;/a&gt;&lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; o porque el &amp;uacute;ltimo proceso en el que se abri&amp;oacute; la base de datos sali&amp;oacute; sin llamar a &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; ) y posteriormente se abre una nueva conexi&amp;oacute;n en esa base de datos y &lt;a href=&quot;wal#walfile&quot;&gt;WAL&lt;/a&gt; , la interfaz &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; solo podr&amp;aacute; abrir la &amp;uacute;ltima transacci&amp;oacute;n agregada al archivo WAL aunque el archivo WAL contenga otras transacciones v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">Si un disparador de actualización o de eliminación modifica o elimina una fila que debía ser actualizada o eliminada,entonces el resultado de la operación de actualización o eliminación subsiguiente queda sin definir.Además,si un activador del tipo ANTES de modificar o borrar una fila,entonces no se define si se ejecutarán o no los activadores del tipo DESPUÉS que de otro modo se habrían ejecutado en esas filas.</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">Si una instrucci&amp;oacute;n COMMIT (o el RELEASE de una transacci&amp;oacute;n SAVEPOINT) falla porque la base de datos se encuentra actualmente en un estado que viola una restricci&amp;oacute;n de clave externa diferida y hay &lt;a href=&quot;lang_savepoint&quot;&gt;puntos de guardado anidados&lt;/a&gt; actualmente , los puntos de guardado anidados permanecen abiertos.</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">Si una declaración DELETE tiene una cláusula LIMITADA,el número máximo de filas que se eliminarán se encuentra evaluando la expresión que la acompaña y castigándola con un valor entero.Si el resultado de la evaluación de la cláusula LIMIT no puede ser convertido sin pérdidas a un valor entero,es un error.Un valor LÍMITE negativo se interpreta como &quot;sin límite&quot;.Si la declaración DELETE también tiene una cláusula OFFSET,entonces se evalúa de forma similar y se convierte en un valor entero.De nuevo,es un error si el valor no puede ser convertido sin pérdidas a un número entero.Si no hay cláusula OFFSET,o el valor entero calculado es negativo,el valor OFFSET efectivo es cero.</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">Si se proporciona una cláusula de FILTROS,entonces sólo las filas para las que el</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">Si se especifica una cl&amp;aacute;usula FROM, los datos sobre los que opera una consulta SELECT simple provienen de una o m&amp;aacute;s tablas o subconsultas (sentencias SELECT entre par&amp;eacute;ntesis) especificadas despu&amp;eacute;s de la palabra clave FROM. Una subconsulta especificada en la tabla o subconsulta que sigue a la cl&amp;aacute;usula FROM en una instrucci&amp;oacute;n SELECT simple se maneja como si fuera una tabla que contiene los datos devueltos al ejecutar la instrucci&amp;oacute;n de subconsulta. Cada columna de la subconsulta tiene la &lt;a href=&quot;datatype3#collation&quot;&gt;secuencia de clasificaci&amp;oacute;n&lt;/a&gt; y la &lt;a href=&quot;datatype3#affinity&quot;&gt;afinidad&lt;/a&gt; de la expresi&amp;oacute;n correspondiente en la declaraci&amp;oacute;n de la subconsulta.</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">Si se especifica una cl&amp;aacute;usula HAVING, se eval&amp;uacute;a una vez para cada grupo de filas como una &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana&lt;/a&gt; . Si el resultado de evaluar la cl&amp;aacute;usula HAVING es falso, el grupo se descarta. Si la cl&amp;aacute;usula HAVING es una expresi&amp;oacute;n agregada, se eval&amp;uacute;a en todas las filas del grupo. Si una cl&amp;aacute;usula HAVING es una expresi&amp;oacute;n no agregada, se eval&amp;uacute;a con respecto a una fila seleccionada arbitrariamente del grupo. La expresi&amp;oacute;n HAVING puede referirse a valores, incluso funciones agregadas, que no est&amp;aacute;n en el resultado.</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">Si hay una cláusula de LÍMITE,podría ser posible evitar el escaneo de toda la mesa.</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">Si un sistema de &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;archivos&lt;/a&gt; Linux ext3 est&amp;aacute; montado sin la opci&amp;oacute;n &quot;barrera = 1&quot; en &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab&lt;/a&gt; y la memoria cach&amp;eacute; de escritura de la unidad de disco est&amp;aacute; habilitada, entonces se puede da&amp;ntilde;ar el sistema de archivos despu&amp;eacute;s de una p&amp;eacute;rdida de energ&amp;iacute;a o una falla del sistema operativo. La posibilidad de que se produzcan da&amp;ntilde;os o no depende de los detalles del hardware de control del disco; La corrupci&amp;oacute;n es m&amp;aacute;s probable con discos econ&amp;oacute;micos para consumidores y un problema menor para los dispositivos de almacenamiento de clase empresarial con caracter&amp;iacute;sticas avanzadas como cach&amp;eacute;s de escritura no vol&amp;aacute;tiles. Varios expertos en ext3 &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;confirman este comportamiento&lt;/a&gt;. Se nos dice que la mayor&amp;iacute;a de las distribuciones de Linux no usan barrera = 1 y no deshabilitan la cach&amp;eacute; de escritura, por lo que la mayor&amp;iacute;a de las distribuciones de Linux son vulnerables a este problema. Tenga en cuenta que se trata de un problema del sistema operativo y del hardware y que no hay nada que SQLite pueda hacer para solucionarlo. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;Otros motores de bases de datos&lt;/a&gt; tambi&amp;eacute;n se han encontrado con este mismo problema.</target>
        </trans-unit>
        <trans-unit id="c69858b8bc714b172e45bdd876c3722d08c7a16a" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;https://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;https://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;https://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;https://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">Si se especifica una restricción NOT NULL,la columna debe tener un valor por defecto distinto de NULL.</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">Si una consulta SELECT contiene una cl&amp;aacute;usula ORDER BY, GROUP BY o DISTINCT, es posible que SQLite necesite usar una estructura de &amp;aacute;rbol b temporal para ordenar las filas de salida. O podr&amp;iacute;a &lt;a href=&quot;queryplanner#sorting&quot;&gt;usar un &amp;iacute;ndice&lt;/a&gt; . Usar un &amp;iacute;ndice es casi siempre mucho m&amp;aacute;s eficiente que realizar una clasificaci&amp;oacute;n. Si se requiere un &amp;aacute;rbol b temporal, se agrega un registro a la salida EXPLAIN QUERY PLAN con el campo &quot;detalle&quot; establecido en un valor de cadena de la forma &quot;USE TEMP B-TREE FOR xxx&quot;, donde xxx es uno de &quot;ORDER POR &quot;,&quot; AGRUPAR POR &quot;o&quot; DISTINTO &quot;. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">Si una instrucción SELECT que devuelve más de una fila no tiene una cláusula ORDER BY,el orden en que se devuelven las filas no está definido.O,si una instrucción SELECT tiene una cláusula ORDER BY,entonces la lista de expresiones adjuntas a la ORDER BY determina el orden en que se devuelven las filas al usuario.</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">Si un operador de UNION conecta la selección inicial con la selección recursiva,sólo se añadirán filas a la cola si no se ha añadido previamente una fila idéntica a la cola.Las filas repetidas se descartan antes de ser añadidas a la cola,incluso si las filas repetidas ya han sido extraídas de la cola por el paso de recursividad.Si el operador es UNION ALL,entonces todas las filas generadas tanto por la selección inicial como por la selección recursiva se añaden siempre a la cola aunque sean repetidas.Al determinar si una fila se repite,los valores NULL se comparan entre sí y no son iguales a ningún otro valor.</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">Si se suministra una cláusula WHEN,las sentencias SQL especificadas sólo se ejecutan si la cláusula WHEN es verdadera.Si no se suministra una cláusula WHEN,las sentencias SQL se ejecutan cada vez que se dispara el trigger.</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">Si se especifica una cl&amp;aacute;usula WHERE, la expresi&amp;oacute;n WHERE se eval&amp;uacute;a para cada fila en los datos de entrada como una &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana&lt;/a&gt; . Solo las filas para las que la expresi&amp;oacute;n de la cl&amp;aacute;usula WHERE se eval&amp;uacute;a como verdadera se incluyen del conjunto de datos antes de continuar. Las filas se excluyen del resultado si la cl&amp;aacute;usula WHERE se eval&amp;uacute;a como falsa o NULL.</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">Si una construcción de SQLite no incluye los módulos FTS,entonces cualquier intento de preparar una declaración SQL para crear una tabla FTS3 o FTS4 o para dejar caer o acceder a una tabla FTS existente de cualquier manera fallará.El mensaje de error devuelto será similar a &quot;no such module:ftsN&quot; (donde N es 3 o 4).</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">Si una llamada a sqlite3_step()que intenta escribir en una tabla de la base de datos devuelve SQLITE_LOCKED,entonces es posible que más de una otra conexión contenga un bloqueo de lectura en la tabla de la base de datos en cuestión.En este caso,SQLite simplemente selecciona una de esas otras conexiones de forma arbitraria y emite la llamada de desbloqueo cuando la transacción de esa conexión ha terminado.Tanto si la llamada a sqlite3_step()fue bloqueada por una o varias conexiones,cuando se emite la correspondiente devolución de llamada de desbloqueo-notificación no se garantiza que el bloqueo requerido esté disponible,sólo que puede estarlo.</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">Si un carácter especificado como parte del argumento de &quot;tokenchars=&quot; se considera por defecto como un carácter simbólico,se ignora.Esto es así incluso si ha sido marcado como separador por una opción anterior de &quot;separators=&quot;.Del mismo modo,si un carácter especificado como parte de una opción &quot;separators=&quot; se trata como un carácter separador por defecto,se ignora.Si se especifican varias opciones &quot;tokenchars=&quot; o &quot;separators=&quot;,se procesan todas.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">Si una función de cotejo falla en alguna de las restricciones anteriores y esa función de cotejo se registra y se utiliza,entonces el comportamiento de SQLite es indefinido.</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">Si un tipo de datos de columna contiene la palabra clave especial &quot;HIDDEN&quot; (en cualquier combinación de letras mayúsculas y minúsculas)entonces esa palabra clave se omite en el nombre del tipo de datos de la columna y la columna se marca internamente como una columna oculta.Una columna oculta difiere de una columna normal en tres aspectos:</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">Si la especificación de un filtro de columna está precedida por un carácter &quot;-&quot;,entonces se interpreta como una lista de columnas contra las que no se puede comparar.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">Si una columna tiene el tipo INTEGER PRIMARY KEY AUTOINCREMENT,entonces se utiliza un algoritmo de selección ROWID ligeramente diferente.El ROWID elegido para la nueva fila es al menos uno mayor que el mayor ROWID que haya existido antes en esa misma tabla.Si la tabla nunca antes ha contenido ningún dato,entonces se utiliza un ROWID de 1.Si se ha insertado previamente el ROWID más grande posible,entonces no se permiten nuevos INSERTOS y cualquier intento de insertar una nueva fila fallará con un error SQLITE_FULL.Sólo se consideran los valores de ROWID de las transacciones anteriores que se hayan cometido.Los valores de ROWID que se retiraron son ignorados y pueden ser reutilizados.</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">Si una lista de nombres de columnas sigue al nombre de la vista, esa lista determina los nombres de las columnas para la vista. Si se omite la lista de nombres de columnas, los nombres de las columnas en la vista se derivan de los nombres de las columnas del conjunto de resultados en &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; . Se recomienda el uso de la lista de nombres de columnas. O, si se omite la lista de nombres de columnas, las columnas de resultado en la instrucci&amp;oacute;n &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; que define la vista deben tener nombres bien definidos utilizando la sintaxis &quot; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &quot;. SQLite le permite crear vistas que dependen de nombres de columna generados autom&amp;aacute;ticamente, pero debe evitar usarlos ya que las reglas utilizadas para generar nombres de columna no son una parte definida de la interfaz y podr&amp;iacute;an cambiar en futuras versiones de SQLite.</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">Si un gestor de conflictos devuelve este valor no se toma ninguna medida especial.El cambio que causó el conflicto no se aplica.El módulo de sesión continúa con el siguiente cambio en el conjunto de cambios.</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">Si se puede utilizar un índice de cobertura para una consulta,entonces se pueden evitar las múltiples búsquedas en fila y el costo de la consulta disminuye drásticamente.</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">Si se produce un accidente o un fallo de alimentación y resulta en un diario caliente pero ese diario se borra,el siguiente proceso para abrir la base de datos no sabrá que contiene cambios que deben ser retrocedidos.El retroceso no se producirá y la base de datos quedará en un estado inconsistente.Los diarios de retroceso pueden ser eliminados por cualquier número de razones:</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">Si ocurre una falla o p&amp;eacute;rdida de energ&amp;iacute;a y se deja un diario activo en el disco, es esencial que el archivo de base de datos original y el diario activo permanezcan en el disco con sus nombres originales hasta que el archivo de base de datos sea abierto por otro proceso SQLite y revertido . Durante la recuperaci&amp;oacute;n en el &lt;a href=&quot;#section_4_2&quot;&gt;paso 4.2&lt;/a&gt; SQLite localiza el diario activo buscando un archivo en el mismo directorio que la base de datos que se est&amp;aacute; abriendo y cuyo nombre se deriva del nombre del archivo que se est&amp;aacute; abriendo. Si el archivo de base de datos original o el diario activo se han movido o cambiado de nombre, el diario activo no se ver&amp;aacute; y la base de datos no se revertir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">Si se produce un accidente o una pérdida de energía en medio de una transacción,entonces el archivo del diario de retroceso se deja en el disco.La siguiente vez que otra aplicación intenta abrir el archivo de la base de datos,nota la presencia del diario de retroceso abandonado (en esta circunstancia lo llamamos &quot;diario caliente&quot;)y utiliza la información del diario para restablecer la base de datos a su estado anterior al comienzo de la transacción incompleta.Así es como SQLite implementa la confirmación atómica.</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">Si se abre una conexi&amp;oacute;n de base de datos con la opci&amp;oacute;n &quot;-uri 1&quot;, los comandos de &quot;copia de seguridad&quot; y &quot;restauraci&amp;oacute;n&quot; &lt;a href=&quot;uri&quot;&gt;respetan los nombres de archivo URI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">Si una conexi&amp;oacute;n de base de datos est&amp;aacute; operando en &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;modo de bloqueo exclusivo&lt;/a&gt; o en &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;modo de diario persistente&lt;/a&gt; (PRAGMA journal_mode = persist), despu&amp;eacute;s de realizar una transacci&amp;oacute;n, el archivo de &lt;a href=&quot;lockingv3#rollback&quot;&gt;diario de reversi&amp;oacute;n&lt;/a&gt; puede permanecer en el sistema de archivos. Esto aumenta el rendimiento para las transacciones posteriores, ya que sobrescribir un archivo existente es m&amp;aacute;s r&amp;aacute;pido que adjuntarlo a un archivo, pero tambi&amp;eacute;n consume espacio en el sistema de archivos. Despu&amp;eacute;s de una transacci&amp;oacute;n grande (por ejemplo, una &lt;a href=&quot;lang_vacuum&quot;&gt;VAC&amp;Iacute;O&lt;/a&gt; ), el archivo de diario de reversi&amp;oacute;n puede consumir una gran cantidad de espacio.</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">Si se accede a un archivo de base de datos utilizando la denominaci&amp;oacute;n 8 + 3 en lugar del nombre de archivo largo predeterminado, todas las conexiones de base de datos deben acceder de forma coherente utilizando la denominaci&amp;oacute;n 8 + 3 cada vez que se abre, o de lo contrario existe el riesgo de corrupci&amp;oacute;n de la base de datos. El &lt;a href=&quot;lockingv3#rollback&quot;&gt;diario de reversi&amp;oacute;n&lt;/a&gt; auxiliar y los archivos de &lt;a href=&quot;wal&quot;&gt;registro de escritura anticipada&lt;/a&gt; son esenciales para SQLite para estar a punto de recuperarse de un bloqueo. Si una aplicaci&amp;oacute;n utiliza 8 + 3 nombres y se bloquea, la informaci&amp;oacute;n necesaria para recuperarse de forma segura del bloqueo se almacena en archivos con la &lt;code&gt;.nal&lt;/code&gt; &quot; .nal &quot; o &quot; &lt;code&gt;.wal&lt;/code&gt; &quot;. Si la pr&amp;oacute;xima aplicaci&amp;oacute;n para abrir la base de datos no especifica el &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;Par&amp;aacute;metro URI, SQLite usar&amp;aacute; los nombres de archivo largos para intentar ubicar el diario de reversi&amp;oacute;n o los archivos de registro de escritura anticipada. No los encontrar&amp;aacute;, ya que la aplicaci&amp;oacute;n que fall&amp;oacute; los guard&amp;oacute; con 8 + 3 nombres y, por lo tanto, la base de datos no se recuperar&amp;aacute; correctamente y es probable que se corrompa.</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">Si una base de datos se escribe con la versión 3.7.0 o posterior y luego se vuelve a escribir con la versión 3.6.23 o anterior de SQLite de forma que el tamaño del archivo de la base de datos disminuya,la próxima vez que SQLite versión 3.7.0 acceda al archivo de la base de datos,podría informar de que el archivo de la base de datos está corrupto.Sin embargo,el archivo de la base de datos no está realmente corrupto.La versión 3.7.0 simplemente estaba siendo demasiado celosa en su detección de la corrupción.</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">Si una base de datos fue creada originalmente usando la versión 3.7.0 de SQLite,luego escrita por la versión 3.6.23.1 de SQLite de tal manera que el tamaño del archivo de la base de datos aumentara,y luego escrita nuevamente por la versión 3.7.0 de SQLite,el archivo de la base de datos podría corromperse.</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">Si una palabra clave entre comillas dobles (por ejemplo: &lt;b&gt;&quot;clave&quot;&lt;/b&gt; o &lt;b&gt;&quot;glob&quot;&lt;/b&gt; ) se usa en un contexto en el que no se puede resolver en un identificador pero donde se permite un literal de cadena, entonces se entiende que el token es un literal de cadena en lugar de un identificador.</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">Si una palabra clave entre comillas simples (por ejemplo: &lt;b&gt;'clave'&lt;/b&gt; o &lt;b&gt;'glob'&lt;/b&gt; ) se usa en un contexto donde se permite un identificador pero donde no se permite un literal de cadena, entonces se entiende que el token es un identificador en lugar de un literal de cadena .</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">Si una frase coincidente forma parte de una serie de frases conectadas por operadores NEAR en la expresión de consulta de la ETF,entonces cada frase coincidente debe ser lo suficientemente cercana a otras frases coincidentes de los tipos pertinentes para satisfacer la condición NEAR.</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">Si se desea una tabla virtual con nombre que utilice el módulo dbstat,entonces la forma recomendada de crear una instancia de la tabla virtual dbstat es la siguiente:</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">Si un literal numérico tiene un punto decimal o una cláusula de exponenciación o si su magnitud es menor que -9223372036854775808 o mayor que 9223372036854775807,entonces es un literal de punto flotante.De lo contrario es un literal entero.El carácter &quot;E&quot; que comienza la cláusula de exponenciación de un literal en coma flotante puede ser mayúscula o minúscula.El carácter &quot;.&quot; siempre se utiliza como punto decimal incluso si el ajuste de la localidad especifica &quot;,&quot; para este papel-el uso de &quot;,&quot; para el punto decimal resultaría en una ambigüedad sintáctica.</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">Si una página no contiene celdas (lo que sólo es posible para una página raíz de una tabla que no contiene filas)entonces el desplazamiento al área de contenido de la celda será igual al tamaño de la página menos los bytes de espacio reservado.Si la base de datos utiliza un tamaño de página de 65536 bytes y el espacio reservado es cero (el valor habitual para el espacio reservado),entonces el desplazamiento del contenido de la célula de una página vacía quiere ser de 65536.Sin embargo,ese entero es demasiado grande para ser almacenado en un entero de 2 bytes sin signo,por lo que se utiliza un valor de 0 en su lugar.</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">Si el nombre de un parámetro comienza con un &quot;:&quot;,entonces se supone que es un valor que debe vincularse a la instrucción SQL antes de ejecutarla.El valor siempre se vincula como texto.Se trata de un error si el parámetro SQL especificado no existe.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">Si se produce un fallo de alimentación o una caída del sistema operativo en este punto,la transacción no se retrocederá cuando el sistema se reinicie,aunque haya diarios de retroceso presentes.La diferencia es la ruta del diario maestro en el encabezado del diario de retroceso.Al reiniciar,SQLite sólo considera que un diario está activo y sólo reproducirá el diario si no hay un nombre de archivo del diario maestro en el encabezado (que es el caso de una confirmación de un solo archivo)o si el archivo del diario maestro sigue existiendo en el disco.</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">Si se produce un fallo de alimentación o del sistema operativo mientras se copia el archivo de la base de datos,la base de datos de reserva puede corromperse tras la recuperación del sistema.</target>
        </trans-unit>
        <trans-unit id="1e430e1109b182ad5e2d81ffc690ca581b0a1b35" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indexes to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. Event bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">Si una consulta contiene una cláusula ORDER BY con múltiples términos,puede ser que SQLite pueda utilizar índices para hacer que las filas salgan en el orden de algún prefijo de los términos del ORDER BY pero que no se satisfagan los términos posteriores del ORDER BY.En ese caso,SQLite hace una clasificación por bloques.Supongamos que la cláusula ORDER BY tiene cuatro términos y el orden natural de la consulta hace que aparezcan filas en el orden de los dos primeros términos.A medida que cada fila es emitida por el motor de consulta y entra en el clasificador,las salidas de la fila actual correspondientes a los dos primeros términos del ORDEN POR se comparan con la fila anterior.Si han cambiado,la clasificación actual se termina y la salida y una nueva clasificación se inicia.Esto da como resultado una clasificación ligeramente más rápida.Pero las mayores ventajas son que se necesitan muchas menos filas en la memoria,lo que reduce los requisitos de memoria,y los resultados pueden comenzar a aparecer antes de que la consulta del núcleo haya terminado.</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">Si una consulta no contiene ninguna función agregada,entonces se puede añadir una cláusula GROUP BY en sustitución de la cláusula DISTINCT ON.En otras palabras,las filas de salida se filtran de manera que sólo se muestra una fila para cada conjunto de valores distintos en la cláusula GROUP BY.Si dos o más filas de salida hubieran tenido de otro modo el mismo conjunto de valores para las columnas GROUP BY,entonces una de las filas se elige arbitrariamente.</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">Si un cliente de lectura / escritura invoca &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; ) antes del apagado, al apagarlo se sigue ejecutando un punto de control, pero el archivo shm y el archivo wal no se eliminan. Esto permite que los clientes posteriores de solo lectura se conecten y lean la base de datos.</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Si se encuentra una fila con valores de clave primaria coincidentes, pero uno o m&amp;aacute;s de los campos de clave no primaria modificados contienen un valor diferente de un valor de fila original almacenado en el conjunto de cambios, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; como segundo argumento . Dado que los cambios de UPDATE solo contienen valores para campos de clave no primaria que se van a modificar, solo esos campos deben coincidir con los valores originales para evitar la devoluci&amp;oacute;n de llamada del controlador de conflictos SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Si se encuentra una fila con valores de clave primaria coincidentes, pero uno o m&amp;aacute;s de los campos de clave no primaria modificados contienen un valor diferente de un valor de fila original almacenado en el conjunto de cambios, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; como segundo argumento . Dado que los cambios de UPDATE solo contienen valores para campos de clave no primaria que se van a modificar, solo esos campos deben coincidir con los valores originales para evitar la devoluci&amp;oacute;n de llamada del controlador de conflictos SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Si se encuentra una fila con valores de clave primaria coincidentes, pero uno o m&amp;aacute;s de los campos de clave no primaria contienen un valor diferente del valor de fila original almacenado en el conjunto de cambios, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; como segundo argumento. Si la tabla de la base de datos tiene m&amp;aacute;s columnas de las que se registran en el conjunto de cambios, solo los valores de esos campos de clave no primaria se comparan con el contenido actual de la base de datos; se ignoran las columnas de la tabla de la base de datos final.</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Si se encuentra una fila con valores de clave primaria coincidentes, pero uno o m&amp;aacute;s de los campos de clave no primaria contienen un valor diferente del valor de fila original almacenado en el conjunto de cambios, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; como segundo argumento. Si la tabla de la base de datos tiene m&amp;aacute;s columnas de las que se registran en el conjunto de cambios, solo los valores de esos campos de clave no primaria se comparan con el contenido actual de la base de datos; se ignoran las columnas de la tabla de la base de datos final.</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">Si se especifica un nombre de esquema como parte de una referencia de objeto,debe ser &quot;principal&quot; o &quot;temporal&quot; o el nombre de esquema de una base de datos adjunta.Al igual que otros identificadores SQL,los nombres de esquema no distinguen entre mayúsculas y minúsculas.Si se especifica un nombre de esquema,sólo se busca en ese esquema el objeto nombrado.</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">Si se especifica un nombre de esquema, debe ser &quot;main&quot;, &quot;temp&quot; o el nombre de una &lt;a href=&quot;lang_attach&quot;&gt;base de datos adjunta&lt;/a&gt; . En este caso, la nueva tabla se crea en la base de datos nombrada. Si la palabra clave &quot;TEMP&quot; o &quot;TEMPORARY&quot; se encuentra entre &quot;CREATE&quot; y &quot;TABLE&quot;, la nueva tabla se crea en la base de datos temporal. Es un error especificar tanto un nombre de esquema como la palabra clave TEMP o TEMPORARY, a menos que el nombre de esquema sea &quot;temp&quot;. Si no se especifica ning&amp;uacute;n nombre de esquema y la palabra clave TEMP no est&amp;aacute; presente, la tabla se crea en la base de datos principal.</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">Si se especifica un nombre de esquema,entonces la vista se crea en la base de datos especificada.Es un error especificar tanto un nombre de esquema como la palabra clave TEMP en una VISTA,a menos que el nombre de esquema sea &quot;temp&quot;.Si no se especifica un nombre de esquema y la palabra clave TEMP no está presente,el VIEW se crea en la base de datos principal.</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">Si un token de b&amp;uacute;squeda (en el lado derecho del operador COINCIDIR) en &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; comienza con &quot;^&quot;, entonces ese token debe ser el primero en su campo del documento. &lt;b&gt;** Cambio potencialmente incompatible **&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Si un hilo separado realiza cambios en la misma conexi&amp;oacute;n de base de datos mientras &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes () se&lt;/a&gt; est&amp;aacute; ejecutando, entonces el valor devuelto es impredecible y no significativo.</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Si un hilo separado realiza cambios en la misma conexi&amp;oacute;n de base de datos mientras &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes () se&lt;/a&gt; est&amp;aacute; ejecutando, entonces el valor devuelto es impredecible y no significativo.</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Si un hilo separado realiza cambios en la misma conexi&amp;oacute;n de base de datos mientras &lt;a href=&quot;changes&quot;&gt;sqlite3_changes () se&lt;/a&gt; est&amp;aacute; ejecutando, entonces el valor devuelto es impredecible y no significativo.</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Si un hilo separado realiza cambios en la misma conexi&amp;oacute;n de base de datos mientras &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes () se&lt;/a&gt; est&amp;aacute; ejecutando, entonces el valor devuelto es impredecible y no significativo.</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Si un subproceso independiente realiza un nuevo &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; en la misma conexi&amp;oacute;n de base de datos mientras se est&amp;aacute; ejecutando la &lt;a href=&quot;last_insert_rowid&quot;&gt;funci&amp;oacute;n sqlite3_last_insert_rowid ()&lt;/a&gt; y, por lo tanto, cambia el &amp;uacute;ltimo &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;identificador de fila&lt;/a&gt; insertado , entonces el valor devuelto por &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; es impredecible y puede que no sea igual al anterior o al nuevo &amp;uacute;ltimo insertar &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Si un subproceso independiente realiza un nuevo &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; en la misma conexi&amp;oacute;n de base de datos mientras se est&amp;aacute; ejecutando la &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;funci&amp;oacute;n sqlite3_last_insert_rowid ()&lt;/a&gt; y, por lo tanto, cambia el &amp;uacute;ltimo &lt;a href=&quot;lang_createtable#rowid&quot;&gt;identificador de fila&lt;/a&gt; insertado , entonces el valor devuelto por &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; es impredecible y puede que no sea igual al anterior o al nuevo &amp;uacute;ltimo insertar &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">Si un solo archivo de base de datos tiene múltiples enlaces (ya sea duros o blandos)entonces es sólo otra forma de decir que el archivo tiene múltiples nombres.Si dos o más procesos abren la base de datos usando nombres diferentes,entonces usarán diferentes diarios de retroceso y archivos WAL.Esto significa que si un proceso falla,el otro proceso no podrá recuperar la transacción en curso porque estará buscando en el lugar equivocado el diario apropiado.</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">Si una sola fila se ve afectada por más de una operación dentro de una sesión,entonces el cambio se considera indirecto si todas las operaciones cumplen los criterios para un cambio indirecto arriba mencionados,o directo de otra manera.</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">Si una declaraci&amp;oacute;n modifica el contenido de la base de datos de modo que una restricci&amp;oacute;n de clave externa inmediata viola la conclusi&amp;oacute;n de la declaraci&amp;oacute;n, se lanza una excepci&amp;oacute;n y se revierten los efectos de la declaraci&amp;oacute;n. Por el contrario, si una declaraci&amp;oacute;n modifica el contenido de la base de datos de manera que se infringe una restricci&amp;oacute;n de clave externa diferida, la infracci&amp;oacute;n no se informa de inmediato. Las restricciones de claves for&amp;aacute;neas diferidas no se comprueban hasta que la transacci&amp;oacute;n intenta &lt;a href=&quot;lang_transaction&quot;&gt;COMPROMETERSE&lt;/a&gt; . Mientras el usuario tenga una transacci&amp;oacute;n abierta, la base de datos puede existir en un estado que viole cualquier n&amp;uacute;mero de restricciones de clave externa diferidas. Sin embargo, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; fallar&amp;aacute; siempre que se sigan infringiendo las restricciones de clave externa.</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">Si una subconsulta no se puede &lt;a href=&quot;optoverview#flattening&quot;&gt;acoplar&lt;/a&gt; en la consulta externa, a&amp;uacute;n podr&amp;iacute;a ser posible mejorar el rendimiento &quot;presionando hacia abajo&quot; los t&amp;eacute;rminos de la cl&amp;aacute;usula WHERE de la consulta externa a la subconsulta. Considere un ejemplo:</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">Si se produce un fallo del sistema en cualquier momento después de que una operación de &quot;borrado de archivos&quot; (llamada al método VFS xDelete())regrese con éxito,se supone que el sistema de archivos no contendrá el archivo borrado tras la recuperación del sistema.</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">Si se produce un fallo del sistema durante una operación de &quot;eliminación de archivos&quot;,se supone que,tras la recuperación del sistema,el sistema de archivos contendrá el archivo que se está eliminando en el estado en que se encontraba antes de que se intentara la operación,o no contendrá el archivo en absoluto.Se supone que no es posible que el archivo se haya corrompido únicamente como resultado de un fallo ocurrido durante una operación de &quot;eliminación de archivos&quot;.</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">Si se produce un fallo del sistema durante o después de una operación de &quot;creación de un archivo&quot;,pero antes de que el archivo creado haya sido</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">Si se produce un fallo del sistema durante o después de una operación de &quot;truncamiento de archivos&quot;,pero antes de que el archivo truncado haya sido</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">Si se produce un fallo del sistema durante o después de una operación de &quot;escritura de archivos&quot; que hace que el archivo crezca,pero antes de que el archivo correspondiente haya sido</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">Si se produce un fallo del sistema durante o después de una operación de &quot;escritura de archivos&quot;,pero antes de que el archivo correspondiente haya sido</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">Si se produce un fallo en un sistema que soporta la</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">Si un sistema soporta</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">Si un sistema soporta la</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">Si una tabla contiene una columna de tipo &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , esa columna se convierte en un alias para ROWID. Luego puede acceder al ROWID usando cualquiera de los cuatro nombres diferentes, los tres nombres originales descritos anteriormente o el nombre dado a la columna &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Todos estos nombres son alias entre s&amp;iacute; y funcionan igualmente bien en cualquier contexto.</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">Si una tabla tiene una clave primaria de una sola columna y el tipo declarado de esa columna es &quot;INTEGER&quot; y la tabla no es una tabla &lt;a href=&quot;withoutrowid&quot;&gt;SIN ROWID&lt;/a&gt; , entonces la columna se conoce como una &lt;a href=&quot;lang_createtable#rowid&quot;&gt;CLAVE PRIMARIA INTEGER&lt;/a&gt; . Consulte a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; para obtener una descripci&amp;oacute;n de las propiedades y comportamientos especiales asociados con una &lt;a href=&quot;lang_createtable#rowid&quot;&gt;CLAVE PRIMARIA INTEGER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">Si un término en X es de la forma &quot;z NO ES NULO&quot; y si un término en W es un operador de comparación en &quot;z&quot; distinto de &quot;IS&quot;,entonces esos términos coinciden.</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">Si un término de la cláusula WHERE es de la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">Si una transacción implica múltiples bases de datos,se utiliza una secuencia de confirmación más compleja,como se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">Si se aborta una transacción debido a una caída de la aplicación,una caída del sistema operativo o un fallo o caída de la alimentación del hardware,entonces la base de datos puede quedar en un estado inconsistente.La próxima vez que SQLite intente abrir el archivo de la base de datos,se detectará la presencia del archivo de diario de retroceso y el diario se reproducirá automáticamente para restaurar la base de datos a su estado al comienzo de la transacción incompleta.</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Si una transacci&amp;oacute;n de escritura est&amp;aacute; abierta en la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de base&lt;/a&gt; de datos D cuando se invoca la interfaz &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , cualquier p&amp;aacute;gina sucia en la cach&amp;eacute; del buscapersonas que no est&amp;eacute; actualmente en uso se escribe en el disco. Una p&amp;aacute;gina sucia puede estar en uso si un cursor de base de datos creado por una declaraci&amp;oacute;n SQL activa est&amp;aacute; leyendo de ella, o si es la p&amp;aacute;gina 1 de un archivo de base de datos (la p&amp;aacute;gina 1 siempre est&amp;aacute; &quot;en uso&quot;). La interfaz &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; vac&amp;iacute;a las cach&amp;eacute;s de todos los esquemas: &quot;principal&quot;, &quot;temp&quot; y cualquier base de datos &lt;a href=&quot;lang_attach&quot;&gt;adjunta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Si una transacci&amp;oacute;n de escritura est&amp;aacute; abierta en la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de base&lt;/a&gt; de datos D cuando se invoca la interfaz &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , cualquier p&amp;aacute;gina sucia en la cach&amp;eacute; del buscapersonas que no est&amp;eacute; actualmente en uso se escribe en el disco. Una p&amp;aacute;gina sucia puede estar en uso si un cursor de base de datos creado por una declaraci&amp;oacute;n SQL activa est&amp;aacute; leyendo de ella, o si es la p&amp;aacute;gina 1 de un archivo de base de datos (la p&amp;aacute;gina 1 siempre est&amp;aacute; &quot;en uso&quot;). La interfaz &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; vac&amp;iacute;a las cach&amp;eacute;s de todos los esquemas: &quot;principal&quot;, &quot;temp&quot; y cualquier base de datos &lt;a href=&quot;../lang_attach&quot;&gt;adjunta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">Si se inicia una transacción de escritura y el indicador Vdbe.usesStmtJournal es verdadero (este indicador se activa si el Vdbe puede modificar más de una fila y puede lanzar una excepción ABORT),también se puede abrir una transacción de declaración.Más concretamente,se abre una transacción de declaración si la conexión de la base de datos no está actualmente en modo de autocomisión,o si hay otras declaraciones activas.Una transacción de extracto permite que los cambios realizados por esta VDBE se retrocedan después de un error sin tener que retroceder toda la transacción.Si no se encuentra ningún error,la transacción de declaración se confirmará automáticamente cuando el VDBE se detenga.</target>
        </trans-unit>
        <trans-unit id="b5fbd175e5cd25d62d623adf09f78e07d2af672b" translate="yes" xml:space="preserve">
          <source>If after This.P1 steps, the cursor is still point to a place that is earlier in the btree than the target row, then fall through into the subsquence &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">Si los tres pasos enumerados anteriormente se ejecutan con éxito,entonces es seguro modificar el contenido de la</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">Si una &quot;MESA ALTERNA&quot;...RENOMBRAR A&quot; para cambiar el nombre de una tabla que es la tabla matriz de una o más restricciones de clave externa,las definiciones de las restricciones de clave externa se modifican para referirse a la tabla matriz por su nuevo nombre.El texto de la sentencia CREATE TABLE hija o las sentencias almacenadas en la tabla sqlite_master se modifican para reflejar el nuevo nombre de la tabla padre.</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Si un objeto &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; se destruye mientras una transacci&amp;oacute;n est&amp;aacute; abierta, la transacci&amp;oacute;n se revierte autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Si se produce un &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; dentro de un disparador, esta rutina devolver&amp;aacute; el &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;identificador&lt;/a&gt; de fila de la fila insertada siempre que el disparador est&amp;eacute; en ejecuci&amp;oacute;n. Una vez que finaliza el programa de disparo, el valor devuelto por esta rutina vuelve a ser el que era antes de que se disparara el disparador.</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Si se produce un &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; dentro de un disparador, esta rutina devolver&amp;aacute; el &lt;a href=&quot;lang_createtable#rowid&quot;&gt;identificador&lt;/a&gt; de fila de la fila insertada siempre que el disparador est&amp;eacute; en ejecuci&amp;oacute;n. Una vez que finaliza el programa de disparo, el valor devuelto por esta rutina vuelve a ser el que era antes de que se disparara el disparador.</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Si un objeto &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; se destruye mientras una transacci&amp;oacute;n est&amp;aacute; abierta, la transacci&amp;oacute;n se revierte autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">Si una tabla FTS5 est&amp;aacute; configurada con tama&amp;ntilde;o de columna = 0 pero no es una &lt;a href=&quot;fts5#contentless_tables&quot;&gt;tabla sin contenido&lt;/a&gt; , la funci&amp;oacute;n de la API xColumnSize a&amp;uacute;n funciona, pero se ejecuta mucho m&amp;aacute;s lentamente. En este caso, en lugar de leer el valor para regresar directamente desde la base de datos, lee el valor de texto en s&amp;iacute; y cuenta los tokens dentro de &amp;eacute;l a pedido.</target>
        </trans-unit>
        <trans-unit id="54d66d7577e86e2b88484e46218701181acd86ca" translate="yes" xml:space="preserve">
          <source>If an FTS5 trigram tokenizer is created with the case_sensitive option set to 1, it may only index GLOB queries, not LIKE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">Si una instrucci&amp;oacute;n INSERT intenta insertar un valor NULL en una columna de clave primaria de n&amp;uacute;mero de fila o de n&amp;uacute;mero entero, el sistema elige un valor de n&amp;uacute;mero entero para usar como el ID de fila autom&amp;aacute;ticamente. Se proporciona una descripci&amp;oacute;n detallada de c&amp;oacute;mo se hace esto por &lt;a href=&quot;autoinc&quot;&gt;separado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">Si hay una cláusula ORDER BY,determina el orden en que las filas se extraen de la cola en el paso 2a.Si no hay una cláusula ORDER BY,entonces el orden en que se extraen las filas no está definido.(En la implementación actual,la cola se convierte en FIFO si se omite la cláusula ORDER BY,pero las aplicaciones no deberían depender de ese hecho ya que podría cambiar).</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">Si una operación SQL está muy cerca de terminar en el momento en que se llama a sqlite3_interrupt(),entonces puede que no tenga la oportunidad de ser interrumpida y pueda continuar hasta su finalización.</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">Si una declaraci&amp;oacute;n SQL est&amp;aacute; limitada a un mill&amp;oacute;n de bytes de longitud, obviamente no podr&amp;aacute; insertar cadenas de varios millones de bytes incrust&amp;aacute;ndolas como literales dentro de las declaraciones INSERT. Pero no deber&amp;iacute;as hacer eso de todos modos. Utilice &lt;a href=&quot;lang_expr#varparam&quot;&gt;par&amp;aacute;metros de&lt;/a&gt; host para sus datos. Prepare declaraciones SQL cortas como esta:</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">Si se crea una tabla SQL usando la cl&amp;aacute;usula &quot;WITHOUT ROWID&quot; al final de su instrucci&amp;oacute;n CREATE TABLE, entonces esa tabla es una tabla &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; y usa una representaci&amp;oacute;n en disco diferente. Una tabla SIN ROWID utiliza un &amp;aacute;rbol b de &amp;iacute;ndice en lugar de un &amp;aacute;rbol b de tabla para el almacenamiento. La clave para cada entrada en el &amp;aacute;rbol b WITHOUT ROWID es un registro compuesto por las columnas de la CLAVE PRIMARIA seguida de todas las columnas restantes de la tabla. Las columnas de clave primaria aparecen en el orden en que fueron declaradas en la cl&amp;aacute;usula PRIMARY KEY y las columnas restantes aparecen en el orden en que aparecen en la sentencia CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">Si una declaración UPDATE intenta establecer una clave primaria de un entero o una columna de una fila a un valor NULL o blob,o a una cadena o valor real que no puede ser convertido sin pérdidas a un entero,se produce un error de &quot;desajuste de tipo de datos&quot; y la declaración se aborta.Si una instrucción INSERT intenta insertar un valor blob,o una cadena o valor real que no puede ser convertido sin pérdidas a un número entero en una clave primaria de número entero o en una columna de tipo &quot;rowid&quot;,se produce un error de &quot;desajuste de tipo de datos&quot; y la instrucción se aborta.</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">Si una declaración de ACTUALIZACIÓN tiene una cláusula LÍMITE,el número máximo de filas que se actualizarán se encuentra evaluando la expresión que la acompaña y castigándola con un valor entero.Un valor negativo se interpreta como &quot;sin límite&quot;.</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">Si una aplicación emite una declaración SELECT en una sola tabla como &quot;</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">Si una aplicaci&amp;oacute;n pone SQLite en &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;modo de bloqueo exclusivo&lt;/a&gt; usando el pragma:</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">Si una aplicaci&amp;oacute;n que utiliza E / S as&amp;iacute;ncrona ejecuta transacciones en r&amp;aacute;pida sucesi&amp;oacute;n, es posible que otros usuarios de la base de datos se bloqueen efectivamente de la base de datos. Esto se debe a que cuando se ejecuta un &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; , se establece inmediatamente un bloqueo de base de datos. Pero cuando ocurre el COMMIT o ROLLBACK correspondiente, el bloqueo no se libera hasta que la parte relevante de la cola de escritura se haya limpiado. Como resultado, si un COMMIT va seguido de un BEGIN antes de que se vac&amp;iacute;e la cola de escritura, la base de datos nunca se desbloquea, lo que impide que otros procesos accedan a la base de datos.</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">Si un intento de adquirir una</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">Si un intento de actualizar a un</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">Si se produce un error (por ejemplo,una condición OOM)dentro de esta función,los datos auxiliares se establecen en NULL y se devuelve un código de error.Si el parámetro xDelete no era NULL,se invoca en el puntero de datos auxiliares antes de devolverlo.</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">Si se produce un error en cualquiera de las tres rutinas principales de la API de respaldo, el &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; y el &lt;a href=&quot;c3ref/errcode&quot;&gt;mensaje&lt;/a&gt; se adjuntan a la &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino . Adem&amp;aacute;s, si &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; encuentra un error, el &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; es devuelto por la propia llamada &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; y por la llamada posterior a &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; . Entonces, una llamada a &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; no sobrescribe un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; almacenado en la &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino por &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt;. Esta caracter&amp;iacute;stica se usa en el c&amp;oacute;digo de ejemplo para reducir la cantidad de manejo de errores requerido. Los valores de retorno de las llamadas &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; y &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; se ignoran y el c&amp;oacute;digo de error indica el &amp;eacute;xito o el fracaso de la operaci&amp;oacute;n de copia recopilada de la &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino posteriormente.</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Si ocurre un error al evaluar las sentencias SQL pasadas a sqlite3_exec (), la ejecuci&amp;oacute;n de la sentencia actual se detiene y las sentencias subsiguientes se saltan. Si el quinto par&amp;aacute;metro de sqlite3_exec () no es NULL, cualquier mensaje de error se escribe en la memoria obtenida de &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; y se devuelve al quinto par&amp;aacute;metro. Para evitar p&amp;eacute;rdidas de memoria, la aplicaci&amp;oacute;n debe invocar &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; en las cadenas de mensajes de error devueltas a trav&amp;eacute;s del quinto par&amp;aacute;metro de sqlite3_exec () despu&amp;eacute;s de que la cadena de mensajes de error ya no sea necesaria. Si el quinto par&amp;aacute;metro de sqlite3_exec () no es NULL y no ocurren errores, entonces sqlite3_exec () establece el puntero en su quinto par&amp;aacute;metro en NULL antes de regresar.</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Si ocurre un error al evaluar las sentencias SQL pasadas a sqlite3_exec (), la ejecuci&amp;oacute;n de la sentencia actual se detiene y las sentencias subsiguientes se saltan. Si el quinto par&amp;aacute;metro de sqlite3_exec () no es NULL, cualquier mensaje de error se escribe en la memoria obtenida de &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; y se devuelve al quinto par&amp;aacute;metro. Para evitar p&amp;eacute;rdidas de memoria, la aplicaci&amp;oacute;n debe invocar &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; en las cadenas de mensajes de error devueltas a trav&amp;eacute;s del quinto par&amp;aacute;metro de sqlite3_exec () despu&amp;eacute;s de que la cadena de mensajes de error ya no sea necesaria. Si el quinto par&amp;aacute;metro de sqlite3_exec () no es NULL y no ocurren errores, entonces sqlite3_exec () establece el puntero en su quinto par&amp;aacute;metro en NULL antes de regresar.</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Si ocurre un error dentro de sqlite3_backup_init (D, N, S, M), entonces se devuelve NULL y un c&amp;oacute;digo de error y un mensaje de error se almacenan en la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino D. El c&amp;oacute;digo de error y el mensaje de la llamada fallida a sqlite3_backup_init () pueden recuperarse utilizando las funciones &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; y / o &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Una llamada exitosa a sqlite3_backup_init () devuelve un puntero a un objeto &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; . El objeto &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; puede usarse con las funciones sqlite3_backup_step () y sqlite3_backup_finish () para realizar la operaci&amp;oacute;n de respaldo especificada.</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Si ocurre un error dentro de sqlite3_backup_init (D, N, S, M), entonces se devuelve NULL y un c&amp;oacute;digo de error y un mensaje de error se almacenan en la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; destino D. El c&amp;oacute;digo de error y el mensaje de la llamada fallida a sqlite3_backup_init () pueden recuperarse utilizando las funciones &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; y / o &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Una llamada exitosa a sqlite3_backup_init () devuelve un puntero a un objeto &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; . El objeto &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; puede usarse con las funciones sqlite3_backup_step () y sqlite3_backup_finish () para realizar la operaci&amp;oacute;n de respaldo especificada.</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">Si se produce un error,se devuelve un código de error SQLite y las variables de salida (*pnData)y (*ppData)se establecen en 0.En caso contrario,se devuelve SQLITE_OK y las variables de salida se establecen en el tamaño y un puntero al búfer de salida,respectivamente.En este caso,es responsabilidad del llamador liberar eventualmente el búfer mediante una llamada a sqlite3_free().</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">Si se produce un error,se devuelve un código de error SQLite.Entre los posibles códigos de error se encuentran SQLITE_CORRUPT (si el búfer de cambios está corrupto)o SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Si se encontr&amp;oacute; un error dentro de una llamada a una funci&amp;oacute;n sqlite3changeset_xxx () (por ejemplo, un &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; en &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; o un &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; en &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), esta funci&amp;oacute;n devuelve un c&amp;oacute;digo de error correspondiente a ese error. De lo contrario, se devuelve SQLITE_OK. Esto es para permitir el siguiente patr&amp;oacute;n (pseudoc&amp;oacute;digo):</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Si se encontr&amp;oacute; un error dentro de una llamada a una funci&amp;oacute;n sqlite3changeset_xxx () (por ejemplo, un &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; en &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; o un &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; en &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), esta funci&amp;oacute;n devuelve un c&amp;oacute;digo de error correspondiente a ese error. De lo contrario, se devuelve SQLITE_OK. Esto es para permitir el siguiente patr&amp;oacute;n (pseudoc&amp;oacute;digo):</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">Si se crea un cuadro fts5vocab en la base de datos temporal,puede asociarse con un cuadro FTS5 en cualquier base de datos adjunta.Para adjuntar el cuadro fts5vocab a un cuadro FTS5 ubicado en una base de datos que no sea &quot;temp&quot;,el nombre de la base de datos se inserta antes del nombre del cuadro FTS5 en los argumentos CREATE VIRTUAL TABLE.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">Si hay un índice disponible en la columna ORDENAR POR,ese índice puede ser utilizado para la clasificación.Considere la solicitud de todos los artículos clasificados por &quot;fruta&quot;:</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">Si se crea un índice usando una declaración como esta:</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">Si una instancia-lista crece tan grande que supera el &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; l&amp;iacute;mite, FTS3 / 4 no es capaz de manejar la situaci&amp;oacute;n. FTS5 no tiene este problema.</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">Si una interfaz falla con SQLITE_MISUSE,eso significa que la interfaz fue invocada incorrectamente por la aplicación.En ese caso,el código de error y el mensaje pueden o no estar configurados.</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Si se produce un error de memoria insuficiente, el valor de retorno de estas rutinas es el mismo que si la columna hubiera contenido un valor NULL de SQL. Los retornos SQL NULL v&amp;aacute;lidos se pueden distinguir de los errores de memoria insuficiente invocando &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; inmediatamente despu&amp;eacute;s de que se obtenga el valor de retorno sospechoso y antes de que se llame a cualquier otra interfaz SQLite en la misma &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de base de datos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Si se produce un error de memoria insuficiente, el valor de retorno de estas rutinas es el mismo que si la columna hubiera contenido un valor NULL de SQL. Los retornos SQL NULL v&amp;aacute;lidos se pueden distinguir de los errores de memoria insuficiente invocando &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; inmediatamente despu&amp;eacute;s de que se obtenga el valor de retorno sospechoso y antes de que se llame a cualquier otra interfaz SQLite en la misma &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de base de datos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">Si una llamada de sqlite3_exec()devuelve un valor distinto de cero,la rutina sqlite3_exec()devuelve SQLITE_ABORT sin volver a invocar la llamada y sin ejecutar ninguna instrucción SQL posterior.</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">Si una actualización sólo se aplica parcialmente a la base de datos del objetivo en el momento en que se llama a sqlite3rbu_close(),la información del estado se guarda dentro de la base de datos del estado si existe,o de otra manera en la base de datos de la RBU.Esto permite que los procesos posteriores reanuden automáticamente la actualización de la RBU desde donde la dejaron.Si la información de estado se almacena en la base de datos de la RBU,puede eliminarse eliminando todas las tablas cuyos nombres empiecen por &quot;rbu_&quot;.</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">Si una llamada de xToken()devuelve cualquier otro valor que no sea SQLITE_OK,entonces se debe abandonar la conversión a token y el método xTokenize()debe devolver inmediatamente una copia del valor de retorno xToken().O,si el búfer de entrada se agota,xTokenize()debería devolver SQLITE_OK.Por último,si se produce un error con la propia implementación de xTokenize(),puede abandonar la conversión a token y devolver cualquier código de error que no sea SQLITE_OK o SQLITE_DONE.</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">Si y sólo si la conversión anteriormente descrita de OR a un operador IN no funciona,se intenta la segunda optimización de la cláusula OR.Supongamos que la cláusula OR consta de múltiples subterfugios como se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">Si otra conexi&amp;oacute;n de base de datos tiene el modo de base de datos abierto en &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;modo de bloqueo exclusivo,&lt;/a&gt; todas las consultas contra la base de datos devolver&amp;aacute;n &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Tanto Chrome como Firefox abren sus archivos de base de datos en modo de bloqueo exclusivo, por lo que los intentos de leer las bases de datos de Chrome o Firefox mientras se ejecutan las aplicaciones se encontrar&amp;aacute;n con este problema, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">Si otro hilo cambia el estado de autocomisión de la conexión de la base de datos mientras se está ejecutando esta rutina,entonces el valor de retorno no está definido.</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">Si otro hilo o proceso escribe en la base de datos de origen mientras esta función está durmiendo,entonces SQLite lo detecta y suele reiniciar el proceso de copia de seguridad cuando se llama a continuación a sqlite3_backup_step().Hay una excepción a esta regla:si la base de datos de origen no es una base de datos en memoria,y la escritura se realiza desde el mismo proceso que la operación de copia de seguridad y utiliza el mismo manejador de base de datos (pDb),entonces la base de datos de destino (la que se abre usando la conexión pFile)se actualiza automáticamente junto con la fuente.El proceso de respaldo puede entonces continuar después de que la llamada sqlite3_sleep()regrese como si nada hubiera pasado.</target>
        </trans-unit>
        <trans-unit id="6abf22da0f107c51712228d5db063535c6a4d21a" translate="yes" xml:space="preserve">
          <source>If any application-defined SQL functions have potentially dangerous side-effects, or if they could potentially leak sensitive information to an attacker if misused, then tag those functions using the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; option on the &quot;enc&quot; parameter. This means that the function can never be run from schema-code even if the trusted-schema option is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452fe80b19e0f85e5121496bd6edf4647e872526" translate="yes" xml:space="preserve">
          <source>If any checksum is incorrect, the &quot;PRAGMA quick_check&quot; command will find it. To verify that checksums are actually enabled and running, use SQL like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">Si se encuentran errores durante la compilaci&amp;oacute;n, se escribe un mensaje de error en la memoria obtenida de &lt;b&gt;malloc&lt;/b&gt; y se hace que el quinto par&amp;aacute;metro apunte a esa memoria. Si el quinto par&amp;aacute;metro es NULL, no se genera ning&amp;uacute;n mensaje de error. Si el quinto par&amp;aacute;metro no es NULL, entonces la funci&amp;oacute;n de llamada debe deshacerse de la memoria que contiene el mensaje de error llamando a &lt;b&gt;sqlite_freemem&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">Si se omite alguna de las entradas de casos especiales que se muestran arriba,entonces se utiliza el valor de 100 para la inserción y la supresión y 150 para la sustitución.Para deshabilitar la inserción,eliminación y/o sustitución por defecto,establezca su respectivo costo en 10000 o más.</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Si se llama a cualquiera de las rutinas sqlite3_bind _ * () con un puntero NULL para la &lt;a href=&quot;#sqlite3_stmt&quot;&gt;instrucci&amp;oacute;n preparada&lt;/a&gt; o con una instrucci&amp;oacute;n preparada para la cual &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; se ha llamado m&amp;aacute;s recientemente que &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , entonces la llamada devolver&amp;aacute; &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Si cualquier rutina sqlite3_bind_ () se pasa una &lt;a href=&quot;#sqlite3_stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; que ha sido finalizada, el resultado no est&amp;aacute; definido y probablemente da&amp;ntilde;ino.</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Si se llama a cualquiera de las rutinas sqlite3_bind _ * () con un puntero NULL para la &lt;a href=&quot;stmt&quot;&gt;instrucci&amp;oacute;n preparada&lt;/a&gt; o con una instrucci&amp;oacute;n preparada para la cual &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; se ha llamado m&amp;aacute;s recientemente que &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , entonces la llamada devolver&amp;aacute; &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Si cualquier rutina sqlite3_bind_ () se pasa una &lt;a href=&quot;stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; que ha sido finalizada, el resultado no est&amp;aacute; definido y probablemente da&amp;ntilde;ino.</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">Si se define alguna de estas opciones, entonces tambi&amp;eacute;n se debe definir el mismo conjunto de opciones SQLITE_OMIT_ * cuando se usa la herramienta &lt;a href=&quot;lemon&quot;&gt;generadora del analizador Lemon&lt;/a&gt; para generar el archivo parse.cy cuando se compila la herramienta 'mkkeywordhash' que genera el archivo keywordhash.h. Debido a esto, estas opciones solo se pueden usar cuando la biblioteca se crea a partir de una fuente can&amp;oacute;nica, no a partir de la &lt;a href=&quot;amalgamation&quot;&gt;fusi&amp;oacute;n&lt;/a&gt; . Algunas opciones de SQLITE_OMIT_ * pueden funcionar, o parecer que funcionan, cuando se usan con la &lt;a href=&quot;amalgamation&quot;&gt;fusi&amp;oacute;n&lt;/a&gt; . Pero esto no est&amp;aacute; garantizado. En general, compile siempre a partir de fuentes can&amp;oacute;nicas para aprovechar las opciones de SQLITE_OMIT_ *.</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">Si se produce cualquier otra violación de la restricción mientras se aplica un cambio (es decir,una restricción ÚNICA,VERIFICADA o NO NULADA),se invoca el manejador de conflictos con CHANGESET_CONSTRAINT como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Si se produce cualquier otro error al descargar p&amp;aacute;ginas sucias en el disco (por ejemplo, un error de E / S o una condici&amp;oacute;n de falta de memoria), el procesamiento se abandona y se devuelve un &lt;a href=&quot;../rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; SQLite a la persona que llama inmediatamente.</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Si se produce cualquier otro error al descargar p&amp;aacute;ginas sucias en el disco (por ejemplo, un error de E / S o una condici&amp;oacute;n de falta de memoria), el procesamiento se abandona y se devuelve un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; SQLite a la persona que llama inmediatamente.</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Si se ha producido alg&amp;uacute;n error anterior al construir la cadena din&amp;aacute;mica en sqlite3_str X, entonces el m&amp;eacute;todo &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; devolver&amp;aacute; un c&amp;oacute;digo de error apropiado. El m&amp;eacute;todo &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; despu&amp;eacute;s de cualquier error de memoria &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;insuficiente&lt;/a&gt; , o SQLITE_TOOBIG si el tama&amp;ntilde;o de la cadena din&amp;aacute;mica excede &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , o &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; si no ha habido errores.</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Si se ha producido alg&amp;uacute;n error anterior al construir la cadena din&amp;aacute;mica en sqlite3_str X, entonces el m&amp;eacute;todo &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; devolver&amp;aacute; un c&amp;oacute;digo de error apropiado. El m&amp;eacute;todo &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; devuelve &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; despu&amp;eacute;s de cualquier error de memoria &lt;a href=&quot;../rescode#toobig&quot;&gt;insuficiente&lt;/a&gt; , o SQLITE_TOOBIG si el tama&amp;ntilde;o de la cadena din&amp;aacute;mica excede &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , o &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; si no ha habido errores.</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">Si alguna vista hace referencia a la tabla X de una manera que se ve afectada por el cambio de esquema, elimine esas vistas usando &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; y vuelva a crearlas con los cambios que sean necesarios para acomodar el cambio de esquema usando &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">Si el argumento P3 es distinto de cero,entonces indica que el clasificador puede suponer que una clasificación estable considerando los primeros campos P3 de cada clave es suficiente para producir los resultados requeridos.</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">Si el argumento pnCol no es NULL,entonces *pnCol se establece en el número de columnas de la tabla.</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Si el argumento pzTab no es NULL, entonces * pzTab se establece para apuntar a una cadena codificada en utf-8 terminada en nulo que contiene el nombre de la tabla afectada por el cambio actual. El b&amp;uacute;fer permanece v&amp;aacute;lido hasta que se llame a sqlite3changeset_next () en el iterador o hasta que regrese la funci&amp;oacute;n de manejo de conflictos. Si pnCol no es NULL, entonces * pnCol se establece en el n&amp;uacute;mero de columnas de la tabla afectadas por el cambio. Si pbIndirect no es NULL, entonces * pbIndirect se establece en verdadero (1) si el cambio es un cambio indirecto, o falso (0) en caso contrario. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; para obtener una descripci&amp;oacute;n de los cambios directos e indirectos. Finalmente, si pOp no es NULL, entonces * pOp se establece en uno de &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; o &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, dependiendo del tipo de cambio al que apunta actualmente el iterador.</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Si el argumento pzTab no es NULL, entonces * pzTab se establece para apuntar a una cadena codificada en utf-8 terminada en nulo que contiene el nombre de la tabla afectada por el cambio actual. El b&amp;uacute;fer permanece v&amp;aacute;lido hasta que se llame a sqlite3changeset_next () en el iterador o hasta que regrese la funci&amp;oacute;n de manejo de conflictos. Si pnCol no es NULL, entonces * pnCol se establece en el n&amp;uacute;mero de columnas de la tabla afectadas por el cambio. Si pbIndirect no es NULL, entonces * pbIndirect se establece en verdadero (1) si el cambio es un cambio indirecto, o falso (0) en caso contrario. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; para obtener una descripci&amp;oacute;n de los cambios directos e indirectos. Finalmente, si pOp no es NULL, entonces * pOp se establece en uno de &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; o &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, dependiendo del tipo de cambio al que apunta actualmente el iterador.</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Si el argumento zTab no es NULL, entonces es el nombre de una tabla para adjuntar al objeto de sesi&amp;oacute;n pasado como primer argumento. Se registrar&amp;aacute;n todos los cambios posteriores realizados en la tabla mientras el objeto de sesi&amp;oacute;n est&amp;aacute; habilitado. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Si el argumento zTab no es NULL, entonces es el nombre de una tabla para adjuntar al objeto de sesi&amp;oacute;n pasado como primer argumento. Se registrar&amp;aacute;n todos los cambios posteriores realizados en la tabla mientras el objeto de sesi&amp;oacute;n est&amp;aacute; habilitado. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">Si tanto el indicador SQLITE_STOREP2 como el indicador SQLITE_KEEPNULL están activados,el contenido de r[P2]sólo se modifica si el nuevo valor es NULL o 0 (falso).En otras palabras,un valor anterior de r[P2]no será sobrescrito por 1 (true).</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">Si tanto el indicador SQLITE_STOREP2 como el indicador SQLITE_KEEPNULL están activados,el contenido de r[P2]sólo se modifica si el nuevo valor es NULL o 1 (true).En otras palabras,un valor anterior de r[P2]no será sobrescrito por 0 (falso).</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">Si ambos pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; y &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; est&amp;aacute;n DESACTIVADOS, se aplica el caso (2).</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Si se producen ciertos tipos de errores en una declaraci&amp;oacute;n dentro de una transacci&amp;oacute;n de m&amp;uacute;ltiples declaraciones (errores que incluyen &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; y &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), la transacci&amp;oacute;n podr&amp;iacute;a revertirse autom&amp;aacute;ticamente. La &amp;uacute;nica forma de saber si SQLite revirti&amp;oacute; autom&amp;aacute;ticamente la transacci&amp;oacute;n despu&amp;eacute;s de un error es usar esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Si se producen ciertos tipos de errores en una declaraci&amp;oacute;n dentro de una transacci&amp;oacute;n de m&amp;uacute;ltiples declaraciones (errores que incluyen &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; y &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), la transacci&amp;oacute;n podr&amp;iacute;a revertirse autom&amp;aacute;ticamente. La &amp;uacute;nica forma de saber si SQLite revirti&amp;oacute; autom&amp;aacute;ticamente la transacci&amp;oacute;n despu&amp;eacute;s de un error es usar esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">Si se producen ciertos tipos de errores en una transacción,ésta puede o no retroceder automáticamente.Entre los errores que pueden causar un retroceso automático se incluyen:</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">Si se producen cambios en la misma conexión de la base de datos después de que empiece a ejecutarse una consulta pero antes de que ésta se complete,entonces no se define si la consulta verá o no esos cambios.</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">Si se producen cambios en la misma conexión de la base de datos después de que empiece a ejecutarse una consulta pero antes de que ésta se complete,entonces la consulta podría devolver una fila modificada más de una vez,o podría devolver una fila que fue eliminada anteriormente.</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">Si se cambia al modo WAL o fuera de él,el procedimiento es más complicado.</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">Si se proporcionan explícitamente nombres de columna para la tabla FTS como parte de la declaración CREAR TABLA VIRTUAL,entonces se podrá especificar opcionalmente un nombre de tipo de datos para cada columna.Se trata de azúcar sintáctico puro,los nombres de tipo suministrados no son utilizados por FTS o el núcleo SQLite para ningún propósito.Lo mismo se aplica a cualquier restricción especificada junto con un nombre de columna FTS:se analizan pero no se utilizan ni se registran en el sistema de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">Si el conflicto es con una ACTUALIZACIÓN remota y la resolución es OMITAR,entonces los valores antiguos.*se vuelven a basar usando los nuevos valores.*en el cambio remoto.O,si la resolución es REEMPLAZAR,entonces el cambio es copiado en el conjunto de cambios rebasados con las actualizaciones de las columnas también actualizadas por el ACTUALIZADOR remoto eliminado.Si esto significa que no se actualizarán las columnas,se omite el cambio.</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">Si el cursor P1 es un índice,entonces el contenido es la clave de la fila.Si el cursor P2 es una tabla,entonces el contenido extraído son los datos.</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Si el cursor P1 se refiere a una tabla SQL (B-Tree que utiliza teclas de números enteros),utilice el valor del registro P3 como clave.Si el cursor P1 se refiere a un índice SQL,entonces P3 es el primero de una serie de registros P4 que se utilizan como clave de índice descomprimido.</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Si el cursor P1 se refiere a una tabla SQL (B-Tree que utiliza teclas de números enteros),utilice el valor del registro P3 como clave.Si el cursor P1 se refiere a un índice SQL,entonces P3 es el primero de una serie de registros P4 que se utilizan como clave de índice descomprimido.</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">Si los datos son de tipo &lt;b&gt;texto&lt;/b&gt; , la comparaci&amp;oacute;n se determina mediante las funciones est&amp;aacute;ndar de comparaci&amp;oacute;n de datos C &lt;b&gt;memcmp ()&lt;/b&gt; o &lt;b&gt;strcmp ()&lt;/b&gt; . La comparaci&amp;oacute;n mira los bytes de dos entradas uno por uno y devuelve la primera diferencia distinta de cero. Las cadenas terminan en '\ 000', por lo que las cadenas m&amp;aacute;s cortas se ordenan antes que las cadenas m&amp;aacute;s largas, como era de esperar.</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">Si la base de datos zDb es el nombre de una base de datos adjunta que no está en modo WAL,se devuelve SQLITE_OK y tanto *pnLog como *pnCkpt se establecen en -1.Si zDb no es NULL (o una cadena de longitud cero)y no es el nombre de ninguna base de datos adjunta,se devuelve SQLITE_ERROR al llamador.</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">Si se define,se omite el soporte para sub-selecciones y el operador IN().</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">Si lo desea,puede verificar la nueva base de datos ejecutando este comando:</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">Si P1 o P2 es 0 (falso)entonces el resultado es 0 aunque la otra entrada sea NULL.Un NULL y true o dos NULLs dan una salida NULL.</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">Si P1 o P2 es distinto de cero (verdadero)entonces el resultado es 1 (verdadero)aunque la otra entrada sea NULL.Un NULL y falso o dos NULLs dan una salida NULL.</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">Si P3 o el clasificador contiene un NULL en uno de sus campos significativos (sin contar los campos P4 al final,que son ignorados)entonces la comparación se asume igual.</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">Si X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; o X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; no son num&amp;eacute;ricos, entonces el l&amp;iacute;mite es la primera fila para la cual la expresi&amp;oacute;n &quot;X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &quot; es verdadera.</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">Si alguno de los operandos tiene una asignaci&amp;oacute;n de funci&amp;oacute;n de clasificaci&amp;oacute;n expl&amp;iacute;cita utilizando el &lt;a href=&quot;lang_expr#collateop&quot;&gt;operador COLLATE de&lt;/a&gt; sufijo , entonces la funci&amp;oacute;n de clasificaci&amp;oacute;n expl&amp;iacute;cita se utiliza para la comparaci&amp;oacute;n, con precedencia a la funci&amp;oacute;n de clasificaci&amp;oacute;n del operando izquierdo.</target>
        </trans-unit>
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">Si cualquiera de los operandos es una columna,entonces se utiliza la función de cotejo de esa columna con prioridad al operando izquierdo.A los efectos de la frase anterior,un nombre de columna precedido por uno o más operadores unarios &quot;+&quot; y/o operadores CAST se sigue considerando un nombre de columna.</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">Si el valor actual o la marca de agua alta es demasiado grande para ser representado por un entero de 32 bits,entonces los valores devueltos por sqlite3_status()están indefinidos.</target>
        </trans-unit>
        <trans-unit id="f734ad1cf91506e2435f2ec6895dbb828ca868ad" translate="yes" xml:space="preserve">
          <source>If everything is OK, the query above should return a single row where the second column is 1. Any other result indicates either that there is a checksum error, or checksum validation is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">Si el bloqueo de archivos está activado (está activado por defecto),entonces las conexiones de múltiples procesos también pueden leer y escribir el archivo de la base de datos.Sin embargo,la concurrencia se reduce de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">Si las restricciones de clave for&amp;aacute;nea est&amp;aacute;n habilitadas cuando est&amp;aacute; preparada, el comando &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; realiza un &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; impl&amp;iacute;cito para eliminar todas las filas de la tabla antes de descartarla. El DELETE impl&amp;iacute;cito no provoca que se active ning&amp;uacute;n disparador SQL, pero puede invocar acciones de clave externa o violaciones de restricciones. Si se viola una restricci&amp;oacute;n de clave externa inmediata, la instrucci&amp;oacute;n DROP TABLE falla y la tabla no se elimina. Si se viola una restricci&amp;oacute;n de clave externa diferida, se informa de un error cuando el usuario intenta realizar la transacci&amp;oacute;n si las violaciones de la restricci&amp;oacute;n de clave externa todav&amp;iacute;a existen en ese momento. Se ignora cualquier error de &quot;falta de coincidencia de clave externa&quot; que se encuentre como parte de un DELETE impl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">Si las restricciones de clave for&amp;aacute;nea est&amp;aacute;n habilitadas, deshabil&amp;iacute;telas usando &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA Foreign_keys = OFF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">Si las restricciones de clave externa estaban habilitadas originalmente, ejecute &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA Foreign_key_check&lt;/a&gt; para verificar que el cambio de esquema no rompi&amp;oacute; ninguna restricci&amp;oacute;n de clave externa.</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">Si se habilita el manejo de claves externas,y la aplicación de un conjunto de cambios deja la base de datos en un estado que contiene violaciones de claves externas,el manejador de conflictos se invoca con CHANGESET_FOREIGN_KEY como segundo argumento exactamente una vez antes de que se cometa el conjunto de cambios.Si el manejador de conflictos devuelve CHANGESET_OMIT,se cometen los cambios,incluyendo los que causaron la violación de la restricción de la clave externa.O,si devuelve CHANGESET_ABORT,el conjunto de cambios se devuelve.</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">Si se habilitaron originalmente las restricciones de las claves extranjeras,vuelva a habilitarlas ahora.</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">Si a&amp;uacute;n no est&amp;aacute; adjunto al objeto de sesi&amp;oacute;n pasado como primer argumento, esta funci&amp;oacute;n adjunta la tabla zTbl de la misma manera que la funci&amp;oacute;n &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; . Si zTbl no existe, o si no tiene una clave principal, esta funci&amp;oacute;n no es operativa (pero no devuelve un error).</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">Si a&amp;uacute;n no est&amp;aacute; adjunto al objeto de sesi&amp;oacute;n pasado como primer argumento, esta funci&amp;oacute;n adjunta la tabla zTbl de la misma manera que la funci&amp;oacute;n &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; . Si zTbl no existe, o si no tiene una clave principal, esta funci&amp;oacute;n no es operativa (pero no devuelve un error).</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">Si muchos hilos y/o procesos necesitan escribir la base de datos en el mismo instante (y no pueden hacer cola y tomar turnos)entonces es mejor seleccionar un motor de base de datos que soporte esa capacidad,lo que siempre significa un motor de base de datos cliente/servidor.</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">Si mmap_size se establece en N,entonces todas las implementaciones actuales mapean los primeros N bytes del archivo de base de datos y utilizan las llamadas xRead()heredadas para cualquier contenido más allá de N bytes.Si el archivo de base de datos es más pequeño que N bytes,entonces se mapea todo el archivo.En el futuro,las nuevas interfaces del sistema operativo podrían,en teoría,mapear regiones del archivo distintas de los primeros N bytes,pero actualmente no existe ninguna implementación de este tipo.</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">Si se puede encontrar más de un fragmento de este tipo,entonces los fragmentos que contienen un mayor número de coincidencias de frase &quot;extra&quot; son los favoritos.El inicio del fragmento de texto seleccionado puede moverse unas cuantas fichas hacia adelante o hacia atrás para intentar concentrar las coincidencias de frase hacia el centro del fragmento.</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">Si el procesamiento de subprocesos m&amp;uacute;ltiples est&amp;aacute; habilitado a trav&amp;eacute;s de la configuraci&amp;oacute;n de &lt;a href=&quot;pragma#pragma_threads&quot;&gt;subprocesos PRAGMA&lt;/a&gt; , las operaciones de ordenaci&amp;oacute;n intentar&amp;aacute;n iniciar subprocesos auxiliares cuando la cantidad de contenido a ordenar exceda el m&amp;iacute;nimo de &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; y PMA Size determinados por la opci&amp;oacute;n de tiempo de inicio &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; . Esta opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n establece el valor predeterminado para la opci&amp;oacute;n de tiempo de inicio &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; . El valor predeterminado es 250.</target>
        </trans-unit>
        <trans-unit id="aefd863d94581cbe189ba146626a8379609c65b7" translate="yes" xml:space="preserve">
          <source>If multiple calls to sqlite3_create_function() specify the same function name, and the same number of arguments, and the same preferred text encoding, then the callbacks and other parameters of the second call overwrite the first, and the destructor callback from the first call (if it exists) is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">Si se ejecutan varios comandos contra la misma conexión de base de datos SQLite al mismo tiempo,la autocomisión se aplaza hasta que se complete el último comando.Por ejemplo,si se está ejecutando una instrucción SELECT,la ejecución del comando se detendrá a medida que se devuelva cada fila del resultado.Durante esta pausa se pueden ejecutar otros comandos INSERTAR,ACTUALIZAR o BORRAR contra otras tablas de la base de datos.Pero ninguno de estos cambios se confirmará hasta que la instrucción SELECT original termine.</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">Si no se puede utilizar ninguna de estas dos estrategias de consulta,todas las consultas sobre las tablas FTS se implementan mediante un escaneo lineal de toda la tabla.Si la tabla contiene grandes cantidades de datos,puede ser un enfoque poco práctico (el primer ejemplo de esta página muestra que un escaneo lineal de 1,5 GB de datos lleva unos 30 segundos utilizando un PC moderno).</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">Si no...</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n ROWID en la inserci&amp;oacute;n, o si el ROWID especificado tiene un valor de NULL, se crea autom&amp;aacute;ticamente un ROWID apropiado. El algoritmo habitual es dar a la fila reci&amp;eacute;n creada un ROWID que es uno m&amp;aacute;s grande que el ROWID m&amp;aacute;s grande en la tabla antes de la inserci&amp;oacute;n. Si la tabla est&amp;aacute; inicialmente vac&amp;iacute;a, entonces se usa un ROWID de 1. Si el ROWID m&amp;aacute;s grande es igual al entero m&amp;aacute;s grande posible (9223372036854775807), el motor de la base de datos comienza a seleccionar los ROWID candidatos positivos al azar hasta que encuentra uno que no se haya utilizado anteriormente. Si no se puede encontrar ning&amp;uacute;n ROWID sin usar despu&amp;eacute;s de un n&amp;uacute;mero razonable de intentos, la operaci&amp;oacute;n de inserci&amp;oacute;n falla con un error &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; . Si no se insertan expl&amp;iacute;citamente valores ROWID negativos, los valores ROWID generados autom&amp;aacute;ticamente siempre ser&amp;aacute;n mayores que cero.</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">Si no se produce ningún error,se devuelve SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">Si no se produce ningún error,se devuelve SQLITE_OK.Si se produce un error,se devuelve un código de error SQLite.En este caso,los valores de las variables de salida pueden no ser fiables.</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">Si no hay un diario maestro involucrado,entonces un diario está caliente si existe y tiene un encabezado distinto de cero y su correspondiente archivo de base de datos no tiene un candado RESERVADO.Si se nombra un diario maestro en el diario del archivo,entonces el diario del archivo está activo si existe su diario maestro y no hay un bloqueo RESERVADO en el archivo de base de datos correspondiente.Es importante entender cuándo un diario está caliente para que las reglas anteriores se repitan en viñetas:</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">Si no se encuentra ninguna fila con valores de clave primaria coincidentes en la base de datos, se invoca la funci&amp;oacute;n de manejo de conflictos con &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; pasado como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">Si no se encuentra ninguna fila con valores de clave primaria coincidentes en la base de datos, se invoca la funci&amp;oacute;n de manejo de conflictos con &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; pasado como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">Si ninguna de las cadenas anteriores aparece en ningún lugar de la declaración de tipo,entonces el tipo de datos es numérico.Obsérvese en particular que el tipo de datos de las columnas con una declaración de tipo vacía es numérico.</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">Si el offset iOffset es menor que N bytes desde el final del BLOB, se devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; y no se lee ning&amp;uacute;n dato. Si N o iOffset es menor que cero, se devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; y no se lee ning&amp;uacute;n dato. El tama&amp;ntilde;o del blob (y por lo tanto el valor m&amp;aacute;ximo de N + iOffset) se puede determinar usando la interfaz &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">Si el offset iOffset es menor que N bytes desde el final del BLOB, se devuelve &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; y no se lee ning&amp;uacute;n dato. Si N o iOffset es menor que cero, se devuelve &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; y no se lee ning&amp;uacute;n dato. El tama&amp;ntilde;o del blob (y por lo tanto el valor m&amp;aacute;ximo de N + iOffset) se puede determinar usando la interfaz &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">Si un operando tiene afinidad INTEGER,REAL o NUMÉRICA y el otro operando tiene afinidad de TEXTO o BLOB o ninguna afinidad,entonces se aplica la afinidad NUMÉRICA al otro operando.</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">Si un operando tiene afinidad de TEXTO y el otro no tiene afinidad,entonces la afinidad de TEXTO se aplica al otro operando.</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">Si uno o más de los valores de la columna en la fila insertada por el nuevo cambio difieren de los de la fila eliminada por el cambio existente,el BORRADO existente es sustituido por un ACTUALIZADO dentro del grupo de cambio.De lo contrario,si la fila insertada es exactamente igual a la fila eliminada,el BORRADO existente simplemente se descarta.</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">Si la propiedad del puntero se pasa a SQLite al proporcionar un par&amp;aacute;metro D no NULL a &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; o &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer (),&lt;/a&gt; entonces la propiedad permanece con SQLite hasta que se destruye el objeto. No hay forma de transferir la propiedad de SQLite y volver a la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">Si los datos de la página 1 se leen según lo requerido por H35230,entonces el valor de la</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">Si el parámetro iCol es mayor o igual al número de columnas de la tabla,se devuelve SQLITE_RANGE.O,si se produce un error (por ejemplo,una condición OOM o un error IO),se devuelve un código de error SQLite apropiado.</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">Si el parámetro iCol es menor que cero,establezca la variable de salida *pnToken al número total de fichas en la tabla FTS5.O,si iCol no es negativo pero es menor que el número de columnas de la tabla,devuelva el número total de fichas en la columna iCol,considerando todas las filas de la tabla FTS5.</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">Si el parámetro iCol es menor que cero,establezca la variable de salida *pnToken al número total de fichas en la fila actual.O,si iCol no es negativo pero es menor que el número de columnas de la tabla,establezca *pnToken al número de fichas de la columna iCol de la fila actual.</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">Si el par&amp;aacute;metro zDb es NULL o apunta a una cadena de longitud cero, entonces se intenta la operaci&amp;oacute;n especificada en todas las bases de datos WAL &lt;a href=&quot;../lang_attach&quot;&gt;adjuntas&lt;/a&gt; a la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de base&lt;/a&gt; de datos db. En este caso, los valores escritos en los par&amp;aacute;metros de salida * pnLog y * pnCkpt no est&amp;aacute;n definidos. Si se encuentra un error SQLITE_BUSY al procesar una o m&amp;aacute;s de las bases de datos WAL adjuntas, la operaci&amp;oacute;n a&amp;uacute;n se intenta en las bases de datos adjuntas restantes y se devuelve SQLITE_BUSY al final. Si ocurre cualquier otro error mientras se procesa una base de datos adjunta, el procesamiento se abandona y el c&amp;oacute;digo de error se devuelve a la persona que llama de inmediato. Si no se encuentra ning&amp;uacute;n error (SQLITE_BUSY o de otro tipo) mientras se procesan las bases de datos adjuntas, se devuelve SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">Si el par&amp;aacute;metro zDb es NULL o apunta a una cadena de longitud cero, entonces se intenta la operaci&amp;oacute;n especificada en todas las bases de datos WAL &lt;a href=&quot;lang_attach&quot;&gt;adjuntas&lt;/a&gt; a la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de base&lt;/a&gt; de datos db. En este caso, los valores escritos en los par&amp;aacute;metros de salida * pnLog y * pnCkpt no est&amp;aacute;n definidos. Si se encuentra un error SQLITE_BUSY al procesar una o m&amp;aacute;s de las bases de datos WAL adjuntas, la operaci&amp;oacute;n a&amp;uacute;n se intenta en las bases de datos adjuntas restantes y se devuelve SQLITE_BUSY al final. Si ocurre cualquier otro error mientras se procesa una base de datos adjunta, el procesamiento se abandona y el c&amp;oacute;digo de error se devuelve a la persona que llama de inmediato. Si no se encuentra ning&amp;uacute;n error (SQLITE_BUSY o de otro tipo) mientras se procesan las bases de datos adjuntas, se devuelve SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">Si pnLog no es NULL, entonces * pnLog se establece en el n&amp;uacute;mero total de fotogramas en el archivo de registro o en -1 si el punto de control no se pudo ejecutar debido a un error o porque la base de datos no est&amp;aacute; en &lt;a href=&quot;../wal&quot;&gt;modo WAL&lt;/a&gt; . Si pnCkpt no es NULL, entonces * pnCkpt se establece en el n&amp;uacute;mero total de cuadros con puntos de control en el archivo de registro (incluidos los que ya estaban marcados antes de que se llamara a la funci&amp;oacute;n) o en -1 si el punto de control no se pudo ejecutar debido a un error o porque la base de datos no est&amp;aacute; en modo WAL. Tenga en cuenta que al completar con &amp;eacute;xito un SQLITE_CHECKPOINT_TRUNCATE, el archivo de registro se habr&amp;aacute; truncado a cero bytes y, por lo tanto, * pnLog y * pnCkpt se establecer&amp;aacute;n en cero.</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">Si pnLog no es NULL, entonces * pnLog se establece en el n&amp;uacute;mero total de fotogramas en el archivo de registro o en -1 si el punto de control no se pudo ejecutar debido a un error o porque la base de datos no est&amp;aacute; en &lt;a href=&quot;wal&quot;&gt;modo WAL&lt;/a&gt; . Si pnCkpt no es NULL, entonces * pnCkpt se establece en el n&amp;uacute;mero total de cuadros con puntos de control en el archivo de registro (incluidos los que ya estaban marcados antes de que se llamara a la funci&amp;oacute;n) o en -1 si el punto de control no se pudo ejecutar debido a un error o porque la base de datos no est&amp;aacute; en modo WAL. Tenga en cuenta que al completar con &amp;eacute;xito un SQLITE_CHECKPOINT_TRUNCATE, el archivo de registro se habr&amp;aacute; truncado a cero bytes y, por lo tanto, * pnLog y * pnCkpt se establecer&amp;aacute;n en cero.</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">Si está presente,emita un informe más verborreico para cada consulta analizada.</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">Si pzTail no es NULL entonces *pzTail se hace para apuntar al primer byte pasado el final de la primera sentencia SQL en zSql.Estas rutinas sólo compilan la primera sentencia en zSql,así que *pzTail se deja apuntando a lo que queda sin compilar.</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">Si r[P3]es cero o negativo,significa que no hay compensación y que r[P2]es el valor del LÍMITE,r[P1].</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">Si el registro P1 contiene un número entero,conviértalo en un valor real.</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">Si es necesario truncar una página de la base de datos desde el final del archivo de la base de datos,la</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">Si se ejecuta en &lt;a href=&quot;../sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; , la aplicaci&amp;oacute;n debe garantizar que no se acceda a la cach&amp;eacute; compartida utilizada por la base de datos de destino mientras se ejecuta la copia de seguridad. En la pr&amp;aacute;ctica, esto significa que la aplicaci&amp;oacute;n debe garantizar que ninguna conexi&amp;oacute;n dentro del proceso acceda al archivo de disco del que se realiza la copia de seguridad, no solo la conexi&amp;oacute;n espec&amp;iacute;fica que se pas&amp;oacute; a sqlite3_backup_init ().</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">Si se ejecuta en &lt;a href=&quot;sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; , la aplicaci&amp;oacute;n debe garantizar que no se acceda a la cach&amp;eacute; compartida utilizada por la base de datos de destino mientras se ejecuta la copia de seguridad. En la pr&amp;aacute;ctica, esto significa que la aplicaci&amp;oacute;n debe garantizar que ninguna conexi&amp;oacute;n dentro del proceso acceda al archivo de disco del que se realiza la copia de seguridad, no solo la conexi&amp;oacute;n espec&amp;iacute;fica que se pas&amp;oacute; a sqlite3_backup_init ().</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">Si se establece en 1, el modo de &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;bloqueo&lt;/a&gt; predeterminado se establece en EXCLUSIVO. Si se omite o se establece en 0, el modo de &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;bloqueo&lt;/a&gt; predeterminado es NORMAL.</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">Si no se ha seleccionado el modo de un solo hilo en el momento de la compilación o del inicio,entonces las conexiones individuales de la base de datos pueden crearse como multihilo o serializadas.No es posible degradar una conexión de base de datos individual al modo de un solo hilo.Tampoco es posible escalar una conexión de base de datos individual si el modo de tiempo de compilación o de inicio es de un solo hilo.</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">Si se selecciona el modo de un solo hilo en el momento de la compilación,se omite la lógica de silenciamiento crítico en la compilación y es imposible habilitar los modos multihilo o serializado en el momento de inicio o en el momento de ejecución.</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">Si alguna futura versión de SQLite añade nuevas capacidades de TABLA DE ALTERNATIVAS,es muy probable que esas capacidades utilicen uno de los dos procedimientos descritos anteriormente.</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">Si se produce algún otro error (por ejemplo,una condición OOM),se devuelve un código de error SQLite y *ppValue se establece en NULL.</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">Si se especifica,interprete todas las rutas relativas como relativas al DIR,en lugar del directorio de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">Si se especifica,use el archivo FILE como el archivo.De lo contrario,suponga que la base de datos &quot;principal&quot; actual es el archivo con el que se va a operar.</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">Si sqlite3_backup_step () no puede obtener un bloqueo del sistema de archivos requerido, entonces se invoca la &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;funci&amp;oacute;n de controlador de ocupado&lt;/a&gt; (si se especifica una). Si el controlador de ocupado devuelve un valor distinto de cero antes de que el bloqueo est&amp;eacute; disponible, entonces se devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; al que llama. En este caso, la llamada a sqlite3_backup_step () se puede reintentar m&amp;aacute;s tarde. Si la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; origen se usa para escribir en la base de datos de origen cuando se llama a sqlite3_backup_step (), entonces &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; se devuelve inmediatamente. Nuevamente, en este caso, la llamada a sqlite3_backup_step () se puede reintentar m&amp;aacute;s adelante. Si &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; o &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;se devuelve, entonces no tiene sentido volver a intentar la llamada a sqlite3_backup_step (). Estos errores se consideran fatales. La aplicaci&amp;oacute;n debe aceptar que la operaci&amp;oacute;n de respaldo ha fallado y pasar el identificador de la operaci&amp;oacute;n de respaldo al sqlite3_backup_finish () para liberar los recursos asociados.</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">Si sqlite3_backup_step () no puede obtener un bloqueo del sistema de archivos requerido, entonces se invoca la &lt;a href=&quot;busy_handler&quot;&gt;funci&amp;oacute;n de controlador de ocupado&lt;/a&gt; (si se especifica una). Si el controlador de ocupado devuelve un valor distinto de cero antes de que el bloqueo est&amp;eacute; disponible, entonces se devuelve &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; al que llama. En este caso, la llamada a sqlite3_backup_step () se puede reintentar m&amp;aacute;s tarde. Si la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n de la base de datos de&lt;/a&gt; origen se usa para escribir en la base de datos de origen cuando se llama a sqlite3_backup_step (), entonces &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; se devuelve inmediatamente. Nuevamente, en este caso, la llamada a sqlite3_backup_step () se puede reintentar m&amp;aacute;s adelante. Si &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; o &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;se devuelve, entonces no tiene sentido volver a intentar la llamada a sqlite3_backup_step (). Estos errores se consideran fatales. La aplicaci&amp;oacute;n debe aceptar que la operaci&amp;oacute;n de respaldo ha fallado y pasar el identificador de la operaci&amp;oacute;n de respaldo al sqlite3_backup_finish () para liberar los recursos asociados.</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">Si sqlite3_deserialize (D, S, P, N, M, F) falla por cualquier motivo y si el bit SQLITE_DESERIALIZE_FREEONCLOSE se establece en el argumento F, entonces &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; se invoca en el argumento P antes de regresar.</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">Si sqlite3_deserialize (D, S, P, N, M, F) falla por cualquier motivo y si el bit SQLITE_DESERIALIZE_FREEONCLOSE se establece en el argumento F, entonces &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; se invoca en el argumento P antes de regresar.</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">Si sqlite3_malloc()falla durante el procesamiento de cualquiera de las dos rutinas (por ejemplo durante una conversión de UTF-8 a UTF-16)entonces se devuelve un puntero NULL.</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">Si se llama a sqlite3_unlock_notify()en una aplicación multi-hilo,existe la posibilidad de que la conexión de bloqueo ya haya concluido su transacción en el momento en que se invoque a sqlite3_unlock_notify().Si esto ocurre,entonces la llamada especificada se invoca inmediatamente,desde dentro de la llamada a sqlite3_unlock_notify().</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">Si la base de datos de estados S no existe cuando se invoca sqlite3rbu_vacuum(),se crea automáticamente y se rellena con la única tabla utilizada para almacenar el estado de un vacío RBU-&quot;rbu_state&quot;.Si se suspende un vacío RBU en curso,esta tabla se rellena con datos de estado.La próxima vez que sqlite3rbu_vacuum()es llamada con el mismo parámetro S,detecta estos datos e intenta reanudar la operación de vacío suspendida.Cuando se completa una operación de vacío RBU o se encuentra con un error,RBU borra automáticamente el contenido de la tabla rbu_state.En este caso,la siguiente llamada a sqlite3rbu_vacuum()inicia una operación de vacío completamente nueva desde cero.</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">Si el paso 1 tuvo éxito,se intenta leer el</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">Si tiene éxito,un puntero a un buffer que contiene el conjunto de cambios invertido se almacena en *ppOut,el tamaño del mismo buffer se almacena en *pnOut,y se devuelve SQLITE_OK.Si se produce un error,tanto *pnOut como *ppOut se ponen a cero y se devuelve un código de error SQLite.</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">Si tiene éxito,esta función devuelve SQLITE_OK y llena (*pp)con un puntero a un nuevo objeto sqlite3_changegroup antes de volver.El llamador debería eventualmente liberar el objeto devuelto usando una llamada a sqlite3changegroup_delete().Si se produce un error,se devuelve un código de error de SQLite (es decir,SQLITE_NOMEM)y se establece *pp como NULL.</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">Si tiene éxito,esta función establece *ppValue para que apunte a un objeto protegido sqlite3_value que contenga el valor iVal'th de la &quot;fila de conflicto&quot; asociada a la llamada de retorno del manejador de conflictos actual y devuelve SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">Si tiene éxito,esta función establece *ppValue para que apunte a un objeto protegido sqlite3_value que contenga el valor iVal'th del vector de los nuevos valores de fila almacenados como parte del cambio UPDATE o INSERT y devuelve SQLITE_OK.Si el cambio es un UPDATE y no incluye un nuevo valor para la columna solicitada,*ppValue se establece en NULL y se devuelve SQLITE_OK.El nombre de la función se debe a que es similar a las columnas &quot;new.*&quot; disponibles para actualizar o eliminar disparadores.</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">Si tiene éxito,esta función establece *ppValue para que apunte a un objeto protegido sqlite3_value que contenga el valor iVal'th del vector de los valores de fila originales almacenados como parte del cambio UPDATE o DELETE y devuelve SQLITE_OK.El nombre de la función proviene del hecho de que es similar a las columnas &quot;old.*&quot; disponibles para actualizar o eliminar disparadores.</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">Si tiene &amp;eacute;xito, xCreateFunction () devuelve SQLITE_OK. De lo contrario, devuelve un c&amp;oacute;digo de error SQLite. En este caso, &lt;b&gt;no se&lt;/b&gt; invoca la funci&amp;oacute;n xDestroy .</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">Si tiene &amp;eacute;xito, xCreateTokenizer () devuelve SQLITE_OK. De lo contrario, devuelve un c&amp;oacute;digo de error SQLite. En este caso, &lt;b&gt;no se&lt;/b&gt; invoca la funci&amp;oacute;n xDestroy .</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">Si se encuentra un fragmento de texto de este tipo,se devuelve con las siguientes modificaciones:</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Si el</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">Si los comandos &quot;.output&quot; o &quot;.once&quot; tienen un argumento &quot;-x&quot;,que hace que acumulen la salida como valores separados por comas (CSV)en un archivo temporal,entonces invoca la utilidad del sistema por defecto para ver los archivos CSV (normalmente un programa de hoja de cálculo)en el resultado.Esta es una forma rápida de enviar el resultado de una consulta a una hoja de cálculo para su fácil visualización:</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">Si los comandos &quot;.output&quot; o &quot;.once&quot; tienen el argumento &quot;-e&quot;,la salida se recoge en un archivo temporal y se invoca el editor de texto del sistema en ese archivo de texto.Así,el comando &quot;.once -e&quot; logra el mismo resultado que &quot;.once '|open -f'&quot; pero con la ventaja de ser portátil en todos los sistemas.</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">Si el comando &quot;.recover&quot; recupera una o más filas que no puede atribuir a ninguna tabla de la base de datos,el script de salida crea una tabla &quot;lost_and_found&quot; para almacenar las filas huérfanas.El esquema de la tabla &quot;lost_and_found&quot; es el siguiente:</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">Si la declaración &quot;CREATE VIRTUAL TABLE&quot; especifica el módulo FTS4 (no FTS3),entonces también pueden aparecer directivas especiales-opciones FTS4-similares a la opción &quot;tokenize=*&quot; en lugar de los nombres de las columnas.Una opción FTS4 consiste en el nombre de la opción,seguido de un carácter &quot;=&quot;,seguido del valor de la opción.El valor de la opción puede ir entre comillas simples o dobles,con caracteres de comillas incrustados que se escapan de la misma manera que en los literales de SQL.No puede haber espacios en blanco a ambos lados del carácter &quot;=&quot;.Por ejemplo,para crear una tabla FTS4 con el valor de la opción &quot;matchinfo&quot; establecido en &quot;fts3&quot;:</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">Si la palabra clave &quot;TEMP&quot; o &quot;TEMPORARY&quot; se encuentra entre &quot;CREATE&quot; y &quot;VIEW&quot;, la vista que se crea solo es visible para la &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexi&amp;oacute;n de base de datos&lt;/a&gt; que la cre&amp;oacute; y se elimina autom&amp;aacute;ticamente cuando se cierra la conexi&amp;oacute;n de base de datos.</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">Si la columna &quot;col&quot; contiene el valor &quot;*&quot;,entonces esta columna contiene el número de filas de la tabla FTS que contienen al menos una instancia del término (en cualquier columna).Si col contiene un valor entero,entonces esta columna contiene el número de filas de la tabla ETC que contienen al menos una instancia del término en la columna identificada por el valor col.Como es habitual,las columnas de la tabla FTS están numeradas de izquierda a derecha,empezando por cero.</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">Si la columna &quot;col&quot; contiene el valor &quot;*&quot;,entonces esta columna contiene el número total de instancias del término en todas las filas de la tabla FTS (en cualquier columna).De lo contrario,si col contiene un valor entero,entonces esta columna contiene el número total de instancias del término que aparecen en la columna de la tabla ETC identificada por el valor col.</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">Si se omite el &quot;esquema&quot;, el valor predeterminado es la base de datos primaria (generalmente llamada 'principal', a menos que se &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;cambie el&lt;/a&gt; nombre mediante SQLITE_DBCONFIG_MAINDBNAME ). Por lo tanto, las siguientes dos consultas son normalmente equivalentes:</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">Si el argumento &quot;no ordenado&quot; está presente,entonces el planificador de consultas asume que el índice no está ordenado y no usará el índice para una consulta de rango o para la clasificación.</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">Si la variable $bigstring tiene una representación tanto de cadena como de &quot;bytearray&quot;,entonces TCL inserta el valor como una cadena.Si sólo tiene una representación &quot;bytearray&quot;,entonces el valor se inserta como BLOB.Para forzar que un valor se inserte como BLOB aunque también tenga una representación de texto,usa un carácter &quot;@&quot; en lugar del &quot;$&quot;.Así:</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">Si se utiliza la opción de formato %Q en lugar de %q,así:</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">Si la opción --vtab se pasa a sqldiff.exe,entonces ignora todas las tablas de sombra subyacentes pertenecientes a una tabla virtual FTS3,FTS5 o rtree y en su lugar incluye las diferencias de la tabla virtual directamente.</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">Si el segundo par&amp;aacute;metro realmente contiene dos o m&amp;aacute;s declaraciones de SQL, solo se compila la primera declaraci&amp;oacute;n. (Esto es diferente del comportamiento de &lt;b&gt;sqlite_exec&lt;/b&gt; que ejecuta todas las sentencias SQL en su cadena de entrada). El tercer par&amp;aacute;metro de &lt;b&gt;sqlite_compile&lt;/b&gt; se hace para apuntar al primer car&amp;aacute;cter m&amp;aacute;s all&amp;aacute; del final de la primera sentencia de SQL en la entrada. Si el segundo par&amp;aacute;metro contiene s&amp;oacute;lo una &amp;uacute;nica instrucci&amp;oacute;n SQL, entonces el tercer par&amp;aacute;metro se har&amp;aacute; para apuntar al terminador '\ 000' al final del segundo par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">Si el 2º parámetro de sqlite3_exec()es un puntero NULL,un puntero a una cadena vacía o un puntero que sólo contiene espacios en blanco y/o comentarios SQL,entonces no se evalúa ninguna sentencia SQL y la base de datos no se modifica.</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Si el tercer par&amp;aacute;metro de sqlite3_open_v2 () no es una de las combinaciones que se muestran arriba, opcionalmente combinado con otros &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;bits SQLITE_OPEN_ *,&lt;/a&gt; entonces el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Si el tercer par&amp;aacute;metro de sqlite3_open_v2 () no es una de las combinaciones que se muestran arriba, opcionalmente combinado con otros &lt;a href=&quot;c_open_autoproxy&quot;&gt;bits SQLITE_OPEN_ *,&lt;/a&gt; entonces el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">Si se establece el indicador &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; , la conexi&amp;oacute;n de la base de datos se abre en el &lt;a href=&quot;threadsafe&quot;&gt;modo de subprocesos m&amp;uacute;ltiples&lt;/a&gt; siempre que el modo de un solo subproceso no se haya establecido en el tiempo de compilaci&amp;oacute;n o el tiempo de inicio. Si se establece el indicador &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , la conexi&amp;oacute;n de la base de datos se abre en el &lt;a href=&quot;threadsafe&quot;&gt;modo de subproceso&lt;/a&gt; serializado , a menos que se haya seleccionado previamente un solo subproceso en el tiempo de compilaci&amp;oacute;n o el tiempo de inicio. El indicador &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; hace que la conexi&amp;oacute;n de la base de datos sea elegible para usar el &lt;a href=&quot;sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; , independientemente de si la cach&amp;eacute; compartida est&amp;aacute; habilitada o no usando &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . El &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;El indicador hace que la conexi&amp;oacute;n de la base de datos no participe en el &lt;a href=&quot;sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; incluso si est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;#sqlite3_blob&quot;&gt;identificador BLOB&lt;/a&gt; pasado como primer argumento no se abri&amp;oacute; para escritura (el par&amp;aacute;metro flags de &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; era cero), esta funci&amp;oacute;n devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; establece el elemento sqlite3_file.pMethods en un puntero no NULL, entonces el m&amp;eacute;todo sqlite3_io_methods.xClose puede invocarse incluso si &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; inform&amp;oacute; que fall&amp;oacute;. La &amp;uacute;nica forma de evitar una llamada a xClose despu&amp;eacute;s de un error &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; es que &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; establezca el elemento sqlite3_file.pMethods en NULL.</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n SQLITE_FCNTL_BEGIN_ATOMIC_WRITE devuelve SQLITE_OK, entonces el descriptor de archivo se coloca en &quot;modo de escritura por lotes&quot;, lo que significa que todas las operaciones de escritura posteriores se aplazar&amp;aacute;n y se realizar&amp;aacute;n de forma at&amp;oacute;mica en el siguiente &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . Los sistemas que no admiten escrituras at&amp;oacute;micas por lotes devolver&amp;aacute;n SQLITE_NOTFOUND. Despu&amp;eacute;s de un SQLITE_FCNTL_BEGIN_ATOMIC_WRITE exitoso y antes del cierre de &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; o &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite no realizar&amp;aacute; llamadas de interfaz VFS en el mismo archivo &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; descriptor de archivos, excepto para las llamadas al m&amp;eacute;todo xLIT_FILE_WRITE y al m&amp;eacute;todo &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;xLIZ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; llama a sqlite3_vtab_nochange () y encuentra que la columna no ha sido cambiada por la instrucci&amp;oacute;n UPDATE, entonces el m&amp;eacute;todo xColumn puede regresar opcionalmente sin establecer un resultado, sin llamar a ninguna de las &lt;a href=&quot;result_blob&quot;&gt;interfaces sqlite3_result_xxxxx ()&lt;/a&gt; . En ese caso, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; devolver&amp;aacute; verdadero para la misma columna en el m&amp;eacute;todo &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;blob&quot;&gt;identificador BLOB&lt;/a&gt; pasado como primer argumento no se abri&amp;oacute; para escritura (el par&amp;aacute;metro flags de &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; era cero), esta funci&amp;oacute;n devuelve &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">Si se usa la interfaz &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; para anular la funci&amp;oacute;n glob (X, Y) con una implementaci&amp;oacute;n alternativa, entonces el operador &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; invocar&amp;aacute; la implementaci&amp;oacute;n alternativa.</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n SQLITE_FCNTL_BEGIN_ATOMIC_WRITE devuelve SQLITE_OK, entonces el descriptor de archivo se coloca en &quot;modo de escritura por lotes&quot;, lo que significa que todas las operaciones de escritura posteriores se aplazar&amp;aacute;n y se realizar&amp;aacute;n de forma at&amp;oacute;mica en el siguiente &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . Los sistemas que no admiten escrituras at&amp;oacute;micas por lotes devolver&amp;aacute;n SQLITE_NOTFOUND. Despu&amp;eacute;s de un SQLITE_FCNTL_BEGIN_ATOMIC_WRITE exitoso y antes del cierre de &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; o &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite no realizar&amp;aacute; llamadas de interfaz VFS en el mismo archivo &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; descriptor de archivos, excepto para las llamadas al m&amp;eacute;todo xLIT_FILE_WRITE y al m&amp;eacute;todo &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;xLIZ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">Si se establece el indicador &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; , la conexi&amp;oacute;n de la base de datos se abre en el &lt;a href=&quot;../threadsafe&quot;&gt;modo de subprocesos m&amp;uacute;ltiples&lt;/a&gt; siempre que el modo de un solo subproceso no se haya establecido en el tiempo de compilaci&amp;oacute;n o el tiempo de inicio. Si se establece el indicador &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , la conexi&amp;oacute;n de la base de datos se abre en el &lt;a href=&quot;../threadsafe&quot;&gt;modo de subproceso&lt;/a&gt; serializado , a menos que se haya seleccionado previamente un solo subproceso en el tiempo de compilaci&amp;oacute;n o el tiempo de inicio. El indicador &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; hace que la conexi&amp;oacute;n de la base de datos sea elegible para usar el &lt;a href=&quot;../sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; , independientemente de si la cach&amp;eacute; compartida est&amp;aacute; habilitada o no usando &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . El &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;El indicador hace que la conexi&amp;oacute;n de la base de datos no participe en el &lt;a href=&quot;../sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; incluso si est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">Si el &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; se usa la opci&amp;oacute;n, a continuaci&amp;oacute;n, SQLite es capaz de usar 8 + 3 nombres de archivo, sino que las capacidades se desactiva y debe habilitarse por separado para cada conexi&amp;oacute;n de base de datos mediante el uso de &lt;a href=&quot;uri&quot;&gt;nombres de archivo URI&lt;/a&gt; cuando &lt;a href=&quot;c3ref/open&quot;&gt;la apertura&lt;/a&gt; o &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ci&amp;oacute;n de&lt;/a&gt; los archivos de bases de datos e incluir la &lt;code&gt;8_3_names=1&lt;/code&gt; consulta &quot; 8_3_names = 1 &quot; en el URI. Si SQLite se compila con &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; , los nombres de archivo 8 + 3 est&amp;aacute;n habilitados de forma predeterminada y este paso se puede omitir.</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Si el par&amp;aacute;metro de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; especifica el almacenamiento en disco para archivos temporales, anule esa decisi&amp;oacute;n y utilice el almacenamiento de memoria en su lugar. De lo contrario, siga la recomendaci&amp;oacute;n del par&amp;aacute;metro de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Si el par&amp;aacute;metro de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; especifica el almacenamiento de memoria para archivos temporales, anule esa decisi&amp;oacute;n y utilice el almacenamiento en disco en su lugar. De lo contrario, siga la recomendaci&amp;oacute;n del par&amp;aacute;metro de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">Si la &lt;a href=&quot;datatype3#affinity&quot;&gt;afinidad&lt;/a&gt; de una columna es REAL y esa columna contiene un valor que se puede convertir a un n&amp;uacute;mero entero sin p&amp;eacute;rdida de informaci&amp;oacute;n (si el valor no contiene una parte fraccionaria y no es demasiado grande para ser representado como un n&amp;uacute;mero entero), entonces la columna puede ser almacenado en el registro como un n&amp;uacute;mero entero. SQLite volver&amp;aacute; a convertir el valor a punto flotante al extraerlo del registro.</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">Si el &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID de fila&lt;/a&gt; no tiene un alias de &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; entonces no es persistente y podr&amp;iacute;a cambiar. En particular, el comando &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; cambiar&amp;aacute; las filas de las tablas que no declaran una CLAVE PRIMARIA INTEGER. Por lo tanto, las aplicaciones normalmente no deben acceder al rowid directamente, sino que deben usar una CLAVE PRIMARIA INTEGER.</target>
        </trans-unit>
        <trans-unit id="534413628d6b934f8819dac36d834908d33b9044" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P1 cursor is not currently pointing to a valid row, then this opcode is a no-op and control passes through into the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2855fd74b06888f79f65a4994feb49e64faf791" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P1 cursor is pointing to a valid row, then that row might be the target row, or it might be near and slightly before the target row. This opcode attempts to position the cursor on the target row by, perhaps by invoking sqlite3BtreeStep() on the cursor between 0 and This.P1 times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;opcode#VColumn&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n de VColumn se est&amp;aacute; utilizando para obtener el valor de una columna que no cambia durante una operaci&amp;oacute;n UPDATE, entonces el valor P5 es OPFLAG_NOCHNG. Esto har&amp;aacute; que la funci&amp;oacute;n sqlite3_vtab_nochange () devuelva verdadero dentro del m&amp;eacute;todo xColumn de la implementaci&amp;oacute;n de la tabla virtual. La columna P5 podr&amp;iacute;a contener tambi&amp;eacute;n otros bits (OPFLAG_LENGTHARG o OPFLAG_TYPEOFARG) pero esos bits no han sido utilizados por &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">Si la &lt;a href=&quot;optoverview#flattening&quot;&gt;optimizaci&amp;oacute;n de acoplado&lt;/a&gt; se usa en una subconsulta en la cl&amp;aacute;usula FROM de una instrucci&amp;oacute;n SELECT, eso fusiona efectivamente la subconsulta en la consulta externa. La salida de EXPLAIN QUERY PLAN refleja esto, como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">Si el pragma &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;EMPTY_RESULT_CALLBACKS&lt;/a&gt; se establece en ON y el resultado de una consulta es un conjunto vac&amp;iacute;o, entonces la devoluci&amp;oacute;n de llamada se invoca una vez con el tercer par&amp;aacute;metro (argv) establecido en 0. En otras palabras</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">Si el &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; indicador est&amp;aacute; activado, entonces el m&amp;eacute;todo la F_FULLFSYNC sincronizaci&amp;oacute;n se utiliza para todas las operaciones de sincronizaci&amp;oacute;n y el ajuste checkpoint_fullfsync es irrelevante.</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">Si el pragma &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; est&amp;aacute; activado, entonces el nombre del resultado es el nombre de la columna de la tabla fuente sin el prefijo de nombre de la tabla fuente: COLUMN.</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; establece el elemento sqlite3_file.pMethods en un puntero no NULL, entonces el m&amp;eacute;todo sqlite3_io_methods.xClose puede invocarse incluso si &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; inform&amp;oacute; que fall&amp;oacute;. La &amp;uacute;nica forma de evitar una llamada a xClose despu&amp;eacute;s de un error &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; es que &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; establezca el elemento sqlite3_file.pMethods en NULL.</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; llama a sqlite3_vtab_nochange () y encuentra que la columna no ha sido cambiada por la instrucci&amp;oacute;n UPDATE, entonces el m&amp;eacute;todo xColumn puede regresar opcionalmente sin establecer un resultado, sin llamar a ninguna de las &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;interfaces sqlite3_result_xxxxx ()&lt;/a&gt; . En ese caso, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; devolver&amp;aacute; verdadero para la misma columna en el m&amp;eacute;todo &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; en una implementaci&amp;oacute;n de &lt;a href=&quot;vtab&quot;&gt;tabla virtual&lt;/a&gt; devuelve un mensaje de error usando &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error (),&lt;/a&gt; entonces d&amp;eacute; preferencia a ese mensaje de error sobre los mensajes generados internamente.</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; es NULL, entonces las &lt;a href=&quot;lang_createvtab&quot;&gt;sentencias CREATE VIRTUAL TABLE&lt;/a&gt; est&amp;aacute;n prohibidas para esa tabla virtual, y la tabla virtual es una &quot;tabla virtual s&amp;oacute;lo del mismo nombre&quot;. Las tablas virtuales de solo ep&amp;oacute;nimo son &amp;uacute;tiles como &lt;a href=&quot;vtab#tabfunc2&quot;&gt;funciones con valores de tabla&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; para la tabla virtual est&amp;aacute; definido, y si xFindFunction () a veces devuelve &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; o m&amp;aacute;s grande, entonces las restricciones tambi&amp;eacute;n pueden tener la forma:</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">Si el &lt;a href=&quot;wal&quot;&gt;registro de escritura anticipada&lt;/a&gt; est&amp;aacute; habilitado (a trav&amp;eacute;s del &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;pragma journal_mode&lt;/a&gt; ), este pragma hace que se ejecute una operaci&amp;oacute;n de &lt;a href=&quot;wal#ckpt&quot;&gt;punto de control&lt;/a&gt; en la base de datos</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">Si el argumento del &lt;b&gt;encabezado&lt;/b&gt; es verdadero, la primera fila del archivo CSV se tratar&amp;aacute; como encabezado en lugar de como datos. La segunda l&amp;iacute;nea del archivo CSV se convierte en la primera fila de contenido. Si se omiten las opciones de &lt;b&gt;esquema =&lt;/b&gt; , la primera l&amp;iacute;nea del archivo CSV determina los nombres de las columnas.</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">Si la palabra clave AUTOINCREMENT aparece después de INTEGER PRIMARY KEY,eso cambia el algoritmo de asignación automática de ROWID para evitar la reutilización de los ROWID durante la vida útil de la base de datos.En otras palabras,el propósito de AUTOINCREMENT es prevenir la reutilización de ROWIDs de filas previamente eliminadas.</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">Si la versi&amp;oacute;n C de la &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;biblioteca ICU&lt;/a&gt; est&amp;aacute; disponible, entonces FTS tambi&amp;eacute;n puede compilarse con la macro de preprocesador SQLITE_ENABLE_ICU definida. La compilaci&amp;oacute;n con esta macro habilita un &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizador&lt;/a&gt; FTS que usa la biblioteca ICU para dividir un documento en t&amp;eacute;rminos (palabras) usando las convenciones para un idioma y configuraci&amp;oacute;n regional espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si se intenta la operaci&amp;oacute;n DELETE, pero SQLite devuelve SQLITE_CONSTRAINT (que solo puede suceder si se viola una restricci&amp;oacute;n de clave externa), la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; pasado como segundo argumento. Esto incluye el caso en el que se intenta la operaci&amp;oacute;n DELETE porque una llamada anterior a la funci&amp;oacute;n del controlador de conflictos devolvi&amp;oacute; &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si se intenta la operaci&amp;oacute;n DELETE, pero SQLite devuelve SQLITE_CONSTRAINT (que solo puede suceder si se viola una restricci&amp;oacute;n de clave externa), la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; pasado como segundo argumento. Esto incluye el caso en el que se intenta la operaci&amp;oacute;n DELETE porque una llamada anterior a la funci&amp;oacute;n del controlador de conflictos devolvi&amp;oacute; &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">Si la declaración DELETE tiene una cláusula ORDER BY,entonces todas las filas que se eliminarían en ausencia de la cláusula LIMITADA se ordenan según la cláusula ORDER BY.La primera</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">Si la declaración DELETE no tiene una cláusula ORDER BY,entonces todas las filas que se suprimirían en ausencia de la cláusula LIMITADA se ensamblan en un orden arbitrario antes de aplicar las cláusulas LIMITADA y COMPENSADA para determinar el subconjunto que se suprime realmente.</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">Si se utiliza la opción ESCAPE,el carácter ESCAPE debe ser ASCII,o un carácter de un solo byte en UTF-8.</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">Si se omite la cláusula FROM en una simple declaración SELECT,entonces los datos de entrada son implícitamente una sola fila de cero columnas de ancho (es decir.</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">Si la tabla FTS es una tabla FTS4 (no FTS3),un token también puede ser prefijado con un carácter &quot;^&quot;.En este caso,para que el token coincida,debe aparecer como el primer token en cualquier columna de la fila de coincidencia.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">Si la tabla FTS5 se crea con la opción de &quot;detalle&quot; puesta en &quot;col&quot;,entonces el</target>
        </trans-unit>
        <trans-unit id="328eea17bcdc9be6b714e803c02a72c349cdef14" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the detail=none or detail=column option specified, full-text queries may not contain any tokens longer than 3 unicode characters. LIKE and GLOB pattern matching may be slightly slower, but still works. If the index is to be used only for LIKE and/or GLOB pattern matching, these options are worth experimenting with to reduce the index size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">Si la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n HAVE_FDATASYNC es verdadera, entonces el &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; predeterminado para sistemas Unix intentar&amp;aacute; usar fdatasync () en lugar de fsync () donde sea apropiado. Si esta bandera falta o es falsa, siempre se usa fsync ().</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">Si la opci&amp;oacute;n HAVE_GMTIME_R es verdadera y si &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; es verdadera, entonces las palabras clave CURRENT_TIME, CURRENT_DATE y CURRENT_TIMESTAMP utilizar&amp;aacute;n la interfaz &quot;gmtime_r ()&quot; segura para subprocesos en lugar de &quot;gmtime ()&quot;. En el caso habitual donde &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; no est&amp;aacute; definido o es falso, las &lt;a href=&quot;lang_datefunc&quot;&gt;funciones de fecha y hora integradas&lt;/a&gt; se utilizan para implementar las palabras clave CURRENT_TIME, CURRENT_DATE y CURRENT_TIMESTAMP y nunca se llama a gmtime_r () ni a gmtime ().</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">Si la opción HAVE_ISNAN es verdadera,entonces SQLite invoca la función isan()de la biblioteca del sistema para determinar si un valor de coma flotante de doble precisión es un NaN.Si HAVE_ISNAN es indefinido o falso,entonces SQLite sustituye su propia implementación de isan().</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">Si la opci&amp;oacute;n HAVE_LOCALTIME_R es verdadera, entonces SQLite usa la rutina de biblioteca localtime_r () segura para subprocesos en lugar de localtime () para ayudar a implementar el &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;modificador localtime&lt;/a&gt; a las &lt;a href=&quot;lang_datefunc&quot;&gt;funciones&lt;/a&gt; integradas de fecha y hora .</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">Si la opci&amp;oacute;n HAVE_LOCALTIME_S es verdadera, entonces SQLite usa la rutina de biblioteca localtime_s () segura para subprocesos en lugar de localtime () para ayudar a implementar el &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;modificador localtime&lt;/a&gt; en las &lt;a href=&quot;lang_datefunc&quot;&gt;funciones&lt;/a&gt; integradas de fecha y hora .</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">Si la opción HAVE_MALLOC_USABLE_SIZE se omite o es falsa,entonces SQLite utiliza un envoltorio alrededor del sistema malloc()y realloc()que amplía cada asignación en 8 bytes y escribe el tamaño de la asignación en los 8 bytes iniciales,y luego SQLite también implementa su propia versión casera de malloc_usable_size()que consulta ese prefijo de 8 bytes para encontrar el tamaño de la asignación.Este enfoque funciona pero no es óptimo.Se anima a las aplicaciones a usar HAVE_MALLOC_USABLE_SIZE siempre que sea posible.</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">Si la opci&amp;oacute;n HAVE_MALLOC_USABLE_SIZE es verdadera, entonces SQLite intenta usar la interfaz malloc_usable_size () para encontrar el tama&amp;ntilde;o de una asignaci&amp;oacute;n de memoria obtenida de las rutinas malloc () o realloc () de la biblioteca est&amp;aacute;ndar. Esta opci&amp;oacute;n solo es aplicable si se usa la biblioteca est&amp;aacute;ndar malloc (). En los sistemas Apple, se utiliza &quot;zone malloc&quot; en su lugar, por lo que esta opci&amp;oacute;n no es aplicable. Y, por supuesto, si la aplicaci&amp;oacute;n proporciona su propia implementaci&amp;oacute;n de malloc usando &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; , esta opci&amp;oacute;n no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">Si la opción HAVE_STRCHRNUL es verdadera,entonces SQLite utiliza la función de biblioteca strchrnul().Si esta opción falta o es falsa,entonces SQLite sustituye su propia implementación de strchrnul().</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">Si la opci&amp;oacute;n HAVE_USLEEP es verdadera, entonces el VFS de Unix predeterminado usa la llamada al sistema usleep () para implementar el m&amp;eacute;todo xSleep. Si esta opci&amp;oacute;n no est&amp;aacute; definida o es falsa, entonces xSleep en Unix se implementa usando sleep () lo que significa que &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; tendr&amp;aacute; un intervalo de espera m&amp;iacute;nimo de 1000 milisegundos independientemente de su argumento.</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">Si la opción HAVE_UTIME es verdadera,entonces el VFS incorporado,pero no estándar,&quot;unix-dotfile&quot; utilizará la llamada de sistema utime(),en lugar de utimes(),para establecer el último tiempo de acceso al archivo de bloqueo.</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">Si se incluye la cláusula INTO,entonces el archivo de la base de datos original no se modifica y se crea una nueva base de datos en el nombre de archivo dado por el argumento a la cláusula INTO.La nueva base de datos tendrá el mismo contenido lógico que la base de datos original,completamente vacía.</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">Si la expresión LÍMITE se evalúa a valor no negativo</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">Si la palabra clave NATURAL está en el join-operador,entonces se añade una cláusula implícita de USO a las restricciones del join-operador.La cláusula implícita de USO contiene cada uno de los nombres de las columnas que aparecen en los conjuntos de datos de entrada de la izquierda y la derecha.Si los conjuntos de datos de entrada de la izquierda y la derecha no tienen nombres de columna comunes,entonces la palabra clave NATURAL no tiene efecto en los resultados de la unión.No se puede añadir una cláusula de USING o ON a una unión que especifique la palabra clave NATURAL.</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">Si la N-ésima columna devuelta por la declaración es una expresión o subconsulta y no es un valor de columna,entonces todas estas funciones devuelven NULL.Estas rutinas también pueden devolver NULL si se produce un error de asignación de memoria.En caso contrario,devuelven el nombre de la base de datos,tabla o columna adjunta de la que se extrajo la columna del resultado de la consulta.</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">Si el bit OPFLAG_AUXDELETE está puesto en P5,eso indica que este borra uno de varios asociados con la eliminación de una fila de la tabla y todas sus entradas de índice asociadas.Exactamente uno de esos borrados es el borrado &quot;primario&quot;.Los otros están todos en los cursores OPFLAG_FORDELETE o están marcados con la bandera AUXDELETE.</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">Si el indicador OPFLAG_ISUPDATE se fija en P2,entonces P3 contiene la dirección de la celda de memoria que contiene el valor que el rowid de la fila será fijado por la actualización.</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">Si la bandera OPFLAG_ISUPDATE está activada,entonces este opcode es parte de una operación de UPDATE.De lo contrario (si el indicador está claro),entonces este opcode forma parte de una operación de INSERTAR.La diferencia sólo es importante para el gancho de actualización.</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">Si los bits OPFLAG_LENGTHARG y OPFLAG_TYPEOFARG se fijan en P5,se garantiza que el resultado sólo se utilizará como argumento de una función length()o typeof(),respectivamente.La carga de los blobs grandes puede saltarse para length()y toda la carga de contenido puede saltarse para typeof().</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">Si la bandera OPFLAG_NCHANGE de P2 (NB:P2 no P5)está puesta,entonces el recuento de cambio de fila se incrementa (de lo contrario no).</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">Si la bandera OPFLAG_NCHANGE de P5 está puesta,entonces el recuento de cambio de fila se incrementa (de lo contrario no).Si se fija el indicador OPFLAG_LASTROWID de P5,entonces el rowid se almacena para su posterior devolución por la función sqlite3_last_insert_rowid()(de lo contrario no se modifica).</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">Si el bit OPFLAG_SAVEPOSITION del par&amp;aacute;metro P5 est&amp;aacute; establecido, entonces el cursor se dejar&amp;aacute; apuntando al registro anterior o siguiente de la tabla. Si se deja apuntando al siguiente registro, la siguiente instrucci&amp;oacute;n &lt;a href=&quot;opcode#Next&quot;&gt;Siguiente&lt;/a&gt; ser&amp;aacute; inactiva. Como resultado, en este caso est&amp;aacute; bien eliminar un registro dentro de un ciclo &lt;a href=&quot;opcode#Next&quot;&gt;Siguiente&lt;/a&gt; . Si el bit OPFLAG_SAVEPOSITION de P5 est&amp;aacute; limpio, entonces el cursor se dejar&amp;aacute; en un estado indefinido.</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">Si se fija la bandera OPFLAG_USESEEKRESULT de P5,la implementación podría ser más rápida evitando una búsqueda innecesaria en el cursor P1.Sin embargo,la bandera OPFLAG_USESEEKRESULT sólo debe fijarse si no ha habido búsquedas previas en el cursor o si la búsqueda más reciente utilizó una clave igual a P3.</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">Si se fija la bandera OPFLAG_USESEEKRESULT de P5,la implementación podría ser más rápida evitando una búsqueda innecesaria en el cursor P1.Sin embargo,el indicador OPFLAG_USESEEKRESULT sólo debe fijarse si no ha habido búsquedas anteriores en el cursor o si la búsqueda más reciente utilizó una clave equivalente a P2.</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">Si la expresión ORDER BY es un entero constante K,entonces la expresión se considera un alias para la K-ésima columna del conjunto de resultados (las columnas se numeran de izquierda a derecha empezando por 1).</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">Si la expresión ORDER BY es un identificador que corresponde al alias de una de las columnas de salida,entonces la expresión se considera un alias para esa columna.</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">Si a la expresi&amp;oacute;n ORDER BY se le asigna una secuencia de clasificaci&amp;oacute;n mediante el &lt;a href=&quot;lang_expr#collateop&quot;&gt;operador COLLATE de&lt;/a&gt; sufijo , se utiliza la secuencia de clasificaci&amp;oacute;n especificada.</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">Si el cursor P1 debe estar apuntando a una fila válida (no a una fila NULL)de una tabla real,no a una pseudo-tabla.</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Si la entrada del índice P1 es mayor o igual al valor de la clave,entonces salta a P2.De lo contrario,pasa a la siguiente instrucción.</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Si la entrada del índice P1 es mayor que el valor de la clave,entonces salta a P2.De lo contrario,pasa a la siguiente instrucción.</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Si la entrada del índice P1 es menor o igual que el valor de la clave,entonces salta a P2.De lo contrario,pasa a la siguiente instrucción.</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Si la entrada del índice P1 es menor que el valor clave,entonces salta a P2.De lo contrario,pasa a la siguiente instrucción.</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">Si el valor de P1 es distinto de cero, entonces tambi&amp;eacute;n configure el indicador MEM_Cleared para que los valores NULL no se comparen igual incluso si SQLITE_NULLEQ est&amp;aacute; configurado en &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; o &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">Si el valor de P3 no es cero,entonces la tabla a la que se refiere debe ser una tabla intkey (una tabla SQL,no un índice).En este caso,el recuento de cambios de fila se incrementa con el número de filas de la tabla que se borra.Si P3 es mayor que cero,entonces el valor almacenado en el registro P3 también se incrementa con el número de filas de la tabla que se está borrando.</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">Si la palabra clave REINDEX va seguida de un nombre de secuencia de cotejo,entonces se recrean todos los índices de todas las bases de datos adjuntas que utilizan las secuencias de cotejo nombradas.</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">Si la palabra clave REINDEX no va seguida de una secuencia de cotejo o de un identificador de objeto de la base de datos,se reconstruyen todos los índices de todas las bases de datos adjuntas.</target>
        </trans-unit>
        <trans-unit id="9ec1988ffd8f39b68011de5a95c4dd634ef25613" translate="yes" xml:space="preserve">
          <source>If the S argument to sqlite3_txn_state(D,S) is not the name of a valid schema, then -1 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">Si la instrucci&amp;oacute;n SELECT es &lt;b&gt;una consulta no agregada&lt;/b&gt; , entonces cada expresi&amp;oacute;n en la lista de expresiones de resultado se eval&amp;uacute;a para cada fila en el conjunto de datos filtrado por la cl&amp;aacute;usula WHERE.</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">Si la instrucci&amp;oacute;n SELECT es &lt;b&gt;una consulta agregada con una&lt;/b&gt; cl&amp;aacute;usula &lt;b&gt;GROUP BY&lt;/b&gt; , entonces cada una de las expresiones especificadas como parte de la cl&amp;aacute;usula GROUP BY se eval&amp;uacute;a para cada fila del conjunto de datos. Luego, cada fila se asigna a un &quot;grupo&quot; seg&amp;uacute;n los resultados; las filas para las que los resultados de la evaluaci&amp;oacute;n de las expresiones GROUP BY son iguales se asignan al mismo grupo. A los efectos de agrupar filas, los valores NULL se consideran iguales. Las reglas habituales para &lt;a href=&quot;datatype3#collation&quot;&gt;seleccionar una secuencia de clasificaci&amp;oacute;n&lt;/a&gt; con la que comparar valores de texto se aplican al evaluar expresiones en una cl&amp;aacute;usula GROUP BY. Las expresiones de la cl&amp;aacute;usula GROUP BY &lt;em&gt;no&lt;/em&gt; tienen que ser expresiones que aparezcan en el resultado. Las expresiones en una cl&amp;aacute;usula GROUP BY pueden no ser expresiones agregadas.</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">Si la instrucci&amp;oacute;n SELECT es &lt;b&gt;una consulta agregada sin una&lt;/b&gt; cl&amp;aacute;usula &lt;b&gt;GROUP BY&lt;/b&gt; , entonces cada expresi&amp;oacute;n agregada en el conjunto de resultados se eval&amp;uacute;a una vez en todo el conjunto de datos. Cada expresi&amp;oacute;n no agregada en el conjunto de resultados se eval&amp;uacute;a una vez para una fila seleccionada arbitrariamente del conjunto de datos. Se utiliza la misma fila seleccionada arbitrariamente para cada expresi&amp;oacute;n no agregada. O, si el conjunto de datos contiene cero filas, entonces cada expresi&amp;oacute;n no agregada se eval&amp;uacute;a contra una fila que consta en su totalidad de valores NULL.</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">Si la instrucci&amp;oacute;n SELECT especificada como parte del comando CREATE VIRTUAL TABLE devuelve cinco columnas, la columna final se usa solo para el contexto de la aplicaci&amp;oacute;n. Swarmvtab no usa este valor en absoluto, excepto que se pasa despu&amp;eacute;s de &amp;lt;database-name&amp;gt; a las funciones openclose y missing, si se especifica. En otras palabras, en lugar de invocar las funciones como se describe anteriormente, si la columna &quot;contexto&quot; est&amp;aacute; presente, swarmvtab invoca:</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">Si el comando SQL COMMIT activa la autocomisión y la lógica de autocomisión intenta confirmar el cambio pero falla porque algún otro proceso tiene un bloqueo COMPARTIDO,la autocomisión se desactiva automáticamente.Esto permite al usuario volver a intentar la COMISIÓN en un momento posterior después de que el bloqueo COMPARTIDO haya tenido la oportunidad de despejarse.</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">Si la declaraci&amp;oacute;n SQL que se est&amp;aacute; ejecutando devuelve alg&amp;uacute;n dato, entonces se devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; cada vez que una nueva fila de datos est&amp;aacute; lista para ser procesada por la persona que llama. Se puede acceder a los valores utilizando las &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;funciones de acceso a&lt;/a&gt; la columna . sqlite3_step () se llama de nuevo para recuperar la siguiente fila de datos.</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">Si la declaraci&amp;oacute;n SQL que se est&amp;aacute; ejecutando devuelve alg&amp;uacute;n dato, entonces se devuelve &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; cada vez que una nueva fila de datos est&amp;aacute; lista para ser procesada por la persona que llama. Se puede acceder a los valores utilizando las &lt;a href=&quot;column_blob&quot;&gt;funciones de acceso a&lt;/a&gt; la columna . sqlite3_step () se llama de nuevo para recuperar la siguiente fila de datos.</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">Si la instrucci&amp;oacute;n SQL no apunta actualmente a una fila v&amp;aacute;lida, o si el &amp;iacute;ndice de la columna est&amp;aacute; fuera de rango, el resultado no est&amp;aacute; definido. Estas rutinas solo se pueden llamar cuando la llamada m&amp;aacute;s reciente a &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; ha devuelto &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; y ni &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; ni &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; se han llamado posteriormente. Si alguna de estas rutinas se llama despu&amp;eacute;s de &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; o despu&amp;eacute;s de que &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; haya devuelto algo diferente a &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , los resultados no est&amp;aacute;n definidos. Si &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;se llaman desde un hilo diferente mientras cualquiera de estas rutinas est&amp;aacute; pendiente, entonces los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">Si la instrucci&amp;oacute;n SQL no apunta actualmente a una fila v&amp;aacute;lida, o si el &amp;iacute;ndice de la columna est&amp;aacute; fuera de rango, el resultado no est&amp;aacute; definido. Estas rutinas solo se pueden llamar cuando la llamada m&amp;aacute;s reciente a &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; ha devuelto &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; y ni &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; ni &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; se han llamado posteriormente. Si alguna de estas rutinas se llama despu&amp;eacute;s de &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; o &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; o despu&amp;eacute;s de que &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; haya devuelto algo diferente a &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , los resultados no est&amp;aacute;n definidos. Si &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; o &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; o &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;se llaman desde un hilo diferente mientras cualquiera de estas rutinas est&amp;aacute; pendiente, entonces los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">Si el bit SQLITE_DESERIALIZE_FREEONCLOSE está puesto en F,entonces SQLite invocará a sqlite3_free()en el búfer de serialización cuando se cierre la conexión de la base de datos.Si el bit SQLITE_DESERIALIZE_RESIZEABLE está activado,SQLite intentará aumentar el tamaño del búfer con sqlite3_realloc64()si los escritos en la base de datos hacen que crezca más de M bytes.</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">Si el bit SQLITE_JUMPIFNULL de P5 está activado y reg(P1)o reg(P3)es NULL,entonces el salto se da.Si el bit SQLITE_JUMPIFNULL está libre,entonces el salto se realiza si cualquiera de los operandos es NULL.</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">Si la biblioteca SQLite se compila sin la macro del preprocesador NDEBUG, entonces PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; hace que VDBE rastree la ejecuci&amp;oacute;n de los programas. Aunque esta funci&amp;oacute;n se dise&amp;ntilde;&amp;oacute; originalmente para probar y depurar, tambi&amp;eacute;n puede ser &amp;uacute;til para aprender c&amp;oacute;mo funciona el VDBE. Utilice &quot; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &quot; para activar el seguimiento y &quot; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &quot; para desactivar el seguimiento. Me gusta esto:</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">Si la palabra clave ÚNICA aparece entre CREAR e ÍNDICE entonces no se permiten entradas de índice duplicadas.Cualquier intento de insertar una entrada duplicada resultará en un error.A los efectos de los índices únicos,todos los valores NULL se consideran diferentes de todos los demás valores NULL y,por lo tanto,son únicos.Esta es una de las dos interpretaciones posibles de la norma SQL-92 (el lenguaje de la norma es ambiguo)y es la interpretación seguida por PostgreSQL,MySQL,Firebird y Oracle.Informix y Microsoft SQL Server siguen la otra interpretación del estándar.</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si se intenta la operaci&amp;oacute;n UPDATE, pero SQLite devuelve SQLITE_CONSTRAINT, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; pasado como segundo argumento. Esto incluye el caso en el que se intenta la operaci&amp;oacute;n UPDATE despu&amp;eacute;s de que una llamada anterior a la funci&amp;oacute;n de manejo de conflictos devolviera &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si se intenta la operaci&amp;oacute;n UPDATE, pero SQLite devuelve SQLITE_CONSTRAINT, la funci&amp;oacute;n de manejo de conflictos se invoca con &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; pasado como segundo argumento. Esto incluye el caso en el que se intenta la operaci&amp;oacute;n UPDATE despu&amp;eacute;s de que una llamada anterior a la funci&amp;oacute;n de manejo de conflictos devolviera &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">Si la instrucci&amp;oacute;n UPDATE no tiene una cl&amp;aacute;usula WHERE, UPDATE modifica todas las filas de la tabla. De lo contrario, la ACTUALIZACI&amp;Oacute;N afecta solo a aquellas filas para las que la &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana de la&lt;/a&gt; cl&amp;aacute;usula WHERE es verdadera . No es un error si la cl&amp;aacute;usula WHERE no se eval&amp;uacute;a como verdadera para ninguna fila de la tabla; esto solo significa que la declaraci&amp;oacute;n UPDATE afecta a cero filas.</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">Si la declaración de ACTUALIZACIÓN no tiene una cláusula ORDENADORA,entonces todas las filas que se actualizarían en ausencia de la cláusula LÍMITE se ensamblan en un orden arbitrario antes de aplicar las cláusulas LÍMITE y COMPENSACIÓN para determinar cuáles se actualizan realmente.</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">Si el índice WAL se implementa como un archivo mapeado en memoria y ese archivo es de sólo lectura para el primer hilo que se conecta,entonces ese hilo crea un ersazt WAL-index privado de memoria en pila y ejecuta la rutina de recuperación para poblar ese índice WAL privado.Los mismos datos resultan,pero se mantienen en privado en lugar de ser escritos en el área de memoria compartida pública.</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">Si la cláusula DÓNDE evalúa a FALSO,entonces salta los pasos que siguen y continúa con el siguiente registro.</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">Si la cl&amp;aacute;usula WHERE no est&amp;aacute; presente, se eliminan todos los registros de la tabla. Si se proporciona una cl&amp;aacute;usula WHERE, solo se eliminan las filas para las que la &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana de la&lt;/a&gt; cl&amp;aacute;usula WHERE es verdadera. Se retienen las filas para las que la expresi&amp;oacute;n es falsa o NULL.</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">Si la cl&amp;aacute;usula WHERE de una consulta contiene una expresi&amp;oacute;n OR, entonces SQLite podr&amp;iacute;a usar la estrategia &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR por uni&amp;oacute;n&quot;&lt;/a&gt; (tambi&amp;eacute;n conocida como &lt;a href=&quot;optoverview#or_opt&quot;&gt;optimizaci&amp;oacute;n OR&lt;/a&gt; ). En este caso, habr&amp;aacute; un solo registro de nivel superior para la b&amp;uacute;squeda, con dos subregistros, uno para cada &amp;iacute;ndice:</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f803875c1a08bebb885c914c92a3d72ff50a92" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ffc6e6c2f8710bdccd517328f86881951d2cb6" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should not be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d00867bdc20268b3f199466aa210a4d8a43f54" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should not be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">Si la macro _HAVE_SQLITE_CONFIG_H está definida,entonces el código fuente de SQLite intentará #incluir un archivo llamado &quot;config.h&quot;.El archivo &quot;config.h&quot; suele contener otras opciones de configuración,especialmente &quot;HAVE_&quot;.</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">Si el c&amp;oacute;digo de acci&amp;oacute;n es &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; y la devoluci&amp;oacute;n de llamada devuelve &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , la &lt;a href=&quot;#sqlite3_stmt&quot;&gt;declaraci&amp;oacute;n de&lt;/a&gt; declaraci&amp;oacute;n preparada se construye para sustituir un valor NULL en lugar de la columna de la tabla que se habr&amp;iacute;a le&amp;iacute;do si se hubiera devuelto &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . El retorno &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; se puede utilizar para denegar el acceso de un usuario que no es de confianza a columnas individuales de una tabla. Cuando un &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; hace referencia a una tabla pero no se extraen valores de columna de esa tabla (por ejemplo, en una consulta como &quot;SELECT count (*) FROM tab&quot;), la devoluci&amp;oacute;n de llamada del autorizador &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; se invoca una vez para esa tabla con un nombre de columna que es una cadena vac&amp;iacute;a. Si el c&amp;oacute;digo de acci&amp;oacute;n es &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;y la devoluci&amp;oacute;n de llamada devuelve &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; luego la operaci&amp;oacute;n &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; contin&amp;uacute;a, pero la &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;optimizaci&amp;oacute;n de truncar&lt;/a&gt; est&amp;aacute; deshabilitada y todas las filas se eliminan individualmente.</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">Si el c&amp;oacute;digo de acci&amp;oacute;n es &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; y la devoluci&amp;oacute;n de llamada devuelve &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , la &lt;a href=&quot;stmt&quot;&gt;declaraci&amp;oacute;n de&lt;/a&gt; declaraci&amp;oacute;n preparada se construye para sustituir un valor NULL en lugar de la columna de la tabla que se habr&amp;iacute;a le&amp;iacute;do si se hubiera devuelto &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . El retorno &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; se puede utilizar para denegar el acceso de un usuario que no es de confianza a columnas individuales de una tabla. Cuando un &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; hace referencia a una tabla pero no se extraen valores de columna de esa tabla (por ejemplo, en una consulta como &quot;SELECT count (*) FROM tab&quot;), la devoluci&amp;oacute;n de llamada del autorizador &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; se invoca una vez para esa tabla con un nombre de columna que es una cadena vac&amp;iacute;a. Si el c&amp;oacute;digo de acci&amp;oacute;n es &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;y la devoluci&amp;oacute;n de llamada devuelve &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; luego la operaci&amp;oacute;n &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; contin&amp;uacute;a, pero la &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;optimizaci&amp;oacute;n de truncar&lt;/a&gt; est&amp;aacute; deshabilitada y todas las filas se eliminan individualmente.</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">Si la aplicación no utiliza activadores o vistas,entonces deshabilite las capacidades no utilizadas que utiliza:</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n usa disparadores o vistas, utilice consultas para escanear la tabla &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; para verificar que los disparadores y vistas encontrados all&amp;iacute; son los esperados, que no hay disparadores o vistas excedentes, que los disparadores y vistas existentes no han sido manipulados y que ninguna tabla ordinaria existente ha sido reemplazada por vistas maliciosas.</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n invoca &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; ) en la conexi&amp;oacute;n de la base de datos antes del cierre, el punto de control final a&amp;uacute;n se ejecuta, pero los archivos WAL y WAL-index no se eliminan como lo har&amp;iacute;an normalmente. Esto deja la base de datos en un estado que permite que otros procesos sin permiso de escritura en la base de datos, WAL o archivos de &amp;iacute;ndice WAL abran la base de datos como de solo lectura. Si faltan los archivos WAL y WAL-index, un proceso que carece de permiso para crear e inicializar esos archivos no podr&amp;aacute; abrir la base de datos, a menos que la base de datos se designe como inmutable mediante el &lt;a href=&quot;uri#uriimmutable&quot;&gt;par&amp;aacute;metro de consulta inmutable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n est&amp;aacute; dise&amp;ntilde;ada para administrar datos en peque&amp;ntilde;as partes, la base de datos nunca debe contener cadenas grandes o BLOB y, por lo tanto, el elemento 1 anterior no debe ser un factor. Si la base de datos contiene cadenas grandes o BLOB, deben leerse utilizando &lt;a href=&quot;c3ref/blob&quot;&gt;E / S BLOB incrementales&lt;/a&gt; y las filas que contienen cadenas grandes o BLOB nunca deben actualizarse por ning&amp;uacute;n medio que no sea &lt;a href=&quot;c3ref/blob&quot;&gt;E / S BLOB incremental&lt;/a&gt; . De lo contrario, la rutina &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; necesitar&amp;aacute; leer la fila completa en la memoria contigua en alg&amp;uacute;n momento, y eso involucrar&amp;aacute; al menos una gran asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">Si la aplicación o la computadora central se bloquea antes de que se complete la transacción,entonces el diario de retroceso o el registro de escritura anticipada contiene la información necesaria para restaurar el archivo principal de la base de datos a un estado consistente.Cuando el diario de retroceso o el registro de adelanto de escritura contiene información necesaria para recuperar el estado de la base de datos,se denominan &quot;diario caliente&quot; o &quot;archivo WAL caliente&quot;.Los diarios calientes y los archivos WAL son sólo un factor durante los escenarios de recuperación de errores y,por tanto,son poco comunes,pero forman parte del estado de una base de datos SQLite y,por tanto,no pueden ser ignorados.En este documento se define el formato de un diario de retroceso y el archivo de registro de escritura anticipada,pero el foco está en el archivo principal de la base de datos.</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n usa &lt;a href=&quot;c3ref/create_function&quot;&gt;funciones SQL definidas por la aplicaci&amp;oacute;n&lt;/a&gt; que tienen efectos secundarios, entonces se recomienda establecer el indicador &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; en esas funciones SQL para evitar que se utilicen dentro de disparadores y vistas. Para ilustrar la importancia de esta bandera, considere una aplicaci&amp;oacute;n que implementa una funci&amp;oacute;n SQL &quot;send_money (...)&quot;. Sin la marca SQLITE_DIRECTONLY, un atacante podr&amp;iacute;a agregar un disparador o una vista que use esa funci&amp;oacute;n personalizada, luego enga&amp;ntilde;ar a una aplicaci&amp;oacute;n con altos privilegios para ejecutar una consulta inofensiva que invoca ese disparador o vista maliciosa. El indicador SQLITE_DIRECTONLY evita el ataque al requerir que la funci&amp;oacute;n &quot;send_money ()&quot; sea invocada directamente por la aplicaci&amp;oacute;n, en lugar de indirectamente a trav&amp;eacute;s de un disparador o vista.</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">Si la aplicación quería mantener todo el contenido en la memoria,podía seguir leyendo y analizando las otras páginas usando un hilo de fondo después de dibujar la primera página.O,como la lectura de SQLite es tan eficiente,la aplicación podría optar por reducir su huella en la memoria y mantener sólo una diapositiva en la memoria a la vez.O tal vez mantiene la diapositiva actual y la siguiente en la memoria,para facilitar transiciones rápidas a la siguiente diapositiva.</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">Si el argumento N es positivo, entonces el tama&amp;ntilde;o de cach&amp;eacute; sugerido se establece en N. Si el argumento N es negativo, entonces el n&amp;uacute;mero de p&amp;aacute;ginas de cach&amp;eacute; se ajusta para ser un n&amp;uacute;mero de p&amp;aacute;ginas que usar&amp;iacute;an aproximadamente abs (N * 1024) bytes de memoria. basado en el tama&amp;ntilde;o de p&amp;aacute;gina actual. SQLite recuerda la cantidad de p&amp;aacute;ginas en la cach&amp;eacute; de la p&amp;aacute;gina, no la cantidad de memoria utilizada. Entonces, si configura el tama&amp;ntilde;o de la cach&amp;eacute; con un n&amp;uacute;mero negativo y posteriormente cambia el tama&amp;ntilde;o de la p&amp;aacute;gina (usando el comando &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; ), entonces la cantidad m&amp;aacute;xima de memoria cach&amp;eacute; aumentar&amp;aacute; o disminuir&amp;aacute; en proporci&amp;oacute;n al cambio en el tama&amp;ntilde;o de la p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">Si el argumento N es cero,entonces el límite de acumulación suave está desactivado.</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">Si el argumento X a json(X)contiene objetos JSON con etiquetas duplicadas,entonces no está definido si los duplicados se conservan o no.La implementación actual preserva los duplicados.Sin embargo,las futuras mejoras de esta rutina pueden elegir eliminar silenciosamente los duplicados.</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">Si el argumento es una cadena vacía,entonces el autorizador está deshabilitado.Si se omite el argumento,entonces se devuelve el autorizador actual.</target>
        </trans-unit>
        <trans-unit id="aac72e2d439c55d86892749d71b2d6fa2195d5f5" translate="yes" xml:space="preserve">
          <source>If the argument to &quot;.read&quot; begins with the &quot;|&quot; character, then instead of opening the argument as a file, it runs the argument (without the leading &quot;|&quot;) as a command, then uses the output of that command as its input. Thus, if you have a script that generates SQL, you can execute that SQL directly using a command similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">Si el argumento de %Q es un puntero nulo,entonces la salida es un &quot;NULL&quot; no citado.En otras palabras,un puntero nulo genera un NULL SQL,y un puntero no nulo genera un literal de cadena SQL válido.Si el argumento %q es un puntero nulo entonces no se genera ninguna salida.Por lo tanto,un puntero nulo a %q es lo mismo que una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">Si el argumento de &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; es negativo N, eso significa usar aproximadamente -1024 * N bytes de memoria para la cach&amp;eacute; de p&amp;aacute;gina, independientemente del tama&amp;ntilde;o de la p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">Si el argumento de sqlite3_mutex_enter(),sqlite3_mutex_try(),o sqlite3_mutex_leave()es un puntero NULL,entonces las tres rutinas se comportan como no-ops.</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">Si el argumento de sqlite3_mutex_held()es un puntero NULL,la rutina debería devolver 1.Esto parece contrario a la intuición ya que claramente el mutex no puede ser retenido si no existe.Pero la razón por la que el mutex no existe es porque la construcción no utiliza mutexes.Y no queremos que el assert()que contiene la llamada a sqlite3_mutex_held()falle,por lo que un retorno distinto de cero es lo apropiado.La interfaz sqlite3_mutex_notheld()también debería devolver 1 cuando se le da un puntero NULL.</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">Si se omite el nombre de la variable de la matriz o es la cadena vacía,entonces el valor de cada columna se almacena en una variable con el mismo nombre que la propia columna.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si el intento de insertar la fila falla debido a alguna otra violaci&amp;oacute;n de restricci&amp;oacute;n (por ejemplo, NOT NULL o UNIQUE), se invoca la funci&amp;oacute;n de manejo de conflictos con el segundo argumento establecido en &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; . Esto incluye el caso en el que se vuelve a intentar la operaci&amp;oacute;n INSERT porque una llamada anterior a la funci&amp;oacute;n del controlador de conflictos devolvi&amp;oacute; &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Si el intento de insertar la fila falla debido a alguna otra violaci&amp;oacute;n de restricci&amp;oacute;n (por ejemplo, NOT NULL o UNIQUE), se invoca la funci&amp;oacute;n de manejo de conflictos con el segundo argumento establecido en &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; . Esto incluye el caso en el que se vuelve a intentar la operaci&amp;oacute;n INSERT porque una llamada anterior a la funci&amp;oacute;n del controlador de conflictos devolvi&amp;oacute; &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">Si el intento de insertar la fila falla porque la base de datos ya contiene una fila con los mismos valores de clave primaria, se invoca la funci&amp;oacute;n de manejo de conflictos con el segundo argumento establecido en &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">Si el intento de insertar la fila falla porque la base de datos ya contiene una fila con los mismos valores de clave primaria, se invoca la funci&amp;oacute;n de manejo de conflictos con el segundo argumento establecido en &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">Si el argumento bClear es distinto de cero,entonces los datos auxiliares se borran (se establecen en NULL)antes de que regrese esta función.En este caso el xDelete,si existe,no se invoca.</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">Si el proceso de copia de seguridad se reinicia con suficiente frecuencia,es posible que nunca se ejecute hasta el final y que la función backupDb()no vuelva nunca.</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">Si la expresión base es NULL,entonces el resultado del CASE es siempre el resultado de evaluar la expresión ELSE si existe,o NULL si no existe.</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">Si la ventana base tiene una cláusula de ORDENAR POR,se copia en la nueva ventana.En este caso la nueva ventana no debe especificar una cláusula ORDER BY.Si la ventana base no tiene una cláusula ORDER BY,se puede especificar una como parte de la definición de la nueva ventana.</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">Si el mango de la mancha que se está cerrando se abrió para el acceso de lectura-escritura,y si la base de datos está en modo de autocomisión y no hay otros mangos de lectura-escritura abiertos o declaraciones de escritura activas,la transacción actual está comprometida.Si se produce un error mientras se confirma la transacción,se devuelve un código de error y la transacción se anula.</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">Si la conexión bloqueada está intentando obtener un bloqueo de escritura en una tabla de caché compartida,y más de una otra conexión tiene actualmente un bloqueo de lectura en la misma tabla,entonces SQLite selecciona arbitrariamente una de las otras conexiones para usarla como conexión de bloqueo.</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">Si la instrucción de rama que implementa la prueba &quot;c!=0&quot; en la línea 58 se cambia a un no-op,entonces el bucle while-loop se repetirá para siempre y el conjunto de pruebas fallará con un time-out.Pero si esa rama se cambia a un salto incondicional,entonces la función hash siempre devolverá 0.El problema es que 0 es un hash válido.Una función de hash que siempre devuelve 0 sigue funcionando en el sentido de que SQLite siempre obtiene la respuesta correcta.La tabla de hash de nombres de tablas degenera en una lista enlazada,por lo que las búsquedas de nombres de tablas que se producen al analizar las instrucciones SQL pueden ser un poco más lentas,pero el resultado final será el mismo.</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">Si la memoria intermedia contiene un conjunto de parches,entonces todas las llamadas anteriores a esta función en el mismo objeto del grupo de cambio deben tener también conjuntos de parches especificados.O,si la memoria intermedia contiene un conjunto de cambios,entonces deben tener las llamadas anteriores a esta función.De lo contrario,se devuelve SQLITE_ERROR y no se añaden cambios al grupo de cambios.</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">Si la devoluci&amp;oacute;n de llamada de ocupado es NULL, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; se devuelve inmediatamente despu&amp;eacute;s de encontrar el bloqueo. Si la devoluci&amp;oacute;n de llamada de ocupado no es NULL, entonces la devoluci&amp;oacute;n de llamada podr&amp;iacute;a invocarse con dos argumentos.</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">Si la devoluci&amp;oacute;n de llamada de ocupado es NULL, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; se devuelve inmediatamente despu&amp;eacute;s de encontrar el bloqueo. Si la devoluci&amp;oacute;n de llamada de ocupado no es NULL, entonces la devoluci&amp;oacute;n de llamada podr&amp;iacute;a invocarse con dos argumentos.</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">Si se invoca el método ocupado sin un argumento,se devuelve el nombre del procedimiento de devolución de llamada establecido por última vez por el método ocupado.Si no se ha establecido ningún procedimiento de devolución,se devuelve una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">Si el procedimiento de validación de la memoria caché prescrito por el H35040 es necesario y no prueba que la</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xAccess()requerida por H35140 falla (debido a un error de IO o similar),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xAccess()requerida por H35490 falla (debido a un error de IO u otro error interno de VFS),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xAccess()requerida por H35490 revela que el archivo del diario ya no está presente en el sistema de archivos,entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xCheckReservedLock()requerida por H35160 falla (debido a un error de IO u otro error interno de VFS),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">Si la llamada a xCheckReservedLock()requerida por H35160 indica que algún otro</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xDelete()requerida por H35450 falla (debido a un error de IO u otro error interno de VFS),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xFileSize()requerida por H35450 falla (debido a un error de IO u otro error interno de VFS),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Si la llamada a xOpen()requerida por H35440 falla (debido a un error de IO u otro error interno de VFS),entonces SQLite abandonará el intento de abrir un</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">Si la función de devolución de llamada devuelve cualquier otro valor que no sea SQLITE_OK,la consulta se abandona y la función xQueryPhrase vuelve inmediatamente.Si el valor devuelto es SQLITE_DONE,xQueryPhrase devuelve SQLITE_OK.En caso contrario,el código de error se propaga hacia arriba.</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">Si la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada a &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; devuelve un valor distinto de cero, entonces sqlite3_exec () devolver&amp;aacute; SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="4e73b6d395789a1b49c6f60fbafb266cb7180446" translate="yes" xml:space="preserve">
          <source>If the case_sensitive_like pragma is enabled as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">Si el cambio a la tabla X tambi&amp;eacute;n afecta a otras tablas o &amp;iacute;ndices o los desencadenantes son vistas dentro del esquema, ejecute las instrucciones &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; para modificar esos &amp;iacute;ndices y vistas de otras tablas tambi&amp;eacute;n. Por ejemplo, si cambia el nombre de una columna, se deben modificar todas las restricciones, activadores, &amp;iacute;ndices y vistas de FOREIGN KEY que hacen referencia a esa columna.</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">Si las columnas de su conjunto de resultados son nombradas por cl&amp;aacute;usulas AS, entonces se garantiza que SQLite usar&amp;aacute; el identificador a la derecha de la palabra clave AS como el nombre de la columna. Si el conjunto de resultados no usa una cl&amp;aacute;usula AS, entonces SQLite es libre de nombrar la columna como quiera. Consulte la documentaci&amp;oacute;n &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">Si el método de compresión para el registro es 0 u 8 (véase más abajo),entonces los datos descomprimidos asociados a la entrada del archivo zip.O,si el método de compresión no es 0 u 8,esta columna contiene un valor NULL.</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">Si el contenido est&amp;aacute; comprimido, dicha &lt;a href=&quot;sqlar&quot;&gt;base de&lt;/a&gt; datos SQLite Archive tiene &lt;a href=&quot;affcase1#smaller&quot;&gt;el mismo tama&amp;ntilde;o&lt;/a&gt; (&amp;plusmn; 1%) que un archivo ZIP equivalente, y tiene la ventaja de poder actualizar &quot;archivos&quot; individuales sin volver a escribir todo el documento.</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">Si el contenido de una subconsulta puede tener que ser visitado más de una vez,entonces el uso de una subrutina es indeseable,ya que la subrutina tendría que computar los datos más de una vez.Y si la subconsulta no puede ser aplanada,eso significa que la subconsulta debe manifestarse en una tabla transitoria.</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">Si se utiliza la opción de contenido junto con la opción languageid,entonces la columna languageid nombrada debe existir en el cuadro content=(sujeto a las reglas habituales-si una consulta nunca necesita leer el cuadro de contenido entonces esta restricción no se aplica).</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">Si la corrutina que se inicia con esta instrucci&amp;oacute;n termina con &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; o &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; , contin&amp;uacute;e con la siguiente instrucci&amp;oacute;n. Pero si la corrutina iniciada por esta instrucci&amp;oacute;n termina con &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt; , salte a P2 en lugar de continuar con la siguiente instrucci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">Si se utiliza el índice de cobertura para el escaneo,la columna &quot;fruta&quot; aparecerá naturalmente en el orden correcto,pero cuando hay dos o más filas con la misma fruta,el precio podría estar fuera de lugar.Cuando esto ocurre,SQLite hace muchos tipos pequeños,un tipo por cada valor distinto de fruta,en lugar de un tipo grande.La figura 22 infra ilustra el concepto.</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">Si la declaraci&amp;oacute;n actual no est&amp;aacute; dentro de una transacci&amp;oacute;n expl&amp;iacute;cita (un bloque &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; ), entonces se confirma una transacci&amp;oacute;n impl&amp;iacute;cita tan pronto como la declaraci&amp;oacute;n haya terminado de ejecutarse. En este caso, las restricciones diferidas se comportan igual que las restricciones inmediatas.</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">Si la versión actual de SQLite es 3.8.2 o superior,el campo &quot;estimatedRows&quot; puede ser configurado como una estimación del número de filas devueltas por el plan de consulta propuesto.Si este valor no se establece explícitamente,se utiliza la estimación por defecto de 25 filas.</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">Si la versión actual de SQLite es 3.9.0 o superior,el campo idxFlags puede establecerse en SQLITE_INDEX_SCAN_UNIQUE para indicar que la tabla virtual sólo devolverá cero o una fila dadas las restricciones de entrada.Los bits adicionales del campo idxFlags pueden entenderse en versiones posteriores de SQLite.</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">Si el cursor P1 ya está abierto en una tabla efímera,la tabla se borra (se borra todo el contenido).</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">Si el cursor P1 se abri&amp;oacute; usando la bandera OPFLAG_SEEKEQ, entonces este c&amp;oacute;digo de operaci&amp;oacute;n siempre aterrizar&amp;aacute; en un registro que sea igual a la clave, o bien saltar&amp;aacute; inmediatamente a P2. Cuando el cursor es OPFLAG_SEEKEQ, este c&amp;oacute;digo de operaci&amp;oacute;n debe ir seguido de un &lt;a href=&quot;opcode#IdxGE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxGE con los mismos argumentos. El &lt;a href=&quot;opcode#IdxGE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxGE se omitir&amp;aacute; si este c&amp;oacute;digo de operaci&amp;oacute;n tiene &amp;eacute;xito, pero el &lt;a href=&quot;opcode#IdxGE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxGE se utilizar&amp;aacute; en iteraciones de bucle posteriores.</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">Si el cursor P1 se abri&amp;oacute; usando la bandera OPFLAG_SEEKEQ, entonces este c&amp;oacute;digo de operaci&amp;oacute;n siempre aterrizar&amp;aacute; en un registro que sea igual a la clave, o bien saltar&amp;aacute; inmediatamente a P2. Cuando el cursor es OPFLAG_SEEKEQ, este c&amp;oacute;digo de operaci&amp;oacute;n debe ir seguido de un &lt;a href=&quot;opcode#IdxLE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxLE con los mismos argumentos. El &lt;a href=&quot;opcode#IdxLE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxLE se omitir&amp;aacute; si este c&amp;oacute;digo de operaci&amp;oacute;n tiene &amp;eacute;xito, pero el &lt;a href=&quot;opcode#IdxLE&quot;&gt;c&amp;oacute;digo de&lt;/a&gt; operaci&amp;oacute;n IdxLE se utilizar&amp;aacute; en iteraciones de bucle posteriores.</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3c36932aae97dabbc79dda8de195dddbecf67b" translate="yes" xml:space="preserve">
          <source>If the cursor ends up past the target row (indicating the the target row does not exist in the btree) then jump to SeekOP.P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4bfe1f95f30885f0c414ba75caba527ba256bd" translate="yes" xml:space="preserve">
          <source>If the cursor is successfully moved to the target row by 0 or more sqlite3BtreeNext() calls, then jump to This.P2, which will land just past the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode that follows the &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Si la conexi&amp;oacute;n de la base de datos est&amp;aacute; asociada con declaraciones preparadas no finalizadas u objetos sqlite3_backup sin terminar, entonces sqlite3_close () dejar&amp;aacute; abierta la conexi&amp;oacute;n de la base de datos y devolver&amp;aacute; &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Si se llama a sqlite3_close_v2 () con declaraciones preparadas sin finalizar y / o sqlite3_backups sin terminar, la conexi&amp;oacute;n de la base de datos se convierte en un &quot;zombie&quot; inutilizable que se desasignar&amp;aacute; autom&amp;aacute;ticamente cuando finalice la &amp;uacute;ltima declaraci&amp;oacute;n preparada o cuando finalice la &amp;uacute;ltima copia de seguridad de sqlite3_. La interfaz sqlite3_close_v2 () est&amp;aacute; dise&amp;ntilde;ada para usarse con lenguajes host que son recolectados de basura y donde el orden en el que se llaman los destructores es arbitrario.</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Si la conexi&amp;oacute;n de la base de datos est&amp;aacute; asociada con declaraciones preparadas no finalizadas u objetos sqlite3_backup sin terminar, entonces sqlite3_close () dejar&amp;aacute; abierta la conexi&amp;oacute;n de la base de datos y devolver&amp;aacute; &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Si se llama a sqlite3_close_v2 () con declaraciones preparadas sin finalizar y / o sqlite3_backups sin terminar, la conexi&amp;oacute;n de la base de datos se convierte en un &quot;zombie&quot; inutilizable que se desasignar&amp;aacute; autom&amp;aacute;ticamente cuando finalice la &amp;uacute;ltima declaraci&amp;oacute;n preparada o cuando finalice la &amp;uacute;ltima copia de seguridad de sqlite3_. La interfaz sqlite3_close_v2 () est&amp;aacute; dise&amp;ntilde;ada para usarse con lenguajes host que son recolectados de basura y donde el orden en el que se llaman los destructores es arbitrario.</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">Si la conexión a la base de datos se abre de nuevo,asegúrese de que ha leído el esquema de la base de datos preparándose y luego descartando alguna consulta contra la base de datos,o llamando a sqlite3_table_column_metadata(),ignorando cualquier error.Este paso sólo es necesario si la aplicación desea mantener la base de datos en modo WAL después del reinicio si estaba en modo WAL antes del reinicio.</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">Si el archivo de la base de datos tiene alias (enlaces duros o blandos)y el archivo se abre con un alias diferente al utilizado para crear el diario,entonces el diario no se encontrará.Para evitar este problema,no se deben crear enlaces a los archivos de la base de datos SQLite.</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">Si el esquema de la base de datos cambia, en lugar de devolver &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; como siempre sol&amp;iacute;a hacer, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; recompilar&amp;aacute; autom&amp;aacute;ticamente la declaraci&amp;oacute;n SQL e intentar&amp;aacute; ejecutarla nuevamente. &lt;a href=&quot;compile#max_schema_retry&quot;&gt;Se&lt;/a&gt; producir&amp;aacute;n tantos como SQLITE_MAX_SCHEMA_RETRY reintentos antes de que sqlite3_step () se rinda y devuelva un error.</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">Si el esquema de la base de datos cambia, en lugar de devolver &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; como siempre sol&amp;iacute;a hacer, &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; recompilar&amp;aacute; autom&amp;aacute;ticamente la declaraci&amp;oacute;n SQL e intentar&amp;aacute; ejecutarla nuevamente. &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;Se&lt;/a&gt; producir&amp;aacute;n tantos como SQLITE_MAX_SCHEMA_RETRY reintentos antes de que sqlite3_step () se rinda y devuelva un error.</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">Si el esquema de la base de datos contiene errores de claves externas que requieren la observación de más de una definición de tabla para su identificación,entonces esos errores no se detectan cuando se crean las tablas.En su lugar,esos errores impiden que la aplicación prepare sentencias SQL que modifiquen el contenido de las tablas hijo o padre de forma que utilicen las claves externas.Los errores que se notifican cuando se modifica el contenido son &quot;errores DML&quot; y los errores que se notifican cuando se modifica el esquema son &quot;errores DDL&quot;.En otras palabras,las restricciones de claves externas mal configuradas que requieren mirar tanto al hijo como al padre son errores DML.El mensaje de error en inglés para los errores DML de clave externa suele ser &quot;foreign key mismatch&quot; pero también puede ser &quot;no such table&quot; si la tabla padre no existe.Los errores de LMD de clave externa se informan si:</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">Si el tipo declarado contiene la cadena &quot;INT&quot; entonces se le asigna afinidad INTEGER.</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">Si el tipo declarado para una columna contiene cualquiera de las cadenas &quot;REAL&quot;,&quot;FLOA&quot; o &quot;DOUB&quot; entonces la columna tiene afinidad REAL.</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">Si el tipo declarado para una columna contiene la cadena &quot;BLOB&quot; o si no se especifica ningún tipo,entonces la columna tiene afinidad BLOB.</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">Si el tipo declarado de la columna contiene alguna de las cadenas &quot;CHAR&quot;,&quot;CLOB&quot; o &quot;TEXT&quot;,entonces esa columna tiene afinidad con el TEXTO.Observe que el tipo VARCHAR contiene la cadena &quot;CHAR&quot; y por lo tanto se le asigna afinidad de TEXTO.</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">Si el punto de entrada por defecto &quot;sqlite3_extension_init&quot; no está presente en la extensión cargable,pruebe también un punto de entrada &quot;sqlite3_X_init&quot; donde &quot;X&quot; se basa en el nombre de archivo de la biblioteca compartida.Esto permite que cada extensión tenga un punto de entrada diferente,lo que permite enlazarlas estáticamente sin cambios de código.</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">Si el valor por defecto de una columna es CURRENT_TIME,CURRENT_DATE o CURRENT_TIMESTAMP,entonces el valor utilizado en la nueva fila es una representación de texto de la fecha y/o la hora UTC actual.Para HORA_CURRENTE,el formato del valor es &quot;HH:MM:SS&quot;.Para FECHA_CIRCULAR,&quot;AAAA-MM-DD&quot;.El formato de la HORA_MOMENTO_ACTUAL es &quot;AAAA-MM-DD HH:MM:SS&quot;.</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">Si el valor por defecto de una columna es una expresión entre paréntesis,entonces la expresión se evalúa una vez por cada fila insertada y los resultados se utilizan en la nueva fila.</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">Si el valor por defecto de la columna es un valor constante NULL,de texto,blob o de número con signo,entonces ese valor se utiliza directamente en la nueva fila.</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">Si la opci&amp;oacute;n de detalle se establece en &lt;b&gt;columna&lt;/b&gt; , entonces, para cada t&amp;eacute;rmino, el &amp;iacute;ndice FTS registra &amp;uacute;nicamente el ID de fila y el n&amp;uacute;mero de columna, omitiendo la informaci&amp;oacute;n de compensaci&amp;oacute;n del t&amp;eacute;rmino. Esto da como resultado las siguientes restricciones:</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">Si la opci&amp;oacute;n de detalle se establece en &lt;b&gt;none&lt;/b&gt; , entonces, para cada t&amp;eacute;rmino, el &amp;iacute;ndice FTS registra solo el rowid. Se omiten tanto la informaci&amp;oacute;n de columna como la de desplazamiento. Adem&amp;aacute;s de las restricciones detalladas anteriormente para el modo detalle = columna, esto impone las siguientes limitaciones adicionales:</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">Si el tamaño del archivo no es de cero bytes y la memoria caché de la página no contiene datos válidos para la primera página de la base de datos,entonces los datos de la primera página deben leerse de la base de datos.</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">Si el argumento del nombre de archivo para el shell es un archivo ZIP en lugar de una base de datos SQLite, entonces el shell abre autom&amp;aacute;ticamente ese archivo ZIP utilizando la &lt;a href=&quot;zipfile&quot;&gt;tabla virtual Zipfile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">Si el nombre del archivo es &quot;:memory:&quot;,entonces se crea una base de datos privada y temporal en memoria para la conexión.Esta base de datos en memoria desaparecerá cuando la conexión de la base de datos se cierre.Las futuras versiones de SQLite podrían utilizar nombres de archivo especiales adicionales que empiecen con el carácter &quot;:&quot;.Se recomienda que cuando el nombre de un archivo de la base de datos empiece con el carácter &quot;:&quot;,se anteponga al nombre del archivo una ruta como &quot;./&quot; para evitar ambigüedades.</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">Si el nombre del archivo es una cadena vacía,entonces se creará una base de datos privada y temporal en el disco.Esta base de datos privada se eliminará automáticamente en cuanto se cierre la conexión a la base de datos.</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">Si el parámetro final de sqlite3_create_function_v2()o sqlite3_create_window_function()no es NULL,entonces es un destructor para el puntero de datos de la aplicación.El destructor se invoca cuando se elimina la función,ya sea por sobrecarga o cuando se cierra la conexión a la base de datos.El destructor también se invoca si la llamada a sqlite3_create_function_v2()falla.Cuando se invoca la llamada al destructor,se le pasa un único argumento que es una copia del puntero de datos de la aplicación que era el quinto parámetro de sqlite3_create_function_v2().</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">Si el primer carácter del nombre de archivo &quot;.output&quot; o &quot;.once&quot; es un símbolo de pipa (&quot;|&quot;),entonces los caracteres restantes se tratan como un comando y la salida se envía a ese comando.Esto hace que sea fácil canalizar los resultados de una consulta a algún otro proceso.Por ejemplo,el comando &quot;abrir -f&quot; en un Mac abre un editor de texto para mostrar el contenido que lee de la entrada estándar.Así que para ver los resultados de una consulta en un editor de texto,uno podría escribir:</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">Si el parámetro de las banderas no es cero,entonces el BLOB se abre para el acceso de lectura y escritura.Si el parámetro flags es cero,el BLOB se abre para acceso de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">Si el tipo de cuadro es RANGO o GRUPOS,entonces las filas con los mismos valores para todas las expresiones de ORDEN POR se consideran &quot;pares&quot;.O,si no hay términos de ORDEN POR,todas las filas son iguales.Los pares están siempre dentro del mismo marco.</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">Si el &amp;iacute;ndice de texto completo es coherente con el contenido de la tabla, el INSERT utilizado para invocar el comando de verificaci&amp;oacute;n de integridad funciona correctamente. O, si se encuentra alguna discrepancia, falla con un error &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">Si la función se registra mediante la API sqlite3_collation_need(),entonces se le pasan los nombres de las secuencias de cotejo no definidas como cadenas codificadas en UTF-8.Si se utiliza sqlite3_collation_need16(),los nombres se pasan como UTF-16 en el orden de bytes nativo de la máquina.Una llamada a cualquiera de las dos funciones sustituye a la llamada existente de collation_needed.</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">Si el l&amp;iacute;mite superior estricto en mmap_size es distinto de cero en el momento de la compilaci&amp;oacute;n, a&amp;uacute;n puede reducirse o ponerse a cero en el momento de inicio utilizando la &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;interfaz &lt;/a&gt;&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( SQLITE_CONFIG_MMAP_SIZE , X, Y). Los par&amp;aacute;metros X e Y deben ser n&amp;uacute;meros enteros de 64 bits con signo. El par&amp;aacute;metro X es el mmap_size predeterminado del proceso y la Y es el nuevo l&amp;iacute;mite superior duro. El l&amp;iacute;mite superior &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;estricto&lt;/a&gt; no se puede aumentar por encima de su configuraci&amp;oacute;n de tiempo de compilaci&amp;oacute;n mediante SQLITE_CONFIG_MMAP_SIZE, pero se puede reducir o poner a cero.</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">Si el valor inicial del registro P1 es inferior a 1,entonces el valor no se modifica y el control pasa a la siguiente instrucción.</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">Si la operación de inserción causara el fallo de la restricción de singularidad identificada por la cláusula de objetivo de conflicto,entonces se omite la inserción y en su lugar se realiza la operación de NO HACER NADA o ACTUALIZAR.En el caso de una inserción de varias filas,esta decisión se toma por separado para cada fila de la inserción.</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">Si el iterador apunta a una entrada v&amp;aacute;lida DELETE o UPDATE, se puede usar la API &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old ()&lt;/a&gt; para obtener los valores antiguos. * Dentro de la carga &amp;uacute;til del cambio.</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">Si el iterador apunta a una entrada INSERT o UPDATE v&amp;aacute;lida, se puede usar la API &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; para obtener los nuevos valores. * Dentro de la carga &amp;uacute;til del cambio.</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">Si el iterador apunta a una entrada v&amp;aacute;lida, la API &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op ()&lt;/a&gt; se puede usar para determinar el tipo de cambio (INSERT, UPDATE o DELETE) al que apunta el iterador. Adem&amp;aacute;s, la misma API se puede utilizar para obtener el nombre de la tabla a la que se aplica el cambio y su n&amp;uacute;mero esperado de columnas y columnas de clave primaria.</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">Si el operador de la unión es &quot;CRUZADA&quot;,&quot;UNIÓN INTERNA&quot;,&quot;UNIDAD&quot; o una coma (&quot;,&quot;)y no hay una cláusula de ENCENDIDO o USO,entonces el resultado de la unión es simplemente el producto cartesiano de los conjuntos de datos de la izquierda y la derecha.Si el operador del join tiene cláusulas ON o USING,éstas se manejan de acuerdo a los siguientes puntos:</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">Si el operador de unión es un &quot;LEFT JOIN&quot; o &quot;LEFT OUTER JOIN&quot;,entonces después de que se hayan aplicado las cláusulas de filtrado ON o USING,se añade una fila extra a la salida de cada fila en el conjunto de datos de entrada original de la izquierda que corresponde a ninguna fila en absoluto en el conjunto de datos compuesto (si existe).Las filas añadidas contienen valores NULL en las columnas que normalmente contendrían valores copiados del conjunto de datos de entrada de la derecha.</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">Si se llama a la función json_remove(X)sin argumentos de ruta,entonces devuelve la entrada X reformateada,con el exceso de espacio en blanco eliminado.</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">Si el &amp;uacute;ltimo cliente que usa la base de datos se apaga limpiamente llamando a &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; , entonces se ejecuta un &lt;a href=&quot;wal#ckpt&quot;&gt;punto de control&lt;/a&gt; autom&amp;aacute;ticamente para transferir toda la informaci&amp;oacute;n del archivo wal a la base de datos principal, y tanto el archivo shm como el archivo wal se desvinculan. Por lo tanto, cuando la base de datos no est&amp;aacute; en uso por ning&amp;uacute;n cliente, suele ocurrir que solo el archivo de la base de datos principal existe en el disco. Sin embargo, si el &amp;uacute;ltimo cliente no llam&amp;oacute; a &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; antes de cerrarse, o si el &amp;uacute;ltimo cliente que se desconect&amp;oacute; fue un cliente de solo lectura, entonces la operaci&amp;oacute;n de limpieza final no ocurre y los archivos shm y wal a&amp;uacute;n pueden existir en el disco. incluso cuando la base de datos no est&amp;aacute; en uso.</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Si la &amp;uacute;ltima conexi&amp;oacute;n a una base de datos falla, la primera conexi&amp;oacute;n nueva para abrir la base de datos iniciar&amp;aacute; un proceso de recuperaci&amp;oacute;n. Se mantiene un bloqueo exclusivo durante la recuperaci&amp;oacute;n. Entonces, si una tercera conexi&amp;oacute;n de base de datos intenta entrar y consultar mientras la segunda conexi&amp;oacute;n se est&amp;aacute; recuperando, la tercera conexi&amp;oacute;n obtendr&amp;aacute; un error &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">Si el apellido y el nombre de la fila inferior de la pantalla anterior est&amp;aacute;n vinculados a? 1 y? 2, la consulta anterior calcula las siguientes 7 filas. Y, asumiendo que hay un &amp;iacute;ndice apropiado, lo hace de manera muy eficiente, mucho m&amp;aacute;s eficiente que OFFSET.</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">Si la biblioteca no está configurada para UTF-8 y la biblioteca Tcl es una de las más recientes que utiliza UTF-8 internamente,entonces una conversión de UTF-8 a iso8859 y viceversa se hace dentro de la interfaz TCL.</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">Si el modo de bloqueo es EXCLUSIVO cuando ingresa por primera vez al &lt;a href=&quot;wal&quot;&gt;modo de diario WAL&lt;/a&gt; , entonces el modo de bloqueo no se puede cambiar a NORMAL hasta despu&amp;eacute;s de salir del modo de diario WAL. Si el modo de bloqueo es NORMAL cuando ingresa por primera vez al modo de diario WAL, entonces el modo de bloqueo se puede cambiar entre NORMAL y EXCLUSIVO y viceversa en cualquier momento y sin necesidad de salir del modo de diario WAL.</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">Si la frase coincidente en la consulta FTS se restringe a los datos coincidentes en una columna de la tabla FTS especificada,entonces sólo se considerarán las coincidencias de frases que se produzcan dentro de esa columna.</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">Si los subsistemas de asignaci&amp;oacute;n de memoria dentro de SQLite est&amp;aacute;n configurados para un funcionamiento sin aver&amp;iacute;as, pero el uso real de la memoria excede los l&amp;iacute;mites de dise&amp;ntilde;o establecidos por la &lt;a href=&quot;malloc#nofrag&quot;&gt;prueba de Robson&lt;/a&gt; , SQLite generalmente seguir&amp;aacute; funcionando normalmente. El &lt;a href=&quot;malloc#pagecache&quot;&gt;asignador de memoria de pagecache&lt;/a&gt; y el &lt;a href=&quot;malloc#lookaside&quot;&gt;asignador de memoria lookaside conmutan&lt;/a&gt; autom&amp;aacute;ticamente por error al asignador de memoria de prop&amp;oacute;sito general &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; . Y suele ocurrir que el asignador de memoria &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; seguir&amp;aacute; funcionando sin fragmentaci&amp;oacute;n incluso si &lt;b&gt;M&lt;/b&gt; y / o &lt;b&gt;n&lt;/b&gt; exceden los l&amp;iacute;mites impuestos por la &lt;a href=&quot;malloc#nofrag&quot;&gt;prueba de Robson&lt;/a&gt; . La &lt;a href=&quot;malloc#nofrag&quot;&gt;prueba de Robson&lt;/a&gt;muestra que es posible que una asignaci&amp;oacute;n de memoria se descomponga y falle en esta circunstancia, pero tal falla requiere una secuencia especialmente despreciable de asignaciones y desasignaciones, una secuencia que nunca se ha observado que siga SQLite. Por tanto, en la pr&amp;aacute;ctica suele ocurrir que los l&amp;iacute;mites impuestos por Robson pueden superarse por un margen considerable sin efectos negativos.</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">Si la función que falta devuelve un error,entonces la base de datos no se abre y el error se devuelve al usuario.Si se configura una función de abrir-cerrar,entonces se emite una invocación de &quot;cerrar&quot; en este punto para que coincida con la anterior &quot;abrir&quot;.El siguiente seudocódigo ilustra el procedimiento utilizado por una instancia de swarmvtab con funciones tanto de cierre como de apertura configuradas cuando se abre una base de datos de componentes.</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Si la llamada m&amp;aacute;s reciente a &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; para la &lt;a href=&quot;#sqlite3_stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; S indic&amp;oacute; un error, entonces &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; devuelve un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Si la llamada m&amp;aacute;s reciente a &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; para la &lt;a href=&quot;#sqlite3_stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; S volvi&amp;oacute; &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; o &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , o si &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; nunca antes se hab&amp;iacute;a pedido a S, entonces &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; devuelve &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Si la llamada m&amp;aacute;s reciente a &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; para la &lt;a href=&quot;stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; S indic&amp;oacute; un error, entonces &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; devuelve un &lt;a href=&quot;../rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Si la llamada m&amp;aacute;s reciente a &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; para la &lt;a href=&quot;stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; S volvi&amp;oacute; &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; o &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , o si &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; nunca antes se hab&amp;iacute;a pedido a S, entonces &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; devuelve &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">Si la llamada a la API sqlite3_ * m&amp;aacute;s reciente asociada con la &lt;a href=&quot;#sqlite3&quot;&gt;conexi&amp;oacute;n&lt;/a&gt; D de la base de datos fall&amp;oacute;, entonces la interfaz sqlite3_errcode (D) devuelve el &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de resultado&lt;/a&gt; num&amp;eacute;rico o &lt;a href=&quot;rescode#extrc&quot;&gt;el c&amp;oacute;digo de resultado extendido&lt;/a&gt; para esa llamada a la API. La interfaz sqlite3_extended_errcode () es la misma excepto que siempre devuelve el &lt;a href=&quot;rescode#extrc&quot;&gt;c&amp;oacute;digo de resultado extendido&lt;/a&gt; incluso cuando los c&amp;oacute;digos de resultado extendidos est&amp;aacute;n deshabilitados.</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">Si la llamada a la API sqlite3_ * m&amp;aacute;s reciente asociada con la &lt;a href=&quot;sqlite3&quot;&gt;conexi&amp;oacute;n&lt;/a&gt; D de la base de datos fall&amp;oacute;, entonces la interfaz sqlite3_errcode (D) devuelve el &lt;a href=&quot;../rescode&quot;&gt;c&amp;oacute;digo de resultado&lt;/a&gt; num&amp;eacute;rico o &lt;a href=&quot;../rescode#extrc&quot;&gt;el c&amp;oacute;digo de resultado extendido&lt;/a&gt; para esa llamada de API. La interfaz sqlite3_extended_errcode () es la misma excepto que siempre devuelve el &lt;a href=&quot;../rescode#extrc&quot;&gt;c&amp;oacute;digo de resultado extendido&lt;/a&gt; incluso cuando los c&amp;oacute;digos de resultado extendidos est&amp;aacute;n deshabilitados.</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">Si el argumento nByte es negativo,entonces zSql se lee hasta el primer terminador cero.Si nByte es positivo,entonces es el número de bytes leídos de zSql.Si nByte es cero,entonces no se genera ninguna declaración preparada.Si la persona que llama sabe que la cadena suministrada es nul,entonces hay una pequeña ventaja de rendimiento al pasar un parámetro de nByte que es el número de bytes en la cadena de entrada</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">Si el nombre de la base de datos es una cadena vacía,abra una nueva base de datos en un archivo temporal que se elimine automáticamente cuando se cierre la base de datos.</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">Si el nuevo conjunto de cambios contiene cambios en una tabla que ya está presente en el grupo de cambios,entonces el número de columnas y la posición de las columnas clave primarias de la tabla deben ser coherentes.Si no es así,esta función falla con SQLITE_SCHEMA.Si el grupo de cambios de entrada parece estar corrupto y se detecta la corrupción,se devuelve SQLITE_CORRUPT.O,si se produce una condición de falta de memoria durante el procesamiento,esta función devuelve SQLITE_NOMEM.En todos los casos,si se produce un error,el contenido final del grupo de cambios no se define.</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">Si el nuevo límite es un número negativo,el límite no cambia.Para cada categoría de límite SQLITE_LIMIT_</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">Si el número de filas de salida es K,entonces el tiempo necesario para clasificar es proporcional a KlogK.Si K es pequeño,el tiempo de clasificación no suele ser un factor,pero en una consulta como la anterior en la que K==N,el tiempo necesario para clasificar puede ser mucho mayor que el tiempo necesario para hacer una exploración completa de la tabla.Además,toda la salida se acumula en almacenamiento temporal (que puede estar en la memoria principal o en el disco,dependiendo de diversos ajustes de tiempo de compilación y de ejecución),lo que puede significar que se necesita mucho almacenamiento temporal para completar la consulta.</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">Si el sistema operativo no soporta solicitudes de sueño con resolución de tiempo de milisegundos,entonces el tiempo se redondeará al segundo más cercano.Se devuelve el número de milisegundos de sueño realmente solicitado al sistema operativo.</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">Si el sistema operativo devuelve un error de E / S al intentar obtener un cierto bloqueo en la memoria compartida en &lt;a href=&quot;wal&quot;&gt;modo WAL,&lt;/a&gt; entonces SQLite podr&amp;iacute;a no restablecer su cach&amp;eacute;, lo que podr&amp;iacute;a provocar la corrupci&amp;oacute;n de la base de datos si se intentan escrituras posteriores.</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">Si la operación tiene éxito,se devuelve SQLITE_OK.En caso contrario,un código de error de SQLite.En este caso,si el argumento pzErrMsg no es NULL,se puede configurar *pzErrMsg para que apunte a un búfer que contenga un mensaje de error en inglés.Es responsabilidad del llamante liberar este buffer usando sqlite3_free().</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">Si la cláusula opcional de ESCAPE está presente,entonces la expresión que sigue a la palabra clave ESCAPE debe evaluarse a una cadena que consista en un solo carácter.Este carácter puede utilizarse en el patrón LIKE para incluir el porcentaje literal o los caracteres de subrayado.El carácter de escape seguido de un símbolo de porcentaje (%),subrayado (_),o una segunda instancia del propio carácter de escape coincide con un símbolo de porcentaje literal,subrayado o un único carácter de escape,respectivamente.</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">Si la cláusula opcional SI NO EXISTE está presente y ya existe otro índice con el mismo nombre,entonces este comando se convierte en un no-op.</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">Si la consulta externa es un agregado,entonces la subconsulta puede no contener ORDEN POR.</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">Si la consulta externa es parte de una selección compuesta,entonces la subconsulta puede no tener una cláusula LIMITE.</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">Si los parámetros de salida (ppRebase)y (pnRebase)son no-NULL y la entrada es un changeset (no un patchset),entonces sqlite3changeset_apply_v2()puede establecer (*ppRebase)para que apunte a un &quot;rebase&quot; que puede ser utilizado con el buffer de las APIs de sqlite3_rebaser antes de volver.En este caso (*pnRebase)se establece el tamaño del buffer en bytes.Es responsabilidad del llamante liberar eventualmente dicho búfer utilizando sqlite3_free().El buffer sólo se asigna y se llena si se encuentran uno o más conflictos al aplicar el parche.Ver los comentarios sobre las APIs de sqlite3_rebaser para más detalles.</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">Si el parámetro es un valor positivo,las estructuras de árbol B sólo pueden fusionarse si se cumple una de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">Si el parámetro tiene un nombre,entonces su nombre aparece en P4.El valor de P4 es usado por sqlite3_bind_parameter_name().</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">Si el parámetro es negativo,y hay estructuras de árbol B en más de un nivel dentro del índice FTS,todas las estructuras de árbol B se asignan al mismo nivel antes de que se inicie la operación de fusión.Además,si el parámetro es negativo,no se respeta el valor de la opción de configuración de la fusión-tan sólo se pueden fusionar dos árboles B del mismo nivel.</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">Si los caminos se ordenan usando la secuencia de cotejo BINARIO,entonces las páginas de desbordamiento asociadas con una celda aparecerán antes en el orden de clasificación que su página hija:</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">Si el proceso que quiere escribir no puede obtener un candado RESERVADO,debe significar que otro proceso ya tiene un candado RESERVADO.En ese caso,el intento de escritura falla y devuelve SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">Si la devolución de la llamada de progreso vuelve a ser distinta de cero,la operación se interrumpe.Esta característica puede utilizarse para implementar un botón de &quot;Cancelar&quot; en un cuadro de diálogo de progreso de la interfaz gráfica de usuario.</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">Si la consulta contiene una cláusula ORDEN POR o una cláusula GRUPO POR o si la consulta utiliza la palabra clave DISTINTO,entonces es ventajoso seleccionar un camino a través del gráfico que hace que las filas aparezcan naturalmente en orden ordenado,de modo que no se requiera un paso de clasificación separado.La eliminación automática de las cláusulas ORDER BY puede suponer una gran diferencia de rendimiento,por lo que este es otro factor que debe considerarse en una implementación completa.</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">Si la consulta se completa sin incidentes,se devuelve SQLITE_OK.O,si se produce algún error antes de que la consulta se complete o sea abortada por la llamada,se devuelve un código de error SQLite.</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">Si la razón para escribir en el archivo de la base de datos es porque el caché de la memoria estaba lleno,entonces el escritor no se comprometerá de inmediato.En su lugar,el escritor podría continuar haciendo cambios en otras páginas.Antes de que los cambios subsiguientes se escriban en el archivo de la base de datos,el diario de retroceso debe ser descargado en el disco nuevamente.Observe también que el bloqueo EXCLUSIVO que el escritor obtuvo para escribir en la base de datos inicialmente debe mantenerse hasta que se confirmen todos los cambios.Esto significa que ningún otro proceso puede acceder a la base de datos desde el momento en que la memoria caché se vierte por primera vez en el disco hasta que se confirma la transacción.</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">Si el registro contiene menos campos que P2,entonces extraiga un NULL.O,si el argumento P4 es un P4_MEM usa el valor del argumento P4 como resultado.</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">Si el esquema de la base de datos recuperada ya contiene una tabla llamada &quot;lost_and_found&quot;,el comando &quot;.recover&quot; utiliza el nombre &quot;lost_and_found0&quot;.Si el nombre &quot;perdido_y_encontrado0&quot; también está ya tomado,&quot;perdido_y_encontrado1&quot;,y así sucesivamente.El nombre por defecto &quot;perdido_y_encontrado&quot; puede ser anulado invocando &quot;.recover&quot; con el interruptor --perdido-y-encontrado.Por ejemplo,para que el script de salida llame a la tabla &quot;orphaned_rows&quot;:</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">Si la página solicitada ya está en el caché de páginas,entonces la implementación del caché de páginas debe devolver un puntero al búfer de la página con su contenido intacto.Si la página solicitada no está ya en el caché,entonces la implementación del caché debe utilizar el valor del parámetro createFlag para ayudar a determinar qué acción tomar:</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">Si el resultado es una cadena BLOB o UTF-16, entonces la rutina sqlite3_column_bytes16 () devuelve el n&amp;uacute;mero de bytes en ese BLOB o cadena. Si el resultado es una cadena UTF-8, entonces sqlite3_column_bytes16 () convierte la cadena a UTF-16 y luego devuelve el n&amp;uacute;mero de bytes. Si el resultado es un valor num&amp;eacute;rico, entonces sqlite3_column_bytes16 () usa &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; para convertir ese valor en una cadena UTF-16 y devuelve el n&amp;uacute;mero de bytes en esa cadena. Si el resultado es NULL, entonces sqlite3_column_bytes16 () devuelve cero.</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">Si el resultado es una cadena BLOB o UTF-16, entonces la rutina sqlite3_column_bytes16 () devuelve el n&amp;uacute;mero de bytes en ese BLOB o cadena. Si el resultado es una cadena UTF-8, entonces sqlite3_column_bytes16 () convierte la cadena a UTF-16 y luego devuelve el n&amp;uacute;mero de bytes. Si el resultado es un valor num&amp;eacute;rico, entonces sqlite3_column_bytes16 () usa &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; para convertir ese valor en una cadena UTF-16 y devuelve el n&amp;uacute;mero de bytes en esa cadena. Si el resultado es NULL, entonces sqlite3_column_bytes16 () devuelve cero.</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">Si el resultado es una cadena BLOB o UTF-8, la rutina sqlite3_column_bytes () devuelve el n&amp;uacute;mero de bytes en ese BLOB o cadena. Si el resultado es una cadena UTF-16, entonces sqlite3_column_bytes () convierte la cadena a UTF-8 y luego devuelve el n&amp;uacute;mero de bytes. Si el resultado es un valor num&amp;eacute;rico, entonces sqlite3_column_bytes () usa &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; para convertir ese valor en una cadena UTF-8 y devuelve el n&amp;uacute;mero de bytes en esa cadena. Si el resultado es NULL, entonces sqlite3_column_bytes () devuelve cero.</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">Si el resultado es una cadena BLOB o UTF-8, la rutina sqlite3_column_bytes () devuelve el n&amp;uacute;mero de bytes en ese BLOB o cadena. Si el resultado es una cadena UTF-16, entonces sqlite3_column_bytes () convierte la cadena a UTF-8 y luego devuelve el n&amp;uacute;mero de bytes. Si el resultado es un valor num&amp;eacute;rico, entonces sqlite3_column_bytes () usa &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; para convertir ese valor en una cadena UTF-8 y devuelve el n&amp;uacute;mero de bytes en esa cadena. Si el resultado es NULL, entonces sqlite3_column_bytes () devuelve cero.</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">Si el resultado es una cadena de BLOB o TEXTO,entonces las interfaces sqlite3_column_bytes()o sqlite3_column_bytes16()pueden ser usadas para determinar el tamaño de esa BLOB o cadena.</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">Si el resultado es una expresión general,y no sólo el nombre de una columna de la tabla de origen,entonces el nombre del resultado es una copia del texto de la expresión.</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">Si el conjunto de resultados de una consulta est&amp;aacute; vac&amp;iacute;o, entonces, de forma predeterminada, &lt;b&gt;sqlite_get_table&lt;/b&gt; establecer&amp;aacute; nrow en 0 y dejar&amp;aacute; que su par&amp;aacute;metro de resultado se establezca en NULL. Pero si el pragma EMPTY_RESULT_CALLBACKS est&amp;aacute; en ON, el par&amp;aacute;metro de resultado se inicializa solo con los nombres de las columnas. Por ejemplo, considere esta consulta que tiene un conjunto de resultados vac&amp;iacute;o:</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">Si el lado derecho de un operador IN puede ser una lista de valores como en el siguiente:</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">Si la fila proviene de una tabla SIN RUMBO,esta columna contiene NULL.De lo contrario,contiene el valor rowid entero de 64 bits para la fila.</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">Si la fila a la que apunta un identificador BLOB es modificada por un &lt;a href=&quot;../lang_update&quot;&gt;ACTUALIZAR&lt;/a&gt; , &lt;a href=&quot;../lang_delete&quot;&gt;ELIMINAR&lt;/a&gt; o por efectos secundarios &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; , el identificador BLOB se marca como &quot;caducado&quot;. Esto es cierto si se cambia cualquier columna de la fila, incluso una columna que no sea aquella en la que est&amp;aacute; abierto el identificador BLOB. Las llamadas a &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; y &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; para un identificador BLOB caducado fallan con un c&amp;oacute;digo de retorno de &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; . Los cambios escritos en un BLOB antes de la expiraci&amp;oacute;n del BLOB no se revierten al expirar el BLOB. Estos cambios eventualmente se confirmar&amp;aacute;n si la transacci&amp;oacute;n contin&amp;uacute;a hasta completarse.</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">Si la fila a la que apunta un identificador BLOB es modificada por un &lt;a href=&quot;lang_update&quot;&gt;ACTUALIZAR&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;ELIMINAR&lt;/a&gt; o por efectos secundarios &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; , el identificador BLOB se marca como &quot;caducado&quot;. Esto es cierto si se cambia cualquier columna de la fila, incluso una columna que no sea aquella en la que est&amp;aacute; abierto el identificador BLOB. Las llamadas a &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; y &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; para un identificador BLOB caducado fallan con un c&amp;oacute;digo de retorno de &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; . Los cambios escritos en un BLOB antes de la expiraci&amp;oacute;n del BLOB no se revierten al expirar el BLOB. Estos cambios eventualmente se confirmar&amp;aacute;n si la transacci&amp;oacute;n contin&amp;uacute;a hasta completarse.</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">Si se lee y escribe la misma base de datos utilizando dos &lt;a href=&quot;c3ref/sqlite3&quot;&gt;conexiones de base de datos&lt;/a&gt; diferentes (dos objetos &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; diferentes devueltos por llamadas separadas a &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; ) y las dos conexiones de base de datos no tienen una &lt;a href=&quot;sharedcache&quot;&gt;cach&amp;eacute; compartida&lt;/a&gt; , entonces el lector solo puede ver el compromiso completo transacciones del escritor. Los cambios parciales del escritor que no se han comprometido son invisibles para el lector. Esto es cierto independientemente de si las dos conexiones de base de datos est&amp;aacute;n en el mismo hilo, en diferentes hilos del mismo proceso o en diferentes procesos. Este es el comportamiento habitual y esperado de los sistemas de bases de datos SQL.</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">Si el nombre del punto de guardado de un comando RELEASE no coincide con ningún punto de guardado que se encuentre actualmente en la pila de transacciones,entonces no se libera ningún punto de guardado,la base de datos no se modifica y el comando RELEASE devuelve un error.</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">Si el segundo par&amp;aacute;metro (zDbName) no coincide con el nombre de ning&amp;uacute;n archivo de base de datos abierto, se devuelve SQLITE_ERROR. Este c&amp;oacute;digo de error no se recuerda y no ser&amp;aacute; recuperado por &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; . El m&amp;eacute;todo xFileControl subyacente tambi&amp;eacute;n puede devolver SQLITE_ERROR. No hay forma de distinguir entre un zDbName incorrecto y un retorno SQLITE_ERROR del m&amp;eacute;todo xFileControl subyacente.</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">Si el segundo par&amp;aacute;metro (zDbName) no coincide con el nombre de ning&amp;uacute;n archivo de base de datos abierto, se devuelve SQLITE_ERROR. Este c&amp;oacute;digo de error no se recuerda y no ser&amp;aacute; recuperado por &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; o &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; . El m&amp;eacute;todo xFileControl subyacente tambi&amp;eacute;n puede devolver SQLITE_ERROR. No hay forma de distinguir entre un zDbName incorrecto y un retorno SQLITE_ERROR del m&amp;eacute;todo xFileControl subyacente.</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">Si el tamaño de un archivo de diario potencialmente caliente se revela como mayor de cero bytes por una consulta requerida por H35450,entonces SQLite intentará actualizar el</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">Si el tamaño de un archivo de diario potencialmente caliente se revela como cero bytes por una consulta requerida por H35450,entonces SQLite cerrará el manejador de archivo abierto en el archivo de diario y eliminará el archivo de diario usando una llamada al método VFS xDelete().En este caso SQLite concluirá que no hay</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">Si el valor espec&amp;iacute;fico vinculado al &lt;a href=&quot;../lang_expr#varparam&quot;&gt;par&amp;aacute;metro de host&lt;/a&gt; en la cl&amp;aacute;usula WHERE puede influir en la elecci&amp;oacute;n del plan de consulta para una declaraci&amp;oacute;n, la declaraci&amp;oacute;n se volver&amp;aacute; a compilar autom&amp;aacute;ticamente, como si hubiera habido un cambio de esquema, en la primera llamada &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; despu&amp;eacute;s de cualquier cambio a los &lt;a href=&quot;bind_blob&quot;&gt;enlaces&lt;/a&gt; de ese &lt;a href=&quot;../lang_expr#varparam&quot;&gt;par&amp;aacute;metro&lt;/a&gt; . El valor espec&amp;iacute;fico del &lt;a href=&quot;../lang_expr#varparam&quot;&gt;par&amp;aacute;metro&lt;/a&gt; WHERE-clause puede influir en la elecci&amp;oacute;n del plan de consulta si el par&amp;aacute;metro es el lado izquierdo de un operador &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; o &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; o si el par&amp;aacute;metro se compara con una columna indexada y la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; est&amp;aacute; habilitada.</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">Si el valor espec&amp;iacute;fico vinculado al &lt;a href=&quot;lang_expr#varparam&quot;&gt;par&amp;aacute;metro de host&lt;/a&gt; en la cl&amp;aacute;usula WHERE puede influir en la elecci&amp;oacute;n del plan de consulta para una declaraci&amp;oacute;n, la declaraci&amp;oacute;n se volver&amp;aacute; a compilar autom&amp;aacute;ticamente, como si hubiera habido un cambio de esquema, en la primera llamada &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; despu&amp;eacute;s de cualquier cambio a los &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;enlaces&lt;/a&gt; de ese &lt;a href=&quot;lang_expr#varparam&quot;&gt;par&amp;aacute;metro&lt;/a&gt; . El valor espec&amp;iacute;fico del &lt;a href=&quot;lang_expr#varparam&quot;&gt;par&amp;aacute;metro&lt;/a&gt; WHERE-clause puede influir en la elecci&amp;oacute;n del plan de consulta si el par&amp;aacute;metro es el lado izquierdo de un operador &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; o &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; o si el par&amp;aacute;metro se compara con una columna indexada y la opci&amp;oacute;n de tiempo de compilaci&amp;oacute;n &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; est&amp;aacute; habilitada.</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">Si la columna especificada es &quot;rowid&quot;, &quot;oid&quot; o &quot;_rowid_&quot; y la tabla no es una tabla &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; y se ha declarado expl&amp;iacute;citamente una columna &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , los par&amp;aacute;metros de salida se establecen para la columna declarada expl&amp;iacute;citamente. Si no hay una columna &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , las salidas para el &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; se establecen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">Si la columna especificada es &quot;rowid&quot;, &quot;oid&quot; o &quot;_rowid_&quot; y la tabla no es una tabla &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; y se ha declarado expl&amp;iacute;citamente una columna &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , los par&amp;aacute;metros de salida se establecen para la columna declarada expl&amp;iacute;citamente. Si no hay una columna &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , las salidas para el &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; se establecen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">Si las funciones de compresión o descompresión especificadas no existen,la tabla todavía puede ser creada.No se devuelve un error hasta que se lee la tabla FTS4 (si la función de descompresión no existe)o se escribe (si es la función de compresión la que no existe).</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">Si la tabla especificada es en realidad una vista, se devuelve un &lt;a href=&quot;../rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">Si la tabla especificada es en realidad una vista, se devuelve un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">Si el valor especificado es un entero (o un texto que parece un entero),se inserta al pie de la letra.Si el valor no es un modo UNIX válido,algunos programas pueden comportarse de forma inesperada al extraer archivos del archivo.</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">Si no se puede encontrar la vista especificada y la cláusula IF EXISTS no está presente,es un error.Si no se puede encontrar la vista especificada y la cláusula IF EXISTS está presente en la declaración DROP VIEW,entonces la declaración es un no-op.</target>
        </trans-unit>
        <trans-unit id="969d1886dea91ce69d33e9942c74c8365291e28d" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it might return true if the column is being fetched as part of an UPDATE operation during which the column value will not change. The virtual table implementation can use this hint as permission to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">Si se llama a la rutina sqlite3_vtab_nochange (X) dentro del m&amp;eacute;todo &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; de una &lt;a href=&quot;../vtab&quot;&gt;tabla virtual&lt;/a&gt; , devuelve verdadero si y solo si la columna se est&amp;aacute; recuperando como parte de una operaci&amp;oacute;n UPDATE durante la cual el valor de la columna no cambiar&amp;aacute;. Las aplicaciones pueden usar esto para sustituir un valor de retorno que es menos costoso de calcular y que el m&amp;eacute;todo &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; correspondiente entiende como un valor &quot;sin cambios&quot;.</target>
        </trans-unit>
        <trans-unit id="d0558f9621b3961678e1c8ba8bcf516d2187f206" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it might return true if the column is being fetched as part of an UPDATE operation during which the column value will not change. The virtual table implementation can use this hint as permission to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">Si se llama a la rutina sqlite3_vtab_nochange (X) dentro del m&amp;eacute;todo &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; de una &lt;a href=&quot;vtab&quot;&gt;tabla virtual&lt;/a&gt; , devuelve verdadero si y solo si la columna se est&amp;aacute; recuperando como parte de una operaci&amp;oacute;n UPDATE durante la cual el valor de la columna no cambiar&amp;aacute;. Las aplicaciones pueden usar esto para sustituir un valor de retorno que es menos costoso de calcular y que el m&amp;eacute;todo &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; correspondiente entiende como un valor &quot;sin cambios&quot;.</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">Si la columna sqlite_stat1.idx es NULL, entonces la columna sqlite_stat1.stat contiene un &amp;uacute;nico entero que es el n&amp;uacute;mero aproximado de filas en la tabla identificadas por sqlite_stat1.tbl. Si la columna sqlite_stat1.idx es la misma que la columna sqlite_stat1.tbl, entonces la tabla es una tabla &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; y el campo sqlite_stat1.stat contiene informaci&amp;oacute;n sobre el &amp;iacute;ndice btree que implementa la tabla WITHOUT ROWID.</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">Si la subconsulta es un SELECT compuesto,entonces</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">Si la subconsulta es una selección compuesta,entonces todos los términos del PEDIDO por cláusula del padre deben ser simples referencias a las columnas de la subconsulta.</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">Si la subconsulta es una selección compuesta,entonces no debe usar la cláusula ORDER BY.</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">Si la subconsulta es el operando correcto de un LEFT JOIN entonces</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">Si la subconsulta utiliza LIMITE,entonces la consulta externa puede no tener una cláusula DONDE.</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">Si la subconsulta utiliza LIMIT,entonces la consulta externa puede no ser DISTINTA.</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">Si la tabla tiene 32 o menos columnas,se obtiene un único número entero sin signo para cada frase de la consulta.El bit menos significativo del entero se fija si la frase aparece por lo menos una vez en la columna 0.El segundo bit menos significativo se fija si la frase aparece una o más veces en la columna 1.Y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">Si el cuadro tiene más de 32 columnas,se añade un número entero extra a la salida de cada frase por cada 32 columnas extra o parte de ellas.Los números enteros correspondientes a la misma frase se agrupan.Por ejemplo,si se consulta un cuadro con 45 columnas para dos frases,se obtienen 4 números enteros.El primero corresponde a la frase 0 y a las columnas 0-31 del cuadro.El segundo entero contiene datos para la frase 0 y las columnas 32-44,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">Si la tabla también es una tabla sin contenido,las APIs xInstCount,xInst,xPhraseFirst y xPhraseNext se comportan como si la fila actual no contuviera ninguna coincidencia de frases (es decir,xInstCount()devuelve 0).</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">Si la tabla también es una tabla sin contenido,las API de xPhraseFirstColumn y xPhraseNextColumn se comportan como si la fila actual no contuviera ninguna coincidencia de frases (es decir,xPhraseFirstColumn()establece el iterador en EOF).</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">Si las tablas no son compatibles,se devuelve SQLITE_SCHEMA.Si las tablas son compatibles pero no tienen ninguna columna de CLAVE PRIMARIA,no es un error pero no se añaden cambios al objeto de la sesión.Al igual que con otras API de sesión,las tablas sin CLAVE PRIMARIA simplemente se ignoran.</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">Si la tabla de la base de datos de objetivos tiene una CLAVE PRIMARIA DE INTEGRACIÓN,no es posible insertar un valor NULL en la columna IPK.Al intentar hacerlo se produce un error SQLITE_MISMATCH.</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">Si la tabla de la base de datos de destino es una tabla virtual o una tabla que no tiene declaraci&amp;oacute;n PRIMARY KEY, la tabla data_% tambi&amp;eacute;n debe contener una columna llamada &quot;rbu_rowid&quot;. La columna rbu_rowid se asigna a las tablas &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; . Por ejemplo, si la base de datos de destino contiene alguno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">Si la tabla de la base de datos de destino es una tabla virtual o una tabla sin CLAVE PRIMARIA,el valor de rbu_control no debe incluir un carácter correspondiente al valor de rbu_rowid.Por ejemplo,esto:</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">Si el fragmento de texto no comienza al principio de un valor de columna,el texto de las &quot;elipses&quot; se le precede.</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">Si el fragmento de texto no termina al final de un valor de columna,se le añade el texto &quot;elipses&quot;.</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">Si el tercer parámetro (el puntero al objeto sqlite3_module)es NULL entonces no se crea ningún módulo nuevo y se eliminan los módulos existentes con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">Si las dos manijas de las instantáneas no están asociadas al mismo archivo de la base de datos,el resultado de la comparación es indefinido.</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">Si el valor N est&amp;aacute; fuera de rango o si el par&amp;aacute;metro N-&amp;eacute;simo no tiene nombre, se devuelve NULL. La cadena devuelta siempre est&amp;aacute; en codificaci&amp;oacute;n UTF-8 incluso si el par&amp;aacute;metro nombrado se especific&amp;oacute; originalmente como UTF-16 en &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">Si el valor N est&amp;aacute; fuera de rango o si el par&amp;aacute;metro N-&amp;eacute;simo no tiene nombre, se devuelve NULL. La cadena devuelta siempre est&amp;aacute; en codificaci&amp;oacute;n UTF-8 incluso si el par&amp;aacute;metro nombrado se especific&amp;oacute; originalmente como UTF-16 en &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; o &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">Si el valor que se sustituye es mayor que la anchura,entonces se añade el valor completo a la salida.En otras palabras,la anchura es la anchura mínima del valor tal y como se representa en la salida.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">Si el valor de</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">Si el valor de un par de ruta / valor es un valor de TEXTO de SQLite, entonces normalmente se inserta como una cadena JSON entre comillas, incluso si la cadena parece un JSON v&amp;aacute;lido. Sin embargo, si el valor es el resultado de otra funci&amp;oacute;n json1 (como &lt;a href=&quot;json1#jmini&quot;&gt;json ()&lt;/a&gt; o &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()&lt;/a&gt; o &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()&lt;/a&gt; ), entonces se interpreta como JSON y se inserta como JSON conservando toda su subestructura.</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">Si el valor de la variable zString es NULL,el SQL generado tendrá el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">Si los valores &quot;insertados&quot; en las columnas de texto como parte de un comando de &quot;borrar&quot; no son los mismos que los almacenados actualmente en la tabla,los resultados pueden ser impredecibles.</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">Si la variable no tiene una representación de bytearray,entonces &quot;@&quot; funciona igual que &quot;$&quot;.Note que &quot;:&quot; funciona como &quot;$&quot; en todos los casos,así que la siguiente es otra forma de expresar la misma declaración:</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">Si la m&amp;aacute;quina virtual no puede abrir el archivo de base de datos porque est&amp;aacute; bloqueado por otro hilo o proceso, &lt;b&gt;sqlite_step&lt;/b&gt; devolver&amp;aacute; SQLITE_BUSY. La funci&amp;oacute;n de llamada debe realizar alguna otra actividad, o dormir, durante un corto per&amp;iacute;odo de tiempo para que el bloqueo &lt;b&gt;tenga la&lt;/b&gt; oportunidad de &lt;b&gt;borrarse&lt;/b&gt; , luego invocar &lt;b&gt;sqlite_step&lt;/b&gt; nuevamente. Esto se puede repetir tantas veces como se desee.</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">Si la tabla virtual contiene una o m&amp;aacute;s filas que coinciden con los criterios de b&amp;uacute;squeda, entonces el cursor debe apuntar a la izquierda en la primera fila. Las llamadas posteriores a &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; deben devolver falso (cero). Si no hay filas coincidentes, entonces el cursor debe dejarse en un estado que har&amp;aacute; que &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; devuelva verdadero (distinto de cero). El motor SQLite utilizar&amp;aacute; los m&amp;eacute;todos &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; y &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; para acceder al contenido de esa fila. El m&amp;eacute;todo &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; se utilizar&amp;aacute; para avanzar a la siguiente fila.</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">Si la tabla virtual dará salida a las filas en el orden especificado por la cláusula ORDER BY,entonces el indicador orderByConsumed puede ser puesto en true.Si la salida no está automáticamente en el orden correcto,entonces orderByConsumed debe dejarse en su configuración predeterminada falsa.Esto indicará al núcleo de SQLite que tendrá que hacer una pasada de clasificación separada sobre los datos después de que salgan de la tabla virtual.</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">Si la anchura es un solo carácter &quot;*&quot; en lugar de un número,entonces el valor de la anchura real se lee como un número entero de la lista de argumentos.Si el valor leído es negativo,entonces se utiliza el valor absoluto para la anchura y el valor se justifica a la izquierda como si la bandera &quot;-&quot; estuviera presente.</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">Si la consulta xAccess()requerida por H35490 revela que el archivo de diario está todavía presente en el sistema de archivos,entonces SQLite concluirá que el archivo de diario es un</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">Si la implementación del método xColumn no llama a ninguna de las funciones anteriores,entonces el valor de la columna por defecto es un SQL NULL.</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">Si se omite el m&amp;eacute;todo xCreate (se deja como un puntero NULL), entonces la tabla virtual es una &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;tabla virtual del mismo nombre&lt;/a&gt; . No se pueden crear nuevas instancias de la tabla virtual usando &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; y la tabla virtual solo se puede usar a trav&amp;eacute;s de su nombre de m&amp;oacute;dulo. Tenga en cuenta que las versiones de SQLite anteriores a 3.9.0 (2015-10-14) no comprenden las tablas virtuales que solo tienen el mismo nombre y generar&amp;aacute;n una segregaci&amp;oacute;n si se intenta &lt;a href=&quot;lang_createvtab&quot;&gt;CREAR TABLA VIRTUAL&lt;/a&gt; en una tabla virtual que solo tiene el mismo nombre porque el m&amp;eacute;todo xCreate no se verific&amp;oacute; para nulo.</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">Si el m&amp;eacute;todo xCreate es exactamente el mismo puntero que el m&amp;eacute;todo &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; , eso indica que la tabla virtual no necesita inicializar el almacenamiento de respaldo. Dicha tabla virtual se puede usar como una &lt;a href=&quot;vtab#epovtab&quot;&gt;tabla virtual del mismo nombre&lt;/a&gt; o como una tabla virtual con nombre usando &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; o ambos.</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">Si la rutina xEntryPoint encuentra un error, deber&amp;iacute;a hacer que * pzErrMsg apunte a un mensaje de error apropiado (obtenido de &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; ) y devolver un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; apropiado . SQLite asegura que * pzErrMsg sea NULL antes de llamar al xEntryPoint (). SQLite invocar&amp;aacute; &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; en * pzErrMsg despu&amp;eacute;s de que xEntryPoint () regrese. Si cualquier xEntryPoint () devuelve un error, la llamada &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; o &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; que provoc&amp;oacute; el xEntryPoint () fallar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">Si la rutina xEntryPoint encuentra un error, deber&amp;iacute;a hacer que * pzErrMsg apunte a un mensaje de error apropiado (obtenido de &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; ) y devolver un &lt;a href=&quot;../rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; apropiado . SQLite asegura que * pzErrMsg sea NULL antes de llamar al xEntryPoint (). SQLite invocar&amp;aacute; &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; en * pzErrMsg despu&amp;eacute;s de que xEntryPoint () regrese. Si cualquier xEntryPoint () devuelve un error, la llamada &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; o &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; que provoc&amp;oacute; el xEntryPoint () fallar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">Si el m&amp;eacute;todo xUpdate est&amp;aacute; realizando una ACTUALIZACI&amp;Oacute;N, entonces &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; se puede utilizar para descubrir qu&amp;eacute; columnas de la tabla virtual fueron realmente modificadas por la instrucci&amp;oacute;n UPDATE. La interfaz &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; devuelve verdadero para las columnas que no cambian. En cada ACTUALIZACI&amp;Oacute;N, SQLite primero invocar&amp;aacute; &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; por separado para cada columna invariable en la tabla para obtener el valor de esa columna. El m&amp;eacute;todo &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; puede verificar si la columna no ha cambiado en el nivel de SQL invocando &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; . Si &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; ve que la columna no se est&amp;aacute; modificando, deber&amp;iacute;a regresar sin establecer un resultado usando uno de los &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt;interfaces. Solo en ese caso &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; ser&amp;aacute; verdadero dentro del m&amp;eacute;todo xUpdate. Si &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; invoca una o m&amp;aacute;s interfaces &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt; , entonces SQLite entiende eso como un cambio en el valor de la columna y la llamada &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; para esa columna dentro de xUpdate devolver&amp;aacute; falso.</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Si el m&amp;eacute;todo xUpdate viola alguna restricci&amp;oacute;n de la tabla virtual (incluido, entre otros, intentar almacenar un valor del tipo de datos incorrecto, intentar almacenar un valor que es demasiado grande o demasiado peque&amp;ntilde;o, o intentar cambiar un valor de solo lectura value), entonces xUpdate debe fallar con un &lt;a href=&quot;rescode&quot;&gt;c&amp;oacute;digo de error&lt;/a&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">Si la variable zString contiene un texto como &quot;Hola&quot;,entonces esta declaración funcionará bien.Pero supongamos que el usuario introduce una cadena como &quot;¡Hola a todos!&quot;.La sentencia SQL generada dice lo siguiente:</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">Si hay muchos programas cliente que envían SQL a la misma base de datos a través de una red,entonces utilice un motor de base de datos cliente/servidor en lugar de SQLite.SQLite funcionará sobre un sistema de archivos de red,pero debido a la latencia asociada a la mayoría de los sistemas de archivos de red,el rendimiento no será grande.Además,la lógica de bloqueo de archivos tiene fallos en muchas implementaciones de sistemas de archivos en red (tanto en Unix como en Windows).Si el bloqueo de archivos no funciona correctamente,dos o más clientes pueden intentar modificar la misma parte de la misma base de datos al mismo tiempo,lo que da lugar a la corrupción.Dado que este problema se debe a errores en la implementación del sistema de archivos subyacente,no hay nada que SQLite pueda hacer para evitarlo.</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">Si hay múltiples enlaces (duros o simbólicos)a un archivo de base de datos,el diario se creará utilizando el nombre del enlace a través del cual se abrió el archivo.Si se produce una caída y la base de datos se abre de nuevo utilizando un enlace diferente,el diario caliente no se localizará y no se producirá ningún retroceso.</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">Si a&amp;uacute;n hay m&amp;aacute;s p&amp;aacute;ginas para copiar de la base de datos pDb, la funci&amp;oacute;n duerme durante 250 milisegundos (usando la utilidad &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; ) y luego regresa al paso 2.</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">Si existe un índice que mapea la columna &quot;dos&quot; de la tabla &quot;examp&quot; en números enteros,entonces SQLite utilizará ese índice para encontrar las claves de números enteros de todas las filas en examp que tengan un valor de 50 para la columna dos,o todas las filas que sean menores de 50,etc.Pero las siguientes consultas no pueden utilizar el índice:</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">Si ha habido una o más resoluciones de REEMPLAZO en una llave,se vuelve a basar según un REEMPLAZO.</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">Si no ha habido resoluciones de REEMPLAZO en una clave,entonces el conjunto de cambios locales se basa en la más reciente de las resoluciones de la OMIT.</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">Si hay una cl&amp;aacute;usula USING, entonces cada uno de los nombres de columna especificados debe existir en los conjuntos de datos tanto a la izquierda como a la derecha del operador de combinaci&amp;oacute;n. Para cada par de columnas nombradas, la expresi&amp;oacute;n &quot;lhs.X = rhs.X&quot; se eval&amp;uacute;a para cada fila del producto cartesiano como una &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana&lt;/a&gt; . Solo las filas para las que todas estas expresiones se eval&amp;uacute;an como verdaderas se incluyen en el conjunto de resultados. Al comparar valores como resultado de una cl&amp;aacute;usula USING, se aplican las reglas normales para manejar afinidades, secuencias de clasificaci&amp;oacute;n y valores NULL en las comparaciones. La columna del conjunto de datos en el lado izquierdo del operador de combinaci&amp;oacute;n se considera que est&amp;aacute; en el lado izquierdo del operador de comparaci&amp;oacute;n (=) a los efectos de la secuencia de clasificaci&amp;oacute;n y la precedencia de afinidad.</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">Si ya hay una transacción de lectura abierta cuando se invoca esta función,entonces la misma transacción de lectura permanece abierta (en la misma instantánea de la base de datos)si se devuelve SQLITE_ERROR,SQLITE_BUSY o SQLITE_ERROR_SNAPSHOT.Si se devuelve otro código de error -por ejemplo,SQLITE_PROTOCOL o un código de error SQLITE_IOERR-,entonces el estado final de la transacción de lectura es indefinido.Si se devuelve SQLITE_OK,entonces la transacción de lectura está ahora abierta en la instantánea P de la base de datos.</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">Si ya existe un puntero de datos auxiliar cuando se invoca esta función,entonces se sustituye por el nuevo puntero.Si se especificó una llamada xDelete junto con el puntero original,se invoca en este punto.</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">Si hay una cláusula AS en el resultado,entonces el nombre de la columna es el lado derecho de la cláusula AS.</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">Si hay una cl&amp;aacute;usula ON, la expresi&amp;oacute;n ON se eval&amp;uacute;a para cada fila del producto cartesiano como una &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;expresi&amp;oacute;n booleana&lt;/a&gt; . Solo las filas para las que la expresi&amp;oacute;n se eval&amp;uacute;a como verdadera se incluyen en el conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">Si no hay una tabla compatible,no es un error,pero no se aplica ninguno de los cambios asociados a la tabla.Se emite un mensaje de advertencia a través del mecanismo sqlite3_log()con el código de error SQLITE_SCHEMA.Como máximo,se emite una advertencia de este tipo para cada tabla del conjunto de cambios.</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">Si no hay un índice llamado</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">Si no hay una tabla de autoprueba, el comando &quot;.selftest&quot; ejecuta &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA&lt;/a&gt; Integrity_check .</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">Si solo hay una sola tabla o subconsulta en la cl&amp;aacute;usula FROM, entonces los datos de entrada usados ​​por la instrucci&amp;oacute;n SELECT son el contenido de la tabla nombrada. Si hay m&amp;aacute;s de una tabla o subconsulta en la cl&amp;aacute;usula FROM, entonces el contenido de todas las tablas y / o subconsultas se unen en un solo conjunto de datos para que opere la instrucci&amp;oacute;n SELECT simple. Exactamente c&amp;oacute;mo se combinan los datos depende del &lt;a href=&quot;syntax/join-operator&quot;&gt;operador de combinaci&amp;oacute;n&lt;/a&gt; espec&amp;iacute;fico y &lt;a href=&quot;syntax/join-constraint&quot;&gt;de la restricci&amp;oacute;n de combinaci&amp;oacute;n que se&lt;/a&gt; usa para conectar las tablas o subconsultas.</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">Si estas rutinas se llaman desde dentro de un subproceso diferente al que contiene la funci&amp;oacute;n definida por la aplicaci&amp;oacute;n que recibi&amp;oacute; el puntero &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; , los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">Si estas rutinas se llaman desde dentro de un subproceso diferente al que contiene la funci&amp;oacute;n definida por la aplicaci&amp;oacute;n que recibi&amp;oacute; el puntero &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; , los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">Si esta macro del preprocesador C deshabilita la optimizaci&amp;oacute;n del &quot;token diferido&quot; en &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; . La optimizaci&amp;oacute;n del &quot;token diferido&quot; evita cargar listas de publicaci&amp;oacute;n masivas para los t&amp;eacute;rminos que se encuentran en la mayor&amp;iacute;a de los documentos de la colecci&amp;oacute;n y, en su lugar, simplemente busca esos tokens en la fuente del documento. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; deber&amp;iacute;a obtener exactamente la misma respuesta con y sin esta optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">Si esta macro de preprocesador C est&amp;aacute; definida y si el m&amp;eacute;todo xDeviceCharacteristics del objeto &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; para un archivo de base de datos informa (a trav&amp;eacute;s de uno de los bits &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; ) que el sistema de archivos admite escrituras at&amp;oacute;micas y si una transacci&amp;oacute;n implica un cambio en una sola p&amp;aacute;gina de la base de datos , luego la transacci&amp;oacute;n se confirma con una sola solicitud de escritura de una sola p&amp;aacute;gina de la base de datos y no se crea ni escribe ning&amp;uacute;n diario de reversi&amp;oacute;n. En sistemas de archivos que admiten escrituras at&amp;oacute;micas, esta optimizaci&amp;oacute;n puede resultar en importantes mejoras de velocidad para peque&amp;ntilde;as actualizaciones. Sin embargo, pocos sistemas de archivos admiten esta capacidad y las rutas de c&amp;oacute;digo que verifican esta capacidad ralentizan el rendimiento de escritura en sistemas que carecen de capacidad de escritura at&amp;oacute;mica, por lo que esta funci&amp;oacute;n est&amp;aacute; desactivada de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">Si se define esta macro del preprocesador C,se desactivan las sincronizaciones de directorios.SQLite suele intentar sincronizar el directorio principal cuando se elimina un archivo para asegurarse de que las entradas del directorio se actualizan inmediatamente en el disco.</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">Si se define esta macro del preprocesador C,se desactiva el soporte para archivos grandes.</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">Si se define esta macro C-preprocesador, el &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer en &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; se omite de la construcci&amp;oacute;n y no est&amp;aacute; disponible para las aplicaciones.</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">Si se define esta macro de preprocesador C, entonces se incluye c&amp;oacute;digo adicional que permite que SQLite funcione en un sistema de archivos que solo admite 8 + 3 nombres de archivo. Si el valor de esta macro es 1, entonces el comportamiento predeterminado es continuar usando nombres de archivo largos y usar solo 8 + 3 nombres de archivo si la conexi&amp;oacute;n de la base de datos se abre usando &lt;a href=&quot;uri&quot;&gt;nombres de archivo URI&lt;/a&gt; con el par&amp;aacute;metro de consulta &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;. Si el valor de esta macro es 2, entonces el uso de 8 + 3 nombres de archivo se convierte en el predeterminado, pero se puede deshabilitar al usar el par&amp;aacute;metro de consulta &lt;code&gt;8_3_names=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">Si este SELECT devuelve alguna fila,SQLite concluye que la eliminación de la fila de la tabla padre violaría la restricción de clave externa y devuelve un error.Se pueden ejecutar consultas similares si se modifica el contenido de la clave padre o se inserta una nueva fila en la tabla padre.Si estas consultas no pueden utilizar un índice,se ven obligadas a realizar un análisis lineal de toda la tabla hija.En una base de datos no trivial,esto puede resultar prohibitivo.</target>
        </trans-unit>
        <trans-unit id="1a76560d5f1317c75f52d66cf33f56778e31d3b4" translate="yes" xml:space="preserve">
          <source>If this expression returns a non-zero value N, then there exists an embedded NUL at the N-th character position. Thus to count the number fo rows that contain embedded NUL characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0db89932b716eb4d510a7bedc168db8c08402a" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with -DSQLITE_CKSUMVFS_STATIC and statically linked against the application, initialize it using a single API call as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">Si esta extensión se compila con el símbolo del pre-procesador SQLITE_ENABLE_ICU definido,entonces existe un tokenizador incorporado llamado &quot;icu&quot; implementado usando la biblioteca de la UCI.El primer argumento que se pasa al método xCreate()(véase fts3_tokenizer.h)de este tokenizador puede ser un identificador de locale ICU.Por ejemplo,&quot;tr_TR&quot; para el turco,como se utiliza en Turquía,o &quot;en_AU&quot; para el inglés,como se utiliza en Australia.Por ejemplo</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">Si se llama a esta función cuando el iterador no apunta a una entrada válida,se devuelve SQLITE_MISUSE y las variables de salida se ponen a cero.En caso contrario,se devuelve SQLITE_OK y las variables de salida se rellenan como se ha descrito anteriormente.</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">Si esta función necesita obtener bloqueos adicionales de la base de datos antes de que las páginas sucias puedan ser descargadas al disco,lo hace.Si esos bloqueos no pueden obtenerse inmediatamente y se configura una llamada de devolución de ocupado,se invoca de la manera habitual.Si aún así no se puede obtener el bloqueo necesario,se salta la base de datos y se intenta eliminar las páginas sucias pertenecientes a la siguiente base de datos (si la hay).Si se salta alguna base de datos porque no se pueden obtener bloqueos,pero no se produce ningún otro error,esta función devuelve SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">Si esta variable global se hace para apuntar a una cadena que es el nombre de una carpeta (tambi&amp;eacute;n conocido como directorio), entonces se asumir&amp;aacute; que todos los archivos de base de datos especificados con un nombre de ruta relativo y creados o accedidos por SQLite cuando se usa un &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS de&lt;/a&gt; Windows incorporado sea ​​relativo a ese directorio. Si esta variable es un puntero NULL, entonces SQLite asume que todos los archivos de base de datos especificados con un nombre de ruta relativo son relativos al directorio actual del proceso. S&amp;oacute;lo Windows VFS hace uso de esta variable global; es ignorado por el Unix VFS.</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">Si esta variable global se hace para apuntar a una cadena que es el nombre de una carpeta (tambi&amp;eacute;n conocido como directorio), entonces se asumir&amp;aacute; que todos los archivos de base de datos especificados con un nombre de ruta relativo y creados o accedidos por SQLite cuando se usa un &lt;a href=&quot;vfs&quot;&gt;VFS de&lt;/a&gt; Windows incorporado sea ​​relativo a ese directorio. Si esta variable es un puntero NULL, entonces SQLite asume que todos los archivos de base de datos especificados con un nombre de ruta relativo son relativos al directorio actual del proceso. S&amp;oacute;lo Windows VFS hace uso de esta variable global; es ignorado por el Unix VFS.</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">Si esta variable global est&amp;aacute; hecha para apuntar a una cadena que es el nombre de una carpeta (tambi&amp;eacute;n conocido como directorio), entonces todos los archivos temporales creados por SQLite cuando se usa un &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; incorporado se colocar&amp;aacute;n en ese directorio. Si esta variable es un puntero NULL, entonces SQLite realiza una b&amp;uacute;squeda de un directorio de archivos temporal apropiado.</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">Si esta variable global est&amp;aacute; hecha para apuntar a una cadena que es el nombre de una carpeta (tambi&amp;eacute;n conocido como directorio), entonces todos los archivos temporales creados por SQLite cuando se usa un &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; incorporado se colocar&amp;aacute;n en ese directorio. Si esta variable es un puntero NULL, entonces SQLite realiza una b&amp;uacute;squeda de un directorio de archivos temporal apropiado.</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">Si esta interfaz se invoca fuera del contexto de un método de tabla virtual xConnect o xCreate,entonces el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">Si esta macro se define como un número entero positivo</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">Si se define esta macro,entonces el &quot;$&quot; especial</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">Si se define esta opción,se omiten las funciones incorporadas de manipulación de fecha y hora de SQLite.En concreto,las funciones SQL julianday(),date(),time(),datetime()y strftime()no están disponibles.Los valores de columna predeterminados CURRENT_TIME,CURRENT_DATE y CURRENT_TIMESTAMP siguen estando disponibles.</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">Si se define esta opci&amp;oacute;n, la biblioteca no puede crear ni escribir en bases de datos que admitan &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; . La ejecuci&amp;oacute;n de una declaraci&amp;oacute;n de &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;vac&amp;iacute;o autom&amp;aacute;tico de PRAGMA&lt;/a&gt; no es un error (ya que los PRAGMA desconocidos se ignoran silenciosamente), pero no devuelve un valor ni modifica el indicador de vac&amp;iacute;o autom&amp;aacute;tico en el archivo de la base de datos. Si una biblioteca compilada con esta opci&amp;oacute;n abre una base de datos que admite vac&amp;iacute;o autom&amp;aacute;tico, se abre autom&amp;aacute;ticamente en modo de solo lectura.</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">Si se define esta opci&amp;oacute;n, no se reconoce la sintaxis de &lt;a href=&quot;foreignkeys&quot;&gt;restricci&amp;oacute;n de clave externa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; definida, tambi&amp;eacute;n debe definirse cuando se utiliza la herramienta del &lt;a href=&quot;lemon&quot;&gt;generador de analizador de Lemon&lt;/a&gt; para generar un archivo parse.c. Debido a esto, esta opci&amp;oacute;n solo se puede usar cuando la biblioteca se construye a partir de la fuente, no a partir de la &lt;a href=&quot;amalgamation&quot;&gt;fusi&amp;oacute;n&lt;/a&gt; o de la colecci&amp;oacute;n de archivos C preempaquetados proporcionados para plataformas que no son de tipo Unix en el sitio web.</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">Si esta opción está activada,entonces el asignador de memoria alloca()se utilizará en algunas situaciones en las que sea apropiado.Esto da como resultado un binario ligeramente más pequeño y más rápido.El SQLITE_USE_ALLOCA en tiempo de compilación sólo funciona,por supuesto,en sistemas que soporten alloca().</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">Si se pasa a esta opción un argumento distinto de cero,el comando &quot;.expert&quot; genera estadísticas de distribución de datos similares para todos los índices considerados,basadas en el PORCENTAJE de las filas actualmente almacenadas en cada tabla de la base de datos.En el caso de las bases de datos con distribuciones de datos inusuales,esto puede dar lugar a mejores recomendaciones de índices,en particular si la aplicación tiene la intención de ejecutar ANALYZE.</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; presente, SQLite usar&amp;aacute; la funci&amp;oacute;n isnan () de la biblioteca matem&amp;aacute;tica del sistema. Este es un alias para la opci&amp;oacute;n de configuraci&amp;oacute;n &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; presente, el operador &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; integrado distinguir&amp;aacute; entre may&amp;uacute;sculas y min&amp;uacute;sculas. Este mismo efecto se puede lograr en tiempo de ejecuci&amp;oacute;n usando el &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma case_sensitive_like&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">Si esta rutina no se ha llamado previamente o si la llamada anterior ten&amp;iacute;a N menor que uno o un puntero NULL para P, entonces el PRNG se siembra usando la aleatoriedad obtenida del m&amp;eacute;todo xRandomness del objeto &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; predeterminado . Si la llamada anterior a esta rutina ten&amp;iacute;a un N de 1 o m&amp;aacute;s y un P no NULL, entonces la pseudoaleatoriedad se genera internamente y sin recurrir al m&amp;eacute;todo &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness.</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">Si esta rutina no se ha llamado previamente o si la llamada anterior ten&amp;iacute;a N menor que uno o un puntero NULL para P, entonces el PRNG se siembra usando la aleatoriedad obtenida del m&amp;eacute;todo xRandomness del objeto &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; predeterminado . Si la llamada anterior a esta rutina ten&amp;iacute;a un N de 1 o m&amp;aacute;s y un P no NULL, entonces la pseudoaleatoriedad se genera internamente y sin recurrir al m&amp;eacute;todo &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness.</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">Si se devuelve este valor,cualquier cambio aplicado hasta el momento se deshace y la llamada a sqlite3changeset_apply()devuelve SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">Si el rastreo está habilitado (por la interfaz sqlite3_trace()),entonces la cadena UTF-8 contenida en P4 se emite en la llamada de rastreo.O si P4 está en blanco,utiliza la cadena devuelta por sqlite3_sql().</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">Si dos conexiones de base de datos comparten la misma cach&amp;eacute; y el lector ha habilitado el &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;pragma read_uncommitted&lt;/a&gt; , el lector podr&amp;aacute; ver los cambios realizados por el escritor antes de que se confirme la transacci&amp;oacute;n del escritor. El uso combinado del &lt;a href=&quot;sharedcache&quot;&gt;modo de cach&amp;eacute; compartida&lt;/a&gt; y el &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;pragma read_uncommitted&lt;/a&gt; es la &amp;uacute;nica forma en que una conexi&amp;oacute;n de base de datos puede ver los cambios no confirmados en una conexi&amp;oacute;n de base de datos diferente. En todas las dem&amp;aacute;s circunstancias, las conexiones de bases de datos independientes est&amp;aacute;n completamente aisladas entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">Si se necesitan dos o m&amp;aacute;s bases de datos en memoria distintas pero compartibles en un solo proceso, entonces el par&amp;aacute;metro de consulta &lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt; se puede usar con un &lt;a href=&quot;uri&quot;&gt;nombre&lt;/a&gt; de archivo URI para crear una base de datos en memoria con nombre:</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">Si dos o m&amp;aacute;s subprocesos llaman a una o m&amp;aacute;s &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;interfaces de metadatos de columna&lt;/a&gt; para la misma &lt;a href=&quot;#sqlite3_stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; y columna de resultado al mismo tiempo, los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">Si dos o m&amp;aacute;s subprocesos llaman a una o m&amp;aacute;s &lt;a href=&quot;column_database_name&quot;&gt;interfaces de metadatos de columna&lt;/a&gt; para la misma &lt;a href=&quot;stmt&quot;&gt;declaraci&amp;oacute;n preparada&lt;/a&gt; y columna de resultado al mismo tiempo, los resultados no est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">Si dos o más hilos llaman a una o más de estas rutinas contra la misma declaración y columna preparadas al mismo tiempo,entonces los resultados son indefinidos.</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">Si dos procesos tienen conexiones abiertas al mismo archivo de base de datos y un proceso cierra su conexión,desvincula el archivo,luego crea un nuevo archivo de base de datos en su lugar con el mismo nombre y vuelve a abrir el nuevo archivo,entonces los dos procesos estarán hablando con diferentes archivos de base de datos con el mismo nombre.(Obsérvese que esto sólo es posible en los sistemas tipo Posix y Posix que permiten desvincular un archivo mientras aún está abierto para su lectura y escritura.Windows no permite que esto ocurra).Dado que los diarios de retroceso y los archivos WAL se basan en el nombre del archivo de base de datos,los dos archivos de base de datos diferentes compartirán el mismo diario de retroceso o archivo WAL.Un rollback o recuperación para una de las bases de datos podría utilizar el contenido de la otra base de datos,lo que daría lugar a la corrupción.Un problema similar se produce si se cambia el nombre de un archivo de base de datos mientras se abre y se crea un nuevo archivo con el nombre antiguo.</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">Si utiliza los operadores COINCIDIR o =, la expresi&amp;oacute;n a la izquierda del operador COINCIDIR suele ser el nombre de la tabla FTS5 (la excepci&amp;oacute;n es cuando se &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;especifica un filtro de columna&lt;/a&gt; ). La expresi&amp;oacute;n de la derecha debe ser un valor de texto que especifique el t&amp;eacute;rmino a buscar. Para la sintaxis de la funci&amp;oacute;n con valores de tabla, el t&amp;eacute;rmino a buscar se especifica como el primer argumento de la tabla. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">Si se usa el compilador MinGW,la línea de comandos es ésta:</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">Si se utiliza el sistema de construcción basado en la amalgama autoconf,establecer la variable de entorno CPPFLAGS mientras se ejecuta el script 'configure' es una forma fácil de establecer estas macros.Por ejemplo,el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">Si cuando intentas cargar tu biblioteca recibes un mensaje de error que dice &quot;mach-o,pero arquitectura incorrecta&quot; entonces puede que necesites añadir las opciones de línea de comandos &quot;-arch i386&quot; o &quot;arch x86_64&quot; a gcc,dependiendo de cómo esté construida tu aplicación.</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">Si al tratar de detectar una</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">Si xBestIndex devuelve &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , eso no indica un error. M&amp;aacute;s bien, SQLITE_CONSTRAINT indica que la combinaci&amp;oacute;n particular de par&amp;aacute;metros de entrada especificada no debe usarse en el plan de consulta. El retorno SQLITE_CONSTRAINT es &amp;uacute;til para &lt;a href=&quot;vtab#tabfunc2&quot;&gt;funciones con valores&lt;/a&gt; de tabla que tienen par&amp;aacute;metros requeridos. Si el campo utilizable aConstraint []. Es falso para uno de los par&amp;aacute;metros requeridos, entonces el m&amp;eacute;todo xBestIndex deber&amp;iacute;a devolver SQLITE_CONSTRAINT.</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">Si xRead()devuelve SQLITE_IOERR_SHORT_READ también debe rellenar con ceros las partes no leídas del buffer.Un VFS que no rellena con ceros las lecturas cortas podría parecer que funciona.Sin embargo,si no se rellenan las lecturas cortas con ceros,se producirá una corrupción de la base de datos.</target>
        </trans-unit>
        <trans-unit id="406e06acbef99d386159c93608eee295bbb8911c" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; a string into a BLOB, then the entire length of the string is shown. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">Si abusa de la biblioteca al intentar llamar a &lt;b&gt;sqlite_step de manera&lt;/b&gt; inapropiada, intentar&amp;aacute; devolver SQLITE_MISUSE. Esto puede suceder si llama a sqlite_step () en la misma m&amp;aacute;quina virtual al mismo tiempo desde dos o m&amp;aacute;s subprocesos o si vuelve a llamar a sqlite_step () despu&amp;eacute;s de que devolvi&amp;oacute; SQLITE_DONE o SQLITE_ERROR o si pasa un puntero de m&amp;aacute;quina virtual no v&amp;aacute;lido a sqlite_step ( ). No debe depender del c&amp;oacute;digo de retorno SQLITE_MISUSE para indicar un error. Es posible que un uso indebido de la interfaz no se detecte y provoque un bloqueo del programa. SQLITE_MISUSE est&amp;aacute; dise&amp;ntilde;ado como una ayuda de depuraci&amp;oacute;n &amp;uacute;nicamente, para ayudarlo a detectar el uso incorrecto antes de un percance. No se garantiza que la l&amp;oacute;gica de detecci&amp;oacute;n de uso indebido funcione en todos los casos.</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">Si se añade el carácter &quot;*&quot; al final del patrón,entonces se realiza una búsqueda de prefijos.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">Si usted es un &quot;rústico&quot; y cree que el óxido ya cumple las condiciones previas mencionadas anteriormente,y que SQLite debería ser recodificado en óxido,entonces es bienvenido y se le anima a ponerse en contacto con los desarrolladores de SQLite en privado y argumentar su caso.</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">Si eres un usuario devoto de Git,todavía puedes acceder fácilmente a SQLite.Esta sección ofrece algunas sugerencias sobre cómo hacerlo.</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">Si usted es un usuario de SQLite que ha tropezado con alguna rareza de SQLite que no se menciona aquí,por favor envíenos un correo electrónico para que podamos documentar el problema.</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">Si utiliza archivos de origen separados,nombre todos los archivos de origen en lugar de sólo los dos archivos de origen de la amalgama.Una vez hecho esto,confirme los cambios como sigue:</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">Si elimina una gran cantidad de datos y desea reducir el archivo de la base de datos, ejecute el comando &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . VACUUM reconstruir&amp;aacute; la base de datos desde cero. Esto dejar&amp;aacute; la base de datos con una lista libre vac&amp;iacute;a y un archivo de tama&amp;ntilde;o m&amp;iacute;nimo. Sin embargo, tenga en cuenta que VACUUM puede tardar un tiempo en ejecutarse y puede utilizar hasta el doble de espacio temporal en disco que el archivo original mientras se est&amp;aacute; ejecutando.</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">Si borra el</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">Si no tiene una copia de seguridad, la recuperaci&amp;oacute;n es muy dif&amp;iacute;cil. Es posible que pueda encontrar datos de cadenas parciales en un volcado binario del archivo de base de datos sin procesar. La recuperaci&amp;oacute;n de datos num&amp;eacute;ricos tambi&amp;eacute;n podr&amp;iacute;a ser posible con herramientas especiales, aunque hasta donde sabemos no existen tales herramientas. SQLite a veces se compila con la opci&amp;oacute;n &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; que sobrescribe todo el contenido eliminado con ceros. Si ese es el caso, la recuperaci&amp;oacute;n es claramente imposible. La recuperaci&amp;oacute;n tambi&amp;eacute;n es imposible si ha ejecutado &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; desde que se eliminaron los datos. Si no se utiliza SQLITE_SECURE_DELETE y no se ha ejecutado VACUUM, es posible que parte del contenido eliminado todav&amp;iacute;a est&amp;eacute; en el archivo de la base de datos, en &amp;aacute;reas marcadas para su reutilizaci&amp;oacute;n. Pero, nuevamente, no existen procedimientos o herramientas que conozcamos para ayudarlo a recuperar esos datos.</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">Si no quieres usar tu navegador de Internet para ver el nuevo check-in,puedes obtener alguna información desde la línea de comandos usando comandos como estos:</target>
        </trans-unit>
        <trans-unit id="165e1548a7d4a581b8c9984a9f7ab5cdc62be5bb" translate="yes" xml:space="preserve">
          <source>If you do this immediately after creating a new database file, before anything else has been written into the file, then that might be all that you need to do. Otherwise, the API call above should be followed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">Si cree que necesita cadenas de tipo puntero dinámico en su aplicación,es un fuerte indicador de que está haciendo un mal uso de la interfaz de paso de puntero.El uso que se pretende hacer puede ser inseguro.Por favor,reconsidere su diseño.Determine si realmente necesita pasar punteros a través de SQL en primer lugar.O tal vez encuentre un mecanismo diferente a las interfaces de paso de punteros descritas en este artículo.</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">Si encuentra errores en la documentaci&amp;oacute;n o en el c&amp;oacute;digo, no dude en corregirlos y / o ponerse en contacto con el autor en &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt; . Sus correcciones de errores o sugerencias siempre son bienvenidas.</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">Si tiene una copia de seguridad de su archivo de la base de datos,recupere la información de su copia de seguridad.</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">Si tienes una base de datos de grandes BLOBs,¿obtienes un mejor rendimiento de lectura cuando guardas el contenido completo de la BLOB directamente en la base de datos o es más rápido guardar cada BLOB en un archivo separado y almacenar sólo el nombre de archivo correspondiente en la base de datos?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">Si tienes un script y quieres empezar a depurar en algún momento a mitad de camino de ese script,simplemente establece un punto de interrupción en gdb (o cualquier depurador que estés usando)en la función test_breakpoint(),y añade un comando &quot;.breakpoint&quot; donde quieras detenerte.Cuando alcance ese primer punto de interrupción,establezca cualquier punto de interrupción adicional que sean trazas variables que necesite.</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">Si ha hecho alguna programación en lenguaje ensamblador o ha trabajado con algún tipo de máquina abstracta antes,todos estos detalles deberían resultarle familiares.Así que vamos a saltar a la derecha y empezar a buscar como un código.</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">Si tiene la intenci&amp;oacute;n de utilizar esta tabla virtual en cooperaci&amp;oacute;n con una tabla &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; (para la correcci&amp;oacute;n ortogr&amp;aacute;fica de los t&amp;eacute;rminos de b&amp;uacute;squeda), entonces puede extraer el vocabulario usando una tabla &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">Si ha realizado cambios de terminación de línea de NL a CR-NL o cambios de espacio de tabulación en la línea de base original,realice los mismos cambios en el nuevo archivo de origen.</target>
        </trans-unit>
        <trans-unit id="6938d0165858c470278846efb2784fece3e6d115" translate="yes" xml:space="preserve">
          <source>If you need an exact answer, you should not use binary64 floating-point values, in SQLite or in any other product. This is not an SQLite limitation. It is a mathematical limitation inherent in the design of floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">Si necesita verificar que el código fuente de SQLite que tiene es auténtico y no ha sido modificado de ninguna manera (quizás por un adversario),puede hacerlo utilizando unas pocas y simples herramientas de línea de comandos.En la raíz del árbol de código fuente de SQLite hay un archivo llamado &quot;manifest&quot;.El archivo manifiesto contiene el nombre de todos los demás archivos del árbol de fuentes junto con un hash SHA1 o SHA3-256 para ese archivo.(SHA1 se usa para los archivos más antiguos y SHA3-256 para los más nuevos.)Puedes escribir un script para extraer estos hashes y verificarlos con los archivos de código fuente.El nombre del hash para la verificación es sólo el hash SHA3-256 del propio archivo &quot;manifiesto&quot;.</target>
        </trans-unit>
        <trans-unit id="a95dfc6dc355d4bcfc654c806aedf507385d37e3" translate="yes" xml:space="preserve">
          <source>If you notice new CVEs associated with SQLite that are not in the table below, please bring them to the attention of the developers on the &lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLite Forum&lt;/a&gt; so they can be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df7ef5af012df18a05531f4528bcf648f59acb3" translate="yes" xml:space="preserve">
          <source>If you remember nothing else about floating-point values, please don't forget this one key idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">Si se especifica un ancho de columna de 0,entonces el ancho de la columna se ajusta automáticamente para que sea el máximo de tres números:10,el ancho del encabezado y el ancho de la primera fila de datos.Esto hace que el ancho de la columna se ajuste automáticamente.El ajuste de ancho por defecto para cada columna es este valor de autoajuste 0.</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">Si usa la versi&amp;oacute;n 2.6.0 o posterior de la biblioteca para abrir un archivo de base de datos que fue creado originalmente por la versi&amp;oacute;n 2.5.6 o anterior, un intento de reconstruir la base de datos en el nuevo formato ocurrir&amp;aacute; autom&amp;aacute;ticamente. Esto puede llevar alg&amp;uacute;n tiempo para una base de datos grande. (Deje 1 o 2 segundos por megabyte de base de datos en Unix; m&amp;aacute;s tiempo en Windows). Esta conversi&amp;oacute;n de formato es irreversible. Se &lt;strong&gt;recomienda encarecidamente&lt;/strong&gt; que haga una copia de seguridad de los archivos de base de datos m&amp;aacute;s antiguos antes de abrirlos con la versi&amp;oacute;n 2.6.0 o posterior de la biblioteca, en caso de que haya errores en la l&amp;oacute;gica de conversi&amp;oacute;n de formato.</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">Si quieres configurar el nuevo proyecto,escribe:</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">Si desea saber c&amp;oacute;mo funciona internamente la biblioteca SQLite, debe comenzar con un conocimiento s&amp;oacute;lido del motor de base de datos virtual o VDBE. El VDBE ocurre justo en el medio del flujo de procesamiento (vea el &lt;a href=&quot;arch&quot;&gt;diagrama de arquitectura&lt;/a&gt; ) y por eso parece tocar la mayor&amp;iacute;a de las partes de la biblioteca. Incluso las partes del c&amp;oacute;digo que no interact&amp;uacute;an directamente con el VDBE suelen desempe&amp;ntilde;ar una funci&amp;oacute;n de apoyo. El VDBE es realmente el coraz&amp;oacute;n de SQLite.</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">Si quieres usar una palabra clave como nombre,tienes que citarla.Hay cuatro formas de citar palabras clave en SQLite:</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Si va a abrir m&amp;uacute;ltiples conexiones de base de datos en su aplicaci&amp;oacute;n, en lugar de invocar los puntos de entrada de extensi&amp;oacute;n para cada conexi&amp;oacute;n de base de datos por separado, es posible que desee considerar el uso de la interfaz &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; para registrar sus extensiones y hacer que se inicien autom&amp;aacute;ticamente como cada Se abre la conexi&amp;oacute;n a la base de datos. Solo tiene que registrar cada extensi&amp;oacute;n una vez, y puede hacerlo cerca del comienzo de su rutina main (). El uso de la interfaz &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; para registrar sus extensiones hace que sus extensiones funcionen como si estuvieran integradas en el SQLite principal: existen autom&amp;aacute;ticamente cada vez que abre una nueva conexi&amp;oacute;n de base de datos sin necesidad de inicializarlas. Solo aseg&amp;uacute;rese de completar cualquier configuraci&amp;oacute;n que necesite realizar utilizando&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; antes de registrar sus extensiones, ya que el &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; interfaz llama impl&amp;iacute;citamente &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">Si sus datos crecerán hasta un tamaño que le resulte incómodo o que no quepa en un solo archivo de disco,entonces debería seleccionar una solución distinta a SQLite.SQLite admite bases de datos de hasta 140 terabytes de tamaño,suponiendo que pueda encontrar una unidad de disco y un sistema de archivos que admita archivos de 140 terabytes.Aun así,cuando el tamaño del contenido parezca que puede entrar en el rango de los terabytes,sería bueno considerar una base de datos cliente/servidor centralizada.</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">Si su sistema define una interfaz de sistema operativo personalizada para SQLite o si estaba usando &lt;b&gt;sqlite3_os_switch () sin documentar&lt;/b&gt;interfaz, entonces deber&amp;aacute; realizar modificaciones para actualizar a la versi&amp;oacute;n 3.5.0 de SQLite. Esto puede parecer doloroso a primera vista. Pero al mirar m&amp;aacute;s de cerca, probablemente descubrir&amp;aacute; que sus cambios se hacen m&amp;aacute;s peque&amp;ntilde;os y m&amp;aacute;s f&amp;aacute;ciles de entender y administrar con la nueva interfaz SQLite. Es probable que sus cambios ahora tambi&amp;eacute;n funcionen sin problemas con la fusi&amp;oacute;n de SQLite. Ya no necesitar&amp;aacute; realizar ning&amp;uacute;n cambio en el c&amp;oacute;digo fuente de SQLite. Todos los cambios se pueden realizar mediante el c&amp;oacute;digo de la aplicaci&amp;oacute;n y puede vincularlos con una versi&amp;oacute;n est&amp;aacute;ndar sin modificar de la fusi&amp;oacute;n de SQLite. Adem&amp;aacute;s, la capa de interfaz del sistema operativo, que antes no estaba documentada, ahora es una interfaz de soporte oficial para SQLite.Por lo tanto, tiene la seguridad de que este ser&amp;aacute; un cambio &amp;uacute;nico y que su nuevo backend continuar&amp;aacute; funcionando en futuras versiones de SQLite.</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">Si se invoca zipfile()con 2 argumentos,entonces la entrada añadida al archivo es equivalente a la añadida insertando los mismos dos valores en las columnas &quot;nombre&quot; y &quot;datos&quot; de una tabla virtual de zipfile,con todos los demás valores establecidos en NULL.Si se invoca con 4 argumentos,equivale a insertar los 4 valores en las columnas &quot;name&quot;,&quot;mode&quot;,&quot;mtime&quot; y &quot;data&quot;.En otras palabras,los siguientes pares de consultas son equivalentes:</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">Si,como parte de la</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">Si,mientras se abre una</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">Ignoren los espacios en blanco adicionales al final de los comandos de &quot;.&quot; en el caparazón.</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">Inmediatamente después de que un iterador es creado por sqlite3changeset_start(),no apunta a ningún cambio en el changeset.Asumiendo que el conjunto de cambios no está vacío,la primera llamada a esta función hace avanzar el iterador para que apunte al primer cambio en el conjunto de cambios.Cada llamada subsiguiente avanza el iterador para apuntar al siguiente cambio en el conjunto de cambios (si lo hay).Si no se produce ningún error y el iterador apunta a un cambio válido después de que una llamada a sqlite3changeset_next()lo haya avanzado,se devuelve SQLITE_ROW.En caso contrario,si ya se han visitado todos los cambios del conjunto de cambios,se devuelve SQLITE_DONE.</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">Inmediatamente después de la cabecera de la pared hay cero o más marcos.Cada marco consiste en una cabeza de marco de 24 bytes seguida de un</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">Implemente un procedimiento que llame a &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; y le pase un puntero a la estructura &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; del paso anterior. Este procedimiento es probablemente el &amp;uacute;nico s&amp;iacute;mbolo exportado en el archivo fuente que implementa su VFS.</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">Aplicar la cláusula de &quot;LIMITACIÓN ...COMPENSACIÓN ...&quot; en las declaraciones SELECT.</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Implemente los m&amp;eacute;todos requeridos por el objeto &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">Implemente los otros m&amp;eacute;todos requeridos por &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">Implemente el m&amp;eacute;todo xOpen que abre un archivo y completa un objeto &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; , incluida la configuraci&amp;oacute;n de pMethods para que apunte al objeto &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; del paso anterior.</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">Límites de implementación para SQLite</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">Las implementaciones de funciones SQL agregadas utilizan esta rutina para asignar memoria para almacenar su estado.</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">La implementaci&amp;oacute;n de una funci&amp;oacute;n auxiliar personalizada es similar a la implementaci&amp;oacute;n de una &lt;a href=&quot;c3ref/create_function&quot;&gt;funci&amp;oacute;n de SQL escalar&lt;/a&gt; . La implementaci&amp;oacute;n debe ser una funci&amp;oacute;n C de tipo fts5_extension_function, definida de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">Transacciones implícitas contra explícitas</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">Importante corrección de errores:el operador de la entrada no funcionaba si el lado izquierdo o derecho se derivaba de una LLAVE PRIMARIA INTEGER.</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">Imponer un límite al tamaño del montón</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">Tablas Imposter</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">Las tablas de impostores están pensadas sólo para el análisis y la depuración.No es una característica que la mayoría de los desarrolladores de aplicaciones deban entender o incluso conocer.Las tablas Imposter son sólo para expertos.</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">El uso inadecuado de tablas impostoras puede provocar da&amp;ntilde;os en el &amp;iacute;ndice, aunque cualquier da&amp;ntilde;o creado de esta manera se puede solucionar ejecutando &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">Mejore la &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;optimizaci&amp;oacute;n de la combinaci&amp;oacute;n de omisi&amp;oacute;n a la izquierda&lt;/a&gt; para que funcione en los casos en que la tabla de la derecha sea &amp;Uacute;NICA pero no necesariamente NO NULA.</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">Mejore la &lt;a href=&quot;optoverview#pushdown&quot;&gt;optimizaci&amp;oacute;n de empuje hacia abajo&lt;/a&gt; para que funcione para muchas LEFT JOIN.</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">Mejorar el formato de la salida sin procesar &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; , para que proporcione mejor informaci&amp;oacute;n sobre el plan de consulta y sobre las relaciones entre los diversos componentes del plan.</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">Mejorar el rendimiento de las consultas fts3/4 que utilizan el operador de quirófano y al menos una función fts auxiliar.</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">Mejore el rendimiento de la &lt;a href=&quot;lang_corefunc#replace&quot;&gt;funci&amp;oacute;n SQL replace ()&lt;/a&gt; para los casos en los que hay muchas sustituciones en cadenas de tama&amp;ntilde;o megabyte, en un intento de evitar los tiempos de espera de OSSFuzz durante las pruebas. &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;Fab2c2b07b5d3&lt;/a&gt; de facturaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">Mejora de la concurrencia</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">Mejora de la concurrencia.</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">Mejora de la precisión de las conversiones en punto flotante usando el &quot;doble largo&quot;.</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">Algoritmo mejorado para ejecutar consultas con un PEDIDO y un LÍMITE donde sólo el bucle más interno genera naturalmente filas en el orden correcto.</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">Mejora de la concurrencia.</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">Mejora de la resistencia a los choques:escribe el tamaño de la página de la base de datos en el encabezado del diario.</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">Se mejor&amp;oacute; la eliminaci&amp;oacute;n de comillas de nombres de columna para declaraciones &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; con una consulta agregada en el lado derecho.</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">Mejora de la detección de errores de las funciones agregadas mal utilizadas.</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">Mejora de los mensajes de error de &quot;desajuste de clave externa&quot; que muestran los nombres de las dos tablas involucradas.</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Mensajes de error mejorados para argumentos booleanos no v&amp;aacute;lidos para comandos de puntos en el &lt;a href=&quot;cli&quot;&gt;shell de l&amp;iacute;nea de comandos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">Mensajes de error mejorados en la extensi&amp;oacute;n &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c14cbb8bf1ab0754b223743a066a939afc76bf" translate="yes" xml:space="preserve">
          <source>Improved error messages on &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cd821953431d9f45b2ba280ac0721b09c232ad" translate="yes" xml:space="preserve">
          <source>Improved estimates for the cost of running a DISTINCT operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">Mejoras en las pruebas de pelusas de los archivos de la base de datos,con correcciones para los problemas encontrados.</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">Mejora de la resolución de nombres para consultas profundamente anidadas.</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">Optimizaci&amp;oacute;n mejorada de los operadores &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">Mejora de la optimización de los operadores AND y OR cuando uno u otro operando es una constante.</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">Mejora de la optimización de las cláusulas ORDER BY en las consultas compuestas.</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">Mejora de la optimización de las subconsultas agregadas contenidas en una consulta agregada.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
