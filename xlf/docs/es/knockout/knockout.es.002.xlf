<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="1efa8d65721b2af289c42fb7b810ae66b4f29f5d" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to control the presence/absence of a section of markup &lt;em&gt;without&lt;/em&gt; having any container element that can hold an if binding. For example, you might want to control whether a certain &amp;lt;li&amp;gt; element appears alongside siblings that always appear:</source>
          <target state="translated">A veces, es posible que desee controlar la presencia / ausencia de una secci&amp;oacute;n de marcado &lt;em&gt;sin&lt;/em&gt; tener ning&amp;uacute;n elemento contenedor que pueda contener un if vinculante. Por ejemplo, es posible que desee controlar si un determinado elemento &amp;lt;li&amp;gt; aparece junto a los hermanos que siempre aparecen:</target>
        </trans-unit>
        <trans-unit id="cf0e5ef35db2f589ef3d7f23133757750ce5acc6" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to control the presence/absence of a section of markup &lt;em&gt;without&lt;/em&gt; having any container element that can hold an if or ifnot binding. For example, you might want to control whether a certain &amp;lt;li&amp;gt; element appears alongside siblings that always appear:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090d7c130eac68daf4d626886fb71b101a09b651" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to create a component that receives markup and uses it as part of its output. For example, you may want to build a &amp;ldquo;container&amp;rdquo; UI element such as a grid, list, dialog, or tab set that can receive and bind arbitrary markup inside itself.</source>
          <target state="translated">A veces, es posible que desee crear un componente que reciba marcado y lo use como parte de su salida. Por ejemplo, es posible que desee crear un elemento de interfaz de usuario &quot;contenedor&quot;, como una cuadr&amp;iacute;cula, una lista, un cuadro de di&amp;aacute;logo o un conjunto de pesta&amp;ntilde;as que pueda recibir y vincular marcas arbitrarias dentro de s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="1450743be880bbdffbc9a1ba26bf1fd07e6f657e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to inject a component into a view without using an extra container element. You can do this using &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">A veces, es posible que desee inyectar un componente en una vista sin utilizar un elemento contenedor adicional. Puede hacer esto utilizando la &lt;em&gt;sintaxis de flujo de control sin contenedor&lt;/em&gt; , que se basa en etiquetas de comentarios. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f112400da0855e8fa6da455e812ae3ff58f48789" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted without actually losing record of its existence. This is known as a &lt;em&gt;non-destructive delete&lt;/em&gt;. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b22fd48b43a0ffdb2cae9da6d525da9fd48f8e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a &lt;em&gt;non-destructive delete&lt;/em&gt;. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="translated">A veces, es posible que desee marcar una entrada de matriz como eliminada, pero sin perder el registro de su existencia. Esto se conoce como &lt;em&gt;eliminaci&amp;oacute;n no destructiva&lt;/em&gt; . Para obtener detalles sobre c&amp;oacute;mo hacer esto, consulte &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;la funci&amp;oacute;n de destrucci&amp;oacute;n en observableArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd93e9d13d7bfcfd8e5c31ed2ceac2a6c4e1754" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="translated">A veces, es posible que desee marcar una entrada de matriz como eliminada, pero sin perder el registro de su existencia. Esto se conoce como eliminaci&amp;oacute;n no destructiva. Para obtener detalles sobre c&amp;oacute;mo hacer esto, consulte &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;la funci&amp;oacute;n de destrucci&amp;oacute;n en observableArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a812dff6786cd406aaefba5f4c3b70873c52a6" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to set text using Knockout without including an extra element for the text binding. For example, you&amp;rsquo;re not allowed to include other elements within an option element, so the following will not work.</source>
          <target state="translated">A veces, es posible que desee configurar el texto utilizando Knockout sin incluir un elemento adicional para el enlace de texto. Por ejemplo, no puede incluir otros elementos dentro de un elemento de opci&amp;oacute;n, por lo que lo siguiente no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6a4525599ef68a9fe43c6df211cccff711b57d1e" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to represent a data point on the screen in a different format than its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</source>
          <target state="translated">A veces se puede querer representar un punto de datos en la pantalla en un formato diferente al de su almacenamiento subyacente.Por ejemplo,puede querer almacenar un precio como un valor flotante bruto,pero dejar que el usuario lo edite con un símbolo de moneda y un número fijo de decimales.Puede utilizar un observable computarizado escribible para representar el precio formateado,asignando los valores entrantes al valor flotante subyacente:</target>
        </trans-unit>
        <trans-unit id="05cfb62c148b0599a08339e0df2d05f5ef502466" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you&amp;rsquo;re using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates&amp;rsquo; output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</source>
          <target state="translated">A veces, es posible que desee ejecutar una l&amp;oacute;gica de posprocesamiento personalizada en los elementos DOM generados por sus plantillas. Por ejemplo, si est&amp;aacute; utilizando una biblioteca de widgets de JavaScript como jQuery UI, es posible que desee interceptar la salida de sus plantillas para poder ejecutar los comandos de jQuery UI en ella para transformar algunos de los elementos renderizados en selectores de fecha, controles deslizantes o Algo m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="afd9a93d696cf0ee53ba71b61bf9029619eeebff" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to run custom post-processing logic on the DOM elements processed by Knockout. For example, if you&amp;rsquo;re using a JavaScript widgets library such as jQuery UI, you might want to know when a certain section of the DOM is finished binding so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48318af51d331ce8f161c28b2d8b8af865a40b57" translate="yes" xml:space="preserve">
          <source>Sometimes, rather than reacting to every change to an observable, you just need to know when the observable arrives at a specific value. This is what ko.when makes easy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a20134d13c4fa83399a61a6648dae5f5c9116e3" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads &amp;ldquo;Select an item&amp;rdquo; or &amp;ldquo;Please choose an option&amp;rdquo; or similar, and have that one selected by default.</source>
          <target state="translated">A veces, es posible que no desee seleccionar ninguna opci&amp;oacute;n en particular de forma predeterminada. Pero una lista desplegable de selecci&amp;oacute;n &amp;uacute;nica generalmente comienza con alg&amp;uacute;n elemento seleccionado, entonces, &amp;iquest;c&amp;oacute;mo puede evitar preseleccionar algo? La soluci&amp;oacute;n habitual es prefijar la lista de opciones con una opci&amp;oacute;n ficticia especial que solo dice &quot;Seleccionar un elemento&quot; o &quot;Por favor, elija una opci&amp;oacute;n&quot; o similar, y tener esa opci&amp;oacute;n seleccionada por defecto.</target>
        </trans-unit>
        <trans-unit id="a88830ac8683679b861aa2877996a238dbfdf87d" translate="yes" xml:space="preserve">
          <source>Source code: View</source>
          <target state="translated">El código fuente:Ver</target>
        </trans-unit>
        <trans-unit id="6506bd5b573750d96e1b57831c62ba19272cf14f" translate="yes" xml:space="preserve">
          <source>Source code: View model</source>
          <target state="translated">El código fuente:Ver modelo</target>
        </trans-unit>
        <trans-unit id="15f8a682df856004ef8f68cac3fd529a0a678f8b" translate="yes" xml:space="preserve">
          <source>Special consideration for computed observables</source>
          <target state="translated">Consideración especial para los observables computarizados</target>
        </trans-unit>
        <trans-unit id="4551a643a13595067fd9579e7489ebfab8a1983d" translate="yes" xml:space="preserve">
          <source>Special consideration is given if your parameter resolves to an array. In this case, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if the value matches an item in the array, and &lt;em&gt;unchecked&lt;/em&gt; if it is not contained in the array.</source>
          <target state="translated">Se da una consideraci&amp;oacute;n especial si su par&amp;aacute;metro se resuelve en una matriz. En este caso, KO establecer&amp;aacute; el elemento para que se &lt;em&gt;verifique&lt;/em&gt; si el valor coincide con un elemento de la matriz y lo &lt;em&gt;desmarcar&amp;aacute;&lt;/em&gt; si no est&amp;aacute; contenido en la matriz.</target>
        </trans-unit>
        <trans-unit id="2bcf0e18fa32879957b9099a890fa1e0dc44a296" translate="yes" xml:space="preserve">
          <source>Special consideration is given if your parameter resolves to an array. In this case, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; if its value matches an item in the array, and &lt;em&gt;unchecked&lt;/em&gt; if it is not contained in the array. The value of a checkbox is either the element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. When the user checks or unchecks the checkbox, Knockout will add or remove its value from the array accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26666026e63743d1a82020481615fe638ff934ed" translate="yes" xml:space="preserve">
          <source>Specifying a template</source>
          <target state="translated">Especificar una plantilla</target>
        </trans-unit>
        <trans-unit id="2b1d7859ab19cd19f47ec6abc15db40ae61a246c" translate="yes" xml:space="preserve">
          <source>Specifying a viewmodel</source>
          <target state="translated">Especificar un modelo de vista</target>
        </trans-unit>
        <trans-unit id="ea0e6f5e3da2da0e29f0ea90ea1b0cd98c85ba63" translate="yes" xml:space="preserve">
          <source>Specifying additional component options</source>
          <target state="translated">Especificar opciones de componentes adicionales</target>
        </trans-unit>
        <trans-unit id="18b4234e7c86c009699286451ef7b9d36ae43d1e" translate="yes" xml:space="preserve">
          <source>Specifying the update target</source>
          <target state="translated">Especificar el objetivo de actualización</target>
        </trans-unit>
        <trans-unit id="1bcfc349547d09f30035896045c448b81206e326" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</source>
          <target state="translated">A partir de Knockout 3.0,los desarrolladores pueden definir sintaxis personalizadas proporcionando llamadas que reescriben nodos DOM y cadenas de unión durante el proceso de unión.</target>
        </trans-unit>
        <trans-unit id="c796aa5f2bada6792690259418192c7883d1c418" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, you can specify bindings without a value, which will give the binding an undefined value. For example:</source>
          <target state="translated">A partir de Knockout 3.0,puedes especificar las ataduras sin un valor,lo que dará a la atadura un valor indefinido.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2693170c13c752044d965baa86ff029af25c5bd4" translate="yes" xml:space="preserve">
          <source>State-change notifications</source>
          <target state="translated">Notificaciones de cambio de estado</target>
        </trans-unit>
        <trans-unit id="be915d52c2d4abc30f8b3705c52e450a201b3997" translate="yes" xml:space="preserve">
          <source>Status of a disposed pure computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2969f3ba60c665581a9459f630df126d1688e010" translate="yes" xml:space="preserve">
          <source>Subscribing to lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c6f3ef32f538ba7ddc197ba2a40ed8bf1267eff0" translate="yes" xml:space="preserve">
          <source>Taking this a step further, you could also toggle an isValid flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There&amp;rsquo;s an easier way of doing validation (explained below), but first consider the following example, which demonstrates the mechanism:</source>
          <target state="translated">Llevando esto un paso m&amp;aacute;s all&amp;aacute;, tambi&amp;eacute;n puede alternar un indicador isValid dependiendo de si la &amp;uacute;ltima entrada fue satisfactoria y mostrar un mensaje en la interfaz de usuario en consecuencia. Existe una forma m&amp;aacute;s sencilla de realizar la validaci&amp;oacute;n (que se explica a continuaci&amp;oacute;n), pero primero considere el siguiente ejemplo, que demuestra el mecanismo:</target>
        </trans-unit>
        <trans-unit id="bfd2f41bbe59a64109622cb800b43d5098fbef87" translate="yes" xml:space="preserve">
          <source>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there&amp;rsquo;s a better alternative. KO&amp;rsquo;s observableArray has equivalent functions of its own, and they&amp;rsquo;re more useful because:</source>
          <target state="translated">T&amp;eacute;cnicamente, puede utilizar cualquiera de las funciones de matriz de JavaScript nativas para operar en esa matriz subyacente, pero normalmente hay una alternativa mejor. El observableArray de KO tiene funciones equivalentes propias, y son m&amp;aacute;s &amp;uacute;tiles porque:</target>
        </trans-unit>
        <trans-unit id="e9d610e2da9960031e5fc6eb154252b9be195eaf" translate="yes" xml:space="preserve">
          <source>Templates can be specified in any of the following forms. The most commonly useful are &lt;a href=&quot;#an-existing-element-id&quot;&gt;existing element IDs&lt;/a&gt; and &lt;a href=&quot;#an-amd-module-whose-value-describes-a-template&quot;&gt;AMD modules&lt;/a&gt;.</source>
          <target state="translated">Las plantillas se pueden especificar en cualquiera de las siguientes formas. Los m&amp;aacute;s &amp;uacute;tiles son &lt;a href=&quot;#an-existing-element-id&quot;&gt;los ID de elementos existentes&lt;/a&gt; y &lt;a href=&quot;#an-amd-module-whose-value-describes-a-template&quot;&gt;los m&amp;oacute;dulos AMD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200be3445e2bde1ede81d4c95d33bd1076a8277f" translate="yes" xml:space="preserve">
          <source>Templating</source>
          <target state="translated">Templating</target>
        </trans-unit>
        <trans-unit id="d0044a6eb26a5c396986a0204048b9d5e5baf64c" translate="yes" xml:space="preserve">
          <source>That does it! Now, your view will display as if you&amp;rsquo;d written the following HTML:</source>
          <target state="translated">&amp;iexcl;Eso lo hace! Ahora, su vista se mostrar&amp;aacute; como si hubiera escrito el siguiente HTML:</target>
        </trans-unit>
        <trans-unit id="02e149eee4340af4ceec19232b911078d7192e9a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because the options binding tries to be independent of the value binding (which controls selection for a single-select list) and the selectedOptions binding (which controls selection for a multi-select list).</source>
          <target state="translated">Esto se debe a que el enlace de opciones intenta ser independiente del enlace de valor (que controla la selecci&amp;oacute;n para una lista de selecci&amp;oacute;n &amp;uacute;nica) y el enlace selectedOptions (que controla la selecci&amp;oacute;n para una lista de selecci&amp;oacute;n m&amp;uacute;ltiple).</target>
        </trans-unit>
        <trans-unit id="e674558ecc1081e9c1295665f7df128dafb8d87b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You don&amp;rsquo;t have to write code to update it; it updates on its own when the myItems array changes. Similarly, to make the &amp;lsquo;Add&amp;rsquo; button enable or disable depending on the number of items, just write:</source>
          <target state="translated">&amp;iexcl;Eso es! No es necesario escribir c&amp;oacute;digo para actualizarlo; se actualiza por s&amp;iacute; solo cuando cambia la matriz myItems. De manera similar, para habilitar o deshabilitar el bot&amp;oacute;n 'Agregar' seg&amp;uacute;n la cantidad de elementos, simplemente escriba:</target>
        </trans-unit>
        <trans-unit id="667657cfbe0d82dea6d00158cadde1d15d9e504d" translate="yes" xml:space="preserve">
          <source>The &quot;attr&quot; binding</source>
          <target state="translated">La unión &quot;attr&quot;</target>
        </trans-unit>
        <trans-unit id="81fe0aefcb8907e65d4f80424d8b82ba6529ef05" translate="yes" xml:space="preserve">
          <source>The &quot;checked&quot; binding</source>
          <target state="translated">La unión &quot;comprobada&quot;</target>
        </trans-unit>
        <trans-unit id="836a82bfe72ef112581f47a7fba0da6ed84bd80c" translate="yes" xml:space="preserve">
          <source>The &quot;class&quot; and &quot;css&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729792440e88ab1975faa8b1ae741d3568a9e80f" translate="yes" xml:space="preserve">
          <source>The &quot;click&quot; binding</source>
          <target state="translated">La unión del &quot;clic&quot;</target>
        </trans-unit>
        <trans-unit id="87f9daf36f2cbfcb9347bc8d5a2a9ac913f55ee0" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot; binding</source>
          <target state="translated">La unión del &quot;componente&quot;</target>
        </trans-unit>
        <trans-unit id="268bdcaa2d0957c8d0391d4c4e143f349a3a0908" translate="yes" xml:space="preserve">
          <source>The &quot;css&quot; binding</source>
          <target state="translated">La unión &quot;css&quot;</target>
        </trans-unit>
        <trans-unit id="aa22ef1d97b1be4a810e3f5260ca2fd7b9c4b9cc" translate="yes" xml:space="preserve">
          <source>The &quot;disable&quot; binding</source>
          <target state="translated">La unión de &quot;deshabilitar&quot;</target>
        </trans-unit>
        <trans-unit id="1546e74f5d1b76eda2b5dc5a99f2d04abc3904df" translate="yes" xml:space="preserve">
          <source>The &quot;enable&quot; and &quot;disable&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041e1100c69440c690c0a77bb60251bbe60aa13d" translate="yes" xml:space="preserve">
          <source>The &quot;enable&quot; binding</source>
          <target state="translated">La vinculación &quot;habilitante&quot;</target>
        </trans-unit>
        <trans-unit id="8b081740d1fb26b2947fc54f2be8290dd6b4f171" translate="yes" xml:space="preserve">
          <source>The &quot;event&quot; binding</source>
          <target state="translated">La vinculación del &quot;evento&quot;</target>
        </trans-unit>
        <trans-unit id="aeb9266b69cb94e4efef8e8ec8245bac4441f5fb" translate="yes" xml:space="preserve">
          <source>The &quot;foreach&quot; binding</source>
          <target state="translated">La unión &quot;foreach&quot;</target>
        </trans-unit>
        <trans-unit id="387e6548a4d36e8f21807318bf235e14d2cabd7e" translate="yes" xml:space="preserve">
          <source>The &quot;hasFocus&quot; binding</source>
          <target state="translated">La unión &quot;hasFocus&quot;</target>
        </trans-unit>
        <trans-unit id="b3bd7e57ef15a3a444a9a54af1c145628250ace9" translate="yes" xml:space="preserve">
          <source>The &quot;html&quot; binding</source>
          <target state="translated">La unión &quot;html&quot;</target>
        </trans-unit>
        <trans-unit id="ce5aed7a9b37c6426140743870d4fa729ae280bd" translate="yes" xml:space="preserve">
          <source>The &quot;if&quot; and &quot;ifnot&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a22f402c1cb22df5a11c1cf759eb4fcb7755fd" translate="yes" xml:space="preserve">
          <source>The &quot;if&quot; binding</source>
          <target state="translated">El &quot;si&quot; vinculante</target>
        </trans-unit>
        <trans-unit id="6e058224b266f791dfd293b2509c3657b73c91ee" translate="yes" xml:space="preserve">
          <source>The &quot;ifnot&quot; binding</source>
          <target state="translated">La unión &quot;ifnot&quot;</target>
        </trans-unit>
        <trans-unit id="d33b99cd025d1ef1a00d7820955adff6b091a4f6" translate="yes" xml:space="preserve">
          <source>The &quot;let&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ecb831b753a1b99237c2da228b61981e524a2c" translate="yes" xml:space="preserve">
          <source>The &quot;options&quot; binding</source>
          <target state="translated">La vinculación de las &quot;opciones&quot;</target>
        </trans-unit>
        <trans-unit id="998f0ccdcc6e82328f9f4ecba0c9325b97e976df" translate="yes" xml:space="preserve">
          <source>The &quot;selectedOptions&quot; binding</source>
          <target state="translated">La vinculación de las &quot;opciones seleccionadas&quot;</target>
        </trans-unit>
        <trans-unit id="7b0ad502b61055bf3d6312ebedf00afcf36c21e2" translate="yes" xml:space="preserve">
          <source>The &quot;style&quot; binding</source>
          <target state="translated">La encuadernación de &quot;estilo&quot;</target>
        </trans-unit>
        <trans-unit id="012a650b218ca98273aeac430939dd9445632dd3" translate="yes" xml:space="preserve">
          <source>The &quot;submit&quot; binding</source>
          <target state="translated">La obligación de &quot;presentar&quot;</target>
        </trans-unit>
        <trans-unit id="7e48a0247d14aa0d9c333491f221626e25bc43fb" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; binding</source>
          <target state="translated">La vinculación de la &quot;plantilla&quot;</target>
        </trans-unit>
        <trans-unit id="2d856ef4864767a8e9b7d18ca94745b74199eb43" translate="yes" xml:space="preserve">
          <source>The &quot;text&quot; binding</source>
          <target state="translated">La unión del &quot;texto&quot;</target>
        </trans-unit>
        <trans-unit id="60b50b0405f6a55d057311d3ce77ae607e221184" translate="yes" xml:space="preserve">
          <source>The &quot;textInput&quot; binding</source>
          <target state="translated">La vinculación &quot;textInput&quot;</target>
        </trans-unit>
        <trans-unit id="cf70dcaafb5eeb11cd70e48b42ab8792299341fb" translate="yes" xml:space="preserve">
          <source>The &quot;uniqueName&quot; binding</source>
          <target state="translated">La unión del &quot;nombre único&quot;</target>
        </trans-unit>
        <trans-unit id="abff06e6a46c514b00a9d69ebda1678fe9b61252" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; binding</source>
          <target state="translated">La unión del &quot;valor&quot;</target>
        </trans-unit>
        <trans-unit id="dcec70cee11113c3fce39cd44d46e81d4ff35f55" translate="yes" xml:space="preserve">
          <source>The &quot;visible&quot; and &quot;hidden&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9926725b31c6326f65c499ed6e2d7c6ef89cb6" translate="yes" xml:space="preserve">
          <source>The &quot;visible&quot; binding</source>
          <target state="translated">La unión &quot;visible&quot;</target>
        </trans-unit>
        <trans-unit id="99662caaf1c265b5d5f4b8647c0390162f2951ee" translate="yes" xml:space="preserve">
          <source>The &quot;with&quot; and &quot;using&quot; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2695c31457d8ecf209fdcde945ae4b7e6b35704" translate="yes" xml:space="preserve">
          <source>The &quot;with&quot; binding</source>
          <target state="translated">El &quot;con&quot; vinculante</target>
        </trans-unit>
        <trans-unit id="d0172068eae28b7598208322680a72ead20dc040" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;init&amp;rdquo; callback</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada &quot;init&quot;</target>
        </trans-unit>
        <trans-unit id="88bffd25f7f08d8f696284fca0cd9e9a510a5a82" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;update&amp;rdquo; callback</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada de &quot;actualizaci&amp;oacute;n&quot;</target>
        </trans-unit>
        <trans-unit id="a7b56425c510dea26081ff5f361028be5d697e8c" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!-- ko --&amp;gt; and &amp;lt;!-- /ko --&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="translated">Los comentarios &amp;lt;! - ko -&amp;gt; y &amp;lt;! - / ko -&amp;gt; act&amp;uacute;an como marcadores de inicio / fin, definiendo un &quot;elemento virtual&quot; que contiene el marcado en su interior. Knockout comprende la sintaxis de este elemento virtual y se vincula como si tuviera un elemento contenedor real.</target>
        </trans-unit>
        <trans-unit id="66447128a53fc158d2a378583ff58d8cb3b7f44b" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!--ko--&amp;gt; and &amp;lt;!--/ko--&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="translated">Los comentarios &amp;lt;! - ko -&amp;gt; y &amp;lt;! - / ko -&amp;gt; act&amp;uacute;an como marcadores de inicio / fin, definiendo un &quot;elemento virtual&quot; que contiene el marcado en su interior. Knockout comprende la sintaxis de este elemento virtual y se vincula como si tuviera un elemento contenedor real.</target>
        </trans-unit>
        <trans-unit id="f6c987f2e30b59a61bf82010bd82466cbad8bfa5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checked-binding&quot;&gt;checked&lt;/a&gt; binding should be used to bind a view model property against the value of a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or radio button (&amp;lt;input type='radio'&amp;gt;). If you do include the value binding with the checked binding on one of these elements, then the value binding acts similarly to the &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue&lt;/a&gt; option that can be used with the checked binding and will control the value that is used for updating your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0fa3ec409d116219327c807820e685d0a681ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checked-binding&quot;&gt;checked&lt;/a&gt; binding should be used to bind a view model property against the value of a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or radio button (&amp;lt;input type='radio'&amp;gt;). If you do include the value binding with the checked binding on one of these elements, then the value binding will simply act like the &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue&lt;/a&gt; option that can be used with the checked binding and will control the value that is used for updating your view model.</source>
          <target state="translated">La vinculaci&amp;oacute;n &lt;a href=&quot;checked-binding&quot;&gt;marcada&lt;/a&gt; debe usarse para vincular una propiedad de modelo de vista con el valor de una casilla de verificaci&amp;oacute;n (&amp;lt;input type = 'checkbox'&amp;gt;) o bot&amp;oacute;n de opci&amp;oacute;n (&amp;lt;input type = 'radio'&amp;gt;). Si incluye el enlace de valor con el enlace marcado en uno de estos elementos, entonces el enlace de valor simplemente actuar&amp;aacute; como la opci&amp;oacute;n &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;CheckValue&lt;/a&gt; que se puede usar con el enlace marcado y controlar&amp;aacute; el valor que se usa para actualizar su modelo de vista.</target>
        </trans-unit>
        <trans-unit id="063f48d562135b75491eebc35abcf6a8aa221482" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore.js template engine&lt;/a&gt; by default uses ERB-style delimiters (&amp;lt;%= ... %&amp;gt;). Here&amp;rsquo;s how the preceding example&amp;rsquo;s template might look with Underscore:</source>
          <target state="translated">El &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;motor de plantilla de Underscore.js&lt;/a&gt; utiliza por defecto delimitadores de estilo ERB (&amp;lt;% = ...%&amp;gt;). As&amp;iacute; es como se ver&amp;iacute;a la plantilla del ejemplo anterior con Underscore:</target>
        </trans-unit>
        <trans-unit id="ef92cc17f05a45263dfe218714287940c12a0b66" translate="yes" xml:space="preserve">
          <source>The added array element</source>
          <target state="translated">El elemento añadido de la matriz</target>
        </trans-unit>
        <trans-unit id="b57088d36db63605ea20966d4f6ddfdc3a240418" translate="yes" xml:space="preserve">
          <source>The arrays ignore and include still work as normal. The array copy can be used for efficiency to copy array or object properties including children. If an array or object property is not specified in copy or observe then it is recursively mapped:</source>
          <target state="translated">Las matrices ignoran e incluyen todavía funcionan con normalidad.La copia de los arreglos puede ser usada por eficiencia para copiar las propiedades de los arreglos o de los objetos,incluyendo los niños.Si una matriz o propiedad de un objeto no se especifica en copiar u observar,entonces se mapea recursivamente:</target>
        </trans-unit>
        <trans-unit id="5dadf6a7255eba492271ccb4eccaf63b41dfa7f2" translate="yes" xml:space="preserve">
          <source>The as option allows you set an alias for the new context object. Although you can refer to the object using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;, it may be useful to give it a more descriptive name using the as option like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75481e65bcc1f59ce58a2b7a269a6702607e56a" translate="yes" xml:space="preserve">
          <source>The as option also provides a corresponding &lt;em&gt;index&lt;/em&gt; value. For example, if you set as: 'category', you can access the index of the current item using categoryIndex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d35e492a8cbdf9e668e45561d2ef1328ef7965" translate="yes" xml:space="preserve">
          <source>The attr binding can be used to set attributes that include a namespace, such as xlink:href:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b6946f4dee7b5d349c61c577e42283624be620" translate="yes" xml:space="preserve">
          <source>The attr binding provides a generic way to set the value of any attribute for the associated DOM element. This is useful, for example, when you need to set the title attribute of an element, the src of an img tag, or the href of a link based on values in your view model, with the attribute value being updated automatically whenever the corresponding model property changes.</source>
          <target state="translated">La vinculación de atracción proporciona una forma genérica de establecer el valor de cualquier atributo para el elemento DOM asociado.Esto es útil,por ejemplo,cuando se necesita establecer el atributo title de un elemento,el src de una etiqueta img,o el href de un enlace basado en los valores de su modelo de visualización,con el valor del atributo que se actualiza automáticamente cada vez que cambia la propiedad correspondiente del modelo.</target>
        </trans-unit>
        <trans-unit id="a9e9d47bf7dc24b389ee0d6af7ed88fcf6a222e2" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;name&lt;/em&gt; should generally match a registered binding (either built-in or &lt;a href=&quot;custom-bindings&quot;&gt;custom&lt;/a&gt;) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&amp;rsquo;t appear to work, first check that the name is correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef329ec6555c9ead7be23ed4a0362089a23da81" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;name&lt;/em&gt; should generally match a registered binding handler (either built-in or &lt;a href=&quot;custom-bindings&quot;&gt;custom&lt;/a&gt;) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&amp;rsquo;t appear to work, first check that the name is correct.</source>
          <target state="translated">El &lt;em&gt;nombre de&lt;/em&gt; enlace generalmente debe coincidir con un controlador de enlace registrado (ya sea incorporado o &lt;a href=&quot;custom-bindings&quot;&gt;personalizado&lt;/a&gt; ) o ser un par&amp;aacute;metro para otro enlace. Si el nombre no coincide con ninguno de esos, Knockout lo ignorar&amp;aacute; (sin ning&amp;uacute;n error o advertencia). Entonces, si un enlace no parece funcionar, primero verifique que el nombre sea correcto.</target>
        </trans-unit>
        <trans-unit id="652f2f5c9f8a12eb6ee21fee9ad6a56c07e3be9d" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;value&lt;/em&gt; can be a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals&quot;&gt;value, variable, or literal&lt;/a&gt; or almost any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators&quot;&gt;JavaScript expression&lt;/a&gt;. Here are examples of various binding values:</source>
          <target state="translated">El &lt;em&gt;valor de&lt;/em&gt; enlace puede ser un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals&quot;&gt;valor&lt;/a&gt; &amp;uacute;nico , variable o literal o casi cualquier &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators&quot;&gt;expresi&amp;oacute;n de JavaScript&lt;/a&gt; v&amp;aacute;lida . A continuaci&amp;oacute;n, se muestran ejemplos de varios valores vinculantes:</target>
        </trans-unit>
        <trans-unit id="00c2e2c23df54cb959bb9b3e5e3e3ebc75348a46" translate="yes" xml:space="preserve">
          <source>The built-in default component loader, ko.components.defaultLoader, is based around a central &amp;ldquo;registry&amp;rdquo; of component definitions. It relies on you explicitly registering a configuration for each component before you can use that component.</source>
          <target state="translated">El cargador de componentes predeterminado incorporado, ko.components.defaultLoader, se basa en un &quot;registro&quot; central de definiciones de componentes. Se basa en que registre expl&amp;iacute;citamente una configuraci&amp;oacute;n para cada componente antes de poder utilizar ese componente.</target>
        </trans-unit>
        <trans-unit id="5ecaba43f1e6c01df489f88d37a9335daaf77792" translate="yes" xml:space="preserve">
          <source>The change log just gives you the items that actually changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d971840dc40d1d830c39a6836f76bdcbe10df112" translate="yes" xml:space="preserve">
          <source>The checked binding links a checkable form control &amp;mdash; i.e., a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or a radio button (&amp;lt;input type='radio'&amp;gt;) &amp;mdash; with a property on your view model.</source>
          <target state="translated">El enlace marcado vincula un control de formulario que se puede marcar, es decir, una casilla de verificaci&amp;oacute;n (&amp;lt;input type = 'checkbox'&amp;gt;) o un bot&amp;oacute;n de opci&amp;oacute;n (&amp;lt;input type = 'radio'&amp;gt;) - con una propiedad en su modelo de vista.</target>
        </trans-unit>
        <trans-unit id="c50da3ddf514bf7abf386398a139720b01486c05" translate="yes" xml:space="preserve">
          <source>The class and css bindings add or remove one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cda63d43cbee5c35bb13029131bdfe0150f240" translate="yes" xml:space="preserve">
          <source>The click binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked. This is most commonly used with elements like button, input, and a, but actually works with any visible DOM element.</source>
          <target state="translated">El enlace de clic agrega un manejador de eventos para que la función de JavaScript elegida sea invocada cuando se hace clic en el elemento DOM asociado.Esto se usa más comúnmente con elementos como botón,entrada y a,pero en realidad funciona con cualquier elemento DOM visible.</target>
        </trans-unit>
        <trans-unit id="315af6b13a3b050b2e8e589958153d689f7c75e4" translate="yes" xml:space="preserve">
          <source>The component &lt;strong&gt;name&lt;/strong&gt; can be any nonempty string. It&amp;rsquo;s recommended, but not mandatory, to use lowercase dash-separated strings (such as your-component-name) so that the component name is valid to use as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt; (such as &amp;lt;your-component-name&amp;gt;).</source>
          <target state="translated">El &lt;strong&gt;nombre del&lt;/strong&gt; componente puede ser cualquier cadena no vac&amp;iacute;a. Se recomienda, pero no es obligatorio, usar cadenas en min&amp;uacute;sculas separadas por guiones (como su-nombre-componente) para que el nombre del componente sea v&amp;aacute;lido para usar como un &lt;a href=&quot;component-custom-elements&quot;&gt;elemento personalizado&lt;/a&gt; (como &amp;lt;su-nombre-componente&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="d8ee1b6f8e527013cbe31220266cd96f28da0019" translate="yes" xml:space="preserve">
          <source>The component binding injects a specified &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; into an element, and optionally passes parameters to it.</source>
          <target state="translated">El enlace de componentes inyecta un &lt;a href=&quot;component-overview&quot;&gt;componente&lt;/a&gt; especificado en un elemento y, opcionalmente, le pasa par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="4d5135a132a3ef368448c56cda2be61f2f6fc1c6" translate="yes" xml:space="preserve">
          <source>The component can then choose to use the supplied DOM nodes as part of its output however it wishes, such as by using template: { nodes: $componentTemplateNodes } on any element in the component&amp;rsquo;s template.</source>
          <target state="translated">El componente puede entonces optar por utilizar los nodos DOM suministrados como parte de su salida como desee, por ejemplo, mediante el uso de template: {nodes: $ componentTemplateNodes} en cualquier elemento de la plantilla del componente.</target>
        </trans-unit>
        <trans-unit id="35f46804718d8f0a271608004b91334bb085b20e" translate="yes" xml:space="preserve">
          <source>The componentInfo.templateNodes array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">La matriz componentInfo.templateNodes es &amp;uacute;til si desea crear un componente que acepte marcas arbitrarias para influir en su salida (por ejemplo, una cuadr&amp;iacute;cula, una lista, un cuadro de di&amp;aacute;logo o un conjunto de pesta&amp;ntilde;as que inyecta el marcado proporcionado en s&amp;iacute; mismo). Para obtener un ejemplo completo, consulte &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;pasar el marcado a los componentes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1c8df0fe7dc76501e3c6d96810962786f87bc2a" translate="yes" xml:space="preserve">
          <source>The copy array you specify in the mapping options is combined with the default copy array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">La matriz de copia que se especifica en las opciones de mapeo se combina con la matriz de copia por defecto,que por defecto está vacía.Puedes manipular esta matriz por defecto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="932d9cd639f9a34ea0a379bb562c58e1459a2f51" translate="yes" xml:space="preserve">
          <source>The css binding adds or removes one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</source>
          <target state="translated">El enlace css añade o elimina una o más clases CSS nombradas al elemento DOM asociado.Esto es útil,por ejemplo,para resaltar algún valor en rojo si se vuelve negativo.</target>
        </trans-unit>
        <trans-unit id="1bca18c0eecebb94630002d080cd4f3ec6dd0351" translate="yes" xml:space="preserve">
          <source>The data item against which it is bound, or undefined for the caption element</source>
          <target state="translated">El elemento de datos con el que está ligado,o no definido para el elemento de la leyenda</target>
        </trans-unit>
        <trans-unit id="108f5df83762dc6213fdc4d63d42ffa6220b8746" translate="yes" xml:space="preserve">
          <source>The data item against which they are being bound</source>
          <target state="translated">El elemento de datos con el que están vinculados</target>
        </trans-unit>
        <trans-unit id="e02fc5ece743a7fd3262031255398c42b17ef54c" translate="yes" xml:space="preserve">
          <source>The data-bind attribute isn&amp;rsquo;t native to HTML, though it is perfectly OK (it&amp;rsquo;s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it&amp;rsquo;s an unrecognized attribute). But since the browser doesn&amp;rsquo;t know what it means, you need to activate Knockout to make it take effect.</source>
          <target state="translated">El atributo de enlace de datos no es nativo de HTML, aunque est&amp;aacute; perfectamente bien (es estrictamente compatible con HTML 5 y no causa problemas con HTML 4, aunque un validador se&amp;ntilde;alar&amp;aacute; que es un atributo no reconocido). Pero como el navegador no sabe lo que significa, debe activar Knockout para que surta efecto.</target>
        </trans-unit>
        <trans-unit id="c2e3559e993c827d22c705e31984a570c621dea7" translate="yes" xml:space="preserve">
          <source>The data-bind syntax</source>
          <target state="translated">La sintaxis de unión de datos</target>
        </trans-unit>
        <trans-unit id="6b8cf9fefc50c1a7501beecc036ff2dcc8fd4c33" translate="yes" xml:space="preserve">
          <source>The default behavior of the as option is to add a name for the current item while still also binding the contents to the item. But you may prefer keep the context unchanged and only set the name of the current item. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the array items must be through the given name, and $data will remain set to the outer viewmodel. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4353b85d2b9cd5e10fec344428d87770e27c1d9b" translate="yes" xml:space="preserve">
          <source>The default behavior of the as option is to set a name for the provided object while still also binding the contents to the object. But you may prefer to keep the context unchanged and only set the name of the object. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the object must be through the given name, and $data will remain set to the outer viewmodel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366e4820449d60904ec50a029f22f31fe805c045" translate="yes" xml:space="preserve">
          <source>The default component loader</source>
          <target state="translated">El cargador de componentes por defecto</target>
        </trans-unit>
        <trans-unit id="ce7b599739744a48558fac0535eb69108e550ffd" translate="yes" xml:space="preserve">
          <source>The default component loader supplies viewmodels/templates based on &lt;a href=&quot;component-registration&quot;&gt;what you have registered&lt;/a&gt;. If applicable, this is the phase where it requests any specified AMD modules from your AMD loader.</source>
          <target state="translated">El cargador de componentes predeterminado proporciona modelos de vista / plantillas seg&amp;uacute;n &lt;a href=&quot;component-registration&quot;&gt;lo que haya registrado&lt;/a&gt; . Si corresponde, esta es la fase en la que solicita los m&amp;oacute;dulos AMD espec&amp;iacute;ficos de su cargador AMD.</target>
        </trans-unit>
        <trans-unit id="09732649e70687aaf1c33ff6ca19f79f252c6c8b" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the template part of a component configuration into an array of DOM nodes. The nodes are then cached and cloned for each instance of the component.</source>
          <target state="translated">El cargador de componentes por defecto llamará a esta función en los cargadores registrados que lo declaren,para convertir la parte de la plantilla de una configuración de componentes en un array de nodos DOM.Los nodos se almacenan en caché y se clonan para cada instancia del componente.</target>
        </trans-unit>
        <trans-unit id="19ccce60a7742e398540647ff9062227dfd855b0" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the viewModel part of a component configuration into a createViewModel factory function. The function is then cached and called for each new instance of the component that needs a viewmodel.</source>
          <target state="translated">El cargador de componentes por defecto llamará a esta función en los cargadores registrados que la declaren,para convertir la parte viewModel de una configuración de componentes en una función de fábrica createViewModel.La función se almacena en caché y se llama para cada nueva instancia del componente que necesite un viewmodel.</target>
        </trans-unit>
        <trans-unit id="15dd6f7b5fcf81a774da95adae457614aaac160f" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadTemplate function that resolves a range of template configuration formats into DOM arrays.</source>
          <target state="translated">El propio cargador por defecto tiene una función loadTemplate que resuelve una serie de formatos de configuración de plantillas en matrices DOM.</target>
        </trans-unit>
        <trans-unit id="ead01d1120c6a1f313be5641ab191d173c3b1ccd" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadViewModel function that resolves a range of viewmodel configuration formats into createViewModel functions.</source>
          <target state="translated">El propio cargador por defecto tiene una función loadViewModel que resuelve una serie de formatos de configuración de modelos de visualización en funciones createViewModel.</target>
        </trans-unit>
        <trans-unit id="7897f3dd77b93db3f4074ec350ef4f1d3045faba" translate="yes" xml:space="preserve">
          <source>The default rate-limit method is different from the throttle algorithm. To match the throttle behavior, use the notifyWhenChangesStop method.</source>
          <target state="translated">El método del límite de la tasa por defecto es diferente del algoritmo del acelerador.Para igualar el comportamiento del acelerador,usa el método notifyWhenChangesStop.</target>
        </trans-unit>
        <trans-unit id="0e8110ec26b3e497db5167ef4c25bc7261c68f9a" translate="yes" xml:space="preserve">
          <source>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &amp;lsquo;person&amp;rsquo; objects by last name, you could write myObservableArray.sort(function (left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &amp;lt; right.lastName ? -1 : 1) })</source>
          <target state="translated">El orden predeterminado es alfab&amp;eacute;tico, pero opcionalmente puede pasar una funci&amp;oacute;n para controlar c&amp;oacute;mo se debe ordenar la matriz. Su funci&amp;oacute;n debe aceptar dos objetos cualesquiera de la matriz y devolver un valor negativo si el primer argumento es m&amp;aacute;s peque&amp;ntilde;o, un valor positivo es el segundo es m&amp;aacute;s peque&amp;ntilde;o o cero para tratarlos como iguales. Por ejemplo, para ordenar una matriz de objetos 'persona' por apellido, puede escribir myObservableArray.sort (function (left, right) {return left.lastName == right.lastName? 0: (left.lastName &amp;lt;right.lastName ? -1: 1)})</target>
        </trans-unit>
        <trans-unit id="59e06d0e5380901498a48d94a08b531cbe978874" translate="yes" xml:space="preserve">
          <source>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &amp;lsquo;person&amp;rsquo; objects by last name, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d097cb656bd9314287c368f7b582f51a1afa06" translate="yes" xml:space="preserve">
          <source>The destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:</source>
          <target state="translated">Las funciones &quot;destroy and destroyAll&quot; están pensadas principalmente como una conveniencia para los desarrolladores que utilizan Ruby on Rails:</target>
        </trans-unit>
        <trans-unit id="2dc38377602a5bf251c9ac8f8c358c2b61a483de" translate="yes" xml:space="preserve">
          <source>The disable binding causes the associated DOM element to be disabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="translated">El enlace de desactivación hace que el elemento DOM asociado se desactive sólo cuando el valor del parámetro es verdadero.Esto es útil con elementos de forma como input,select y textarea.</target>
        </trans-unit>
        <trans-unit id="034a88a2a8e70f61d5f53b00afb344cce6b30f2a" translate="yes" xml:space="preserve">
          <source>The element you attach a component binding to may contain further markup. For example,</source>
          <target state="translated">El elemento al que se adjunta un componente de unión puede contener más marcas.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="e3c15f42cf7a0908e29bc9f6fc045acec85c8dec" translate="yes" xml:space="preserve">
          <source>The enable binding causes the associated DOM element to be enabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="translated">La vinculación de habilitación hace que el elemento DOM asociado se habilite sólo cuando el valor del parámetro es verdadero.Esto es útil con elementos de forma como input,select y textarea.</target>
        </trans-unit>
        <trans-unit id="e51effe7f29b8c6485f6a0c6d2c659126917abb4" translate="yes" xml:space="preserve">
          <source>The enable binding causes the associated DOM element to be enabled when its parameter value is true. The disable binding works oppositely, causing the associated DOM element to be disabled when its value is true. These bindings are useful with form elements like input, select, and textarea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3a188f4389ae5361ef1aab713ad2e218776c5b" translate="yes" xml:space="preserve">
          <source>The event binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element. This can be used to bind to any event, such as keypress, mouseover or mouseout.</source>
          <target state="translated">La vinculación de eventos le permite añadir un manejador de eventos para un evento específico,de modo que la función de JavaScript elegida se invoque cuando se active ese evento para el elemento DOM asociado.Esto puede utilizarse para vincularse a cualquier evento,como pulsar una tecla,pasar el ratón por encima o dejar de lado el ratón.</target>
        </trans-unit>
        <trans-unit id="8c7fc29a628f445ae71ce6574a8f431c83b56907" translate="yes" xml:space="preserve">
          <source>The expression you wish to evaluate. For the if binding, if it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied; if your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it. For the ifnot binding, the behavior is reversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bb1049202e2fc471d173b4114d739d41bd5d4a" translate="yes" xml:space="preserve">
          <source>The expression you wish to evaluate. If it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied. If your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it.</source>
          <target state="translated">La expresión que desea evaluar.Si se evalúa a verdadero (o a un valor verdadero),la marca contenida estará presente en el documento,y se aplicará cualquier atributo de unión de datos en él.Si la expresión se evalúa en falso,la marca contenida se eliminará del documento sin aplicarle primero ningún tipo de enlace.</target>
        </trans-unit>
        <trans-unit id="08b6e9421ee0e5a90e98af3344e9a07e58b28e79" translate="yes" xml:space="preserve">
          <source>The first parameter says what view model object you want to use with the declarative bindings it activates</source>
          <target state="translated">El primer parámetro dice qué objeto del modelo de la vista quieres usar con los enlaces declarativos que activa</target>
        </trans-unit>
        <trans-unit id="b90ab49c50c0b034f2f0166f20a5588123515faf" translate="yes" xml:space="preserve">
          <source>The first time Knockout needs to construct a component with a given name, it:</source>
          <target state="translated">La primera vez que Knockout necesita construir un componente con un nombre determinado,él:</target>
        </trans-unit>
        <trans-unit id="49abc06d3a5bd2396f32cea388b57547fd21ef1f" translate="yes" xml:space="preserve">
          <source>The following custom loader will take care of loading templates configured with a fromUrl value:</source>
          <target state="translated">El siguiente cargador personalizado se encargará de cargar las plantillas configuradas con un valor fromUrl:</target>
        </trans-unit>
        <trans-unit id="3995f6c348f83c5d5d2c8c0c8d7c7c7dfb7c996e" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to construct and work with computed observables.</source>
          <target state="translated">La siguiente documentación describe cómo construir y trabajar con los observables computarizados.</target>
        </trans-unit>
        <trans-unit id="0271855925638e4b40f25932438e098db254cb45" translate="yes" xml:space="preserve">
          <source>The following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.</source>
          <target state="translated">El siguiente ejemplo muestra que,si su matriz es observable,la interfaz de usuario se mantendrá sincronizada con los cambios en esa matriz.</target>
        </trans-unit>
        <trans-unit id="9b0edc57c644719ae6f6c9285db552bc68ee184f" translate="yes" xml:space="preserve">
          <source>The following functions read and write the default component loader&amp;rsquo;s registry:</source>
          <target state="translated">Las siguientes funciones leen y escriben el registro del cargador de componentes predeterminado:</target>
        </trans-unit>
        <trans-unit id="c0549b512d611b4d61feda0a2b865a4445c3979c" translate="yes" xml:space="preserve">
          <source>The following functions work across the complete list of registered component loaders (not only the default loader):</source>
          <target state="translated">Las siguientes funciones funcionan en toda la lista de cargadores de componentes registrados (no sólo el cargador predeterminado):</target>
        </trans-unit>
        <trans-unit id="5e0d8a79330b00d1238373a646441103eff02bac" translate="yes" xml:space="preserve">
          <source>The following is a contrived example to demonstrate the ability of deferred updates to eliminate UI updates of intermediate values and how this can improve performance.</source>
          <target state="translated">A continuación se presenta un ejemplo artificioso para demostrar la capacidad de las actualizaciones diferidas para eliminar las actualizaciones de la interfaz de usuario de los valores intermedios y cómo esto puede mejorar el rendimiento.</target>
        </trans-unit>
        <trans-unit id="3c11fe6c92bb9852e1a3441bd3a5eaa04a0bf79f" translate="yes" xml:space="preserve">
          <source>The following live example shows how you could use this:</source>
          <target state="translated">El siguiente ejemplo en vivo muestra cómo se podría utilizar esto:</target>
        </trans-unit>
        <trans-unit id="fbe9e5e7430435e030bf8f72ddf5fd35ac54309f" translate="yes" xml:space="preserve">
          <source>The following markup:</source>
          <target state="translated">La siguiente marca:</target>
        </trans-unit>
        <trans-unit id="9a36c23f779b16430f2a073c5b148d24516e2493" translate="yes" xml:space="preserve">
          <source>The following model represents data that you could render as a paged grid:</source>
          <target state="translated">El siguiente modelo representa los datos que se podrían presentar como una cuadrícula paginada:</target>
        </trans-unit>
        <trans-unit id="b0852ae4081a5c612640e5df5209e727eefc9387" translate="yes" xml:space="preserve">
          <source>The following special variables are also available in bindings, but are not part of the binding context object:</source>
          <target state="translated">Las siguientes variables especiales también están disponibles en las encuadernaciones,pero no forman parte del objeto de contexto de la encuadernación:</target>
        </trans-unit>
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="translated">La encuadernación de la foreach duplica una sección de marcado para cada entrada de una matriz y vincula cada copia de ese marcado al elemento correspondiente de la matriz.Esto es especialmente útil para la representación de listas o tablas.</target>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="translated">La funci&amp;oacute;n que desea vincular al evento de clic del elemento.</target>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="translated">La funci&amp;oacute;n que desea vincular al evento de env&amp;iacute;o del elemento.</target>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="translated">El enlace hasFocus vincula el estado de enfoque de un elemento DOM con una propiedad viewmodel. Es un enlace bidireccional, entonces:</target>
        </trans-unit>
        <trans-unit id="6b84448b778b60f9904ec346700cdf0d607944c3" translate="yes" xml:space="preserve">
          <source>The hidden binding works oppositely&amp;mdash;when the parameter is true, it hides the element by setting the display style to none; and when the parameter is false, it removes the display style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="translated">El enlace html hace que el elemento DOM asociado muestre el HTML especificado por su parámetro.</target>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="translated">La vinculación &quot;if&quot; hace que una sección de marcado aparezca en el documento (y que se le apliquen sus atributos de vinculación de datos),sólo si una expresión especificada se evalúa como verdadera (o un valor verdadero como un objeto no nulo o una cadena no vacía).</target>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="translated">El enlace ifnot es exactamente el mismo que &lt;a href=&quot;if-binding&quot;&gt;el enlace if&lt;/a&gt; , excepto que invierte el resultado de cualquier expresi&amp;oacute;n que le pase. Para obtener m&amp;aacute;s detalles, consulte la documentaci&amp;oacute;n &lt;a href=&quot;if-binding&quot;&gt;del enlace if&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b925afaf6c73db524fb09147c998457d671b804" translate="yes" xml:space="preserve">
          <source>The ifnot binding works just like the if binding, except that it inverts the result of whatever expression you pass to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="translated">La matriz de ignorar que se especifica en las opciones de mapeo se combina con la matriz de ignorar por defecto.Puedes manipular esta matriz por defecto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="translated">La matriz de inclusión que se especifica en las opciones de mapeo se combina con la matriz de inclusión por defecto,que por defecto sólo contiene _destruir.Puedes manipular esta matriz por defecto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="translated">El índice del elemento de la matriz añadido</target>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="translated">El índice del elemento de la matriz movida</target>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="translated">El índice del elemento de la matriz eliminado</target>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="translated">La función indexOf devuelve el índice del primer elemento de la matriz que es igual a su parámetro.Por ejemplo,myObservableArray.indexOf('Blah')devolverá el índice de base cero de la primera entrada de la matriz que sea igual a Blah,o el valor -1 si no se encontró ningún valor que coincidiera.</target>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="translated">El elemento de opción insertado</target>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="translated">La funci&amp;oacute;n ko.ignoreDependencies est&amp;aacute; disponible para escenarios en los que desea ejecutar c&amp;oacute;digo dentro de un calculado que no deber&amp;iacute;a contribuir a las dependencias de ese calculado. Esto suele ser &amp;uacute;til en un enlace personalizado cuando desea llamar a un c&amp;oacute;digo que puede acceder a observables, pero no desea volver a activar el enlace en funci&amp;oacute;n de los cambios en esos observables.</target>
        </trans-unit>
        <trans-unit id="3b92b8d8bfa83e3158ebd9c44c77b03f552f6932" translate="yes" xml:space="preserve">
          <source>The let binding lets you set custom &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; properties that you can then reference in the bindings of all descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a260672088501d559448f92a0ce6366e87aebb" translate="yes" xml:space="preserve">
          <source>The main advantages of subscribing to changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057f946e0fbc4388b4cadbdea03e0218892b3f30" translate="yes" xml:space="preserve">
          <source>The main reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="translated">La matriz observable mapeada también expone una función mappedCreate:</target>
        </trans-unit>
        <trans-unit id="aa853229a04ee061c08286d3f3f9d23ede4d8580" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts any of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="translated">La opción de método controla cuando las notificaciones se disparan,y acepta los siguientes valores:</target>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="translated">El elemento de la matriz movida</target>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="translated">El objeto que quieres usar como contexto para unir elementos descendientes.</target>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">La matriz de observación que se especifica en las opciones de mapeo se combina con la matriz de observación por defecto,que por defecto está vacía.Puedes manipular esta matriz por defecto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="translated">La única razón para usar ifnot en lugar de un negado if es sólo una cuestión de gusto:muchos desarrolladores sienten que se ve más ordenado.</target>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="translated">El argumento de opciones suministrado a su llamada de creación es un objeto de JavaScript que contiene:</target>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="translated">El argumento de opciones suministrado a su llamada de actualización es un objeto de JavaScript que contiene:</target>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="translated">El enlace de opciones controla qu&amp;eacute; opciones deben aparecer en una lista desplegable (es decir, un elemento &amp;lt;select&amp;gt;) o una lista de selecci&amp;oacute;n m&amp;uacute;ltiple (por ejemplo, &amp;lt;seleccionar tama&amp;ntilde;o = '6'&amp;gt;). Este enlace no se puede utilizar con nada m&amp;aacute;s que elementos &amp;lt;select&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="translated">El otro truco ingenioso es que los enlaces declarativos se implementan simplemente como observables computarizados.Así,si una unión lee el valor de un observable,esa unión se vuelve dependiente de ese observable,lo que hace que esa unión sea reevaluada si el observable cambia.</target>
        </trans-unit>
        <trans-unit id="1e4ab2afdfa512feba70d54157853368ea9af9fa" translate="yes" xml:space="preserve">
          <source>The parameter value should be a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, the binding will update the classes whenever the value changes, removing any previously added classes and adding the class or classes from new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="translated">El c&amp;oacute;digo de modelo de vista anterior demuestra la &lt;em&gt;sintaxis de par&amp;aacute;metro &amp;uacute;nico&lt;/em&gt; para inicializar observables calculados. Consulte la &lt;a href=&quot;computed-reference&quot;&gt;referencia observable calculada&lt;/a&gt; para obtener la lista completa de opciones disponibles.</target>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="translated">El problema es que esto causar&amp;aacute; &lt;em&gt;dos&lt;/em&gt; solicitudes Ajax: la primera comenzar&amp;aacute; cuando actualice pageSize, y la segunda comenzar&amp;aacute; inmediatamente despu&amp;eacute;s cuando actualice pageIndex. Esto es un desperdicio de ancho de banda y recursos del servidor, y una fuente de condiciones de carrera impredecibles.</target>
        </trans-unit>
        <trans-unit id="b522befc4330a68fe68cf46705ab6afd4d8d2cc9" translate="yes" xml:space="preserve">
          <source>The provided callback will be run whenever the event is notified, &lt;em&gt;except if the node is empty&lt;/em&gt;. For the childrenComplete event, the function is called with two parameters, an array of child nodes and the child view model. The descendantsComplete callback function is called with just the parent node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="translated">La forma m&amp;aacute;s r&amp;aacute;pida y divertida de comenzar es trabajando con los &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;tutoriales interactivos&lt;/a&gt; . Una vez que se haya familiarizado con los conceptos b&amp;aacute;sicos, explore los &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;ejemplos en vivo&lt;/a&gt; y luego int&amp;eacute;ntelo en su propio proyecto.</target>
        </trans-unit>
        <trans-unit id="30c858124194194531fae54788b9b3bfb9b8913c" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;https://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="translated">El extensor rateLimit se puede aplicar a cualquier tipo de observable, incluidas &lt;a href=&quot;observablearrays&quot;&gt;matrices observables&lt;/a&gt; y &lt;a href=&quot;computedobservables&quot;&gt;observables calculadas&lt;/a&gt; . Los principales casos de uso para la limitaci&amp;oacute;n de velocidad son:</target>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="translated">La raz&amp;oacute;n por la que no debe utilizar un calculado &lt;em&gt;puro&lt;/em&gt; si el evaluador tiene efectos secundarios importantes es simplemente que el evaluador no se ejecutar&amp;aacute; siempre que el calculado no tenga suscriptores activos (y por lo tanto est&amp;aacute; durmiendo). Si es importante que el evaluador siempre se ejecute cuando cambian las dependencias, utilice un &lt;a href=&quot;computedobservables&quot;&gt;calculado regular en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="translated">El elemento de la matriz eliminado</target>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="translated">El resto de esta p&amp;aacute;gina describe las funciones de observableArray para leer y escribir informaci&amp;oacute;n de matriz.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">El resultado será:</target>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="translated">El objeto del módulo AMD devuelto puede estar en cualquiera de las formas permitidas para los modelos de visualización.Por lo tanto,puede ser una función constructora,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="translated">El objeto de m&amp;oacute;dulo AMD devuelto puede tener cualquiera de las formas permitidas para los modelos de vista. Por lo tanto, puede ser una cadena de marcado, por ejemplo, obtenido mediante &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;el complemento de texto require.js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="translated">El segundo par&amp;aacute;metro de ko.computed (el bit donde pasamos esto en el ejemplo anterior) define el valor de this al evaluar el observable calculado. Sin pasarlo, no habr&amp;iacute;a sido posible hacer referencia a this.firstName () o this.lastName (). Los codificadores de JavaScript experimentados lo considerar&amp;aacute;n obvio, pero si a&amp;uacute;n est&amp;aacute; familiariz&amp;aacute;ndose con JavaScript, puede parecer extra&amp;ntilde;o. (Los lenguajes como C # y Java nunca esperan que el programador establezca un valor para esto, pero JavaScript lo hace, porque sus funciones en s&amp;iacute; mismas no forman parte de ning&amp;uacute;n objeto por defecto).</target>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="translated">El enlace selectedOptions controla qu&amp;eacute; elementos de una lista de selecci&amp;oacute;n m&amp;uacute;ltiple est&amp;aacute;n seleccionados actualmente. Esto est&amp;aacute; destinado a ser utilizado junto con un elemento &amp;lt;select&amp;gt; y el enlace de opciones.</target>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="translated">El servidor podría devolver datos JSON similares a los siguientes:</target>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="translated">El valor taquigr&amp;aacute;fico tambi&amp;eacute;n puede ser observable. En este caso, si cambia, el enlace del componente &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;eliminar&amp;aacute;&lt;/a&gt; la instancia del componente anterior e inyectar&amp;aacute; el componente al que se hace referencia recientemente. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="translated">La función de rebanada es el equivalente observableArray de la función de rebanada nativa de JavaScript (es decir,devuelve las entradas de su matriz desde un índice de inicio determinado hasta un índice de fin determinado).Llamar a myObservableArray.slice(...)equivale a llamar al mismo método en la matriz subyacente (es decir,myObservableArray().slice(...)).</target>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="translated">El m&amp;eacute;todo est&amp;aacute;ndar para definir un observable calculado &lt;em&gt;puro&lt;/em&gt; es usar ko.pureComputed:</target>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="translated">La vinculación de estilo añade o elimina uno o más valores de estilo al elemento DOM asociado.Esto es útil,por ejemplo,para resaltar algún valor en rojo si se convierte en negativo,o para establecer el ancho de una barra para que coincida con un valor numérico que cambia.</target>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="translated">El enlace de envío añade un manejador de eventos para que la función de JavaScript elegida sea invocada cuando se envíe el elemento DOM asociado.Normalmente sólo querrás usar esto en los elementos del formulario.</target>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="translated">La función de suscripción acepta tres parámetros:callback es la función a la que se llama cada vez que se produce la notificación,target (opcional)define el valor de ésta en la función callback,y event (opcional;el valor por defecto es &quot;change&quot;)es el nombre del evento para el que se recibe la notificación.</target>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="translated">La funci&amp;oacute;n de suscripci&amp;oacute;n es cu&amp;aacute;ntas partes de KO funcionan internamente. La mayor&amp;iacute;a de las veces no es necesario usar esto, porque los enlaces integrados y el sistema de plantillas se encargan de administrar las suscripciones.</target>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="translated">La sintaxis es m&amp;aacute;s conveniente. Para llamar al m&amp;eacute;todo push de KO, simplemente escriba myObservableArray.push (...). Esto es un poco m&amp;aacute;s agradable que llamar al m&amp;eacute;todo push de la matriz subyacente escribiendo myObservableArray (). Push (...).</target>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="translated">La vinculación de la plantilla llena el elemento DOM asociado con los resultados de la renderización de una plantilla.Las plantillas son una forma simple y conveniente de construir sofisticadas estructuras de UI-posiblemente con bloques repetidos o anidados-en función de los datos de su modelo de vista.</target>
        </trans-unit>
        <trans-unit id="ca419c4cef8d81280ee9a194d266426d67669957" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or { element: &quot;someId&quot; } or a custom format such as { loadFromUrl: &quot;someUrl.html&quot; }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="translated">El valor de templateConfig es simplemente la propiedad de template de cualquier objeto componentConfig.Por ejemplo,puede contener &quot;alguna marca&quot; o {elemento:&quot;algúnId&quot;}o un formato personalizado como {cargarDeUrl:&quot;algúnUrl.html&quot;}.</target>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="translated">El enlace de texto hace que el elemento DOM asociado muestre el valor de texto de su parámetro.</target>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="translated">La encuadernación de textInput está diseñada específicamente para manejar una amplia gama de peculiaridades del navegador,para proporcionar actualizaciones de modelo consistentes e inmediatas incluso en respuesta a métodos de entrada de texto inusuales.</target>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="translated">El enlace textInput vincula un cuadro de texto (&amp;lt;input&amp;gt;) o un &amp;aacute;rea de texto (&amp;lt;textarea&amp;gt;) con una propiedad viewmodel, proporcionando actualizaciones bidireccionales entre la propiedad viewmodel y el valor del elemento. A diferencia del enlace de valores, textInput proporciona actualizaciones instant&amp;aacute;neas desde DOM para todos los tipos de entrada del usuario, incluidos los eventos de autocompletar, arrastrar y soltar y del portapapeles.</target>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="translated">El enlace uniqueName asegura que el elemento DOM asociado tiene un atributo de nombre no vacío.Si el elemento DOM no tiene un atributo de nombre,este enlace le da uno y lo establece a un valor de cadena único.</target>
        </trans-unit>
        <trans-unit id="ffad5e24eda165b5281cd7898585addd3dd621b6" translate="yes" xml:space="preserve">
          <source>The using binding was introduced in Knockout 3.5 as a replacement for with when re-rendering descendant elements isn&amp;rsquo;t desired. Because using re-evaluates descendant bindings instead of re-rendering, each descendant binding will include an additional dependency on the using context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="translated">El enlace de valor vincula el valor del elemento DOM asociado con una propiedad en su modelo de vista. Esto suele ser &amp;uacute;til con elementos de formulario como &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; y &amp;lt;textarea&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="translated">El valor del observable calculado no debe variar seg&amp;uacute;n el n&amp;uacute;mero de evaluaciones u otra informaci&amp;oacute;n &quot;oculta&quot;. Su valor debe basarse &amp;uacute;nicamente en los valores de otros observables en la aplicaci&amp;oacute;n, que para la definici&amp;oacute;n de funci&amp;oacute;n pura, se consideran sus par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="translated">El valor que asigne debe ser una matriz (o matriz observable). El elemento &amp;lt;select&amp;gt; mostrar&amp;aacute; un elemento para cada elemento de su matriz.</target>
        </trans-unit>
        <trans-unit id="36f23cd9c77e7cb60fe52409d6584a0d06a1e402" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as { myViewModelType: 'Something', options: {} }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="translated">El valor viewModelConfig es simplemente la propiedad viewModel de cualquier objeto componenteConfig.Por ejemplo,puede ser una función constructora,o un formato personalizado como {myViewModelType:'Algo',options:{}}.</target>
        </trans-unit>
        <trans-unit id="9d1d5f92e2fbae1ac4a6228b675e79f83cfdcae3" translate="yes" xml:space="preserve">
          <source>The visible and hidden bindings cause the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="translated">La unión visible hace que el elemento DOM asociado se oculte o se haga visible según el valor que se le pase a la unión.</target>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="translated">El objetivo de los observables es que se pueden observar, es decir, otro c&amp;oacute;digo puede decir que quiere ser notificado de los cambios. Eso es lo que muchos de los enlaces integrados de KO hacen internamente. Entonces, cuando escribi&amp;oacute; data-bind = &quot;text: personName&quot;, el enlace de texto se registr&amp;oacute; para ser notificado cuando cambia personName (asumiendo que es un valor observable, que es ahora).</target>
        </trans-unit>
        <trans-unit id="3f1f6f9b20e9fb3bb3210dbf3af9429326222e27" translate="yes" xml:space="preserve">
          <source>The with and using bindings create a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object. (The differences between these binding are described below under &lt;a href=&quot;#parameters&quot;&gt;Parameters&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="translated">El enlace with crea un nuevo &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; , de modo que los elementos descendientes se enlazan en el contexto de un objeto especificado.</target>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="translated">El con vinculante añadirá o quitará dinámicamente elementos descendientes dependiendo de si el valor asociado es nulo/indefinido o no</target>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="translated">Luego, con este objeto componentConfig, llama a cada una de las funciones loadComponent de los cargadores registrados a su vez, hasta que la primera proporcione un par template / createViewModel no nulo.</target>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="translated">Entonces,puedes usar la sintaxis jQuery.tmpl en tus plantillas.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="translated">Entonces,su función personalizada estará disponible en todos los valores de ese tipo creados a partir de ese punto.</target>
        </trans-unit>
        <trans-unit id="ef90eaff20a0b48ba01c7718ddb2303b2510f1e6" translate="yes" xml:space="preserve">
          <source>There are a few different methods to subscribe to these events depending on how and in which context you want to be notified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="translated">Hay dos formas principales de usar las plantillas:</target>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="translated">Hay dos maneras de usar el componente de unión:</target>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="translated">Existe una convenci&amp;oacute;n popular que evita la necesidad de rastrear esto por completo: si el constructor de su modelo de vista copia una referencia a esto en una variable diferente (tradicionalmente llamada self), entonces puede usar self en todo su modelo de vista y no tiene que preocuparse de que sea redefinido para referirse a otra cosa. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6450a2048f4541541638ab826b4b88f938c3d11d" translate="yes" xml:space="preserve">
          <source>These bindings differ in how they deal with a value of null or undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9ab8b7fe51fd19f340b30884a7d3b54127cb49" translate="yes" xml:space="preserve">
          <source>These events will generally be notified even if a node is empty. If the node&amp;rsquo;s contents are re-rendered, such as by a control-flow binding like &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, these events will be notified again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="translated">Estos ejemplos muestran que el valor puede ser pr&amp;aacute;cticamente cualquier expresi&amp;oacute;n de JavaScript. Incluso la coma est&amp;aacute; bien cuando est&amp;aacute; entre llaves, corchetes o par&amp;eacute;ntesis. Cuando el valor es un objeto literal, los nombres de las propiedades del objeto deben ser identificadores JavaScript v&amp;aacute;lidos o estar entre comillas. Si el valor de enlace es una expresi&amp;oacute;n no v&amp;aacute;lida o hace referencia a una variable desconocida, Knockout generar&amp;aacute; un error y detendr&amp;aacute; el procesamiento de enlaces.</target>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="translated">Estas funciones suelen ser &amp;uacute;tiles solo en escenarios avanzados, por ejemplo, cuando el prop&amp;oacute;sito principal de su observable calculado es desencadenar alg&amp;uacute;n efecto secundario durante su evaluador, y desea realizar alguna l&amp;oacute;gica de configuraci&amp;oacute;n solo durante la primera ejecuci&amp;oacute;n, o solo si tiene al menos una dependencia (y por lo tanto podr&amp;iacute;a reevaluarse en el futuro). A la mayor&amp;iacute;a de las propiedades calculadas no es necesario que les importe si se han evaluado antes o cu&amp;aacute;ntas dependencias tienen.</target>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="translated">Estas funciones auxiliares se pueden usar en controladores de eventos que se adjuntan discretamente usando algo como el enlace o clic de jQuery. La funci&amp;oacute;n anterior podr&amp;iacute;a adjuntarse a cada enlace con una clase de eliminaci&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="translated">Son funcionalmente equivalentes a las funciones regulares del ko.observableArray,pero pueden hacer cosas basadas en la clave del objeto.Por ejemplo,esto funcionaría:</target>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="translated">Funcionan en todos los navegadores espec&amp;iacute;ficos. (Por ejemplo, la funci&amp;oacute;n nativa de JavaScript indexOf no funciona en IE 8 o anterior, pero indexOf de KO funciona en todas partes).</target>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="translated">Este ejemplo de &quot;lista especial&quot; no hace m&amp;aacute;s que insertar un encabezado sobre cada elemento de la lista. Pero la misma t&amp;eacute;cnica se puede utilizar para crear sofisticadas cuadr&amp;iacute;culas, cuadros de di&amp;aacute;logo, conjuntos de pesta&amp;ntilde;as, etc., ya que todo lo que se necesita para tales elementos de la interfaz de usuario es un marcado de interfaz de usuario com&amp;uacute;n (por ejemplo, para definir la cuadr&amp;iacute;cula o el encabezado y los bordes del cuadro de di&amp;aacute;logo) envuelto alrededor de forma arbitraria. marcado proporcionado.</target>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="translated">Esta capacidad es especialmente &amp;uacute;til cuando se combina con el &lt;a href=&quot;binding-preprocessing&quot;&gt;preprocesamiento de enlaces&lt;/a&gt; , que puede asignar un valor predeterminado para un enlace.</target>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="translated">Esto permite una forma muy moderna, similar a &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt; , de organizar su c&amp;oacute;digo, al tiempo que conserva el soporte incluso para navegadores muy antiguos (consulte &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;elementos personalizados e IE 6 a 8&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="translated">Esto crea automáticamente propiedades observables para cada una de las propiedades de los datos.Luego,cada vez que se reciben nuevos datos del servidor,se pueden actualizar todas las propiedades en viewModel en un solo paso llamando nuevamente a la función ko.mapping.fromJS:</target>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="translated">Esto contiene una mezcla de observables,observables computarizados,conjuntos observables y valores simples.Puede convertirlo en una cadena JSON adecuada para enviar al servidor usando ko.toJSON de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="translated">Este doble desenvolvimiento sería feo,inconveniente e inesperado,así que Knockout automáticamente configura la propiedad computarizada generada (params.myExpr)para desenvolver su valor para ti.Es decir,el componente puede leer params.myExpr()para obtener el valor de cualquier observable que se haya seleccionado (observable1 u observable2),sin necesidad de un doble desenvolvimiento.</target>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="translated">Esto es fácil de hacer:sólo hay que añadir un parámetro adicional con las opciones de nombreCaption,siendo su valor una cadena a mostrar.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="translated">Este ejemplo crea un extensor que permite marcar un observable según se requiera.En lugar de devolver un nuevo objeto,este extensor simplemente añade subobservables adicionales al observable existente.Dado que los observables son funciones,pueden tener sus propias propiedades.Sin embargo,cuando el modelo de vista se convierte a JSON,los sub-observables serán eliminados y simplemente nos quedaremos con el valor de nuestro observable real.Esta es una buena manera de añadir funcionalidad adicional que sólo es relevante para la interfaz de usuario y no necesita ser enviada de vuelta al servidor.</target>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="translated">Este ejemplo crea un extensor que obliga a que la escritura de un observable sea redondeada numéricamente a un nivel de precisión configurable.En este caso,el extensor devolverá un nuevo observable computarizado que se sentará delante del observable real que intercepta las escrituras.</target>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="translated">Este ejemplo declara un componente y luego inyecta dos instancias de él en una vista.Véase el código fuente a continuación.</target>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="translated">Este ejemplo muestra enlaces &quot;agregar&quot; y &quot;eliminar&quot; en varios niveles de padres e hijos con un solo controlador adjunto discretamente para cada tipo de enlace.</target>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="translated">Este ejemplo muestra que el si vinculante puede añadir y eliminar dinámicamente secciones de marcado a medida que cambian los valores observables.</target>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="translated">Este ejemplo simplemente muestra un mensaje si el cuadro de texto tiene actualmente el foco,y utiliza un botón para mostrar que se puede activar el foco de forma programada.</target>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="translated">Este ejemplo utiliza foreach para producir una tabla de sólo lectura con una fila para cada entrada de la matriz.</target>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="translated">Esta funcionalidad se aplica a los errores en los siguientes contextos:</target>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="translated">Esto da el mismo resultado que incrustar una plantilla anónima directamente dentro del elemento que se utiliza para la aproximación,es decir:</target>
        </trans-unit>
        <trans-unit id="41e844da340b97cc893e368b759205db3d2224b9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object { id : 1, name : 'Alicw' } does not equal { id : 1, name : 'Alice' } it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="translated">Esto sucede porque, de forma predeterminada, el complemento de mapeo simplemente compara los dos objetos en la matriz. Y dado que en JavaScript el objeto {id: 1, name: 'Alicw'} no es igual a {id: 1, name: 'Alice'}, cree que el ni&amp;ntilde;o &lt;em&gt;completo&lt;/em&gt; debe ser eliminado y reemplazado por uno nuevo.</target>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="translated">Esto tiene exactamente el mismo resultado,sin necesidad de la clasificación de precios calculada observable.</target>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="translated">Este ejemplo interactivo lo demuestra:</target>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="translated">Esta es una limitaci&amp;oacute;n de la especificaci&amp;oacute;n HTML y est&amp;aacute; fuera del alcance de lo que Knockout puede controlar. Los analizadores HTML, siguiendo la especificaci&amp;oacute;n HTML, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignoran las barras diagonales que se cierran autom&amp;aacute;ticamente&lt;/a&gt; (excepto en una peque&amp;ntilde;a cantidad de &quot;elementos extra&amp;ntilde;os&quot; especiales, que est&amp;aacute;n codificados en el analizador). HTML no es lo mismo que XML.</target>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="translated">Esta es una matriz que representa todos los modelos de vista de los padres:</target>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="translated">Así es como se pueden pasar las propiedades de un modelo de vista de padre a un componente de hijo.Si las propiedades en sí son observables,entonces el modelo de vista padre podrá observar y reaccionar a cualquier nuevo valor insertado en ellas por el componente hijo.</target>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="translated">Esto es principalmente &amp;uacute;til si tiene varios niveles de bloques foreach anidados, porque le brinda una forma inequ&amp;iacute;voca de referirse a cualquier elemento nombrado declarado en un nivel superior en la jerarqu&amp;iacute;a. Aqu&amp;iacute; hay un ejemplo completo, que muestra c&amp;oacute;mo se puede hacer referencia a la temporada mientras se renderiza un mes:</target>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="translated">Esto es principalmente &amp;uacute;til cuando est&amp;aacute; obteniendo el marcado de alg&amp;uacute;n lugar mediante programaci&amp;oacute;n (por ejemplo, &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD, ver m&amp;aacute;s abajo&lt;/a&gt; ), o como una salida del sistema de compilaci&amp;oacute;n que empaqueta componentes para su distribuci&amp;oacute;n, ya que no es muy conveniente editar HTML manualmente como una cadena de JavaScript literal.</target>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="translated">Este es el elemento objeto DOM (para los elementos virtuales,será el objeto DOM comentario)de la vinculación actual.Esto puede ser útil si una vinculación necesita acceder a un atributo del elemento actual.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="translated">Esto es exactamente lo contrario del ejemplo de &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; , ya que aqu&amp;iacute; el nombre y los apellidos no se pueden editar, pero el nombre completo combinado s&amp;iacute; se puede editar.</target>
        </trans-unit>
        <trans-unit id="e3a2757d58a0119bd192fdc042c0cb6c3f74c81a" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;https://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="translated">Este es el objeto del modelo de vista principal en el contexto ra&amp;iacute;z, es decir, el contexto principal superior. Por lo general, es el objeto que se pas&amp;oacute; a ko.applyBindings. Es equivalente a $ parent [$ parent.length - 1].</target>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="translated">Esta es la imagen reflejada del enlace enable. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la &lt;a href=&quot;enable-binding&quot;&gt;documentaci&amp;oacute;n sobre el enlace enable&lt;/a&gt; , porque disable funciona exactamente de la misma manera, excepto que niega cualquier par&amp;aacute;metro que le pase.</target>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="translated">Este es el valor del modelo de vista en bruto en el contexto actual.Normalmente será el mismo que $data,pero si el modelo de vista proporcionado a Knockout está envuelto en un observable,$data será el modelo de vista sin envolver,y $rawData será el observable en sí.</target>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="translated">Este es el objeto modelo de la vista en el contexto actual.En el contexto raíz,$data y $root son equivalentes.Dentro de un contexto de vinculación anidado,este parámetro se establecerá en el elemento de datos actual (por ejemplo,dentro de un con:vinculación de persona,$data se establecerá en persona).$data es útil cuando se quiere hacer referencia al propio modelo de visualización,en lugar de a una propiedad del modelo de visualización.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="translated">Este es el objeto modelo de la vista en el contexto padre,el que está inmediatamente fuera del contexto actual.En el contexto raíz,esto no está definido.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">Este es el índice de base cero de la entrada de la matriz actual que se está produciendo por una unión de la matriz.A diferencia de las demás propiedades de contexto de la vinculación,$index es un observable y se actualiza siempre que el índice del elemento cambia (por ejemplo,si se añaden o se quitan elementos de la matriz).</target>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="translated">Esto es &amp;uacute;til si desea crear componentes que representen elementos de IU de &quot;contenedor&quot;, como cuadr&amp;iacute;culas, listas, cuadros de di&amp;aacute;logo o conjuntos de pesta&amp;ntilde;as, que necesitan inyectar y vincular marcas arbitrarias en una estructura com&amp;uacute;n. Vea &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;un ejemplo completo de elementos personalizados&lt;/a&gt; , que tambi&amp;eacute;n funciona sin elementos personalizados utilizando la sintaxis que se muestra arriba.</target>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="translated">Esto es &amp;uacute;til si est&amp;aacute; creando formularios sofisticados en los que los elementos editables aparecen din&amp;aacute;micamente y desea controlar d&amp;oacute;nde el usuario debe comenzar a escribir o responder a la ubicaci&amp;oacute;n del signo de intercalaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="translated">Esto es &amp;uacute;til, por ejemplo, si la plantilla de un componente incluye uno o m&amp;aacute;s bloques foreach en los que desea hacer referencia a alguna propiedad o funci&amp;oacute;n en el modelo de vista del componente en lugar de en el elemento de datos actual.</target>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="translated">Esto es muy simple y elegante (y es trivial agregar a&amp;uacute;n m&amp;aacute;s par&amp;aacute;metros de consulta observables que tambi&amp;eacute;n activan una actualizaci&amp;oacute;n autom&amp;aacute;ticamente cada vez que cambian), pero existe un posible problema de eficiencia. Suponga que agrega la siguiente funci&amp;oacute;n a GridViewModel que cambia tanto pageIndex como pageSize:</target>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="translated">Esto significa que si se definió giftWrap con el estado inicial falso (es decir,giftWrap:ko.observable(false)),entonces el DIV asociado se ocultaría inicialmente,y luego se deslizaría a la vista cuando el usuario marcara la casilla más tarde.</target>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="translated">Este es m&amp;aacute;s complicado. La expresi&amp;oacute;n en s&amp;iacute;, cuando se eval&amp;uacute;a, lee un observable. El valor de ese observable podr&amp;iacute;a cambiar con el tiempo, por lo que el resultado de la expresi&amp;oacute;n podr&amp;iacute;a cambiar con el tiempo.</target>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="translated">Este patr&amp;oacute;n es beneficioso para aplicaciones grandes, ya que &lt;strong&gt;simplifica el desarrollo a&lt;/strong&gt; trav&amp;eacute;s de una organizaci&amp;oacute;n y encapsulaci&amp;oacute;n claras, y ayuda a &lt;strong&gt;mejorar el rendimiento en tiempo de ejecuci&amp;oacute;n&lt;/strong&gt; al cargar gradualmente el c&amp;oacute;digo y las plantillas de la aplicaci&amp;oacute;n seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="translated">Esta fase siempre se completa sincr&amp;oacute;nicamente (no se permite que los constructores y las funciones de f&amp;aacute;brica sean asincr&amp;oacute;nicas), ya que ocurre &lt;em&gt;cada vez que se crea una instancia de un componente&lt;/em&gt; y el rendimiento ser&amp;iacute;a inaceptable si implicara esperar solicitudes de red.</target>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="translated">Esto se refiere al objeto de contexto de enlace en el nivel principal. Esto es diferente de $ parent, que se refiere a los &lt;em&gt;datos&lt;/em&gt; (no al contexto vinculante) en el nivel principal. Esto es &amp;uacute;til, por ejemplo, si necesita acceder al valor de &amp;iacute;ndice de un elemento foreach externo desde un contexto interno (uso: $ parentContext. $ Index). Esto no est&amp;aacute; definido en el contexto ra&amp;iacute;z.</target>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="translated">Esto se refiere al actual objeto de contexto vinculante.Esto puede ser útil si desea acceder a propiedades del contexto cuando también podrían existir en el modelo de vista,o si desea pasar el objeto de contexto a una función de ayuda en su modelo de vista.</target>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="translated">Esto devuelve un nuevo valor calculado que proporciona una vista filtrada de la matriz,mientras que deja la matriz original sin cambios.Dado que la matriz filtrada es un observable computarizado,será reevaluado cada vez que la matriz subyacente cambie.</target>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="translated">Este debería ser un escenario muy inusual,así que normalmente no necesitarás trabajar con $raw.</target>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="translated">Debe ser una matriz (o una matriz observable). KO establece las opciones seleccionadas del elemento para que coincidan con el contenido de la matriz. Se sobrescribir&amp;aacute; cualquier estado de selecci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="translated">Este sencillo extensor de logChange se suscribe al observable y utiliza la consola para escribir cualquier cambio junto con un mensaje configurable.</target>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="translated">Esta t&amp;eacute;cnica tambi&amp;eacute;n es posible cuando se utilizan componentes &lt;em&gt;sin&lt;/em&gt; elementos personalizados, es decir, se &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;pasa el marcado cuando se utiliza el enlace de componentes directamente&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="translated">Este enlace actualizado conPropiedades ahora puede ser usado de forma anidada,con cada nivel de anidación capaz de acceder al nivel de padres a través de $contexto de padres:</target>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="translated">Esto usa el &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;complemento brfs Browserify para insertar&lt;/a&gt; autom&amp;aacute;ticamente el archivo .html, por lo que necesitar&amp;iacute;a crear el archivo de secuencia de comandos con un comando similar a:</target>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="translated">De esta manera,cada vez que el plugin de mapeo compruebe un elemento en la matriz de hijos,sólo mirará la propiedad id para determinar si un objeto fue reemplazado completamente o si simplemente necesita ser actualizado.</target>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="translated">Esto agregar&amp;aacute; la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada proporcionada a la cola de microtask. Knockout incluye una cola de tareas r&amp;aacute;pida que ejecuta las tareas en orden FIFO hasta que la cola est&amp;aacute; vac&amp;iacute;a. Cuando se programe la primera tarea, Knockout programar&amp;aacute; un evento de descarga utilizando el &lt;a href=&quot;#implementation&quot;&gt;soporte de microtask del navegador&lt;/a&gt; si es posible. Esto asegura que la primera tarea y las tareas posteriores se comporten de manera similar.</target>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="translated">¡Esto alertará a Grahamfoo!.</target>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="translated">Esto aplicará la clase CSS profitPositive cuando el valor de currentProfit sea positivo,de lo contrario aplicará la clase CSS profitWarning.</target>
        </trans-unit>
        <trans-unit id="6d682cf2301f953dbc0cbb0bf8b714c7ce4cac31" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive; otherwise it will apply the profitWarning CSS class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="translated">Esto aplicará la clase CSS profitWarning siempre que el valor de currentProfit caiga por debajo de cero,y eliminará esa clase siempre que pase por encima de cero.</target>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="translated">Esta ser&amp;aacute; la instancia &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; declarada en el modelo de vista principal como myObservable. No es un contenedor, es la misma instancia real a la que hace referencia el padre. Entonces, si el modelo de vista secundario escribe en este observable, el modelo de vista principal recibir&amp;aacute; ese cambio.</target>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="translated">Este será el valor numérico 2.No será un valor observable o calculado,ya que no hay observables involucrados.</target>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="translated">Esto crear&amp;aacute; un objeto sin asignar que contiene solo las propiedades del objeto asignado que formaban parte de su objeto JS original. En otras palabras, se ignoran todas las propiedades o funciones que haya agregado manualmente a su modelo de vista. De forma predeterminada, la &amp;uacute;nica excepci&amp;oacute;n a esta regla es la propiedad _destroy, que tambi&amp;eacute;n se volver&amp;aacute; a asignar, porque es una propiedad que Knockout puede generar cuando destruye un elemento de un ko.observableArray. Consulte la secci&amp;oacute;n &quot;Uso avanzado&quot; para obtener m&amp;aacute;s detalles sobre c&amp;oacute;mo configurar esto.</target>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="translated">Esto establecer&amp;aacute; el atributo href del elemento en year-end.html y el atributo de t&amp;iacute;tulo del elemento en Informe, incluidas las estad&amp;iacute;sticas finales de fin de a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="translated">Esto establecer&amp;aacute; la propiedad style.color del elemento en rojo siempre que el valor currentProfit caiga por debajo de cero y en negro cuando supere el cero.</target>
        </trans-unit>
        <trans-unit id="3b1cd0e6a2217c74948bf4211011886cf75676fa" translate="yes" xml:space="preserve">
          <source>This works because {{each ...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="translated">Esto funciona porque {{each ...}} y $ {...} son sintaxis jQuery.tmpl. Adem&amp;aacute;s, es trivial anidar plantillas: debido a que puede usar atributos de enlace de datos desde el interior de una plantilla, simplemente puede poner un enlace de datos = &quot;plantilla: ...&quot; dentro de una plantilla para representar una anidada.</target>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="translated">Esto funciona muy bien con los elementos DOM regulares.Los siguientes elementos se mezclarán en un orden aleatorio:</target>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">Consejo: recuerde pasar un &lt;em&gt;valor literal de cadena&lt;/em&gt; a as (por ejemplo, como: 'categor&amp;iacute;a', &lt;em&gt;no&lt;/em&gt; como: categor&amp;iacute;a), porque est&amp;aacute; dando un nombre para una nueva variable, no leyendo el valor de una variable que ya existe.</target>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">Consejo: recuerde pasar un &lt;em&gt;valor literal de cadena&lt;/em&gt; a as (por ejemplo, como: 'temporada', &lt;em&gt;no&lt;/em&gt; como: temporada), porque est&amp;aacute; dando un nombre para una nueva variable, no leyendo el valor de una variable que ya existe.</target>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="translated">Para &lt;strong&gt;leer&lt;/strong&gt; el valor actual del observable, simplemente llame al observable sin par&amp;aacute;metros. En este ejemplo, myViewModel.personName () devolver&amp;aacute; 'Bob' y myViewModel.personAge () devolver&amp;aacute; 123.</target>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="translated">Para &lt;strong&gt;escribir&lt;/strong&gt; un nuevo valor al observable, llame al observable y pase el nuevo valor como par&amp;aacute;metro. Por ejemplo, llamar a myViewModel.personName ('Mary') cambiar&amp;aacute; el valor del nombre a 'Mary'.</target>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="translated">Para activar Knockout, agregue la siguiente l&amp;iacute;nea a un bloque &amp;lt;script&amp;gt;:</target>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="translated">Para adjuntar una función personalizada,agréguela a uno de los siguientes puntos de extensibilidad:</target>
        </trans-unit>
        <trans-unit id="266ba5487281979f5f750daeadee12340bd8ff01" translate="yes" xml:space="preserve">
          <source>To be notified in a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt;, you can register a callback function within the component&amp;rsquo;s createViewModel method. Be sure to dispose the subscription within your component&amp;rsquo;s dispose function as well, since a component may be disposed and re-created on the same element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7153140a8c0457153388555a5a5e74ad80e0326" translate="yes" xml:space="preserve">
          <source>To be notified in your view model, bind your callback function to the event through the node&amp;rsquo;s data-bind. Pass a function reference (either a function literal or the name of a function on your view model), and Knockout will invoke it when that event is notified. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="translated">Para comprobar si una propiedad es observable,computarizada,etc.,utilice el siguiente conjunto de funciones:</target>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="translated">Para crear un modelo de vista a través del plugin de mapeo,reemplace la creación de viewModel en el código anterior por la función ko.mapping.fromJS:</target>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="translated">Para crear un modelo de vista con KO,sólo hay que declarar cualquier objeto de JavaScript.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="4d72b444e4e76be69a061cb2a516752a354ce7c2" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="translated">Para ello,adjunte una función de preprocesamiento al manipulador de encuadernación:</target>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="translated">Para ello,defina una función de preprocessNode en su proveedor de vinculación:</target>
        </trans-unit>
        <trans-unit id="474f546cba1324754eedaae0ff4ea7e4b00b8b61" translate="yes" xml:space="preserve">
          <source>To do this, simply return { controlsDescendantBindings: true } from your binding&amp;rsquo;s init function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="translated">Para hacer esto, simplemente devuelva {controlsDescendantBindings: true} de la funci&amp;oacute;n de inicio de su enlace.</target>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="translated">Para asegurarse de que el componente hijo pueda reaccionar a los cambios en el valor de la expresi&amp;oacute;n, Knockout &lt;strong&gt;actualiza autom&amp;aacute;ticamente este par&amp;aacute;metro a una propiedad calculada&lt;/strong&gt; . Entonces, el componente hijo podr&amp;aacute; leer params.observableExpression () para obtener el valor actual, o usar params.observableExpression.subscribe (...), etc.</target>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="translated">Para asegurar que los suscriptores sean siempre notificados de una actualización,incluso si el valor es el mismo,se usaría el extensor de notificación:</target>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="translated">Para comenzar, aqu&amp;iacute; hay un enlace personalizado que aleatoriza el orden de los nodos DOM:</target>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="translated">Para comenzar, puede registrar un componente usando ko.components.register (t&amp;eacute;cnicamente, el registro es opcional, pero es la forma m&amp;aacute;s f&amp;aacute;cil de comenzar). Una definici&amp;oacute;n de componente especifica un viewModel y una plantilla. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">Para manejar esto, puede usar la &lt;em&gt;sintaxis de flujo de control sin contenedor&lt;/em&gt; , que se basa en etiquetas de comentarios. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="translated">Para manejar esto, puede usar la &lt;em&gt;sintaxis sin contenedor&lt;/em&gt; , que se basa en etiquetas de comentarios.</target>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="translated">Para implementar una convención de nombres,su cargador de componentes personalizados sólo necesita implementar getConfig.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="translated">Para facilitar la serialización de los datos de los modelos,incluyendo observables y similares,Knockout incluye dos funciones de ayuda:</target>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="translated">Para registrar una encuadernación,agréguela como subpropiedad de ko.bindingHandlers:</target>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="translated">Para registrar una función que se ejecute cuando se elimina un nodo,puedes llamar a ko.utils.domNodeDisposal.addDisposeCallback(nodo,llamada de retorno).Como ejemplo,supongamos que creas un enlace personalizado para instanciar un widget.Cuando se elimina el elemento con el enlace,puede que quieras llamar al método destroy del widget:</target>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="translated">Registrar cualquier manejador de eventos para que,por ejemplo,cuando el usuario haga clic o modifique el elemento DOM,pueda cambiar el estado del observable asociado</target>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="translated">Para ver c&amp;oacute;mo puede vincular observableArray a una interfaz de usuario y dejar que el usuario la modifique, vea &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;el ejemplo de lista simple&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92ad28c02d4910b0d510a9bd45377e509f33c2cd" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;https://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="translated">Para que esto surta efecto, aqu&amp;iacute; hay un ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="translated">Para establecer cualquier estado inicial para el elemento DOM</target>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="translated">Para resolver esto,puede especificar qué tecla debe usar el plugin de mapeo para determinar si un objeto es nuevo o viejo.Lo configurarías así:</target>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="translated">Para resumir: KO no compite con jQuery o API DOM de bajo nivel similares. KO proporciona una forma complementaria y de alto nivel de vincular un modelo de datos a una interfaz de usuario. El KO en s&amp;iacute; no depende de jQuery, pero ciertamente puede usar jQuery al mismo tiempo, y de hecho, a menudo es &amp;uacute;til si desea cosas como transiciones animadas.</target>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="translated">Para suministrar una configuración,llame al callback(componentConfig),donde componentConfig es cualquier objeto que pueda ser comprendido por la función loadComponent en su cargador o en cualquier otro cargador.El cargador por defecto simplemente suministra cualquier objeto que haya sido registrado usando ko.components.register.</target>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="translated">Para suministrar una función de crearModeloVer,llame de vuelta (su función de crearModeloVer).La función createViewModel debe aceptar parámetros (parámetros,componenteInfo)y debe devolver de forma sincronizada una nueva instancia de viewmodel cada vez que se llame.</target>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="translated">Para suministrar un par de modelo de vista/plantilla,llame a callback(result),donde result es un objeto con las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="translated">Para suministrar un conjunto de nodos DOM,llame a callback(domNodeArray).</target>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="translated">Para suministrar parámetros al componente,pase un objeto con las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="translated">Para escribir valores en &lt;strong&gt;varias propiedades observables&lt;/strong&gt; en un objeto de modelo, puede utilizar la &lt;em&gt;sintaxis de encadenamiento&lt;/em&gt; . Por ejemplo, myViewModel.personName ('Mary'). PersonAge (50) cambiar&amp;aacute; el valor del nombre a 'Mary' &lt;em&gt;y&lt;/em&gt; el valor de la edad a 50.</target>
        </trans-unit>
        <trans-unit id="aafe7d418233e4542cf2fcd1a4855d69c306f6ec" translate="yes" xml:space="preserve">
          <source>Tracking array changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="translated">Activaci&amp;oacute;n de la validaci&amp;oacute;n a nivel de IU usando una biblioteca como &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt; , usando un c&amp;oacute;digo similar al siguiente fragmento: if ($ (formElement) .valid ()) {/ * hacer algo * /}.</target>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="translated">Pruébalo:</target>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="translated">Pruébalo:</target>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="translated">Dos puntos a tener en cuenta sobre este ejemplo:</target>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="translated">Dos cosas han pasado aquí:el nombre fue cambiado de Scot a Scott y el nombre de children[0].name fue cambiado de Alicw a la Alice sin errores de imprenta.Puedes actualizar viewModel basándote en estos nuevos datos:</target>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="translated">Normalmente,esto es útil cuando los valores del modelo de visualización son en realidad cadenas de marcas HTML que desea renderizar.</target>
        </trans-unit>
        <trans-unit id="a45dab66b5b0fb7b4755a5854f26fe1fcf88c6ca" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render. If you know your view model value is plain text, use the more efficient &lt;a href=&quot;text-binding&quot;&gt;text binding&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="translated">Normalmente, esto es &amp;uacute;til con elementos como &amp;lt;span&amp;gt; o &amp;lt;em&amp;gt; que tradicionalmente muestran texto, pero t&amp;eacute;cnicamente puede usarlo con cualquier elemento.</target>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="translated">Normalmente, solo querr&amp;aacute; utilizar optionsValue como una forma de asegurarse de que KO pueda retener correctamente la selecci&amp;oacute;n cuando actualice el conjunto de opciones disponibles. Por ejemplo, si recibe repetidamente una lista de objetos &quot;coche&quot; a trav&amp;eacute;s de llamadas Ajax y desea asegurarse de que el coche seleccionado se conserva, es posible que deba establecer optionsValue en &quot;carId&quot; o cualquier identificador &amp;uacute;nico que tenga cada objeto &quot;coche&quot;. , de lo contrario, KO no sabr&amp;aacute; necesariamente cu&amp;aacute;l de los objetos de &quot;coche&quot; anteriores corresponde a cu&amp;aacute;l de los nuevos.</target>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="translated">Identificar objetos de forma &amp;uacute;nica mediante &quot;claves&quot;</target>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="translated">Sin embargo, a diferencia de algunos lenguajes de programaci&amp;oacute;n m&amp;aacute;s tradicionales, la iteraci&amp;oacute;n actual de JavaScript (ECMA-262) no proporciona a los desarrolladores los medios para importar dichos m&amp;oacute;dulos de c&amp;oacute;digo de una manera limpia y organizada. Es una de las preocupaciones con las especificaciones que no han requerido una gran reflexi&amp;oacute;n hasta a&amp;ntilde;os m&amp;aacute;s recientes, donde se hizo evidente la necesidad de aplicaciones JavaScript m&amp;aacute;s organizadas.</target>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="translated">Actualizando los datos del modelo de vista usando JSON</target>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="translated">Use clearInterval(manija)para detenerlos,de lo contrario su modelo de visión podría ser retenido en la memoria.</target>
        </trans-unit>
        <trans-unit id="a36cf2b849979ba4930b9f37292d09e3fcaa008a" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;as&amp;rdquo; without creating a child context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="translated">Usando un observable computarizado</target>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="translated">Usando un observable computarizado para ejecutar una llamada basada en múltiples observables.</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">Usando elementos personalizados</target>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="translated">El uso de actualizaciones diferidas garantiza que los enlaces y observables calculados se actualicen solo despu&amp;eacute;s de que sus dependencias sean estables. Incluso si un observable puede pasar por m&amp;uacute;ltiples valores intermedios, solo se usa el &amp;uacute;ltimo valor para actualizar sus dependencias. Para facilitar esto, todas las notificaciones se vuelven asincr&amp;oacute;nicas y se programan utilizando la &lt;a href=&quot;microtasks&quot;&gt;cola de microtask Knockout&lt;/a&gt; . Esto puede parecer muy similar a &lt;a href=&quot;ratelimit-observable&quot;&gt;la limitaci&amp;oacute;n de velocidad&lt;/a&gt; , que tambi&amp;eacute;n ayuda a evitar notificaciones adicionales, pero las actualizaciones diferidas pueden brindar estos beneficios en toda la aplicaci&amp;oacute;n sin agregar demoras. A continuaci&amp;oacute;n, se muestra c&amp;oacute;mo la programaci&amp;oacute;n de notificaciones difiere entre los modos est&amp;aacute;ndar, diferido y con tarifa limitada:</target>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="translated">Uso de actualizaciones diferidas para observables específicos</target>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="translated">Uso de extensores para aumentar los observables</target>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="translated">Usando el componente de unión</target>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="translated">Usando el contexto computarizado</target>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="translated">Usando manejadores de eventos discretos</target>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="translated">Usando valueAllowUnset con elementos &amp;lt;select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="translated">Los modelos de visualización pueden ser especificados en cualquiera de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="translated">API de elementos virtuales</target>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="translated">Elementos virtuales</target>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="translated">Hemos tomado prestado el t&amp;eacute;rmino de &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;funciones puras&lt;/a&gt; porque esta caracter&amp;iacute;stica generalmente solo es aplicable para observables calculados cuyo evaluador es una &lt;em&gt;funci&amp;oacute;n pura de la&lt;/em&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; sucede si tiene un &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; para firstName y otro para lastName, y desea mostrar el nombre completo? Ah&amp;iacute; es donde entran los &lt;em&gt;observables calculados&lt;/em&gt; : estas son funciones que dependen de uno o m&amp;aacute;s observables y se actualizar&amp;aacute;n autom&amp;aacute;ticamente cada vez que cambie alguna de estas dependencias.</target>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="translated">Lo que tiende a ser más útil en la práctica es la creación de módulos AMD que tengan clases de modelos de visualización en línea,y que tomen explícitamente las dependencias de AMD en archivos de plantillas externas.</target>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">Cu&amp;aacute;ndo &lt;em&gt;no&lt;/em&gt; utilizar un observable calculado &lt;em&gt;puro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b6c9e2cbc279de2e5c3e0969a9438b76e2aa2e" translate="yes" xml:space="preserve">
          <source>When Knockout renders a foreach binding with the parameter includeDestroyed: false set, it will hide any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="translated">Cuando la unión de un componente inyecta un componente,</target>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="translated">Cuando un observable calculado devuelve un valor primitivo (un n&amp;uacute;mero, cadena, booleano o nulo), las dependencias del observable normalmente solo se notifican si el valor realmente cambi&amp;oacute;. Sin embargo, es posible utilizar el &lt;a href=&quot;extenders&quot;&gt;extensor de&lt;/a&gt; notificaci&amp;oacute;n incorporado para garantizar que los suscriptores de un observable calculado sean siempre notificados sobre una actualizaci&amp;oacute;n, incluso si el valor es el mismo. Aplicar&amp;iacute;a el extensor de esta manera:</target>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="translated">Cuando se aplica a un observable calculado, el extensor diferido tambi&amp;eacute;n evitar&amp;aacute; una evaluaci&amp;oacute;n excesiva de la funci&amp;oacute;n calculada. El uso de actualizaciones diferidas garantiza que cualquier secuencia de cambios en las dependencias en la tarea actual desencadenar&amp;aacute; &lt;em&gt;una&lt;/em&gt; sola reevaluaci&amp;oacute;n del observable calculado. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="translated">Al llamar a su controlador, Knockout proporcionar&amp;aacute; el valor del modelo actual como primer par&amp;aacute;metro. Esto es particularmente &amp;uacute;til si est&amp;aacute; renderizando alguna interfaz de usuario para cada elemento de una colecci&amp;oacute;n y necesita saber a qu&amp;eacute; elemento se refiere el evento. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="translated">Al llamar a su controlador, Knockout proporcionar&amp;aacute; el valor del modelo actual como primer par&amp;aacute;metro. Esto es particularmente &amp;uacute;til si est&amp;aacute; renderizando alguna interfaz de usuario para cada elemento de una colecci&amp;oacute;n y necesita saber en qu&amp;eacute; interfaz de usuario se hizo clic. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="translated">Al convertir su modelo de vista de nuevo a un objeto JS, de forma predeterminada, el complemento de mapeo crear&amp;aacute; observables seg&amp;uacute;n las reglas explicadas &lt;a href=&quot;#how-things-are-mapped&quot;&gt;anteriormente&lt;/a&gt; . Si desea forzar que el complemento de mapeo simplemente copie la propiedad en lugar de hacerla observable, agregue su nombre a la matriz &quot;copiar&quot;:</target>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="translated">Al convertir su modelo de vista de nuevo a un objeto JS,por defecto el plugin de mapeo sólo incluirá las propiedades que eran parte de su modelo de vista original,excepto que también incluirá la propiedad Knockout-generada _destroy aunque no fuera parte de su objeto original.Sin embargo,puedes elegir personalizar este arreglo:</target>
        </trans-unit>
        <trans-unit id="34c7ddb2d85f70c9b78ff4ca6c7fb87b8a5a8a76" translate="yes" xml:space="preserve">
          <source>When items are re-ordered, as shown in the last example above, you will also get &lt;em&gt;moved&lt;/em&gt; information. You can choose to ignore the &lt;em&gt;moved&lt;/em&gt; information and just interpret it as the original Alpha being deleted and a different Alpha being added to the array&amp;rsquo;s end. Or you can recognize that the &lt;em&gt;moved&lt;/em&gt; information tells you that you can think of the &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values being the same item that just changes position (by matching up the indexes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="translated">Al anidar plantillas de foreach, a menudo es &amp;uacute;til hacer referencia a elementos en niveles superiores en la jerarqu&amp;iacute;a. Una forma de hacer esto es hacer referencia a $ parent u otras variables de &lt;a href=&quot;binding-context&quot;&gt;contexto vinculantes&lt;/a&gt; en sus vinculaciones.</target>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="translated">Cuando se presenta al usuario una lista de elementos seleccionables,suele ser útil incluir un método para seleccionar o deseleccionar todos los elementos.Esto puede representarse de manera bastante intuitiva con un valor booleano que representa si todos los elementos están seleccionados.Cuando se establece en true,seleccionará todos los elementos,y cuando se establece en false,los deseleccionará.</target>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="translated">Al eliminar un elemento, Knockout ejecuta la l&amp;oacute;gica para limpiar cualquier dato asociado con el elemento. Como parte de esta l&amp;oacute;gica, Knockout llama al m&amp;eacute;todo cleanData de jQuery si jQuery est&amp;aacute; cargado en su p&amp;aacute;gina. En escenarios avanzados, es posible que desee evitar o personalizar c&amp;oacute;mo se eliminan estos datos en su aplicaci&amp;oacute;n. Knockout expone una funci&amp;oacute;n, ko.utils.domNodeDisposal.cleanExternalData (nodo), que se puede anular para admitir la l&amp;oacute;gica personalizada. Por ejemplo, para evitar que se llame a cleanData, se podr&amp;iacute;a usar una funci&amp;oacute;n vac&amp;iacute;a para reemplazar la implementaci&amp;oacute;n est&amp;aacute;ndar de cleanExternalData:</target>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="translated">Cuando el observable computarizado sólo se usa en su UI</target>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="translated">Cuando se ejecuta el loadComponent del cargador predeterminado, simult&amp;aacute;neamente:</target>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="translated">Cuando la opci&amp;oacute;n deferUpdates est&amp;aacute; activada, todos los observables, los observables calculados y las vinculaciones se configurar&amp;aacute;n para usar actualizaciones y notificaciones diferidas. Habilitar esta funci&amp;oacute;n al comienzo de la creaci&amp;oacute;n de una aplicaci&amp;oacute;n basada en Knockout significa que no tiene que preocuparse por solucionar el problema del valor intermedio, por lo que puede facilitar un dise&amp;ntilde;o m&amp;aacute;s limpio y puramente reactivo. Pero debe tener cuidado al habilitar las actualizaciones diferidas para una aplicaci&amp;oacute;n existente porque romper&amp;aacute; el c&amp;oacute;digo que depende de las actualizaciones sincr&amp;oacute;nicas o de la notificaci&amp;oacute;n de valores intermedios (aunque es posible que pueda &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;solucionar estos problemas&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="translated">Cuando se programa la primera tarea (inicialmente y despu&amp;eacute;s de que haya finalizado un evento de descarga anterior), Knockout programar&amp;aacute; un evento de descarga para procesar la cola de microtask. Si es posible, intentar&amp;aacute; utilizar las capacidades de microtask propias de los navegadores. En los navegadores modernos, utilizar&amp;aacute; un &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;observador de mutaci&amp;oacute;n DOM&lt;/a&gt; y, en versiones anteriores de Internet Explorer, utilizar&amp;aacute; un evento &amp;lt;script&amp;gt; onreadystatechange. Estos m&amp;eacute;todos le permiten comenzar a procesar la cola antes de cualquier reflujo o redibujado. En otros navegadores, volver&amp;aacute; a usar setTimeout.</target>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="translated">Cuando el enlace de opciones cambia el conjunto de opciones en su elemento &amp;lt;select&amp;gt;, KO dejar&amp;aacute; la selecci&amp;oacute;n del usuario sin cambios cuando sea posible. Por lo tanto, para una lista desplegable de selecci&amp;oacute;n &amp;uacute;nica, el valor de la opci&amp;oacute;n previamente seleccionada seguir&amp;aacute; estando seleccionado, y para una lista de selecci&amp;oacute;n m&amp;uacute;ltiple, todos los valores de opci&amp;oacute;n seleccionados previamente todav&amp;iacute;a estar&amp;aacute;n seleccionados (a menos que, por supuesto, haya eliminado una o m&amp;aacute;s de esas opciones).</target>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="translated">Cuando el par&amp;aacute;metro se resuelve en un &lt;strong&gt;valor similar&lt;/strong&gt; a &lt;strong&gt;falso&lt;/strong&gt; (por ejemplo, el valor booleano falso, o el valor num&amp;eacute;rico 0, o nulo, o indefinido), el enlace establece yourElement.style.display en none, lo que hace que se oculte. Esto tiene prioridad sobre cualquier estilo de visualizaci&amp;oacute;n que haya definido mediante CSS.</target>
        </trans-unit>
        <trans-unit id="486a4906c8e802b0c506137554408d59db04e832" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the visible binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="translated">Cuando el par&amp;aacute;metro se resuelve en un &lt;strong&gt;valor similar&lt;/strong&gt; a &lt;strong&gt;verdadero&lt;/strong&gt; (por ejemplo, el valor booleano verdadero, o un objeto o matriz no nulo), el enlace elimina el valor de yourElement.style.display, lo que hace que se vuelva visible.</target>
        </trans-unit>
        <trans-unit id="fc7bf8fa30e9cc8653a4d8b4f189e36ca8bb5a36" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the visible binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="translated">Cuando el usuario cambie el botón de radio seleccionado,KO establecerá la propiedad de su modelo para que sea igual al valor del botón de radio seleccionado.En el ejemplo anterior,al hacer clic en el botón de radio con valor=&quot;cereza&quot;,la propiedad viewModel.spamFlavor sería &quot;cereza&quot;.</target>
        </trans-unit>
        <trans-unit id="03e179ef7606802f89ca3b95e7468e850b02c502" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, Knockout will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="translated">Cuando el usuario marca o desmarca la casilla de verificación,KO añadirá o quitará el valor de la matriz en consecuencia.</target>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="translated">Cuando el usuario marca o desmarca la casilla de verificación,KO fijará la propiedad del modelo en verdadero o falso según corresponda.</target>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="translated">Cuando el usuario comprueba el control de formulario asociado,esto actualiza el valor en su modelo de vista.Del mismo modo,cuando actualiza el valor en su modelo de vista,esto comprueba o deselecciona el control de formulario en pantalla.</target>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="translated">Cuando el usuario edita el valor en el control de formulario asociado,actualiza el valor en su modelo de visualización.Del mismo modo,cuando actualiza el valor en su modelo de vista,esto actualiza el valor del control de formulario en pantalla.</target>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="translated">Cuando el usuario enfoca o desenfoca manualmente el elemento,su valor se ajustará a verdadero o falso en consecuencia.</target>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="translated">Cuando el usuario selecciona o deselecciona un elemento en la lista de selecci&amp;oacute;n m&amp;uacute;ltiple, esto agrega o elimina el valor correspondiente a una matriz en su modelo de vista. Del mismo modo, suponiendo que sea una matriz &lt;em&gt;observable&lt;/em&gt; en su modelo de vista, siempre que agregue o elimine (por ejemplo, mediante empuje o empalme) elementos a esta matriz, los elementos correspondientes en la interfaz de usuario se seleccionan o deseleccionan. Es un enlace bidireccional.</target>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="translated">Cuando el valor de cualquier observable es primitivo (un número,una cadena,booleano o nulo),los dependientes del observable se notifican por defecto sólo cuando se establece un valor que es realmente diferente del anterior.Así pues,los observables diferidos de valor primitivo notifican sólo cuando su valor es realmente diferente al final de la tarea actual.En otras palabras,si un observable diferido de valor primitivo se cambia a un nuevo valor y luego se vuelve a cambiar al valor original,no se notificará.</target>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="translated">Cuando el valor de cualquier observable es primitivo (un número,una cadena,booleano o nulo),los dependientes del observable se notifican por defecto sólo cuando se establece un valor que es realmente diferente del anterior.Así pues,los observables de valor primitivo y de tasa limitada notifican sólo cuando su valor es realmente diferente al final del período de tiempo.En otras palabras,si un observable de valor primitivo y tasa limitada se cambia a un nuevo valor y luego se vuelve a cambiar al valor original antes de que termine el período de tiempo muerto,no se producirá ninguna notificación.</target>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">Cu&amp;aacute;ndo usar un observable calculado &lt;em&gt;puro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="translated">Cuando se utiliza el KO,su vista es simplemente su documento HTML con enlaces declarativos para vincularlo al modelo de vista.Alternativamente,puede usar plantillas que generan HTML usando datos de su modelo de vista.</target>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="translated">Al usar rateLimit:</target>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="translated">Cuando decimos que una aplicaci&amp;oacute;n es modular, generalmente nos referimos a que est&amp;aacute; compuesta por un conjunto de funciones distintas y altamente desacopladas almacenadas en m&amp;oacute;dulos. Como probablemente sepa, el acoplamiento flexible facilita el mantenimiento de las aplicaciones al eliminar las dependencias donde sea posible. Cuando esto se implementa de manera eficiente, es bastante f&amp;aacute;cil ver c&amp;oacute;mo los cambios en una parte de un sistema pueden afectar a otra.</target>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="translated">Cuando se escribe en un observable que contiene un valor primitivo (un n&amp;uacute;mero, cadena, booleano o nulo), las dependencias del observable normalmente solo se notifican si el valor realmente cambi&amp;oacute;. Sin embargo, es posible utilizar el &lt;a href=&quot;extenders&quot;&gt;extensor de&lt;/a&gt; notificaci&amp;oacute;n incorporado para garantizar que los suscriptores de un observable siempre sean notificados en una escritura, incluso si el valor es el mismo. Aplicar&amp;iacute;a el extensor a un observable como este:</target>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="translated">Cuando &lt;strong&gt;agrega&lt;/strong&gt; entradas de matriz, foreach renderizar&amp;aacute; nuevas copias de su plantilla y las insertar&amp;aacute; en el DOM existente</target>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="translated">Cuando &lt;strong&gt;elimina las&lt;/strong&gt; entradas de la matriz, foreach simplemente eliminar&amp;aacute; los elementos DOM correspondientes</target>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="translated">Cuando &lt;strong&gt;reordena las&lt;/strong&gt; entradas de la matriz (conservando las mismas instancias de objeto), foreach normalmente solo mover&amp;aacute; los elementos DOM correspondientes a su nueva posici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="translated">Cuando cambia el valor del nombre a 'Mary' llamando a myViewModel.personName ('Mary'), el enlace de texto actualizar&amp;aacute; autom&amp;aacute;ticamente el contenido de texto del elemento DOM asociado. As&amp;iacute; es como los cambios en el modelo de vista se propagan autom&amp;aacute;ticamente a la vista.</target>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="translated">Cuando se carga un modelo o plantilla a través de requerir declaraciones,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="translated">Cuando se modifica el contenido de la matriz de modelos (añadiendo,moviendo o borrando sus entradas),la encuadernación de la horquilla utiliza un eficiente algoritmo de diferenciación para averiguar qué ha cambiado,de modo que puede actualizar el DOM para que coincida.Esto significa que puede manejar combinaciones arbitrarias de cambios simultáneos.</target>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="translated">Cuando utiliza el enlace de env&amp;iacute;o en un formulario, Knockout evitar&amp;aacute; la acci&amp;oacute;n de env&amp;iacute;o predeterminada del navegador para ese formulario. En otras palabras, el navegador llamar&amp;aacute; a su funci&amp;oacute;n de controlador pero &lt;em&gt;no&lt;/em&gt; enviar&amp;aacute; el formulario al servidor. Este es un valor predeterminado &amp;uacute;til porque cuando usa el enlace de env&amp;iacute;o, normalmente es porque est&amp;aacute; usando el formulario como una interfaz para su modelo de vista, no como un formulario HTML normal. Si &lt;em&gt;no&lt;/em&gt; desea que la forma presente como un formulario HTML normal, s&amp;oacute;lo devuelve verdadero de su controlador de enviar.</target>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="translated">Siempre que tiene &lt;em&gt;alg&amp;uacute;n&lt;/em&gt; cambio de suscriptor, est&amp;aacute; despierto y &lt;strong&gt;&lt;em&gt;escuchando&lt;/em&gt;&lt;/strong&gt; . Al entrar en el estado de &lt;em&gt;escucha&lt;/em&gt; , se suscribe inmediatamente a cualquier dependencia. En este estado, funciona como un observable calculado normal, como se describe en &lt;a href=&quot;computed-dependency-tracking&quot;&gt;c&amp;oacute;mo funciona el seguimiento de dependencias&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="translated">Siempre que &lt;em&gt;no&lt;/em&gt; tenga suscriptores de cambio, est&amp;aacute; &lt;strong&gt;&lt;em&gt;durmiendo&lt;/em&gt;&lt;/strong&gt; . Al entrar en el estado de &lt;em&gt;reposo&lt;/em&gt; , dispone todas las suscripciones a sus dependencias. Durante este estado, no se suscribir&amp;aacute; a ning&amp;uacute;n observable al que se acceda en la funci&amp;oacute;n del evaluador (aunque s&amp;iacute; los rastrea). Si el valor del observable calculado se lee mientras est&amp;aacute; &lt;em&gt;inactivo&lt;/em&gt; , se vuelve a evaluar autom&amp;aacute;ticamente si alguna de sus dependencias ha cambiado.</target>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="translated">Cada vez que el usuario edite el valor en el control de formulario asociado,KO actualizará la propiedad en su modelo de vista.KO siempre intentará actualizar el modelo de vista cuando el valor se haya modificado y el usuario transfiera el enfoque a otro nodo DOM (es decir,en el evento de cambio),pero también puede desencadenar actualizaciones basadas en otros eventos mediante el parámetro valueUpdate que se describe a continuación.</target>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="translated">Cada vez que el usuario edite el valor en el control de formulario asociado,KO actualizará la propiedad en su modelo de vista.KO siempre intentará actualizar su modelo de vista cuando el valor haya sido modificado por el usuario o cualquier evento DOM.</target>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="translated">Cada vez que se declara un observable computarizado,el KO invoca inmediatamente su función evaluadora para obtener su valor inicial.</target>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="translated">Siempre que inyecta un &lt;a href=&quot;component-overview&quot;&gt;componente&lt;/a&gt; usando el &lt;a href=&quot;component-binding&quot;&gt;enlace&lt;/a&gt; del componente o un &lt;a href=&quot;component-custom-elements&quot;&gt;elemento personalizado&lt;/a&gt; , Knockout recupera la plantilla y el modelo de vista de ese componente usando uno o m&amp;aacute;s &lt;em&gt;cargadores de componentes&lt;/em&gt; . El trabajo de un cargador de componentes es proporcionar de forma asincr&amp;oacute;nica un par de plantilla / modelo de vista para cualquier nombre de componente dado.</target>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="translated">Sea o no el parámetro un arreglo observable,el KO detectará cuando el usuario seleccione o deseleccione un elemento de la lista de multiselección,y actualizará el arreglo para que coincida.Así es como se puede leer cuál de las opciones está seleccionada.</target>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="translated">Mientras que el resultado2 será:</target>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="translated">Mientras se ejecuta la función de evaluación,el KO establece una suscripción a cualquier observable (incluidos otros observables computados)que el evaluador lea.La devolución de la suscripción se configura para que el evaluador vuelva a ejecutarse,volviendo todo el proceso al paso 1 (eliminando cualquier suscripción antigua que ya no se aplique).</target>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="translated">Mientras que las soluciones nativas a estos problemas llegarán a ES Harmony,la buena noticia es que escribir Javascript modular nunca ha sido tan fácil y puedes empezar a hacerlo hoy.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; &quot;puro&quot;?</target>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="translated">¿Por qué no poner un controlador de clic en el botón de envío?</target>
        </trans-unit>
        <trans-unit id="d9388a16fe8139626304808559f7f5bbed3b2319" translate="yes" xml:space="preserve">
          <source>With binding preprocessing, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c21e0bb780f4445b10d04fb402764ba77e9803b" translate="yes" xml:space="preserve">
          <source>Without the completeOn option, myPostProcessingLogic will be called even if resultData is not set intitially. With the option set as above, myPostProcessingLogic will only be called once resultData is set to a true-like value, and the contents of that node are rendered and bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="translated">Trabajando con las cuerdas de JSON</target>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="translated">Observables computarizados escritos</target>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="translated">Los observables computarizados escribibles son una característica poderosa con una amplia gama de posibles usos.</target>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="translated">No está limitado a suministrar objetos de configuración en cualquier formato estándar.Puede suministrar objetos arbitrarios siempre y cuando su función loadComponent los entienda.</target>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="translated">También puede personalizar la forma en que se actualiza un objeto especificando una llamada de actualización.Recibirá el objeto que está intentando actualizar y un objeto de opciones que es idéntico al utilizado por la llamada de retorno de la creación.Debe devolver el valor actualizado.</target>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="translated">También puede terminar una suscripción si lo desea:primero capture el valor de retorno como una variable,luego puede llamar a su función de disposición,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="translated">También puede usar una función de JavaScript o una expresión arbitraria de JavaScript como valor del parámetro.Si lo haces,KO ejecutará tu función/evaluará tu expresión,y usará el resultado para determinar si ocultar el elemento.</target>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="translated">Tambi&amp;eacute;n puede utilizar el enlace de valor con un elemento &amp;lt;select&amp;gt; que no utiliza el enlace de opciones. En este caso, puede optar por especificar sus elementos &amp;lt;option&amp;gt; en el marcado o crearlos utilizando los enlaces foreach o de plantilla. Incluso puede anidar opciones dentro de los elementos &amp;lt;optgroup&amp;gt; y Knockout establecer&amp;aacute; el valor seleccionado de manera apropiada.</target>
        </trans-unit>
        <trans-unit id="443d155ae980ce22546521692e114b8091b7dca0" translate="yes" xml:space="preserve">
          <source>You can bind either event using ko.bindingEvent.subscribe, but importantly for components, which are asynchronous by default, the descendantsComplete event will wait for all child components to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="translated">Puedes combinar múltiples objetos JS en un modelo de vista aplicando múltiples llamadas ko.mapping.fromJS,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="translated">Puede colocar el bloque de secuencia de comandos en la parte inferior de su documento HTML, o puede ponerlo en la parte superior y envolver el contenido en un controlador listo para DOM como &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;la funci&amp;oacute;n $ de jQuery&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="translated">Incluso puedes establecer múltiples clases CSS basadas en la misma condición envolviendo los nombres entre comillas como:</target>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="translated">Puede encontrar una buena lista de palabras reservadas en &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;la p&amp;aacute;gina MDN de Mozilla aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="904b621173f2d4b30a15643fddcc0af2f1534b33" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="translated">Puede conectarse a la l&amp;oacute;gica de Knockout para interpretar atributos de enlace de datos proporcionando un &lt;em&gt;preprocesador de enlace&lt;/em&gt; para un controlador de enlace espec&amp;iacute;fico (como clic, visible o cualquier &lt;a href=&quot;custom-bindings&quot;&gt;controlador de enlace personalizado&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="translated">Puede conectarse con la l&amp;oacute;gica de Knockout para atravesar el DOM proporcionando un &lt;em&gt;preprocesador de nodo&lt;/em&gt; . Esta es una funci&amp;oacute;n que Knockout llamar&amp;aacute; una vez por cada nodo DOM sobre el que pase, tanto cuando se enlaza la interfaz de usuario por primera vez como luego cuando se inyectan nuevos sub&amp;aacute;rboles DOM (por ejemplo, a trav&amp;eacute;s de un &lt;a href=&quot;foreach-binding&quot;&gt;enlace foreach&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="90e55ee316113a7d87000ded1fefd296bd68ce62" translate="yes" xml:space="preserve">
          <source>You can manually dispose a computed observable by calling its dispose function, which clears all subscriptions to its dependencies. It is also automatically disposed if its evaluator function doesn&amp;rsquo;t access any observables. Although you can continue to access the most recent value of a disposed computed observable, its evaluator function will not be run again. Additionally, a disposed &lt;em&gt;pure&lt;/em&gt; computed observables is neither awake nor asleep, and does not notify state-change events. To determine if a computed observable is disposed, call myComputed.isActive().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="translated">Puedes mapear esto a un modelo de vista sin problemas:</target>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="translated">Puede hacer referencia a cualquier funci&amp;oacute;n de JavaScript; no tiene que ser una funci&amp;oacute;n en su modelo de vista. Puede hacer referencia a una funci&amp;oacute;n en cualquier objeto escribiendo click: someObject.someFunction.</target>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="translated">Puede hacer referencia a cualquier funci&amp;oacute;n de JavaScript; no tiene que ser una funci&amp;oacute;n en su modelo de vista. Puede hacer referencia a una funci&amp;oacute;n en cualquier objeto escribiendo event {mouseover: someObject.someFunction}.</target>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="translated">Puede hacer referencia a cualquier funci&amp;oacute;n de JavaScript; no tiene que ser una funci&amp;oacute;n en su modelo de vista. Puede hacer referencia a una funci&amp;oacute;n en cualquier objeto escribiendo submit: someObject.someFunction.</target>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="translated">Puede registrar un componente de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">Puedes establecer varias clases de CSS a la vez.Por ejemplo,si tu modelo de vista tiene una propiedad llamada isSevere,</target>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">Puedes establecer varios valores de estilo a la vez.Por ejemplo,si tu modelo de vista tiene una propiedad llamada isSevere,</target>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="translated">Luego, puede crear una &lt;em&gt;vista&lt;/em&gt; muy simple de este modelo de vista utilizando un enlace declarativo. Por ejemplo, el siguiente marcado muestra el valor personName:</target>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="translated">Puede utilizar un observable calculado escribible exactamente como un observable regular, con su propia l&amp;oacute;gica personalizada interceptando todas las lecturas y escrituras. Al igual que los observables, puede escribir valores en m&amp;uacute;ltiples propiedades observables o observables calculadas en un objeto modelo utilizando la &lt;em&gt;sintaxis de encadenamiento&lt;/em&gt; . Por ejemplo, myViewModel.fullName ('Joe Smith'). Age (50).</target>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="translated">Puede usar la caracter&amp;iacute;stica &lt;em&gt;pura&lt;/em&gt; para cualquier observable calculado que siga las &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;pautas de la &lt;/a&gt;&lt;em&gt;funci&amp;oacute;n pura&lt;/em&gt; . Sin embargo, ver&amp;aacute; el mayor beneficio cuando se aplica a dise&amp;ntilde;os de aplicaciones que involucran modelos de vista persistentes que son usados ​​y compartidos por vistas temporales y modelos de vista. El uso de observables calculados &lt;em&gt;puros&lt;/em&gt; en un modelo de vista persistente proporciona beneficios de rendimiento de c&amp;aacute;lculo. Usarlos en modelos de vista temporal proporciona beneficios de administraci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="translated">Puede utilizar la devolución de llamada del inicio como un lugar para registrar un manejador de eventos que causará cambios en el observable asociado.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="translated">Puede utilizar esta técnica si,por ejemplo,desea controlar qué subconjunto de componentes registrados puede utilizarse como elementos personalizados.</target>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="translated">Podrías unir este modelo de vista a algunos elementos HTML de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="translated">No tiene que cambiar la vista en absoluto, la misma sintaxis de enlace de datos seguir&amp;aacute; funcionando. La diferencia es que ahora es capaz de detectar cambios y, cuando lo haga, actualizar&amp;aacute; la vista autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="translated">Es posible que desee implementar un cargador de componentes personalizado si desea utilizar convenciones de nomenclatura, en lugar de un registro expl&amp;iacute;cito, para cargar componentes. O bien, si desea utilizar una biblioteca de &quot;cargadores&quot; de terceros para obtener modelos de visualizaci&amp;oacute;n de componentes o plantillas de ubicaciones externas.</target>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="translated">Debe usar dispose para liberar cualquier recurso que no sea inherentemente recolectable de basura. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="translated">Debe escribir &amp;lt;my-custom-element&amp;gt; &amp;lt;/my-custom-element&amp;gt;, y &lt;strong&gt;no&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. De lo contrario, su elemento personalizado no se cerrar&amp;aacute; y los elementos posteriores se analizar&amp;aacute;n como elementos secundarios.</target>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="translated">Sólo se necesitan dos archivos para el componente-un modelo de vista (path/my-component.js)y una plantilla (path/my-component.html)-lo cual es un arreglo muy natural durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="translated">No debe usar la caracter&amp;iacute;stica &lt;em&gt;pura&lt;/em&gt; para un observable calculado que est&amp;aacute; destinado a realizar una acci&amp;oacute;n cuando cambian sus dependencias. Ejemplos incluyen:</target>
        </trans-unit>
        <trans-unit id="7273cd1f360253be372b4b6ac72a1c8b27685344" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names are your CSS classes and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="translated">Debe pasar un objeto JavaScript en el que los nombres de las propiedades se correspondan con los nombres de los atributos y los valores se correspondan con los valores de los atributos que desee aplicar.</target>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="translated">Debes pasar un objeto JavaScript en el que los nombres de las propiedades correspondan a los nombres de los eventos,y los valores correspondan a la función que quieres vincular al evento.</target>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="translated">Debe pasar un objeto JavaScript en el que los nombres de las propiedades correspondan a los nombres de los estilos,y los valores correspondan a los valores de los estilos que desea aplicar.</target>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="translated">Debe proporcionar una matriz (o matriz observable). Para cada elemento, KO agregar&amp;aacute; una &amp;lt;opci&amp;oacute;n&amp;gt; al nodo &amp;lt;select&amp;gt; asociado. Se eliminar&amp;aacute;n todas las opciones anteriores.</target>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="translated">Quiere mostrar la hora actual del servidor y el número de usuarios de su página web.Podría representar esta información usando el siguiente modelo de vista:</target>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="translated">No necesitar&amp;aacute; usar esto a menudo. Solo es &amp;uacute;til en algunos casos raros, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="translated">Tendrías que hacer esto para cada variable que quieras mostrar en tu página.Si sus estructuras de datos se vuelven más complejas (por ejemplo,contienen niños o contienen matrices)esto se vuelve muy engorroso de manejar manualmente.Lo que el plugin de mapeo le permite hacer es crear un mapeo desde el objeto regular JavaScript (o estructura JSON)a un modelo de vista observable.</target>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="translated">Se usaría este extensor llamando a la función de extensión de un observable y pasando un objeto que contiene una propiedad logChange.</target>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="translated">No est&amp;aacute; limitado a hacer referencia a variables; puede hacer referencia a expresiones arbitrarias para controlar la habilitaci&amp;oacute;n de un elemento. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="translated">No est&amp;aacute; limitado a usar elementos &amp;lt;template&amp;gt;, pero estos son convenientes (en navegadores que los admiten) ya que no se renderizan por s&amp;iacute; mismos. Cualquier otro tipo de elemento tambi&amp;eacute;n funciona.</target>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="translated">No est&amp;aacute; limitado a usar los enlaces integrados como clic, valor, etc., puede crear los suyos propios. As&amp;iacute; es como se controla c&amp;oacute;mo los observables interact&amp;uacute;an con los elementos DOM, y le brinda mucha flexibilidad para encapsular comportamientos sofisticados de una manera f&amp;aacute;cil de reutilizar.</target>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="translated">Ya ha visto c&amp;oacute;mo usar la actualizaci&amp;oacute;n para que, cuando un observable cambie, pueda actualizar un elemento DOM asociado. Pero, &amp;iquest;qu&amp;eacute; pasa con los eventos en la otra direcci&amp;oacute;n? Cuando el usuario realiza alguna acci&amp;oacute;n en un elemento DOM, es posible que desee actualizar un observable asociado.</target>
        </trans-unit>
        <trans-unit id="e674f60b3e3f970884c28a49f2eace45a0bc8f3b" translate="yes" xml:space="preserve">
          <source>Your function can also accept a third parameter, an object that includes any additional parameters passed to the rateLimit extender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="translated">La función de preprocesamiento debe devolver el nuevo valor de la cadena para ser analizado y pasado a la encuadernación,o devolverlo indefinido para eliminar la encuadernación.</target>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="translated">Sus modelos de vista &lt;em&gt;son&lt;/em&gt; objetos de JavaScript, por lo que, en cierto sentido, podr&amp;iacute;a serializarlos como JSON usando cualquier serializador JSON est&amp;aacute;ndar, como &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (una funci&amp;oacute;n nativa en los navegadores modernos) o la biblioteca &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; . Sin embargo, sus modelos de vista probablemente contengan observables, observables calculados y matrices observables, que se implementan como funciones de JavaScript y, por lo tanto, no siempre se serializar&amp;aacute;n limpiamente sin trabajo adicional en su nombre.</target>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="translated">un &lt;strong&gt;observable calculado&lt;/strong&gt; llamado selectedItems que devuelve una matriz de objetos de elementos correspondientes a los &amp;iacute;ndices seleccionados</target>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="translated">addBinding:una función de devolución de llamada que se puede utilizar opcionalmente para insertar otro enlace en el elemento actual.Esto requiere dos parámetros,nombre y valor.Por ejemplo,dentro de tu función de preprocesamiento,llama a addBinding('visible','acceptsTerms()');para hacer que Knockout se comporte como si el elemento tuviera un enlace visible:acceptsTerms()sobre él.</target>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterAdd: es como afterRender, excepto que se invoca solo cuando se agregan nuevas entradas a su matriz (y &lt;em&gt;no&lt;/em&gt; cuando foreach itera por primera vez sobre el contenido inicial de su matriz). Un uso com&amp;uacute;n de afterAdd es llamar a un m&amp;eacute;todo como $ (domNode) .fadeIn () de jQuery para obtener transiciones animadas cada vez que se agregan elementos. Knockout proporcionar&amp;aacute; los siguientes par&amp;aacute;metros a su devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterMove: se invoca despu&amp;eacute;s de que un elemento de la matriz haya cambiado de posici&amp;oacute;n en la matriz y despu&amp;eacute;s de que foreach haya actualizado el DOM para que coincida. Tenga en cuenta que afterMove se aplica a todos los elementos de la matriz cuyos &amp;iacute;ndices han cambiado, por lo que si inserta un nuevo elemento al principio de una matriz, la devoluci&amp;oacute;n de llamada (si se especifica) se activar&amp;aacute; para todos los dem&amp;aacute;s elementos, ya que su posici&amp;oacute;n de &amp;iacute;ndice ha aumentado en uno. Knockout proporcionar&amp;aacute; los siguientes par&amp;aacute;metros a su devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterRender: se invoca cada vez que el bloque foreach se duplica y se inserta en el documento, tanto cuando foreach se inicializa por primera vez como cuando se agregan nuevas entradas a la matriz asociada posteriormente. Knockout proporcionar&amp;aacute; los siguientes par&amp;aacute;metros a su devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="translated">afterRender, afterAdd o beforeRemove: funciones de devoluci&amp;oacute;n de llamada que se invocar&amp;aacute;n contra los elementos DOM renderizados; consulte la &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Nota 4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="translated">allBindings: un objeto JavaScript que puede usar para acceder a todos los valores del modelo vinculados a este elemento DOM. Llame a allBindings.get ('nombre') para recuperar el valor del enlace de nombre (devuelve undefined si el enlace no existe); o allBindings.has ('nombre') para determinar si el enlace de nombre est&amp;aacute; presente para el elemento actual.</target>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="translated">un &lt;strong&gt;observables&lt;/strong&gt; denominados elementos que representan un conjunto de elementos</target>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="translated">otro &lt;strong&gt;observable calculado&lt;/strong&gt; que devuelve verdadero o falso dependiendo de si alguno de los art&amp;iacute;culos seleccionados tiene alguna propiedad (como ser nuevo o no guardado). Algunos elementos de la interfaz de usuario, como un bot&amp;oacute;n, pueden habilitarse o deshabilitarse en funci&amp;oacute;n de este valor.</target>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="translated">otro &lt;strong&gt;observable&lt;/strong&gt; llamado selectedIndexes que almacena qu&amp;eacute; &amp;iacute;ndices de elementos han sido 'seleccionados' por el usuario</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="translated">as: cuando se usa junto con foreach, define un alias para cada elemento que se representa; consulte la &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Nota 3&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="fe82d73a4cd0fd638c5b4b7c43ff1f46fdf88ddf" translate="yes" xml:space="preserve">
          <source>asleep &amp;mdash; Whevener the computed observable enters the &lt;em&gt;sleeping&lt;/em&gt; state, it notifies an asleep event with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="translated">actualizaciones asincrónicas hechas como parte del textoIngreso y unión de valores</target>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="translated">atrayendo la atención</target>
        </trans-unit>
        <trans-unit id="4d1df76ffa98addd696f0868b465b5a5ac6051c9" translate="yes" xml:space="preserve">
          <source>awake &amp;mdash; Whenever the computed observable enters the &lt;em&gt;listening&lt;/em&gt; state, it notifies an awake event using its current value. (The awake event also applies to normal computed observables created with the deferEvaluation option.) You won&amp;rsquo;t normally need to know about the internal state of your observables. But since the internal state can correspond to whether the observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeMove: se invoca cuando un elemento de la matriz ha cambiado de posici&amp;oacute;n en la matriz, pero antes de que se hayan movido los nodos DOM correspondientes. Tenga en cuenta que beforeMove se aplica a todos los elementos de la matriz cuyos &amp;iacute;ndices han cambiado, por lo que si inserta un nuevo elemento al principio de una matriz, la devoluci&amp;oacute;n de llamada (si se especifica) se activar&amp;aacute; para todos los dem&amp;aacute;s elementos, ya que su posici&amp;oacute;n de &amp;iacute;ndice ha aumentado en uno. Puede usar beforeMove para almacenar las coordenadas de pantalla originales de los elementos afectados para que pueda animar sus movimientos en la devoluci&amp;oacute;n de llamada afterMove. Knockout proporcionar&amp;aacute; los siguientes par&amp;aacute;metros a su devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeRemove: se invoca cuando se ha eliminado un elemento de la matriz, pero antes de que se hayan eliminado los nodos DOM correspondientes. Si especifica una devoluci&amp;oacute;n de llamada beforeRemove, entonces &lt;em&gt;ser&amp;aacute; su responsabilidad eliminar los nodos DOM&lt;/em&gt; . El caso de uso obvio aqu&amp;iacute; es llamar a algo como $ (domNode) .fadeOut () de jQuery para animar la eliminaci&amp;oacute;n de los nodos DOM correspondientes; en este caso, Knockout no puede saber qu&amp;eacute; tan pronto se permite eliminar f&amp;iacute;sicamente los nodos DOM (qui&amp;eacute;n sabe c&amp;oacute;mo &amp;iquest;Cu&amp;aacute;nto tardar&amp;aacute; su animaci&amp;oacute;n?), por lo que depende de usted eliminarlos. Knockout proporcionar&amp;aacute; los siguientes par&amp;aacute;metros a su devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="translated">bindingContext: un objeto que contiene el &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; disponible para los enlaces de este elemento. Este objeto incluye propiedades especiales que incluyen $ parent, $ parent y $ root que se pueden utilizar para acceder a los datos vinculados a los antepasados ​​de este contexto.</target>
        </trans-unit>
        <trans-unit id="46540f2415ab34cc44a0a28cf94dc516343761db" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;http://knockoutjs.com/documentation/binding-context.html&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="translated">Comprobado el vínculo...</target>
        </trans-unit>
        <trans-unit id="312ab7ec76efbca4142c1e1bc45818dbfbbc12d3" translate="yes" xml:space="preserve">
          <source>childrenComplete &amp;mdash; This event is notified &lt;strong&gt;synchronously&lt;/strong&gt; once the child nodes (and all synchronously loaded descendants) have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="translated">la encuadernación por clic</target>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="translated">componente vinculante</target>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="translated">carga de componentes de un componente en cach&amp;eacute; cuando no est&amp;aacute; configurado para &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;carga s&amp;iacute;ncrona&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="translated">createViewModel (params, componentInfo): &lt;strong&gt;opcional. &lt;/strong&gt;Una funci&amp;oacute;n que luego se llamar&amp;aacute; para proporcionar un objeto de modelo de vista para cada instancia de este componente</target>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="translated">css vinculante</target>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="translated">datos: un objeto que se debe proporcionar como datos para que la plantilla se represente. Si omite este par&amp;aacute;metro, KO buscar&amp;aacute; un par&amp;aacute;metro foreach o recurrir&amp;aacute; al uso de su objeto de modelo actual.</target>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="translated">sintaxis de unión de datos</target>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="translated">datos:El objeto JavaScript que contiene los datos de este niño</target>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="translated">deferEvaluation: opcional. Si esta opci&amp;oacute;n es verdadera, entonces el valor del observable calculado no se evaluar&amp;aacute; hasta que algo realmente intente acceder a su valor o se suscriba manualmente. De forma predeterminada, un observable calculado tiene su valor determinado inmediatamente durante la creaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="50483074a00f34742adc3cf6acea848d89daee7d" translate="yes" xml:space="preserve">
          <source>descendantsComplete &amp;mdash; This event is notified after all descendant nodes have been bound, even if those nodes were loaded and bound &lt;strong&gt;asynchronously&lt;/strong&gt;. If all descendant nodes are bound synchronously, this event is notified right after childrenComplete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="translated">destruir y destruir todo (Nota:Normalmente relevante sólo para los desarrolladores de Ruby on Rails)</target>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="translated">destroy (function (someItem) {return someItem.age &amp;lt;18;}) - Encuentra cualquier objeto en la matriz cuya propiedad de edad sea menor que 18, y le da a esos objetos una propiedad especial llamada _destroy con valor verdadero.</target>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="translated">destruir (someItem): busca cualquier objeto en la matriz que sea igual a someItem y les da una propiedad especial llamada _destroy con valor verdadero.</target>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroyAll (['Chad', 132, undefined]): busca cualquier objeto en la matriz que sea igual a 'Chad', 123 o undefined y les da una propiedad especial llamada _destroy con valor verdadero.</target>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="translated">destroyAll (): proporciona una propiedad especial llamada _destroy con un valor verdadero para todos los objetos de la matriz.</target>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="translated">deshabilitar la vinculación</target>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="translated">dispose (): elimina manualmente el observable calculado, borrando todas las suscripciones a las dependencias. Esta funci&amp;oacute;n es &amp;uacute;til si desea evitar que un observable calculado se actualice o si desea limpiar la memoria de un observable calculado que tiene dependencias de observables que no se limpiar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="translated">disposeWhen - Opcional. Si se da, esta funci&amp;oacute;n se ejecuta antes de cada reevaluaci&amp;oacute;n para determinar si el observable calculado debe eliminarse. Un resultado verdadero activar&amp;aacute; la eliminaci&amp;oacute;n del observable calculado.</target>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="translated">disposeWhenNodeIsRemoved: opcional. Si se da, la eliminaci&amp;oacute;n del observable calculado se activar&amp;aacute; cuando KO elimine el nodo DOM especificado. Esta caracter&amp;iacute;stica se utiliza para eliminar los observables calculados que se utilizan en las vinculaciones cuando la plantilla y las vinculaciones de flujo de control eliminan los nodos.</target>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="translated">elemento: el elemento DOM involucrado en este enlace</target>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="translated">permitir la vinculación</target>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">evaluador: funci&amp;oacute;n que se utiliza para evaluar el valor actual del observable calculado.</target>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="translated">evento vinculante</target>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="translated">manejadores de eventos añadidos por ko.utils.registerEventHandler incluyendo los vinculados al evento y a los enlaces de click</target>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="translated">extender (extensores): aplica los &lt;a href=&quot;extenders&quot;&gt;extensores&lt;/a&gt; dados al observable calculado.</target>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="translated">foreach: indica a KO que represente la plantilla en modo &amp;ldquo;foreach&amp;rdquo;; consulte la &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Nota 2&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="translated">la encuadernación del frente</target>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="translated">getConfig(nombre,devolución de llamada)</target>
        </trans-unit>
        <trans-unit id="b4c4660644d77f70fe1a9cee3ca63cac55a0dc9f" translate="yes" xml:space="preserve">
          <source>getDependencies() &amp;mdash; Returns an array of the current dependencies of the computed observable. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cbd9a0bc9e935ac585a0fd1e9cef0b854a0878" translate="yes" xml:space="preserve">
          <source>getDependencies() &amp;mdash; Returns an array of the dependencies of the computed observable detected so far during the current evaluation. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="translated">getDependenciesCount (): devuelve el n&amp;uacute;mero actual de dependencias del observable calculado.</target>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="translated">getDependenciesCount (): devuelve el n&amp;uacute;mero de dependencias del observable calculado detectado hasta el momento durante la evaluaci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="translated">getSubscriptionsCount ([evento]): devuelve el n&amp;uacute;mero actual de suscripciones (ya sea de otros observables calculados o suscripciones manuales) del observable calculado. Opcionalmente, pase un nombre de evento (como &quot;cambiar&quot;) para devolver solo el recuento de suscripciones para ese evento.</target>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="translated">hasFocus binding</target>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="translated">Encuadernación con html</target>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="translated">if: si se proporciona este par&amp;aacute;metro, la plantilla solo se procesar&amp;aacute; si la expresi&amp;oacute;n especificada se eval&amp;uacute;a como verdadera (o un valor verdadero). Esto puede resultar &amp;uacute;til para evitar que un observable nulo se vincule con una plantilla antes de que se rellene.</target>
        </trans-unit>
        <trans-unit id="f8a7ee59b7f626d3e0bbf6283344f28bfd576098" translate="yes" xml:space="preserve">
          <source>if (and ifnot) play a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible (and hidden) bindings&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied&amp;mdash;the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="translated">si es vinculante</target>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="translated">si juega un papel similar al &lt;a href=&quot;visible-binding&quot;&gt;enlace visible&lt;/a&gt; . La diferencia es que, con visible, el marcado contenido siempre permanece en el DOM y siempre se aplican sus atributos de enlace de datos; el enlace visible solo usa CSS para alternar la visibilidad del elemento contenedor. Sin embargo, el enlace if agrega o elimina f&amp;iacute;sicamente el marcado contenido en su DOM, y solo aplica enlaces a los descendientes si la expresi&amp;oacute;n es verdadera.</target>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="translated">si no es vinculante</target>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="translated">isActive (): devuelve si el observable calculado se puede actualizar en el futuro. Un observable calculado est&amp;aacute; inactivo si no tiene dependencias.</target>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="translated">isInitial (): una funci&amp;oacute;n que devuelve verdadero si se llama durante la primera evaluaci&amp;oacute;n del observable calculado actual, o falso en caso contrario. En &lt;em&gt;el caso de&lt;/em&gt; observables calculados &lt;em&gt;puros&lt;/em&gt; , isInitial () siempre est&amp;aacute; indefinido.</target>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="translated">ko.bindingHandlers. &amp;lt;nombre&amp;gt; .preprocess (valor, nombre, addBindingCallback)</target>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="translated">ko.componentes.defaultLoader.getConfig(name,callback)</target>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="translated">ko.componentes.defaultLoader.loadComponente(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="translated">ko.componentes.defaultLoader.loadViewModel(name,viewModelConfig,callback)</target>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="translated">ko.componentes.get(nombre,llamada)</target>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="translated">ko.components.register(nombre,configuración)</target>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="translated">ko.propiedades computarizadas siguen recibiendo notificaciones de sus dependencias hasta que se disponga explícitamente de ellas.</target>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="translated">ko.computed (evaluator [, targetObject, options]): este formulario admite el caso m&amp;aacute;s com&amp;uacute;n de creaci&amp;oacute;n de un observable calculado.</target>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="translated">ko.computed (opciones): este formulario de par&amp;aacute;metro &amp;uacute;nico para crear un observable calculado acepta un objeto JavaScript con cualquiera de las siguientes propiedades.</target>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="translated">ko.contextFor (elemento): devuelve el &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; completo que estaba disponible para el elemento DOM.</target>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="translated">ko.dataFor(element)-devuelve los datos que estaban disponibles para la unión con el elemento</target>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="translated">ko.isComputed: devuelve verdadero para todos los observables calculados.</target>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable: devuelve verdadero para observables, matrices observables y todos los observables calculados.</target>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable-devuelve verdadero para los observables,las matrices observables y todos los observables computados.</target>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="translated">ko.isPureComputed: devuelve verdadero para los observables calculados &lt;em&gt;puros&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable: devuelve verdadero para observables, matrices observables y observables calculados &lt;em&gt;grabables&lt;/em&gt; (tambi&amp;eacute;n alias como ko.isWriteableObservable).</target>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isObservableEscribible-devuelve verdadero para observables,matrices observables y observables computarizados escribibles (también alias ko.isObservableEscribible).</target>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="translated">ko.pureComputed (evaluator [, targetObject]): construye un &lt;a href=&quot;computed-pure&quot;&gt;observable calculado &lt;/a&gt;&lt;em&gt;puro&lt;/em&gt; usando la funci&amp;oacute;n de evaluador dada y el objeto opcional para usar para esto. A diferencia de ko.computed, este m&amp;eacute;todo no acepta un par&amp;aacute;metro de opciones.</target>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="translated">ko.pureComputed (opciones): construye un observable calculado &lt;em&gt;puro&lt;/em&gt; utilizando un objeto de opciones. Esto acepta las opciones de lectura, escritura y propietario descritas anteriormente.</target>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="translated">ko.tasks.runEarly (): llame a este m&amp;eacute;todo para procesar la cola de microtask actual bajo demanda, inmediatamente, hasta que est&amp;eacute; vac&amp;iacute;a. Adem&amp;aacute;s de la integraci&amp;oacute;n de la biblioteca, puede usar este m&amp;eacute;todo si tiene un c&amp;oacute;digo que programa una serie de tareas, pero luego necesita lidiar con los efectos de esas tareas sincr&amp;oacute;nicamente.</target>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="translated">ko.tasks.scheduler: anula este m&amp;eacute;todo para redefinir o aumentar la forma en que Knockout programa el evento para procesar y vaciar la cola. Knockout llama a este m&amp;eacute;todo cuando se programa la primera tarea, por lo que debe programar el evento y regresar de inmediato. Por ejemplo, si su aplicaci&amp;oacute;n se ejecuta en Node.js, es posible que prefiera usar process.nextTick para el evento flush: ko.tasks.scheduler = process.nextTick ;.</target>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="translated">ko.toJS: esto clona el gr&amp;aacute;fico de objetos de su modelo de vista, sustituyendo para cada observable el valor actual de ese observable, por lo que obtiene una copia simple que contiene solo sus datos y no artefactos relacionados con Knockout</target>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="translated">ko.toJSON: esto produce una cadena JSON que representa los datos de su modelo de vista. Internamente, simplemente llama a ko.toJS en su modelo de vista y luego usa el serializador JSON nativo del navegador en el resultado. Nota: para que esto funcione en navegadores m&amp;aacute;s antiguos que no tienen serializador JSON nativo (por ejemplo, IE 7 o anterior), tambi&amp;eacute;n debe hacer referencia a la biblioteca &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="translated">ko.virtualElements.insertAfter(containerElem,nodeToInsert,insertAfter)</target>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="translated">ko.virtualElements.prepend(containerElem,nodeToPrepend)</target>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="translated">ko.virtualElements.setDomNodeChildren(containerElem,arrayOfNodes)</target>
        </trans-unit>
        <trans-unit id="ae33d3da7690605630d3b5ed0a0e56ec1697cf89" translate="yes" xml:space="preserve">
          <source>ko.when can also be called with just the predicate function. In that case, it returns a Promise that will be resolved with the predicate result once the predicate returns a true-ish value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cee4d4c787cee1d4b2b9866ab7a9b69e7a5057b" translate="yes" xml:space="preserve">
          <source>ko.when waits until the first function (predicate) returns true or a true-ish value, at which time it runs the second function (callback), passing the predicate result. You can optionally pass in a third parameter (context) that defines the value of this for the predicate and callback functions. ko.when returns a subscription object that you can use the cancel the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="translated">loadComponent(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="translated">loadViewModel(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="1f9c1aeab0274b6b6348b52a68972d4ea5726e3b" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, viewModelConfig, callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="translated">name: el ID de un elemento que contiene la plantilla que desea representar; consulte la &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Nota 5&lt;/a&gt; para saber c&amp;oacute;mo variar esto mediante programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="translated">nombre: el nombre del componente a inyectar. Nuevamente, esto puede ser observable.</target>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="translated">nombre:el nombre de la encuadernación (por ejemplo,para tuEncuadernación:1+1,el nombre es &quot;tuEncuadernación&quot; como una cadena).</target>
        </trans-unit>
        <trans-unit id="f5b834e53d7ae92556a516cf6fed5206f4bf3cd5" translate="yes" xml:space="preserve">
          <source>noChildContext</source>
          <target state="translated">noChildContext</target>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="translated">nodos: pasa directamente una matriz de nodos DOM para usar como plantilla. Esta debe ser una matriz no observable y tenga en cuenta que los elementos se eliminar&amp;aacute;n de su padre actual si tienen uno. Esta opci&amp;oacute;n se ignora si tambi&amp;eacute;n ha pasado un valor no vac&amp;iacute;o para el nombre.</target>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="translated">notifyAtFixedRate: &lt;strong&gt;valor predeterminado si no se especifica lo contrario&lt;/strong&gt; . La notificaci&amp;oacute;n ocurre despu&amp;eacute;s del per&amp;iacute;odo de tiempo especificado desde el primer cambio al observable (ya sea inicialmente o desde la notificaci&amp;oacute;n anterior).</target>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="translated">notifyWhenChangesStop: la notificaci&amp;oacute;n se produce despu&amp;eacute;s de que no se hayan producido cambios en el observable durante el per&amp;iacute;odo de tiempo especificado. Cada vez que lo observable cambia, ese temporizador se reinicia, por lo que las notificaciones no pueden ocurrir si lo observable cambia continuamente con m&amp;aacute;s frecuencia que el per&amp;iacute;odo de tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="translated">observable:Si la propiedad es un observable,esto se ajustará al observable real</target>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="translated">observableArray agrega algunos m&amp;eacute;todos m&amp;aacute;s &amp;uacute;tiles que no se encuentran en las matrices de JavaScript de forma predeterminada:</target>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="translated">observableArray expone un conjunto familiar de funciones para modificar el contenido del array y notificar a los oyentes.</target>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="translated">opciones: un objeto con propiedades adicionales para el observable calculado. Vea la lista completa a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="translated">opciones vinculantes</target>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="translated">propietario: opcional. Si se proporciona, define el valor de esto cada vez que KO invoca sus devoluciones de llamada de lectura o escritura.</target>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="translated">params: un objeto que se pasar&amp;aacute; al componente. Normalmente, se trata de un objeto de valor-clave que contiene varios par&amp;aacute;metros y normalmente lo recibe el constructor del modelo de vista del componente.</target>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="translated">padre:El objeto o matriz padre al que pertenece este hijo</target>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="translated">peek (): devuelve el valor actual del observable calculado sin crear una dependencia (consulte la secci&amp;oacute;n sobre &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="translated">pop (): elimina el &amp;uacute;ltimo valor de la matriz y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="translated">pop,push,shift,unshift,reverse,sort,splice</target>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="translated">puro: opcional. Si esta opci&amp;oacute;n es verdadera, el observable calculado se configurar&amp;aacute; como un &lt;a href=&quot;computed-pure&quot;&gt;observable calculado &lt;/a&gt;&lt;em&gt;puro&lt;/em&gt; . Esta opci&amp;oacute;n es una alternativa al constructor ko.pureComputed.</target>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="translated">empujar (valor): agrega un nuevo elemento al final de la matriz.</target>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="translated">rateLimit soporta dos formatos de parámetros:</target>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">leer: obligatorio. Funci&amp;oacute;n que se utiliza para evaluar el valor actual del observable calculado.</target>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="translated">quitar y quitar todo...</target>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="translated">remove (function (item) {return item.age &amp;lt;18;}) - Elimina todos los valores cuya propiedad de edad es menor que 18 y los devuelve como una matriz.</target>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="translated">remove (someItem): elimina todos los valores que son iguales a someItem y los devuelve como una matriz.</target>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="translated">removeAll (['Chad', 132, undefined]): elimina todos los valores que son iguales a 'Chad', 123 o undefined y los devuelve como una matriz.</target>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="translated">removeAll (): elimina todos los valores y los devuelve como una matriz.</target>
        </trans-unit>
        <trans-unit id="a3c46952e7fa1e806af3072725a0a18fe8a7a8d2" translate="yes" xml:space="preserve">
          <source>replace( oldItem, newItem ) &amp;mdash; Replaces the first value that equals oldItem with newItem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240cc955cee05a65ec8631352200efd2449f3e17" translate="yes" xml:space="preserve">
          <source>replace, remove and removeAll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="translated">reverse (): invierte el orden de la matriz y devuelve observableArray (no la matriz subyacente).</target>
        </trans-unit>
        <trans-unit id="c221784f0945c6f78a753619cc5ddf314594c065" translate="yes" xml:space="preserve">
          <source>reversed() &amp;mdash; Returns a reversed &lt;strong&gt;copy&lt;/strong&gt; of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="translated">seleccionadoOpciones vinculantes</target>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="translated">Las llamadas a intervalos continuarán disparándose hasta que se despejen explícitamente.</target>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="translated">shift (): elimina el primer valor de la matriz y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="translated">sort (): ordena el contenido de la matriz y devuelve observableArray.</target>
        </trans-unit>
        <trans-unit id="02dfee61ca9f2a129d89bd0f0818fbde5bd7aea7" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray. The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. See the example under sorted below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7434a175cdd232131e04992fb56ac2855b98e7ec" translate="yes" xml:space="preserve">
          <source>sorted and reversed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feaeaf39776332d680a2cd5ff36dccfebdd345d" translate="yes" xml:space="preserve">
          <source>sorted() &amp;mdash; Returns a sorted &lt;strong&gt;copy&lt;/strong&gt; of the array. This is preferable to sort if you want to leave the observable array in its original order but need to display it in a specific order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08689664c7819b1ab9daec145c9c6a25661021b" translate="yes" xml:space="preserve">
          <source>spectate &amp;mdash; Whenever the computed observable &lt;strong&gt;records&lt;/strong&gt; a change to its value, even while sleeping, it notifies a spectate event with the new value. (The spectate event applies to any type of observable but is generally most useful for pure computed observables.) This event allows you to track the current value of the observable without affecting its sleeping/waking state. Also note that when using rate-limiting or deferred updates, the &amp;ldquo;spectated&amp;rdquo; values might include intermediate values that aren&amp;rsquo;t captured by change notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="translated">splice (): elimina y devuelve un n&amp;uacute;mero determinado de elementos a partir de un &amp;iacute;ndice determinado. Por ejemplo, myObservableArray.splice (1, 3) elimina tres elementos comenzando desde la posici&amp;oacute;n de &amp;iacute;ndice 1 (es decir, el segundo, tercer y cuarto elemento) y los devuelve como una matriz.</target>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="translated">estilo de encuadernación</target>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="translated">presentar vinculante</target>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="translated">subscribe (callback [, callbackTarget, event]): registra una &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;suscripci&amp;oacute;n manual&lt;/a&gt; para recibir notificaciones de los cambios en el observable calculado.</target>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="translated">targetObject: si se proporciona, define el valor de esto siempre que KO invoca sus funciones de devoluci&amp;oacute;n de llamada. Consulte la secci&amp;oacute;n sobre &lt;a href=&quot;computedobservables#managing-this&quot;&gt;c&amp;oacute;mo administrar esto&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="translated">plantilla: &lt;strong&gt;obligatorio. &lt;/strong&gt;Una matriz de nodos DOM</target>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="translated">la vinculación de la plantilla</target>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="translated">La plantilla es obligatoria y puede tomar cualquiera de &lt;a href=&quot;#specifying-a-template&quot;&gt;los formatos de plantilla que se describen a continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="translated">la encuadernación del texto</target>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="translated">textInput binding</target>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="translated">un vínculo de nombre único...</target>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="translated">unshift (valor): inserta un nuevo elemento al comienzo de la matriz.</target>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="translated">valor vinculante</target>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="translated">El valor, de forma predeterminada, solo actualiza su modelo cuando el usuario mueve el foco fuera del cuadro de texto. textInput actualiza su modelo inmediatamente con cada pulsaci&amp;oacute;n de tecla u otro mecanismo de entrada de texto (como cortar o arrastrar texto, que no necesariamente genera eventos de cambio de foco).</target>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="translated">valor:la sintaxis asociada al valor vinculante antes de que Knockout intente analizarlo (por ejemplo,para tuBinding:1+1,el valor asociado es &quot;1+1&quot; como cadena).</target>
        </trans-unit>
        <trans-unit id="c0028d499648445b972232716f7a0d90be688c64" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string). If the binding was given without a value, this will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="translated">valueAccessor: una funci&amp;oacute;n de JavaScript a la que puede llamar para obtener la propiedad del modelo actual que est&amp;aacute; involucrada en este enlace. Llame a esto sin pasar ning&amp;uacute;n par&amp;aacute;metro (es decir, llame a valueAccessor ()) para obtener el valor de propiedad del modelo actual. Para aceptar f&amp;aacute;cilmente valores tanto observables como simples, llame a ko.unwrap en el valor devuelto.</target>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="translated">viewModel: este par&amp;aacute;metro est&amp;aacute; obsoleto en Knockout 3.x. Use bindingContext. $ Data o bindingContext. $ RawData para acceder al modelo de vista en su lugar.</target>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="translated">viewModel es opcional y puede tomar cualquiera de &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;los formatos viewModel que se describen a continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="translated">la encuadernación visible</target>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="translated">con la unión</target>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="translated">escribir: opcional. Si se da, hace que el observable calculado se pueda &lt;em&gt;escribir&lt;/em&gt; . Esta es una funci&amp;oacute;n que recibe valores que otro c&amp;oacute;digo est&amp;aacute; tratando de escribir en su observable calculado. Depende de usted proporcionar una l&amp;oacute;gica personalizada para manejar los valores entrantes, normalmente escribiendo los valores en algunos observables subyacentes.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
