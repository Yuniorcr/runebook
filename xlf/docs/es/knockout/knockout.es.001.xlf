<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="55f7a75bfb6b682f736e46b92c2f236aae124e0e" translate="yes" xml:space="preserve">
          <source>&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</source>
          <target state="translated">&quot;afterkeydown&quot;: actualiza su modelo de vista tan pronto como el usuario comienza a escribir un car&amp;aacute;cter. Esto funciona capturando el evento keydown del navegador y manejando el evento de forma asincr&amp;oacute;nica. Esto no funciona en algunos navegadores m&amp;oacute;viles.</target>
        </trans-unit>
        <trans-unit id="9bf88a9f967d7e0a2ecb9a2c3cb373e62550ca35" translate="yes" xml:space="preserve">
          <source>&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</source>
          <target state="translated">&quot;entrada&quot;: actualiza su modelo de vista cuando cambia el valor de un elemento &amp;lt;input&amp;gt; o &amp;lt;textarea&amp;gt;. Tenga en cuenta que este evento solo lo generan navegadores razonablemente modernos (por ejemplo, IE 9+).</target>
        </trans-unit>
        <trans-unit id="43249745c4adbf35a9cb9922652997d87dbe4042" translate="yes" xml:space="preserve">
          <source>&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</source>
          <target state="translated">&quot;pulsaci&amp;oacute;n de tecla&quot;: actualiza su modelo de vista cuando el usuario ha escrito una tecla. A diferencia del keyup, esto se actualiza repetidamente mientras el usuario mantiene presionada una tecla</target>
        </trans-unit>
        <trans-unit id="754a19ddfd1580a60ebdb60a67460f4ed1868828" translate="yes" xml:space="preserve">
          <source>&quot;keyup&quot; - updates your view model when the user releases a key</source>
          <target state="translated">&quot;keyup&quot;: actualiza su modelo de vista cuando el usuario suelta una tecla</target>
        </trans-unit>
        <trans-unit id="b023c5f7752f43d6081c327d978bba7f21cae65e" translate="yes" xml:space="preserve">
          <source>&quot;notifyAtFixedRate&quot; &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a76466185a7fa8b0e097018e39dd0d76592070" translate="yes" xml:space="preserve">
          <source>&quot;notifyWhenChangesStop&quot; &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e067625ca975ca350ad14ef24cf6b1eeeb932ab7" translate="yes" xml:space="preserve">
          <source>$component</source>
          <target state="translated">$component</target>
        </trans-unit>
        <trans-unit id="f27c0d6823b43be383afbf56a525fa3e7b5bca08" translate="yes" xml:space="preserve">
          <source>$componentTemplateNodes</source>
          <target state="translated">$componentTemplateNodes</target>
        </trans-unit>
        <trans-unit id="b4aa877f2150e2e324627c78466629fcce97867e" translate="yes" xml:space="preserve">
          <source>$context</source>
          <target state="translated">$context</target>
        </trans-unit>
        <trans-unit id="461e9bac5c124e13e943d74294b5b3c23e91e59a" translate="yes" xml:space="preserve">
          <source>$data</source>
          <target state="translated">$data</target>
        </trans-unit>
        <trans-unit id="8d42409e40e4019fe1ad3970dab02ce54792984f" translate="yes" xml:space="preserve">
          <source>$element</source>
          <target state="translated">$element</target>
        </trans-unit>
        <trans-unit id="a7455dbeff981624c8fd90602ba9b39d8a3236fe" translate="yes" xml:space="preserve">
          <source>$index (only available within foreach bindings)</source>
          <target state="translated">$ index (solo disponible dentro de los enlaces foreach)</target>
        </trans-unit>
        <trans-unit id="45e7737b5f1d96d16a40213881d84a2a492be556" translate="yes" xml:space="preserve">
          <source>$parent</source>
          <target state="translated">$parent</target>
        </trans-unit>
        <trans-unit id="95e2237aee892666510550fbfab5413dc3d3c57a" translate="yes" xml:space="preserve">
          <source>$parentContext</source>
          <target state="translated">$parentContext</target>
        </trans-unit>
        <trans-unit id="551e29188e6f391357b84d891bae6ddf016d5ab0" translate="yes" xml:space="preserve">
          <source>$parents</source>
          <target state="translated">$parents</target>
        </trans-unit>
        <trans-unit id="f68b486675e88b186e3e5d97a647fbca76132e19" translate="yes" xml:space="preserve">
          <source>$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</source>
          <target state="translated">$ parent [0] es el modelo de vista del contexto principal (es decir, es lo mismo que $ parent)</target>
        </trans-unit>
        <trans-unit id="65c4ecaa451b9f437d3935b91802b54bbb000546" translate="yes" xml:space="preserve">
          <source>$parents[1] is the view model from the grandparent context</source>
          <target state="translated">$ padres [1] es el modelo de vista del contexto de los abuelos</target>
        </trans-unit>
        <trans-unit id="3cdd4ec57af42ab07ce806176c82747601207768" translate="yes" xml:space="preserve">
          <source>$parents[2] is the view model from the great-grandparent context</source>
          <target state="translated">$ padres [2] es el modelo de vista del contexto de los bisabuelos</target>
        </trans-unit>
        <trans-unit id="7efb9bde8c0dcb7c458231902442f2ac06b5d48e" translate="yes" xml:space="preserve">
          <source>$rawData</source>
          <target state="translated">$rawData</target>
        </trans-unit>
        <trans-unit id="b764ba81776db6e2c0d3c795e5f0fb4f7b3b3158" translate="yes" xml:space="preserve">
          <source>$root</source>
          <target state="translated">$root</target>
        </trans-unit>
        <trans-unit id="281a6ce7dc200bc3ee6a1f7a74996c60f02fadb8" translate="yes" xml:space="preserve">
          <source>&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</source>
          <target state="translated">&amp;copy; Steven Sanderson, el equipo de Knockout.js y otros colaboradores</target>
        </trans-unit>
        <trans-unit id="a48ee17c964423bf4cc960d5d152f164fe712d06" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</source>
          <target state="translated">... e IE 6 no muestra ning&amp;uacute;n espacio en blanco antes de las palabras en nuestro sitio web, puede evitar el problema poniendo cualquier texto en &amp;lt;span&amp;gt;, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e27c42ca2533fdefaeb58cc1b7eb45a5f42080eb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</source>
          <target state="translated">... y defina una funci&amp;oacute;n correspondiente en su modelo de vista (es decir, el objeto que contiene myData):</target>
        </trans-unit>
        <trans-unit id="cd11f3ee80ccedd0afebd460c00d949f65c71240" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e4a9ac6cd86f6006efcb5074a7cfc4a95acc99" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and so on.</source>
          <target state="translated">&amp;hellip; y as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="5a844d0606e2cebac6157c81cc9a6f5ca56660d6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</source>
          <target state="translated">... y el siguiente cargador personalizado se encargar&amp;aacute; de cargar modelos de vista configurados con un valor viaLoader:</target>
        </trans-unit>
        <trans-unit id="2392c33f696700587811efee0b525c35b66a8113" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</source>
          <target state="translated">... y el marcado de la plantilla est&amp;aacute; en la ruta del archivo / my-component.html, entonces tiene estos beneficios:</target>
        </trans-unit>
        <trans-unit id="306ad3adf4c6d524c866e2da9e33f77bb76e411e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and then you can use it on any number of DOM elements:</source>
          <target state="translated">... y luego puede usarlo en cualquier n&amp;uacute;mero de elementos DOM:</target>
        </trans-unit>
        <trans-unit id="1d1269190ed98d387c971daefbe0a562031c6ac7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</source>
          <target state="translated">&amp;hellip; Y se actualizar&amp;aacute;n cada vez que cambie el nombre o apellido (se llamar&amp;aacute; a su funci&amp;oacute;n de evaluador una vez cada vez que cambie alguna de sus dependencias, y cualquier valor que devuelva se pasar&amp;aacute; a los observadores, como elementos de la interfaz de usuario u otros observables calculados).</target>
        </trans-unit>
        <trans-unit id="f0e6d69780be5a001171b8e0891626e76815b8cb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and you can do so using custom loaders.</source>
          <target state="translated">&amp;hellip; Y puede hacerlo utilizando cargadores personalizados.</target>
        </trans-unit>
        <trans-unit id="c678b47361f53960d600a49f5e2a49ab33bf1efb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</source>
          <target state="translated">&amp;hellip; Asumiendo que someProperty es &lt;em&gt;observable&lt;/em&gt; y por lo tanto necesita invocarlo como una funci&amp;oacute;n para obtener el valor actual.</target>
        </trans-unit>
        <trans-unit id="436bfbadf0d7e3d2acd161b36e9fa6c0aee1ca68" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; Porque data-something no es un nombre de identificaci&amp;oacute;n legal en ese momento. La soluci&amp;oacute;n es simple: simplemente envuelva el nombre del identificador entre comillas para que se convierta en un literal de cadena, lo cual es legal en un literal de objeto de JavaScript. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d96ec87b990d2a5f05fcb8d21bf32f55812f3e19" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">... porque mi clase no es un nombre de identificaci&amp;oacute;n legal en ese momento. La soluci&amp;oacute;n es simple: simplemente envuelva el nombre del identificador entre comillas para que se convierta en un literal de cadena, lo cual es legal en un literal de objeto de JavaScript. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="e308fd02d63129d37593963615074a07790d41e5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</source>
          <target state="translated">&amp;hellip; Pero no es necesario, porque firstName se evaluar&amp;aacute; dentro del contexto de $ data de forma predeterminada de todos modos.</target>
        </trans-unit>
        <trans-unit id="675271334f75433b76e0d2ca2daa2caedcb7aa93" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway. If the items in the array are observables, $data will refer to the value of each observable. To refer to the observable itself, use $rawData.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd0331bbbc30c917af2ce818fb5586d7cecd6f7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be injected with:</source>
          <target state="translated">... se puede inyectar con:</target>
        </trans-unit>
        <trans-unit id="7f3a7cb698f6c8ba821554005a2fe7438261aff6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be used as the template for a component by specifying its ID:</source>
          <target state="translated">... se puede utilizar como plantilla para un componente especificando su ID:</target>
        </trans-unit>
        <trans-unit id="9ddd2ca25a0f65763e8a310b7c6de249963ba2b7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; is equivalent to the following:</source>
          <target state="translated">&amp;hellip; Es equivalente a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="fd4393ed67ac1cfb24dad9cf459b5a8aa896d33c" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a createViewModel function, e.g.:</source>
          <target state="translated">... o una funci&amp;oacute;n createViewModel, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4445358862216b92eb56a5a61275070dfed5150b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a shared object instance, e.g.:</source>
          <target state="translated">... o una instancia de objeto compartido, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9f9f2be5a24b6d2be93f0a540aa1c45603b7e12d" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</source>
          <target state="translated">&amp;hellip; O cualquiera de las otras formas descritas aqu&amp;iacute;, aunque ser&amp;iacute;a inusual que las otras fueran &amp;uacute;tiles al buscar plantillas a trav&amp;eacute;s de AMD.</target>
        </trans-unit>
        <trans-unit id="dfd09f5a0fc940760751819d925befbc4f3884f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</source>
          <target state="translated">... o incluso, aunque es poco probable que desee hacer esto, una referencia a un m&amp;oacute;dulo AMD diferente, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="76deaf0467a8d01ce5fda8253ca2bf94e5c1d09f" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or passing parameters:</source>
          <target state="translated">&amp;hellip; O pasando par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="c8dde18842940735246b96ebc2b6801af0bff816" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or you can send data to the server:</source>
          <target state="translated">... o puede enviar datos al servidor:</target>
        </trans-unit>
        <trans-unit id="83dd09db0bbbaf75986c9f14324dd51a6c7b3c2b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">... o, m&amp;aacute;s convenientemente, como &lt;a href=&quot;component-custom-elements&quot;&gt;elemento personalizado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9a0cac50f6e17cb0207d461cfe3eadb4c1cb5b0b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</source>
          <target state="translated">... el par&amp;aacute;metro params del modelo de vista del componente contendr&amp;aacute; tres valores:</target>
        </trans-unit>
        <trans-unit id="d03a96e5ee2c9a78e87d9468f59e17ba046629a1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</source>
          <target state="translated">&amp;hellip; Luego vea &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;la documentaci&amp;oacute;n para elementos virtuales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eb4b5f8187f3ef64e228acdde18a278aa6c4f55" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</source>
          <target state="translated">&amp;hellip; Entonces upperCaseName se volver&amp;aacute; a calcular inmediatamente, antes de que se ejecute la siguiente l&amp;iacute;nea de c&amp;oacute;digo. Pero si, en cambio, define el nombre usando rateLimit de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d6d1fbc554c515663655cf7715837ed5aa4d192b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</source>
          <target state="translated">... entonces upperCaseName no se volver&amp;aacute; a calcular inmediatamente cuando cambie el nombre; en cambio, el nombre esperar&amp;aacute; 500 milisegundos (medio segundo) antes de notificar su nuevo valor a upperCaseName, que luego volver&amp;aacute; a calcular su valor. No importa cu&amp;aacute;ntas veces se cambie el nombre durante esos 500 ms, upperCaseName solo se actualizar&amp;aacute; una vez con el valor m&amp;aacute;s reciente.</target>
        </trans-unit>
        <trans-unit id="6b92e76aa3ffd11c41f69f8adf6378acda520d0e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</source>
          <target state="translated">... entonces obtendr&amp;aacute; el error El enlace 'randomOrder' no se puede usar con elementos virtuales. Arreglemos esto. Para hacer que randomOrder sea utilizable con elementos virtuales, comience por decirle a Knockout que lo permita. Agregue lo siguiente:</target>
        </trans-unit>
        <trans-unit id="80d023722c8262c22ad3fc675542d06cee7a10d4" translate="yes" xml:space="preserve">
          <source>&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</source>
          <target state="translated">&amp;hellip; Esto &lt;em&gt;no se&lt;/em&gt; representar&amp;iacute;a como texto en cursiva, sino como texto literal con corchetes angulares visibles.</target>
        </trans-unit>
        <trans-unit id="4fe8ec038bc4329e9e45b5dfe41cee9f2fe195b1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you can write:</source>
          <target state="translated">&amp;hellip; puedes escribir:</target>
        </trans-unit>
        <trans-unit id="b66a8f7dc087cc3fe583564359f2ab71878995ff" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you could add a computed observable to return the full name:</source>
          <target state="translated">... podr&amp;iacute;a agregar un observable calculado para devolver el nombre completo:</target>
        </trans-unit>
        <trans-unit id="71d7c773808d5efbd7cce431ad808079c3272374" translate="yes" xml:space="preserve">
          <source>&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</source>
          <target state="translated">... todo lo que hace Knockout es llamar require (['some / module / name'], callback) y require (['text! Some-template.html'], callback), y usa los objetos devueltos asincr&amp;oacute;nicamente como modelo de vista y plantilla definiciones. Entonces,</target>
        </trans-unit>
        <trans-unit id="38ee4fba456bf575e89e5da4159e11ef4ef51e69" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can be composed together (nested) or inherited from other components</source>
          <target state="translated">... se pueden componer (anidar) o heredar de otros componentes</target>
        </trans-unit>
        <trans-unit id="162d2e6a27442e0aa5ac2c677764866d6758b55a" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can easily be packaged for reuse across projects</source>
          <target state="translated">... se puede empaquetar f&amp;aacute;cilmente para su reutilizaci&amp;oacute;n en todos los proyectos</target>
        </trans-unit>
        <trans-unit id="bcba4513804170c2cfb012b6c5f4e034f8b93be4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</source>
          <target state="translated">... se puede precargar o cargar de forma as&amp;iacute;ncrona (bajo demanda) a trav&amp;eacute;s de AMD u otros sistemas de m&amp;oacute;dulos</target>
        </trans-unit>
        <trans-unit id="7734991d30f834e7dc1591e178e0cd0b0d5521fb" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</source>
          <target state="translated">... puede recibir par&amp;aacute;metros y, opcionalmente, escribir cambios en ellos o invocar devoluciones de llamada</target>
        </trans-unit>
        <trans-unit id="37c9fb1cbc39cb59f3625da14f6e4805d7b6d501" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can represent individual controls/widgets, or entire sections of your application</source>
          <target state="translated">... puede representar controles / widgets individuales o secciones completas de su aplicaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="1c2182731546dc53e24b1c9569feb025fd6bb517" translate="yes" xml:space="preserve">
          <source>&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</source>
          <target state="translated">... contienen su propia vista y, por lo general (pero opcionalmente) su propio modelo de vista</target>
        </trans-unit>
        <trans-unit id="62feedff48dd72e9502546eae6f60f51588cac08" translate="yes" xml:space="preserve">
          <source>&amp;hellip;let you define your own conventions/logic for configuration and loading</source>
          <target state="translated">... le permite definir sus propias convenciones / l&amp;oacute;gica para la configuraci&amp;oacute;n y la carga</target>
        </trans-unit>
        <trans-unit id="1d6d88d1123b98cbd0f1f5e62ff9ab2b24498c00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad39df7089dc71921905acab8fd21922898ed00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb3c78ce58dd06a6d43eb3b9ff55c63d6083256" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c61fd8db0084748a81447c5ac602f14593ede76" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9a2f7e913b123d1b2147b6fcea7fc3b56f2226" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', 'font-weight': isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5c19398840fdde1cad04e87976626ec9752a56" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="translated">&amp;lt;div data-bind = &quot;style: {color: currentProfit () &amp;lt;0? 'red': 'black', fontWeight: isSevere ()? 'bold': ''}&quot;&amp;gt; ... &amp;lt;/div&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38e9d45ee1eed004e555cb8df16e05183c19f62c" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = 'options: myOptions, optionsCaption: &quot;Seleccionar un elemento ...&quot;, valor: myChosenValue'&amp;gt; &amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="db710280a1f20bb61913609f07dc49291fe0ba4f" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = 'options: myOptions, optionsIncludeDestroyed: true'&amp;gt; &amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb1429e4a9ace15f00ed398e300f2d1e6d8acde7" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</source>
          <target state="translated">(Nota: si no desea aplicar una clase CSS, sino que desea asignar un valor de atributo de estilo directamente, consulte &lt;a href=&quot;style-binding&quot;&gt;el enlace de estilo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="15891bb9e3faad48e1edd4725ace6108a9566b87" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the class or css binding&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a142a8a08360ecb44da2e404e6e9702082412cb" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</source>
          <target state="translated">(Nota: si no desea aplicar un valor de estilo expl&amp;iacute;cito, sino que desea asignar una clase CSS, consulte &lt;a href=&quot;css-binding&quot;&gt;el enlace css&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd7f1dbd9b0a6243440f34f5f4c46eeb6f3829a1" translate="yes" xml:space="preserve">
          <source>(The awake event also applies to normal computed observables created with the deferEvaluation option.)</source>
          <target state="translated">(El evento despierto tambi&amp;eacute;n se aplica a los observables calculados normales creados con la opci&amp;oacute;n deferEvaluation).</target>
        </trans-unit>
        <trans-unit id="8626117b5c558a6896256b03c3366c11dc83bf9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It&amp;rsquo;s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</source>
          <target state="translated">&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; es una biblioteca popular para hacer referencia a bibliotecas de JavaScript con una sintaxis de requerimiento sincr&amp;oacute;nico estilo Node. A menudo se considera una alternativa a un cargador AMD como require.js. Sin embargo, Browserify resuelve un problema bastante diferente: resoluci&amp;oacute;n de referencia en tiempo de compilaci&amp;oacute;n sincr&amp;oacute;nica, en lugar de resoluci&amp;oacute;n de referencia en tiempo de ejecuci&amp;oacute;n asincr&amp;oacute;nica como la maneja AMD.</target>
        </trans-unit>
        <trans-unit id="b39766fa59a9837dc3c0076b5c0edc9947c018b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="translated">&lt;a href=&quot;ratelimit-observable&quot;&gt;&lt;/a&gt;calculados con velocidad limitada y &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;acelerada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b4bb06f8e720378aa0ea6e2adc0ff799010ff99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799efd7655ba3b9889f9740fd0862be90bc93730" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to supply configurations programmatically based on names, e.g., to implement a naming convention.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Defina esto si:&lt;/strong&gt; desea proporcionar configuraciones program&amp;aacute;ticamente basadas en nombres, por ejemplo, para implementar una convenci&amp;oacute;n de nomenclatura.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6212d983fffffd9e6209c49fa2c090cd3246f96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Defina esto si:&lt;/strong&gt; desea tomar el control sobre c&amp;oacute;mo se interpretan las configuraciones de los componentes, por ejemplo, si no desea utilizar el formato est&amp;aacute;ndar de par viewModel / template.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a555c705767297e9a26aa2786f606e4bddfbdc4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Defina esto si:&lt;/strong&gt; desea usar l&amp;oacute;gica personalizada para proporcionar nodos DOM para una configuraci&amp;oacute;n de plantilla determinada (por ejemplo, usar una solicitud ajax para obtener una plantilla por URL).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42c134db8841f2566f885e08b68c5c8d619f2908" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Defina esto si:&lt;/strong&gt; desea utilizar l&amp;oacute;gica personalizada para proporcionar una f&amp;aacute;brica de modelos de vista para una configuraci&amp;oacute;n de modelo de vista determinada (por ejemplo, integrar con un cargador de m&amp;oacute;dulos de terceros o un sistema de inyecci&amp;oacute;n de dependencias).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="951a4f2777566b4db649df1913890afa95d9199f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners don&amp;rsquo;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los principiantes no necesitan saber sobre esto, pero los desarrolladores m&amp;aacute;s avanzados querr&amp;aacute;n saber por qu&amp;eacute; seguimos haciendo todas estas afirmaciones sobre KO que rastrea autom&amp;aacute;ticamente las dependencias y actualiza las partes correctas de la interfaz de usuario ...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa952fc0ed2f794d316a68b12bbe7feaad64baf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los principiantes pueden querer saltarse esta secci&amp;oacute;n: los observables computados que se pueden escribir son bastante avanzados y no son necesarios en la mayor&amp;iacute;a de las situaciones&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b05d71845457c0f57f5c46e823954aa6b0676cbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deferred&lt;/em&gt; &amp;ndash; Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</source>
          <target state="translated">&lt;em&gt;Diferido&lt;/em&gt; : las notificaciones se producen de forma asincr&amp;oacute;nica, inmediatamente despu&amp;eacute;s de la tarea actual y, en general, antes de que se vuelva a dibujar la IU.</target>
        </trans-unit>
        <trans-unit id="1a3eb4911a7639fdbf44236533a918c6726b8746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Model-View-View Model (MVVM)&lt;/em&gt; is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</source>
          <target state="translated">&lt;em&gt;Modelo-Vista-Vista Modelo (MVVM)&lt;/em&gt; es un patr&amp;oacute;n de dise&amp;ntilde;o para construir interfaces de usuario. Describe c&amp;oacute;mo puede mantener simple una IU potencialmente sofisticada dividi&amp;eacute;ndola en tres partes:</target>
        </trans-unit>
        <trans-unit id="8d5d07f2734b6af11f85414b793aa7ddf201eb11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Native templating&lt;/em&gt; is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn&amp;rsquo;t require any external library.</source>
          <target state="translated">&lt;em&gt;La creaci&amp;oacute;n de plantillas nativas&lt;/em&gt; es el mecanismo que sustenta foreach, if, with y otros enlaces de flujo de control. Internamente, esos enlaces de flujo de control capturan el marcado HTML contenido en su elemento y lo usan como una plantilla para renderizar contra un elemento de datos arbitrario. Esta funci&amp;oacute;n est&amp;aacute; integrada en Knockout y no requiere ninguna biblioteca externa.</target>
        </trans-unit>
        <trans-unit id="62995f07b684cd1e442b8e8983d90777e3520707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: As an alternative, it&amp;rsquo;s possible to implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that fetches components by your own conventions instead of explicit configuration.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: Como alternativa, es posible implementar un &lt;a href=&quot;component-loaders&quot;&gt;cargador de componentes personalizado&lt;/a&gt; que obtenga componentes seg&amp;uacute;n sus propias convenciones en lugar de una configuraci&amp;oacute;n expl&amp;iacute;cita.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d338d1a1dd37312fe044a380c3ea1d735e815b63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; plugin provides similar support.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: esta documentaci&amp;oacute;n se aplica a Knockout 3.4.0 y versiones posteriores. Para versiones anteriores, el complemento de &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Actualizaciones diferidas&lt;/a&gt; proporciona un soporte similar.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62498b02454097b103305de14b9e278671df1dae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: esta documentaci&amp;oacute;n se aplica a Knockout 3.4.0 y versiones posteriores.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8a670cb7b1ce7328b8161c795abd85a6da3f03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452d27c97bc5cb3c05b0a492913c856dfecc7e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: esta es una t&amp;eacute;cnica avanzada, que normalmente se usa solo al crear bibliotecas de enlaces reutilizables o sintaxis extendidas. No es algo que deba hacer normalmente al crear aplicaciones con Knockout.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d10f8fcc7959551d54bb29ecb4d9c7d6381a396c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: esta es una t&amp;eacute;cnica avanzada, que normalmente se usa solo al crear bibliotecas de enlaces reutilizables. No es algo que deba hacer normalmente al crear aplicaciones con Knockout.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13a617cb2c3f39c989433be077da2528155d2c63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: Esta API de l&amp;iacute;mite de velocidad se agreg&amp;oacute; en Knockout 3.1.0. Para versiones anteriores, el &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;extensor&lt;/a&gt; del acelerador proporciona una funcionalidad similar.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f07301b891a79e640658b5d5f6382bfcb281196" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ff05c21394b3c8fde74181447625b3f4a3c9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Observables &lt;em&gt;puros&lt;/em&gt; computados</target>
        </trans-unit>
        <trans-unit id="a8a339e267cfb8f1a5acc964a91f6bddd68f8c55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables work slightly differently. For more details, see the documentation for &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Los&lt;/em&gt; observables computados &lt;em&gt;puros&lt;/em&gt; funcionan de manera ligeramente diferente. Para obtener m&amp;aacute;s detalles, consulte la documentaci&amp;oacute;n de &lt;a href=&quot;computed-pure&quot;&gt;observables calculados &lt;/a&gt;&lt;em&gt;puros&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d78dec7911bd8203863417e869cad05a283e2aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a &lt;em&gt;pure&lt;/em&gt; computed observable doesn&amp;rsquo;t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</source>
          <target state="translated">&lt;em&gt;Los&lt;/em&gt; observables computados &lt;em&gt;puros&lt;/em&gt; , introducidos en Knockout 3.2.0, brindan beneficios de rendimiento y memoria sobre los observables computados regulares para la mayor&amp;iacute;a de las aplicaciones. Esto se debe a que un observable calculado &lt;em&gt;puro&lt;/em&gt; no mantiene suscripciones a sus dependencias cuando no tiene suscriptores. Esta caracter&amp;iacute;stica:</target>
        </trans-unit>
        <trans-unit id="874de401496e2450d62370c0489d8134a4680445" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rate-limited&lt;/em&gt; &amp;ndash; Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</source>
          <target state="translated">&lt;em&gt;Tasa limitada&lt;/em&gt; : las notificaciones ocurren despu&amp;eacute;s del per&amp;iacute;odo de tiempo especificado (un m&amp;iacute;nimo de 2-10 ms, seg&amp;uacute;n el navegador).</target>
        </trans-unit>
        <trans-unit id="e9fb2be0abb789016ac0a5f7e66231b360cba479" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Standard&lt;/em&gt; &amp;ndash; Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</source>
          <target state="translated">&lt;em&gt;Est&amp;aacute;ndar&lt;/em&gt; : las notificaciones se producen de forma inmediata y sincr&amp;oacute;nica. Las dependencias se notifican a menudo de valores intermedios.</target>
        </trans-unit>
        <trans-unit id="a530af1836dfa7520cbd67286036f07b4d5db232" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;String-based templating&lt;/em&gt; is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the &lt;em&gt;jquery.tmpl&lt;/em&gt; and &lt;em&gt;Underscore&lt;/em&gt; template engines.</source>
          <target state="translated">&lt;em&gt;Las plantillas basadas en cadenas&lt;/em&gt; son una forma de conectar Knockout a un motor de plantillas de terceros. Knockout pasar&amp;aacute; los valores de su modelo al motor de plantilla externo e inyectar&amp;aacute; la cadena de marcado resultante en su documento. Consulte a continuaci&amp;oacute;n los ejemplos que utilizan los motores de plantilla &lt;em&gt;jquery.tmpl&lt;/em&gt; y &lt;em&gt;Underscore&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d18c945a954e5590e42b342e105bd6d20d1a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This advanced technique for working with observables was added in Knockout 3.5.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89db5d2a0f4af59a6f45fb25a27d621ea08d0a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Writes&lt;/em&gt; to observables are not delayed; the observable&amp;rsquo;s value is updated right away. For writable computed observables, this means that the write function is always run right away.</source>
          <target state="translated">&lt;em&gt;Las escrituras&lt;/em&gt; en observables no se retrasan; El valor del observable se actualiza de inmediato. En el caso de observables calculados que se pueden escribir, esto significa que la funci&amp;oacute;n de escritura siempre se ejecuta de inmediato.</target>
        </trans-unit>
        <trans-unit id="976802e52d04d57e933efed69813c57bdea15efe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You won&amp;rsquo;t normally need to set up subscriptions manually, so beginners should skip this section.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Normalmente no necesitar&amp;aacute; configurar las suscripciones manualmente, por lo que los principiantes deben omitir esta secci&amp;oacute;n.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6f4cea10f713ca2c89ae228e3ad371071a148e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Version 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb minified)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Versi&amp;oacute;n 2.0&lt;/a&gt;&lt;/strong&gt; (8,6 kb minificado)</target>
        </trans-unit>
        <trans-unit id="9fc9b0f2bd6f8643b58e34e7531e60e824fddf5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; It&amp;rsquo;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&amp;rsquo;t need to add a custom function to these namespaces if you&amp;rsquo;re only planning to use it once.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Nota:&lt;/em&gt;&lt;/strong&gt; Es mejor usar este punto de extensibilidad solo para funciones personalizadas que son realmente aplicables en una amplia gama de escenarios. No es necesario que agregue una funci&amp;oacute;n personalizada a estos espacios de nombres si solo planea usarla una vez.</target>
        </trans-unit>
        <trans-unit id="af169da745a1392a07e007770b35a87197553011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser event quirks handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Manejo de peculiaridades de eventos del navegador&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4642b89f0bf9cae05827d33f0e6b50627671416f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be added on top of your existing web application&lt;/strong&gt; without requiring major architectural changes</source>
          <target state="translated">&lt;strong&gt;Se puede agregar sobre su aplicaci&amp;oacute;n web existente&lt;/strong&gt; sin requerir cambios arquitect&amp;oacute;nicos importantes</target>
        </trans-unit>
        <trans-unit id="3f22e14067daefd1c483604455b05ad6c16fab03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compact&lt;/strong&gt; - around 13kb after gzipping</source>
          <target state="translated">&lt;strong&gt;Compacto&lt;/strong&gt; : alrededor de 13 kb despu&amp;eacute;s de gzip</target>
        </trans-unit>
        <trans-unit id="21be6783f2642d52a3544838078409e490d219d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt; are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</source>
          <target state="translated">&lt;strong&gt;Los componentes&lt;/strong&gt; son una forma potente y limpia de organizar el c&amp;oacute;digo de la interfaz de usuario en fragmentos aut&amp;oacute;nomos y reutilizables. Ellos:</target>
        </trans-unit>
        <trans-unit id="67202d2d955236aa4dfeac5729c2f6c4ab70604a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comprehensive suite of specifications&lt;/strong&gt; (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</source>
          <target state="translated">&lt;strong&gt;El conjunto completo de especificaciones&lt;/strong&gt; (desarrollado al estilo BDD) significa que su correcto funcionamiento se puede verificar f&amp;aacute;cilmente en nuevos navegadores y plataformas.</target>
        </trans-unit>
        <trans-unit id="fe040890c716ea22696a8f2b6f9be7582d520286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom elements&lt;/strong&gt; are an optional but convenient syntax for consuming components. Instead of needing placeholder &amp;lt;div&amp;gt;s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., &amp;lt;voting-button&amp;gt; or &amp;lt;product-editor&amp;gt;). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</source>
          <target state="translated">&lt;strong&gt;Los elementos personalizados&lt;/strong&gt; son una sintaxis opcional pero conveniente para consumir componentes. En lugar de necesitar marcadores de posici&amp;oacute;n &amp;lt;div&amp;gt; s en los que los componentes se inyectan con enlaces, puede usar un marcado m&amp;aacute;s autodescriptivo con nombres de elementos personalizados (por ejemplo, &amp;lt;voting-button&amp;gt; o &amp;lt;product-editor&amp;gt;). Knockout se encarga de garantizar la compatibilidad incluso con navegadores antiguos como IE 6.</target>
        </trans-unit>
        <trans-unit id="14acee7d825a2fe41e8bcf0a2ee1b89a69b3b6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Declarative bindings&lt;/strong&gt; - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</source>
          <target state="translated">&lt;strong&gt;Enlaces declarativos&lt;/strong&gt; : una forma simple y obvia de conectar partes de su interfaz de usuario a su modelo de datos. Puede construir interfaces de usuario din&amp;aacute;micas complejas f&amp;aacute;cilmente utilizando contextos de enlace anidados arbitrariamente.</target>
        </trans-unit>
        <trans-unit id="990b12697bf051a85eebd23ba9e0305e64003986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elegant dependency tracking&lt;/strong&gt; - automatically updates the right parts of your UI whenever your data model changes.</source>
          <target state="translated">&lt;strong&gt;Seguimiento elegante de dependencias&lt;/strong&gt; : actualiza autom&amp;aacute;ticamente las partes correctas de su interfaz de usuario cada vez que cambia su modelo de datos.</target>
        </trans-unit>
        <trans-unit id="2c47af57f11ec324216f4b036c02f4d8a8dd1885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sintaxis completa&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd14d38224fd44da0d36469b3026a46c9a2a53c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the component has a viewmodel, it is instantiated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Si el componente tiene un modelo de vista, se crea una instancia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="853557afd32cc4840ee8b113330eee7c54353605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immediate updates&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actualizaciones inmediatas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="005d93bacec0cddafeed676ed8ea8668552bc146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet Explorer 6 to 8&lt;/strong&gt; also supports custom elements, &lt;em&gt;but only if they are registered before the HTML parser encounters any of those elements&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 6 a 8&lt;/strong&gt; tambi&amp;eacute;n admite elementos personalizados, &lt;em&gt;pero solo si est&amp;aacute;n registrados antes de que el analizador HTML encuentre alguno de esos elementos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd066585f0b991d7b67e9c322cf8b29f5934ed43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout does not interpret the module name&lt;/strong&gt; in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That&amp;rsquo;s up to your AMD loader and how you&amp;rsquo;ve configured it.</source>
          <target state="translated">&lt;strong&gt;Knockout no interpreta el nombre del m&amp;oacute;dulo&lt;/strong&gt; de ninguna manera, simplemente lo pasa a require (). Entonces, por supuesto, Knockout no sabe ni le importa de d&amp;oacute;nde se cargan los archivos de su m&amp;oacute;dulo. Eso depende de su cargador AMD y de c&amp;oacute;mo lo haya configurado.</target>
        </trans-unit>
        <trans-unit id="b14afc719747032408502f996f8253babcf10125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout doesn&amp;rsquo;t know or care whether your AMD modules are anonymous or not&lt;/strong&gt;. Typically we find it&amp;rsquo;s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</source>
          <target state="translated">&lt;strong&gt;Knockout no sabe ni le importa si sus m&amp;oacute;dulos AMD son an&amp;oacute;nimos o no&lt;/strong&gt; . Por lo general, encontramos que es m&amp;aacute;s conveniente que los componentes se definan como m&amp;oacute;dulos an&amp;oacute;nimos, pero esa preocupaci&amp;oacute;n est&amp;aacute; completamente separada de KO.</target>
        </trans-unit>
        <trans-unit id="7623301b20fba50846d11ffcff0175e2f950b534" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native templating&lt;/strong&gt; does not require any library other than Knockout itself</source>
          <target state="translated">&lt;strong&gt;Las plantillas nativas&lt;/strong&gt; no requieren ninguna otra biblioteca que no sea Knockout.</target>
        </trans-unit>
        <trans-unit id="cce7f1297a779b792b0890892033a0603eadd234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Normally, you&amp;rsquo;d load the view model and template from external files&lt;/strong&gt; instead of declaring them inline like this. We&amp;rsquo;ll get to that later.</source>
          <target state="translated">&lt;strong&gt;Normalmente, cargar&amp;iacute;a el modelo de vista y la plantilla desde archivos externos en&lt;/strong&gt; lugar de declararlos en l&amp;iacute;nea de esta manera. Llegaremos a eso m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="9547e2cb901643dbdb78d8aee63e0abb0b96ab2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Para requisitos tan triviales como validar que una entrada es num&amp;eacute;rica, esta t&amp;eacute;cnica es excesiva. Ser&amp;iacute;a mucho m&amp;aacute;s f&amp;aacute;cil usar jQuery Validation y su clase num&amp;eacute;rica en el elemento &amp;lt;input&amp;gt;. Knockout y jQuery Validation funcionan muy bien juntos, como se demuestra en el ejemplo del &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;editor de cuadr&amp;iacute;cula&lt;/a&gt; . Sin embargo, el ejemplo anterior demuestra un mecanismo m&amp;aacute;s general para filtrar y validar con l&amp;oacute;gica personalizada para controlar qu&amp;eacute; tipo de comentarios de los usuarios aparecen, lo que puede ser &amp;uacute;til si su escenario es m&amp;aacute;s complejo de lo que jQuery Validation maneja de forma nativa.</target>
        </trans-unit>
        <trans-unit id="b19719b50b1d1146b5c1b9e976c239dc581c1e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c1d2bdf3c7252f3d741539a13c27876814e6d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These callbacks are &lt;em&gt;only&lt;/em&gt; intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt; instead, because then you can use that behavior anywhere, independently of the foreach binding.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Estas devoluciones de llamada &lt;em&gt;solo&lt;/em&gt; est&amp;aacute;n destinadas a activar animaciones relacionadas con cambios en una lista. Si su objetivo es en realidad adjuntar otros comportamientos a los nuevos elementos DOM cuando se han agregado (por ejemplo, controladores de eventos o para activar controles de IU de terceros), entonces su trabajo ser&amp;aacute; mucho m&amp;aacute;s f&amp;aacute;cil si implementa ese nuevo comportamiento como una &lt;a href=&quot;custom-bindings&quot;&gt;costumbre vinculante en su&lt;/a&gt; lugar, porque entonces puede usar ese comportamiento en cualquier lugar, independientemente del enlace foreach.</target>
        </trans-unit>
        <trans-unit id="8cf6a6684f50f3ea7a170aa3398f4403873e6036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Parameters:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96f242a46391269bfbcea22f170fb9153b44f393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prevents memory leaks&lt;/strong&gt; from computed observables that are no longer referenced in an application but whose dependencies still exist.</source>
          <target state="translated">&lt;strong&gt;Evita p&amp;eacute;rdidas de memoria&lt;/strong&gt; de observables calculados a los que ya no se hace referencia en una aplicaci&amp;oacute;n, pero cuyas dependencias a&amp;uacute;n existen.</target>
        </trans-unit>
        <trans-unit id="5af02e14314a6af73700df96c09743c910918af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pure JavaScript library&lt;/strong&gt; - works with any server or client-side technology</source>
          <target state="translated">&lt;strong&gt;Biblioteca de JavaScript puro&lt;/strong&gt; : funciona con cualquier servidor o tecnolog&amp;iacute;a del lado del cliente</target>
        </trans-unit>
        <trans-unit id="65b27346b30be7b0a4f38908addd9e6f4370dbcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reduces computation overhead&lt;/strong&gt; by not re-calculating computed observables whose value isn&amp;rsquo;t being observed.</source>
          <target state="translated">&lt;strong&gt;Reduce la sobrecarga de c&amp;aacute;lculo&lt;/strong&gt; al no volver a calcular los observables calculados cuyo valor no se est&amp;aacute; observando.</target>
        </trans-unit>
        <trans-unit id="36974a86b9014bdc65e78c9d0ffe9aae3425befe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Requirements&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38b847315206d412de961c02dd15d22a61454dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return value&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Valor devuelto&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="538d30d06518081cbff7ad599fc04c913bb63f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorthand syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sintaxis taquigr&amp;aacute;fica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c03113c1df32711c668bb01816e62caf66f8cf31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String-based templating&lt;/strong&gt; works only once you&amp;rsquo;ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</source>
          <target state="translated">&lt;strong&gt;Las plantillas basadas en cadenas&lt;/strong&gt; solo funcionan una vez que se ha hecho referencia a un motor de plantillas adecuado, como jQuery.tmpl o el motor de plantillas Underscore.</target>
        </trans-unit>
        <trans-unit id="01f4687a04e08868399938b56a400b5cef0e8132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscriptions&lt;/strong&gt; to observables continue to fire until explicitly disposed.</source>
          <target state="translated">&lt;strong&gt;Las suscripciones&lt;/strong&gt; a observables contin&amp;uacute;an funcionando hasta que se eliminan expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="32f777cc20c7769740052cd86dadccf8d489dfd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is active&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El componente est&amp;aacute; activo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7395eabba8d626f204fa038e96ea461092ce9a5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is torn down, and the viewmodel is disposed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El componente se desmonta y el modelo de vista se elimina&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b6f57d0a651bb6db8d366391beeb0328a19e7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component template is cloned and injected into the container element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La plantilla del componente se clona y se inyecta en el elemento contenedor.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82e6e92787d7eb666a8b10c3b0f889e56b7acf80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The viewmodel is bound to the view&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El modelo de vista est&amp;aacute; vinculado a la vista&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6460afbcbb4cbdec561841a248ba1e6424d666a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This does not take a strict dependency on &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; or any other particular module loader. &lt;em&gt;Any&lt;/em&gt; module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Esto no &lt;a href=&quot;http://requirejs.org/&quot;&gt;requiere&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; una dependencia estricta de &lt;/strong&gt;&lt;strong&gt;require.js&lt;/strong&gt; o cualquier otro cargador de m&amp;oacute;dulos en particular. &lt;em&gt;Cualquier&lt;/em&gt; cargador de m&amp;oacute;dulos que proporcione una API requerida al estilo AMD servir&amp;aacute;. Si desea integrarse con un cargador de m&amp;oacute;dulos cuya API es diferente, puede implementar un &lt;a href=&quot;component-loaders&quot;&gt;cargador de componentes personalizado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04dcd21b22096736da7955495e67376657beed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trivially extensible&lt;/strong&gt; - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</source>
          <target state="translated">&lt;strong&gt;Trivialmente extensible&lt;/strong&gt; : implemente comportamientos personalizados como nuevos enlaces declarativos para una f&amp;aacute;cil reutilizaci&amp;oacute;n en solo unas pocas l&amp;iacute;neas de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="f0992ab4728f88b2a84a0b8caa835c1cf39986f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the component&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usando el componente&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32cbc5d0a2b4f65ca0027e1ba199cc25d7d8a11a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is component loading normally forced to be asynchronous?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; la carga de componentes normalmente se obliga a ser as&amp;iacute;ncrona?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efa66cf89ab1790c16c3bd2f001aebe35bb73112" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why would you ever enable synchronous loading?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; habilitar&amp;iacute;a la carga s&amp;iacute;ncrona?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f570eaf052941ca34607e3a4699d3fedd619ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works on any mainstream browser&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</source>
          <target state="translated">&lt;strong&gt;Funciona en cualquier navegador convencional&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, otros)</target>
        </trans-unit>
        <trans-unit id="b78c43aa7b941a0cf5c09e85ba15c220598279bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your component loaders are asked to supply the viewmodel factory and template&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Se solicita a los cargadores de componentes que proporcionen la f&amp;aacute;brica de modelos de vista y la plantilla&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96c74267b4a56b3e028b9afdd40d0fafdfcfdcb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binding context&lt;/em&gt; is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, that creates a child binding context that refers to the nested view model data.</source>
          <target state="translated">Un &lt;em&gt;contexto de enlace&lt;/em&gt; es un objeto que contiene datos a los que puede hacer referencia desde sus enlaces. Al aplicar enlaces, Knockout crea y gestiona autom&amp;aacute;ticamente una jerarqu&amp;iacute;a de contextos de enlace. El nivel ra&amp;iacute;z de la jerarqu&amp;iacute;a se refiere al par&amp;aacute;metro viewModel que proporcion&amp;oacute; a ko.applyBindings (viewModel). Luego, cada vez que use un enlace de flujo de control como &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; o &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , eso crea un contexto de enlace secundario que hace referencia a los datos del modelo de vista anidada.</target>
        </trans-unit>
        <trans-unit id="f4a248fb269bbbb88f6088e277f3883569cefc2a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;model&lt;/em&gt;: your application&amp;rsquo;s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</source>
          <target state="translated">Un &lt;em&gt;modelo&lt;/em&gt; : los datos almacenados de su aplicaci&amp;oacute;n. Estos datos representan objetos y operaciones en su dominio comercial (por ejemplo, cuentas bancarias que pueden realizar transferencias de dinero) y son independientes de cualquier interfaz de usuario. Cuando use KO, generalmente har&amp;aacute; llamadas Ajax a alg&amp;uacute;n c&amp;oacute;digo del lado del servidor para leer y escribir estos datos de modelo almacenados.</target>
        </trans-unit>
        <trans-unit id="672cec499a5e1f1cee87a332d86b3b33abc231fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pure&lt;/em&gt; computed observable automatically switches between two states based on whether it has change subscribers.</source>
          <target state="translated">Un observable calculado &lt;em&gt;puro&lt;/em&gt; cambia autom&amp;aacute;ticamente entre dos estados en funci&amp;oacute;n de si tiene suscriptores de cambio.</target>
        </trans-unit>
        <trans-unit id="59bc15f49d66eaa773779760f79faa3fa9423729" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view model&lt;/em&gt;: a pure-code representation of the data and operations on a UI. For example, if you&amp;rsquo;re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</source>
          <target state="translated">Un &lt;em&gt;modelo de vista&lt;/em&gt; : una representaci&amp;oacute;n de c&amp;oacute;digo puro de los datos y las operaciones en una interfaz de usuario. Por ejemplo, si est&amp;aacute; implementando un editor de listas, su modelo de vista ser&amp;iacute;a un objeto que contiene una lista de elementos y expone m&amp;eacute;todos para agregar y eliminar elementos.</target>
        </trans-unit>
        <trans-unit id="eace4ec15816838615483a0f9f07130cd593dae7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt;: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</source>
          <target state="translated">Una &lt;em&gt;vista&lt;/em&gt; : una interfaz de usuario interactiva y visible que representa el estado del modelo de vista. Muestra informaci&amp;oacute;n del modelo de vista, env&amp;iacute;a comandos al modelo de vista (por ejemplo, cuando el usuario hace clic en los botones) y se actualiza cada vez que cambia el estado del modelo de vista.</target>
        </trans-unit>
        <trans-unit id="ca93da47b0c5a3da43e52690cd086f2e1a2ebd77" translate="yes" xml:space="preserve">
          <source>A DOM node being added to the document</source>
          <target state="translated">Un nodo DOM que se está agregando al documento</target>
        </trans-unit>
        <trans-unit id="d551d8332829826ecacd9fb849d14363184a926a" translate="yes" xml:space="preserve">
          <source>A DOM node that may be about to move</source>
          <target state="translated">Un nodo DOM que puede estar a punto de moverse</target>
        </trans-unit>
        <trans-unit id="6331cd6f9ebb43fddcf15dfc9b7fb432c2f730af" translate="yes" xml:space="preserve">
          <source>A DOM node that may have moved</source>
          <target state="translated">Un nodo DOM que puede haberse movido</target>
        </trans-unit>
        <trans-unit id="9a3f7e5611e70df33d8f227c6f7b7360a7dd399e" translate="yes" xml:space="preserve">
          <source>A DOM node that you should remove</source>
          <target state="translated">Un nodo DOM que deberías quitar</target>
        </trans-unit>
        <trans-unit id="73d257d4d5c6be661a1e19a48818fd69414e6730" translate="yes" xml:space="preserve">
          <source>A JavaScript object whose properties will be copied to the binding context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9b23eb6c3fecb0a19eee9723a2f762712f465" translate="yes" xml:space="preserve">
          <source>A binding consists of two items, the binding &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;, separated by a colon. Here is an example of a single, simple binding:</source>
          <target state="translated">Un enlace consta de dos elementos, el &lt;em&gt;nombre&lt;/em&gt; y el &lt;em&gt;valor&lt;/em&gt; del enlace , separados por dos puntos. A continuaci&amp;oacute;n, se muestra un ejemplo de un enlace &amp;uacute;nico y simple:</target>
        </trans-unit>
        <trans-unit id="b97f27c6008d5459bdb04cdb810c301f0271f67b" translate="yes" xml:space="preserve">
          <source>A computed observable can be constructed using one of the following forms:</source>
          <target state="translated">Un observable computarizado puede construirse utilizando una de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="9b3c42d55504f21b1b9ff8c6dc937021d9e0fbbb" translate="yes" xml:space="preserve">
          <source>A computed observable provides the following functions:</source>
          <target state="translated">Un observable computarizado proporciona las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="ee2ee99b4fbef7f88d22ec53a5ac2485da3ddb43" translate="yes" xml:space="preserve">
          <source>A constructor function</source>
          <target state="translated">Una función de constructor</target>
        </trans-unit>
        <trans-unit id="d421b1fb0fc49225f6485c171df52e5c3cf18816" translate="yes" xml:space="preserve">
          <source>A createViewModel factory function</source>
          <target state="translated">Una función de la fábrica createViewModel</target>
        </trans-unit>
        <trans-unit id="3140686e93078602a724ffd63d00b2000a63120a" translate="yes" xml:space="preserve">
          <source>A custom component loader is simply an object whose properties are &lt;strong&gt;any combination&lt;/strong&gt; of the following functions:</source>
          <target state="translated">Un cargador de componentes personalizados es simplemente un objeto cuyas propiedades son &lt;strong&gt;cualquier combinaci&amp;oacute;n&lt;/strong&gt; de las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="875be908e85823e41220d8f215eb69acb7523ecf" translate="yes" xml:space="preserve">
          <source>A custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,</source>
          <target state="translated">Un elemento personalizado puede tener un atributo regular de unión de datos (además de cualquier atributo de parámesis)si es necesario.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="ed4ac8818951d35d2d4f2644dd9eaf887a755c40" translate="yes" xml:space="preserve">
          <source>A custom function that will handle the scheduling of notifications. For example, you could use Underscore&amp;rsquo;s throttle method: myObservable.extend({ rateLimit: { timeout: 500, method: _.throttle } }); For more details, see the section below on custom rate-limit methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbce704022becdf28532ea1454acbf19683d7755" translate="yes" xml:space="preserve">
          <source>A document fragment</source>
          <target state="translated">Un fragmento de documento</target>
        </trans-unit>
        <trans-unit id="a84827e1e80c6d853c30bc27f2185443890c1904" translate="yes" xml:space="preserve">
          <source>A popular convention that simplifies things</source>
          <target state="translated">Una convención popular que simplifica las cosas</target>
        </trans-unit>
        <trans-unit id="0fb40af78bc85a323dc4a804096a956f6e13aef0" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies an awake event (using its current value) whenever it enters the &lt;em&gt;listening&lt;/em&gt; state and notifies an asleep event (using an undefined value) whevener it enter the &lt;em&gt;sleeping&lt;/em&gt; state. You won&amp;rsquo;t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="translated">Un notifica observables un evento pura computarizada despierto (usando su valor actual) cada vez que entra en la &lt;em&gt;escucha&lt;/em&gt; del estado y notifica un evento dormidos (con un valor indefinido) whevener que entre en el &lt;em&gt;dormir&lt;/em&gt; estado. Normalmente, no necesitar&amp;aacute; conocer el estado interno de sus observables calculados. Pero dado que el estado interno puede corresponder a si el observable calculado est&amp;aacute; vinculado a la vista o no, puede usar esa informaci&amp;oacute;n para realizar alguna inicializaci&amp;oacute;n o limpieza del modelo de vista.</target>
        </trans-unit>
        <trans-unit id="d17d0e20bbc6723a6f53f7095e5b9e515f8490db" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies some events that allow you to respond to changes to the state of the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219abd734eaa39b3e5af5d4aae85aae74f210ba7" translate="yes" xml:space="preserve">
          <source>A recommended AMD module pattern</source>
          <target state="translated">Un patrón de módulo AMD recomendado</target>
        </trans-unit>
        <trans-unit id="96a16d06ab9525707f973555c03a9a069b2890ef" translate="yes" xml:space="preserve">
          <source>A shared object instance</source>
          <target state="translated">Una instancia de objeto compartido</target>
        </trans-unit>
        <trans-unit id="f05cd21e831a202875a8dffd0d37c25b82bec9e6" translate="yes" xml:space="preserve">
          <source>A simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:</source>
          <target state="translated">Una opción más simple y elegante,sin embargo,es utilizar como declarar un nombre para sus variables de iteración.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a7c8841f5e8f9c936c29327e4d6733bdab3c12e1" translate="yes" xml:space="preserve">
          <source>A string of markup</source>
          <target state="translated">Una cadena de marcado</target>
        </trans-unit>
        <trans-unit id="41a59868d9ef75167ce556f0565eb922f6cc31f5" translate="yes" xml:space="preserve">
          <source>A value that controls whether or not the associated DOM element should be enabled.</source>
          <target state="translated">Un valor que controla si el elemento DOM asociado debe ser habilitado o no.</target>
        </trans-unit>
        <trans-unit id="1629231a910c1a9903f050df95a79a00ff663fe9" translate="yes" xml:space="preserve">
          <source>AMD modules are loaded only on demand</source>
          <target state="translated">Los módulos AMD se cargan sólo a petición</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="dba104dad21c672e8d177c331e1988224ee9c40f" translate="yes" xml:space="preserve">
          <source>Activating Knockout</source>
          <target state="translated">Activando el Knockout</target>
        </trans-unit>
        <trans-unit id="9e50bbf06486aad9ed5858d61f790ecc35cf4bdb" translate="yes" xml:space="preserve">
          <source>Adding custom functions using &quot;fn&quot;</source>
          <target state="translated">Añadir funciones personalizadas usando &quot;fn&quot;</target>
        </trans-unit>
        <trans-unit id="5f55b709f75ff470666d48ed8e0dd3202f9462b3" translate="yes" xml:space="preserve">
          <source>Additional benefits:</source>
          <target state="translated">Beneficios adicionales:</target>
        </trans-unit>
        <trans-unit id="d9ca1471a1c5c73c1eaf333a7d893c103077a28a" translate="yes" xml:space="preserve">
          <source>Additional parameters</source>
          <target state="translated">Parámetros adicionales</target>
        </trans-unit>
        <trans-unit id="2eecc85d283c6cfc2c01cf8cf19d07776798fd03" translate="yes" xml:space="preserve">
          <source>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</source>
          <target state="translated">Además,Knockout proporciona funciones similares que pueden operar en observables y observables computarizados:</target>
        </trans-unit>
        <trans-unit id="69d691f44445960d684f25080c894d46d0ef6515" translate="yes" xml:space="preserve">
          <source>Advanced queue control</source>
          <target state="translated">Control avanzado de la cola</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">Uso avanzado</target>
        </trans-unit>
        <trans-unit id="bdafa12daa294233db606dc624e7cfa8736c4318" translate="yes" xml:space="preserve">
          <source>Advanced: Accessing $raw parameters</source>
          <target state="translated">Avanzado:Acceder a los parámetros de $raw</target>
        </trans-unit>
        <trans-unit id="acb27fde407851516098c690ede0080b631c0f01" translate="yes" xml:space="preserve">
          <source>Advanced: Custom component loaders</source>
          <target state="translated">Avanzado:Cargadores de componentes personalizados</target>
        </trans-unit>
        <trans-unit id="6b68add7c4ef423265bf6c36f75e07b61ca328f2" translate="yes" xml:space="preserve">
          <source>After you have defined the module update the input element from the HTML example above to be:</source>
          <target state="translated">Después de haber definido el módulo actualizar el elemento de entrada del ejemplo HTML anterior a ser:</target>
        </trans-unit>
        <trans-unit id="329df29582c6ec3024bef034171a5a78bd9cbb39" translate="yes" xml:space="preserve">
          <source>Again, only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned for use as the component&amp;rsquo;s template.</source>
          <target state="translated">Nuevamente, solo los nodos &lt;em&gt;dentro&lt;/em&gt; del elemento especificado se clonar&amp;aacute;n para usarlos como plantilla del componente.</target>
        </trans-unit>
        <trans-unit id="a9180eedfdd61587618067116c1c45385c35cb38" translate="yes" xml:space="preserve">
          <source>All change notifications are delayed, including when calling valueHasMutated manually. This means you can&amp;rsquo;t use valueHasMutated to force a rate-limited observable to notify an un-changed value.</source>
          <target state="translated">Todas las notificaciones de cambio se retrasan, incluso cuando se llama a valueHasMutated manualmente. Esto significa que no puede usar valueHasMutated para forzar a un observable de tasa limitada a notificar un valor sin cambios.</target>
        </trans-unit>
        <trans-unit id="1faff78215a2b42eb91a45b8356b4f79235b938d" translate="yes" xml:space="preserve">
          <source>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</source>
          <target state="translated">Todas estas funciones equivalen a ejecutar las funciones de la matriz nativa de JavaScript en la matriz subyacente,y luego notificar a los oyentes sobre el cambio:</target>
        </trans-unit>
        <trans-unit id="2c9de1c05e289fb463cf3a1c26f4670e737ed411" translate="yes" xml:space="preserve">
          <source>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</source>
          <target state="translated">Todas las propiedades de un objeto se convierten en observables.Si una actualización cambiara el valor,actualizaría el observable.</target>
        </trans-unit>
        <trans-unit id="38c026ebda36ef4388e796344b3abce466922b2b" translate="yes" xml:space="preserve">
          <source>Also, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.</source>
          <target state="translated">Además,randomOrder seguirá funcionando con elementos DOM regulares,porque todas las APIs de ko.virtualElements son compatibles con elementos DOM regulares.</target>
        </trans-unit>
        <trans-unit id="8fda4896a6cfabf38010923d25545054759b05e1" translate="yes" xml:space="preserve">
          <source>Also, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</source>
          <target state="translated">Además,como ko.components.defaultLoader es un cargador de componentes,implementa las siguientes funciones estándar del cargador de componentes.Puede invocarlas directamente,por ejemplo,como parte de su implementación de un cargador personalizado:</target>
        </trans-unit>
        <trans-unit id="4edfae09ecfcc29756a62316c12a008c591612f8" translate="yes" xml:space="preserve">
          <source>Also, you need to have referenced a suitable module loader library (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) or implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that knows how to grab your files.</source>
          <target state="translated">Adem&amp;aacute;s, debe haber hecho referencia a una biblioteca de cargador de m&amp;oacute;dulos adecuada (como &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) o haber implementado un &lt;a href=&quot;component-loaders&quot;&gt;cargador de componentes personalizado&lt;/a&gt; que sepa c&amp;oacute;mo capturar sus archivos.</target>
        </trans-unit>
        <trans-unit id="db4db8b9b399a9292d2681e94db2f56cc50be27a" translate="yes" xml:space="preserve">
          <source>Alternatively, components also support a direct method to receive a descendantsComplete notification. If your component view model has a koDescendantsComplete function, Knockout will call it with the component&amp;rsquo;s node once all descendants are bound. For example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5cc861eaf7ac508de6b2b58d1ed770fee1e988" translate="yes" xml:space="preserve">
          <source>Alternatively, if you prefer to avoid the function literal in your view, you can use the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; function, which attaches specific parameter values to a function reference:</source>
          <target state="translated">Alternativamente, si prefiere evitar la funci&amp;oacute;n literal en su vista, puede usar la funci&amp;oacute;n de &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;vinculaci&amp;oacute;n&lt;/a&gt; , que adjunta valores de par&amp;aacute;metros espec&amp;iacute;ficos a una referencia de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="fa6e7ea09a57e761a9110c8a9df4784c24443111" translate="yes" xml:space="preserve">
          <source>Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed &amp;mdash; see below for details of these extra options and examples of their use.</source>
          <target state="translated">Alternativamente, pase un objeto literal de JavaScript con una propiedad llamada datos que es la matriz sobre la que desea iterar. El objeto literal tambi&amp;eacute;n puede tener otras propiedades, como afterAdd o includeDestroyed; consulte a continuaci&amp;oacute;n los detalles de estas opciones adicionales y ejemplos de su uso.</target>
        </trans-unit>
        <trans-unit id="b7dfbc21d336e304b1aefd8da00433e7d002f8f1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;override getComponentNameForNode&lt;/a&gt; to control dynamically which elements map to which component names, independently of preregistration.</source>
          <target state="translated">Alternativamente, puede &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;anular getComponentNameForNode&lt;/a&gt; para controlar din&amp;aacute;micamente qu&amp;eacute; elementos se asignan a qu&amp;eacute; nombres de componentes, independientemente del registro previo.</target>
        </trans-unit>
        <trans-unit id="ae14a33d0421d469795c28cb8d6c7b5a300d1437" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the pure option with ko.computed:</source>
          <target state="translated">Alternativamente,puedes usar la opción pura con ko.computed:</target>
        </trans-unit>
        <trans-unit id="c6881ab5fe1c9360a98b31b040fcb030610e5b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you don&amp;rsquo;t need to create a computed observable if you&amp;rsquo;re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,</source>
          <target state="translated">Alternativamente, no necesita crear un observable calculado si est&amp;aacute; haciendo algo simple como esto. Puede pasar una expresi&amp;oacute;n JavaScript arbitraria al enlace de texto. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="467b199c0d9c0c472351991602cecc7ed24eedcf" translate="yes" xml:space="preserve">
          <source>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly method&lt;/a&gt;. For example:</source>
          <target state="translated">Aunque las notificaciones asincr&amp;oacute;nicas diferidas son generalmente mejores debido a que hay menos actualizaciones de la interfaz de usuario, puede ser un problema si necesita actualizar la interfaz de usuario de inmediato. A veces, para una funcionalidad adecuada, necesita un valor intermedio enviado a la interfaz de usuario. Puede lograr esto usando el &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;m&amp;eacute;todo ko.tasks.runEarly&lt;/a&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="cccda6b76e9fe36a78cbb8b19672fab53b808ae3" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;value-binding&quot;&gt;value binding&lt;/a&gt; can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:</source>
          <target state="translated">Aunque el &lt;a href=&quot;value-binding&quot;&gt;enlace de valor&lt;/a&gt; tambi&amp;eacute;n puede realizar un enlace bidireccional entre los cuadros de texto y las propiedades del modelo de vista, debe preferir textInput siempre que desee actualizaciones en vivo inmediatas. Las principales diferencias son:</target>
        </trans-unit>
        <trans-unit id="54e9247f8574a1aa66c8291b2a6f5cecfef75b1e" translate="yes" xml:space="preserve">
          <source>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.</source>
          <target state="translated">Aunque los nodos DOM de este elemento serán despojados y no limitados por defecto,no se pierden.En su lugar,se suministran al componente (en este caso,a mi lista especial),que puede incluirlos en su salida como desee.</target>
        </trans-unit>
        <trans-unit id="065f5f46184d6f9b66cb0337f9c8985d191e4c55" translate="yes" xml:space="preserve">
          <source>Although you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64e2a25f4ecdbf890fa878004386d735536f164" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a template</source>
          <target state="translated">Un módulo AMD cuyo valor describe una plantilla</target>
        </trans-unit>
        <trans-unit id="e68eb6e1b6701b3c386d6f393c8c2332fcca13e2" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a viewmodel</source>
          <target state="translated">Un módulo AMD cuyo valor describe un modelo de vista</target>
        </trans-unit>
        <trans-unit id="242417090831cde58cc194cc22ae4eab474f143d" translate="yes" xml:space="preserve">
          <source>An array of DOM nodes</source>
          <target state="translated">Un conjunto de nodos DOM</target>
        </trans-unit>
        <trans-unit id="968a4f61a70888dd1fa2a0eb32b82dc937a8263d" translate="yes" xml:space="preserve">
          <source>An array of the inserted DOM elements</source>
          <target state="translated">Un conjunto de los elementos DOM insertados</target>
        </trans-unit>
        <trans-unit id="677bc5c11af17aad4286438791881da11106a6b3" translate="yes" xml:space="preserve">
          <source>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</source>
          <target state="translated">Un elemento puede incluir múltiples uniones (relacionadas o no),con cada unión separada por una coma.A continuación se presentan algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="4d626c0f133638f459d4ffb6d3a56ba114d6d9ce" translate="yes" xml:space="preserve">
          <source>An existing element ID</source>
          <target state="translated">Un elemento existente ID</target>
        </trans-unit>
        <trans-unit id="e36639c5e653a711057a5a79fa2fd56cc32a4737" translate="yes" xml:space="preserve">
          <source>An existing element instance</source>
          <target state="translated">Una instancia de elemento existente</target>
        </trans-unit>
        <trans-unit id="f48281418a421e56b65e2f335f96fc8ee14c0591" translate="yes" xml:space="preserve">
          <source>An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.</source>
          <target state="translated">Un objeto cuyas claves determinan qué ataduras son utilizables con elementos virtuales.Establezca ko.virtualElements.allowedBindings.mySuperBinding=true para permitir que mySuperBinding se utilice con elementos virtuales.</target>
        </trans-unit>
        <trans-unit id="dd15fd1ba5ddf1cc618917899b23e48ea396d2d4" translate="yes" xml:space="preserve">
          <source>An observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e1b4a97e09ed466c53a7a581f325eb74fda90" translate="yes" xml:space="preserve">
          <source>And name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!</source>
          <target state="translated">Y el nombre habría cambiado como se esperaba.Sin embargo,en el conjunto de niños,el niño (Alicw)habría sido eliminado completamente y se habría añadido uno nuevo (Alice).Esto no es completamente lo que se esperaba.En su lugar,habría esperado que sólo la propiedad del nombre del niño se actualizara de Alicw a Alice,¡no que todo el niño fuera reemplazado!</target>
        </trans-unit>
        <trans-unit id="e9ca86081be1235e5d657f4784b8eda45576a203" translate="yes" xml:space="preserve">
          <source>Any existing content is removed and discarded.</source>
          <target state="translated">Cualquier contenido existente es eliminado y descartado.</target>
        </trans-unit>
        <trans-unit id="4f4f05405754c54fdd9676fba604372b29335c05" translate="yes" xml:space="preserve">
          <source>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their *JS counterparts.</source>
          <target state="translated">Aparte del hecho de que trabajan con cadenas JSON en lugar de objetos JS,estas funciones son completamente idénticas a sus contrapartes *JS.</target>
        </trans-unit>
        <trans-unit id="7f1ccfc969139d4ee723e3cd26a3b87a5f4bd6fb" translate="yes" xml:space="preserve">
          <source>Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });</source>
          <target state="translated">Las aplicaciones pueden hacer referencia a esto trivialmente,es decir,ko.components.register('mi-componente',{require:'path/my-component' });</target>
        </trans-unit>
        <trans-unit id="c1c42fc46dfc0ee9be1215927e31c8ac247229ec" translate="yes" xml:space="preserve">
          <source>Applying multiple extenders</source>
          <target state="translated">Aplicando múltiples extensores</target>
        </trans-unit>
        <trans-unit id="bb775857f1edfb66da986af1438cdd40f990f61d" translate="yes" xml:space="preserve">
          <source>Applying the rateLimit extender</source>
          <target state="translated">Aplicando el extensor de la tasaLimit</target>
        </trans-unit>
        <trans-unit id="a30bfe9fb3fdb4e5e2bd1e24672ab720fe7f064f" translate="yes" xml:space="preserve">
          <source>Arrays are converted into &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt;. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</source>
          <target state="translated">Las matrices se convierten en &lt;a href=&quot;observablearrays&quot;&gt;matrices observables&lt;/a&gt; . Si una actualizaci&amp;oacute;n cambia la cantidad de elementos, realizar&amp;aacute; las acciones de agregar / quitar apropiadas. Tambi&amp;eacute;n intentar&amp;aacute; mantener el orden igual que la matriz JavaScript original.</target>
        </trans-unit>
        <trans-unit id="64e6eb4e5415e08468cb571b630e6982ce45a64e" translate="yes" xml:space="preserve">
          <source>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</source>
          <target state="translated">Como alternativa,Knockout proporciona dos funciones de ayuda que permiten identificar los datos asociados a un elemento DOM:</target>
        </trans-unit>
        <trans-unit id="18bd9d7dc396ea105d8584c5d8a67ce95140998c" translate="yes" xml:space="preserve">
          <source>As an array, $componentTemplateNodes, available to any binding expression in the component&amp;rsquo;s template (i.e., as a &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; property). Usually this is the most convenient way to use the supplied markup. See the example below.</source>
          <target state="translated">Como una matriz, $ componentTemplateNodes, disponible para cualquier expresi&amp;oacute;n de enlace en la plantilla del componente (es decir, como una propiedad de &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; ). Por lo general, esta es la forma m&amp;aacute;s conveniente de utilizar el marcado proporcionado. Vea el ejemplo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bdc42cbe041397354fa48d36ba2fff1663ff9d0f" translate="yes" xml:space="preserve">
          <source>As an array, componentInfo.templateNodes, passed to its &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel function&lt;/a&gt;</source>
          <target state="translated">Como una matriz, componentInfo.templateNodes, pasada a su &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;funci&amp;oacute;n createViewModel&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ab4f1ab556f0024f4505366ba60640abe3aa3a6" translate="yes" xml:space="preserve">
          <source>As described in Note 1, you can refer to each array entry using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;. In some cases though, it may be useful to give the current item a more descriptive name using the as option like:</source>
          <target state="translated">Como se describe en la Nota 1, puede hacer referencia a cada entrada de la matriz utilizando la &lt;a href=&quot;binding-context&quot;&gt;variable de contexto&lt;/a&gt; $ data . Sin embargo, en algunos casos, puede ser &amp;uacute;til darle al elemento actual un nombre m&amp;aacute;s descriptivo usando la opci&amp;oacute;n as como:</target>
        </trans-unit>
        <trans-unit id="c9e6cce525faa11e83082f916934eb369ee22979" translate="yes" xml:space="preserve">
          <source>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</source>
          <target state="translated">Como se ilustra en este ejemplo,el KO pasa el elemento de forma como un parámetro a su función de controlador de envío.Puedes ignorar ese parámetro si quieres,o hay varias formas en las que podrías querer usarlo,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5900cfc0e230ba6370b7536d4e0bc93369597873" translate="yes" xml:space="preserve">
          <source>As long as they reference different CSS class names, you can include both class and css bindings on the same element. Thus you can have some classes that are set based on a true/false value and others that are calculated dynamically. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb01af05163d90a3c9bcdc7eb32c655738d0ff1e" translate="yes" xml:space="preserve">
          <source>As shown above, the changes are reported as a list of &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values. The indexes for &lt;em&gt;deleted&lt;/em&gt; items refer to the original array, and the indexes for &lt;em&gt;added&lt;/em&gt; items refer to the new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40531ab2533e66fef97d544b345056144f69e728" translate="yes" xml:space="preserve">
          <source>As shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; referenced the firstName and lastName properties on each array entry.</source>
          <target state="translated">Como se muestra en los ejemplos anteriores, los enlaces dentro del bloque foreach pueden hacer referencia a propiedades en las entradas de la matriz. Por ejemplo, el &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Ejemplo 1 hizo&lt;/a&gt; referencia a las propiedades firstName y lastName en cada entrada de la matriz.</target>
        </trans-unit>
        <trans-unit id="03dd56f30baeedf6f43ffeb0f96b6c0c125970f3" translate="yes" xml:space="preserve">
          <source>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you&amp;rsquo;re displaying a list of items, stating the number of items in that list, and want to enable an &amp;lsquo;Add&amp;rsquo; button only when there are fewer than 5 items. jQuery doesn&amp;rsquo;t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN&amp;rsquo;s text when the user adds an item. You also must remember to disable the &amp;lsquo;Add&amp;rsquo; button when the number of TRs is 5. Later, you&amp;rsquo;re asked also to implement a &amp;lsquo;Delete&amp;rsquo; button and you have to figure out which DOM elements to change whenever it&amp;rsquo;s clicked.</source>
          <target state="translated">Tan pronto como su interfaz de usuario no sea trivial y tenga algunos comportamientos superpuestos, las cosas pueden volverse complicadas y costosas de mantener si solo usa jQuery. Considere un ejemplo: est&amp;aacute; mostrando una lista de elementos, indicando la cantidad de elementos en esa lista y desea habilitar un bot&amp;oacute;n 'Agregar' solo cuando hay menos de 5 elementos. jQuery no tiene un concepto de un modelo de datos subyacente, por lo que para obtener la cantidad de elementos, debe inferirla a partir de la cantidad de TR en una tabla o la cantidad de DIV con una determinada clase CSS. Tal vez el n&amp;uacute;mero de elementos se muestre en alg&amp;uacute;n SPAN, y debe recordar actualizar el texto de ese SPAN cuando el usuario agrega un elemento. Tambi&amp;eacute;n debe recordar deshabilitar el bot&amp;oacute;n 'Agregar' cuando el n&amp;uacute;mero de TRs sea 5. M&amp;aacute;s tarde, tambi&amp;eacute;n se le pedir&amp;aacute; que implemente un bot&amp;oacute;n 'Eliminar' y debe averiguar qu&amp;eacute; elementos DOM cambiar cada vez que se hace clic en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="3824481999af1a08c2a42310b9623d970b4c8e60" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="translated">Como de costumbre,puede usar expresiones o funciones arbitrarias de JavaScript como valores de los parámetros.KO las evaluará y usará los valores resultantes para determinar los valores de estilo a aplicar.</target>
        </trans-unit>
        <trans-unit id="ce18070a48ec4dcf3c21d8c773695eaa7e43f60a" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="translated">Como de costumbre,puede usar expresiones o funciones arbitrarias de JavaScript como valores de los parámetros.KO las evaluará y usará los valores resultantes para determinar las clases CSS apropiadas para agregar o quitar.</target>
        </trans-unit>
        <trans-unit id="be219c6df3733113cae67ffbcbc8620e153c2b9c" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting value to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4da197852de89fac4dcfd406e4865e31c17c79" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fd897b08c686dca588676f977987af4cbc17de" translate="yes" xml:space="preserve">
          <source>As well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; you may be using.</source>
          <target state="translated">Adem&amp;aacute;s de (o en lugar de) plantilla y viewModel, el objeto de configuraci&amp;oacute;n de su componente puede tener otras propiedades arbitrarias. Este objeto de configuraci&amp;oacute;n est&amp;aacute; disponible para cualquier &lt;a href=&quot;component-loaders&quot;&gt;cargador de componentes personalizados&lt;/a&gt; que pueda estar utilizando.</target>
        </trans-unit>
        <trans-unit id="271643e4723e546ecfd37518fb0f1e341e319028" translate="yes" xml:space="preserve">
          <source>As you can see from Example 2 above, it&amp;rsquo;s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">Como puede ver en el Ejemplo 2 anterior, es posible usar $ index para hacer referencia al &amp;iacute;ndice de base cero del elemento de matriz actual. $ index es un observable y se actualiza cada vez que cambia el &amp;iacute;ndice del elemento (por ejemplo, si se agregan o eliminan elementos de la matriz).</target>
        </trans-unit>
        <trans-unit id="cabec4e28a1cc149d5844e47658d55240bebd319" translate="yes" xml:space="preserve">
          <source>As you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn&amp;rsquo;t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</source>
          <target state="translated">Como puede ver, los contextos vinculantes tienen una funci&amp;oacute;n de extensi&amp;oacute;n que produce un clon con propiedades adicionales. La funci&amp;oacute;n de extensi&amp;oacute;n acepta un objeto con las propiedades para copiar o una funci&amp;oacute;n que devuelve tal objeto. Se prefiere la sintaxis de la funci&amp;oacute;n para que los cambios futuros en el valor de enlace siempre se actualicen en el contexto de enlace. Este proceso no afecta el contexto de enlace original, por lo que no hay peligro de que afecte a los elementos del nivel de hermanos; solo afectar&amp;aacute; a los descendientes.</target>
        </trans-unit>
        <trans-unit id="9ea6690b6b5207f9ef37a626e0bbe8a12a55cab9" translate="yes" xml:space="preserve">
          <source>As you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:</source>
          <target state="translated">Como se ha visto en los ejemplos anteriores,se puede utilizar un atributo de parámeros para suministrar parámetros al modelo de vista de los componentes.El contenido del atributo params se interpreta como un objeto literal de JavaScript (igual que un atributo de unión de datos),por lo que puede pasar valores arbitrarios de cualquier tipo.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e34c40ba0f5fa3fb6eb13d61c372271984f13555" translate="yes" xml:space="preserve">
          <source>Assuming your array is an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.</source>
          <target state="translated">Suponiendo que su matriz es una &lt;a href=&quot;observablearrays&quot;&gt;matriz observable&lt;/a&gt; , cada vez que agregue, elimine o reordene entradas de matriz, el enlace actualizar&amp;aacute; eficientemente la interfaz de usuario para que coincida, insertando o eliminando m&amp;aacute;s copias del marcado, o reordenando los elementos DOM existentes, sin afectando a cualquier otro elemento DOM. Esto es mucho m&amp;aacute;s r&amp;aacute;pido que regenerar toda la salida de foreach despu&amp;eacute;s de cada cambio de matriz.</target>
        </trans-unit>
        <trans-unit id="0a29a876f6fee0ab06e8d6374c2a1f8b7410a520" translate="yes" xml:space="preserve">
          <source>Asynchronous Module Definition (AMD) With RequireJs</source>
          <target state="translated">Definición de Módulo Asíncrono (AMD)con Requerimientos de J</target>
        </trans-unit>
        <trans-unit id="f15ea1e1d443f1c22a341a9e0edeca34b288d76c" translate="yes" xml:space="preserve">
          <source>Asynchronous error handling</source>
          <target state="translated">Manejo de errores asincrónicos</target>
        </trans-unit>
        <trans-unit id="f8b6cc5cdc6b8261c411bf780fb442ecccc793b5" translate="yes" xml:space="preserve">
          <source>Asynchronous module definition (AMD) with requireJs</source>
          <target state="translated">Definición de módulo asíncrono (AMD)con requireJs</target>
        </trans-unit>
        <trans-unit id="4669c785b85f8d268aedb9a3b7494a7c8313488f" translate="yes" xml:space="preserve">
          <source>Because of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.</source>
          <target state="translated">Debido a la herencia,si se adjunta una función a ko.subscribable,estará disponible en todos los demás también.Si adjuntas una función a ko.observable,será heredada por ko.observableArray pero no por ko.computed.</target>
        </trans-unit>
        <trans-unit id="3aa536687687d7362ee99aa5d4ec974df63a5c14" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="translated">Debido a que self se captura en el cierre de la funci&amp;oacute;n, permanece disponible y consistente en cualquier funci&amp;oacute;n anidada, como el evaluador del observable calculado. Esta convenci&amp;oacute;n es a&amp;uacute;n m&amp;aacute;s &amp;uacute;til cuando se trata de controladores de eventos, como ver&amp;aacute; en muchos de los &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;ejemplos en vivo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd834cbc10e441f97b7b77e9db5957d9221be9db" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;https://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550907ac1f6696f0600c8c1a60187b368d514a83" translate="yes" xml:space="preserve">
          <source>Because the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$.getJSON function&lt;/a&gt; to reload currentPageData when a GridViewModel is first instantiated &lt;em&gt;and&lt;/em&gt; whenever the pageIndex or pageSize properties are later changed.</source>
          <target state="translated">Debido a que el observable calculado eval&amp;uacute;a tanto pageIndex como pageSize, se vuelve dependiente de ambos. Por lo tanto, este c&amp;oacute;digo usar&amp;aacute; la &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;funci&amp;oacute;n $ .getJSON de&lt;/a&gt; jQuery para recargar currentPageData cuando se crea una instancia de GridViewModel por primera vez &lt;em&gt;y&lt;/em&gt; cada vez que se cambian las propiedades pageIndex o pageSize.</target>
        </trans-unit>
        <trans-unit id="0c00e991fcf301ea36ef0431f7266e3845d6942f" translate="yes" xml:space="preserve">
          <source>Because the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it&amp;rsquo;s a convenient way to toggle an &amp;ldquo;edit&amp;rdquo; mode. In this example, the UI displays either a &amp;lt;span&amp;gt; or an &amp;lt;input&amp;gt; element depending on the model&amp;rsquo;s editing property. Unfocusing the &amp;lt;input&amp;gt; element sets editing to false, so the UI switches out of &amp;ldquo;edit&amp;rdquo; mode.</source>
          <target state="translated">Debido a que el enlace hasFocus funciona en ambas direcciones (establecer el valor asociado enfoca o desenfoca el elemento; enfocar o desenfocar el elemento establece el valor asociado), es una forma conveniente de alternar un modo de &quot;edici&amp;oacute;n&quot;. En este ejemplo, la interfaz de usuario muestra un elemento &amp;lt;span&amp;gt; o &amp;lt;input&amp;gt; seg&amp;uacute;n la propiedad de edici&amp;oacute;n del modelo. Al desenfocar el elemento &amp;lt;input&amp;gt;, la edici&amp;oacute;n se establece en falso, por lo que la interfaz de usuario sale del modo &quot;editar&quot;.</target>
        </trans-unit>
        <trans-unit id="bd8beb104f73636a98fcd6cda7c1acde17a32e28" translate="yes" xml:space="preserve">
          <source>Behind the scenes, an observableArray is actually an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</source>
          <target state="translated">Detr&amp;aacute;s de escena, un observableArray es en realidad un &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; cuyo valor es una matriz (adem&amp;aacute;s, observableArray agrega algunas caracter&amp;iacute;sticas adicionales que se describen a continuaci&amp;oacute;n). Por lo tanto, puede obtener la matriz de JavaScript subyacente invocando observableArray como una funci&amp;oacute;n sin par&amp;aacute;metros, como cualquier otro observable. Luego, puede leer la informaci&amp;oacute;n de esa matriz subyacente. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="9cd4c935e79a15a4f2de856a72f11306af77e87c" translate="yes" xml:space="preserve">
          <source>Better yet, this techinique could be used to support event delegation. jQuery&amp;rsquo;s live/delegate/on functions are an easy way to make this happen:</source>
          <target state="translated">Mejor a&amp;uacute;n, esta t&amp;eacute;cnica podr&amp;iacute;a usarse para apoyar la delegaci&amp;oacute;n de eventos. Las funciones live / delegate / on de jQuery son una manera f&amp;aacute;cil de hacer que esto suceda:</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="3a81a526cb1140d2e424d0180bf85d9cd3d1c460" translate="yes" xml:space="preserve">
          <source>Binding context</source>
          <target state="translated">Contexto vinculante</target>
        </trans-unit>
        <trans-unit id="93d552de279f9f9e13483b79acf3dd9808266d2b" translate="yes" xml:space="preserve">
          <source>Binding lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f722c7a7e44d3deb47b141e7f82c81b0815261" translate="yes" xml:space="preserve">
          <source>Binding preprocessor reference</source>
          <target state="translated">Referencia del preprocesador vinculante</target>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="translated">Sintaxis vinculante</target>
        </trans-unit>
        <trans-unit id="a9b9212b6073a73407ac32ba882e6a4bcaeeaed2" translate="yes" xml:space="preserve">
          <source>Binding values</source>
          <target state="translated">Valores vinculantes</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="89aea1a967b670a09ecb14ffdbd5170d33e77df9" translate="yes" xml:space="preserve">
          <source>Bindings can include JavaScript-style comments (//... and /*...*/). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0f9a9f1a5ef31bad0fa03e077b16e18f5a9b5" translate="yes" xml:space="preserve">
          <source>Bindings can include any amount of &lt;em&gt;whitespace&lt;/em&gt; (spaces, tab, and newlines), so you&amp;rsquo;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</source>
          <target state="translated">Los enlaces pueden incluir cualquier cantidad de &lt;em&gt;espacios&lt;/em&gt; en &lt;em&gt;blanco&lt;/em&gt; (espacios, tabulaci&amp;oacute;n y nuevas l&amp;iacute;neas), por lo que puede usarlos para organizar los enlaces como desee. Los siguientes ejemplos son todos equivalentes:</target>
        </trans-unit>
        <trans-unit id="92f78f786d943b799c2c8bf4c4f8c9a36f323743" translate="yes" xml:space="preserve">
          <source>Bindings contexts offer the following special properties that you can reference in any binding:</source>
          <target state="translated">Los contextos de encuadernación ofrecen las siguientes propiedades especiales que puede consultar en cualquier encuadernación:</target>
        </trans-unit>
        <trans-unit id="f7dfee65d89e215d7fc623cc4674a60289e7c1ce" translate="yes" xml:space="preserve">
          <source>Bindings such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.</source>
          <target state="translated">Los enlaces como &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; crean niveles adicionales en la jerarqu&amp;iacute;a del contexto de enlace. Esto significa que sus descendientes pueden acceder a datos en niveles externos usando $ parent, $ parent, $ root o $ parentContext.</target>
        </trans-unit>
        <trans-unit id="6acc9a939f24c837662878de4c3d39eeade8294a" translate="yes" xml:space="preserve">
          <source>Both result and result2 will be:</source>
          <target state="translated">Tanto el resultado como el resultado2 lo serán:</target>
        </trans-unit>
        <trans-unit id="0b375916d78848c4b0ac042003d5c4e6a2e1607f" translate="yes" xml:space="preserve">
          <source>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.</source>
          <target state="translated">Los navegadores son altamente inconsistentes en los eventos que disparan en respuesta a mecanismos inusuales de entrada de texto como cortar,arrastrar o aceptar sugerencias de autocompletar.La vinculación de valores,incluso con opciones adicionales como valorUpdate:afterkeydown para obtener actualizaciones de eventos particulares,no cubre todos los escenarios de entrada de texto en todos los navegadores.</target>
        </trans-unit>
        <trans-unit id="82dc9108de5adbfed209f29bd45aca2f7129d561" translate="yes" xml:space="preserve">
          <source>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the &lt;a href=&quot;binding-context&quot;&gt;special context property&lt;/a&gt; $data. Within a foreach block, it means &amp;ldquo;the current item&amp;rdquo;. For example,</source>
          <target state="translated">Pero, &amp;iquest;qu&amp;eacute; sucede si desea hacer referencia a la entrada de la matriz en s&amp;iacute; (no solo a una de sus propiedades)? En ese caso, puede utilizar la &lt;a href=&quot;binding-context&quot;&gt;propiedad de contexto especial&lt;/a&gt; $ data. Dentro de un bloque foreach, significa &quot;el elemento actual&quot;. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="eec18f7623a3b7b58d6302099822dbf86dd41114" translate="yes" xml:space="preserve">
          <source>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.</source>
          <target state="translated">De forma predeterminada,Knockout asume que los nombres de las etiquetas de los elementos personalizados corresponden exactamente a los nombres de los componentes registrados usando ko.components.register.Esta estrategia de convención sobre la configuración es ideal para la mayoría de las aplicaciones.</target>
        </trans-unit>
        <trans-unit id="dfd4b509346f65fb32adf29e6062d88da4847b7c" translate="yes" xml:space="preserve">
          <source>By default, Knockout comes with support for &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt;. To use it, you need to reference the following libraries, in this order:</source>
          <target state="translated">De forma predeterminada, Knockout viene con soporte para &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt; . Para usarlo, debe hacer referencia a las siguientes bibliotecas, en este orden:</target>
        </trans-unit>
        <trans-unit id="a6a1b05bbc994e6ce05943724747faea53070d14" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:</source>
          <target state="translated">De forma predeterminada,el Knockout permitirá que el evento de clic continúe burbujeando hasta cualquier manejador de eventos de nivel superior.Por ejemplo,si tu elemento y un padre de ese elemento están manejando el evento de clic,entonces se activará el manejador de clic de ambos elementos.Si es necesario,puedes evitar que el evento burbujee incluyendo un enlace adicional que se llama clickBubble y pasándole false,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="f653a59193ad26cd8f474a7f1ec0369bc69dd3cf" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:</source>
          <target state="translated">Por defecto,el Knockout permitirá que el evento continúe burbujeando a cualquier manejador de eventos de nivel superior.Por ejemplo,si tu elemento está manejando un evento de mouseover y un padre del elemento también maneja ese mismo evento,entonces se activará el manejador de eventos de ambos elementos.Si es necesario,puedes evitar que el evento burbujee incluyendo un enlace adicional que se llama youreventBubble y pasándole false,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="0213c08b2e3987a7bcfe88f7f8be8cd23b5038ae" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">De forma predeterminada, Knockout evitar&amp;aacute; que el evento de clic realice cualquier acci&amp;oacute;n predeterminada. Esto significa que si usa el enlace de clic en una etiqueta a (un enlace), por ejemplo, el navegador solo llamar&amp;aacute; a su funci&amp;oacute;n de controlador y &lt;em&gt;no&lt;/em&gt; navegar&amp;aacute; hasta el href del enlace. Este es un valor predeterminado &amp;uacute;til porque cuando usa el enlace de clic, normalmente es porque est&amp;aacute; usando el enlace como parte de una interfaz de usuario que manipula su modelo de vista, no como un hiperv&amp;iacute;nculo normal a otra p&amp;aacute;gina web.</target>
        </trans-unit>
        <trans-unit id="25eb83de5d5b73340ff952e4e80755f80b025215" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; add the value of the key to the input element&amp;rsquo;s value. A more common example is using &lt;a href=&quot;click-binding&quot;&gt;the click binding&lt;/a&gt;, which internally uses this binding, where your handler function will be called, but the browser will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">De forma predeterminada, Knockout evitar&amp;aacute; que el evento realice cualquier acci&amp;oacute;n predeterminada. Por ejemplo, si usa el enlace de eventos para capturar el evento de pulsaci&amp;oacute;n de tecla de una etiqueta de entrada, el navegador solo llamar&amp;aacute; a su funci&amp;oacute;n de controlador y &lt;em&gt;no&lt;/em&gt; agregar&amp;aacute; el valor de la clave al valor del elemento de entrada. Un ejemplo m&amp;aacute;s com&amp;uacute;n es el uso &lt;a href=&quot;click-binding&quot;&gt;del enlace de clic&lt;/a&gt; , que utiliza internamente este enlace, donde se llamar&amp;aacute; a su funci&amp;oacute;n de controlador, pero el navegador &lt;em&gt;no&lt;/em&gt; navegar&amp;aacute; al href del enlace. Este es un valor predeterminado &amp;uacute;til porque cuando usa el enlace de clic, normalmente es porque est&amp;aacute; usando el enlace como parte de una interfaz de usuario que manipula su modelo de vista, no como un hiperv&amp;iacute;nculo normal a otra p&amp;aacute;gina web.</target>
        </trans-unit>
        <trans-unit id="68e7b48de47c13e7d29cf450260662702544cfb2" translate="yes" xml:space="preserve">
          <source>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout &lt;em&gt;not&lt;/em&gt; to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</source>
          <target state="translated">De forma predeterminada, los enlaces solo afectan al elemento al que se aplican. Pero, &amp;iquest;y si tambi&amp;eacute;n quieres afectar a todos los elementos descendientes? Esto es posible. Su enlace puede decirle a Knockout que &lt;em&gt;no&lt;/em&gt; enlace descendientes en absoluto, y luego su enlace personalizado puede hacer lo que quiera para enlazarlos de una manera diferente.</target>
        </trans-unit>
        <trans-unit id="1c243a6737db34c7b0eeac830e3f8771116e5e45" translate="yes" xml:space="preserve">
          <source>By default, the DOM nodes inside &amp;lt;my-special-list&amp;gt; will be stripped out (without being bound to any viewmodel) and replaced by the component&amp;rsquo;s output. However, those DOM nodes aren&amp;rsquo;t lost: they are remembered, and are supplied to the component in two ways:</source>
          <target state="translated">Por defecto, los nodos DOM dentro de &amp;lt;my-special-list&amp;gt; ser&amp;aacute;n eliminados (sin estar vinculados a ning&amp;uacute;n modelo de vista) y reemplazados por la salida del componente. Sin embargo, esos nodos DOM no se pierden: se recuerdan y se suministran al componente de dos maneras:</target>
        </trans-unit>
        <trans-unit id="e8fbd98fd6d39033349a1b00ea69a73c915cbf4b" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will show all array entries, even those that are marked as destroyed. If you want to hide destroyed entries, set the includeDestroyed option to false. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c47fdcb3268ade367b3d412d238b7c1e97b37a3" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,</source>
          <target state="translated">Por defecto,la encuadernación frontal salteará (es decir,ocultará)cualquier entrada de la matriz que esté marcada como destruida.Si quieres mostrar las entradas destruidas,usa la opción includeDestroyed.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="8d966b6b812aaffebe3e1b225c111fc8166fe9bd" translate="yes" xml:space="preserve">
          <source>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</source>
          <target state="translated">Por defecto,la vinculación de las opciones salteará (es decir,ocultará)cualquier entrada de la matriz que esté marcada como destruida.Si desea mostrar las entradas destruidas,entonces especifique este parámetro adicional como:</target>
        </trans-unit>
        <trans-unit id="dd4b73242b19586f5ded1578826470337eec450d" translate="yes" xml:space="preserve">
          <source>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</source>
          <target state="translated">Al modificar los contextos de encuadernación y controlar las encuadernaciones descendentes,se dispone de una herramienta poderosa y avanzada para crear mecanismos de encuadernación personalizados propios.</target>
        </trans-unit>
        <trans-unit id="3ffe9da1a370013ec59a35300a7401d42fae6091" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; getConfig functions in turn, until the first one supplies a non-null componentConfig.</source>
          <target state="translated">Llama a cada una de las funciones getConfig de los cargadores registrados a su vez, hasta que el primero proporciona un componentConfig no nulo.</target>
        </trans-unit>
        <trans-unit id="ce90863a4388baecfe3dc5e7b6c6832eca44d46f" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadTemplate functions in turn, until the first one supplies a non-null DOM array.</source>
          <target state="translated">Llama a cada una de las funciones loadTemplate de los cargadores registrados a su vez, hasta que el primero proporciona una matriz DOM no nula.</target>
        </trans-unit>
        <trans-unit id="cd542f36c0ad03db70cea2aa6e54148b04219c1b" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.</source>
          <target state="translated">Llama a cada una de las funciones loadViewModel de los cargadores registrados a su vez, hasta que la primera proporciona una funci&amp;oacute;n createViewModel no nula.</target>
        </trans-unit>
        <trans-unit id="5ff3b8319fac2d8b7d9acad81d7aa35a5ad48a52" translate="yes" xml:space="preserve">
          <source>Changes to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</source>
          <target state="translated">Los cambios en los elementos o en los índices seleccionados se extenderán a través de la cadena de observables computarizados,que a su vez actualizarán cualquier elemento de interfaz de usuario vinculado a ellos.</target>
        </trans-unit>
        <trans-unit id="0c1d4b0b47058f82dd1b216d04be28f56938456f" translate="yes" xml:space="preserve">
          <source>Combining multiple changes into a single update</source>
          <target state="translated">Combinando múltiples cambios en una sola actualización</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="49288181e14cf83b9352f7e2e0537da14cdcb5e8" translate="yes" xml:space="preserve">
          <source>Communication between parent and child components</source>
          <target state="translated">La comunicación entre los componentes padre e hijo</target>
        </trans-unit>
        <trans-unit id="c97e23b3c4d2518efc7bf5b1e60ef2c00b9c85c1" translate="yes" xml:space="preserve">
          <source>Comparison with deferred updates</source>
          <target state="translated">Comparación con las actualizaciones diferidas</target>
        </trans-unit>
        <trans-unit id="fb8c2f5e94bd4d3fa6518057575ef05920fde751" translate="yes" xml:space="preserve">
          <source>Comparison with the throttle extender</source>
          <target state="translated">Comparación con el extensor del acelerador</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="4a87edfaece4a4e94d877c76e134bc7cf6471a21" translate="yes" xml:space="preserve">
          <source>Component lifecycle</source>
          <target state="translated">El ciclo de vida de los componentes</target>
        </trans-unit>
        <trans-unit id="2ffddfd282dff2b14a0ea7fa7125f3df71357ad8" translate="yes" xml:space="preserve">
          <source>Component loader utility functions</source>
          <target state="translated">Funciones de utilidad del cargador de componentes</target>
        </trans-unit>
        <trans-unit id="761842342f7602addd473021216f52faa86cae83" translate="yes" xml:space="preserve">
          <source>Component loaders</source>
          <target state="translated">Cargadores de componentes</target>
        </trans-unit>
        <trans-unit id="f452457ae4b51fa02b1e173b4b0f6a1052bd7c42" translate="yes" xml:space="preserve">
          <source>Component registration</source>
          <target state="translated">Registro de componentes</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="eed91a528f2fc4fa5bc0cc953effda03077582c3" translate="yes" xml:space="preserve">
          <source>Components and Custom Elements - Overview</source>
          <target state="translated">Componentes y elementos personalizados-Descripción general</target>
        </trans-unit>
        <trans-unit id="659136f125703fbf239b6fdcbf9807af68bdd3ca" translate="yes" xml:space="preserve">
          <source>Components usually have viewmodels, but they don&amp;rsquo;t necessarily have to. A component can specify just a template.</source>
          <target state="translated">Los componentes suelen tener modelos de vista, pero no necesariamente tienen que hacerlo. Un componente puede especificar solo una plantilla.</target>
        </trans-unit>
        <trans-unit id="02608739ad96779f6714a96facc9a51c046de4d6" translate="yes" xml:space="preserve">
          <source>Computed Observable Reference</source>
          <target state="translated">Referencia observable calculada</target>
        </trans-unit>
        <trans-unit id="cac67370227943652edb1bf32470cb7ededf3cd3" translate="yes" xml:space="preserve">
          <source>Computed Observables</source>
          <target state="translated">Observables computarizados</target>
        </trans-unit>
        <trans-unit id="d98b156baebd0cc88075e455bd6e7b1bb0e76a4b" translate="yes" xml:space="preserve">
          <source>Computed observable reference</source>
          <target state="translated">Referencia observable calculada</target>
        </trans-unit>
        <trans-unit id="d2ec0435fbe18656377dae8b79915d57ab98a0b9" translate="yes" xml:space="preserve">
          <source>Computed observables</source>
          <target state="translated">Observables calculados</target>
        </trans-unit>
        <trans-unit id="5be6efbe0cdf63c1654669d988fd6948bafd8cb6" translate="yes" xml:space="preserve">
          <source>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&amp;rsquo;t make sense to include cycles in your dependency chains. Cycles would &lt;em&gt;not&lt;/em&gt; be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</source>
          <target state="translated">Se supone que los observables computados mapean un conjunto de entradas observables en una &amp;uacute;nica salida observable. Como tal, no tiene sentido incluir ciclos en sus cadenas de dependencia. Los ciclos &lt;em&gt;no&lt;/em&gt; ser&amp;iacute;an an&amp;aacute;logos a la recursividad; Ser&amp;iacute;an an&amp;aacute;logos a tener dos celdas de hoja de c&amp;aacute;lculo que se calculan como funciones entre s&amp;iacute;. Conducir&amp;iacute;a a un ciclo de evaluaci&amp;oacute;n infinito.</target>
        </trans-unit>
        <trans-unit id="2947b370ef1780b5ce5f7b757f8fbc6949d5aa95" translate="yes" xml:space="preserve">
          <source>Consider a special list component that can be invoked as follows:</source>
          <target state="translated">Considere un componente de lista especial que puede ser invocado de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cdc5c7e600b4462cb7a47184c49b5743744e2362" translate="yes" xml:space="preserve">
          <source>Consider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:</source>
          <target state="translated">Consideremos el siguiente caso inusual,en el que el uso deObservable1,observable1 y observable2 son todos observables:</target>
        </trans-unit>
        <trans-unit id="2013a8ac11dfd30a4371b3a3b80a3e57ac8e78e1" translate="yes" xml:space="preserve">
          <source>Consider the observables in the following code:</source>
          <target state="translated">Considere los observables en el siguiente código:</target>
        </trans-unit>
        <trans-unit id="1117c8b3e83be86f1626d72435beb4550b6b1224" translate="yes" xml:space="preserve">
          <source>Constructing a computed observable</source>
          <target state="translated">Construir un observable computarizado</target>
        </trans-unit>
        <trans-unit id="4221e67369d1a203bdb0ecf119eb9ef7949b278f" translate="yes" xml:space="preserve">
          <source>Consults each registered loader in turn (by default, that&amp;rsquo;s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.</source>
          <target state="translated">Consulta cada cargador registrado por turno (de forma predeterminada, es solo el cargador predeterminado), para encontrar el primero que proporciona una definici&amp;oacute;n de modelo de vista / plantilla para el componente nombrado, luego invoca la devoluci&amp;oacute;n de llamada para devolver la declaraci&amp;oacute;n de modelo de vista / plantilla. Invoca la devoluci&amp;oacute;n de llamada (nula) si ninguno de los cargadores registrados conoce este componente.</target>
        </trans-unit>
        <trans-unit id="edea616075e1b992e2a1f7d2acc1cdd1bdf21fbc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</source>
          <target state="translated">Siguiendo con el ejemplo anterior,puede que quieras que slideVisible establezca que el elemento sea visible o invisible de forma instantánea cuando la página aparezca por primera vez (sin ninguna diapositiva animada),de modo que la animación sólo se ejecute cuando el usuario cambie el estado del modelo.Podrías hacerlo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ce832f145332955eb3265a8ede075cf6b1348107" translate="yes" xml:space="preserve">
          <source>Controlling custom element tag names</source>
          <target state="translated">Controlar los nombres de las etiquetas de los elementos personalizados</target>
        </trans-unit>
        <trans-unit id="b8f133feb465932694ab2a98e1eb7747d66f64e3" translate="yes" xml:space="preserve">
          <source>Controlling dependencies using peek</source>
          <target state="translated">Control de las dependencias mediante el uso de peek</target>
        </trans-unit>
        <trans-unit id="dc6504831105dad1f130ff746a8aac74129f3308" translate="yes" xml:space="preserve">
          <source>Controlling or modifying the binding context in custom bindings</source>
          <target state="translated">Controlar o modificar el contexto de la vinculación en las vinculaciones personalizadas</target>
        </trans-unit>
        <trans-unit id="7001c43b6b88f7e449641661e4b5f14d9fd1e3c4" translate="yes" xml:space="preserve">
          <source>Controlling precedence</source>
          <target state="translated">Control de la precedencia</target>
        </trans-unit>
        <trans-unit id="5a2bc032092b4e94355ac6de4992fb4188dcfb12" translate="yes" xml:space="preserve">
          <source>Controlling synchronous/asynchronous loading</source>
          <target state="translated">Control de la carga síncrona/asíncrona</target>
        </trans-unit>
        <trans-unit id="1c7def4489979402bef239f8ce6c91bfba309a07" translate="yes" xml:space="preserve">
          <source>Converting View Model Data to Plain JSON</source>
          <target state="translated">Convertir los datos del modelo de vista en el JSON plano</target>
        </trans-unit>
        <trans-unit id="6db93df4caeca527834703cd00425530177a63ba" translate="yes" xml:space="preserve">
          <source>Copying certain properties using &amp;ldquo;copy&amp;rdquo;</source>
          <target state="translated">Copiar ciertas propiedades usando &quot;copiar&quot;</target>
        </trans-unit>
        <trans-unit id="2203e5a230379d565a0c899ed4adc6b93e7f6dea" translate="yes" xml:space="preserve">
          <source>Creating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</source>
          <target state="translated">La creación de un extensor implica añadir una función al objeto ko.extenders.La función toma el observable en sí como primer argumento y las opciones en el segundo argumento.Puede entonces devolver el observable o devolver algo nuevo como un observable calculado que utiliza el observable original de alguna manera.</target>
        </trans-unit>
        <trans-unit id="4039add3326a9c3c1c76f899ffeb9a382a6a0bbb" translate="yes" xml:space="preserve">
          <source>Creating custom bindings</source>
          <target state="translated">Creación de ataduras personalizadas</target>
        </trans-unit>
        <trans-unit id="ffb9756189a28d9adfb06e166fd3288595e0d920" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that control descendant bindings</source>
          <target state="translated">Creando ataduras personalizadas que controlan las ataduras de los descendientes</target>
        </trans-unit>
        <trans-unit id="f643fe053a4c78aac0aa1cb4ee160c7166f2853b" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that support virtual elements</source>
          <target state="translated">Creación de encuadernaciones personalizadas que soportan elementos virtuales</target>
        </trans-unit>
        <trans-unit id="bb539e2cde83f162d3671d028d8f300a026106c8" translate="yes" xml:space="preserve">
          <source>Custom bindings</source>
          <target state="translated">Encuadernaciones personalizadas</target>
        </trans-unit>
        <trans-unit id="33671f984027a68370db04ee2850cad72a30b9b1" translate="yes" xml:space="preserve">
          <source>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.</source>
          <target state="translated">Las encuadernaciones personalizadas también pueden funcionar con elementos virtuales,pero para habilitarlas,debes decirle explícitamente a Knockout que tu encuadernación comprende los elementos virtuales,utilizando la API ko.virtualElements.allowedBindings.</target>
        </trans-unit>
        <trans-unit id="b02f7ac0bddff91f51122a7841af16420a2282a7" translate="yes" xml:space="preserve">
          <source>Custom disposal logic</source>
          <target state="translated">Lógica de eliminación personalizada</target>
        </trans-unit>
        <trans-unit id="6789075eb722c50f4da3df82b6df6ba9f8fa1b61" translate="yes" xml:space="preserve">
          <source>Custom elements</source>
          <target state="translated">Elementos personalizados</target>
        </trans-unit>
        <trans-unit id="3ac9f87f42e53076f0f3bc01bdfc33cd3a3330a1" translate="yes" xml:space="preserve">
          <source>Custom elements are a syntactical alternative to the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; (and in fact, custom elements make use of a component binding behind the scenes).</source>
          <target state="translated">Los elementos personalizados son una alternativa sint&amp;aacute;ctica al &lt;a href=&quot;component-binding&quot;&gt;enlace de componentes&lt;/a&gt; (y de hecho, los elementos personalizados utilizan un enlace de componentes detr&amp;aacute;s de escena).</target>
        </trans-unit>
        <trans-unit id="8bdeeedc365799bc2628a672569777dea3cd4f5b" translate="yes" xml:space="preserve">
          <source>Custom elements provide a convenient way of injecting &lt;a href=&quot;component-overview&quot;&gt;components&lt;/a&gt; into your views.</source>
          <target state="translated">Los elementos personalizados proporcionan una manera conveniente de inyectar &lt;a href=&quot;component-overview&quot;&gt;componentes&lt;/a&gt; en sus vistas.</target>
        </trans-unit>
        <trans-unit id="253deb0b4c3f25b5d0a8ab69ab15a0a5e8a1bbf9" translate="yes" xml:space="preserve">
          <source>Custom functions</source>
          <target state="translated">Funciones personalizadas</target>
        </trans-unit>
        <trans-unit id="20edd160b708193b8cd0d39f58c10bc666a47f89" translate="yes" xml:space="preserve">
          <source>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.</source>
          <target state="translated">Los cargadores personalizados pueden conectarse a cualquier parte de este proceso,de modo que usted puede tomar el control sobre las configuraciones de suministro,la interpretación de las configuraciones,el suministro de los nodos DOM,o el suministro de las funciones de fábrica de modelos de visualización.Al poner los cargadores personalizados en un orden elegido dentro de ko.components.loaders,puede controlar el orden de prioridad de las diferentes estrategias de carga.</target>
        </trans-unit>
        <trans-unit id="a613a57094a36803b28114f2b5a1abcb9176c942" translate="yes" xml:space="preserve">
          <source>Custom rate-limit methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cea07f3d8dcbe1745bc7ec0339edf9dd8a1c9" translate="yes" xml:space="preserve">
          <source>Customizing object construction using &amp;ldquo;create&amp;rdquo;</source>
          <target state="translated">Personalizar la construcci&amp;oacute;n de objetos usando &quot;crear&quot;</target>
        </trans-unit>
        <trans-unit id="c50ee97e0e3e0b6e26cae536ab969b9b4086cfdd" translate="yes" xml:space="preserve">
          <source>Customizing object updating using &amp;ldquo;update&amp;rdquo;</source>
          <target state="translated">Personalizar la actualizaci&amp;oacute;n de objetos usando &quot;actualizar&quot;</target>
        </trans-unit>
        <trans-unit id="a2e01b2c84eeb85c92c0c227a329d46faf0286ed" translate="yes" xml:space="preserve">
          <source>Declarative bindings</source>
          <target state="translated">Vinculaciones declarativas</target>
        </trans-unit>
        <trans-unit id="602e3ca9311ed01ea1f90901d68acf0154edb840" translate="yes" xml:space="preserve">
          <source>Deferred updates</source>
          <target state="translated">Actualizaciones diferidas</target>
        </trans-unit>
        <trans-unit id="d33bdc7c7c750f5687e4acfbfe0dbcbd94980b54" translate="yes" xml:space="preserve">
          <source>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</source>
          <target state="translated">Las actualizaciones diferidas se desactivan por defecto para proporcionar compatibilidad con las aplicaciones existentes.Para utilizar las actualizaciones diferidas para su aplicación,debe habilitarla antes de inicializar sus modelos de visualización configurando la siguiente opción:</target>
        </trans-unit>
        <trans-unit id="222e63650134f06185ff4eba850a6bbc59f05df7" translate="yes" xml:space="preserve">
          <source>Defining and registering components</source>
          <target state="translated">Definición y registro de componentes</target>
        </trans-unit>
        <trans-unit id="82561171b4e8eed7831575a3bd0fd837f8a82416" translate="yes" xml:space="preserve">
          <source>Delaying and/or suppressing change notifications</source>
          <target state="translated">Retrasar y/o suprimir las notificaciones de cambio</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a811f27fa09ba74dbb3e42867afbb878bcbad3e6" translate="yes" xml:space="preserve">
          <source>Dependency chains just work</source>
          <target state="translated">Las cadenas de dependencia sólo funcionan</target>
        </trans-unit>
        <trans-unit id="7c363ed6db02f3ea32be85600b21f30d4c97ea44" translate="yes" xml:space="preserve">
          <source>Descendant bindings</source>
          <target state="translated">Las fijaciones de los descendientes</target>
        </trans-unit>
        <trans-unit id="59380b44a10043c9034706c8bb58c001df92a319" translate="yes" xml:space="preserve">
          <source>Determining if a property is a computed observable</source>
          <target state="translated">Determinar si una propiedad es un observable computarizado</target>
        </trans-unit>
        <trans-unit id="7d7568009623a301a6c07b4b81d08e0e95375454" translate="yes" xml:space="preserve">
          <source>Determining if a property is a pure computed observable</source>
          <target state="translated">Determinar si una propiedad es un observable puro computarizado</target>
        </trans-unit>
        <trans-unit id="f8ade81c4c64f53543f1c485af47d756a3b07816" translate="yes" xml:space="preserve">
          <source>Determining if a property is an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177b5ed57d02388907afbbf9df075dc986c6b4a" translate="yes" xml:space="preserve">
          <source>Determining the observable type</source>
          <target state="translated">Determinar el tipo de observación</target>
        </trans-unit>
        <trans-unit id="2ff2f116ddb0dad37555150f401b3a0c8dbb95b1" translate="yes" xml:space="preserve">
          <source>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data&amp;hellip; whatever works for you :)</source>
          <target state="translated">Los desarrolladores familiarizados con Ruby on Rails, ASP.NET MVC u otras tecnolog&amp;iacute;as MV * pueden ver MVVM como una forma en tiempo real de MVC con sintaxis declarativa. En otro sentido, puede pensar en KO como una forma general de crear interfaces de usuario para editar datos JSON ... lo que sea que funcione para usted :)</target>
        </trans-unit>
        <trans-unit id="853ee1f12570f18e3388b47c2a0f03eb555b5bbd" translate="yes" xml:space="preserve">
          <source>Disposal and memory management</source>
          <target state="translated">Eliminación y gestión de la memoria</target>
        </trans-unit>
        <trans-unit id="1b44b6295dded1bbfd5d400fc72e1bf24012f125" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;custom-bindings&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="translated">La documentaci&amp;oacute;n sobre Binding Handlers en general se puede encontrar &lt;a href=&quot;custom-bindings&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Esta secci&amp;oacute;n est&amp;aacute; destinada a demostrar el poder que brindan los m&amp;oacute;dulos AMD para mantener sus controladores personalizados. Tomaremos el ejemplo del ejemplo ko.bindingHandlers.hasFocus de la documentaci&amp;oacute;n de los controladores de enlace. Al incluir ese controlador en su propio m&amp;oacute;dulo, puede restringir su uso solo a las p&amp;aacute;ginas que lo necesitan. El m&amp;oacute;dulo envuelto se convierte en:</target>
        </trans-unit>
        <trans-unit id="63aac2ff7f975838de0c8c949cea93205b344a59" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;http://knockoutjs.com/documentation/custom-bindings.html&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e71968601f25cc8d728fb672b3c6eef4f524e2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t return non-string values. That wouldn&amp;rsquo;t make sense, because markup is always a string.</source>
          <target state="translated">No devuelva valores que no sean cadenas. Eso no tendr&amp;iacute;a sentido, porque el marcado es siempre una cadena.</target>
        </trans-unit>
        <trans-unit id="3c7559a433a9d713a940341db539ff9c4b28ea8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to use the value and textInput bindings together on the same element, as that won&amp;rsquo;t achieve anything useful.</source>
          <target state="translated">No intente usar los enlaces value y textInput juntos en el mismo elemento, ya que eso no lograr&amp;aacute; nada &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="6f44f2279c8cf4e05783eedaa0f0f9909bcb3b91" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {font-weight:someValue}; do write {fontWeight:someValue}</source>
          <target state="translated">No escriba {font-weight: someValue}; escribe {fontWeight: someValue}</target>
        </trans-unit>
        <trans-unit id="6be7c5667ed6550d41ae6c0658c6f47b62d579f4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {text-decoration:someValue}; do write {textDecoration:someValue}</source>
          <target state="translated">No escriba {text-decoration: someValue}; escribe {textDecoration: someValue}</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="f9ae8a63307356d3207b70880fd5b3983d9bf72f" translate="yes" xml:space="preserve">
          <source>Drilling down into arrays/objects works but copy and observe can conflict:</source>
          <target state="translated">Perforar en matrices/objetos funciona pero copiar y observar puede entrar en conflicto:</target>
        </trans-unit>
        <trans-unit id="b14f1acd92dd2af3e3a0d2d48a5aca685f3a348f" translate="yes" xml:space="preserve">
          <source>During the execution of a computed observable&amp;rsquo;s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</source>
          <target state="translated">Durante la ejecuci&amp;oacute;n de la funci&amp;oacute;n evaluadora de un observable calculado, puede acceder a ko.computedContext para obtener informaci&amp;oacute;n sobre la propiedad calculada actual. Proporciona las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="cb51b2c1c5469acfdd11fbdd71a5689e012cc63b" translate="yes" xml:space="preserve">
          <source>Each time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.</source>
          <target state="translated">Cada vez que haga clic en el botón,esto invocará a incrementClickCounter()en el modelo de vista,lo que a su vez cambia el estado del modelo de vista,lo que hace que la interfaz de usuario se actualice.</target>
        </trans-unit>
        <trans-unit id="0cec7a4fc80a79a8517827ff50614001f95e25f2" translate="yes" xml:space="preserve">
          <source>Either { 'font-weight': someValue } or { fontWeight: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea802701347963a7c6d7d1af9b4192766647022" translate="yes" xml:space="preserve">
          <source>Either { 'text-decoration': someValue } or { textDecoration: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9b2101da6336d889f8e0edd362bebf4c734ee" translate="yes" xml:space="preserve">
          <source>Enabling deferred updates</source>
          <target state="translated">Habilitación de actualizaciones diferidas</target>
        </trans-unit>
        <trans-unit id="15ae64a2d0e5091397c73f3a4af82d2c60920a8a" translate="yes" xml:space="preserve">
          <source>Ensure you call ko.components.register('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements</source>
          <target state="translated">Aseg&amp;uacute;rese de llamar a ko.components.register ('su-componente') &lt;em&gt;antes de que&lt;/em&gt; el analizador HTML vea cualquier elemento &amp;lt;your-component&amp;gt;</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">Manejo de errores...</target>
        </trans-unit>
        <trans-unit id="1dad2cf157eb99bbacb6f803399efe19332b4be1" translate="yes" xml:space="preserve">
          <source>Evaluating the computed observable should not cause any side effects.</source>
          <target state="translated">La evaluación del observable computarizado no debería causar ningún efecto secundario.</target>
        </trans-unit>
        <trans-unit id="bb63aeafbc8fa85c1955b6434579c431172024e1" translate="yes" xml:space="preserve">
          <source>Evaluation of a rate-limited computed observable isn&amp;rsquo;t rate-limited; it will re-evaluate if you read its value.</source>
          <target state="translated">La evaluaci&amp;oacute;n de un observable calculado de tasa limitada no est&amp;aacute; limitada a la tasa; volver&amp;aacute; a evaluar si lee su valor.</target>
        </trans-unit>
        <trans-unit id="9a4dd6b0c34a91a968005c6fdb0958613d790b68" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:</source>
          <target state="translated">Incluso si no habilita las actualizaciones diferidas para toda su aplicaci&amp;oacute;n, a&amp;uacute;n puede beneficiarse de esta funci&amp;oacute;n si difiere espec&amp;iacute;ficamente ciertos observables. Esto se hace usando el extensor diferido:</target>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">Manejo de eventos</target>
        </trans-unit>
        <trans-unit id="ecaca2e0dae16fbf4a4ad04e56b1d2b31b12e57f" translate="yes" xml:space="preserve">
          <source>Everyone loves jQuery! It&amp;rsquo;s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</source>
          <target state="translated">&amp;iexcl;Todo el mundo ama jQuery! Es un reemplazo excepcional para la API DOM torpe e inconsistente que tuvimos que soportar en el pasado. jQuery es una excelente forma de bajo nivel para manipular elementos y controladores de eventos en una p&amp;aacute;gina web. KO resuelve un problema diferente.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">Ejemplo 1</target>
        </trans-unit>
        <trans-unit id="77ef6015f49d42a91349a37284f0d10ce58dfca6" translate="yes" xml:space="preserve">
          <source>Example 1 showed how a writable computed observable can effectively &lt;em&gt;filter&lt;/em&gt; its incoming data by choosing not to write certain values back to the underlying observables if they don&amp;rsquo;t meet some criteria. It ignored full name values that didn&amp;rsquo;t include a space.</source>
          <target state="translated">El ejemplo 1 mostr&amp;oacute; c&amp;oacute;mo un observable calculado escribible puede &lt;em&gt;filtrar&lt;/em&gt; efectivamente sus datos entrantes eligiendo no escribir ciertos valores en los observables subyacentes si no cumplen con algunos criterios. Ignor&amp;oacute; los valores de nombre completo que no inclu&amp;iacute;an un espacio.</target>
        </trans-unit>
        <trans-unit id="4c47207b8b7ae8ab2d635eb01fc483f744594a47" translate="yes" xml:space="preserve">
          <source>Example 1: A component loader that sets up naming conventions</source>
          <target state="translated">Ejemplo 1:Un cargador de componentes que establece convenciones de nomenclatura</target>
        </trans-unit>
        <trans-unit id="25518d7fb94487e753554d645c6334d7a18971ef" translate="yes" xml:space="preserve">
          <source>Example 1: Decomposing user input</source>
          <target state="translated">Ejemplo 1:Entrada de usuario en descomposición</target>
        </trans-unit>
        <trans-unit id="4ea51a4ffde5737f46b31ecbe0d2ce38e03e5c87" translate="yes" xml:space="preserve">
          <source>Example 1: Drop-down list</source>
          <target state="translated">Ejemplo 1:Lista desplegable</target>
        </trans-unit>
        <trans-unit id="0d4cfa89e17777c37aa14362706fd9828f313abe" translate="yes" xml:space="preserve">
          <source>Example 1: Iterating over an array</source>
          <target state="translated">Ejemplo 1:Iteración sobre una matriz</target>
        </trans-unit>
        <trans-unit id="cde8db0303a6ef26ab001c13fc6ef4c4a5867277" translate="yes" xml:space="preserve">
          <source>Example 1: Setting a default value for a binding</source>
          <target state="translated">Ejemplo 1:Establecer un valor por defecto para una encuadernación</target>
        </trans-unit>
        <trans-unit id="0b080011a40c4eb15898518a2e3a11c9a40dc6a7" translate="yes" xml:space="preserve">
          <source>Example 1: The basics</source>
          <target state="translated">Ejemplo 1:Lo básico</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">Ejemplo 2</target>
        </trans-unit>
        <trans-unit id="de3d10fd223ba2f62435c7e02579b9cdc45e4ca2" translate="yes" xml:space="preserve">
          <source>Example 2: A component loader that loads external files using custom code</source>
          <target state="translated">Ejemplo 2:Un cargador de componentes que carga archivos externos utilizando un código personalizado</target>
        </trans-unit>
        <trans-unit id="152baefa2649a3e481777e4febefb3f62efbbff0" translate="yes" xml:space="preserve">
          <source>Example 2: Binding expressions to events</source>
          <target state="translated">Ejemplo 2:Vincular las expresiones a los acontecimientos</target>
        </trans-unit>
        <trans-unit id="d9d8b537de776eff6af7ceab0dd013a34c60123d" translate="yes" xml:space="preserve">
          <source>Example 2: Click-to-edit</source>
          <target state="translated">Ejemplo 2:Click-to-editar</target>
        </trans-unit>
        <trans-unit id="d220784caedb8582e4b56dcacda886e7debebcbd" translate="yes" xml:space="preserve">
          <source>Example 2: Doing something when the user stops typing</source>
          <target state="translated">Ejemplo 2:Hacer algo cuando el usuario deja de escribir</target>
        </trans-unit>
        <trans-unit id="68cfd4d2225424d953c697fb7607585a091cb604" translate="yes" xml:space="preserve">
          <source>Example 2: Live example with add/remove</source>
          <target state="translated">Ejemplo 2:Ejemplo en vivo con agregar/quitar</target>
        </trans-unit>
        <trans-unit id="cc3711f3c0d99468999474edf36f69743a26180f" translate="yes" xml:space="preserve">
          <source>Example 2: Multi-select list</source>
          <target state="translated">Ejemplo 2:Lista de selección múltiple</target>
        </trans-unit>
        <trans-unit id="46b269bb32dd9e2791dd2abef3477feb53abf1d7" translate="yes" xml:space="preserve">
          <source>Example 2: Selecting/deselecting all items</source>
          <target state="translated">Ejemplo 2:Seleccionar/deseleccionar todos los elementos</target>
        </trans-unit>
        <trans-unit id="50e87750a3521296001652d5e8e5eb52d3e10882" translate="yes" xml:space="preserve">
          <source>Example 3: A value converter</source>
          <target state="translated">Ejemplo 3:Un convertidor de valores</target>
        </trans-unit>
        <trans-unit id="1ae049f41b4bef03f225ee3aa4c5f8f8e6b59956" translate="yes" xml:space="preserve">
          <source>Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</source>
          <target state="translated">Ejemplo 3:Lista desplegable que representa objetos arbitrarios de JavaScript,no sólo cadenas</target>
        </trans-unit>
        <trans-unit id="65ad7a42106a9c349f796f4927c5d9dd3e154f38" translate="yes" xml:space="preserve">
          <source>Example 3: Virtual template elements</source>
          <target state="translated">Ejemplo 3:Elementos de la plantilla virtual</target>
        </trans-unit>
        <trans-unit id="2c6ee2315f1fbb9f42c5ff7683886da7013cc130" translate="yes" xml:space="preserve">
          <source>Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</source>
          <target state="translated">Ejemplo 4:Lista desplegable que representa objetos arbitrarios de JavaScript,con el texto mostrado calculado en función del elemento representado</target>
        </trans-unit>
        <trans-unit id="113b6fb251c660444fac91367247b19ef5ceb219" translate="yes" xml:space="preserve">
          <source>Example 4: Filtering and validating user input</source>
          <target state="translated">Ejemplo 4:Filtrar y validar las entradas del usuario</target>
        </trans-unit>
        <trans-unit id="b5a7dec77db39f767aebc5bdc16bef64364a4359" translate="yes" xml:space="preserve">
          <source>Example adding checkboxes bound to an array</source>
          <target state="translated">Ejemplo añadiendo casillas de verificación unidas a una matriz</target>
        </trans-unit>
        <trans-unit id="50416933cd6d1c51d0982199bf3a9959f145560c" translate="yes" xml:space="preserve">
          <source>Example adding radio buttons</source>
          <target state="translated">Ejemplo añadiendo botones de radio</target>
        </trans-unit>
        <trans-unit id="0c0fb6e0f3233e0276bdc610ce75b2efce4645ad" translate="yes" xml:space="preserve">
          <source>Example with checkbox</source>
          <target state="translated">Ejemplo con casilla de verificación</target>
        </trans-unit>
        <trans-unit id="3d8ebdde40a810f8bcecb22744e7b919dc5edb75" translate="yes" xml:space="preserve">
          <source>Example with dynamic classes</source>
          <target state="translated">Ejemplo con clases dinámicas</target>
        </trans-unit>
        <trans-unit id="6433628dbf98786e98c232e686cdd5f6a5f19fc7" translate="yes" xml:space="preserve">
          <source>Example with static classes</source>
          <target state="translated">Ejemplo con clases estáticas</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="32d559acc95c5e2026c88355b2fc6dbb56610729" translate="yes" xml:space="preserve">
          <source>Example: A filtered view of an observable array</source>
          <target state="translated">Ejemplo:Una vista filtrada de un conjunto observable</target>
        </trans-unit>
        <trans-unit id="48ca56b48fa467d7cffa5a1ad762033d25d9baf5" translate="yes" xml:space="preserve">
          <source>Example: A like/dislike widget</source>
          <target state="translated">Ejemplo:Un widget de &quot;me gusta&quot; o &quot;no me gusta&quot;.</target>
        </trans-unit>
        <trans-unit id="550a2ef513bd2e9716cf255edf159d7eac98e6ab" translate="yes" xml:space="preserve">
          <source>Example: Adding extra levels in the binding context hierarchy</source>
          <target state="translated">Ejemplo:Adición de niveles adicionales en la jerarquía de contexto vinculante</target>
        </trans-unit>
        <trans-unit id="530246441e8d386c7708bd3e341f39543a901741" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple Ajax requests</source>
          <target state="translated">Ejemplo:Evitar múltiples solicitudes de Ajax</target>
        </trans-unit>
        <trans-unit id="ed1408f9ac2794bd9571def8f7b6df4057a59a28" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple UI updates</source>
          <target state="translated">Ejemplo:Evitar múltiples actualizaciones de la interfaz de usuario</target>
        </trans-unit>
        <trans-unit id="c2642b17305d614b451304cd70c56ebaa48362c4" translate="yes" xml:space="preserve">
          <source>Example: Controlling whether or not descendant bindings are applied</source>
          <target state="translated">Ejemplo:Controlar si se aplican o no las vinculaciones de los descendientes</target>
        </trans-unit>
        <trans-unit id="5c3289a0b0b51a0be2ba51f5bf9c959f825caa0c" translate="yes" xml:space="preserve">
          <source>Example: Loading the like/dislike widget from external files, on demand</source>
          <target state="translated">Ejemplo:Cargar el widget &quot;Me gusta/No me gusta&quot; desde archivos externos,a petición.</target>
        </trans-unit>
        <trans-unit id="6597b4b37cee763a15316f6ba15516f4f3baf020" translate="yes" xml:space="preserve">
          <source>Example: Manual mapping without the ko.mapping plugin</source>
          <target state="translated">Ejemplo:Mapeo manual sin el plugin ko.mapping</target>
        </trans-unit>
        <trans-unit id="c298c6fe3398c7d0b1e666fec016b7d667c91616" translate="yes" xml:space="preserve">
          <source>Example: Supplying additional values to descendant bindings</source>
          <target state="translated">Ejemplo:Suministrar valores adicionales a los enlaces descendientes</target>
        </trans-unit>
        <trans-unit id="30054173d63a971c583a297024b8430fbad005a6" translate="yes" xml:space="preserve">
          <source>Example: Using ko.mapping</source>
          <target state="translated">Ejemplo:Usando ko.mapping</target>
        </trans-unit>
        <trans-unit id="5b10251ba9ffb2c86c7da769237457e995ac6fa9" translate="yes" xml:space="preserve">
          <source>Excerpt From &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;Writing Modular JavaScript With AMD, CommonJs &amp;amp; ES Harmony&lt;/a&gt;:</source>
          <target state="translated">Extracto de la &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;escritura de JavaScript modular con AMD, CommonJs y ES Harmony&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5bdedba4c5ce2948fd4206f7e11d5e6799420d42" translate="yes" xml:space="preserve">
          <source>Explicitly subscribing to observables</source>
          <target state="translated">Suscripción explícita a los observables</target>
        </trans-unit>
        <trans-unit id="1208c99ef5025c09bf368869c5593ca302f58dd8" translate="yes" xml:space="preserve">
          <source>Extending Knockout's binding syntax using preprocessing</source>
          <target state="translated">Extendiendo la sintaxis de unión del Knockout usando preprocesamiento</target>
        </trans-unit>
        <trans-unit id="477b9ac7b2012a7c4ef01dab5b6738e39bfd0290" translate="yes" xml:space="preserve">
          <source>Extending observables</source>
          <target state="translated">Extendiendo los observables</target>
        </trans-unit>
        <trans-unit id="6d075b19378326b1dd5562c4110427dc1221e6d9" translate="yes" xml:space="preserve">
          <source>Extracting additional data or state from the form elements</source>
          <target state="translated">Extracción de datos o estados adicionales de los elementos de la forma</target>
        </trans-unit>
        <trans-unit id="aa46347e225c51cf57a22ad6da0baa8c26e37d15" translate="yes" xml:space="preserve">
          <source>Finally, to update your view model using this data (without using the mapping plugin), you would write:</source>
          <target state="translated">Finalmente,para actualizar su modelo de vista usando estos datos (sin usar el plugin de mapeo),usted escribiría:</target>
        </trans-unit>
        <trans-unit id="95a70ce88e1373d7443eeddd31cb4fdbb0259963" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false.</source>
          <target state="translated">Para las &lt;strong&gt;casillas de verificaci&amp;oacute;n&lt;/strong&gt; , KO establecer&amp;aacute; el elemento para que se &lt;em&gt;verifique&lt;/em&gt; cuando el valor del par&amp;aacute;metro sea verdadero y lo &lt;em&gt;desmarque&lt;/em&gt; cuando sea falso. Si da un valor que en realidad no es booleano, se interpretar&amp;aacute; de forma flexible. Esto significa que los n&amp;uacute;meros distintos de cero y los objetos no nulos y las cadenas no vac&amp;iacute;as se interpretar&amp;aacute;n como verdaderas, mientras que las cadenas cero, nulas, indefinidas y vac&amp;iacute;as se interpretar&amp;aacute;n como falsas.</target>
        </trans-unit>
        <trans-unit id="1972d38c80951a9e678c4ff687d7462b49456982" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false. When the user checks or unchecks the checkbox, Knockout will set your model property to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d41ab8ba0a18cc5a9b626ab01db87a9b2b8cd" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if and only if the parameter value equals the radio button node&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="translated">Para &lt;strong&gt;los botones de radio&lt;/strong&gt; , KO establecer&amp;aacute; el elemento para que se &lt;em&gt;verifique&lt;/em&gt; si y solo si el valor del par&amp;aacute;metro es igual al atributo de valor del nodo del bot&amp;oacute;n de radio o al valor especificado por el par&amp;aacute;metro checkValue. En el ejemplo anterior, el bot&amp;oacute;n de opci&amp;oacute;n con value = &quot;almond&quot; se verific&amp;oacute; solo cuando la propiedad spamFlavor del modelo de vista era igual a &quot;almond&quot;.</target>
        </trans-unit>
        <trans-unit id="cc3c89585ed643a35bcd1fe16e2cc01737ccbce0" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value equals the radio button element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85206a98cfdd4a13c8db149c728546b8ffb8cf" translate="yes" xml:space="preserve">
          <source>For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.</source>
          <target state="translated">Para que Knockout pueda cargar e instanciar sus componentes,debe registrarlos usando ko.components.register,proporcionando una configuración como se describe aquí.</target>
        </trans-unit>
        <trans-unit id="fb653bd6fda509ae69de2f3c411ab3f9ecc16aff" translate="yes" xml:space="preserve">
          <source>For a computed observable, the rate-limit timer is triggered when one of the computed observable&amp;rsquo;s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed&amp;mdash;after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed&amp;rsquo;s most recent evaluation, you can do so with the peek method.</source>
          <target state="translated">Para un observable calculado, el temporizador de l&amp;iacute;mite de velocidad se activa cuando una de las dependencias del observable calculado cambia en lugar de cuando cambia su valor. El observable calculado no se vuelve a evaluar hasta que su valor sea realmente necesario, despu&amp;eacute;s del per&amp;iacute;odo de tiempo de espera cuando deber&amp;iacute;a ocurrir la notificaci&amp;oacute;n de cambio, o cuando se accede directamente al valor observable calculado. Si necesita acceder al valor de la evaluaci&amp;oacute;n m&amp;aacute;s reciente calculada, puede hacerlo con el m&amp;eacute;todo peek.</target>
        </trans-unit>
        <trans-unit id="f6a669cb32d714a0fa05339382fe1c38249fefbd" translate="yes" xml:space="preserve">
          <source>For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has &lt;a href=&quot;selectedoptions-binding&quot;&gt;its own documentation&lt;/a&gt;.</source>
          <target state="translated">Para una lista de selecci&amp;oacute;n m&amp;uacute;ltiple, puede leer y escribir el estado de selecci&amp;oacute;n usando selectedOptions. T&amp;eacute;cnicamente, se trata de un enlace independiente, por lo que tiene &lt;a href=&quot;selectedoptions-binding&quot;&gt;su propia documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd598195e6041713fa3eb6fa2ec0c343db66800" translate="yes" xml:space="preserve">
          <source>For a very simple example, here&amp;rsquo;s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won&amp;rsquo;t be bound as usual.</source>
          <target state="translated">Para un ejemplo muy simple, aqu&amp;iacute; hay un enlace personalizado llamado allowBindings que permite que los enlaces descendientes se apliquen solo si su valor es verdadero. Si el valor es falso, allowBindings le dice a Knockout que es responsable de los enlaces descendientes para que no se enlacen como de costumbre.</target>
        </trans-unit>
        <trans-unit id="f738301a087259c2cb88d3ee079875129c0660ae" translate="yes" xml:space="preserve">
          <source>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</source>
          <target state="translated">Para los usuarios avanzados,si desean registrar sus propias suscripciones para que se les notifiquen los cambios en los observables,pueden llamar a su función de suscripción.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0f758951954c6cb5686e9de3f4ea46d08e3e6c56" translate="yes" xml:space="preserve">
          <source>For backward compatibility, you can also use the css binding with a string value like the class binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc285857d05b5c21a59d307e884dc555d9c7a77" translate="yes" xml:space="preserve">
          <source>For complete syntax, see the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener la sintaxis completa, consulte la &lt;a href=&quot;computed-reference&quot;&gt;referencia observable calculada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f8598317b25a1d69826eb855f00f8318431cdf0" translate="yes" xml:space="preserve">
          <source>For documentation on these standard component loader functions, see &lt;a href=&quot;#custom-component-loader&quot;&gt;implementing a custom component loader&lt;/a&gt;.</source>
          <target state="translated">Para obtener documentaci&amp;oacute;n sobre estas funciones est&amp;aacute;ndar del cargador de componentes, consulte &lt;a href=&quot;#custom-component-loader&quot;&gt;implementaci&amp;oacute;n de un cargador de componentes personalizado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75d6aa97d869ac1df9beec0c8c0cbb559a4d3a8d" translate="yes" xml:space="preserve">
          <source>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</source>
          <target state="translated">Para una mejor encapsulación,puedes empaquetar un componente en un único módulo AMD autodescriptivo.Entonces puedes referirte a un componente tan simple como:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="7f3364ff4802481e63e46cadfbc8760e3675bb8b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like { template: 'someElementId', viewModel: { require: 'myModule' } } can be understood and instantiated by the default loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6431474d550826b851e8376cf48298a6011540b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like {template:'someElementId',viewModel:{require:'myModule'}} can be understood and instantiated by the default loader.</source>
          <target state="translated">Por ejemplo,un componenteConfig como {template:'someElementId',viewModel:{require:'myModule'}}puede ser entendido e instanciado por el cargador por defecto.</target>
        </trans-unit>
        <trans-unit id="63125df5cb160d3708cafec1f0e9b2f0547ee516" translate="yes" xml:space="preserve">
          <source>For example, define a view model as follows:</source>
          <target state="translated">Por ejemplo,defina un modelo de vista de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="36572a6a5e79cde64bef7c1785b1f36c362c494f" translate="yes" xml:space="preserve">
          <source>For example, given the following view model class,</source>
          <target state="translated">Por ejemplo,dada la siguiente clase de modelo de vista,</target>
        </trans-unit>
        <trans-unit id="8c8a073a43cbbbf266ce41b059e8d1e1736f0261" translate="yes" xml:space="preserve">
          <source>For example, if the following is in a file at path/my-component.js,</source>
          <target state="translated">Por ejemplo,si lo siguiente está en un archivo en path/my-component.js,</target>
        </trans-unit>
        <trans-unit id="389a8f18d6ec0043db2935b9cac1d05b35c584a6" translate="yes" xml:space="preserve">
          <source>For example, if you return 'value + &quot;.toUpperCase()&quot;' as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="translated">Por ejemplo,si devuelves &quot;valor+&quot;.toUpperCase()&quot;' como una cadena,entonces tuBinding:&quot;Bert&quot; se interpretaría como si el marcado contuviera tuBinding:&quot;Bert&quot;.toUpperCase()&quot;.Knockout analizará el valor devuelto de la forma normal,por lo que tiene que ser una expresión legal de JavaScript.</target>
        </trans-unit>
        <trans-unit id="631d5ff146ac1b7e8d91b5960cafd4e8fdada71b" translate="yes" xml:space="preserve">
          <source>For example, if you return value + &quot;.toUpperCase()&quot; as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1345d943ae097566d0a2d604bb67d731cf352713" translate="yes" xml:space="preserve">
          <source>For example, if you structure your page like this, then everything will be OK:</source>
          <target state="translated">Por ejemplo,si estructuras tu página así,entonces todo estará bien:</target>
        </trans-unit>
        <trans-unit id="a37e35428471e05739a74959c92c8f8eda5e555f" translate="yes" xml:space="preserve">
          <source>For example, if your component is inside some other element with an &lt;a href=&quot;if-binding&quot;&gt;if binding&lt;/a&gt; (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</source>
          <target state="translated">Por ejemplo, si su componente est&amp;aacute; dentro de alg&amp;uacute;n otro elemento con un &lt;a href=&quot;if-binding&quot;&gt;enlace if&lt;/a&gt; (u otro enlace de flujo de control), no har&amp;aacute; que el m&amp;oacute;dulo AMD se cargue hasta que la condici&amp;oacute;n if sea verdadera. Por supuesto, si el m&amp;oacute;dulo AMD ya estaba cargado (por ejemplo, en un paquete precargado), la llamada require no activar&amp;aacute; ninguna solicitud HTTP adicional, por lo que puede controlar qu&amp;eacute; est&amp;aacute; precargado y qu&amp;eacute; se carga a pedido.</target>
        </trans-unit>
        <trans-unit id="e99ffdec1cc7a8a75e2b94b719091deff0a98942" translate="yes" xml:space="preserve">
          <source>For example, instead of writing this:</source>
          <target state="translated">Por ejemplo,en lugar de escribir esto:</target>
        </trans-unit>
        <trans-unit id="9a23df25508d72cfc8abcacad7f0ed1d5ab1eb72" translate="yes" xml:space="preserve">
          <source>For example, rewrite the preceding view model object as follows:</source>
          <target state="translated">Por ejemplo,reescriba el objeto modelo de la vista anterior de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="abacb1facc5d8e8adbbbcedeb1ae28fe320f9867" translate="yes" xml:space="preserve">
          <source>For example, the following element:</source>
          <target state="translated">Por ejemplo,el siguiente elemento:</target>
        </trans-unit>
        <trans-unit id="64c9c667af6bb9f6172083bac994162a1c1b7a9a" translate="yes" xml:space="preserve">
          <source>For example, the my-special-list component&amp;rsquo;s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here&amp;rsquo;s the complete working example:</source>
          <target state="translated">Por ejemplo, la plantilla del componente my-special-list puede hacer referencia a $ componentTemplateNodes para que su salida incluya el marcado proporcionado. Aqu&amp;iacute; est&amp;aacute; el ejemplo de trabajo completo:</target>
        </trans-unit>
        <trans-unit id="2b6ff54598ebe3588255d709e9a0c9f753a2b35d" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="translated">Por ejemplo, puede crear componentes interactivos como cuadr&amp;iacute;culas, conjuntos de pesta&amp;ntilde;as, etc., en forma de enlaces personalizados (consulte el &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;ejemplo de cuadr&amp;iacute;cula&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="259dc2bfcba22b9dd8b551f2db8f17cbb974e01e" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;https://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a7c228afe4cc9a5c128478008d3b1f5884e84" translate="yes" xml:space="preserve">
          <source>For example, you might have been controlling an element&amp;rsquo;s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery&amp;rsquo;s slideUp/slideDown functions:</source>
          <target state="translated">Por ejemplo, es posible que haya estado controlando la visibilidad de un elemento utilizando el enlace visible, pero ahora desea ir un paso m&amp;aacute;s all&amp;aacute; y animar la transici&amp;oacute;n. Quieres que los elementos entren y salgan de la existencia de acuerdo con el valor de un observable. Puede hacer esto escribiendo un enlace personalizado que llame a las funciones slideUp / slideDown de jQuery:</target>
        </trans-unit>
        <trans-unit id="a0af413f30c072cb2f86c4d5c9c43068f2afe457" translate="yes" xml:space="preserve">
          <source>For example, you might want to enable configuration formats like the following:</source>
          <target state="translated">Por ejemplo,podría querer habilitar formatos de configuración como los siguientes:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f678f7a6798df2a555b214e68d162f307fd8e326" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="translated">Para ver ejemplos de afterAdd y beforeRemove, consulte las &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;transiciones animadas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e3b099a296c9a13aa7e5074fa8572b152dae60" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;https://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eebaa938c7aaf194d0d6134712c9458bdd1e31e" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO&amp;rsquo;s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don&amp;rsquo;t send any notification to the array&amp;rsquo;s subscribers that its content has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fee50827f83055c14d664c8ae49efc9b3ea847" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</source>
          <target state="translated">Para las funciones que modifican el contenido de la matriz, como empujar y empalmar, los m&amp;eacute;todos de KO activan autom&amp;aacute;ticamente el mecanismo de seguimiento de dependencias para que todos los oyentes registrados sean notificados del cambio y su interfaz de usuario se actualice autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="76a00e59b8c3067b079a7bc20c769830ca1ae02b" translate="yes" xml:space="preserve">
          <source>For information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren&amp;rsquo;t on your view model, see the notes relating to the &lt;a href=&quot;click-binding&quot;&gt;click binding&lt;/a&gt;. All the notes on that page apply to submit handlers too.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo pasar par&amp;aacute;metros adicionales a su funci&amp;oacute;n de controlador de env&amp;iacute;o, o c&amp;oacute;mo controlar este controlador al invocar funciones que no est&amp;aacute;n en su modelo de vista, consulte las notas relacionadas con el &lt;a href=&quot;click-binding&quot;&gt;enlace de clic&lt;/a&gt; . Todas las notas de esa p&amp;aacute;gina tambi&amp;eacute;n se aplican a los controladores de env&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="c7f48a902247b730ada79fe82babfb437d3afca3" translate="yes" xml:space="preserve">
          <source>For loading, update your view model using data that you&amp;rsquo;ve received using one of the above techniques</source>
          <target state="translated">Para cargar, actualice su modelo de vista usando los datos que ha recibido usando una de las t&amp;eacute;cnicas anteriores</target>
        </trans-unit>
        <trans-unit id="7adb7866a71f6f46b996a32c046194acab2ca099" translate="yes" xml:space="preserve">
          <source>For more control, pass a JavaScript object with some combination of the following properties:</source>
          <target state="translated">Para más control,pasa un objeto JavaScript con alguna combinación de las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="ad4b6504c8a1b8acae6adc1c35890de1f949db77" translate="yes" xml:space="preserve">
          <source>For more details about these observableArray functions, see the equivalent documentation of the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;standard JavaScript array functions&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre estas funciones observablesArray, consulte la documentaci&amp;oacute;n equivalente de las &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;funciones est&amp;aacute;ndar de matriz de JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33ebce62a68ac66ad4bdebcd712e571477e40bce" translate="yes" xml:space="preserve">
          <source>For more information about $index and other context properties such as $parent, see documentation for &lt;a href=&quot;binding-context&quot;&gt;binding context properties&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre $ index y otras propiedades de contexto como $ parent, consulte la documentaci&amp;oacute;n sobre &lt;a href=&quot;binding-context&quot;&gt;las propiedades de contexto de enlace&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d002e63ef2bdfe307b7dc6dd93d11d5d0f3420e" translate="yes" xml:space="preserve">
          <source>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</source>
          <target state="translated">Para guardarlo,consiga los datos de su modelo de vista en un simple formato JSON para que pueda enviarlo usando una de las técnicas anteriores.</target>
        </trans-unit>
        <trans-unit id="6ed6deeffb9be7ad51042e1a135e3e9e951b890d" translate="yes" xml:space="preserve">
          <source>For the using binding, although you can use this option, it would generally be more efficient and descriptive to use the &lt;a href=&quot;let-binding&quot;&gt;let binding&lt;/a&gt; instead. Rather than using: currentPerson, as: 'person', noChildContext: true, you&amp;rsquo;d use let: { person: currentPerson }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e09e1e68bd9f09528070843f84d40f2039aa8c2" translate="yes" xml:space="preserve">
          <source>For the using binding, descendant elements will remain in the document and their bindings re-evaluated with the new context value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f20975442dd142df3dfc2e9186957414d588e0" translate="yes" xml:space="preserve">
          <source>For the using binding, it is generally incorrect to supply a null or undefined value since it will try to use that value as the context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299f2d31774daca6f4077fc8efaadbf7175a173" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1234d03268a26c263a165b8d5a4f87d33c04e4" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22b50f0de3d7cac900daaf7c9e5b4041689cd2f" translate="yes" xml:space="preserve">
          <source>For this to work, the files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files/component-like-widget.js&lt;/a&gt; and &lt;a href=&quot;files/component-like-widget&quot;&gt;files/component-like-widget.html&lt;/a&gt; need to exist. Check them out (and &lt;em&gt;view source&lt;/em&gt; on the .html one) - as you&amp;rsquo;ll see, this is cleaner and more convenient that including the code inline in the definition.</source>
          <target state="translated">Para que esto funcione, los archivos &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files / component-like-widget.js&lt;/a&gt; y &lt;a href=&quot;files/component-like-widget&quot;&gt;files / component-like-widget.html&lt;/a&gt; deben existir. Compru&amp;eacute;belos (y &lt;em&gt;vea el c&amp;oacute;digo fuente&lt;/em&gt; en .html); como ver&amp;aacute;, esto es m&amp;aacute;s limpio y m&amp;aacute;s conveniente que incluir el c&amp;oacute;digo en l&amp;iacute;nea en la definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b3f6e3b0f1ca1f18fefa1a37d9ba45e25616b20" translate="yes" xml:space="preserve">
          <source>Forcing computed observables to always notify subscribers</source>
          <target state="translated">Obligar a los observables computarizados a notificar siempre a los suscriptores</target>
        </trans-unit>
        <trans-unit id="84662a42c470dcc749e4f555eafc404bee27a93f" translate="yes" xml:space="preserve">
          <source>Forcing deferred notifications to happen early</source>
          <target state="translated">Obligar a que las notificaciones aplazadas se realicen con antelación</target>
        </trans-unit>
        <trans-unit id="5f499a5d8b4de8fa658740f93586939f3677a5ae" translate="yes" xml:space="preserve">
          <source>Forcing deferred observables to always notify subscribers</source>
          <target state="translated">Obligar a los observables diferidos a notificar siempre a los suscriptores</target>
        </trans-unit>
        <trans-unit id="98d0c19699f7a2e290891f5a4e98f8719c1258d5" translate="yes" xml:space="preserve">
          <source>Forcing observables to always notify subscribers</source>
          <target state="translated">Obligar a los observables a notificar siempre a los suscriptores</target>
        </trans-unit>
        <trans-unit id="f54bb0060ff337df25025c131396a49f22403fe7" translate="yes" xml:space="preserve">
          <source>Forcing rate-limited observables to always notify subscribers</source>
          <target state="translated">Obligar a los observables de tasa limitada a notificar siempre a los suscriptores</target>
        </trans-unit>
        <trans-unit id="6e02a1c244564b921ceb8e82920afc310566e328" translate="yes" xml:space="preserve">
          <source>Full details:</source>
          <target state="translated">Todos los detalles:</target>
        </trans-unit>
        <trans-unit id="2c93794a5d7ef6cb3e1c45af5db6db00afa54472" translate="yes" xml:space="preserve">
          <source>Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have to write submit: viewModel.doSomething (though technically that&amp;rsquo;s also valid).</source>
          <target state="translated">Las funciones en su modelo de vista son un poco especiales porque puede hacer referencia a ellas por su nombre, es decir, puede escribir submit: doSomething y &lt;em&gt;no&lt;/em&gt; tiene que escribir submit: viewModel.doSomething (aunque t&amp;eacute;cnicamente eso tambi&amp;eacute;n es v&amp;aacute;lido).</target>
        </trans-unit>
        <trans-unit id="45c386b929cd8059a6ebbcf8d5cf6632dffb76e7" translate="yes" xml:space="preserve">
          <source>Functions you can implement</source>
          <target state="translated">Funciones que puede implementar</target>
        </trans-unit>
        <trans-unit id="5b8ebd236050a24d7ee285b263736dd0ada77452" translate="yes" xml:space="preserve">
          <source>Generally, the best way to perform such post-processing on DOM elements is to write a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;, but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.</source>
          <target state="translated">Generalmente, la mejor manera de realizar dicho procesamiento posterior en elementos DOM es escribir un &lt;a href=&quot;custom-bindings&quot;&gt;enlace personalizado&lt;/a&gt; , pero si realmente solo desea acceder a los elementos DOM sin procesar emitidos por una plantilla, puede usar afterRender.</target>
        </trans-unit>
        <trans-unit id="74b46ff2fa2d37b0a8e7636b52d4e4152c5f19f8" translate="yes" xml:space="preserve">
          <source>Generally, there would be little reason to subscribe to the childrenComplete event in such a binding since it would be the same as just running your post-processing code after ko.applyBindingsToDescendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc53371ed103fecb3625d6b54a824260aab0b6d" translate="yes" xml:space="preserve">
          <source>Going back to the classic &amp;ldquo;first name + last name = full name&amp;rdquo; example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into &amp;ldquo;firstName&amp;rdquo; and &amp;ldquo;lastName&amp;rdquo; components, and writing those values back to the underlying observables.</source>
          <target state="translated">Volviendo al ejemplo cl&amp;aacute;sico de &quot;nombre + apellido = nombre completo&quot;, puede cambiar las cosas al rev&amp;eacute;s: haga que el nombre completo calculado y observable se pueda escribir, de modo que el usuario pueda editar directamente el nombre completo, y su valor proporcionado ser analizado y mapeado de nuevo a los observables firstName y lastName subyacentes. En este ejemplo, la devoluci&amp;oacute;n de llamada de escritura maneja los valores entrantes dividiendo el texto entrante en los componentes &quot;firstName&quot; y &quot;lastName&quot;, y escribiendo esos valores en los observables subyacentes.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="e790fc9db2ebd2516f36edd273ef2c230b8019be" translate="yes" xml:space="preserve">
          <source>HTML5-era browsers, which includes &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; and later, automatically allow for custom elements with no difficulties.</source>
          <target state="translated">Los navegadores de la era HTML5, que incluyen &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; y &lt;strong&gt;versiones&lt;/strong&gt; posteriores, permiten autom&amp;aacute;ticamente elementos personalizados sin dificultades.</target>
        </trans-unit>
        <trans-unit id="db3faaddbfebaf215e63526cf28c5c5fa9f0ccf7" translate="yes" xml:space="preserve">
          <source>Headline features:</source>
          <target state="translated">Titulares:</target>
        </trans-unit>
        <trans-unit id="4e7751af05ac722a6fb5ef531e8dadad667d4de0" translate="yes" xml:space="preserve">
          <source>Here a few situations in which you might want to use these mapping options.</source>
          <target state="translated">Aquí hay algunas situaciones en las que podría querer usar estas opciones de mapeo.</target>
        </trans-unit>
        <trans-unit id="6ec4c1a3ba1febd520b968b83993af24bd3d1248" translate="yes" xml:space="preserve">
          <source>Here are examples of how the changes are reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc2db2d3dd09d2d25123ee5014cb4e846965eaa" translate="yes" xml:space="preserve">
          <source>Here is a basic example of setting values using let that are then available in all descendant elements, regardless of context changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e69de42d839b42bf754d25ca92cab286df4be6" translate="yes" xml:space="preserve">
          <source>Here is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is &lt;em&gt;not&lt;/em&gt; necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo muy b&amp;aacute;sico de c&amp;oacute;mo cambiar el contexto de enlace a un objeto secundario. Tenga en cuenta que en los atributos de datos se unen, es &lt;em&gt;no&lt;/em&gt; necesario prefijo de latitud o longitud con coord., Porque el contexto uni&amp;oacute;n se cambi&amp;oacute; a coords.</target>
        </trans-unit>
        <trans-unit id="b82739780a396a71434b267de5bea3a454dbbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration that will add some text to the incoming data before updating:</source>
          <target state="translated">He aquí un ejemplo de una configuración que añadirá algún texto a los datos entrantes antes de actualizarlos:</target>
        </trans-unit>
        <trans-unit id="3280dba535f19f2febc60673f89c1a84ba00d47d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;a simple implementation of integrating Underscore templates with Knockout&lt;/a&gt;. The integration code is just 16 lines long, but it&amp;rsquo;s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables ($parent, $root, etc.).</source>
          <target state="translated">Aqu&amp;iacute; hay &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;una implementaci&amp;oacute;n simple de la integraci&amp;oacute;n de plantillas de subrayado con Knockout&lt;/a&gt; . El c&amp;oacute;digo de integraci&amp;oacute;n tiene solo 16 l&amp;iacute;neas, pero es suficiente para admitir atributos de enlace de datos Knockout (y por lo tanto plantillas anidadas) y variables de &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; Knockout ($ parent, $ root, etc.).</target>
        </trans-unit>
        <trans-unit id="84443bf9a128caa94205efa8ada501ff154e881b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a trivial example that uses afterAdd to apply the classic &amp;ldquo;yellow fade&amp;rdquo; effect to newly-added items. It requires the &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color plugin&lt;/a&gt; to enable animation of background colors.</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo trivial que usa afterAdd para aplicar el efecto cl&amp;aacute;sico de &quot;desvanecimiento amarillo&quot; a los elementos reci&amp;eacute;n agregados. Requiere el &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;complemento jQuery Color&lt;/a&gt; para habilitar la animaci&amp;oacute;n de los colores de fondo.</target>
        </trans-unit>
        <trans-unit id="37cf14e229e69417a43a02c23085e0aa99c73561" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:</source>
          <target state="translated">Aqu&amp;iacute; hay una forma de definir una funci&amp;oacute;n filterByProperty que estar&amp;aacute; disponible en todas las instancias de ko.observableArray creadas posteriormente:</target>
        </trans-unit>
        <trans-unit id="8fb66c98e55cbff21c223380e9a5374ec4c0a1ef" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example configuration:</source>
          <target state="translated">Aqu&amp;iacute; hay una configuraci&amp;oacute;n de ejemplo:</target>
        </trans-unit>
        <trans-unit id="b05ce77e66ba4c65f03af6e3ab19e65b03d68454" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using the above custom binding:</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo del uso del enlace personalizado anterior:</target>
        </trans-unit>
        <trans-unit id="66b583251e6c4a39e879523f6accea2dbf4b4259" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that uses optionsAfterRender to add a disable binding to each option.</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo que usa optionsAfterRender para agregar un enlace de desactivaci&amp;oacute;n a cada opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="30b31c34d144c1947d36ca331230826869c8a16e" translate="yes" xml:space="preserve">
          <source>How Knockout loads components via AMD</source>
          <target state="translated">Cómo Knockout carga los componentes a través de AMD</target>
        </trans-unit>
        <trans-unit id="7e306597890108bc7fc111d560e6054689ac6ebc" translate="yes" xml:space="preserve">
          <source>How dependency tracking works</source>
          <target state="translated">Cómo funciona el seguimiento de la dependencia</target>
        </trans-unit>
        <trans-unit id="93fddf00520975913c2fecc46ee1c69334b1426a" translate="yes" xml:space="preserve">
          <source>How is Knockout different?</source>
          <target state="translated">¿En qué se diferencia Knockout?</target>
        </trans-unit>
        <trans-unit id="47ba114c765ebcdb727f9bec12dc3ebaf5886692" translate="yes" xml:space="preserve">
          <source>How things are mapped</source>
          <target state="translated">Como las cosas están mapeadas</target>
        </trans-unit>
        <trans-unit id="361fb2674c6c2b62b9aae1a7ce5281fcff2e1a0b" translate="yes" xml:space="preserve">
          <source>How to create an extender</source>
          <target state="translated">Cómo crear un extensor</target>
        </trans-unit>
        <trans-unit id="ae005b5e0ed8d5109a9c1e98c6cbd19a088774bc" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default action proceed, just return true from your event handler function.</source>
          <target state="translated">Sin embargo, si usted &lt;em&gt;no&lt;/em&gt; desea que la acci&amp;oacute;n predeterminada proceder, simplemente vuelta verdad de su funci&amp;oacute;n de controlador de eventos.</target>
        </trans-unit>
        <trans-unit id="64ce42b8e7f69d107832250d68dbd01a878deeb2" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default click action proceed, just return true from your click handler function.</source>
          <target state="translated">Sin embargo, si usted &lt;em&gt;no&lt;/em&gt; desea que la acci&amp;oacute;n predeterminada clic en Continuar, simplemente vuelta verdad de su funci&amp;oacute;n de clic manejador.</target>
        </trans-unit>
        <trans-unit id="a6e2915dc92ca412b52398579f1e49c3c8348959" translate="yes" xml:space="preserve">
          <source>However, if you use value to link a form element to a &lt;em&gt;non&lt;/em&gt;-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</source>
          <target state="translated">Sin embargo, si usa valor para vincular un elemento de formulario a una propiedad &lt;em&gt;no&lt;/em&gt; observable (por ejemplo, una cadena antigua simple o una expresi&amp;oacute;n de JavaScript arbitraria), KO har&amp;aacute; lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8c30fbacefa412111122658b9f8bc072a603ddd1" translate="yes" xml:space="preserve">
          <source>However, it does &lt;em&gt;not&lt;/em&gt; work with virtual elements. If you try the following:</source>
          <target state="translated">Sin embargo, &lt;em&gt;no&lt;/em&gt; funciona con elementos virtuales. Si prueba lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8531b5d91c66d42745ea8deb05f270abe4564d92" translate="yes" xml:space="preserve">
          <source>However, it does not make sense to use bindings that would modify the element&amp;rsquo;s contents, such as the &lt;a href=&quot;text-binding&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; bindings, since they would overwrite the template injected by your component.</source>
          <target state="translated">Sin embargo, no tiene sentido usar enlaces que modificar&amp;iacute;an el contenido del elemento, como el &lt;a href=&quot;text-binding&quot;&gt;texto&lt;/a&gt; o los enlaces de la &lt;a href=&quot;template-binding&quot;&gt;plantilla&lt;/a&gt; , ya que sobrescribir&amp;iacute;an la plantilla inyectada por su componente.</target>
        </trans-unit>
        <trans-unit id="8b2c1d7baa87a948e36706143a1b3bd56c309bf4" translate="yes" xml:space="preserve">
          <source>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see &lt;a href=&quot;plugins-mapping&quot;&gt;the knockout.mapping plugin&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, muchos desarrolladores prefieren utilizar un enfoque m&amp;aacute;s basado en convenciones para actualizar sus modelos de vista utilizando datos entrantes sin escribir manualmente una l&amp;iacute;nea de c&amp;oacute;digo para cada propiedad a actualizar. Esto puede ser beneficioso si sus modelos de vista tienen muchas propiedades o estructuras de datos profundamente anidadas, ya que puede reducir en gran medida la cantidad de c&amp;oacute;digo de mapeo manual que necesita escribir. Para obtener m&amp;aacute;s detalles sobre esta t&amp;eacute;cnica, consulte &lt;a href=&quot;plugins-mapping&quot;&gt;el complemento knockout.mapping&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df78c9be1d978ee24c637cf614f8f43143a6b702" translate="yes" xml:space="preserve">
          <source>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the &amp;lt;select&amp;gt;, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the &amp;lt;select&amp;gt;, then the &amp;lt;select&amp;gt; simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</source>
          <target state="translated">Sin embargo, a veces es posible que no desee ese comportamiento. Si, en cambio, desea que Knockout permita que su modelo observable tome valores que no tienen una entrada correspondiente en &amp;lt;select&amp;gt;, especifique valueAllowUnset: true. En este caso, siempre que el valor de su modelo no se pueda representar en &amp;lt;select&amp;gt;, entonces &amp;lt;select&amp;gt; simplemente no tiene ning&amp;uacute;n valor seleccionado en ese momento, lo que se representa visualmente al estar en blanco. Cuando el usuario seleccione m&amp;aacute;s tarde una entrada del men&amp;uacute; desplegable, se escribir&amp;aacute; en su modelo como de costumbre. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0df1b7294fed0a051d101c1ced30ea172ab4baf7" translate="yes" xml:space="preserve">
          <source>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</source>
          <target state="translated">Sin embargo,el valor de la propiedad computada es en sí mismo un observable.Esto parecería llevar a un escenario incómodo,en el que la lectura de su valor actual implicaría un doble desenvolvimiento (es decir,params.myExpr()(),en el que el primer paréntesis da el valor de la expresión,y el segundo da el valor de la instancia observable resultante).</target>
        </trans-unit>
        <trans-unit id="be4ce8e4d8bb3b24ee5b708a10a1169afa34a1e3" translate="yes" xml:space="preserve">
          <source>IE 6 does not allow radio buttons to be checked if they don&amp;rsquo;t have a name attribute. Most of the time this is irrelevant because your radio button elements &lt;em&gt;will&lt;/em&gt; have name attributes to put them into mutually-exclusive groups. However, just in case you didn&amp;rsquo;t add a name attribute because it&amp;rsquo;s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.</source>
          <target state="translated">IE 6 no permite que se verifiquen los botones de opci&amp;oacute;n si no tienen un atributo de nombre. La mayor&amp;iacute;a de las veces, esto es irrelevante porque los elementos de su bot&amp;oacute;n de opci&amp;oacute;n &lt;em&gt;tendr&amp;aacute;n&lt;/em&gt; atributos de nombre para colocarlos en grupos mutuamente excluyentes. Sin embargo, en caso de que no haya agregado un atributo de nombre porque es innecesario en su caso, KO usar&amp;aacute; internamente uniqueName en esos elementos para asegurarse de que se puedan verificar.</target>
        </trans-unit>
        <trans-unit id="2fcefc92a53613238743a06738a1a958455ef2e0" translate="yes" xml:space="preserve">
          <source>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</source>
          <target state="translated">IE 6 tiene una extraña peculiaridad por la que a veces ignora los espacios en blanco que siguen inmediatamente a un espacio vacío.Esto no tiene nada que ver directamente con Knockout,pero en caso de que quieras escribir:</target>
        </trans-unit>
        <trans-unit id="91559d59670bd974a48fef061e5a488f693ecb19" translate="yes" xml:space="preserve">
          <source>IE 6-8&amp;rsquo;s HTML parser will discard any unrecognized elements. To ensure it doesn&amp;rsquo;t throw out your custom elements, you must do one of the following:</source>
          <target state="translated">El analizador de HTML de IE 6-8 descartar&amp;aacute; cualquier elemento no reconocido. Para asegurarse de que no elimine sus elementos personalizados, debe realizar una de las siguientes acciones:</target>
        </trans-unit>
        <trans-unit id="2d16b47ea598c9827309c0d43dee7b26141e40d5" translate="yes" xml:space="preserve">
          <source>If a binding includes a manual subscription, this can be set to dispose automatically by calling its disposeWhenNodeIsRemoved method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5f5e45ca2c0ef94cde806f22f9193ea7e171a" translate="yes" xml:space="preserve">
          <source>If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed&lt;/a&gt; to avoid the need for manual disposal.</source>
          <target state="translated">Si una dependencia est&amp;aacute; en un objeto externo, aseg&amp;uacute;rese de usar .dispose () en la propiedad calculada, de lo contrario, (y posiblemente tambi&amp;eacute;n su modelo de vista) se mantendr&amp;aacute; en la memoria. Alternativamente, considere usar un &lt;a href=&quot;computed-pure&quot;&gt;calculado &lt;/a&gt;&lt;em&gt;puro&lt;/em&gt; para evitar la necesidad de eliminaci&amp;oacute;n manual.</target>
        </trans-unit>
        <trans-unit id="d97a8252f992217661b3da8e9168c34da29b4082" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does not&lt;/strong&gt; involve evaluating an observable/computed, it is passed literally.</source>
          <target state="translated">Si la evaluaci&amp;oacute;n de un par&amp;aacute;metro &lt;strong&gt;no&lt;/strong&gt; implica evaluar un observable / calculado, se pasa literalmente.</target>
        </trans-unit>
        <trans-unit id="85bdcb92d8fed08ef07c5a9167f6303fb9542783" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does&lt;/strong&gt; involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</source>
          <target state="translated">Si la evaluaci&amp;oacute;n de un par&amp;aacute;metro &lt;strong&gt;no&lt;/strong&gt; implica la evaluaci&amp;oacute;n de uno o m&amp;aacute;s observables / computeds, se pasa como una propiedad calculada para que pueda reaccionar a los cambios en el valor del par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="1f49d13df2276280d49d2672aa1b68bc3513435f" translate="yes" xml:space="preserve">
          <source>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; or window.onerror.</source>
          <target state="translated">Si una tarea produce una excepci&amp;oacute;n, no interrumpir&amp;aacute; la cola de tareas, que continuar&amp;aacute; hasta que est&amp;eacute; vac&amp;iacute;a. En cambio, la excepci&amp;oacute;n se pospondr&amp;aacute; para un evento posterior y se puede manejar usando &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; o window.onerror.</target>
        </trans-unit>
        <trans-unit id="c0e58b3f0b1346e29b75ea079a4a3af7f374c623" translate="yes" xml:space="preserve">
          <source>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</source>
          <target state="translated">Si alguno de los parámetros pasados al componente es observable,entonces el componente puede,por supuesto,observar cualquier cambio,o incluso escribir valores modificados.Así es como puede comunicarse limpiamente con su progenitor,sin acoplar estrechamente el código del componente a cualquier progenitor que lo utilice.</target>
        </trans-unit>
        <trans-unit id="d2042df6fe8e9a541f83353153b54cf9ca0fb63e" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.</source>
          <target state="translated">Si se declara,Knockout llamará a esta función para convertir un objeto componenteConfig en un par modelo/plantilla.</target>
        </trans-unit>
        <trans-unit id="399dea5a85a9f6316a3592794fb48cd5d6a619e0" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</source>
          <target state="translated">Si se declara,Knockout llamará a esta función para obtener un objeto de configuración para cada componente que se instale.</target>
        </trans-unit>
        <trans-unit id="be4cb475157b09548b6d107ebd37c013b2c16886" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each &amp;lt;name&amp;gt; binding before the binding is evaluated.</source>
          <target state="translated">Si se define, esta funci&amp;oacute;n se llamar&amp;aacute; para cada enlace &amp;lt;nombre&amp;gt; antes de que se eval&amp;uacute;e el enlace.</target>
        </trans-unit>
        <trans-unit id="6a046840fb4cbdaaea31db2bea0e71b5d3908b95" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.</source>
          <target state="translated">Si se define,se llamará a esta función para cada nodo DOM antes de que se procesen los enlaces.La función puede modificar,eliminar o reemplazar un nodo.Cualquier nuevo nodo debe ser insertado inmediatamente antes del nodo,y si se ha añadido o eliminado algún nodo,la función debe devolver una matriz de los nuevos nodos que están ahora en el documento en lugar del nodo.</target>
        </trans-unit>
        <trans-unit id="8a2cb3b57840c0deef2eb7e49e7b4db257ff08df" translate="yes" xml:space="preserve">
          <source>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</source>
          <target state="translated">Si no se da un modelo de visualización,el componente se trata como un simple bloque de HTML que se vinculará a cualquier parámetro pasado al componente.</target>
        </trans-unit>
        <trans-unit id="6caa6867d855ce7ca277ec137fe7e6b2092a7de4" translate="yes" xml:space="preserve">
          <source>If required, you can remove ko.components.defaultLoader from the loaders array altogether.</source>
          <target state="translated">Si es necesario,puede eliminar ko.components.defaultLoader de la matriz de cargadores por completo.</target>
        </trans-unit>
        <trans-unit id="03317c5ba9cb772a076d1cd9742af2eaadf6c3ea" translate="yes" xml:space="preserve">
          <source>If the array you supply is observable, the foreach binding will respond to any future changes in the array&amp;rsquo;s contents by adding or removing corresponding sections of markup in the DOM.</source>
          <target state="translated">Si la matriz que proporciona es observable, el enlace foreach responder&amp;aacute; a cualquier cambio futuro en el contenido de la matriz agregando o eliminando las secciones correspondientes de marcado en el DOM.</target>
        </trans-unit>
        <trans-unit id="612f5263f91277945f3c298ba4abc465bd6747bb" translate="yes" xml:space="preserve">
          <source>If the checkedValue parameter is set, that value is used instead of true to represent a &lt;em&gt;checked&lt;/em&gt; status, and an &lt;em&gt;unchecked&lt;/em&gt; status is represented with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ef00d24a33559e687f508a59c22e7850ec79c" translate="yes" xml:space="preserve">
          <source>If the component binding&amp;rsquo;s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposal and memory management&lt;/a&gt;.</source>
          <target state="translated">Si el valor del nombre del enlace del componente cambia de forma observable, o si un enlace de flujo de control adjunto hace que se elimine el elemento contenedor, entonces se llama a cualquier funci&amp;oacute;n de disposici&amp;oacute;n en el modelo de vista justo antes de que el elemento contenedor se elimine del DOM. Ver tambi&amp;eacute;n: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;eliminaci&amp;oacute;n y gesti&amp;oacute;n de memoria&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da622aea8b5c8a482d41ae46dd18ebd2d3a51d5" translate="yes" xml:space="preserve">
          <source>If the expression you provide to the let binding unwraps any observables, each descendant binding will include an additional dependency on the let binding. This is true whether or not the binding references any of the custom context properties. If you want to make an observable value available through let, it is generally better to set the observable itself rather than unwrap it and set the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354afd97c35f636203d9262ca360ec893a10aa03" translate="yes" xml:space="preserve">
          <source>If the expression you supply evaluates to null or undefined, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="translated">Si la expresi&amp;oacute;n que proporciona se eval&amp;uacute;a como nula o indefinida, los elementos descendientes &lt;em&gt;no&lt;/em&gt; se vincular&amp;aacute;n en absoluto, sino que se eliminar&amp;aacute;n del documento.</target>
        </trans-unit>
        <trans-unit id="348434b438cb1d0346b5c2336a1b0270a699841f" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new evaluation result.</source>
          <target state="translated">Si la expresi&amp;oacute;n que proporciona incluye valores observables, la expresi&amp;oacute;n se volver&amp;aacute; a evaluar siempre que cambie alguno de esos observables. Luego, los elementos descendientes se borrar&amp;aacute;n y se agregar&amp;aacute; &lt;strong&gt;una nueva copia del marcado&lt;/strong&gt; a su documento y se vincular&amp;aacute; en el contexto del nuevo resultado de la evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3f2e0923cee18f9719776d03929fd49911724f4b" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. These bindings differ in how they react when the bound value changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623412eb267c55f2826cce3e4419e3b4cba4388f" translate="yes" xml:space="preserve">
          <source>If the expression you supply unwraps any observable values, the expression will be re-evaluated whenever any of those observables change. Additionally, the bindings for all descendant elements will be re-evaluated as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61935dcf249e331edbcc8210b8ebbb2409b5384" translate="yes" xml:space="preserve">
          <source>If the firstName observable&amp;rsquo;s value was changed to Ted, then the console would show first name: Ted.</source>
          <target state="translated">Si el valor del observable firstName se cambiara a Ted, la consola mostrar&amp;iacute;a el nombre: Ted.</target>
        </trans-unit>
        <trans-unit id="90ee5b54e158b99edb3b0d00a6d84366ceb29486" translate="yes" xml:space="preserve">
          <source>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.</source>
          <target state="translated">Si el usuario enfoca o desenfoca manualmente el elemento asociado,la propiedad viewmodel se ajustará a verdadero o falso en consecuencia.</target>
        </trans-unit>
        <trans-unit id="bbaee0a673e126908759d4192388e02a5778a34a" translate="yes" xml:space="preserve">
          <source>If the value you supply is observable, the hasFocus binding will update the element&amp;rsquo;s focus state whenever that observable value changes.</source>
          <target state="translated">Si el valor que proporciona es observable, el enlace hasFocus actualizar&amp;aacute; el estado de enfoque del elemento cada vez que cambie ese valor observable.</target>
        </trans-unit>
        <trans-unit id="b5c5acd515e8ae2158bb6854344b82731dca4d6c" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).</source>
          <target state="translated">Si el modelo de vista se da como una función constructora,esto significa que Knockout llama a los nuevos YourViewModel(params).</target>
        </trans-unit>
        <trans-unit id="73a19cfa23e05247f726bb0c3e3e11110deb972d" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.</source>
          <target state="translated">Si el viewmodel se da como una función de fábrica createViewModel,Knockout llama a createViewModel(params,componentInfo),donde componentInfo.element es el elemento en el que ya se ha inyectado la plantilla aún no vinculada.</target>
        </trans-unit>
        <trans-unit id="105d045e38636fe798ecdb5a45a203d90df04fff" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s available options whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s available options once and will not update them again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; las opciones disponibles del elemento siempre que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; las opciones disponibles del elemento una vez y no las actualizar&amp;aacute; nuevamente m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="cb1eb730b6d4db61f330d71ef6135d8fac903258" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s content whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s content once and will not update it again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; el contenido del elemento siempre que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el contenido del elemento una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="d54c813843091459c90fd11e7297fc0446687938" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s text whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s text once and will not update it again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; el texto del elemento siempre que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el texto del elemento una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="7a744e971b96b18141128533922f19a87beb8881" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the observable value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; el valor del elemento siempre que cambie el valor observable. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el valor del elemento una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="47eda63e6c27e664a420f7aabc543742f5f58f16" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; el valor del elemento siempre que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el valor del elemento una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="697682d3cadcd44d9c1d1305da3a61036fdfa605" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s visibility whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s visibility once and will not update it again later.</source>
          <target state="translated">Si este par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; la visibilidad del elemento siempre que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; la visibilidad del elemento una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="f45c52f51bf20ce24a7e4b608d15ab347ed9c290" translate="yes" xml:space="preserve">
          <source>If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.</source>
          <target state="translated">Si el valor AllowUnset no hubiera sido activado,entonces Knockout habría sobrescrito selectedCountry con undefined,para que coincidiera con el valor de la entrada de la leyenda 'Choose one...'.</target>
        </trans-unit>
        <trans-unit id="a24740e5d492d0bcabc30118270e3e7eae827804" translate="yes" xml:space="preserve">
          <source>If you apply a simple numeric value to a style that requires a unit, Knockout will append px to the value before setting the style. For example, style: { width: 100 } will set the width to 100px.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ea4a49bfcd03916cd06d69dac827b155984b2" translate="yes" xml:space="preserve">
          <source>If you are trying to bind an &amp;lt;input type=&quot;text&quot; /&amp;gt; or &amp;lt;textarea&amp;gt; to get instant updates to your viewmodel, use the &lt;a href=&quot;textinput-binding&quot;&gt;the textInput binding&lt;/a&gt;. It has better support for browser edge cases than any combination of valueUpdate options.</source>
          <target state="translated">Si est&amp;aacute; tratando de vincular un &amp;lt;input type = &quot;text&quot; /&amp;gt; o &amp;lt;textarea&amp;gt; para obtener actualizaciones instant&amp;aacute;neas de su modelo de vista, use el &lt;a href=&quot;textinput-binding&quot;&gt;v&amp;iacute;nculo textInput&lt;/a&gt; . Tiene mejor soporte para los casos extremos del navegador que cualquier combinaci&amp;oacute;n de opciones valueUpdate.</target>
        </trans-unit>
        <trans-unit id="1a7f396d14387545628545aeb2802baaa004a716" translate="yes" xml:space="preserve">
          <source>If you are using a component loader to fetch components by a naming convention, and are &lt;em&gt;not&lt;/em&gt; registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven&amp;rsquo;t told Knockout that they even exist).</source>
          <target state="translated">Si est&amp;aacute; utilizando un cargador de componentes para obtener componentes mediante una convenci&amp;oacute;n de nomenclatura y &lt;em&gt;no&lt;/em&gt; est&amp;aacute; registrando sus componentes mediante ko.components.register, esos componentes no se podr&amp;aacute;n utilizar autom&amp;aacute;ticamente como elementos personalizados (porque no le ha dicho a Knockout que incluso existe).</target>
        </trans-unit>
        <trans-unit id="57acecaab300936e5fb81a00ce2ade1592a7db93" translate="yes" xml:space="preserve">
          <source>If you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; usando foreach y solo desea que se le notifique sobre elementos que se agregan o eliminan espec&amp;iacute;ficamente, puede usar afterAdd y beforeRemove en su lugar. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la documentaci&amp;oacute;n del &lt;a href=&quot;foreach-binding&quot;&gt;enlace foreach&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce083543ff1be7a981205d49b50c12c2d35aab21" translate="yes" xml:space="preserve">
          <source>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="translated">Si estás usando nombres de clases CSS estáticas,entonces puedes pasar un objeto JavaScript en el que los nombres de las propiedades son tus clases CSS,y sus valores se evalúan a verdadero o falso según si la clase debe aplicarse actualmente.</target>
        </trans-unit>
        <trans-unit id="b409ece9cd23f86abee691f7b17d7b89e59dbba4" translate="yes" xml:space="preserve">
          <source>If you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</source>
          <target state="translated">Si estás usando el cargador de componentes por defecto,y por lo tanto estás registrando tus componentes usando ko.components.register,entonces no hay nada extra que necesites hacer.Los componentes registrados de esta manera están disponibles inmediatamente para su uso como elementos personalizados.</target>
        </trans-unit>
        <trans-unit id="8ddcd80cbca13d044050f160b5fe2da2f4edef8d" translate="yes" xml:space="preserve">
          <source>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</source>
          <target state="translated">Si se incluye comúnmente el contenido de la plantilla usando elementos virtuales,la sintaxis normal puede sentirse un poco verbosa.Usando el preprocesamiento,puedes añadir un nuevo formato de plantilla que use un solo comentario:</target>
        </trans-unit>
        <trans-unit id="c1d7cd0691a5cabd2961f5bde8eb238a8f9e084c" translate="yes" xml:space="preserve">
          <source>If you create a computed observable in a custom binding, rather than using a custom disposal callback, you can set the computed to dispose automatically when the node is removed. When constructing the computed observable, provide the node using the disposeWhenNodeIsRemoved option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dac748b82ce1d7e9df2f75a51a1b265e4aee88" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Si no quiere que su cargador proporcione una configuración para el componente nombrado,entonces llame a la devolución de llamada (null).Knockout consultará entonces a cualquier otro cargador registrado en secuencia,hasta que uno suministre un valor no nulo.</target>
        </trans-unit>
        <trans-unit id="a803a11622a50576c908d4836ed761b181f5ff65" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Si no desea que su cargador suministre una función createViewModel para los parámetros dados (por ejemplo,porque no reconoce el formato de configuración),llame a callback(null).Knockout consultará entonces a cualquier otro cargador registrado en secuencia,hasta que uno suministre un valor no nulo.</target>
        </trans-unit>
        <trans-unit id="88a98aefdcf31a903e5d480df483166240bfba37" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Si no quiere que su cargador le proporcione una plantilla para los parámetros dados (por ejemplo,porque no reconoce el formato de la configuración),llame a callback(null).Knockout consultará entonces a cualquier otro cargador registrado en secuencia,hasta que uno suministre un valor no nulo.</target>
        </trans-unit>
        <trans-unit id="96bd57dfc5e8e227d695eb9cc1de257c99d1c474" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">Si no quiere que su cargador suministre un par de modelo/plantilla para los parámetros dados,entonces llame a callback(null).Knockout consultará entonces a cualquier otro cargador registrado en secuencia,hasta que uno suministre un valor no nulo.</target>
        </trans-unit>
        <trans-unit id="c512ba9128c02d4d1a3f480875fdee4dc35677d7" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</source>
          <target state="translated">Si no desea mostrar solo un valor de propiedad simple como texto para cada elemento en el men&amp;uacute; desplegable, puede pasar una funci&amp;oacute;n de JavaScript para la opci&amp;oacute;n optionsText y proporcionar su propia l&amp;oacute;gica arbitraria para calcular el texto mostrado en t&amp;eacute;rminos del objeto representado . Consulte el Ejemplo 4 anterior, que muestra c&amp;oacute;mo podr&amp;iacute;a generar el texto mostrado concatenando varios valores de propiedad.</target>
        </trans-unit>
        <trans-unit id="4830a1b281a9a9be8b4899be04ed0ad714a44701" translate="yes" xml:space="preserve">
          <source>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</source>
          <target state="translated">Si tiene una referencia a un elemento DOM en su código,puede utilizarlo como contenedor para el marcado de la plantilla:</target>
        </trans-unit>
        <trans-unit id="6fc07db8d07ca18d202ff7e05a94198b45413180" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a template. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">Si ya tiene un cargador AMD (como &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) en su p&amp;aacute;gina, puede usarlo para buscar una plantilla. Para obtener m&amp;aacute;s detalles sobre c&amp;oacute;mo funciona esto, vea &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;c&amp;oacute;mo Knockout carga componentes a trav&amp;eacute;s de AMD a&lt;/a&gt; continuaci&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9a69d18b622bb3cca3c70f1710dff19c9f5aca93" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">Si ya tiene un cargador AMD (como &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; ) en su p&amp;aacute;gina, puede usarlo para obtener un modelo de vista. Para obtener m&amp;aacute;s detalles sobre c&amp;oacute;mo funciona esto, vea &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;c&amp;oacute;mo Knockout carga componentes a trav&amp;eacute;s de AMD a&lt;/a&gt; continuaci&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="8d613332487fc8236cb7e6d5e6bc539bf312e263" translate="yes" xml:space="preserve">
          <source>If you have implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;, and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don&amp;rsquo;t need to specify any configuration, since your custom component loader won&amp;rsquo;t be using the configuration anyway. For example,</source>
          <target state="translated">Si ha implementado un &lt;a href=&quot;component-loaders&quot;&gt;cargador de componentes personalizado&lt;/a&gt; y no est&amp;aacute; usando ko.components.register, entonces debe informar a Knockout sobre cualquier nombre de elemento que desee usar como elementos personalizados. Para hacer esto, simplemente llame a ko.components.register; no necesita especificar ninguna configuraci&amp;oacute;n, ya que su cargador de componentes personalizados no usar&amp;aacute; la configuraci&amp;oacute;n de todos modos. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="c6dc783c88a9a55d059f753b19bf7c4b10f1293f" translate="yes" xml:space="preserve">
          <source>If you have multiple named templates, you can pass an observable for the name option. As the observable&amp;rsquo;s value is updated, the element&amp;rsquo;s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item&amp;rsquo;s value as the only argument. Otherwise, the function will be given the data option&amp;rsquo;s value or fall back to providing your whole current model object.</source>
          <target state="translated">Si tiene varias plantillas con nombre, puede pasar un observable para la opci&amp;oacute;n de nombre. A medida que se actualiza el valor del observable, el contenido del elemento se volver&amp;aacute; a representar utilizando la plantilla adecuada. Alternativamente, puede pasar una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada para determinar qu&amp;eacute; plantilla usar. Si est&amp;aacute; utilizando el modo de plantilla foreach, Knockout evaluar&amp;aacute; la funci&amp;oacute;n para cada elemento de su matriz, pasando el valor de ese elemento como &amp;uacute;nico argumento. De lo contrario, a la funci&amp;oacute;n se le dar&amp;aacute; el valor de la opci&amp;oacute;n de datos o volver&amp;aacute; a proporcionar todo su objeto de modelo actual.</target>
        </trans-unit>
        <trans-unit id="f9fde0bfc8d899331beb6d9ec952dcb2dab1b640" translate="yes" xml:space="preserve">
          <source>If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</source>
          <target state="translated">Si se ha suscrito a un observatorio externo,asegúrese de utilizar .dispose()en la suscripción,de lo contrario la llamada de retorno (y posiblemente también su modelo de visualización)se mantendrá en la memoria.</target>
        </trans-unit>
        <trans-unit id="3c4d57bb828a71531ceeb4aa49b28a3c60f87e52" translate="yes" xml:space="preserve">
          <source>If you leave off the value of a binding, it&amp;rsquo;s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:</source>
          <target state="translated">Si omite el valor de un enlace, est&amp;aacute; vinculado a indefinido de forma predeterminada. Si desea tener un valor predeterminado diferente para un enlace, puede hacerlo con un preprocesador. Por ejemplo, puede permitir que uniqueName se vincule sin un valor haciendo que su valor predeterminado sea verdadero:</target>
        </trans-unit>
        <trans-unit id="df6baaff79cb69e31e568c59ade70f1456f1c34c" translate="yes" xml:space="preserve">
          <source>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</source>
          <target state="translated">Si necesita pasar más parámetros,una forma de hacerlo es envolviendo a su manejador en una función literal que tome un parámetro,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="395b1c02e2a6fd4dd3478f8ed3123de446425e64" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.</source>
          <target state="translated">Si necesita ejecutar alguna otra lógica personalizada en los elementos DOM generados,puede utilizar cualquiera de las devoluciones de llamada afterRender/afterAdd/beforeRemove/beforeMove/afterMove que se describen a continuación.</target>
        </trans-unit>
        <trans-unit id="e172b40bc2aac406378c1826a63899ef1e1c8897" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.</source>
          <target state="translated">Si necesita ejecutar más lógica personalizada en los elementos de opción generados,puede utilizar las opciones de devolución de llamada AfterRender.Véase la Nota 2 más abajo.</target>
        </trans-unit>
        <trans-unit id="e0946163467362f9f0453888bade424cd2a18cd9" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:</source>
          <target state="translated">Si necesita ejecutar más lógica personalizada en los elementos de opción generados,puede utilizar las opciones de devolución de llamada AfterRender.La función de devolución de llamada se invoca cada vez que se inserta un elemento de opción en la lista,con los siguientes parámetros:</target>
        </trans-unit>
        <trans-unit id="7add5138afadba9db94cdfc48e15c94798748a29" translate="yes" xml:space="preserve">
          <source>If you need to set HTML content in this manner, see &lt;a href=&quot;html-binding&quot;&gt;the html binding&lt;/a&gt;.</source>
          <target state="translated">Si necesita configurar el contenido HTML de esta manera, consulte &lt;a href=&quot;html-binding&quot;&gt;el enlace html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e813a05b4d4fc8d95d220cb80a0c91d23fba7f44" translate="yes" xml:space="preserve">
          <source>If you only need to combine updates without adding a delay, &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; provides a more efficient method.</source>
          <target state="translated">Si solo necesita combinar actualizaciones sin agregar un retraso, las &lt;a href=&quot;deferred-updates&quot;&gt;actualizaciones diferidas&lt;/a&gt; proporcionan un m&amp;eacute;todo m&amp;aacute;s eficiente.</target>
        </trans-unit>
        <trans-unit id="5e7be95f226e675b640699b19295d6d29cb25a1d" translate="yes" xml:space="preserve">
          <source>If you only need to use the compound full name in the UI you could declare it as:</source>
          <target state="translated">Si sólo necesitas usar el nombre completo del compuesto en la UI podrías declararlo como:</target>
        </trans-unit>
        <trans-unit id="fd19412014a27de66dbd7f90139a256b3d51da33" translate="yes" xml:space="preserve">
          <source>If you open your browser developer tools&amp;rsquo; &lt;strong&gt;Network&lt;/strong&gt; inspector before your first click on &lt;em&gt;Add product&lt;/em&gt;, you&amp;rsquo;ll see that the component&amp;rsquo;s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.</source>
          <target state="translated">Si abre el inspector de &lt;strong&gt;red de&lt;/strong&gt; las herramientas de desarrollador de su navegador antes de hacer clic por primera vez en &lt;em&gt;Agregar producto&lt;/em&gt; , ver&amp;aacute; que los archivos .js / .html del componente se obtienen a pedido cuando se solicitan por primera vez y, a partir de entonces, se conservan para su reutilizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7e3531ed2ee3130336ffaac70ea47406b8f9ad62" translate="yes" xml:space="preserve">
          <source>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</source>
          <target state="translated">Si se pasa sólo una cadena,se interpreta como un nombre de componente.El componente nombrado se inyecta entonces sin suministrarle ningún parámetro.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d8655e03ea768a2840f2c814ce3e4612e25b0a0e" translate="yes" xml:space="preserve">
          <source>If you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it&amp;rsquo;s quite nice to separate out these concerns, since their implementations are quite independent.</source>
          <target state="translated">Si lo prefiere, puede combinar templateFromUrlLoader y viewModelCustomLoader en un solo cargador colocando las funciones loadTemplate y loadViewModel en un solo objeto. Sin embargo, es bastante bueno separar estas preocupaciones, ya que sus implementaciones son bastante independientes.</target>
        </trans-unit>
        <trans-unit id="7d9099195cbde906f499c9495d5f5fd785651e50" translate="yes" xml:space="preserve">
          <source>If you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the &amp;lsquo;parent&amp;rsquo; or &amp;lsquo;host&amp;rsquo; viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel&amp;rsquo;s constructor as params.someModelProperty.</source>
          <target state="translated">Si se refiere a las propiedades del modelo en un atributo params, entonces, por supuesto, se est&amp;aacute; refiriendo a las propiedades en el modelo de vista fuera del componente (el modelo de vista 'principal' o 'anfitri&amp;oacute;n'), ya que el componente en s&amp;iacute; a&amp;uacute;n no est&amp;aacute; instanciado. En el ejemplo anterior, myModelValue ser&amp;iacute;a una propiedad en el modelo de vista principal y el constructor del modelo de vista del componente secundario lo recibir&amp;iacute;a como params.someModelProperty.</target>
        </trans-unit>
        <trans-unit id="7b53a3732a6bc04d508eda25f801b0bef1ad6dfd" translate="yes" xml:space="preserve">
          <source>If you reference a &lt;em&gt;simple property&lt;/em&gt;, i.e., it is just a regular property on your view model, KO will set the form element&amp;rsquo;s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn&amp;rsquo;t observable), so this is only a 1-way binding.</source>
          <target state="translated">Si hace referencia a una &lt;em&gt;propiedad simple&lt;/em&gt; , es decir, es solo una propiedad regular en su modelo de vista, KO establecer&amp;aacute; el estado inicial del elemento del formulario en el valor de la propiedad, y cuando se edite el elemento del formulario, KO volver&amp;aacute; a escribir los cambios en su propiedad . No puede detectar cu&amp;aacute;ndo cambia la propiedad (porque no es observable), por lo que este es solo un enlace de 1 v&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="7d891ed8be741967c449e958da98ffc8cc566217" translate="yes" xml:space="preserve">
          <source>If you reference something that is &lt;em&gt;not&lt;/em&gt; a simple property, e.g., the result of a function call or comparison operation, KO will set the form element&amp;rsquo;s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it&amp;rsquo;s a one-time-only value setter, not an ongoing binding that reacts to changes.</source>
          <target state="translated">Si hace referencia a algo que &lt;em&gt;no&lt;/em&gt; es una propiedad simple, por ejemplo, el resultado de una llamada a una funci&amp;oacute;n o una operaci&amp;oacute;n de comparaci&amp;oacute;n, KO establecer&amp;aacute; el estado inicial del elemento del formulario en ese valor, pero no podr&amp;aacute; volver a escribir ning&amp;uacute;n cambio cuando el usuario edite el elemento de formulario. En este caso, es un establecedor de valor de una sola vez, no un enlace continuo que reacciona a los cambios.</target>
        </trans-unit>
        <trans-unit id="4136055364963301ac3a0672768006e0b60b4010" translate="yes" xml:space="preserve">
          <source>If you set the viewmodel property to true or false, the associated element will become focused or unfocused.</source>
          <target state="translated">Si establece la propiedad viewmodel en verdadero o falso,el elemento asociado se enfocará o desenfocará.</target>
        </trans-unit>
        <trans-unit id="b04308191c20dd0438d23903c6a2d68567c5dfe6" translate="yes" xml:space="preserve">
          <source>If you specify bindings without a value, Knockout will give the binding an undefined value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea10c506e67e02d37f3ff59d06b553132c889a0" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()</source>
          <target state="translated">Si proporcionas algo que no sea un número o una cadena (por ejemplo,pasas un objeto o una matriz),el texto mostrado será equivalente a tuParámetro.aCadena()</target>
        </trans-unit>
        <trans-unit id="8f936a4cf3802ef50c0aec5ecfef503f372a0ded" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that&amp;rsquo;s usually not very useful, so it&amp;rsquo;s best to supply string or numeric values).</source>
          <target state="translated">Si proporciona algo que no sea un n&amp;uacute;mero o una cadena (por ejemplo, pasa un objeto o una matriz), el texto mostrado ser&amp;aacute; equivalente a yourParameter.toString () (que generalmente no es muy &amp;uacute;til, por lo que es mejor proporcionar cadenas o n&amp;uacute;meros valores).</target>
        </trans-unit>
        <trans-unit id="33531730aa65cc0aed58be0f106c04649fd218ba" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()</source>
          <target state="translated">Si proporcionas algo que no sea un número o una cadena (por ejemplo,pasas un objeto o una matriz),el innerHTML será equivalente a tuParámetro.aCadena()</target>
        </trans-unit>
        <trans-unit id="d0c67876e2d6e6a962ee02ea3bfd2bc8d147be3f" translate="yes" xml:space="preserve">
          <source>If you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose &lt;em&gt;not&lt;/em&gt; to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:</source>
          <target state="translated">Si tiende a filtrar mucho las matrices observables, agregar un filterByProperty globalmente a todas las matrices observables podr&amp;iacute;a hacer que su c&amp;oacute;digo sea m&amp;aacute;s ordenado. Pero si solo necesita filtrar ocasionalmente, puede optar por &lt;em&gt;no&lt;/em&gt; adjuntar a ko.observableArray.fn y, en su lugar, simplemente construir doneTasks a mano de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="e10e3c94b35fd8632dab2ca5d675651a6b4f0bb0" translate="yes" xml:space="preserve">
          <source>If you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</source>
          <target state="translated">Si se utiliza el valor para vincular un elemento de forma a una propiedad observable,el KO es capaz de establecer una vinculación de dos vías para que los cambios en cualquiera de ellas afecten a la otra.</target>
        </trans-unit>
        <trans-unit id="e93054a2d66f23c13f6c50afc30a17cac10665b4" translate="yes" xml:space="preserve">
          <source>If you want Knockout to allow your model property to take values that have no corresponding entry in your &amp;lt;select&amp;gt; element (and display this by making the &amp;lt;select&amp;gt; element blank), then see &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentation for valueAllowUnset&lt;/a&gt;.</source>
          <target state="translated">Si desea que Knockout permita que la propiedad de su modelo tome valores que no tienen una entrada correspondiente en su elemento &amp;lt;select&amp;gt; (y muestre esto dejando el elemento &amp;lt;select&amp;gt; en blanco), entonces consulte la &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentaci&amp;oacute;n de valueAllowUnset&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a89bcaf9d5696bd11fb99d2d58e919ab34e4a21" translate="yes" xml:space="preserve">
          <source>If you want a custom binding to be usable with Knockout&amp;rsquo;s &lt;em&gt;virtual elements&lt;/em&gt; syntax, e.g.:</source>
          <target state="translated">Si desea que un enlace personalizado se pueda utilizar con la sintaxis de &lt;em&gt;elementos virtuales&lt;/em&gt; de Knockout , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="12de6cba1d2b34cbb4e79120d38a72eb8f87f4f5" translate="yes" xml:space="preserve">
          <source>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</source>
          <target state="translated">Si desea que todas las instancias de su componente compartan la misma instancia de objeto de vista (lo cual no suele ser deseable):</target>
        </trans-unit>
        <trans-unit id="2f370654b97f0f29acfaf8c9f3cbd1053b47dfd4" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:</source>
          <target state="translated">Si quieres el equivalente a una encuadernación de un frente,pero usando una plantilla con nombre,puedes hacerlo de forma natural:</target>
        </trans-unit>
        <trans-unit id="e0687bb9af427b875127182534a1eca56e0d6596" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</source>
          <target state="translated">Si quieres que el plugin de mapeo ignore algunas propiedades de tu objeto JS (es decir,que no las mapee),puedes especificar una serie de nombres de propiedades para ignorar:</target>
        </trans-unit>
        <trans-unit id="48877e0877c23be66516c571a7f2f9808b04bbbc" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</source>
          <target state="translated">Si quieres que el plugin de mapeo sólo cree observables de algunas propiedades de tu objeto JS y copie el resto,puedes especificar una serie de nombres de propiedades para observar:</target>
        </trans-unit>
        <trans-unit id="1a610cb362a9cb355f038caa3483260b1682b467" translate="yes" xml:space="preserve">
          <source>If you want to access data/functions from parent binding contexts, you can use &lt;a href=&quot;binding-context&quot;&gt;special context properties such as $parent and $root&lt;/a&gt;.</source>
          <target state="translated">Si desea acceder a datos / funciones desde contextos de enlace padre, puede usar &lt;a href=&quot;binding-context&quot;&gt;propiedades de contexto especiales como $ parent y $ root&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5e8a9598e8913d6b161a0231caddfc4c3d6385d" translate="yes" xml:space="preserve">
          <source>If you want to apply a font-weight or text-decoration style, or any other style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the &lt;em&gt;JavaScript name&lt;/em&gt; for that style. For example,</source>
          <target state="translated">Si desea aplicar un estilo de decoraci&amp;oacute;n de texto o de peso de fuente, o cualquier otro estilo cuyo nombre no sea un identificador JavaScript legal (por ejemplo, porque contiene un gui&amp;oacute;n), debe usar el &lt;em&gt;nombre JavaScript&lt;/em&gt; para ese estilo. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="42a04b9a7a064c9209637e25fdea69c9c72b38f4" translate="yes" xml:space="preserve">
          <source>If you want to apply a style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you can either put it in quotes or use the JavaScript name for that style. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a7840c3566eba919210c187885f629cdea7e6" translate="yes" xml:space="preserve">
          <source>If you want to apply the CSS class my-class, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">Si desea aplicar la clase CSS my-class, no &lt;em&gt;puede&lt;/em&gt; escribir esto:</target>
        </trans-unit>
        <trans-unit id="400ea2089a975a1be517a84a31ee89203ffb5ce6" translate="yes" xml:space="preserve">
          <source>If you want to apply the attribute data-something, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">Si desea aplicar el atributo data-something, no &lt;em&gt;puede&lt;/em&gt; escribir esto:</target>
        </trans-unit>
        <trans-unit id="926dd1aabde3cc388fd5f78c44f8b0dc656ffe88" translate="yes" xml:space="preserve">
          <source>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</source>
          <target state="translated">Si desea que se le notifique el valor de un observable antes de que esté a punto de ser modificado,puede suscribirse al evento beforeChange.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4dc22f6555d4554142d875304efe0f5c3fb52625" translate="yes" xml:space="preserve">
          <source>If you want to change the policy for a particular component, you can specify synchronous: true on that component&amp;rsquo;s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you&amp;rsquo;re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.</source>
          <target state="translated">Si desea cambiar la pol&amp;iacute;tica de un componente en particular, puede especificar sincr&amp;oacute;nico: verdadero en la configuraci&amp;oacute;n de ese componente. Luego, podr&amp;iacute;a cargar de forma asincr&amp;oacute;nica en el primer uso, seguido de forma s&amp;iacute;ncrona en todos los usos posteriores. Si hace esto, debe tener en cuenta este comportamiento cambiante en cualquier c&amp;oacute;digo que espera a que se carguen los componentes. Sin embargo, si su componente siempre se puede cargar e inicializar de forma s&amp;iacute;ncrona, habilitar esta opci&amp;oacute;n garantizar&amp;aacute; un comportamiento sincr&amp;oacute;nico coherente. Esto puede ser importante si est&amp;aacute; utilizando un componente dentro de un enlace foreach y desea utilizar las opciones afterAdd o afterRender para realizar el posprocesamiento.</target>
        </trans-unit>
        <trans-unit id="5d46531ca9799ade7ca26f1bed17707b4876bd54" translate="yes" xml:space="preserve">
          <source>If you want to convert your mapped object back to a regular JS object, use:</source>
          <target state="translated">Si quieres convertir tu objeto mapeado de nuevo en un objeto JS normal,usa:</target>
        </trans-unit>
        <trans-unit id="20972324a8ac6446023da390397678c0423402dd" translate="yes" xml:space="preserve">
          <source>If you want to detect and respond to changes on one object, you&amp;rsquo;d use &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;. If you want to detect and respond to changes of a &lt;em&gt;collection of things&lt;/em&gt;, use an observableArray. This is useful in many scenarios where you&amp;rsquo;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</source>
          <target state="translated">Si desea detectar y responder a cambios en un objeto, usar&amp;iacute;a &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt; . Si desea detectar y responder a los cambios de una &lt;em&gt;colecci&amp;oacute;n de cosas&lt;/em&gt; , use un observableArray. Esto es &amp;uacute;til en muchos escenarios en los que muestra o edita varios valores y necesita secciones repetidas de la interfaz de usuario para que aparezcan y desaparezcan a medida que se agregan y eliminan elementos.</target>
        </trans-unit>
        <trans-unit id="5dbe5851856488928c88861ca66a429c2a8a54c3" translate="yes" xml:space="preserve">
          <source>If you want to detemine text programmatically, one option is to create a &lt;a href=&quot;computedobservables&quot;&gt;computed observable&lt;/a&gt;, and use its evaluator function as a place for your code that works out what text to display.</source>
          <target state="translated">Si desea detectar texto mediante programaci&amp;oacute;n, una opci&amp;oacute;n es crear un &lt;a href=&quot;computedobservables&quot;&gt;observable calculado&lt;/a&gt; y usar su funci&amp;oacute;n de evaluador como un lugar para su c&amp;oacute;digo que determina qu&amp;eacute; texto mostrar.</target>
        </trans-unit>
        <trans-unit id="a0e5d4f6f665f1af91a7e87e9210302dace1de3d" translate="yes" xml:space="preserve">
          <source>If you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,</source>
          <target state="translated">Si quieres hacer esto en encuadernaciones personalizadas,entonces en lugar de usar bindingContext.extend(),usa bindingContext.createChildContext(someData).Esto devuelve un nuevo contexto de enlace cuyo modelo de vista es someData y cuyo $parentContext es bindingContext.Si quieres,puedes extender el contexto hijo con propiedades extra usando ko.utils.extend.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="87af9ca294d83f6fba572d78050da057a49b8c89" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:</source>
          <target state="translated">Si desea asegurarse de que los suscriptores sean notificados siempre de una actualización,incluso si el valor es el mismo,utilizaría el extensor de notificación además de rateLimit:</target>
        </trans-unit>
        <trans-unit id="44cdfd3b6064088d2c5aa5fc20d93a5155c03685" translate="yes" xml:space="preserve">
          <source>If you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</source>
          <target state="translated">Si quieres encargarte de una parte del mapeo tú mismo,también puedes proporcionar una llamada de creación.Si esta llamada está presente,el plugin de mapeo le permitirá hacer esta parte del mapeo usted mismo.</target>
        </trans-unit>
        <trans-unit id="72b1f64bd3585abcdb719c6af16ba28b06cb4a0c" translate="yes" xml:space="preserve">
          <source>If you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,</source>
          <target state="translated">Si quieres tener diferentes nombres de etiqueta de elementos personalizados,puedes anular getComponentNameForNode para controlar esto.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f48f247482677e3d298eb9f8794c7720f2d28823" translate="yes" xml:space="preserve">
          <source>If you want to map the children array yourself, you can specify that like this:</source>
          <target state="translated">Si quieres mapear la matriz de niños tú mismo,puedes especificarlo así:</target>
        </trans-unit>
        <trans-unit id="1351e5f77b9081488d46eb8f548df93a34b7ae41" translate="yes" xml:space="preserve">
          <source>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</source>
          <target state="translated">Si desea ejecutar cualquier lógica de configuración en el elemento asociado antes de que se vincule al modelo de vista,o utilizar la lógica arbitraria para decidir qué clase de modelo de vista se debe instanciar:</target>
        </trans-unit>
        <trans-unit id="c66df88a215f6f7b24bd3deee59aec7e6d2e2f59" translate="yes" xml:space="preserve">
          <source>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable&amp;rsquo;s new value.</source>
          <target state="translated">Si desea utilizar nombres de clases de CSS din&amp;aacute;micos, puede pasar una cadena que corresponda a la clase o clases de CSS que desea agregar al elemento. Si el par&amp;aacute;metro hace referencia a un valor observable, entonces el enlace eliminar&amp;aacute; las clases agregadas previamente y agregar&amp;aacute; la clase o clases correspondientes al nuevo valor del observable.</target>
        </trans-unit>
        <trans-unit id="6d39bf93c568ed46321d7833a330f6569b221b30" translate="yes" xml:space="preserve">
          <source>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the &lt;em&gt;beginning&lt;/em&gt; of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the &lt;em&gt;end&lt;/em&gt; of the array.</source>
          <target state="translated">Si desea que su cargador personalizado tenga prioridad sobre el cargador predeterminado (para que tenga la primera oportunidad de proporcionar configuraci&amp;oacute;n / valores), agr&amp;eacute;guelo al &lt;em&gt;principio&lt;/em&gt; de la matriz. Si desea que el cargador predeterminado tenga prioridad (por lo que su cargador personalizado solo se llama para componentes no registrados expl&amp;iacute;citamente), agr&amp;eacute;guelo al &lt;em&gt;final&lt;/em&gt; de la matriz.</target>
        </trans-unit>
        <trans-unit id="5ceafe6c0f244a6b62bf46e8591b041a309c0459" translate="yes" xml:space="preserve">
          <source>If you want your observable array &lt;strong&gt;not&lt;/strong&gt; to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</source>
          <target state="translated">Si desea que su matriz observable &lt;strong&gt;no&lt;/strong&gt; comience vac&amp;iacute;a, sino que contenga algunos elementos iniciales, pase esos elementos como una matriz al constructor. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="e61100d48bd38e328d61f92193723be823f648bd" translate="yes" xml:space="preserve">
          <source>If you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; as follows:</source>
          <target state="translated">Si lo desea, puede usar $ data como prefijo al hacer referencia a las propiedades en cada entrada. Por ejemplo, podr&amp;iacute;a reescribir parte del &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Ejemplo 1 de la&lt;/a&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="1d0c200b210145556f08539e16369c8ae1101651" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:</source>
          <target state="translated">Si desea poder vincular expresiones a eventos de clic (en lugar de una referencia de funci&amp;oacute;n como espera Knockout), puede configurar un preprocesador para que el controlador de clic admita esta sintaxis:</target>
        </trans-unit>
        <trans-unit id="907374589d9e730eb5f8d2c95837b3f35a14d2f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.</source>
          <target state="translated">Si desea migrar el c&amp;oacute;digo desde el uso del extensor de aceleraci&amp;oacute;n obsoleto, debe tener en cuenta las siguientes formas en las que el extensor rateLimit es diferente del extensor de aceleraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82cf070f85ee99e13abeb8d98714402eb45540b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:</source>
          <target state="translated">Si est&amp;aacute; creando configuraciones mediante programaci&amp;oacute;n y tiene un objeto DocumentFragment, puede usarlo como plantilla de componente:</target>
        </trans-unit>
        <trans-unit id="362388121008c8da14509414fa3107e12b516595" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</source>
          <target state="translated">Si est&amp;aacute; creando configuraciones mediante programaci&amp;oacute;n y tiene una matriz de nodos DOM, puede usarlos como plantilla de componente:</target>
        </trans-unit>
        <trans-unit id="e5fbe4f70abc50527b7288b53aa01cad2d4a9fe8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re inside a nested &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, for example if you&amp;rsquo;re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you&amp;rsquo;ll need to use a prefix such as $parent or $root to locate the handler function.</source>
          <target state="translated">Si est&amp;aacute; dentro de un &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; anidado , por ejemplo, si est&amp;aacute; dentro de un foreach o un bloque with, pero su funci&amp;oacute;n de controlador est&amp;aacute; en el modelo de vista ra&amp;iacute;z o en alg&amp;uacute;n otro contexto principal, deber&amp;aacute; usar un prefijo como $ parent o $ root para localizar la funci&amp;oacute;n del controlador.</target>
        </trans-unit>
        <trans-unit id="b30aa6dd1b7b726ed22a1386408193b3ed07cc63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not a fan of the &amp;lt;%= ... %&amp;gt; delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</source>
          <target state="translated">Si no eres fan&amp;aacute;tico de los delimitadores &amp;lt;% = ...%&amp;gt;, puedes configurar el motor de plantilla de subrayado para usar cualquier otro car&amp;aacute;cter delimitador de tu elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="128a03e2b47df3a4720a787432ce69b6c26af34a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $component refers to the viewmodel for that component. It&amp;rsquo;s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.</source>
          <target state="translated">Si est&amp;aacute; dentro del contexto de una plantilla de &lt;a href=&quot;component-overview&quot;&gt;componente en&lt;/a&gt; particular , entonces $ componente se refiere al modelo de vista de ese componente. Es el equivalente espec&amp;iacute;fico del componente a $ root. En el caso de componentes anidados, $ componente se refiere al modelo de vista del componente m&amp;aacute;s cercano.</target>
        </trans-unit>
        <trans-unit id="8207088fe6ea022be6846a6dde93cdfdbb4659e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; dentro del contexto de una plantilla de &lt;a href=&quot;component-overview&quot;&gt;componente en&lt;/a&gt; particular , $ componentTemplateNodes es una matriz que contiene los nodos DOM que se pasaron a ese componente. Esto facilita la creaci&amp;oacute;n de componentes que reciben plantillas, por ejemplo, un componente de cuadr&amp;iacute;cula que acepta una plantilla para definir sus filas de salida. Para obtener un ejemplo completo, consulte &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;pasar el marcado a los componentes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50cd6a8b962993f971b8353a9f4567faa0ee548a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working with AMD, then you might prefer a structure like this:</source>
          <target state="translated">Si est&amp;aacute; trabajando con AMD, es posible que prefiera una estructura como esta:</target>
        </trans-unit>
        <trans-unit id="3d7b9ced2efd23f656198e4a25fb4db243307f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</source>
          <target state="translated">Si ha cargado algunos datos del servidor y desea usarlos para actualizar su modelo de vista, la forma m&amp;aacute;s sencilla es hacerlo usted mismo. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="bf20ec3aaef79dcc3c3e98b605cfa93d5c521bb6" translate="yes" xml:space="preserve">
          <source>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.</source>
          <target state="translated">Si tu llamada a Ajax devuelve una cadena JSON (y no la deserializa en un objeto JavaScript),entonces puedes usar la función ko.mapping.fromJSON para crear y actualizar tu modelo de vista en su lugar.Para desmapear,puedes usar ko.mapping.toJSON.</target>
        </trans-unit>
        <trans-unit id="b44f19840a62453340adc3a1ccb826f912401798" translate="yes" xml:space="preserve">
          <source>If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:</source>
          <target state="translated">Si su vinculación también incluye un parámetro llamado valueUpdate,esto define los eventos adicionales del navegador que KO debe usar para detectar cambios además del evento de cambio.Los siguientes valores de cadena son las opciones más útiles:</target>
        </trans-unit>
        <trans-unit id="d155bf9b29c1f0a2a9418e2feadc2ccfa15452dc" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</source>
          <target state="translated">Si su enlace tambi&amp;eacute;n incluye checkValue, esto define el valor utilizado por el enlace verificado en lugar del atributo de valor del elemento. Esto es &amp;uacute;til si desea que el valor sea algo diferente a una cadena (como un n&amp;uacute;mero entero o un objeto), o desea que el valor se establezca din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="b3ab84e69e9a2c18e82003929561e37ee4fbb1d3" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically. For normally boolean checkboxes, this value is used instead of true to represent the &lt;em&gt;checked&lt;/em&gt; state, with undefined used for the &lt;em&gt;unchecked&lt;/em&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d14bdc74a8da6a89453d8ef51d2e2cc6ebf79fa" translate="yes" xml:space="preserve">
          <source>If your binding uses a preprocess function but should still have undefined as a default value, the function should return the string &quot;undefined&quot; rather than an undefined value. Returning undefined will remove the binding instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588138852c7a0d26f567881e0157a12d1880b4b0" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes bound to an array, it will remove the previous value from the array and add the new value. Otherwise, it will just update the model value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10fa5bcf76b5721cd82848b0bb414540b34d62f" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</source>
          <target state="translated">Si su parámetro checkedValue es un valor observable,siempre que el valor cambie y el elemento esté actualmente comprobado,el enlace actualizará la propiedad del modelo comprobado.En el caso de las casillas de verificación,eliminará el valor antiguo de la matriz y añadirá el nuevo valor.Para los botones de radio,sólo actualizará el valor del modelo.</target>
        </trans-unit>
        <trans-unit id="1dbc2f2301ffac98a49b2e6297ccb2fb1e2c8d49" translate="yes" xml:space="preserve">
          <source>If your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,</source>
          <target state="translated">Si la configuración del componente tiene una propiedad booleana síncrona,Knockout la utiliza para determinar si se permite cargar e inyectar el componente de forma síncrona.El valor predeterminado es falso (es decir,forzado a ser asíncrono).Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="b9854050320055febc419828d11cb1650e59a3b0" translate="yes" xml:space="preserve">
          <source>If your computed observable simply calculates and returns a value based on some observable dependencies, then it&amp;rsquo;s better to declare it as a ko.pureComputed instead of a ko.computed. For example:</source>
          <target state="translated">Si su observable calculado simplemente calcula y devuelve un valor basado en algunas dependencias observables, entonces es mejor declararlo como ko.pureComputed en lugar de ko.computed. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f07feff737da55640367588cd5b8867853add3d9" translate="yes" xml:space="preserve">
          <source>If your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</source>
          <target state="translated">Si su cargador personalizado implementa loadTemplate y/o loadViewModel,entonces puede conectar el código personalizado al proceso de carga.También puede utilizar estas funciones para interpretar los formatos de configuración personalizados.</target>
        </trans-unit>
        <trans-unit id="f9e85383888aee26e47a33473edbdb8e84955e5a" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="translated">Si su expresi&amp;oacute;n incluye valores observables, la expresi&amp;oacute;n se volver&amp;aacute; a evaluar siempre que cambie alguno de ellos. En consecuencia, el marcado dentro de su bloque if puede agregarse o eliminarse din&amp;aacute;micamente como resultado de los cambios de expresi&amp;oacute;n. Los atributos de enlace de datos se aplicar&amp;aacute;n a &lt;strong&gt;una nueva copia del marcado contenido&lt;/strong&gt; cada vez que se vuelva a agregar.</target>
        </trans-unit>
        <trans-unit id="8e661a6c7ed635e0bf691bba88868184d5c21e24" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if or ifnot block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226676b80f71bd0aee4405b7dbac5960cfd4e3e7" translate="yes" xml:space="preserve">
          <source>If your function accepts a second parameter, then it will receive the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. You can then access $parent or any other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</source>
          <target state="translated">Si su funci&amp;oacute;n acepta un segundo par&amp;aacute;metro, recibir&amp;aacute; todo el &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; . A continuaci&amp;oacute;n, puede acceder a $ parent o cualquier otra variable de &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; al elegir din&amp;aacute;micamente una plantilla. Por ejemplo, puede modificar el fragmento de c&amp;oacute;digo anterior de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="9b4eec9f8db27a16ed532421672ba7179cce19f2" translate="yes" xml:space="preserve">
          <source>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</source>
          <target state="translated">Si su función hace referencia a valores observables,entonces la encuadernación se actualizará siempre que cambie alguno de esos valores.Esto hará que los datos se vuelvan a representar utilizando la plantilla apropiada.</target>
        </trans-unit>
        <trans-unit id="6374db41fb1a34f6794e3a7a263b2a5d8f3d6ae6" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable array, the binding will update the element&amp;rsquo;s selection whenever the array changes (e.g., via push, pop or &lt;a href=&quot;observablearrays&quot;&gt;other observable array methods&lt;/a&gt;). If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s selection state once and will not update it again later.</source>
          <target state="translated">Si su par&amp;aacute;metro es una matriz observable, el enlace actualizar&amp;aacute; la selecci&amp;oacute;n del elemento siempre que la matriz cambie (por ejemplo, mediante push, pop u &lt;a href=&quot;observablearrays&quot;&gt;otros m&amp;eacute;todos de matriz observables&lt;/a&gt; ). Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el estado de selecci&amp;oacute;n del elemento una vez y no lo actualizar&amp;aacute; nuevamente m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="4ddb383dfae6006d12773bd8bc5511d587b2ccb9" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable value, the binding will update the element&amp;rsquo;s checked state whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s checked state once and will not update it again later.</source>
          <target state="translated">Si su par&amp;aacute;metro es un valor observable, el enlace actualizar&amp;aacute; el estado verificado del elemento cada vez que cambie el valor. Si el par&amp;aacute;metro no es observable, solo establecer&amp;aacute; el estado verificado del elemento una vez y no lo actualizar&amp;aacute; nuevamente m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="1fff36bdc6055d9bb8992e0fdfb26a189710fb02" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later.</source>
          <target state="translated">Si su par&amp;aacute;metro hace referencia a un valor observable, el enlace agregar&amp;aacute; o eliminar&amp;aacute; la clase CSS siempre que cambie el valor observable. Si el par&amp;aacute;metro no hace referencia a un valor observable, solo agregar&amp;aacute; o eliminar&amp;aacute; la clase una vez y no lo volver&amp;aacute; a hacer m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="aa6f113eec157fdb2ab367ee2fd9cbd80ddb0996" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the attribute once and will not update it later.</source>
          <target state="translated">Si su par&amp;aacute;metro hace referencia a un valor observable, el enlace actualizar&amp;aacute; el atributo siempre que cambie el valor observable. Si el par&amp;aacute;metro no hace referencia a un valor observable, solo establecer&amp;aacute; el atributo una vez y no lo actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="633f858df401ebd55c78f8496da63fdb61af5458" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the state once and will not do so again later.</source>
          <target state="translated">Si su par&amp;aacute;metro hace referencia a un valor observable, el enlace actualizar&amp;aacute; el estado habilitado / deshabilitado siempre que cambie el valor observable. Si el par&amp;aacute;metro no hace referencia a un valor observable, solo establecer&amp;aacute; el estado una vez y no lo volver&amp;aacute; a hacer m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="6d3819bd4ed3fd60e94476b444ece0ada882cf49" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the styles once and will not update them later.</source>
          <target state="translated">Si su par&amp;aacute;metro hace referencia a un valor observable, el enlace actualizar&amp;aacute; los estilos siempre que cambie el valor observable. Si el par&amp;aacute;metro no hace referencia a un valor observable, solo establecer&amp;aacute; los estilos una vez y no los actualizar&amp;aacute; m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="d9c0408c9bf4c4a37030fc7cdecf2361bd78f581" translate="yes" xml:space="preserve">
          <source>If your parameter&amp;rsquo;s value is an array of strings, you don&amp;rsquo;t need to give any other parameters. The &amp;lt;select&amp;gt; element will display an option for each string value. However, if you want to let the user choose from an array of &lt;em&gt;arbitrary JavaScript objects&lt;/em&gt; (not merely strings), then see the optionsText and optionsValue parameters below.</source>
          <target state="translated">Si el valor de su par&amp;aacute;metro es una matriz de cadenas, no necesita proporcionar ning&amp;uacute;n otro par&amp;aacute;metro. El elemento &amp;lt;select&amp;gt; mostrar&amp;aacute; una opci&amp;oacute;n para cada valor de cadena. Sin embargo, si desea permitir que el usuario elija entre una matriz de &lt;em&gt;objetos JavaScript arbitrarios&lt;/em&gt; (no simplemente cadenas), consulte los par&amp;aacute;metros optionsText y optionsValue a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a69077a26824bf6bf1d9998d4bf4a08fe6a1767d" translate="yes" xml:space="preserve">
          <source>If, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,</source>
          <target state="translated">Si,como en el ejemplo anterior,usted está realizando la cartografía dentro de una clase,le gustaría tener esto como objetivo de su operación de cartografía.El tercer parámetro de ko.mapping.fromJS indica el objetivo.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="9ee772074f2af1d7a8aaad138b9ed8cf1f46dbbc" translate="yes" xml:space="preserve">
          <source>Ignoring certain properties using &amp;ldquo;ignore&amp;rdquo;</source>
          <target state="translated">Ignorar determinadas propiedades mediante &quot;ignorar&quot;</target>
        </trans-unit>
        <trans-unit id="862cab77807ae3aed03ab6e5350848a0245d7862" translate="yes" xml:space="preserve">
          <source>Ignoring dependencies within a computed</source>
          <target state="translated">Ignorando las dependencias dentro de una</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="e98d0b401da7a27f72e4030036db78a4058a43b6" translate="yes" xml:space="preserve">
          <source>Implementing a custom component loader</source>
          <target state="translated">Implementación de un cargador de componentes personalizado</target>
        </trans-unit>
        <trans-unit id="9e1f2cc17fbee96463fbddbcea3b554850c3baa9" translate="yes" xml:space="preserve">
          <source>In a binding&amp;rsquo;s init function, using a computed observable to update the bound element.</source>
          <target state="translated">En la funci&amp;oacute;n de inicio de un enlace, el uso de un observable calculado para actualizar el elemento enlazado.</target>
        </trans-unit>
        <trans-unit id="a6abb210083356c831fde074a2c122126ad2030b" translate="yes" xml:space="preserve">
          <source>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; binding or via control-flow bindings (&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;, &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</source>
          <target state="translated">En una aplicaci&amp;oacute;n Knockout t&amp;iacute;pica, los elementos DOM se agregan y eliminan din&amp;aacute;micamente, por ejemplo, utilizando el enlace de &lt;a href=&quot;template-binding&quot;&gt;plantilla&lt;/a&gt; o mediante enlaces de flujo de control ( &lt;a href=&quot;if-binding&quot;&gt;si&lt;/a&gt; , si &lt;a href=&quot;ifnot-binding&quot;&gt;no&lt;/a&gt; , &lt;a href=&quot;with-binding&quot;&gt;con&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; ). Al crear un enlace personalizado, a menudo es conveniente agregar una l&amp;oacute;gica de limpieza que se ejecuta cuando Knockout elimina un elemento asociado con su enlace personalizado.</target>
        </trans-unit>
        <trans-unit id="141b57414e301727c0b0d54cb5649b30de0602c3" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re wondering what the parameters to ko.applyBindings do,</source>
          <target state="translated">En caso de que se est&amp;eacute; preguntando qu&amp;eacute; hacen los par&amp;aacute;metros para ko.applyBindings,</target>
        </trans-unit>
        <trans-unit id="934ed4b9942e197c4b326248bae145be6b363266" translate="yes" xml:space="preserve">
          <source>In complex applications, with multiple, intertwined dependencies, updating a single &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; might trigger a cascade of &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;) can have a similar effect.</source>
          <target state="translated">En aplicaciones complejas, con m&amp;uacute;ltiples dependencias entrelazadas, la actualizaci&amp;oacute;n de un solo &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; puede desencadenar una cascada de &lt;a href=&quot;computedobservables&quot;&gt;observables calculados&lt;/a&gt; , suscripciones manuales y actualizaciones de enlaces de IU. Estas actualizaciones pueden ser costosas e ineficientes si se env&amp;iacute;an a la vista valores intermedios innecesarios o si resultan en evaluaciones observables calculadas adicionales. Incluso en una aplicaci&amp;oacute;n simple, actualizar observables relacionados o un solo observable varias veces (como llenar una &lt;a href=&quot;observablearrays&quot;&gt;matriz observable&lt;/a&gt; ) puede tener un efecto similar.</target>
        </trans-unit>
        <trans-unit id="298a4f1f3d69231f90369b88842f87a3f201c02d" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</source>
          <target state="translated">En general, si la evaluaci&amp;oacute;n de un par&amp;aacute;metro no implica evaluar un observable (en este caso, el observable simplemente se pas&amp;oacute; sin evaluarlo), entonces el valor se pasa literalmente.</target>
        </trans-unit>
        <trans-unit id="9fea9cada35fecd5a76c1bf34c364291fb1dfeb5" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it&amp;rsquo;s not observable the parent would not know the child had done so.</source>
          <target state="translated">En general, si la evaluaci&amp;oacute;n de un par&amp;aacute;metro no involucra la evaluaci&amp;oacute;n de un observable (en este caso, el valor no involucr&amp;oacute; observables en absoluto), entonces el valor se pasa literalmente. Si el valor fuera un objeto, entonces el componente hijo podr&amp;iacute;a mutarlo, pero como no es observable, el padre no sabr&amp;iacute;a que el hijo lo hab&amp;iacute;a hecho.</target>
        </trans-unit>
        <trans-unit id="9408b29fab575c1d6a718e0d164b10b2342550d4" translate="yes" xml:space="preserve">
          <source>In general, with custom elements, if a parameter&amp;rsquo;s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression&amp;rsquo;s result, and supplies that to the component.</source>
          <target state="translated">En general, con elementos personalizados, si la evaluaci&amp;oacute;n de un par&amp;aacute;metro implica evaluar un observable, Knockout construye autom&amp;aacute;ticamente un valor calculado para dar el resultado de la expresi&amp;oacute;n y lo proporciona al componente.</target>
        </trans-unit>
        <trans-unit id="dada114537b3d8ec4d940c1f848a0b4d17e427dd" translate="yes" xml:space="preserve">
          <source>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</source>
          <target state="translated">En muchos escenarios,este enfoque directo es la solución más simple y flexible.Por supuesto,a medida que actualice las propiedades en su modelo de vista,Knockout se encargará de actualizar la interfaz de usuario visible para que coincida con ella.</target>
        </trans-unit>
        <trans-unit id="1336d55dbbe8a14101718dce289bfc08355c43e3" translate="yes" xml:space="preserve">
          <source>In most applications, you&amp;rsquo;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</source>
          <target state="translated">En la mayor&amp;iacute;a de las aplicaciones, querr&amp;aacute; mantener los modelos y plantillas de vista de componentes en archivos externos. Si configura Knockout para obtenerlos a trav&amp;eacute;s de un cargador de m&amp;oacute;dulos AMD como &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; , entonces se pueden precargar (posiblemente empaquetar / minificar) o cargar incrementalmente seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="9393d5a40d776a6854af0f2c50bfec273ef93bff" translate="yes" xml:space="preserve">
          <source>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</source>
          <target state="translated">En la mayoría de los casos,los atributos de unión de datos proporcionan una forma limpia y sucinta de unirse a un modelo de vista.Sin embargo,el manejo de eventos es una esfera que a menudo puede dar lugar a atributos verbosos de enlace de datos,ya que las funciones anónimas solían ser la técnica recomendada para transmitir argumentos.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e51abc57c35dadaabfdce19179eb0debbebbeaf7" translate="yes" xml:space="preserve">
          <source>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</source>
          <target state="translated">En los navegadores más antiguos (ie8 e inferiores)el uso de palabras reservadas de javascript como nombres de atributos causa un error.Puedes evitarlo citándolas así:</target>
        </trans-unit>
        <trans-unit id="78c97a2a9b619f6af8e28ca3d1b212c9106b36d9" translate="yes" xml:space="preserve">
          <source>In some cases, you might want to duplicate a section of markup, but you don&amp;rsquo;t have any container element on which to put a foreach binding. For example, you might want to generate the following:</source>
          <target state="translated">En algunos casos, es posible que desee duplicar una secci&amp;oacute;n de marcado, pero no tiene ning&amp;uacute;n elemento contenedor en el que colocar un enlace foreach. Por ejemplo, es posible que desee generar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="24cb80dcb3e226fb881227f4a0ccddef514b98a4" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</source>
          <target state="translated">En algunos escenarios,es útil determinar programáticamente si se trata de un observable computarizado.Knockout proporciona una función de utilidad,ko.isComputado para ayudar en esta situación.Por ejemplo,podrías querer excluir los observables computarizados de los datos que estás enviando al servidor.</target>
        </trans-unit>
        <trans-unit id="6e3b5296e5cf5300764dcbb83ced0ab56bb3f938" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</source>
          <target state="translated">En algunos escenarios,es útil determinar programáticamente si se trata de un observable puro computarizado.Knockout proporciona una función de utilidad,ko.isPureComputado para ayudar en esta situación.Por ejemplo,podrías querer excluir los observables no computados puros de los datos que estás enviando al servidor.</target>
        </trans-unit>
        <trans-unit id="f78cb94e8b3d800b2ea0fcaad4990a5f1a56de28" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b0b573c69ea5aac246a77f09332e0af893398" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">En algunos escenarios,es posible que necesite acceder al objeto de evento DOM asociado con su evento de clic.El knockout pasará el evento como el segundo parámetro de tu función,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="89a035bdd8bde1fc808e15cc5a03eb180ed46c10" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">En algunos escenarios,es posible que necesite acceder al objeto de evento DOM asociado a su evento.Knockout pasará el evento como el segundo parámetro de tu función,como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="8a7c3e36457e6b3964cbe1d0bb7c4a44fc9b6097" translate="yes" xml:space="preserve">
          <source>In summary, the general rule is:</source>
          <target state="translated">En resumen,la regla general es:</target>
        </trans-unit>
        <trans-unit id="7abd619b7fce5ea9d7c5cd5e72650986e1b05fc5" translate="yes" xml:space="preserve">
          <source>In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.</source>
          <target state="translated">En el ejemplo anterior,el país seleccionado conservará el valor &quot;Letonia&quot;,y el desplegable estará en blanco,porque no hay ninguna opción correspondiente.</target>
        </trans-unit>
        <trans-unit id="a079557bbe2fc66148c2ddbfa0077e907128f7e8" translate="yes" xml:space="preserve">
          <source>In the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.</source>
          <target state="translated">En el ejemplo que figura a continuación,se utiliza un observable computarizado para recargar un observable denominado CurrentPageData utilizando Ajax con datos de otras dos propiedades observables.El observable computado se actualizará cada vez que cambie el PageIndex,pero ignora los cambios en el SelectItem porque se accede a él usando peek.En este caso,es posible que el usuario desee utilizar el valor actual de selectedItem sólo con fines de seguimiento cuando se cargue un nuevo conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="257966647233e2e113fd6e59387bdb2e8ee4f13b" translate="yes" xml:space="preserve">
          <source>In the example code above, the user can choose from an array of string values. You&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; for details on how to control how arbitrary objects should be displayed in the list.</source>
          <target state="translated">En el c&amp;oacute;digo de ejemplo anterior, el usuario puede elegir entre una matriz de valores de cadena. Estas &lt;em&gt;no se&lt;/em&gt; limita a proporcionar cadenas - la matriz de opciones puede contener objetos JavaScript arbitrario si lo desea. Consulte &lt;a href=&quot;options-binding&quot;&gt;el enlace de opciones&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo controlar c&amp;oacute;mo se deben mostrar los objetos arbitrarios en la lista.</target>
        </trans-unit>
        <trans-unit id="7f1eec557c11682dd0041b7ee985e305de5b96b1" translate="yes" xml:space="preserve">
          <source>In the following example of a simple wizard interface, the fullName &lt;em&gt;pure&lt;/em&gt; computed is only bound to the view during the final step and so is only updated when that step is active.</source>
          <target state="translated">En el siguiente ejemplo de una interfaz de asistente simple, fullName &lt;em&gt;puro&lt;/em&gt; calculado solo est&amp;aacute; vinculado a la vista durante el paso final y, por lo tanto, solo se actualiza cuando ese paso est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">En el siguiente ejemplo,</target>
        </trans-unit>
        <trans-unit id="e6b59bdb65eb1fb7ea8933f16ea767b69ee4a3eb" translate="yes" xml:space="preserve">
          <source>In the following example, the &amp;lt;div&amp;gt; element will be empty for &amp;ldquo;Mercury&amp;rdquo;, but populated for &amp;ldquo;Earth&amp;rdquo;. That&amp;rsquo;s because Earth has a non-null capital property, whereas &amp;ldquo;Mercury&amp;rdquo; has null for that property.</source>
          <target state="translated">En el siguiente ejemplo, el elemento &amp;lt;div&amp;gt; estar&amp;aacute; vac&amp;iacute;o para &quot;Mercurio&quot;, pero poblado para &quot;Tierra&quot;. Eso es porque la Tierra tiene una propiedad de capital no nula, mientras que &quot;Mercurio&quot; tiene una propiedad nula para esa propiedad.</target>
        </trans-unit>
        <trans-unit id="ea4ef6f441e7c614e804c04b6a2e41d53a3f525d" translate="yes" xml:space="preserve">
          <source>In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:</source>
          <target state="translated">En el siguiente ejemplo,los propios objetos del artículo (no sus cadenas de nombre de artículo)se incluirán en la matriz de artículos elegidos cuando sus casillas de verificación correspondientes estén marcadas:</target>
        </trans-unit>
        <trans-unit id="fd533036ba8a852bee55ce9ff27ce0f5cbea1320" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,</source>
          <target state="translated">En el caso poco probable de que &lt;em&gt;no&lt;/em&gt; desee el desenvolvimiento autom&amp;aacute;tico, porque desea acceder directamente a las instancias observables1 / observables2, puede leer los valores de params. $ Raw. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="82f26ef92fcf3d919b5692d621d24247e24ffdf3" translate="yes" xml:space="preserve">
          <source>In the vast majority of cases, Knockout&amp;rsquo;s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; or &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, Knockout offers a way to do it.</source>
          <target state="translated">En la gran mayor&amp;iacute;a de los casos, las plantillas nativas de Knockout y foreach, if, with y otros enlaces de flujo de control ser&amp;aacute;n todo lo que necesita para construir una interfaz de usuario arbitrariamente sofisticada. Pero en caso de que desee integrarse con una biblioteca de plantillas externa, como el &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;motor de plantillas Underscore&lt;/a&gt; o &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt; , Knockout ofrece una forma de hacerlo.</target>
        </trans-unit>
        <trans-unit id="6089b197798e2998b901eb8dbbf1b20e0c170048" translate="yes" xml:space="preserve">
          <source>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</source>
          <target state="translated">En este caso,todos los nodos especificados (y sus descendientes)serán clonados y concatenados en cada copia del componente que se instale.</target>
        </trans-unit>
        <trans-unit id="a348c38b4b02b07c8665149add553a1e8b9d5d0e" translate="yes" xml:space="preserve">
          <source>In this case, both the required and logChange extenders would be executed against our observable.</source>
          <target state="translated">En este caso,tanto los extensores requeridos como los de logChange se ejecutarían contra nuestro observable.</target>
        </trans-unit>
        <trans-unit id="a699872accd4a004c8e32410cc63d8c1833fccde" translate="yes" xml:space="preserve">
          <source>In this case, the object to which the component&amp;rsquo;s view is bound is the params object that you passed to the component binding. Example:</source>
          <target state="translated">En este caso, el objeto al que est&amp;aacute; vinculada la vista del componente es el objeto params que pas&amp;oacute; al enlace del componente. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="c17fd19412152ec3913a0a1d358a54a8292c9681" translate="yes" xml:space="preserve">
          <source>In this case, you can&amp;rsquo;t put if on the &amp;lt;ul&amp;gt; (because then it would affect the first &amp;lt;li&amp;gt; too), and you can&amp;rsquo;t put any other container around the second &amp;lt;li&amp;gt; (because HTML doesn&amp;rsquo;t allow extra containers within &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">En este caso, no puede poner if en &amp;lt;ul&amp;gt; (porque entonces afectar&amp;iacute;a tambi&amp;eacute;n al primer &amp;lt;li&amp;gt;), y no puede poner ning&amp;uacute;n otro contenedor alrededor del segundo &amp;lt;li&amp;gt; (porque HTML no permitir contenedores adicionales dentro de &amp;lt;ul&amp;gt; s).</target>
        </trans-unit>
        <trans-unit id="4bd55725b74476a658ad8c3ddffc52240205843b" translate="yes" xml:space="preserve">
          <source>In this example, the &amp;ldquo;Your cellphone number&amp;rdquo; text box will initially be disabled. It will be enabled only when the user checks the box labelled &amp;ldquo;I have a cellphone&amp;rdquo;.</source>
          <target state="translated">En este ejemplo, el cuadro de texto &quot;Su n&amp;uacute;mero de tel&amp;eacute;fono celular&quot; estar&amp;aacute; inicialmente deshabilitado. Se habilitar&amp;aacute; solo cuando el usuario marque la casilla denominada &quot;Tengo un tel&amp;eacute;fono celular&quot;.</target>
        </trans-unit>
        <trans-unit id="23b1af26f17b9406ba47b28c79e10c531b381108" translate="yes" xml:space="preserve">
          <source>In this example, the component both displays and edits an observable property called userRating on the Product view model class.</source>
          <target state="translated">En este ejemplo,el componente muestra y edita una propiedad observable llamada userRating en la clase de modelo Product view.</target>
        </trans-unit>
        <trans-unit id="b578fdc737cd1643dadd8aea539b4c2f16e439d0" translate="yes" xml:space="preserve">
          <source>In this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a &amp;lt;script type=&quot;text/html&quot;&amp;gt; &amp;mdash; the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</source>
          <target state="translated">En este ejemplo, el marcado de plantilla de persona se usa dos veces: una para el comprador y otra para el vendedor. Tenga en cuenta que el marcado de la plantilla est&amp;aacute; envuelto en un &amp;lt;script type = &quot;text / html&quot;&amp;gt;: el atributo de tipo ficticio es necesario para garantizar que el marcado no se ejecute como JavaScript, y Knockout no intenta aplicar enlaces a ese marcado excepto cuando se est&amp;aacute; utilizando como plantilla.</target>
        </trans-unit>
        <trans-unit id="4923e8cd2117852530d9802d4bbf382ff3afc82c" translate="yes" xml:space="preserve">
          <source>In this example, there isn&amp;rsquo;t anywhere to put a normal foreach binding. You can&amp;rsquo;t put it on the &amp;lt;ul&amp;gt; (because then you&amp;rsquo;d be duplicating the header item), nor can you put a further container inside the &amp;lt;ul&amp;gt; (because only &amp;lt;li&amp;gt; elements are allowed inside &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">En este ejemplo, no hay ning&amp;uacute;n lugar para colocar un enlace foreach normal. No puede ponerlo en &amp;lt;ul&amp;gt; (porque entonces estar&amp;iacute;a duplicando el elemento de encabezado), ni puede poner un contenedor adicional dentro de &amp;lt;ul&amp;gt; (porque solo se permiten elementos &amp;lt;li&amp;gt; dentro de &amp;lt;ul&amp;gt; s ).</target>
        </trans-unit>
        <trans-unit id="fb736901afba0868e604845ea5c5136b0ef06755" translate="yes" xml:space="preserve">
          <source>In this live example, there&amp;rsquo;s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that&amp;rsquo;s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.</source>
          <target state="translated">En este ejemplo en vivo, hay un valor instant&amp;aacute;neo observable que reacciona inmediatamente cuando presiona una tecla. Esto luego se envuelve dentro de un observable calculado delayedValue que est&amp;aacute; configurado para notificar solo cuando los cambios se detienen durante al menos 400 milisegundos, utilizando el m&amp;eacute;todo de l&amp;iacute;mite de velocidad notifyWhenChangesStop.</target>
        </trans-unit>
        <trans-unit id="697eb6430df1ff767ba12b86170aabf874197762" translate="yes" xml:space="preserve">
          <source>In this scenario, the values you can read and write using selectedOptions are those objects themselves, &lt;em&gt;not&lt;/em&gt; their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</source>
          <target state="translated">En este escenario, los valores que puede leer y escribir usando selectedOptions son esos objetos en s&amp;iacute; mismos, &lt;em&gt;no&lt;/em&gt; sus representaciones textuales. Esto conduce a un c&amp;oacute;digo mucho m&amp;aacute;s limpio y elegante en la mayor&amp;iacute;a de los casos. Su modelo de vista puede imaginar que el usuario elige entre una serie de objetos arbitrarios, sin tener que preocuparse de c&amp;oacute;mo se asignan esos objetos a una representaci&amp;oacute;n en pantalla.</target>
        </trans-unit>
        <trans-unit id="899b5b3c843785e5bdf5e9462999644c6d640741" translate="yes" xml:space="preserve">
          <source>In your viewmodel, it&amp;rsquo;s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.</source>
          <target state="translated">En su modelo de vista, a menudo es &amp;uacute;til declarar self (o alguna otra variable) como un alias para esto. Si lo hace, evita cualquier problema con la redefinici&amp;oacute;n de esto para que signifique algo m&amp;aacute;s en los controladores de eventos o en las devoluciones de llamada de solicitud de Ajax.</target>
        </trans-unit>
        <trans-unit id="01d3f9dd3adc47ab7ac1b64ead3455b5e2967b39" translate="yes" xml:space="preserve">
          <source>Include the module in the list of dependencies for your view model:</source>
          <target state="translated">Incluya el módulo en la lista de dependencias para su modelo de vista:</target>
        </trans-unit>
        <trans-unit id="a540fcc7f8debd81035e2aedabe7eca5ef988f87" translate="yes" xml:space="preserve">
          <source>Including certain properties using &amp;ldquo;include&amp;rdquo;</source>
          <target state="translated">Incluir ciertas propiedades usando &quot;incluir&quot;</target>
        </trans-unit>
        <trans-unit id="51f5cfb3bf91b525954d3382e4520457debfab20" translate="yes" xml:space="preserve">
          <source>Indicating that a control-flow binding &amp;ldquo;completes&amp;rdquo; asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbb6e3feed90f14fa1eaeab9ddfc2be5402137" translate="yes" xml:space="preserve">
          <source>Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).</source>
          <target state="translated">Inserta el nodoToInsert as a child of the real or virtual element containerElem,posicionado inmediatamente después de insertAfter (donde insertAfter debe ser un hijo de containerElem).</target>
        </trans-unit>
        <trans-unit id="5226f3c318b899bef48bc2eb6b90732ff9e7c110" translate="yes" xml:space="preserve">
          <source>Inserts nodeToPrepend as the first child of the real or virtual element containerElem.</source>
          <target state="translated">Inserta el nodoToPrepend como el primer hijo del elemento real o virtual containerElem.</target>
        </trans-unit>
        <trans-unit id="0c6bbabe746e549a40b0c4c9d91c41eb15b7c78a" translate="yes" xml:space="preserve">
          <source>Instead of using submit on the form, you &lt;em&gt;could&lt;/em&gt; use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the &lt;em&gt;enter&lt;/em&gt; key while typing into a text box.</source>
          <target state="translated">En lugar de usar enviar en el formulario, &lt;em&gt;puede&lt;/em&gt; hacer clic en el bot&amp;oacute;n enviar. Sin embargo, enviar tiene la ventaja de que tambi&amp;eacute;n captura formas alternativas de enviar el formulario, como presionar la tecla &lt;em&gt;Intro&lt;/em&gt; mientras escribe en un cuadro de texto.</target>
        </trans-unit>
        <trans-unit id="83dd21419fd3a38dcc7db394fe1758f026c592be" translate="yes" xml:space="preserve">
          <source>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it&amp;rsquo;s still possible to incur naming collisions in your architecture. There&amp;rsquo;s also no clean way to handle dependency management without some manual effort or third party tools.</source>
          <target state="translated">En cambio, los desarrolladores en la actualidad tienen que recurrir a variaciones del m&amp;oacute;dulo o patrones literales de objetos. Con muchos de estos, los scripts de m&amp;oacute;dulo se encadenan en el DOM con los espacios de nombres descritos por un &amp;uacute;nico objeto global donde a&amp;uacute;n es posible incurrir en colisiones de nombres en su arquitectura. Tampoco existe una forma limpia de manejar la administraci&amp;oacute;n de dependencias sin un esfuerzo manual o herramientas de terceros.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="0ed5597c3a7b69dedb6a6d299a96c9f0d4cdda78" translate="yes" xml:space="preserve">
          <source>Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</source>
          <target state="translated">¿El KO tiene la intención de competir con jQuery (o Prototipo,etc.)o trabajar con él?</target>
        </trans-unit>
        <trans-unit id="65da43a24216ab5b6b86fc60da5f46e3f4aeba18" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</source>
          <target state="translated">No es estrictamente necesario eliminar los c&amp;aacute;lculos y las suscripciones que solo dependen de las propiedades del mismo objeto de modelo de vista, ya que esto crea solo una referencia circular que los recolectores de basura de JavaScript saben c&amp;oacute;mo publicar. Sin embargo, para evitar tener que recordar qu&amp;eacute; cosas deben eliminarse, es posible que prefiera usar pureComputed siempre que sea posible y eliminar expl&amp;iacute;citamente todos los dem&amp;aacute;s computados / suscripciones, sean t&amp;eacute;cnicamente necesarios o no.</target>
        </trans-unit>
        <trans-unit id="2c8d88dcd3513a54272253518c0497355ab086ef" translate="yes" xml:space="preserve">
          <source>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</source>
          <target state="translated">Primero comprobará si la llave ya está presente y hará una excepción si lo está.Luego,invocará las llamadas de creación y actualización,si las hay,para crear el nuevo objeto.Finalmente,añadirá este objeto a la matriz y lo devolverá.</target>
        </trans-unit>
        <trans-unit id="d79526c06b498ef03e22fd6acf22e655f708bfbf" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually very simple and rather lovely. The tracking algorithm goes like this:</source>
          <target state="translated">En realidad, es muy simple y bastante encantador. El algoritmo de seguimiento es el siguiente:</target>
        </trans-unit>
        <trans-unit id="878cb611fac9777800e6495d4a84b9db45ca03ab" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of &amp;ldquo;Mercury&amp;rdquo; where capital is null. In JavaScript, you&amp;rsquo;re not allowed to evaluate subproperties of null or undefined values.</source>
          <target state="translated">Es importante entender que el enlace if es realmente vital para que este c&amp;oacute;digo funcione correctamente. Sin &amp;eacute;l, habr&amp;iacute;a un error al intentar evaluar capital.cityName en el contexto de &amp;ldquo;Mercurio&amp;rdquo; donde capital es nulo. En JavaScript, no se le permite evaluar subpropiedades de valores nulos o indefinidos.</target>
        </trans-unit>
        <trans-unit id="e3874fb9afc15bfa8481f8f5826ec25b83ba6641" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a foreach binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don&amp;rsquo;t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</source>
          <target state="translated">Es mucho m&amp;aacute;s f&amp;aacute;cil con KO. Le permite escalar en complejidad sin temor a introducir inconsistencias. Simplemente represente sus elementos como una matriz de JavaScript y luego use un enlace foreach para transformar esta matriz en una TABLA o un conjunto de DIV. Siempre que cambia la matriz, la interfaz de usuario cambia para coincidir (no tiene que averiguar c&amp;oacute;mo inyectar nuevos TR o d&amp;oacute;nde inyectarlos). El resto de la interfaz de usuario permanece sincronizada. Por ejemplo, puede vincular declarativamente un SPAN para mostrar el n&amp;uacute;mero de elementos de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="006519a934952c4254be41efd04fdc8f35b9bbc1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not mandatory</source>
          <target state="translated">No es obligatorio</target>
        </trans-unit>
        <trans-unit id="0b7ff8fbd1e3390894e542bb222f79b8c9ed9a17" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not very often that you&amp;rsquo;ll need to use named templates, but on occasion it can help to minimise duplication of markup.</source>
          <target state="translated">No es muy frecuente que deba utilizar plantillas con nombre, pero en ocasiones puede ayudar a minimizar la duplicaci&amp;oacute;n de marcado.</target>
        </trans-unit>
        <trans-unit id="5f7ea21297f054ffd0625db94299b6ba1fe8aaa4" translate="yes" xml:space="preserve">
          <source>JSON data</source>
          <target state="translated">Datos de JSON</target>
        </trans-unit>
        <trans-unit id="c63fa2ce723842121580c849293751dfa2071897" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with and using without any container element to host it. This is useful if you need to use these bindings in a place where it would not be legal to introduce a new container element just to hold the binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56018c5b9bb46e0b7d9532486fd48da666983d" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings, you can use let without any container element to host it. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcbc8242b1e3ebc93c1cfe4363423f333e167a" translate="yes" xml:space="preserve">
          <source>Just like other control flow elements such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with without any container element to host it. This is useful if you need to use with in a place where it would not be legal to introduce a new container element just to hold the with binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="translated">Al igual que otros elementos de flujo de control, como &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , puede usar con sin ning&amp;uacute;n elemento contenedor para alojarlo. Esto es &amp;uacute;til si necesita usar con en un lugar donde no ser&amp;iacute;a legal introducir un nuevo elemento contenedor solo para mantener el enlace con. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; o &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="f64bb981f55e85e97b341a43c767424d5619a17b" translate="yes" xml:space="preserve">
          <source>Just like the built-in bindings &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creating custom bindings that control descendant bindings&lt;/a&gt;.</source>
          <target state="translated">Al igual que los enlaces integrados &lt;a href=&quot;with-binding&quot;&gt;con&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; , los enlaces personalizados pueden cambiar el contexto de enlace de sus elementos descendientes o proporcionar propiedades especiales al extender el objeto de contexto de enlace. Esto se describe en detalle en la &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creaci&amp;oacute;n de enlaces personalizados que controlan los enlaces descendientes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f10396afd953909c4df70ba9023b9185a81cc60" translate="yes" xml:space="preserve">
          <source>KO clears the previous content and then sets the element&amp;rsquo;s content to your parameter value using jQuery&amp;rsquo;s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</source>
          <target state="translated">KO borra el contenido anterior y luego establece el contenido del elemento en el valor de su par&amp;aacute;metro utilizando la funci&amp;oacute;n html de jQuery o analizando la cadena en nodos HTML y agregando cada nodo como hijo del elemento, si jQuery no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="69fa041d6384a6c679e26d44e244d5f32beebb78" translate="yes" xml:space="preserve">
          <source>KO notifies any subscribers about the new value of your computed observable.</source>
          <target state="translated">KO notifica a los suscriptores sobre el nuevo valor de su observable computarizado.</target>
        </trans-unit>
        <trans-unit id="71fb9b79738717eee4554654ca119320338369c1" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="translated">KO establece el estado marcado del elemento para que coincida con el valor de su par&amp;aacute;metro. Se sobrescribir&amp;aacute; cualquier estado verificado anteriormente. La forma en que se interpreta su par&amp;aacute;metro depende del tipo de elemento al que se vincula:</target>
        </trans-unit>
        <trans-unit id="8a3df96598c4036511dc238d5a88ee9394c86f50" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s text content to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO establece el contenido de texto del elemento en el valor de su par&amp;aacute;metro. Se sobrescribir&amp;aacute; cualquier valor anterior.</target>
        </trans-unit>
        <trans-unit id="e1f9d65da5ea43666bdeb72a28f9a6b37496e064" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s value property to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO establece la propiedad de valor del elemento en el valor de su par&amp;aacute;metro. Se sobrescribir&amp;aacute; cualquier valor anterior.</target>
        </trans-unit>
        <trans-unit id="3bde7388020d016b48b1ca2b6ab57e2975906b8d" translate="yes" xml:space="preserve">
          <source>KO will pass exactly the same set of parameters that it passes to &lt;a href=&quot;#the-update-callback&quot;&gt;the update callback&lt;/a&gt;.</source>
          <target state="translated">KO pasar&amp;aacute; exactamente el mismo conjunto de par&amp;aacute;metros que pasa a &lt;a href=&quot;#the-update-callback&quot;&gt;la devoluci&amp;oacute;n de llamada de actualizaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ac751a44f21c39e46010fe72a276f9173a2c15" translate="yes" xml:space="preserve">
          <source>KO will prefix the list of items with one that displays the text &amp;ldquo;Select an item&amp;hellip;&amp;rdquo; and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable&amp;rsquo;s value changes.</source>
          <target state="translated">KO antepondr&amp;aacute; a la lista de elementos uno que muestre el texto &quot;Seleccionar un elemento ...&quot; y tenga el valor indefinido. Por lo tanto, si myChosenValue tiene el valor indefinido (lo que hacen los observables de forma predeterminada), se seleccionar&amp;aacute; la opci&amp;oacute;n ficticia. Si el par&amp;aacute;metro optionsCaption es un observable, entonces el texto del elemento inicial se actualizar&amp;aacute; a medida que cambie el valor del observable.</target>
        </trans-unit>
        <trans-unit id="aa70ea5fbce8c2f9ed5def8836b676cb1d01b105" translate="yes" xml:space="preserve">
          <source>Key point: An observableArray tracks which objects are &lt;em&gt;in&lt;/em&gt; the array, &lt;em&gt;not&lt;/em&gt; the state of those objects</source>
          <target state="translated">Punto clave: un observableArray rastrea qu&amp;eacute; objetos est&amp;aacute;n &lt;em&gt;en&lt;/em&gt; el arreglo, &lt;em&gt;no&lt;/em&gt; el estado de esos objetos</target>
        </trans-unit>
        <trans-unit id="65b8802912f36c09e8cad961f5924ed6360633cb" translate="yes" xml:space="preserve">
          <source>Knockout 3.5 introduced the ability to specify a custom rate-limit method by passing a function to the rateLimit extender rather than just a string. The function is called with three parameters (function, timeout, options) and must return a new, rate-limited function. Whenever the observable has a possibly new value to notify, it will call the returned function, which should then call the original function after some delay based on the rules of the custom method. For example, here is a function that implements &lt;em&gt;debounce&lt;/em&gt; but also immediately notifies the initial value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd00a0b3dad001fec0c192cbc11b089833bdc7" translate="yes" xml:space="preserve">
          <source>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in &lt;a href=&quot;http://json.org/&quot;&gt;JSON format&lt;/a&gt; - the format that the majority of Ajax applications use today.</source>
          <target state="translated">Knockout le permite implementar interactividad sofisticada del lado del cliente, pero casi todas las aplicaciones web tambi&amp;eacute;n necesitan intercambiar datos con el servidor, o al menos serializar los datos para el almacenamiento local. La forma m&amp;aacute;s conveniente de intercambiar o almacenar datos es en &lt;a href=&quot;http://json.org/&quot;&gt;formato JSON&lt;/a&gt; , el formato que utilizan la mayor&amp;iacute;a de las aplicaciones Ajax en la actualidad.</target>
        </trans-unit>
        <trans-unit id="f229f6596fbe329e6bb64b5dce17d58c2ffbdd68" translate="yes" xml:space="preserve">
          <source>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</source>
          <target state="translated">El Knockout permite usar varios cargadores de componentes simultáneamente.Esto es útil para que,por ejemplo,se puedan conectar cargadores que implementen diferentes mecanismos (por ejemplo,uno podría obtener plantillas de un servidor backend de acuerdo con una convención de nombres;otro podría configurar modelos de vistas utilizando un sistema de inyección de dependencia)y hacer que funcionen juntos.</target>
        </trans-unit>
        <trans-unit id="b60fb8fc7684ef97c17d8ccca6eefd233019acb9" translate="yes" xml:space="preserve">
          <source>Knockout does not call require([moduleName], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.</source>
          <target state="translated">Knockout no llama a require([nombreModulo],...)hasta que su componente se instancie.Así es como los componentes se cargan a petición,no por adelantado.</target>
        </trans-unit>
        <trans-unit id="6bdbad01c03ad4f569a7ab9c513b131c9c780424" translate="yes" xml:space="preserve">
          <source>Knockout doesn&amp;rsquo;t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery&amp;rsquo;s Ajax helper methods, such as &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;, &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;, and &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;. You can fetch data from the server:</source>
          <target state="translated">Knockout no te obliga a utilizar ninguna t&amp;eacute;cnica en particular para cargar o guardar datos. Puede utilizar cualquier mecanismo que sea conveniente para la tecnolog&amp;iacute;a del lado del servidor que elija. El mecanismo m&amp;aacute;s utilizado son los m&amp;eacute;todos auxiliares Ajax de jQuery, como &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt; , &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt; y &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt; . Puede obtener datos del servidor:</target>
        </trans-unit>
        <trans-unit id="f5aed4a079474df37e1a8e5472e53d73006c662b" translate="yes" xml:space="preserve">
          <source>Knockout has special support for drop-down lists (i.e., &amp;lt;select&amp;gt; elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; or for handling multi-select lists, see the documentation for &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;.</source>
          <target state="translated">Knockout tiene soporte especial para listas desplegables (es decir, elementos &amp;lt;select&amp;gt;). El enlace de valor funciona junto con el enlace de opciones para permitirle leer y escribir valores que son objetos de JavaScript arbitrarios, no solo valores de cadena. Esto es muy &amp;uacute;til si desea permitir que el usuario seleccione de un conjunto de objetos de modelo. Para obtener ejemplos de esto, consulte &lt;a href=&quot;options-binding&quot;&gt;el enlace de opciones&lt;/a&gt; o para manejar listas de selecci&amp;oacute;n m&amp;uacute;ltiple, consulte la documentaci&amp;oacute;n &lt;a href=&quot;selectedoptions-binding&quot;&gt;del enlace selectedOptions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfbfbf7e76555709a0e8ee8ab3da25adea41602f" translate="yes" xml:space="preserve">
          <source>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user&amp;rsquo;s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</source>
          <target state="translated">Knockout es una biblioteca de JavaScript que le ayuda a crear interfaces de usuario de editor y visualizaci&amp;oacute;n ricas y receptivas con un modelo de datos subyacente limpio. Siempre que tenga secciones de UI que se actualicen din&amp;aacute;micamente (p. Ej., Cambiando seg&amp;uacute;n las acciones del usuario o cuando cambie una fuente de datos externa), KO puede ayudarlo a implementarlo de manera m&amp;aacute;s simple y f&amp;aacute;cil de mantener.</target>
        </trans-unit>
        <trans-unit id="ce1aa9a9160bc65a886f29f47c527a318a8927af" translate="yes" xml:space="preserve">
          <source>Knockout is built around three core features:</source>
          <target state="translated">El golpe de gracia se construye alrededor de tres características principales:</target>
        </trans-unit>
        <trans-unit id="09a2d95410f39ed2247b45c19059e92620c5572c" translate="yes" xml:space="preserve">
          <source>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&amp;rsquo;s properties are &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</source>
          <target state="translated">Knockout est&amp;aacute; dise&amp;ntilde;ado para permitirle utilizar objetos JavaScript arbitrarios como modelos de vista. Siempre que algunas de las propiedades de su modelo de vista sean &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt; , puede usar KO para vincularlas a su IU, y la IU se actualizar&amp;aacute; autom&amp;aacute;ticamente siempre que cambien las propiedades observables.</target>
        </trans-unit>
        <trans-unit id="0332512be6d6db18462a0af0288d09889035cb5f" translate="yes" xml:space="preserve">
          <source>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</source>
          <target state="translated">Los observatorios de los knock-out proporcionan las características básicas necesarias para apoyar los valores de lectura/escritura y notificar a los suscriptores cuando ese valor cambie.En algunos casos,sin embargo,puede que desee añadir funcionalidad adicional a un observable.Esto podría incluir la adición de propiedades adicionales al observable o la interceptación de escrituras colocando un observable computarizado escribible delante del observable.Los extensores Knockout proporcionan una forma fácil y flexible de hacer este tipo de aumento a un observable.</target>
        </trans-unit>
        <trans-unit id="aad0f3305d675fb1b797b9228f57e9108d17c6a8" translate="yes" xml:space="preserve">
          <source>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout&amp;rsquo;s microtask system with another library or add support for additional environments.</source>
          <target state="translated">Knockout proporciona algunos m&amp;eacute;todos avanzados para controlar cu&amp;aacute;ndo se procesa la cola de microtask. Estos son &amp;uacute;tiles si desea integrar el sistema de microtask de Knockout con otra biblioteca o agregar soporte para entornos adicionales.</target>
        </trans-unit>
        <trans-unit id="ca6abd5738b63edcd68975dfacaf86d8c1192d78" translate="yes" xml:space="preserve">
          <source>Knockout provides the following functions for working with virtual elements.</source>
          <target state="translated">Knockout proporciona las siguientes funciones para trabajar con elementos virtuales.</target>
        </trans-unit>
        <trans-unit id="2ed4d7a56d6f5a6d67ea07b3132d5ff007844b64" translate="yes" xml:space="preserve">
          <source>Knockout provides two similar events that you can use to be notified when the contents of a node have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef914aa2073c907e472f6d2527feb737ec2b058e" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0091a1df891fb4dfb8dfd62f26c34e55f8c10" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s content to a text node with your parameter value. Any previous content will be overwritten.</source>
          <target state="translated">Knockout establece el contenido del elemento en un nodo de texto con el valor de su par&amp;aacute;metro. Se sobrescribir&amp;aacute; cualquier contenido anterior.</target>
        </trans-unit>
        <trans-unit id="f4be7114f1815cac446415c10a81311effa02c36" translate="yes" xml:space="preserve">
          <source>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</source>
          <target state="translated">Knockout se esfuerza por evitar a los desarrolladores el dolor de tratar con problemas de compatibilidad entre navegadores,¡especialmente los relacionados con los navegadores más antiguos! Aunque los elementos personalizados proporcionan un estilo muy moderno de desarrollo web,siguen funcionando en todos los navegadores comunes:</target>
        </trans-unit>
        <trans-unit id="3614b4e93dd3cdeb6c24be3fd21755de5f630cec" translate="yes" xml:space="preserve">
          <source>Knockout version 3.4.0 added support for &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;deferred updates&lt;/em&gt;&lt;/a&gt;, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</source>
          <target state="translated">Knockout versi&amp;oacute;n 3.4.0 agreg&amp;oacute; soporte para &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;actualizaciones diferidas&lt;/em&gt;&lt;/a&gt; , que funciona de manera similar a la limitaci&amp;oacute;n de velocidad al hacer que las notificaciones y las actualizaciones sean asincr&amp;oacute;nicas. Pero en lugar de usar un retraso programado, las actualizaciones diferidas se procesan lo antes posible despu&amp;eacute;s de la tarea actual, antes de ceder para E / S, reflujo o redibujado. Si est&amp;aacute; actualizando a 3.4.0 y tiene un c&amp;oacute;digo que usa un tiempo de espera de l&amp;iacute;mite de velocidad corto (por ejemplo, 0 milisegundos), puede modificarlo para usar actualizaciones diferidas en su lugar:</target>
        </trans-unit>
        <trans-unit id="bf00d058136f6ed851cf257f843756b9fbf0a3dc" translate="yes" xml:space="preserve">
          <source>Knockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:</source>
          <target state="translated">Knockout llamará a la llamada de actualización inicialmente cuando la vinculación se aplique a un elemento y rastreará cualquier dependencia (observables/computadoras)a la que acceda.Cuando alguna de estas dependencias cambie,se volverá a llamar la llamada de actualización.Se le pasan los siguientes parámetros:</target>
        </trans-unit>
        <trans-unit id="2eae698b690b8c1bcce8105ecab4ab66625edf99" translate="yes" xml:space="preserve">
          <source>Knockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:</source>
          <target state="translated">Knockout llamará a tu función de inicio una vez por cada elemento DOM en el que uses el enlace.Hay dos usos principales para el init:</target>
        </trans-unit>
        <trans-unit id="a23739891b1f51e8af9e998ec7eca300dc988110" translate="yes" xml:space="preserve">
          <source>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</source>
          <target state="translated">Knockout creará un observable computarizado internamente para detectar de qué observables depende la expresión,y lo dispondrá automáticamente cuando el elemento asociado sea retirado más tarde.</target>
        </trans-unit>
        <trans-unit id="8ab974d067e98d55b933807ee21cdb58029eeed8" translate="yes" xml:space="preserve">
          <source>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component&amp;rsquo;s view.</source>
          <target state="translated">Knockout invocar&amp;aacute; su constructor una vez para cada instancia del componente, produciendo un objeto viewmodel separado para cada uno. Las propiedades del objeto resultante o su cadena de prototipos (por ejemplo, someProperty y doSomething en el ejemplo anterior) est&amp;aacute;n disponibles para vincularse en la vista del componente.</target>
        </trans-unit>
        <trans-unit id="48c5db285f5258d37819571d4c74273c14dd139e" translate="yes" xml:space="preserve">
          <source>Knockout will prevent the use of any bindings that use &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt;, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</source>
          <target state="translated">Knockout evitar&amp;aacute; el uso de enlaces que usen &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt; , porque esto tambi&amp;eacute;n entrar&amp;iacute;a en conflicto con el componente al intentar vincular su modelo de vista a la plantilla inyectada. Por lo tanto, si desea usar un enlace de flujo de control como if o foreach, debe envolverlo alrededor de su elemento personalizado en lugar de usarlo directamente en el elemento personalizado, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ce5685352c45a8ccb78cdea5682fde3ead2b6d04" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/css/&quot;&gt;css&lt;/a&gt; function to set the styles, if available. This lets you take advantage of the extra compatibility features of jQuery, such as setting browser-specific prefixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409698893159f365e2fba812abf15b879db2dd76" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout usará jQuery,si está presente,para manejar eventos de UI como el cambio.Para desactivar este comportamiento e instruir al Knockout para que use siempre el manejo de eventos nativos,puedes configurar la siguiente opción en tu código antes de llamar a ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="628ae63ef225d2591f558c7eb5f9fe4b46e164f9" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout usará jQuery,si está presente,para manejar eventos de UI como el click.Para deshabilitar este comportamiento e instruir al Knockout para que use siempre el manejo de eventos nativos,puedes configurar la siguiente opción en tu código antes de llamar a ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="d77ef2ccc75214842d9b2c0a3d534e87e201ecce" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout usará jQuery,si está presente,para manejar los eventos de UI.Para deshabilitar este comportamiento e instruir al Knockout para que use siempre el manejo de eventos nativos,puedes establecer la siguiente opción en tu código antes de llamar a ko.applyBindings:</target>
        </trans-unit>
        <trans-unit id="2a463ee652f33a4ecb8721a1952f7992b0096faf" translate="yes" xml:space="preserve">
          <source>Knockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.</source>
          <target state="translated">Knockout envuelve llamadas asincrónicas internas y busca una llamada opcional de ko.onError para ejecutar,si se encuentra una excepción,antes de lanzar el error original.Esto le da la oportunidad de ejecutar una lógica personalizada,como pasar el error a un módulo de registro.Además,como la llamada original está envuelta en un try/catch,el error pasado a ko.onError contiene una propiedad de pila,lo que no es cierto en muchos navegadores cuando se manejan errores usando window.onerror.</target>
        </trans-unit>
        <trans-unit id="eaba5f2372fd360661055282561600552507d4f4" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s &lt;em&gt;control flow bindings&lt;/em&gt; (e.g., &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;) can be applied not only to regular DOM elements, but also to &amp;ldquo;virtual&amp;rdquo; DOM elements defined by a special comment-based syntax. For example:</source>
          <target state="translated">Los &lt;em&gt;enlaces de flujo de control&lt;/em&gt; de Knockout (por ejemplo, &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; ) se pueden aplicar no solo a elementos DOM regulares, sino tambi&amp;eacute;n a elementos DOM &quot;virtuales&quot; definidos por una sintaxis especial basada en comentarios. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="10dcefe7d15993a636613b17dda7a5e5e9fcae8a" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.</source>
          <target state="translated">El seguimiento autom&amp;aacute;tico de dependencias de Knockout normalmente hace exactamente lo que quieres. Pero a veces es posible que deba controlar qu&amp;eacute; observables actualizar&amp;aacute;n su observable calculado, especialmente si el observable calculado realiza alg&amp;uacute;n tipo de acci&amp;oacute;n, como realizar una solicitud Ajax. La funci&amp;oacute;n peek le permite acceder a un observable observable o calculado sin crear una dependencia.</target>
        </trans-unit>
        <trans-unit id="dd482bdf1441531cfa78b4dbd9241b7e06ebb86c" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s declarative binding system provides a concise and powerful way to link data to the UI. It&amp;rsquo;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&amp;rsquo;s binding system.</source>
          <target state="translated">El sistema de enlace declarativo de Knockout proporciona una forma concisa y poderosa de vincular datos a la interfaz de usuario. Por lo general, es f&amp;aacute;cil y obvio vincular propiedades de datos simples o utilizar una &amp;uacute;nica vinculaci&amp;oacute;n. Para enlaces m&amp;aacute;s complejos, ayuda a comprender mejor el comportamiento y la sintaxis del sistema de enlace de Knockout.</target>
        </trans-unit>
        <trans-unit id="7691338ff4b6fbe0156716cb2ed66851f5e37135" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue</source>
          <target state="translated">Cola de microtask de Knockout</target>
        </trans-unit>
        <trans-unit id="29bf809f39e83f00213a2579389145bb353bc904" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for &lt;a href=&quot;component-overview&quot;&gt;Knockout components&lt;/a&gt; to maintain asynchronous behavior, and for scheduling &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; for observables.</source>
          <target state="translated">La cola de microtask de Knockout admite la programaci&amp;oacute;n de tareas para que se ejecuten lo antes posible sin dejar de ser asincr&amp;oacute;nica, esforz&amp;aacute;ndose por programarlas para que ocurran antes de ceder para E / S, reflujo o redibujado. Se utiliza internamente para que los &lt;a href=&quot;component-overview&quot;&gt;componentes Knockout&lt;/a&gt; mantengan un comportamiento asincr&amp;oacute;nico y para programar &lt;a href=&quot;deferred-updates&quot;&gt;actualizaciones diferidas&lt;/a&gt; de observables.</target>
        </trans-unit>
        <trans-unit id="eca702ffcf354707c6d7e704262cbeb2920d80d3" translate="yes" xml:space="preserve">
          <source>Knockout.js</source>
          <target state="translated">Knockout.js</target>
        </trans-unit>
        <trans-unit id="8c7dca686f307018a9b4d98dff3ae5fb4bbceb4a" translate="yes" xml:space="preserve">
          <source>Later, when you&amp;rsquo;re asked to implement the &amp;lsquo;Delete&amp;rsquo; functionality, you don&amp;rsquo;t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</source>
          <target state="translated">M&amp;aacute;s tarde, cuando se le solicite que implemente la funcionalidad 'Eliminar', no tendr&amp;aacute; que averiguar con qu&amp;eacute; partes de la interfaz de usuario tiene que interactuar; simplemente lo hace alterar el modelo de datos subyacente.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">Aprende más.</target>
        </trans-unit>
        <trans-unit id="1f2e2bde04a28d8be8e4af5907acc2fba80505c0" translate="yes" xml:space="preserve">
          <source>Learn more about configuring and registering components with the default loader</source>
          <target state="translated">Más información sobre la configuración y el registro de componentes con el cargador predeterminado</target>
        </trans-unit>
        <trans-unit id="6be1bb6cdfa52ff974724e62faceb68b7d67cb10" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a JavaScript object that looks like this:</source>
          <target state="translated">Digamos que tiene un objeto JavaScript que se parece a esto:</target>
        </trans-unit>
        <trans-unit id="94f3d8639201581d19e8cd3a9912e85ca0fa345a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update the code for randomOrder, this time using KO&amp;rsquo;s virtual element APIs:</source>
          <target state="translated">Actualicemos el c&amp;oacute;digo para randomOrder, esta vez usando las API de elementos virtuales de KO:</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Con licencia del MIT.</target>
        </trans-unit>
        <trans-unit id="7d96c306a2bdbcd8c8b74b52fb7d8e32e3c7d783" translate="yes" xml:space="preserve">
          <source>Like components, &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;custom bindings that control descendant bindings&lt;/a&gt; can use ko.bindingEvent.subscribe to run post-processing logic. However, in order to subscribe to the descendantsComplete event, you also need to tell Knockout that your binding is involved in asynchronous notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c0dccba3224320a8069043f5f6f3d98d749d5" translate="yes" xml:space="preserve">
          <source>Live Example 1: Forcing input to be numeric</source>
          <target state="translated">Ejemplo vivo 1:Forzar la entrada para que sea numérica</target>
        </trans-unit>
        <trans-unit id="a999d211200204fb1d5f89b2e98b09601e4ab925" translate="yes" xml:space="preserve">
          <source>Live Example 2: Adding validation to an observable</source>
          <target state="translated">Ejemplo en vivo 2:Agregar validación a un observable</target>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">Ejemplo en vivo</target>
        </trans-unit>
        <trans-unit id="c96856283b27b5efa4c99dbc46c686a71954647b" translate="yes" xml:space="preserve">
          <source>Live example: nested children</source>
          <target state="translated">Ejemplo vivo:niños anidados</target>
        </trans-unit>
        <trans-unit id="ce4efabbd5fd9902131eac73e8e59cb786288b4a" translate="yes" xml:space="preserve">
          <source>Live examples are not available on DevDocs, sorry.</source>
          <target state="translated">Los ejemplos en vivo no están disponibles en DevDocs,lo siento.</target>
        </trans-unit>
        <trans-unit id="e8179062abf1c808535e17f3bba054486e091bd3" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js and a ViewModel class via RequireJs</source>
          <target state="translated">Cargando Knockout.js y una clase de ViewModel a través de RequireJs</target>
        </trans-unit>
        <trans-unit id="7a1275f750d43f39de53842ed4dbab527886627e" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</source>
          <target state="translated">Cargando Knockout.js,un Binding Handler y una clase ViewModel a través de RequireJs</target>
        </trans-unit>
        <trans-unit id="a6971a11e0a52091a5c953372bb00569922b2df7" translate="yes" xml:space="preserve">
          <source>Loading and Saving JSON data</source>
          <target state="translated">Cargando y guardando los datos de JSON</target>
        </trans-unit>
        <trans-unit id="28f44d40c76afc7d7591cf58f327b1bbe21530d4" translate="yes" xml:space="preserve">
          <source>Loading or Saving Data</source>
          <target state="translated">Cargando o guardando datos</target>
        </trans-unit>
        <trans-unit id="902d451cfddbf1a7bd9bf785b56f8ce391deaaca" translate="yes" xml:space="preserve">
          <source>Logically, 'major highlight': isSevere is equivalent to major: isSevere, highlight: isSevere. It&amp;rsquo;s merely a shortcut syntax if you want two or more CSS classes to be set and unset together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac600279c0db054ae2804d05146b63ba0414ceea" translate="yes" xml:space="preserve">
          <source>MVVM and View Models</source>
          <target state="translated">MVVM y ver modelos</target>
        </trans-unit>
        <trans-unit id="d0132e7037dde4a1569f3f0cf422fc539613ba46" translate="yes" xml:space="preserve">
          <source>Main Parameter</source>
          <target state="translated">Parámetro principal</target>
        </trans-unit>
        <trans-unit id="1b773120102a6c1a24da236928541cb48a5ec94c" translate="yes" xml:space="preserve">
          <source>Main parameter</source>
          <target state="translated">Parámetro principal</target>
        </trans-unit>
        <trans-unit id="042abe727f60c8d9932534243bb81872b7416c98" translate="yes" xml:space="preserve">
          <source>Making things respond after a certain delay</source>
          <target state="translated">Hacer que las cosas respondan después de un cierto retraso</target>
        </trans-unit>
        <trans-unit id="c8a5870106ccf1eddcdec83e7b076fb5c8b992dd" translate="yes" xml:space="preserve">
          <source>Managing &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">Gestionar 'esto'</target>
        </trans-unit>
        <trans-unit id="8f860a27c927a94a2081dcaffc79957c81d02b57" translate="yes" xml:space="preserve">
          <source>Manipulating an observableArray</source>
          <target state="translated">Manipulación de un observableArray</target>
        </trans-unit>
        <trans-unit id="f22316e0ceeda20484d97d991e8da0112dd866d9" translate="yes" xml:space="preserve">
          <source>Manually-created &lt;strong&gt;event handlers&lt;/strong&gt; on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn&amp;rsquo;t) must be removed.</source>
          <target state="translated">Los &lt;strong&gt;controladores de eventos&lt;/strong&gt; creados manualmente en elementos DOM externos, si se crean dentro de una funci&amp;oacute;n createViewModel (o incluso dentro de un modelo de vista de componente normal, aunque para ajustarse al patr&amp;oacute;n MVVM no deber&amp;iacute;a) deben eliminarse.</target>
        </trans-unit>
        <trans-unit id="588de813ea47b650faf54523ad98714b629c740e" translate="yes" xml:space="preserve">
          <source>Mapped observable array</source>
          <target state="translated">El mapa de la matriz observable...</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="996b905af8ff85c85478f1f8432f440056372995" translate="yes" xml:space="preserve">
          <source>Mapping from multiple sources</source>
          <target state="translated">Mapeo de múltiples fuentes</target>
        </trans-unit>
        <trans-unit id="7e632657a4c6244bb198de62ec1571b6dfbf8396" translate="yes" xml:space="preserve">
          <source>Mapping options that you specify in each call will be merged.</source>
          <target state="translated">Las opciones de mapeo que especifique en cada llamada se fusionarán.</target>
        </trans-unit>
        <trans-unit id="0c19d4dee164eb75d3ed611fe2afd01eccf8b645" translate="yes" xml:space="preserve">
          <source>Microtasks</source>
          <target state="translated">Microtasks</target>
        </trans-unit>
        <trans-unit id="1ee20630e0871cafa9aed0bf7aa0013db967c5b0" translate="yes" xml:space="preserve">
          <source>Microtasks can be canceled using the &lt;em&gt;handle&lt;/em&gt; value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.</source>
          <target state="translated">Las microtareas se pueden cancelar utilizando el valor de &lt;em&gt;identificador&lt;/em&gt; devuelto por ko.tasks.schedule. Si la tarea ya se ejecut&amp;oacute; o se cancel&amp;oacute; anteriormente, cancelar no hace nada.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="53e411847528d541c26c3c00ed9603e00cf5d49c" translate="yes" xml:space="preserve">
          <source>Modifying observables after DOM events</source>
          <target state="translated">Modificación de los observables después de los eventos DOM</target>
        </trans-unit>
        <trans-unit id="148523423d67830c8f1a8a3e23b0aa52da24e903" translate="yes" xml:space="preserve">
          <source>More more detailed information, see:</source>
          <target state="translated">Información más detallada,ver:</target>
        </trans-unit>
        <trans-unit id="03e0bcfaabb4306e0ad24ddb4448860d09263fb3" translate="yes" xml:space="preserve">
          <source>More than one extender can be applied in a single call to the .extend method of an observable.</source>
          <target state="translated">Se puede aplicar más de un extensor en una sola llamada al método .extend de un observable.</target>
        </trans-unit>
        <trans-unit id="0a842f6a98c04fd60847152441adf06e65c2bcdb" translate="yes" xml:space="preserve">
          <source>Most applications need to fetch data from a backend server. Since the server doesn&amp;rsquo;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&amp;rsquo;ve fetched from the server.</source>
          <target state="translated">La mayor&amp;iacute;a de las aplicaciones necesitan obtener datos de un servidor backend. Dado que el servidor no tiene ning&amp;uacute;n concepto de observables, solo proporcionar&amp;aacute; un objeto JavaScript simple (generalmente serializado como JSON). El complemento de mapeo le brinda una forma sencilla de mapear ese objeto JavaScript simple en un modelo de vista con los observables apropiados. Esta es una alternativa a escribir manualmente su propio c&amp;oacute;digo JavaScript que construye un modelo de vista basado en algunos datos que ha obtenido del servidor.</target>
        </trans-unit>
        <trans-unit id="e4d448139b3552f2ce58ee18a84ae6283ba5f3bb" translate="yes" xml:space="preserve">
          <source>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place &lt;strong&gt;once per component type&lt;/strong&gt;, since Knockout caches the resulting definitions in memory.</source>
          <target state="translated">Se pueden consultar varios cargadores de componentes, hasta que el primero reconozca el nombre del componente y proporcione un modelo / plantilla de vista. Este proceso solo tiene lugar &lt;strong&gt;una vez por tipo de componente&lt;/strong&gt; , ya que Knockout almacena en cach&amp;eacute; las definiciones resultantes en la memoria.</target>
        </trans-unit>
        <trans-unit id="6a6cd3eea908b0b2a5c411ea2342c43a36c3d759" translate="yes" xml:space="preserve">
          <source>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&amp;rsquo;s $.getJSON or $.ajax functions):</source>
          <target state="translated">A continuaci&amp;oacute;n, desea obtener los datos m&amp;aacute;s recientes del servidor. Cada 5 segundos puede emitir una solicitud Ajax (por ejemplo, usando las funciones $ .getJSON o $ .ajax de jQuery):</target>
        </trans-unit>
        <trans-unit id="5f490764c270257caa7816a634ad9ceb0029f602" translate="yes" xml:space="preserve">
          <source>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</source>
          <target state="translated">No importa cuán anidados estén los vínculos,el manipulador siempre puede identificar y operar con los datos apropiados.Usando esta técnica,podemos evitar la sobrecarga de adjuntar manipuladores a cada enlace individual y podemos mantener el marcado limpio y conciso.</target>
        </trans-unit>
        <trans-unit id="afa1839782d1d70ed8698b21df5705b582780b4b" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.</source>
          <target state="translated">Los valores no booleanos se interpretan vagamente como booleanos.Por ejemplo,0 y nulos se tratan como falsos,mientras que 21 y los objetos no nulos se tratan como verdaderos.</target>
        </trans-unit>
        <trans-unit id="065695e32c88230ab4bdf412903d650d890a874e" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true. If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later. As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="b7e6ebe0a5573c6fa19a2a0f36cfae8a5b91c39f" translate="yes" xml:space="preserve">
          <source>None, other than the core Knockout library.</source>
          <target state="translated">Ninguno,excepto el núcleo de la biblioteca de Knockout.</target>
        </trans-unit>
        <trans-unit id="db09b0691b02a98f1c82dcb9d3a19d0909373cf6" translate="yes" xml:space="preserve">
          <source>Normally, Knockout consults the loaders &lt;em&gt;once per component name&lt;/em&gt;, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</source>
          <target state="translated">Normalmente, Knockout consulta a los cargadores &lt;em&gt;una vez por nombre de componente&lt;/em&gt; y luego almacena en cach&amp;eacute; la definici&amp;oacute;n resultante. Esto asegura que se puedan crear instancias de un gran n&amp;uacute;mero de componentes muy r&amp;aacute;pidamente. Si desea borrar la entrada de cach&amp;eacute; para un componente dado, llame a esto, y luego se consultar&amp;aacute; a los cargadores nuevamente la pr&amp;oacute;xima vez que se necesite ese componente.</target>
        </trans-unit>
        <trans-unit id="eeec499c3f627d57c3576dc1e65df40411bba37d" translate="yes" xml:space="preserve">
          <source>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because &lt;em&gt;sometimes it has no choice but to be asynchronous&lt;/em&gt; (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default &amp;mdash; it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</source>
          <target state="translated">Normalmente, Knockout asegura que la carga de componentes, y por tanto la inyecci&amp;oacute;n de componentes, siempre se complete de forma asincr&amp;oacute;nica, porque a &lt;em&gt;veces no tiene m&amp;aacute;s remedio que ser asincr&amp;oacute;nica&lt;/em&gt; (por ejemplo, porque implica una solicitud al servidor). Hace esto incluso si una instancia de componente en particular podr&amp;iacute;a inyectarse sincr&amp;oacute;nicamente (por ejemplo, porque la definici&amp;oacute;n del componente ya estaba cargada). Esta pol&amp;iacute;tica siempre asincr&amp;oacute;nica es una cuesti&amp;oacute;n de coherencia y es una convenci&amp;oacute;n bien establecida heredada de otras tecnolog&amp;iacute;as JavaScript asincr&amp;oacute;nicas modernas, como AMD. La convenci&amp;oacute;n es un valor predeterminado seguro: mitiga posibles errores en los que un desarrollador podr&amp;iacute;a no tener en cuenta la posibilidad de que un proceso t&amp;iacute;picamente as&amp;iacute;ncrono a veces se complete de manera s&amp;iacute;ncrona o viceversa.</target>
        </trans-unit>
        <trans-unit id="6524854e62e38125ced06867534d8b38f18ad484" translate="yes" xml:space="preserve">
          <source>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable&amp;rsquo;s updates and notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Normalmente, un observable calculado actualiza y notifica a sus suscriptores inmediatamente, tan pronto como cambian sus dependencias. Pero si un observable calculado tiene muchas dependencias o implica actualizaciones costosas, puede obtener un mejor rendimiento al limitar o retrasar las actualizaciones y notificaciones del observable calculado. Esto se logra usando el &lt;a href=&quot;ratelimit-observable&quot;&gt;extensor rateLimit&lt;/a&gt; como este:</target>
        </trans-unit>
        <trans-unit id="de8510f955a76aae57a6decf3b1d448a2721eab0" translate="yes" xml:space="preserve">
          <source>Normally, an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</source>
          <target state="translated">Normalmente, un &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; que se cambia notifica a sus suscriptores inmediatamente, de modo que cualquier observable calculado o vinculaciones que dependan del observable se actualizan sincr&amp;oacute;nicamente. El extensor rateLimit, sin embargo, hace que un observable suprima y retrase las notificaciones de cambio durante un per&amp;iacute;odo de tiempo espec&amp;iacute;fico. Por lo tanto, un observable con velocidad limitada actualiza las dependencias de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="85e4e3194fb98ff27c2137c8428ce2e4d1b258a4" translate="yes" xml:space="preserve">
          <source>Normally, an observable notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable&amp;rsquo;s change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Normalmente, un observable notifica a sus suscriptores inmediatamente, tan pronto como se cambia. Pero si un observable se cambia repetidamente o desencadena actualizaciones costosas, puede obtener un mejor rendimiento al limitar o retrasar las notificaciones de cambio del observable. Esto se logra usando el &lt;a href=&quot;ratelimit-observable&quot;&gt;extensor rateLimit&lt;/a&gt; como este:</target>
        </trans-unit>
        <trans-unit id="971d310ac30608c092a71563e91ea63dc1528f2c" translate="yes" xml:space="preserve">
          <source>Normally, an observableArray notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">Normalmente, un observableArray notifica a sus suscriptores inmediatamente, tan pronto como se cambia. Pero si un observableArray se cambia repetidamente o desencadena actualizaciones costosas, puede obtener un mejor rendimiento al limitar o retrasar las notificaciones de cambio. Esto se logra usando el &lt;a href=&quot;ratelimit-observable&quot;&gt;extensor rateLimit&lt;/a&gt; como este:</target>
        </trans-unit>
        <trans-unit id="a43fe63b87c4cb41558a04d9c42885616a56c55a" translate="yes" xml:space="preserve">
          <source>Normally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:</source>
          <target state="translated">Normalmente, los enlaces que utilizan controlesDescendantBindings tambi&amp;eacute;n llamar&amp;aacute;n a ko.applyBindingsToDescendants (someBindingContext, elemento) para aplicar los enlaces descendientes contra alg&amp;uacute;n &lt;a href=&quot;binding-context&quot;&gt;contexto de enlace&lt;/a&gt; modificado . Por ejemplo, podr&amp;iacute;a tener un enlace llamado withProperties que adjunte algunas propiedades adicionales al contexto de enlace que luego estar&amp;aacute; disponible para todos los enlaces descendientes:</target>
        </trans-unit>
        <trans-unit id="b15e1efcc6bbdd05b9bb899a299cf912de21af36" translate="yes" xml:space="preserve">
          <source>Normally, computed observables have a value that is computed from other observables and are therefore &lt;em&gt;read-only&lt;/em&gt;. What may seem surprising, then, is that it is possible to make computed observables &lt;em&gt;writable&lt;/em&gt;. You just need to supply your own callback function that does something sensible with written values.</source>
          <target state="translated">Normalmente, los observables calculados tienen un valor que se calcula a partir de otros observables y, por lo tanto, son &lt;em&gt;de solo lectura&lt;/em&gt; . Lo que puede parecer sorprendente, entonces, es que es posible hacer que los observables computados se puedan &lt;em&gt;escribir&lt;/em&gt; . Solo necesita proporcionar su propia funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que haga algo sensato con valores escritos.</target>
        </trans-unit>
        <trans-unit id="d425a57c002e80bcb922861fb6ad11cb4606ddb8" translate="yes" xml:space="preserve">
          <source>Normally, if you change name as follows:</source>
          <target state="translated">Normalmente,si cambias de nombre de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ea5e697b7346a3eeff279e706b4abc4448a43fae" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">Normalmente,en este caso se llamaría primero a mi Manejador de Botones,y luego el evento de clic se elevaría hasta mi Manejador de Divisiones.Sin embargo,el enlace clickBubble que añadimos con un valor de false impide que el evento pase a myButtonHandler.</target>
        </trans-unit>
        <trans-unit id="fc7808246a4e59ebea4927b73d56662e9805e699" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">Normalmente,en este caso se llamaría primero a mi Manejador de Botones,y luego el evento burbujearía hasta mi Manejador de Divisiones.Sin embargo,el enlace MouseoverBubble que añadimos con un valor de false impide que el evento pase a myButtonHandler.</target>
        </trans-unit>
        <trans-unit id="a70aaac2826c5ee7760b4f9bcd2d5cf62e31d0b4" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; bindings notify &amp;ldquo;completeness&amp;rdquo; even if they are bound to a null or false value and therefore clear the node&amp;rsquo;s contents instead of binding them. But if you use such a control-flow binding to delay binding until part of your viewmodel is finished initializing, it may be more appropriate to also delay the binding notifications. This could be important to delay an outer node&amp;rsquo;s descendantsComplete event. To do so, include the completeOn: &quot;render&quot; option with the binding. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00011c53827e97e83b74eeaeeb5176dcdd95e89" translate="yes" xml:space="preserve">
          <source>Normally, this is an &lt;em&gt;asynchronous&lt;/em&gt; process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlling synchronous/asynchronous loading&lt;/a&gt;.</source>
          <target state="translated">Normalmente, este es un proceso &lt;em&gt;asincr&amp;oacute;nico&lt;/em&gt; . Puede involucrar solicitudes al servidor. Para la coherencia de la API, Knockout garantiza de forma predeterminada que el proceso de carga se complete como una devoluci&amp;oacute;n de llamada asincr&amp;oacute;nica incluso si el componente ya est&amp;aacute; cargado y almacenado en la memoria cach&amp;eacute;. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esto y c&amp;oacute;mo permitir la carga s&amp;iacute;ncrona, consulte &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlar la carga s&amp;iacute;ncrona / asincr&amp;oacute;nica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5928082628ac47958f2a49985793c5a9cfe7a4ac" translate="yes" xml:space="preserve">
          <source>Normally, when you use the value binding on a &amp;lt;select&amp;gt; element, it means that you want the associated model value to describe which item in the &amp;lt;select&amp;gt; is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</source>
          <target state="translated">Normalmente, cuando usa el enlace de valor en un elemento &amp;lt;select&amp;gt;, significa que desea que el valor del modelo asociado describa qu&amp;eacute; elemento en &amp;lt;select&amp;gt; est&amp;aacute; seleccionado. Pero, &amp;iquest;qu&amp;eacute; sucede si establece el valor del modelo en algo que no tiene una entrada correspondiente en la lista? El comportamiento predeterminado es que Knockout sobrescriba el valor de su modelo para restablecerlo a lo que ya est&amp;eacute; seleccionado en el men&amp;uacute; desplegable, evitando as&amp;iacute; que el modelo y la IU se desincronicen.</target>
        </trans-unit>
        <trans-unit id="b0d7a6b36856238f1888ea77959ac6db008365ad" translate="yes" xml:space="preserve">
          <source>Normally, when you&amp;rsquo;re using control flow bindings (foreach, with, if, etc.), there&amp;rsquo;s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</source>
          <target state="translated">Normalmente, cuando usa enlaces de flujo de control (foreach, with, if, etc.), no es necesario dar nombres a sus plantillas: est&amp;aacute;n definidas de forma impl&amp;iacute;cita y an&amp;oacute;nima por el marcado dentro de su elemento DOM. Pero si lo desea, puede factorizar las plantillas en un elemento separado y luego hacer referencia a ellas por su nombre:</target>
        </trans-unit>
        <trans-unit id="892c7a538c26d5912a114ef4c5b4dd9cb750dea3" translate="yes" xml:space="preserve">
          <source>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually &lt;em&gt;functions&lt;/em&gt;.</source>
          <target state="translated">No todos los navegadores admiten getters y setters de JavaScript (* cough * IE * cough *), por lo que, por compatibilidad, los objetos ko.observable son en realidad &lt;em&gt;funciones&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5a2a88914badea0501ca78d4a26a3df5411beb0f" translate="yes" xml:space="preserve">
          <source>Note 1: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a5f5143031f243bb9a60c2b68ea23336cd99f" translate="yes" xml:space="preserve">
          <source>Note 1: Getting value updates instantly from inputs</source>
          <target state="translated">Nota 1:Obtener actualizaciones de valores instantáneamente de las entradas</target>
        </trans-unit>
        <trans-unit id="5fab9187a677e6b78569955d9666c1ccb6694140" translate="yes" xml:space="preserve">
          <source>Note 1: Passing a &amp;ldquo;current item&amp;rdquo; as a parameter to your handler function</source>
          <target state="translated">Nota 1: pasar un &quot;elemento actual&quot; como par&amp;aacute;metro a su funci&amp;oacute;n de controlador</target>
        </trans-unit>
        <trans-unit id="3a814cb6ad3dec3e35271de124fcb52fc7ea8a30" translate="yes" xml:space="preserve">
          <source>Note 1: Referring to each array entry using $data</source>
          <target state="translated">Nota 1:Al referirse a cada entrada de la matriz usando $datos</target>
        </trans-unit>
        <trans-unit id="ca9ba60cb79484ae10cbb526fdec0d6b22f6191b" translate="yes" xml:space="preserve">
          <source>Note 1: Rendering a named template</source>
          <target state="translated">Nota 1:Renderizar una plantilla con nombre</target>
        </trans-unit>
        <trans-unit id="8cb27abf41be27c85ca84a090a734e919e5e138f" translate="yes" xml:space="preserve">
          <source>Note 1: Selection is preserved when setting/changing options</source>
          <target state="translated">Nota 1:La selección se conserva al establecer/cambiar las opciones</target>
        </trans-unit>
        <trans-unit id="8cab987f23a9bac56add3eebe707607f36a2ea67" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;let&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebaabfbfb4ad642b58d8dfcc7e5c4ff9d66877" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; or &amp;ldquo;using&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ce25db4800747a44dd7be30e5487498ca714b8" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; without a container element</source>
          <target state="translated">Nota 1: uso de &quot;con&quot; sin un elemento contenedor</target>
        </trans-unit>
        <trans-unit id="42e4b385f89381daa4e0c5e3ef0819aa9d2954e1" translate="yes" xml:space="preserve">
          <source>Note 1: Using functions and expressions to detemine text values</source>
          <target state="translated">Nota 1:El uso de funciones y expresiones para determinar los valores del texto</target>
        </trans-unit>
        <trans-unit id="a1e70856ca0bef317ab669b291a07dba08a49ed6" translate="yes" xml:space="preserve">
          <source>Note 1: textInput vs value binding</source>
          <target state="translated">Nota 1:textInput vs.value binding</target>
        </trans-unit>
        <trans-unit id="890064c263ea4cdf85ec4df05608a767470d9dee" translate="yes" xml:space="preserve">
          <source>Note 2: About HTML encoding</source>
          <target state="translated">Nota 2:Acerca de la codificación HTML</target>
        </trans-unit>
        <trans-unit id="44d94bff3e26ecd38bca324673da6818a6524a66" translate="yes" xml:space="preserve">
          <source>Note 2: Accessing the event object, or passing more parameters</source>
          <target state="translated">Nota 2:Acceder al objeto del evento,o pasar más parámetros</target>
        </trans-unit>
        <trans-unit id="bc192205bb6999807250e198d100299a2633603b" translate="yes" xml:space="preserve">
          <source>Note 2: Performance considerations when using &amp;ldquo;let&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0d7caea5eed0f78bbea6e5338469a3a2dc28c" translate="yes" xml:space="preserve">
          <source>Note 2: Post-processing the generated options</source>
          <target state="translated">Nota 2:El post-procesamiento de las opciones generadas</target>
        </trans-unit>
        <trans-unit id="61e119aef6a09c668ea64e8f185afb7cb5e1a1c1" translate="yes" xml:space="preserve">
          <source>Note 2: Setting styles which require a unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1677efb75559f0bfd41b60da29baf1f864a1f9" translate="yes" xml:space="preserve">
          <source>Note 2: Using $index, $parent, and other context properties</source>
          <target state="translated">Nota 2:Usando $index,$parent,y otras propiedades de contexto</target>
        </trans-unit>
        <trans-unit id="8999863783c665a40bdd09bd691a298f8f656468" translate="yes" xml:space="preserve">
          <source>Note 2: Using the &amp;ldquo;foreach&amp;rdquo; option with a named template</source>
          <target state="translated">Nota 2: uso de la opci&amp;oacute;n &quot;foreach&quot; con una plantilla con nombre</target>
        </trans-unit>
        <trans-unit id="7026de456ff3382a0e236d7fac1891af4a1a5c1c" translate="yes" xml:space="preserve">
          <source>Note 2: Why are there two similar bindings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d8c3723f8725ce919b58379e9c2909628d4ef" translate="yes" xml:space="preserve">
          <source>Note 2: Working with drop-down lists (i.e., &amp;lt;select&amp;gt; elements)</source>
          <target state="translated">Nota 2: Trabajar con listas desplegables (es decir, elementos &amp;lt;select&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="a2c468fee63b93cfdf8f4899d1272df0051f3f42" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default action</source>
          <target state="translated">Nota 3:Permitir la acción por defecto</target>
        </trans-unit>
        <trans-unit id="961ff8e09bdf3aa8b1b204afa8f0a5e5a818618c" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default click action</source>
          <target state="translated">Nota 3:Permitir la acción de clic por defecto</target>
        </trans-unit>
        <trans-unit id="0fc1a8ea173efa6a26682559149d35b58c72587a" translate="yes" xml:space="preserve">
          <source>Note 3: Enhanced functionality when jQuery is present</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e882f5d136c5c9ff8d8962c222ce417eb151f4" translate="yes" xml:space="preserve">
          <source>Note 3: Updating observable and non-observable property values</source>
          <target state="translated">Nota 3:Actualización de los valores de propiedad observables y no observables</target>
        </trans-unit>
        <trans-unit id="7588edf8b51bfb005ba96690f74a34daa01047a1" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;as&amp;rdquo; to give an alias to &amp;ldquo;foreach&amp;rdquo; items</source>
          <target state="translated">Nota 3: uso de &quot;como&quot; para dar un alias a los elementos &quot;foreach&quot;</target>
        </trans-unit>
        <trans-unit id="f42f724af26e21363687b0dda2ed01310ea7ab5a" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;text&amp;rdquo; without a container element</source>
          <target state="translated">Nota 3: uso de &quot;texto&quot; sin un elemento contenedor</target>
        </trans-unit>
        <trans-unit id="a3a20f1b394f93301d92f03c60d60e1549f40c99" translate="yes" xml:space="preserve">
          <source>Note 4: About an IE 6 whitespace quirk</source>
          <target state="translated">Nota 4:Acerca de una peculiaridad del espacio en blanco del IE 6</target>
        </trans-unit>
        <trans-unit id="23419d68201af3e1cc15bff11daeeb0f79f2c99c" translate="yes" xml:space="preserve">
          <source>Note 4: Preventing the event from bubbling</source>
          <target state="translated">Nota 4:Evitar que el evento burbujee</target>
        </trans-unit>
        <trans-unit id="3e526ff19533fbdea78f0e87c923669d66b13daf" translate="yes" xml:space="preserve">
          <source>Note 4: Using &amp;ldquo;afterRender&amp;rdquo;, &amp;ldquo;afterAdd&amp;rdquo;, and &amp;ldquo;beforeRemove&amp;rdquo;</source>
          <target state="translated">Nota 4: Uso de &quot;afterRender&quot;, &quot;afterAdd&quot; y &quot;beforeRemove&quot;</target>
        </trans-unit>
        <trans-unit id="2163a402155b39d7e2c760112b0647ef85484e62" translate="yes" xml:space="preserve">
          <source>Note 4: Using foreach without a container element</source>
          <target state="translated">Nota 4:El uso de la madera de anteojos sin un elemento contenedor</target>
        </trans-unit>
        <trans-unit id="c786ee828c774288377fdaba163a22ff298763be" translate="yes" xml:space="preserve">
          <source>Note 4: Using the value binding with the checked binding</source>
          <target state="translated">Nota 4:Usar la unión de valores con la unión marcada</target>
        </trans-unit>
        <trans-unit id="ea9b887209a1ac7ee930f38b5412044c510f0f34" translate="yes" xml:space="preserve">
          <source>Note 5: Dynamically choosing which template is used</source>
          <target state="translated">Nota 5:Elegir dinámicamente la plantilla que se utiliza</target>
        </trans-unit>
        <trans-unit id="3bff1a14c09530d5378f91032bbee6d975eeab75" translate="yes" xml:space="preserve">
          <source>Note 5: How array changes are detected and handled</source>
          <target state="translated">Nota 5:Cómo se detectan y manejan los cambios de arreglos</target>
        </trans-unit>
        <trans-unit id="34f5c157ce0b3313df132dd29f97171e41483cf0" translate="yes" xml:space="preserve">
          <source>Note 5: Interaction with jQuery</source>
          <target state="translated">Nota 5:Interacción con jQuery</target>
        </trans-unit>
        <trans-unit id="7bdb9fca3db83a1d3859d688638577c6ee88ba7f" translate="yes" xml:space="preserve">
          <source>Note 6: Destroyed entries are hidden by default</source>
          <target state="translated">Nota 6:Las entradas destruidas están ocultas por defecto</target>
        </trans-unit>
        <trans-unit id="644fea2c743dda120843a65ecaaaaf53c3e37f54" translate="yes" xml:space="preserve">
          <source>Note 6: Hiding destroyed entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a357c555f225c8e2949ce0c275baf99efa923731" translate="yes" xml:space="preserve">
          <source>Note 6: Using jQuery.tmpl, an external string-based template engine</source>
          <target state="translated">Nota 6:Usando jQuery.tmpl,un motor externo de plantillas basado en cadenas</target>
        </trans-unit>
        <trans-unit id="3b8b656336f81c4a99e466d9c14848a3f391c670" translate="yes" xml:space="preserve">
          <source>Note 7: Post-processing or animating the generated DOM elements</source>
          <target state="translated">Nota 7:El post-procesamiento o la animación de los elementos DOM generados</target>
        </trans-unit>
        <trans-unit id="d7bcd8dcb7fb8e81342016d8da6a4aa51bb7c3a9" translate="yes" xml:space="preserve">
          <source>Note 7: Using the Underscore.js template engine</source>
          <target state="translated">Nota 7:Usando el motor de plantillas de Underscore.js</target>
        </trans-unit>
        <trans-unit id="cf25c2749f90cc1bc6823eee106a1d44e331c5bf" translate="yes" xml:space="preserve">
          <source>Note that any display style you&amp;rsquo;ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).</source>
          <target state="translated">Tenga en cuenta que se aplicar&amp;aacute; cualquier estilo de visualizaci&amp;oacute;n que haya configurado utilizando sus reglas CSS (por lo que las reglas CSS como x {display: table-row} funcionan bien junto con este enlace).</target>
        </trans-unit>
        <trans-unit id="ab6b8705ccd46f28afca1a82cfbc0f5e3ac0c980" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using { notify: 'always' } causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f64d633bf252e83e6a30775ca9bae85c7feffc" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using {notify:'always'} causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="translated">Tenga en cuenta que para que esto borre autom&amp;aacute;ticamente los valores rechazados de la interfaz de usuario, es necesario usar .extend ({notificar: 'siempre'}) en el observable calculado. Sin esto, es posible que el usuario ingrese un newValue no v&amp;aacute;lido que cuando se redondea da un valueToWrite sin cambios. Luego, dado que el valor del modelo no cambiar&amp;iacute;a, no habr&amp;iacute;a notificaci&amp;oacute;n para actualizar el cuadro de texto en la interfaz de usuario. El uso de {notificar: 'siempre'} hace que el cuadro de texto se actualice (borrando los valores rechazados) incluso si la propiedad calculada no ha cambiado de valor.</target>
        </trans-unit>
        <trans-unit id="3928cd9c277ba72dbf69e81590702f90731185e0" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.</source>
          <target state="translated">Tenga en cuenta que es necesario especificar viewModel: {instance: object}, y no solo viewModel: object. Esto se diferencia de los otros casos siguientes.</target>
        </trans-unit>
        <trans-unit id="fc236e1ebc6928f0c511903c41b30d3206eee445" translate="yes" xml:space="preserve">
          <source>Note that ko.toJSON accepts the same arguments as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;. For example, it can be useful to have a &amp;ldquo;live&amp;rdquo; representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the &lt;em&gt;spaces&lt;/em&gt; argument into ko.toJSON and bind against your view model like:</source>
          <target state="translated">Tenga en cuenta que ko.toJSON acepta los mismos argumentos que &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; . Por ejemplo, puede ser &amp;uacute;til tener una representaci&amp;oacute;n &quot;en vivo&quot; de los datos de su modelo de vista al depurar una aplicaci&amp;oacute;n Knockout. Para generar una pantalla bien formateada para este prop&amp;oacute;sito, puede pasar el argumento de &lt;em&gt;espacios&lt;/em&gt; a ko.toJSON y vincularlo con su modelo de vista como:</target>
        </trans-unit>
        <trans-unit id="8ed17d0a4365c067e0d0cca185b3a02627fee026" translate="yes" xml:space="preserve">
          <source>Note that only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned into each instance of the component. The container element (in this example, the &amp;lt;template&amp;gt; element), will &lt;em&gt;not&lt;/em&gt; be treated as part of the component template.</source>
          <target state="translated">Tenga en cuenta que solo los nodos &lt;em&gt;dentro&lt;/em&gt; del elemento especificado se clonar&amp;aacute;n en cada instancia del componente. El elemento contenedor (en este ejemplo, el elemento &amp;lt;template&amp;gt;) &lt;em&gt;no&lt;/em&gt; se tratar&amp;aacute; como parte de la plantilla del componente.</target>
        </trans-unit>
        <trans-unit id="5fd98c45b76cfffda7fb29aabbcc4105f3cac578" translate="yes" xml:space="preserve">
          <source>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect &amp;ldquo;simple&amp;rdquo; movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an &amp;ldquo;delete&amp;rdquo; plus an &amp;ldquo;add&amp;rdquo; instead of a single &amp;ldquo;move&amp;rdquo;, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won&amp;rsquo;t encounter this edge case, and even if you do, the end-user experience will usually be identical.</source>
          <target state="translated">Tenga en cuenta que la detecci&amp;oacute;n de reordenamiento no est&amp;aacute; garantizada: para garantizar que el algoritmo se complete r&amp;aacute;pidamente, est&amp;aacute; optimizado para detectar movimientos &amp;ldquo;simples&amp;rdquo; de peque&amp;ntilde;as cantidades de entradas de matriz. Si el algoritmo detecta demasiados reordenamientos simult&amp;aacute;neos combinados con inserciones y eliminaciones no relacionadas, entonces, para mayor velocidad, puede optar por considerar un reordenamiento como una &quot;eliminaci&amp;oacute;n&quot; m&amp;aacute;s un &quot;agregar&quot; en lugar de un solo &quot;movimiento&quot;, y en ese caso el DOM correspondiente. los elementos ser&amp;aacute;n derribados y recreados. La mayor&amp;iacute;a de los desarrolladores no se encontrar&amp;aacute;n con este caso extremo, e incluso si lo hace, la experiencia del usuario final generalmente ser&amp;aacute; id&amp;eacute;ntica.</target>
        </trans-unit>
        <trans-unit id="8d4451b80b2ea7a6435a9b74cfdb3ee7699047bf" translate="yes" xml:space="preserve">
          <source>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</source>
          <target state="translated">Tengan en cuenta que el módulo de manejo de encuadernación personalizada no inyecta nada en nuestro módulo ViewModel,eso es porque no devuelve nada.Sólo agrega un comportamiento adicional al módulo de eliminación.</target>
        </trans-unit>
        <trans-unit id="f85932fb55d2aff93e968e51c4da2dd6a4165c51" translate="yes" xml:space="preserve">
          <source>Note that the only difference between examples 3 and 4 is the optionsText value.</source>
          <target state="translated">Observe que la única diferencia entre los ejemplos 3 y 4 es el valor de opcionesTexto.</target>
        </trans-unit>
        <trans-unit id="7c7ebe43d20e5eae9b1b095f73abef9b56607824" translate="yes" xml:space="preserve">
          <source>Note that this is not the UI itself: it doesn&amp;rsquo;t have any concept of buttons or display styles. It&amp;rsquo;s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</source>
          <target state="translated">Tenga en cuenta que esta no es la interfaz de usuario en s&amp;iacute;: no tiene ning&amp;uacute;n concepto de botones o estilos de visualizaci&amp;oacute;n. Tampoco es el modelo de datos persistentes: contiene los datos no guardados con los que est&amp;aacute; trabajando el usuario. Cuando usa KO, sus modelos de vista son objetos de JavaScript puros que no tienen conocimiento de HTML. Mantener el modelo de vista abstracto de esta manera permite que sea simple, para que pueda administrar comportamientos m&amp;aacute;s sofisticados sin perderse.</target>
        </trans-unit>
        <trans-unit id="e87df4d38ae4cd5ed452a5004cb65d4e1e2d6c9d" translate="yes" xml:space="preserve">
          <source>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="translated">Tenga en cuenta que cuando KO representa un enlace foreach, oculta autom&amp;aacute;ticamente cualquier objeto marcado con _destroy igual a verdadero. Por lo tanto, puede tener alg&amp;uacute;n tipo de bot&amp;oacute;n &quot;eliminar&quot; que invoque el m&amp;eacute;todo destroy (someItem) en la matriz, y esto har&amp;aacute; que el elemento especificado desaparezca inmediatamente de la interfaz de usuario visible. M&amp;aacute;s tarde, cuando env&amp;iacute;e el gr&amp;aacute;fico de objetos JSON a Rails, ese elemento tambi&amp;eacute;n se eliminar&amp;aacute; de la base de datos (mientras que los otros elementos de la matriz se insertar&amp;aacute;n o actualizar&amp;aacute;n como de costumbre).</target>
        </trans-unit>
        <trans-unit id="e450c418845800c7f4318df4ef7374c24e1e9cb3" translate="yes" xml:space="preserve">
          <source>Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposed&lt;/a&gt;</source>
          <target state="translated">Tenga en cuenta que siempre que se elimina un componente (ya sea porque el nombre observable cambi&amp;oacute; o porque un enlace de flujo de control adjunto elimin&amp;oacute; todo el elemento), el componente eliminado se &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;elimina&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65025960631541c741b459bf73aacbde8d728d8d" translate="yes" xml:space="preserve">
          <source>Note that, typically, it&amp;rsquo;s best to perform direct DOM manipulation only through &lt;a href=&quot;custom-bindings&quot;&gt;custom bindings&lt;/a&gt; rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.</source>
          <target state="translated">Tenga en cuenta que, por lo general, es mejor realizar la manipulaci&amp;oacute;n DOM directa solo a trav&amp;eacute;s de &lt;a href=&quot;custom-bindings&quot;&gt;enlaces personalizados en&lt;/a&gt; lugar de actuar en componentInfo.element desde el interior de createViewModel. Esto conduce a un c&amp;oacute;digo m&amp;aacute;s modular y reutilizable.</target>
        </trans-unit>
        <trans-unit id="2ab69f1d78a98533c1ec94379b4b6361aa3fd348" translate="yes" xml:space="preserve">
          <source>Note: &amp;ldquo;ifnot&amp;rdquo; is the same as a negated &amp;ldquo;if&amp;rdquo;</source>
          <target state="translated">Nota: &quot;si no&quot; es lo mismo que un &quot;si&quot; negado</target>
        </trans-unit>
        <trans-unit id="4d936c2871be1bf2c84824c58d0b50a0046f059e" translate="yes" xml:space="preserve">
          <source>Note: About HTML encoding</source>
          <target state="translated">Nota:Acerca de la codificación HTML</target>
        </trans-unit>
        <trans-unit id="b3bd5be04d2a77b8fbb42b423e270ca8d27974f7" translate="yes" xml:space="preserve">
          <source>Note: Applying CSS classes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Nota: Aplicar clases CSS cuyos nombres no son nombres legales de variables de JavaScript</target>
        </trans-unit>
        <trans-unit id="36e59391e4012e916e2efca315ab8a0ac9019825" translate="yes" xml:space="preserve">
          <source>Note: Applying attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Nota: Aplicar atributos cuyos nombres no son nombres legales de variables de JavaScript</target>
        </trans-unit>
        <trans-unit id="40dbc8e3fecd759b1343c0ec1a8b8e04691b65e3" translate="yes" xml:space="preserve">
          <source>Note: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">Nota: Aplicar estilos cuyos nombres no son nombres legales de variables de JavaScript</target>
        </trans-unit>
        <trans-unit id="e4f74718bbd2f9c628b5720909d7d35fb25664a8" translate="yes" xml:space="preserve">
          <source>Note: Combining custom elements with regular bindings</source>
          <target state="translated">Nota:La combinación de elementos personalizados con fijaciones regulares</target>
        </trans-unit>
        <trans-unit id="9e0ba81f0e79b9ea41b49ea9879be53189f0c81a" translate="yes" xml:space="preserve">
          <source>Note: Custom component loaders and custom elements</source>
          <target state="translated">Nota:Los cargadores de componentes personalizados y los elementos personalizados</target>
        </trans-unit>
        <trans-unit id="097a1159163b98735917888cc1f3edd2f432ff4d" translate="yes" xml:space="preserve">
          <source>Note: Custom elements and Internet Explorer 6 to 8</source>
          <target state="translated">Nota:Elementos personalizados e Internet Explorer 6 a 8</target>
        </trans-unit>
        <trans-unit id="3452f7b8dfc0078e81c174fd19ab87bdb730cee7" translate="yes" xml:space="preserve">
          <source>Note: Custom elements cannot be self-closing</source>
          <target state="translated">Nota:Los elementos personalizados no pueden ser de cierre automático</target>
        </trans-unit>
        <trans-unit id="15b14d285bce9dc6c5d35d744705210b61bb5f03" translate="yes" xml:space="preserve">
          <source>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;. For a single-select list, you can also read and write the selected option using &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt;.</source>
          <target state="translated">Nota: Para una lista de selecci&amp;oacute;n m&amp;uacute;ltiple, para establecer cu&amp;aacute;les de las opciones est&amp;aacute;n seleccionadas, o para leer cu&amp;aacute;les de las opciones est&amp;aacute;n seleccionadas, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;el enlace selectedOptions&lt;/a&gt; . Para una lista de selecci&amp;oacute;n &amp;uacute;nica, tambi&amp;eacute;n puede leer y escribir la opci&amp;oacute;n seleccionada usando &lt;a href=&quot;value-binding&quot;&gt;el enlace de valor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea83c2531ea63cd46a3690a3c5a207b81e6a5f4" translate="yes" xml:space="preserve">
          <source>Note: For text boxes, drop-down lists, and all non-checkable form controls, use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; to read and write the element&amp;rsquo;s value, not the checked binding.</source>
          <target state="translated">Nota: Para cuadros de texto, listas desplegables y todos los controles de formulario que no se pueden marcar, utilice &lt;a href=&quot;value-binding&quot;&gt;el enlace de valor&lt;/a&gt; para leer y escribir el valor del elemento, no el enlace marcado.</target>
        </trans-unit>
        <trans-unit id="5d17b383b870bd49e9fdcd437b821085b1249406" translate="yes" xml:space="preserve">
          <source>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</source>
          <target state="translated">Nota:Si el usuario navega a una página web completamente diferente,los navegadores lo hacen sin pedir a ningún código que se ejecute en la página que lo limpie.Así que en este caso no se invocará ninguna función de eliminación.Esto está bien porque el navegador liberará automáticamente la memoria utilizada por todos los objetos que estaban en uso.</target>
        </trans-unit>
        <trans-unit id="07830fa525672973fcad872d9479a00d3f0aae0b" translate="yes" xml:space="preserve">
          <source>Note: If you just want to prevent a computed observable from updating too often, see the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt;.</source>
          <target state="translated">Nota: Si solo desea evitar que un observable calculado se actualice con demasiada frecuencia, consulte el &lt;a href=&quot;ratelimit-observable&quot;&gt;extensor rateLimit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a9907430c3d424ba976757e1f30ff936d301ef5" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re working with checkboxes or radio buttons, use &lt;a href=&quot;checked-binding&quot;&gt;the checked binding&lt;/a&gt; to read and write your element&amp;rsquo;s checked state, not the value binding.</source>
          <target state="translated">Nota: Si est&amp;aacute; trabajando con casillas de verificaci&amp;oacute;n o botones de opci&amp;oacute;n, use &lt;a href=&quot;checked-binding&quot;&gt;el enlace marcado&lt;/a&gt; para leer y escribir el estado marcado de su elemento, no el enlace de valor.</target>
        </trans-unit>
        <trans-unit id="4013149ccb3f87d8ccbd0084efe996d0838d6311" translate="yes" xml:space="preserve">
          <source>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;an example&lt;/a&gt; and &lt;a href=&quot;component-registration&quot;&gt;registration documentation&lt;/a&gt;.</source>
          <target state="translated">Nota: En casos m&amp;aacute;s realistas, normalmente cargar&amp;iacute;a modelos de vista de componentes y plantillas desde archivos externos, en lugar de codificarlos en el registro. Vea &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;un ejemplo&lt;/a&gt; y &lt;a href=&quot;component-registration&quot;&gt;documentaci&amp;oacute;n de registro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32f182a0b9cb163063cf0210deaf0ef0bfd93fe2" translate="yes" xml:space="preserve">
          <source>Note: Integrating with browserify</source>
          <target state="translated">Nota:La integración con el navegador</target>
        </trans-unit>
        <trans-unit id="f5847643b33a4979437c074b1772f4baa9785665" translate="yes" xml:space="preserve">
          <source>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it&amp;rsquo;s up to you to use a subscription to capture and track it.</source>
          <target state="translated">Nota: Knockout no garantiza que los eventos beforeChange y change ocurran en pares, ya que otras partes de su c&amp;oacute;digo pueden generar cualquiera de los eventos individualmente. Si necesita rastrear el valor anterior de un observable, depende de usted usar una suscripci&amp;oacute;n para capturarlo y rastrearlo.</target>
        </trans-unit>
        <trans-unit id="129196d92bb0c541677b616e7f9a98c3cc7e94cf" translate="yes" xml:space="preserve">
          <source>Note: Letting the user select from arbitrary JavaScript objects</source>
          <target state="translated">Nota:Dejar que el usuario seleccione de entre los objetos arbitrarios de JavaScript</target>
        </trans-unit>
        <trans-unit id="140ebf77e1d231f3e690deb8c6320dc6a123f7b1" translate="yes" xml:space="preserve">
          <source>Note: Passing markup to components</source>
          <target state="translated">Nota:Pasar el marcado a los componentes</target>
        </trans-unit>
        <trans-unit id="23a3c1f00b1235c3c83812b480d0211ea6db2687" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30af1206ec552873ed1d054e17b9fad1512a18" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes with a namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd54c6d3ace6bef5b8658344fb90ff9e01f394" translate="yes" xml:space="preserve">
          <source>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator. Blog post coming soon.</source>
          <target state="translated">Nota: Dado que el optimizador r.js es muy flexible, tiene muchas opciones y puede llevar alg&amp;uacute;n tiempo configurarlo. Es posible que desee comenzar con un ejemplo listo para usar de componentes Knockout optimizados a trav&amp;eacute;s de r.js, en cuyo caso vea &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; y el &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generador generator-ko&lt;/a&gt; . Publicaci&amp;oacute;n de blog pr&amp;oacute;ximamente.</target>
        </trans-unit>
        <trans-unit id="54b8295547dbd8dd296d604963578e9c5ba48c73" translate="yes" xml:space="preserve">
          <source>Note: Supporting virtual elements</source>
          <target state="translated">Nota:El apoyo a los elementos virtuales</target>
        </trans-unit>
        <trans-unit id="dd0ab8e16c1919532cc43e7aa1a6b879552640b4" translate="yes" xml:space="preserve">
          <source>Note: Template-only components</source>
          <target state="translated">Nota:Los componentes de la plantilla</target>
        </trans-unit>
        <trans-unit id="b05caaa87623573294cec899219e7deabd2359f2" translate="yes" xml:space="preserve">
          <source>Note: To control which element in a single-select drop-down list is selected, you can use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; instead.</source>
          <target state="translated">Nota: Para controlar qu&amp;eacute; elemento de una lista desplegable de selecci&amp;oacute;n &amp;uacute;nica est&amp;aacute; seleccionado, puede usar &lt;a href=&quot;value-binding&quot;&gt;el enlace de valor en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="c337589312cb228d7babfb1d2ebfd714455f588c" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; and &amp;ldquo;ifnot&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfb58e2925ffb0818561abbfa7a1e8de927a56" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; without a container element</source>
          <target state="translated">Nota: uso de &quot;si&quot; sin un elemento contenedor</target>
        </trans-unit>
        <trans-unit id="71884929340b18d767f7c056cf2d3ecb21755e40" translate="yes" xml:space="preserve">
          <source>Note: Using arbitrary JavaScript expressions</source>
          <target state="translated">Nota:El uso de expresiones arbitrarias de JavaScript</target>
        </trans-unit>
        <trans-unit id="4403ac4eff9ff864673188e035a34bcf003869af" translate="yes" xml:space="preserve">
          <source>Note: Using component without a container element</source>
          <target state="translated">Nota:El uso de un componente sin un elemento contenedor</target>
        </trans-unit>
        <trans-unit id="1d0bc144231da12d70fed9c1daabfaf618fbc1bf" translate="yes" xml:space="preserve">
          <source>Note: Using functions and expressions to control element visibility</source>
          <target state="translated">Nota:El uso de funciones y expresiones para controlar la visibilidad de los elementos</target>
        </trans-unit>
        <trans-unit id="e11057c5759e08cd6106a99f6b95d00bd0ed796b" translate="yes" xml:space="preserve">
          <source>Note: Using reserved words as attribute names in older browsers</source>
          <target state="translated">Nota:El uso de palabras reservadas como nombres de atributos en navegadores antiguos</target>
        </trans-unit>
        <trans-unit id="b01856c6cdf3d733f8df97b227257f8bdea3947d" translate="yes" xml:space="preserve">
          <source>Note: Using the &amp;ldquo;class&amp;rdquo; and &amp;ldquo;css&amp;rdquo; bindings at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f815e27b345ec1efada4bea3643d51e789c47670" translate="yes" xml:space="preserve">
          <source>Note: Why circular dependencies aren&amp;rsquo;t meaningful</source>
          <target state="translated">Nota: Por qu&amp;eacute; las dependencias circulares no son significativas</target>
        </trans-unit>
        <trans-unit id="c8a2ea7aa039e3cc85d86b844a0aed9f68c466c1" translate="yes" xml:space="preserve">
          <source>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</source>
          <target state="translated">Nota:ko.computedContext.getDependenciesCount()es equivalente a llamar a getDependenciesCount()en el propio observable computarizado.La razón por la que también existe en el ko.computedContext es para proporcionar una forma de contar las dependencias durante la primera evaluación,antes de que el observable computado haya terminado de construirse.</target>
        </trans-unit>
        <trans-unit id="102fb6d0d403a0d599dae72a7da85eadcf53fd8f" translate="yes" xml:space="preserve">
          <source>Note: you don&amp;rsquo;t actually have to provide both init &lt;em&gt;and&lt;/em&gt; update callbacks &amp;mdash; you can just provide one or the other if that&amp;rsquo;s all you need.</source>
          <target state="translated">Nota: en realidad, no tiene que proporcionar tanto las devoluciones de llamada de inicio &lt;em&gt;como las de&lt;/em&gt; actualizaci&amp;oacute;n; solo puede proporcionar una u otra si eso es todo lo que necesita.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e652fe47c807dd0369ac321e0b23b49fe4d6ad4e" translate="yes" xml:space="preserve">
          <source>Notice how, instead of using APIs like domElement.firstChild, we&amp;rsquo;re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., &amp;lt;!-- ko randomOrder: true --&amp;gt;...&amp;lt;!-- /ko --&amp;gt;.</source>
          <target state="translated">Observe c&amp;oacute;mo, en lugar de usar API como domElement.firstChild, ahora estamos usando ko.virtualElements.firstChild (domOrVirtualElement). El enlace randomOrder ahora funcionar&amp;aacute; correctamente con elementos virtuales, por ejemplo, &amp;lt;! - ko randomOrder: true -&amp;gt; ... &amp;lt;! - / ko -&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="881524b74eec619b61fa6cd558f217630d0d2032" translate="yes" xml:space="preserve">
          <source>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:</source>
          <target state="translated">Observe que no se especifica ningún par modelo/plantilla.El propio módulo AMD puede proporcionar un par modelo/plantilla,utilizando cualquiera de los formatos de definición mencionados anteriormente.Por ejemplo,el archivo some/module.js podría ser declarado como:</target>
        </trans-unit>
        <trans-unit id="3ffaab6a02fcd20ec4acba9eb285ffb74bb339fc" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;em&gt;not&lt;/em&gt; intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;no&lt;/em&gt; pretende ser un reemplazo completo del conjunto completo de API DOM regulares. Knockout proporciona solo un conjunto m&amp;iacute;nimo de API de elementos virtuales para que sea posible realizar los tipos de transformaciones necesarias al implementar enlaces de flujo de control.</target>
        </trans-unit>
        <trans-unit id="d64ee77ed37778a54c73db4a866a3e17bd92900f" translate="yes" xml:space="preserve">
          <source>Notice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.</source>
          <target state="translated">Fíjese en el valor de la cadena &quot;empleado&quot; asociado a as.Ahora,en cualquier lugar dentro de este bucle,los enlaces en las plantillas de sus hijos podrán referirse al empleado para acceder al objeto empleado que se está renderizando.</target>
        </trans-unit>
        <trans-unit id="e3a7345017a99ea270b44a59fd49d8ee6f486954" translate="yes" xml:space="preserve">
          <source>Now any descendant binding will be able to refer to person to access this context object. This can be especially useful in scenarios where you have nested contexts and you need to refer to something declared at a higher level in the hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839a7efc6c32176be9d0069eb8544d9601b7d394" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item that is being rendered from the people array. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac7108123b5f245ef9f5df9d943f636924637d" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item, from the people array, that is being rendered. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="translated">Ahora,en cualquier lugar dentro de este bucle frontal,los enlaces serán capaces de referirse a la persona para acceder al elemento de la matriz actual,desde la matriz de personas,que se está renderizando.Esto puede ser especialmente útil en los escenarios en los que se han anidado bloques foreach y es necesario referirse a un elemento declarado en un nivel superior de la jerarquía.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5673fdafd7626621793c97c3c05163e839f06fa8" translate="yes" xml:space="preserve">
          <source>Now like-or-dislike can be consumed in the same way as before, using either a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">Ahora me gusta o no me gusta se puede consumir de la misma manera que antes, utilizando un &lt;a href=&quot;component-binding&quot;&gt;enlace de componente&lt;/a&gt; o un &lt;a href=&quot;component-custom-elements&quot;&gt;elemento personalizado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6480651531660c84a55576d27e9ed7d8351ebcd4" translate="yes" xml:space="preserve">
          <source>Now the component is operating, and can remain on-screen for as long as needed.</source>
          <target state="translated">Ahora el componente está operando,y puede permanecer en pantalla tanto tiempo como sea necesario.</target>
        </trans-unit>
        <trans-unit id="1ee0ffaf853c8407a424f11a481c7a0f71be59bc" translate="yes" xml:space="preserve">
          <source>Now there won&amp;rsquo;t be an error. However, it still won&amp;rsquo;t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don&amp;rsquo;t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it&amp;rsquo;s not going to work properly!</source>
          <target state="translated">Ahora no habr&amp;aacute; ning&amp;uacute;n error. Sin embargo, todav&amp;iacute;a no funcionar&amp;aacute; correctamente, porque nuestro enlace randomOrder est&amp;aacute; codificado usando llamadas API DOM normales (firstChild, appendChild, etc.) que no entienden los elementos virtuales. Esta es la raz&amp;oacute;n por la que KO requiere que usted opte expl&amp;iacute;citamente por la compatibilidad con elementos virtuales: a menos que su enlace personalizado est&amp;eacute; codificado usando API de elementos virtuales, &amp;iexcl;no funcionar&amp;aacute; correctamente!</target>
        </trans-unit>
        <trans-unit id="f68b7fa0902e29163231a8e1b14bcdcd84f1f8c2" translate="yes" xml:space="preserve">
          <source>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</source>
          <target state="translated">Ahora que esto está registrado,se puede hacer referencia a los componentes con cualquier nombre (sin prerregistrarlos),por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a9abe577afb6560e727b712ab6c0be7874d881af" translate="yes" xml:space="preserve">
          <source>Now we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.</source>
          <target state="translated">Ahora podemos introducir un montón de elementos en la matriz de datos sin preocuparnos de causar un exceso de UI o actualizaciones computarizadas.El extensor diferido puede ser aplicado a cualquier tipo de observables,incluyendo conjuntos de observables y observables computarizados.</target>
        </trans-unit>
        <trans-unit id="fda568a2d060f080b79888ad65ca98b3f5cb075b" translate="yes" xml:space="preserve">
          <source>Now you can bind click like this:</source>
          <target state="translated">Ahora puedes hacer un click como este:</target>
        </trans-unit>
        <trans-unit id="3482f1f45804606e4ae189fe1f25ad32491bef16" translate="yes" xml:space="preserve">
          <source>Now you can bind it like this:</source>
          <target state="translated">Ahora puedes atarlo así:</target>
        </trans-unit>
        <trans-unit id="40d230de5c1460b029face137aa50f89cfff29a6" translate="yes" xml:space="preserve">
          <source>Now you can both read and write the &amp;ldquo;focusedness&amp;rdquo; of an element by binding it to an observable:</source>
          <target state="translated">Ahora puede leer y escribir el &quot;enfoque&quot; de un elemento vincul&amp;aacute;ndolo a un observable:</target>
        </trans-unit>
        <trans-unit id="6de72398a9643fb68b8c419f88d72e0cc3455cae" translate="yes" xml:space="preserve">
          <source>Now you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</source>
          <target state="translated">Ahora puedes cambiar pageIndex y pageSize tantas veces como quieras,y la llamada a Ajax sólo ocurrirá una vez después de que liberes tu hilo de vuelta al tiempo de ejecución de JavaScript.</target>
        </trans-unit>
        <trans-unit id="18f2aeef65d906e4473cfba8e914455277450ce1" translate="yes" xml:space="preserve">
          <source>Now you can include a template in your view like this:</source>
          <target state="translated">Ahora puedes incluir una plantilla en tu vista como esta:</target>
        </trans-unit>
        <trans-unit id="cdd6cfad8e975c0657b6d67e96fe52c3a48e9aa8" translate="yes" xml:space="preserve">
          <source>Now you can use this binding as follows:</source>
          <target state="translated">Ahora puedes usar esta encuadernación de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="4c9b28edefdb5a8470622ecf317b145edc4837c3" translate="yes" xml:space="preserve">
          <source>Now you could bind UI elements to it, e.g.:</source>
          <target state="translated">Ahora podrías unir elementos de UI a él,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="02d8cd1aeb019148b74c77705355b7163631d297" translate="yes" xml:space="preserve">
          <source>Now your binding in UI elements becomes a method call, e.g.:</source>
          <target state="translated">Ahora su unión en elementos de UI se convierte en una llamada de método,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f030ce6c537ab6ebb0bf1ffd14b3a4657684bade" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</source>
          <target state="translated">Ahora,el KO pasará los datos y los objetos de eventos a su función literal,que luego estarán disponibles para ser pasados a su manejador.</target>
        </trans-unit>
        <trans-unit id="bd13b366a6bf0e481a78cb8415ed4850572371a6" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</source>
          <target state="translated">Ahora,el KO pasará el evento a su función literal,que luego estará disponible para ser pasado a su manejador.</target>
        </trans-unit>
        <trans-unit id="75b3699fea4994e40b27cf8acdc9dbd74ac8d3b7" translate="yes" xml:space="preserve">
          <source>Now, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</source>
          <target state="translated">Ahora,un único manejador de eventos se adjunta en un nivel superior y maneja los clics contra cualquier enlace con la clase de eliminación.Este método tiene la ventaja añadida de manejar automáticamente los enlaces adicionales que se añaden dinámicamente al documento (tal vez como resultado de la adición de un elemento a un observableArray).</target>
        </trans-unit>
        <trans-unit id="bd680cea0a442ee897310989fbae69d04e84c88d" translate="yes" xml:space="preserve">
          <source>Now, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.</source>
          <target state="translated">Ahora,acceptedNumericValue sólo contendrá valores numéricos,y cualquier otro valor que se introduzca provocará la aparición de un mensaje de validación en lugar de actualizar acceptedNumericValue.</target>
        </trans-unit>
        <trans-unit id="e0f38308579b18f9d4a6971e8cbcbf8290d174a2" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say the data is updated to be without any typos:</source>
          <target state="translated">Ahora, digamos que los datos se actualizan para que no tengan errores tipogr&amp;aacute;ficos:</target>
        </trans-unit>
        <trans-unit id="540f67e29415bf23f1b5c0759292b5c41747e4c8" translate="yes" xml:space="preserve">
          <source>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.</source>
          <target state="translated">Ahora,moviendo el puntero del ratón sobre o fuera del primer elemento invocará métodos en el modelo de la vista para conmutar los detalles Habilitados observables.El segundo elemento reacciona a los cambios en el valor de detailsEnabled mostrándose u ocultándose.</target>
        </trans-unit>
        <trans-unit id="3736efca9ddde7db65691710604802d1a6d9f093" translate="yes" xml:space="preserve">
          <source>Now, the text will switch between &amp;ldquo;expensive&amp;rdquo; and &amp;ldquo;affordable&amp;rdquo; as needed whenever price changes.</source>
          <target state="translated">Ahora, el texto cambiar&amp;aacute; entre &quot;caro&quot; y &quot;asequible&quot; seg&amp;uacute;n sea necesario cada vez que cambie el precio.</target>
        </trans-unit>
        <trans-unit id="088a5e50ba0e6a14fe36eaa6f26ee4c53c1aeffe" translate="yes" xml:space="preserve">
          <source>Now, to use this component, you can reference it from any other view in your application, either using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or using a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;. Here&amp;rsquo;s a live example that uses it as a custom element:</source>
          <target state="translated">Ahora, para usar este componente, puede hacer referencia a &amp;eacute;l desde cualquier otra vista en su aplicaci&amp;oacute;n, ya sea usando el &lt;a href=&quot;component-binding&quot;&gt;enlace&lt;/a&gt; del componente o usando un &lt;a href=&quot;component-custom-elements&quot;&gt;elemento personalizado&lt;/a&gt; . Aqu&amp;iacute; hay un ejemplo en vivo que lo usa como un elemento personalizado:</target>
        </trans-unit>
        <trans-unit id="4245c3b686b0a2dc1aff4f4de7c87fcd1a33a5a7" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="translated">Ahora, cada vez que el usuario ingresa un nuevo precio, el cuadro de texto se actualiza inmediatamente para mostrarlo formateado con el s&amp;iacute;mbolo de moneda y dos decimales, sin importar en qu&amp;eacute; formato ingresaron el valor. Esto brinda una excelente experiencia de usuario, porque el usuario ve c&amp;oacute;mo el software ha entendido su entrada de datos como un precio. Saben que no pueden ingresar m&amp;aacute;s de dos lugares decimales, porque si lo intentan, los lugares decimales adicionales se eliminan inmediatamente. De manera similar, no pueden ingresar valores negativos, porque la devoluci&amp;oacute;n de llamada de escritura elimina cualquier signo menos.</target>
        </trans-unit>
        <trans-unit id="2f11f252395402a0b2ef2d05d00513a9da6f819b" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac3b49a89e1b1842cca9897c548ac837711b286" translate="yes" xml:space="preserve">
          <source>OK, how do you use it?</source>
          <target state="translated">Bien,¿cómo lo usas?</target>
        </trans-unit>
        <trans-unit id="42801dc107e69330fc6f28652e42c67848f2e3d3" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as &lt;em&gt;observables&lt;/em&gt;, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</source>
          <target state="translated">Bien, ha visto c&amp;oacute;mo crear un modelo de vista b&amp;aacute;sico y c&amp;oacute;mo mostrar una de sus propiedades usando un enlace. Pero uno de los beneficios clave de KO es que actualiza su interfaz de usuario autom&amp;aacute;ticamente cuando cambia el modelo de vista. &amp;iquest;C&amp;oacute;mo puede saber KO cu&amp;aacute;ndo cambian partes de su modelo de vista? Respuesta: debe declarar las propiedades de su modelo como &lt;em&gt;observables&lt;/em&gt; , porque estos son objetos especiales de JavaScript que pueden notificar a los suscriptores sobre cambios y pueden detectar dependencias autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="49ef41d692a31c86e07e70c90965e70e376a7d17" translate="yes" xml:space="preserve">
          <source>Observable Arrays</source>
          <target state="translated">Matrices observables</target>
        </trans-unit>
        <trans-unit id="46996089e8555e78352bfb82f74492b629adadd3" translate="yes" xml:space="preserve">
          <source>Observable arrays</source>
          <target state="translated">Matrices observables</target>
        </trans-unit>
        <trans-unit id="ae2926058ff9077b5ef1fa67cef194213c7bb29a" translate="yes" xml:space="preserve">
          <source>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:</source>
          <target state="translated">Las matrices observables generadas por el plugin de mapeo se aumentan con algunas funciones que pueden hacer uso de las teclas de mapeo:</target>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="b11d034f48ad50b05bcdbc51fb2bc638d49916bb" translate="yes" xml:space="preserve">
          <source>Observables and dependency tracking</source>
          <target state="translated">Observables y seguimiento de la dependencia</target>
        </trans-unit>
        <trans-unit id="621445c3740dea16b530b18f93e077809839e366" translate="yes" xml:space="preserve">
          <source>Observing only certain properties using &amp;ldquo;observe&amp;rdquo;</source>
          <target state="translated">Observando solo ciertas propiedades usando &quot;observar&quot;</target>
        </trans-unit>
        <trans-unit id="5820d44b10477929b579ab80e1dfa0b99895aa33" translate="yes" xml:space="preserve">
          <source>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&amp;rsquo;s core value types. You can define custom functions on any of the following types:</source>
          <target state="translated">De vez en cuando, puede encontrar oportunidades para optimizar su c&amp;oacute;digo adjuntando nueva funcionalidad a los tipos de valores centrales de Knockout. Puede definir funciones personalizadas en cualquiera de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="31449567d7f21edc1facbf4447d941d2b4798e0a" translate="yes" xml:space="preserve">
          <source>Of course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;:</source>
          <target state="translated">Por supuesto, dentro de la devoluci&amp;oacute;n de llamada de creaci&amp;oacute;n puede hacer otra llamada a ko.mapping.fromJS si lo desea. Un caso de uso t&amp;iacute;pico podr&amp;iacute;a ser si desea aumentar el objeto JavaScript original con algunos &lt;a href=&quot;computedobservables&quot;&gt;observables computados&lt;/a&gt; adicionales :</target>
        </trans-unit>
        <trans-unit id="0ab11f1d7ae1b763bfdbe3807e0dd9ad83af6511" translate="yes" xml:space="preserve">
          <source>Of course, this is a lot of code at first glance, but once you&amp;rsquo;ve created your custom bindings they can very easily be reused in many places.</source>
          <target state="translated">Por supuesto, esto es mucho c&amp;oacute;digo a primera vista, pero una vez que haya creado sus enlaces personalizados, pueden reutilizarse f&amp;aacute;cilmente en muchos lugares.</target>
        </trans-unit>
        <trans-unit id="078756006ae7a0012d20c159834f8a64afd1f3de" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) &amp;ndash; doing this puts them into a group where only one can be selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f700094b19d2adf8500f72e2a84b3d54353191" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) - doing this puts them into a group where only one can be selected.</source>
          <target state="translated">Por supuesto, esto es m&amp;aacute;s &amp;uacute;til cuando tiene varios elementos de bot&amp;oacute;n de opci&amp;oacute;n vinculados a una &amp;uacute;nica propiedad de modelo. Para asegurarse de que solo &lt;em&gt;uno&lt;/em&gt; de esos botones de opci&amp;oacute;n se pueda marcar a la vez, debe establecer todos sus atributos de nombre en un valor com&amp;uacute;n arbitrario (por ejemplo, el valor de grupo de sabor en el ejemplo anterior); hacer esto los coloca en un grupo donde solo se puede seleccionar uno.</target>
        </trans-unit>
        <trans-unit id="c68f1c87405be42eacbbbce0c48e9cb553450844" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.1.0).</source>
          <target state="translated">Por supuesto,x.y.z debe ser reemplazado por el número de versión del script Knockout que estás cargando (por ejemplo,knockout-3.1.0).</target>
        </trans-unit>
        <trans-unit id="a449e9eab7822a64523bbf6509430f2bd5f4edd2" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.5.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa33e822518a764cd6aa37dbe83b7633c72e02d" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.</source>
          <target state="translated">Por supuesto,se puede anidar arbitrariamente cualquier número de fijaciones de frente junto con otras fijaciones de flujo de control como si y con.</target>
        </trans-unit>
        <trans-unit id="a81c8bc825594ecd549001af937392796036a625" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with and using bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f4b8ea9e954eebaa70e0a9c65d26766627d86b" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="translated">Por supuesto, puede anidar arbitrariamente con enlaces junto con los otros enlaces de flujo de control como &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; y &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3aa665242655dd6d40a7753ba8a1bef582d3cc" translate="yes" xml:space="preserve">
          <source>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</source>
          <target state="translated">Por supuesto,puede crear cadenas enteras de observables computarizados si lo desea.Por ejemplo,podrías tener:</target>
        </trans-unit>
        <trans-unit id="3b3b30a86f9e0ac4c5bc2f098d8abb20f874f834" translate="yes" xml:space="preserve">
          <source>Of course, you don&amp;rsquo;t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</source>
          <target state="translated">Por supuesto, no tiene que preocuparse por liberar ning&amp;uacute;n controlador de eventos creado por enlaces Knockout est&amp;aacute;ndar en su vista, ya que KO los anula autom&amp;aacute;ticamente cuando se eliminan los elementos.</target>
        </trans-unit>
        <trans-unit id="b7bdef4ca5fa385742d68cfa6579c30b6c61548d" translate="yes" xml:space="preserve">
          <source>On this page, you&amp;rsquo;ll learn about the first of these three. But before that, let&amp;rsquo;s examine the MVVM pattern and the concept of a &lt;em&gt;view model&lt;/em&gt;.</source>
          <target state="translated">En esta p&amp;aacute;gina, aprender&amp;aacute; sobre el primero de estos tres. Pero antes de eso, examinemos el patr&amp;oacute;n MVVM y el concepto de &lt;em&gt;modelo de vista&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1bc6631468dfada790b80fb194db5f58e531526" translate="yes" xml:space="preserve">
          <source>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</source>
          <target state="translated">Opcionalmente,puede pasar un segundo parámetro para definir qué parte del documento desea buscar los atributos de la unión de datos.Por ejemplo,ko.applyBindings(myViewModel,document.getElementById('someElementId')).Esto restringe la activación al elemento con ID someElementId y sus descendientes,lo cual es útil si quieres tener múltiples modelos de vista y asociar cada uno con una región diferente de la página.</target>
        </trans-unit>
        <trans-unit id="1765a06342825b17a9e403b215e90bde7a3b1c92" translate="yes" xml:space="preserve">
          <source>Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).</source>
          <target state="translated">Opcionalmente,su clase de modelo de vista puede tener una función de eliminación.Si se implementa,Knockout la llamará siempre que el componente se esté desmontando y eliminando del DOM (por ejemplo,porque el elemento correspondiente se ha eliminado de un anteproyecto,o si la unión se ha vuelto falsa).</target>
        </trans-unit>
        <trans-unit id="a4e4c99b9180d995ef38e38e86d46c2c354b0131" translate="yes" xml:space="preserve">
          <source>Or if you really don&amp;rsquo;t like the hackiness of the document.createElement call, then you could use a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:</source>
          <target state="translated">O si realmente no le gusta la pirater&amp;iacute;a de la llamada document.createElement, entonces podr&amp;iacute;a usar un &lt;a href=&quot;component-binding&quot;&gt;enlace de componente&lt;/a&gt; para su componente de nivel superior en lugar de un elemento personalizado. Siempre que todos los dem&amp;aacute;s componentes est&amp;eacute;n registrados antes de la llamada a ko.applyBindings, se pueden usar como elementos personalizados en IE6-8 sin m&amp;aacute;s problemas:</target>
        </trans-unit>
        <trans-unit id="4c54970fdc4cfe5ce955d0d99cddf7a056c2d8f2" translate="yes" xml:space="preserve">
          <source>Or, at least call document.createElement('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements. You can ignore the result of the createElement call &amp;mdash; all that matters is that you have called it.</source>
          <target state="translated">O, al menos, llame a document.createElement ('su-componente') &lt;em&gt;antes de que&lt;/em&gt; el analizador HTML vea cualquier elemento &amp;lt;your-component&amp;gt;. Puede ignorar el resultado de la llamada createElement; todo lo que importa es que lo haya llamado.</target>
        </trans-unit>
        <trans-unit id="888fa89b9dae94f674ec75254af5184f71fd7fb9" translate="yes" xml:space="preserve">
          <source>Or, if the component has no viewmodel, then the view is bound to any params you&amp;rsquo;ve supplied to the component binding.</source>
          <target state="translated">O, si el componente no tiene modelo de vista, entonces la vista est&amp;aacute; vinculada a cualquier par&amp;aacute;metro que haya proporcionado al enlace del componente.</target>
        </trans-unit>
        <trans-unit id="4ba0856e67eb87e7f52493db1a23ca2ca82c78f6" translate="yes" xml:space="preserve">
          <source>Or, if you don&amp;rsquo;t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</source>
          <target state="translated">O, si no desea usar jQuery, puede usar cualquier otro mecanismo para cargar o guardar datos JSON. Entonces, todo lo que Knockout necesita para ayudarlo es:</target>
        </trans-unit>
        <trans-unit id="f699ec4a263d96ea6e8330f504cbc76acb04a6da" translate="yes" xml:space="preserve">
          <source>Or, if you just want the plain JavaScript object graph &lt;em&gt;before&lt;/em&gt; serialization, use ko.toJS as follows:</source>
          <target state="translated">O, si solo desea el gr&amp;aacute;fico de objetos de JavaScript simple &lt;em&gt;antes de la&lt;/em&gt; serializaci&amp;oacute;n, use ko.toJS de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0f545ea154ca17421845c1c4d49c0c277020bb7c" translate="yes" xml:space="preserve">
          <source>Other browsers, and newer versions of IE, don&amp;rsquo;t have this quirk.</source>
          <target state="translated">Otros navegadores y versiones m&amp;aacute;s recientes de IE no tienen esta peculiaridad.</target>
        </trans-unit>
        <trans-unit id="a7d69219a1d86b1de7eaa38435a5ef6a295349c2" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="translated">Otras tecnolog&amp;iacute;as pueden depender de la suposici&amp;oacute;n de que ciertos elementos tienen nombres, aunque los nombres pueden ser irrelevantes cuando usa KO. Por ejemplo, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; actualmente solo validar&amp;aacute; elementos que tengan nombres. Para usar esto con una IU Knockout, a veces es necesario aplicar el enlace uniqueName para evitar confundir la validaci&amp;oacute;n de jQuery. Vea &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;un ejemplo del uso de jQuery Validation con KO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efa09ae2cb2e40a26065664566609723294929" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76426a4b4527523a89c8447c24b37b42bba21f" translate="yes" xml:space="preserve">
          <source>Overriding the clean-up of external data</source>
          <target state="translated">Anulando la limpieza de los datos externos</target>
        </trans-unit>
        <trans-unit id="9c6c53d0c3ba99a8159d80012914470bb2bd02f8" translate="yes" xml:space="preserve">
          <source>Overview of AMD</source>
          <target state="translated">Visión general de la DMA</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="ee9bc64679c883d8315ef21591e760cbc38b8e61" translate="yes" xml:space="preserve">
          <source>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you&amp;rsquo;re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,</source>
          <target state="translated">Pase una referencia de funci&amp;oacute;n (ya sea una funci&amp;oacute;n literal o proporcione el nombre de una funci&amp;oacute;n en su modelo de vista), y Knockout la invocar&amp;aacute; inmediatamente despu&amp;eacute;s de renderizar o volver a renderizar su plantilla. Si est&amp;aacute; utilizando foreach, Knockout invocar&amp;aacute; su devoluci&amp;oacute;n de llamada afterRender para cada elemento agregado a su matriz observable. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="2a4fc664fb015dd2b90366bae7b7c6166a290c0f" translate="yes" xml:space="preserve">
          <source>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</source>
          <target state="translated">Pasa la matriz sobre la que deseas iterar.La encuadernación producirá una sección de marcado para cada entrada.</target>
        </trans-unit>
        <trans-unit id="ac917217788ea4daf427e3524d9e686c7fae6951" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.</source>
          <target state="translated">Pasar true (o algún valor que se evalúe como verdadero)para permitir la vinculación de uniqueName,como en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="48fbf79eab4d275311cd306a9da00e04a2da8f50" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</source>
          <target state="translated">Pasar verdadero (o algún valor que se evalúe como verdadero)para enfocar el elemento asociado.De lo contrario,el elemento asociado se desenfocará.</target>
        </trans-unit>
        <trans-unit id="b9cfb6f55eaea0baeb940c302cc0775a2e4e29f0" translate="yes" xml:space="preserve">
          <source>Passing markup into components</source>
          <target state="translated">Pasar el marcado a los componentes</target>
        </trans-unit>
        <trans-unit id="7b31412042fa68bceb2962653f184dcb45a1c94c" translate="yes" xml:space="preserve">
          <source>Passing observable expressions</source>
          <target state="translated">Pasando expresiones observables</target>
        </trans-unit>
        <trans-unit id="3157744f3e6488a569fb33f59900039dd87730b5" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
          <target state="translated">Los parámetros de paso</target>
        </trans-unit>
        <trans-unit id="52fe29993c9eadbd173dbd6bdcce3efe7de4a21e" translate="yes" xml:space="preserve">
          <source>Performance is O(1) in most cases, i.e., there&amp;rsquo;s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you&amp;rsquo;ve made an arbitrary change without using a typical array mutation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30396c874cdc27bd19277aa1a80c77188378ef" translate="yes" xml:space="preserve">
          <source>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout&amp;rsquo;s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</source>
          <target state="translated">Tenga en cuenta que, a partir de diciembre de 2011, jQuery.tmpl ya no se encuentra en desarrollo activo. Recomendamos el uso de plantillas nativas basadas en DOM de Knockout (es decir, los enlaces foreach, if, with, etc.) en lugar de jQuery.tmpl o cualquier otro motor de plantillas basado en cadenas.</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="24a0be8dab4fe687c8ad437ae1be347c7c275ab3" translate="yes" xml:space="preserve">
          <source>Prepopulating an observableArray</source>
          <target state="translated">Preparando un observableArray</target>
        </trans-unit>
        <trans-unit id="30d1738d650def938c652b581eb2ab8e9e23bac2" translate="yes" xml:space="preserve">
          <source>Preprocessing DOM nodes</source>
          <target state="translated">Preprocesamiento de los nodos DOM</target>
        </trans-unit>
        <trans-unit id="3bd28988e0d739a767c1940c87323328cfd0452d" translate="yes" xml:space="preserve">
          <source>Preprocessing Reference</source>
          <target state="translated">Referencia de preprocesamiento</target>
        </trans-unit>
        <trans-unit id="47b4f8689a05bc9cca63e4c44017f14efdaadb92" translate="yes" xml:space="preserve">
          <source>Preprocessing binding strings</source>
          <target state="translated">Preprocesamiento de las cuerdas de unión</target>
        </trans-unit>
        <trans-unit id="72734b1cb5286fcdc2e795102ddabad4a96ba527" translate="yes" xml:space="preserve">
          <source>Pretty simple, really.</source>
          <target state="translated">Bastante simple,en realidad.</target>
        </trans-unit>
        <trans-unit id="02097511df2d0e39c9337e94983004dd3194c3a0" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout&amp;rsquo;s &lt;a href=&quot;microtasks&quot;&gt;microtasks&lt;/a&gt; to ensure asynchronicity, and so will generally perform as well as synchronous loading.</source>
          <target state="translated">Antes de Knockout 3.4.0, es posible que deba usar la carga s&amp;iacute;ncrona para evitar m&amp;uacute;ltiples reflujos de DOM al incluir muchos componentes simult&amp;aacute;neamente (como con el enlace foreach). Con Knockout 3.4.0, los componentes utilizan las &lt;a href=&quot;microtasks&quot;&gt;microtareas&lt;/a&gt; de Knockout para garantizar la asincron&amp;iacute;a y, por lo tanto, generalmente funcionar&amp;aacute;n tan bien como la carga sincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="ea02aeead6e71fc6cbe55e718e12cf9185abfa29" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.5.0, the default behavior was to hide destroyed items. To use this behavior as the default in newer versions, you can set a global option: ko.options.foreachHidesDestroyed = true. Then, if you want to show destroyed items for a specific foreach binding, you would set includeDestroyed: true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2145824730e5c1b8fb6fa87d2dd101b9cb427" translate="yes" xml:space="preserve">
          <source>Pure computed observables</source>
          <target state="translated">Observables puros computarizados</target>
        </trans-unit>
        <trans-unit id="b4ce509d140c0943b0fb6b3aa19d560a50d452fc" translate="yes" xml:space="preserve">
          <source>Pure computeds were introduced in Knockout 3.2.0. See also: &lt;a href=&quot;computed-pure&quot;&gt;more about pure computed observables&lt;/a&gt;.</source>
          <target state="translated">Los c&amp;aacute;lculos puros se introdujeron en Knockout 3.2.0. Ver tambi&amp;eacute;n: &lt;a href=&quot;computed-pure&quot;&gt;m&amp;aacute;s sobre observables computados puros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="57f47271f3869d1768dcebd5706b5e412a9e5dd1" translate="yes" xml:space="preserve">
          <source>Rate-limiting observable notifications</source>
          <target state="translated">Notificaciones observables que limitan la tasa</target>
        </trans-unit>
        <trans-unit id="fe99aebaa6323f9c1f185c4c64c2f1a0b751fa1b" translate="yes" xml:space="preserve">
          <source>Reacting to a specific observable event with &amp;ldquo;ko.when&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109ca37b53291d60621572a50045d0cd051c1b2b" translate="yes" xml:space="preserve">
          <source>Reading and writing observables</source>
          <target state="translated">Los observables de lectura y escritura</target>
        </trans-unit>
        <trans-unit id="0a460971e455292dd35a366b845f6510cca16999" translate="yes" xml:space="preserve">
          <source>Reading information from an observableArray</source>
          <target state="translated">Leyendo la información de un observableArray</target>
        </trans-unit>
        <trans-unit id="10a415b94b161f38c600daa4d4bb513ecf982216" translate="yes" xml:space="preserve">
          <source>Recursive task limit</source>
          <target state="translated">Límite de tareas recursivas</target>
        </trans-unit>
        <trans-unit id="43f5384571767bbaaa6fd7375d219904895bb1b7" translate="yes" xml:space="preserve">
          <source>Registering a callback on the disposal of an element</source>
          <target state="translated">El registro de una llamada sobre la eliminación de un elemento</target>
        </trans-unit>
        <trans-unit id="9a480de52dbedb53c2cf2350afee5ac13630029e" translate="yes" xml:space="preserve">
          <source>Registering components as a single AMD module</source>
          <target state="translated">Registrando los componentes como un único módulo AMD</target>
        </trans-unit>
        <trans-unit id="35b2eb936781d5e3694cfbb0f326c5c7048ea539" translate="yes" xml:space="preserve">
          <source>Registering components as a viewmodel/template pair</source>
          <target state="translated">Registrar los componentes como un par de modelo/plantilla</target>
        </trans-unit>
        <trans-unit id="dbdca1da5454335dd25004eb3b50c8f66e895af6" translate="yes" xml:space="preserve">
          <source>Registering custom component loaders</source>
          <target state="translated">Registro de cargadores de componentes personalizados</target>
        </trans-unit>
        <trans-unit id="bbd0999bf6bb00d22dc5e82c04cc79930c05379a" translate="yes" xml:space="preserve">
          <source>Registering custom elements</source>
          <target state="translated">Registro de elementos personalizados</target>
        </trans-unit>
        <trans-unit id="1532215d29dce0afe9ba8e71d6fd4a5554bf38e2" translate="yes" xml:space="preserve">
          <source>Registering your binding</source>
          <target state="translated">Registrando su encuadernación</target>
        </trans-unit>
        <trans-unit id="30a362d04fc57f7bc49c1be4cc35fc032c5bc523" translate="yes" xml:space="preserve">
          <source>Registers a component. See: &lt;a href=&quot;component-registration&quot;&gt;full documentation&lt;/a&gt;.</source>
          <target state="translated">Registra un componente. Ver: &lt;a href=&quot;component-registration&quot;&gt;documentaci&amp;oacute;n completa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e806ea593f70ec532713b2e31cb54e34ae2fbb61" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).</source>
          <target state="translated">Elimina todos los nodos infantiles del elemento real o virtual containerElem (limpiando cualquier dato asociado a ellos para evitar fugas de memoria).</target>
        </trans-unit>
        <trans-unit id="55eb1f75a4466755cbf9da8ee93eb912dc9b1c70" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.</source>
          <target state="translated">Elimina todos los nodos hijos del elemento real o virtual containerElem (en el proceso,limpiando cualquier dato asociado a ellos para evitar fugas de memoria),y luego inserta todos los nodos de arrayOfNodes como sus nuevos hijos.</target>
        </trans-unit>
        <trans-unit id="aa97aaf82420ccf3d840fd847ac4d33d6adbd799" translate="yes" xml:space="preserve">
          <source>Removes the named component from the registry. Or if no such component was registered, does nothing.</source>
          <target state="translated">Elimina el componente nombrado del registro.O si no se registró tal componente,no hace nada.</target>
        </trans-unit>
        <trans-unit id="0890f779408fa8ac76a438a26ba53f60dda91ecf" translate="yes" xml:space="preserve">
          <source>RequireJs Download</source>
          <target state="translated">RequiereJs Descargar</target>
        </trans-unit>
        <trans-unit id="00f09c861f9b24affecf1566366551a836249bc6" translate="yes" xml:space="preserve">
          <source>RequireJs can be downloaded from &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;.</source>
          <target state="translated">RequireJs se puede descargar desde &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353d8d344e6b162e4c17b4210bea67369e7ef3b0" translate="yes" xml:space="preserve">
          <source>Returns the first child of the real or virtual element containerElem, or null if there are no children.</source>
          <target state="translated">Devuelve el primer hijo del elemento real o virtual containerElem,o nulo si no hay hijos.</target>
        </trans-unit>
        <trans-unit id="f44b98d7f68f260183d81c591bdaf943f8bbc926" translate="yes" xml:space="preserve">
          <source>Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.</source>
          <target state="translated">Devuelve el nodo hermano que sigue al nodo en su elemento padre real o virtual,o nulo si no hay hermano siguiente.</target>
        </trans-unit>
        <trans-unit id="4bb189a069efd2411fee0be779b73d0bb87f5573" translate="yes" xml:space="preserve">
          <source>Returns true if a component with the specified name is already registered; false otherwise.</source>
          <target state="translated">Devuelve verdadero si un componente con el nombre especificado ya está registrado;falso en caso contrario.</target>
        </trans-unit>
        <trans-unit id="4e0da6a7855830c066dbda602feb809af4d79023" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Note 2&lt;/a&gt; below. Note that valueAllowUnset is only applicable when using value to control selection on a &amp;lt;select&amp;gt; element. On other elements it has no effect.</source>
          <target state="translated">Consulte la &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Nota 2 a&lt;/a&gt; continuaci&amp;oacute;n. Tenga en cuenta que valueAllowUnset solo es aplicable cuando se usa value para controlar la selecci&amp;oacute;n en un elemento &amp;lt;select&amp;gt;. Sobre otros elementos no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="7a4086bf02e9470ff9beaf89243d77e8723e08b3" translate="yes" xml:space="preserve">
          <source>See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&amp;rsquo; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.</source>
          <target state="translated">Consulte el Ejemplo 3 anterior para ver c&amp;oacute;mo puede vincular opciones a una matriz de objetos JavaScript arbitrarios, no solo cadenas. En este caso, debe elegir cu&amp;aacute;l de las propiedades de los objetos debe mostrarse como texto en la lista desplegable o en la lista de selecci&amp;oacute;n m&amp;uacute;ltiple. El ejemplo 3 muestra c&amp;oacute;mo puede especificar ese nombre de propiedad pasando un par&amp;aacute;metro adicional llamado optionsText.</target>
        </trans-unit>
        <trans-unit id="627ede17723b7a1dcb26a936f7757623f8efd898" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;a longer list of style names and their JavaScript equivalents&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;una lista m&amp;aacute;s larga de nombres de estilo y sus equivalentes de JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60845dd06d2f273308891baec64862cb1ed3b782" translate="yes" xml:space="preserve">
          <source>See later on this page for an API reference.</source>
          <target state="translated">Véase más adelante en esta página una referencia a la API.</target>
        </trans-unit>
        <trans-unit id="bf68dcb1970e76f58db5ceb232524856770b8e5d" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;How to enable custom elements with names that don&amp;rsquo;t correspond to explicitly registered components&lt;/a&gt;</source>
          <target state="translated">Consulte: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;C&amp;oacute;mo habilitar elementos personalizados con nombres que no corresponden a componentes registrados expl&amp;iacute;citamente&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95713d3429a1266b03118a0b69f2eaedb23716fe" translate="yes" xml:space="preserve">
          <source>Sequence of calls</source>
          <target state="translated">Secuencia de llamadas</target>
        </trans-unit>
        <trans-unit id="f85944bee806bc0827acaf6829524bc912923c28" translate="yes" xml:space="preserve">
          <source>Setting computed observables or manual subscriptions to dispose automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a31297954712265cfbf6c89f922aec8df4a41" translate="yes" xml:space="preserve">
          <source>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</source>
          <target state="translated">Sintaxis de la taquigrafía:Si sólo proporciona un valor de cadena,KO lo interpretará como el ID de una plantilla para renderizar.Los datos que suministre a la plantilla serán su actual objeto modelo.</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">Los efectos secundarios</target>
        </trans-unit>
        <trans-unit id="e6ea4fd88d422a61726a7ab7fbe12390130c4662" translate="yes" xml:space="preserve">
          <source>Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects&amp;rsquo; properties should be used to set the value attribute on the &amp;lt;option&amp;gt; elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the &amp;lt;option&amp;gt; element&amp;rsquo;s value attribute.</source>
          <target state="translated">De manera similar a optionsText, tambi&amp;eacute;n puede pasar un par&amp;aacute;metro adicional llamado optionsValue para especificar cu&amp;aacute;l de las propiedades de los objetos se debe usar para establecer el atributo de valor en los elementos &amp;lt;option&amp;gt; que genera KO. Tambi&amp;eacute;n puede especificar una funci&amp;oacute;n de JavaScript para determinar este valor. Esta funci&amp;oacute;n recibir&amp;aacute; el elemento seleccionado como su &amp;uacute;nico argumento y deber&amp;iacute;a devolver una cadena para usar para el atributo de valor del elemento &amp;lt;option&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="2a3bedd0f29a85642c5a7d68ff7d9693c61a907d" translate="yes" xml:space="preserve">
          <source>Similarly, you can use $parent to refer to data from outside the foreach, e.g.:</source>
          <target state="translated">Del mismo modo,se puede utilizar $parent para referirse a los datos de fuera del foreach,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="650503158b05d9103c9329aa587f1f1317a8e97b" translate="yes" xml:space="preserve">
          <source>Simply putting an object into an observableArray doesn&amp;rsquo;t make all of that object&amp;rsquo;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&amp;rsquo;s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</source>
          <target state="translated">Simplemente poner un objeto en un observableArray no hace que todas las propiedades de ese objeto sean observables. Por supuesto, puede hacer que esas propiedades sean observables si lo desea, pero esa es una elecci&amp;oacute;n independiente. Un observableArray solo rastrea qu&amp;eacute; objetos contiene y notifica a los oyentes cuando se agregan o eliminan objetos.</target>
        </trans-unit>
        <trans-unit id="abf2e06137216103f9b100bf2bc6e09236071fb4" translate="yes" xml:space="preserve">
          <source>Since Browserify is a build-time tool, it doesn&amp;rsquo;t really need any special integration with KO components, and there&amp;rsquo;s no need to implement any kind of custom component loader to work with it. You can simply use Browserify&amp;rsquo;s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</source>
          <target state="translated">Dado que Browserify es una herramienta de tiempo de compilaci&amp;oacute;n, realmente no necesita ninguna integraci&amp;oacute;n especial con los componentes KO, y no es necesario implementar ning&amp;uacute;n tipo de cargador de componentes personalizados para trabajar con &amp;eacute;l. Simplemente puede usar las declaraciones require de Browserify para capturar instancias de sus modelos de vista de componentes, luego registrarlos expl&amp;iacute;citamente, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="010c57fd25ed1704f31800fad07288ef30d11c0d" translate="yes" xml:space="preserve">
          <source>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</source>
          <target state="translated">Dado que Knockout procesa la cola de microtareas hasta que está vacía,sin ceder a los eventos externos,las numerosas o largas tareas podrían hacer que la página del navegador no responda.Knockout previene la recursión infinita cancelando todas las tareas restantes si detecta un alto nivel de recursión.Por ejemplo,las siguientes eventualmente se detendrán y arrojarán un error:</target>
        </trans-unit>
        <trans-unit id="e12616501c65e2d78b083723430a1a67a2a4941a" translate="yes" xml:space="preserve">
          <source>Since document fragments can have multiple top-level nodes, the &lt;em&gt;entire&lt;/em&gt; document fragment (not just descendants of top-level nodes) is treated as the component template.</source>
          <target state="translated">Dado que los fragmentos de documentos pueden tener varios nodos de nivel superior, &lt;em&gt;todo el&lt;/em&gt; fragmento de documento (no solo los descendientes de los nodos de nivel superior) se trata como la plantilla de componente.</target>
        </trans-unit>
        <trans-unit id="bd18b758f5b6eba86bebba7b461201774c396857" translate="yes" xml:space="preserve">
          <source>Since evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.</source>
          <target state="translated">Dado que la evaluación de myExpr implica la lectura de un observable (useObservable1),el KO suministrará el parámetro al componente como una propiedad calculada.</target>
        </trans-unit>
        <trans-unit id="03be85be12c780e8cd251d6eb6bc1adf4b6ad284" translate="yes" xml:space="preserve">
          <source>Since the dependency on the template is explicitly stated in the define call, this automatically works with the &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js optimizer&lt;/a&gt; or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.</source>
          <target state="translated">Dado que la dependencia de la plantilla se indica expl&amp;iacute;citamente en la llamada de definici&amp;oacute;n, esto funciona autom&amp;aacute;ticamente con el &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;optimizador r.js&lt;/a&gt; o herramientas de agrupaci&amp;oacute;n similares. Por lo tanto, todo el componente (viewmodel plus template) se puede incluir trivialmente en un archivo de paquete durante un paso de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="224aadfbf82f9551d1965c5a2c5ff4d289869d3f" translate="yes" xml:space="preserve">
          <source>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</source>
          <target state="translated">Como las propiedades del modelo de vista son observables,KO actualizará automáticamente los elementos HTML cada vez que esas propiedades cambien.</target>
        </trans-unit>
        <trans-unit id="b6b795bc25ad13bca901cb739b9e575d5ba5241f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad2a3557f290cc16325b7dad71154f1a20332d" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value using innerText or textContent instead.</source>
          <target state="translated">Dado que este enlace establece el contenido de su elemento usando innerHTML, debe tener cuidado de no usarlo con valores de modelo que no sean de confianza, porque eso podr&amp;iacute;a abrir la posibilidad de un ataque de inyecci&amp;oacute;n de script. Si no puede garantizar que el contenido sea seguro para mostrar (por ejemplo, si se basa en la entrada de un usuario diferente que se almacen&amp;oacute; en su base de datos), entonces puede usar &lt;a href=&quot;text-binding&quot;&gt;el enlace de texto&lt;/a&gt; , que establecer&amp;aacute; el valor del texto del elemento usando innerText o textContent en su lugar.</target>
        </trans-unit>
        <trans-unit id="bd93df4e4321804a588bbd3af3830ed05cdb095f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your text value using a text node, it&amp;rsquo;s safe to set any string value without risking HTML or script injection. For example, if you wrote:</source>
          <target state="translated">Dado que este enlace establece su valor de texto usando un nodo de texto, es seguro establecer cualquier valor de cadena sin arriesgar HTML o inyecci&amp;oacute;n de script. Por ejemplo, si escribi&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="3ef8a4666dd8f23e26196f0af5791e8341741188" translate="yes" xml:space="preserve">
          <source>Since this computed is declared to be &lt;em&gt;pure&lt;/em&gt; (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</source>
          <target state="translated">Dado que este c&amp;aacute;lculo se declara &lt;em&gt;puro&lt;/em&gt; (es decir, su evaluador no modifica directamente otros objetos o estados), Knockout puede administrar de manera m&amp;aacute;s eficiente su reevaluaci&amp;oacute;n y uso de memoria. Knockout lo suspender&amp;aacute; o liberar&amp;aacute; autom&amp;aacute;ticamente si ning&amp;uacute;n otro c&amp;oacute;digo tiene una dependencia activa en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="eec92e863ead404e06db453854298b7f7aeeb964" translate="yes" xml:space="preserve">
          <source>Skipping the binding value</source>
          <target state="translated">Saltando el valor vinculante</target>
        </trans-unit>
        <trans-unit id="5a0401febcbb91e5467f60a83d13d63f45dbb325" translate="yes" xml:space="preserve">
          <source>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: &lt;strong&gt;Knockout will not restart evaluation of a computed while it is already evaluating&lt;/strong&gt;. This is very unlikely to affect your code. It&amp;rsquo;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.</source>
          <target state="translated">Entonces, &amp;iquest;qu&amp;eacute; hace Knockout si tiene un ciclo en su gr&amp;aacute;fico de dependencia? Evita bucles infinitos aplicando la siguiente regla: &lt;strong&gt;Knockout no reiniciar&amp;aacute; la evaluaci&amp;oacute;n de un calculado mientras ya est&amp;aacute; evaluando&lt;/strong&gt; . Es muy poco probable que esto afecte su c&amp;oacute;digo. Es relevante en dos situaciones: cuando dos observables calculados dependen el uno del otro (solo es posible si uno o ambos usan la opci&amp;oacute;n deferEvaluation), o cuando un observable calculado escribe en otro observable del cual tiene una dependencia (ya sea directamente o mediante una dependencia cadena). Si necesita usar uno de estos patrones y desea evitar por completo la dependencia circular, puede usar la funci&amp;oacute;n de inspecci&amp;oacute;n descrita anteriormente.</target>
        </trans-unit>
        <trans-unit id="f6f08edfde52faf5dc68f34cf119dab791fd12c1" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution.</source>
          <target state="translated">Por lo tanto, Knockout no solo detecta las dependencias la primera vez que se ejecuta el evaluador, sino que las vuelve a detectar cada vez. Esto significa, por ejemplo, que las dependencias pueden variar din&amp;aacute;micamente: la dependencia A podr&amp;iacute;a determinar si el observable calculado tambi&amp;eacute;n depende de B o C. Entonces, solo se volver&amp;aacute; a evaluar cuando A o su elecci&amp;oacute;n actual de B o C cambie. No tiene que declarar dependencias: se determinan en tiempo de ejecuci&amp;oacute;n a partir de la ejecuci&amp;oacute;n del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="a1add6969e68c367f948e300f5de00d8ce1226a9" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution. If the evaluator doesn&amp;rsquo;t access any obsevables, the computed observable will have no dependencies and won&amp;rsquo;t ever need to call the evaluator function again. In that case, to save resources, the computed observable will be automatically &amp;ldquo;disposed.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6039155cfd6e7342a4bb866968884c937aafd1" translate="yes" xml:space="preserve">
          <source>So, if you would like to map a JavaScript object to this, you can pass this as the third argument:</source>
          <target state="translated">Así que,si quieres mapear un objeto de JavaScript a esto,puedes pasar esto como el tercer argumento:</target>
        </trans-unit>
        <trans-unit id="3c47887016b47f8753b43bbda895cb4a52d3627b" translate="yes" xml:space="preserve">
          <source>So, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.</source>
          <target state="translated">Así que,ko.componentes.cargadores es un conjunto que contiene todos los cargadores actualmente habilitados.Por defecto,este array contiene un solo elemento:ko.components.defaultLoader.Para agregar cargadores adicionales,simplemente insértalos en el array ko.components.loaders.</target>
        </trans-unit>
        <trans-unit id="bcadd6a9a819e98e876d51538df845e3924045c1" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s this _destroy thing all about? It&amp;rsquo;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</source>
          <target state="translated">Entonces, &amp;iquest;de qu&amp;eacute; se trata esto _destroy? Solo es realmente interesante para los desarrolladores de Rails. La convenci&amp;oacute;n en Rails es que, cuando pasa a una acci&amp;oacute;n un gr&amp;aacute;fico de objeto JSON, el marco puede convertirlo autom&amp;aacute;ticamente en un gr&amp;aacute;fico de objeto ActiveRecord y luego guardarlo en su base de datos. Sabe cu&amp;aacute;les de los objetos ya est&amp;aacute;n en su base de datos y emite las instrucciones INSERT o UPDATE correctas. Para decirle al marco que ELIMINE un registro, simplemente m&amp;aacute;rquelo con _destroy establecido en verdadero.</target>
        </trans-unit>
        <trans-unit id="0cc17b6b6ff109ca3571a9c612acc5269c5e86c5" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using &lt;em&gt;mapping options&lt;/em&gt;. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don&amp;rsquo;t need to specify them again.</source>
          <target state="translated">A veces puede ser necesario tener m&amp;aacute;s control sobre c&amp;oacute;mo se realiza el mapeo. Esto se logra usando &lt;em&gt;opciones de mapeo&lt;/em&gt; . Se pueden especificar durante la llamada ko.mapping.fromJS. En llamadas posteriores, no es necesario que los vuelva a especificar.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
