<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="c05d2d3e27ddcc721da61cee1a36f988089cfb17" translate="yes" xml:space="preserve">
          <source>For control over canceling or setting a timeout on a handshake, use the Dialer's DialContext method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c2ce00eb37f48324b8088e1562b15a52ee733a" translate="yes" xml:space="preserve">
          <source>For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:</source>
          <target state="translated">Para controlar los proxies,la configuración de TLS,keep-alives,la compresión y otros ajustes,crea un Transporte:</target>
        </trans-unit>
        <trans-unit id="993c8adfef972ba1b068a5731b030b2c3e0c3fdb" translate="yes" xml:space="preserve">
          <source>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations.</source>
          <target state="translated">Para la correcta impresión del código fuente que contiene los comentarios (utilizando los paquetes go/format y go/printer),se debe tener especial cuidado en la actualización de los comentarios cuando se modifica el árbol de sintaxis de un archivo:Para la impresión,los comentarios se intercalan entre las fichas en función de su posición.Si se eliminan o desplazan los nodos del árbol de sintaxis,también deben eliminarse (de la lista File.Comments)o desplazarse en consecuencia (actualizando sus posiciones)los comentarios pertinentes que se encuentren en su proximidad.Se puede utilizar un CommentMap para facilitar algunas de estas operaciones.</target>
        </trans-unit>
        <trans-unit id="483fb4b25526c306ca9ffc7060d999d1af757359" translate="yes" xml:space="preserve">
          <source>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().</source>
          <target state="translated">Para la depuración,el resultado de t.String incluye la lectura del reloj monótono si está presente.Si t !=u debido a las diferentes lecturas del reloj monótono,esa diferencia será visible al imprimir t.String()y u.String().</target>
        </trans-unit>
        <trans-unit id="c8abfac368bfa911449148a175097af24838350b" translate="yes" xml:space="preserve">
          <source>For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.</source>
          <target state="translated">Para cada función de impresión,hay también una función de impresión que no tiene formato y equivale a decir %v para cada operando.Otra variante de Println inserta espacios en blanco entre los operandos y añade una nueva línea.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="0691fc88626f896c5b4d0c9d21eb150c4440f732" translate="yes" xml:space="preserve">
          <source>For example, a client might run a HELP command that returns a dot-body by using:</source>
          <target state="translated">Por ejemplo,un cliente podría ejecutar un comando de AYUDA que devuelve un cuerpo puntual usando:</target>
        </trans-unit>
        <trans-unit id="d2c85d01a63eaf87fca388b5018e0aae0a907e1f" translate="yes" xml:space="preserve">
          <source>For example, a plugin defined as</source>
          <target state="translated">Por ejemplo,un plugin definido como</target>
        </trans-unit>
        <trans-unit id="b604de3a3134fd6e14b1dedf12ca2289afcd00f8" translate="yes" xml:space="preserve">
          <source>For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.</source>
          <target state="translated">Por ejemplo,supongamos que decidimos espumar leche,extraer café y mezclar leche y café en goroutines separados.Con una tarea,la herramienta de rastreo puede identificar los goroutines involucrados en un orden específico de capuchino.</target>
        </trans-unit>
        <trans-unit id="eb2f502c06edd8d48f9eb402147b9d0d02234fdf" translate="yes" xml:space="preserve">
          <source>For example, consider this input:</source>
          <target state="translated">Por ejemplo,considere esta entrada:</target>
        </trans-unit>
        <trans-unit id="4c08416096093138a9f21f98db3e35296861799a" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="translated">Por ejemplo,si p apunta a una estructura que contiene un descriptor de archivo d,y p tiene un finalizador que cierra ese descriptor de archivo,y si el último uso de p en una función es una llamada a syscall.Write(p.d,buf,size),entonces p puede ser inalcanzable tan pronto como el programa entra en syscall.Write.El finalizador puede ejecutarse en ese momento,cerrando p.d,causando que syscall.Write falle porque está escribiendo a un descriptor de archivo cerrado (o,peor aún,a un descriptor de archivo completamente diferente abierto por un goroutine diferente).Para evitar este problema,llame a runtime.KeepAlive(p)después de la llamada a syscall.Write.</target>
        </trans-unit>
        <trans-unit id="648df35862f0618dac59c24e1f3c2197d967fa5c" translate="yes" xml:space="preserve">
          <source>For example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.</source>
          <target state="translated">Por ejemplo,los cheques preenviados que utilizan este paquete directamente se comportarían de forma diferente según la versión de Go que utilice cada desarrollador,lo que provocaría que el cheque fuera intrínsecamente frágil.</target>
        </trans-unit>
        <trans-unit id="b70afa30fe71b5984e96c509da8feab3dc9a6c66" translate="yes" xml:space="preserve">
          <source>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:</source>
          <target state="translated">Por ejemplo,este código siempre calcula un tiempo transcurrido positivo de aproximadamente 20 milisegundos,incluso si se cambia el reloj de pared durante la operación que se está cronometrando:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b900be25452bfa919448d61bc68d11256350e2d5" translate="yes" xml:space="preserve">
          <source>For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.</source>
          <target state="translated">En el caso de los valores de punto flotante,la anchura fija la anchura mínima del campo y la precisión fija el número de lugares después del decimal,si procede,excepto que para la precisión %g/%G fija el número máximo de dígitos significativos (se eliminan los ceros finales).Por ejemplo,dado 12.345 el formato %6.3f imprime 12.345 mientras que %.3g imprime 12.3.La precisión por defecto para %e,%f y %#g es 6;para %g es el menor número de dígitos necesario para identificar el valor de forma única.</target>
        </trans-unit>
        <trans-unit id="8acb9c872d25848ac32729a8857f27d0fe460ece" translate="yes" xml:space="preserve">
          <source>For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.</source>
          <target state="translated">Para la compatibilidad hacia adelante,los usuarios que recuperen un Header de Reader.Next,lo muten de alguna manera,y luego lo pasen de vuelta a Writer.WriteHeader deben hacerlo creando un nuevo Header y copiando los campos que les interese preservar.</target>
        </trans-unit>
        <trans-unit id="e4409a51b04b7b882dd788481aa8d78b52daf5f6" translate="yes" xml:space="preserve">
          <source>For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.</source>
          <target state="translated">Para un mayor nivel de soporte de clientes HTTP (como el manejo de cookies y redireccionamientos),vea Obtener,Publicar y el tipo de cliente.</target>
        </trans-unit>
        <trans-unit id="ccf573cb88fa50261bc0cb844250e5c546113d3a" translate="yes" xml:space="preserve">
          <source>For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.</source>
          <target state="translated">En el caso de las solicitudes de servidores entrantes,el contexto se cancela cuando se cierra la conexión del cliente,se cancela la solicitud (con HTTP/2)o cuando regresa el método ServeHTTP.</target>
        </trans-unit>
        <trans-unit id="fbc897ff158a8e45243f9b229fc5329d56c63ca4" translate="yes" xml:space="preserve">
          <source>For information about UTF-8 strings in Go, see &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre las cadenas UTF-8 en Go, consulte &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63fe9b03e1c707dfe354f7496b7b0ea1047361fe" translate="yes" xml:space="preserve">
          <source>For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:</source>
          <target state="translated">Por ejemplo,NewInt(x)devuelve un *Int establecido al valor del argumento x de int64,NewRat(a,b)devuelve un *Rat establecido a la fracción a/b donde a y b son valores de int64,y NewFloat(f)devuelve un *Float inicializado al argumento f de float64.Se proporciona más flexibilidad con setters explícitos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ef36fa9bc6685ceb9dbf97a5a5da2cffd6025d4b" translate="yes" xml:space="preserve">
          <source>For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &amp;gt;= 23 }) returns the smallest index i such that data[i] &amp;gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately.</source>
          <target state="translated">Por ejemplo, dado un segmento de datos ordenados en orden ascendente, la llamada Search (len (data), func (i int) bool {return data [i]&amp;gt; = 23}) devuelve el &amp;iacute;ndice m&amp;aacute;s peque&amp;ntilde;o i tal que data [i]&amp;gt; = 23. Si la persona que llama quiere saber si 23 est&amp;aacute; en el segmento, debe probar los datos [i] == 23 por separado.</target>
        </trans-unit>
        <trans-unit id="c7dfa4cd456b849ced74b774ac752b76885a540c" translate="yes" xml:space="preserve">
          <source>For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:</source>
          <target state="translated">Por ejemplo,los argumentos de (*Int).Add se denominan x e y,y como el receptor especifica el destino del resultado,se denomina z:</target>
        </trans-unit>
        <trans-unit id="8f07f1d3d8e7f6b87f995e34e12a6b2b7256d6aa" translate="yes" xml:space="preserve">
          <source>For instance, when executing the template whose source is</source>
          <target state="translated">Por ejemplo,al ejecutar la plantilla cuya fuente es</target>
        </trans-unit>
        <trans-unit id="d7e0bab67441455c755b896ba0e2e68a1eb05350" translate="yes" xml:space="preserve">
          <source>For layouts specifying the two-digit year 06, a value NN &amp;gt;= 69 will be treated as 19NN and a value NN &amp;lt; 69 will be treated as 20NN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6018681f8b36b5a67b809b220861a7e3eea4cf91" translate="yes" xml:space="preserve">
          <source>For more information about pprof, see &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre pprof, consulte &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d996431a64b6bd8bf9d3bd0300d40b96d810b5b1" translate="yes" xml:space="preserve">
          <source>For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.</source>
          <target state="translated">Para un análisis más tolerante,Scan devolverá una señal válida si es posible,incluso si se ha encontrado un error de sintaxis.Así,incluso si la secuencia de fichas resultante no contiene fichas ilegales,el cliente no puede asumir que no se ha producido ningún error.En su lugar,debe comprobar el ErrorCount del escáner o el número de llamadas del controlador de errores,si es que había alguno instalado.</target>
        </trans-unit>
        <trans-unit id="ee92c8f279c1f6e92caa92b507d20eceb3f7bf2a" translate="yes" xml:space="preserve">
          <source>For most Unix systems, this package has two internal implementations of resolving user and group ids to names. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r and getgrnam_r.</source>
          <target state="translated">Para la mayoría de los sistemas Unix,este paquete tiene dos implementaciones internas de resolución de identificaciones de usuario y grupo a nombres.Una está escrita en Go puro y analiza /etc/passwd y /etc/group.La otra está basada en cgo y se apoya en las rutinas estándar de la biblioteca C (libc)como getpwuid_r y getgrnam_r.</target>
        </trans-unit>
        <trans-unit id="c4cdb94c601192f951b8e3c2e58421475088397d" translate="yes" xml:space="preserve">
          <source>For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.</source>
          <target state="translated">Para la mayoría de los valores,el ancho es el número mínimo de runas a emitir,rellenando la forma forma formateada con espacios si es necesario.</target>
        </trans-unit>
        <trans-unit id="515255bc358ef4ff5aa5412e1b66dcc8c403a8d9" translate="yes" xml:space="preserve">
          <source>For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).</source>
          <target state="translated">En el caso de los tipos no de interfaz V,o si se establece la estática,V implementa T si todos los métodos de T están presentes en V.En caso contrario (V es una interfaz y la estática no está establecida),MissingMethod sólo comprueba que los métodos de T que también están presentes en V tienen tipos coincidentes (por ejemplo,para una afirmación de tipo x.(T)donde x es de tipo de interfaz V).</target>
        </trans-unit>
        <trans-unit id="b71be130422309f072d39771550fbade7a681c88" translate="yes" xml:space="preserve">
          <source>For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.</source>
          <target state="translated">Para otros métodos HTTP,o cuando el Content-Type no está codificado con application/x-www-form-urlencoded,la petición Body no se lee,y r.PostForm se inicializa con un valor no nulo y vacío.</target>
        </trans-unit>
        <trans-unit id="90fd7feae6eaa72525957265644b35d2d7178aab" translate="yes" xml:space="preserve">
          <source>For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">En el caso de la solicitud de un cliente saliente,el contexto controla toda la vida de una solicitud y su respuesta:obtención de una conexión,envío de la solicitud y lectura de los encabezamientos y el cuerpo de la respuesta.</target>
        </trans-unit>
        <trans-unit id="d9dd41b387dea5f2e387ef2638e22692d5781ada" translate="yes" xml:space="preserve">
          <source>For outgoing client requests, the context controls cancellation.</source>
          <target state="translated">Para las solicitudes de clientes salientes,el contexto controla la cancelación.</target>
        </trans-unit>
        <trans-unit id="a001fc47d27546732ba34a6c50953e3947ee9592" translate="yes" xml:space="preserve">
          <source>For parsing this time format, see ParseTime.</source>
          <target state="translated">Para analizar este formato de tiempo,ver ParseTime.</target>
        </trans-unit>
        <trans-unit id="f71ccb724292b936b826fde518652933240dfacc" translate="yes" xml:space="preserve">
          <source>For portability, the status code should be in the range [0, 125].</source>
          <target state="translated">Para la portabilidad,el código de estado debe estar en el rango [0,125].</target>
        </trans-unit>
        <trans-unit id="bf654bcdb4217ef6a979d8f651f736b1fbda2ae7" translate="yes" xml:space="preserve">
          <source>For random numbers suitable for security-sensitive work, see the crypto/rand package.</source>
          <target state="translated">Para los números aleatorios adecuados para trabajos de seguridad,véase el paquete de criptografía/marca.</target>
        </trans-unit>
        <trans-unit id="8dac1d0bb1e2323543dc0dee447715c7804fe438" translate="yes" xml:space="preserve">
          <source>For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.</source>
          <target state="translated">Para escanear en *bool,la fuente puede ser verdadera,falsa,1,0,o entradas de cadena parseables por strconv.ParseBool.</target>
        </trans-unit>
        <trans-unit id="22a8f63617a1059c9b07e1b34be114b05733ec0f" translate="yes" xml:space="preserve">
          <source>For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect</source>
          <target state="translated">Para pruebas de igualdad multidireccionales más sencillas,la ecuación (sólo)acepta dos o más argumentos y compara el segundo y el posterior al primero,volviendo en efecto</target>
        </trans-unit>
        <trans-unit id="b0a480a0eda63e237a87664c806578f92d694410" translate="yes" xml:space="preserve">
          <source>For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:</source>
          <target state="translated">Para simplificar la configuración,la conexión se define para entender estos tipos a priori,así como los tipos básicos de gob int,uint,etc.Sus identificaciones son:</target>
        </trans-unit>
        <trans-unit id="2a1206bb6c7f79687004103bffb38cbee66ebc60" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">Para algunos argumentos,como una simple expresión de matriz,el resultado puede ser una constante.Véase la sección &quot;Longitud y capacidad&quot; de la especificación del lenguaje Go para más detalles.</target>
        </trans-unit>
        <trans-unit id="b73ee93bdb118cfdcf76b1431924d083213a9b9c" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">Para algunos argumentos,como una literalidad de la cadena o una simple expresión de la matriz,el resultado puede ser una constante.Véase la sección &quot;Longitud y capacidad&quot; de la especificación del lenguaje Go para más detalles.</target>
        </trans-unit>
        <trans-unit id="6fd5303b38861cc1f75ea4005c27f0d0e4bc73ba" translate="yes" xml:space="preserve">
          <source>For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.</source>
          <target state="translated">Sin embargo,en el caso de las cadenas,los cortes de bytes y los conjuntos de bytes,la precisión limita la longitud de la entrada a formatear (no el tamaño de la salida),truncando si es necesario.Normalmente se mide en runas,pero para estos tipos cuando se formatean con el formato %x o %X se mide en bytes.</target>
        </trans-unit>
        <trans-unit id="751d670356e91a449ec7c80c4156cc58a03922ea" translate="yes" xml:space="preserve">
          <source>For such flags, the default value is just the initial value of the variable.</source>
          <target state="translated">Para tales banderas,el valor por defecto es sólo el valor inicial de la variable.</target>
        </trans-unit>
        <trans-unit id="fe319d30e4ff1d3bb9c9679e1d41b020cb9fc422" translate="yes" xml:space="preserve">
          <source>For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.</source>
          <target state="translated">Para probar:los clientes pueden poner esta bandera para forzar la creación de enchufes IPv6 para devolver EAFNOSUPPORT.</target>
        </trans-unit>
        <trans-unit id="0d0e9615cbad5d104943c88a1e426bb41d0d3626" translate="yes" xml:space="preserve">
          <source>For the compiler to recognize this pattern, the conversion must appear in the argument list:</source>
          <target state="translated">Para que el compilador reconozca este patrón,la conversión debe aparecer en la lista de argumentos:</target>
        </trans-unit>
        <trans-unit id="13732a80c7c6067fbd8ddcc6a6ec2963b831f009" translate="yes" xml:space="preserve">
          <source>For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead.</source>
          <target state="translated">En la mayoría de los casos,los métodos de LineTable deben tratarse como un detalle interno del paquete;los que llaman deben utilizar los métodos de Table.</target>
        </trans-unit>
        <trans-unit id="82aa2e5faa1102c849b424650d24e3f7def76f8e" translate="yes" xml:space="preserve">
          <source>For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:</source>
          <target state="translated">En su mayor parte,este paquete sigue la sintaxis especificada por la RFC 5322 y ampliada por la RFC 6532.Notables divergencias:</target>
        </trans-unit>
        <trans-unit id="9dbc53494237ff152fc67f06045073fe509d54b4" translate="yes" xml:space="preserve">
          <source>For the power-of-two exponent formats, the mantissa is printed in normalized form:</source>
          <target state="translated">Para los formatos de potencia de dos exponentes,la mantisa se imprime en forma normalizada:</target>
        </trans-unit>
        <trans-unit id="f64016515259f77234a6cb253ce7855821350f37" translate="yes" xml:space="preserve">
          <source>For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.</source>
          <target state="translated">Para las señales síncronas y el SIGPIPE,el tiempo de ejecución de Go instalará un manejador de señales.Guardará cualquier manejador de señales existente.Si llega una señal síncrona mientras se ejecuta un código no Go,el tiempo de ejecución de Go invocará el manejador de señales existente en lugar del manejador de señales Go.</target>
        </trans-unit>
        <trans-unit id="cee851057097c0db5b5b8a9c0d45d60cedf064a6" translate="yes" xml:space="preserve">
          <source>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.</source>
          <target state="translated">Para estas funciones de escape interno,si una tubería de acción se evalúa a un valor de interfaz nulo,se trata como si fuera una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="94cdbab58de221c0845a1f0bccdc6ab6b9dfee7c" translate="yes" xml:space="preserve">
          <source>For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.</source>
          <target state="translated">Para este recorte,la definición de los caracteres de espacio en blanco es la misma que en Go:espacio,tabulación horizontal,retorno de carro y nueva línea.</target>
        </trans-unit>
        <trans-unit id="c4dda3b24b75ceb8fb66edf8e6d50d204c1750ea" translate="yes" xml:space="preserve">
          <source>For unrecognized or vendor-defined attributes, Class may be ClassUnknown.</source>
          <target state="translated">Para los atributos no reconocidos o definidos por el proveedor,Class puede ser ClassUnknown.</target>
        </trans-unit>
        <trans-unit id="a2c58c0bacd7ac1887ab982a2597ef55f18dc028" translate="yes" xml:space="preserve">
          <source>For usage examples, see the wiki page at &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt;.</source>
          <target state="translated">Para ver ejemplos de uso, consulte la p&amp;aacute;gina wiki en &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="988918abc4e75847a40cae9d31b2ff0b26774a56" translate="yes" xml:space="preserve">
          <source>ForCompiler returns an Importer for importing from installed packages for the compilers &quot;gc&quot; and &quot;gccgo&quot;, or for importing directly from the source if the compiler argument is &quot;source&quot;. In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).</source>
          <target state="translated">ForCompiler devuelve un Importador para importar desde los paquetes instalados para los compiladores &quot;gc&quot; y &quot;gccgo&quot;,o para importar directamente desde la fuente si el argumento del compilador es &quot;source&quot;.En este último caso,la importación puede fallar en circunstancias en las que la API exportada no esté completamente definida en código fuente Go puro (si la API del paquete depende de entidades definidas por cgo,el verificador de tipos no tendrá acceso a ellas).</target>
        </trans-unit>
        <trans-unit id="133285841cd925c282a101cb331b225c1c71812e" translate="yes" xml:space="preserve">
          <source>ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.</source>
          <target state="translated">ForLabels invoca la f con cada etiqueta puesta en el contexto.La función f debe regresar verdadero para continuar la iteración o falso para detener la iteración antes de tiempo.</target>
        </trans-unit>
        <trans-unit id="353aeb4085eb053c5afffba4c97380c4860aca38" translate="yes" xml:space="preserve">
          <source>Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.</source>
          <target state="translated">La forma es una forma multiparte analizada.Sus partes de archivo se almacenan en la memoria o en el disco,y se puede acceder a ellas mediante el método abierto del *Cabezador de Archivos.Las partes de su valor se almacenan como cadenas.Ambas son tecleadas por el nombre del campo.</target>
        </trans-unit>
        <trans-unit id="eccde56e16564dc7c7df2c5cc1796440a15f9401" translate="yes" xml:space="preserve">
          <source>FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.</source>
          <target state="translated">FormDataContentType devuelve el Content-Type para un HTTP multiparte/form-data con este Writer's Boundary.</target>
        </trans-unit>
        <trans-unit id="a49e5a35587aa21155c47ca684122af3589d1687" translate="yes" xml:space="preserve">
          <source>FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.</source>
          <target state="translated">FormFile devuelve el primer archivo de la clave de formulario proporcionada.FormFile llama a ParseMultipartForm y a ParseForm si es necesario.</target>
        </trans-unit>
        <trans-unit id="5d5c015330e69759a40946c508bd098ecc8416e4" translate="yes" xml:space="preserve">
          <source>FormName returns the name parameter if p has a Content-Disposition of type &quot;form-data&quot;. Otherwise it returns the empty string.</source>
          <target state="translated">FormName devuelve el parámetro del nombre si p tiene una disposición de contenido de tipo &quot;form-data&quot;.En caso contrario,devuelve la cadena vacía.</target>
        </trans-unit>
        <trans-unit id="445b64c2c00e9bf0c6abebdbd962d04b7f9f105c" translate="yes" xml:space="preserve">
          <source>FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.</source>
          <target state="translated">FormValue devuelve el primer valor para el componente nombrado de la consulta.Los parámetros corporales POST y PUT tienen prioridad sobre los valores de la cadena de consulta URL.FormValue llama a ParseMultipartForm y a ParseForm si es necesario e ignora cualquier error devuelto por estas funciones.Si la clave no está presente,FormValue devuelve la cadena vacía.Para acceder a múltiples valores de la misma clave,llama a ParseForm y luego inspecciona Request.Form directamente.</target>
        </trans-unit>
        <trans-unit id="b90d813e4920205a13e7a3e3ea46b1033f09615e" translate="yes" xml:space="preserve">
          <source>Format errors:</source>
          <target state="translated">Errores de formato:</target>
        </trans-unit>
        <trans-unit id="bd81fbee8cc623aef03682c00bd263e80dddfcaa" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.</source>
          <target state="translated">Format implementa fmt.Formatter.Acepta todos los formatos regulares de los números de punto flotante ('b','e','E','f','F','g','G','x')así como 'p' y 'v'.Ver (*Flotante).Texto para la interpretación de &quot;p&quot;.El formato 'v' se maneja como 'g'.El formato también admite la especificación de la precisión mínima en dígitos,el ancho del campo de salida,así como las banderas de formato &quot;+&quot; y &quot; ' ' para el control del signo,&quot;0&quot; para el relleno de espacio o cero,y &quot;-&quot; para la justificación izquierda o derecha.Vea el paquete fmt para más detalles.</target>
        </trans-unit>
        <trans-unit id="ddca00e8215628107f30d61b04b8094c67090fc1" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.</source>
          <target state="translated">Format implementa fmt.Formatter.Acepta los formatos &quot;b&quot; (binario),&quot;o&quot; (octal con prefijo 0),&quot;O&quot; (octal con prefijo 0o),&quot;d&quot; (decimal),&quot;x&quot; (hexadecimal en minúsculas)y &quot;X&quot; (hexadecimal en mayúsculas).También se admite el conjunto completo de banderas de formato del paquete fmt para tipos integrales,incluyendo '+' y ' ' para el control del signo,'#' para el cero inicial en octal y para hexadecimal,un &quot;0x&quot; o &quot;0X&quot; inicial para &quot;%#x&quot; y &quot;%#X&quot; respectivamente,especificación de la precisión mínima de los dígitos,ancho del campo de salida,relleno de espacio o cero,y '-' para la justificación izquierda o derecha.</target>
        </trans-unit>
        <trans-unit id="81a5476108fadb465e67c178e260599d04ddc2e8" translate="yes" xml:space="preserve">
          <source>Format represents the tar archive format.</source>
          <target state="translated">El formato representa el formato de archivo del alquitrán.</target>
        </trans-unit>
        <trans-unit id="8d4885fbdac6d0d14accf79b985b4ce78e6bdd62" translate="yes" xml:space="preserve">
          <source>Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</source>
          <target state="translated">Formato devuelve una representación textual del valor de tiempo formateado según la disposición,que define el formato mostrando cómo el tiempo de referencia,definido como</target>
        </trans-unit>
        <trans-unit id="b3ee515426820c27b536513d4c839dfeda89b51d" translate="yes" xml:space="preserve">
          <source>FormatBool</source>
          <target state="translated">FormatBool</target>
        </trans-unit>
        <trans-unit id="1b75ed131650db00babc41765f3ab4d40a495482" translate="yes" xml:space="preserve">
          <source>FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</source>
          <target state="translated">FormatBool devuelve &quot;verdadero&quot; o &quot;falso&quot; según el valor de b.</target>
        </trans-unit>
        <trans-unit id="6afd52cbbbdc2288edb941b965e52c2fc0f3f529" translate="yes" xml:space="preserve">
          <source>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</source>
          <target state="translated">FormatBool,FormatFloat,FormatInt y FormatUint convierten los valores en cadenas:</target>
        </trans-unit>
        <trans-unit id="7cde6838cd6d9db48f444c3319801df0ed449cfb" translate="yes" xml:space="preserve">
          <source>FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf02981ef6c41fa3e9a421259a94865e8c2df157" translate="yes" xml:space="preserve">
          <source>FormatError is returned by some operations if the data does not have the correct format for an object file.</source>
          <target state="translated">FormatError de formato es devuelto por algunas operaciones si los datos no tienen el formato correcto para un archivo de objeto.</target>
        </trans-unit>
        <trans-unit id="9be4c97132e0f61e257dba73681e0455cf421f26" translate="yes" xml:space="preserve">
          <source>FormatError is unused. The type is retained for compatibility.</source>
          <target state="translated">FormatError no se usa.El tipo se conserva por compatibilidad.</target>
        </trans-unit>
        <trans-unit id="66155c8335bf85f47e7201829386a88e599875d5" translate="yes" xml:space="preserve">
          <source>FormatFloat</source>
          <target state="translated">FormatFloat</target>
        </trans-unit>
        <trans-unit id="8ab806a123a3e3bc36a09fdd9698930a4aafbfb9" translate="yes" xml:space="preserve">
          <source>FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).</source>
          <target state="translated">FormatFloat convierte el número de punto flotante f en una cadena,de acuerdo con el formato fmt y la precisión prec.Redondea el resultado suponiendo que el original se obtuvo a partir de un valor en coma flotante de bits de tamaño bit (32 para float32,64 para float64).</target>
        </trans-unit>
        <trans-unit id="54acac612d12c84fbb587187170a9d2f5002e9e1" translate="yes" xml:space="preserve">
          <source>FormatInt</source>
          <target state="translated">FormatInt</target>
        </trans-unit>
        <trans-unit id="ac942d8c471010cc2511b6465b29a4a4eaf7e487" translate="yes" xml:space="preserve">
          <source>FormatInt returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatInt devuelve la representaci&amp;oacute;n de cadena de i en la base dada, para 2 &amp;lt;= base &amp;lt;= 36. El resultado usa las letras min&amp;uacute;sculas 'a' a 'z' para valores de d&amp;iacute;gitos&amp;gt; = 10.</target>
        </trans-unit>
        <trans-unit id="7ffe85b478b1a8a795e300c5a2b13589a4aacd1b" translate="yes" xml:space="preserve">
          <source>FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.</source>
          <target state="translated">FormatMediaType serializa el tipo de medio t y los parámetros param como un tipo de medio conforme a RFC 2045 y RFC 2616.Los nombres del tipo y los parámetros están escritos en minúsculas.Cuando cualquiera de los argumentos resulta en una violación estándar,entonces FormatMediaType devuelve la cadena vacía.</target>
        </trans-unit>
        <trans-unit id="457b9a9d61506e909562e056e83daf32584b6e03" translate="yes" xml:space="preserve">
          <source>FormatUint</source>
          <target state="translated">FormatUint</target>
        </trans-unit>
        <trans-unit id="29e428f2dcc8699c0417730387a64fac7ddd1961" translate="yes" xml:space="preserve">
          <source>FormatUint returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatUint devuelve la representaci&amp;oacute;n de cadena de i en la base dada, para 2 &amp;lt;= base &amp;lt;= 36. El resultado utiliza las letras min&amp;uacute;sculas 'a' a 'z' para valores de d&amp;iacute;gitos&amp;gt; = 10.</target>
        </trans-unit>
        <trans-unit id="74de65e787a3b1e89f96cc3e3b260c1d5a19f78c" translate="yes" xml:space="preserve">
          <source>Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="translated">El formateo es la interfaz implementada por valores con un formateo personalizado.La implementación del Formato puede llamar a Sprint(f)o Fprint(f)etc.para generar su salida.</target>
        </trans-unit>
        <trans-unit id="d3a818c703590da441ab8fb9d8bac8b6144c0764" translate="yes" xml:space="preserve">
          <source>Formatting can be controlled with these flags.</source>
          <target state="translated">El formato puede ser controlado con estas banderas.</target>
        </trans-unit>
        <trans-unit id="75a6bd1d5df471e18e5ef09488e671afbb943a27" translate="yes" xml:space="preserve">
          <source>Fprint</source>
          <target state="translated">Fprint</target>
        </trans-unit>
        <trans-unit id="8c8522f1e4d59e7911ef9e37ddbccae99dbf77c6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.</source>
          <target state="translated">Imprime &quot;pretty-prints&quot; un nodo AST para la salida de una configuración determinada cfg.La información de posición se interpreta en relación con el conjunto de archivos fset.El tipo de nodo debe ser *ast.File,*CommentedNode,[]ast.Decl,[]ast.Stmt,o asignación-compatible con ast.Expr,ast.Decl,ast.Spec,o ast.Stmt.</target>
        </trans-unit>
        <trans-unit id="f8a539386d013173d33a590058d75eefbdb15fa6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.</source>
          <target state="translated">Imprime &quot;Pretty-prints&quot; un nodo AST para la salida.Llama a Config.Fprint con ajustes por defecto.Tenga en cuenta que gofmt utiliza pestañas para la indentación pero espacios para la alineación;utilice format.Node (package go/format)para la salida que coincida con gofmt.</target>
        </trans-unit>
        <trans-unit id="104c28c9f2550f07e8ce3bfa8162280f3f8c80ca" translate="yes" xml:space="preserve">
          <source>Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Imprime formatos usando los formatos por defecto de sus operandos y escribe a w.Se añaden espacios entre los operandos cuando ninguno de ellos es una cadena.Devuelve el número de bytes escritos y cualquier error de escritura encontrado.</target>
        </trans-unit>
        <trans-unit id="6a536bd9e7bf91ae60cda20d0ea5db515bbd6c7b" translate="yes" xml:space="preserve">
          <source>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).</source>
          <target state="translated">Fprint imprime el (sub-)árbol empezando en el nodo AST x a w.Si fset !=nil,la información de posición se interpreta en relación con ese conjunto de archivos.En caso contrario,las posiciones se imprimen como valores enteros (compensaciones específicas del conjunto de archivos).</target>
        </trans-unit>
        <trans-unit id="d20e1fe41e4983b3d1227303d39b1a75b7115f30" translate="yes" xml:space="preserve">
          <source>Fprintf</source>
          <target state="translated">Fprintf</target>
        </trans-unit>
        <trans-unit id="a13c0d787117a7941cdce4981a12d040db7f0953" translate="yes" xml:space="preserve">
          <source>Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintf formatea de acuerdo a un especificador de formato y escribe a w.Devuelve el número de bytes escritos y cualquier error de escritura encontrado.</target>
        </trans-unit>
        <trans-unit id="46197102442051b0256d5e8d44d3fa71b3e0ca3a" translate="yes" xml:space="preserve">
          <source>Fprintln</source>
          <target state="translated">Fprintln</target>
        </trans-unit>
        <trans-unit id="b390d66055f3fb09a9893ca4c02d4466e93e9f7e" translate="yes" xml:space="preserve">
          <source>Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintln usa los formatos por defecto de sus operandos y escribe a w.Siempre se añaden espacios entre los operandos y se añade una nueva línea.Devuelve el número de bytes escritos y cualquier error de escritura encontrado.</target>
        </trans-unit>
        <trans-unit id="c52284236b3cbc2d437f96673b062717eea95c7a" translate="yes" xml:space="preserve">
          <source>Frame is the information returned by Frames for each call frame.</source>
          <target state="translated">La trama es la información que devuelve Frames para cada trama de llamada.</target>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="translated">Frames</target>
        </trans-unit>
        <trans-unit id="6a32e149e9d6773e4f6967f48bf708bb90588f99" translate="yes" xml:space="preserve">
          <source>Frames may be used to get function/file/line information for a slice of PC values returned by Callers.</source>
          <target state="translated">Los marcos pueden ser usados para obtener información de función/archivo/línea para un trozo de valores de PC devueltos por Callers.</target>
        </trans-unit>
        <trans-unit id="971e42ae8bcc68c1d3c0b0b0f45fd394dc7d0afe" translate="yes" xml:space="preserve">
          <source>FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)</source>
          <target state="translated">FreeOSMemory obliga a una recogida de basura seguida de un intento de devolver tanta memoria al sistema operativo como sea posible.(Incluso si esto no se llama,el tiempo de ejecución devuelve gradualmente la memoria al sistema operativo en una tarea de fondo).</target>
        </trans-unit>
        <trans-unit id="2d6c189d92419208a8893cd5a97e05687d681927" translate="yes" xml:space="preserve">
          <source>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac &amp;times; 2**exp, with the absolute value of frac in the interval [&amp;frac12;, 1).</source>
          <target state="translated">Frexp divide f en una fracci&amp;oacute;n normalizada y una potencia integral de dos. Devuelve frac y exp satisfaciendo f == frac &amp;times; 2 ** exp, con el valor absoluto de frac en el intervalo [&amp;frac12;, 1).</target>
        </trans-unit>
        <trans-unit id="fa23c274e14dd5cc1e7fa9a8a9b29bf34200b44f" translate="yes" xml:space="preserve">
          <source>FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.</source>
          <target state="translated">FromSlash devuelve el resultado de reemplazar cada barra ('/')en el camino con un carácter separador.Las barras múltiples son reemplazadas por múltiples separadores.</target>
        </trans-unit>
        <trans-unit id="164e0e9caa51bad7048b8f096c49d9b2c2ab5e89" translate="yes" xml:space="preserve">
          <source>Front returns the first element of list l or nil if the list is empty.</source>
          <target state="translated">Front devuelve el primer elemento de la lista l o nulo si la lista está vacía.</target>
        </trans-unit>
        <trans-unit id="52c1852fe9f31cf9deb2025a2022f1fc079a5aee" translate="yes" xml:space="preserve">
          <source>Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Fscan escanea el texto leído desde r,almacenando valores sucesivos separados por el espacio en argumentos sucesivos.Las nuevas líneas cuentan como espacio.Devuelve el número de elementos escaneados con éxito.Si es menor que el número de argumentos,err informará del porqué.</target>
        </trans-unit>
        <trans-unit id="554810832552956da9a7da2eee0a73593dca23e7" translate="yes" xml:space="preserve">
          <source>Fscanf</source>
          <target state="translated">Fscanf</target>
        </trans-unit>
        <trans-unit id="8bd3b6e023a616305dbe6b056ba1a191e7adb603" translate="yes" xml:space="preserve">
          <source>Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Fscanf escanea el texto leído desde r,almacenando valores sucesivos separados por el espacio en argumentos sucesivos según lo determine el formato.Devuelve el número de elementos analizados con éxito.Las nuevas líneas de la entrada deben coincidir con las nuevas líneas del formato.</target>
        </trans-unit>
        <trans-unit id="24ce0d47eda270ec1be1d5faf6933fc84f496fc9" translate="yes" xml:space="preserve">
          <source>Fscanln</source>
          <target state="translated">Fscanln</target>
        </trans-unit>
        <trans-unit id="6ba607f7da03e13291dee0bc0511128cd6a13033" translate="yes" xml:space="preserve">
          <source>Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">El Fscanln es similar al Fscan,pero deja de escanear en una nueva línea y después del último elemento debe haber una nueva línea o EOF.</target>
        </trans-unit>
        <trans-unit id="18339496bb65d9199e22c7756d8d353de7e08bb1" translate="yes" xml:space="preserve">
          <source>FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.</source>
          <target state="translated">El nombre completo encuentra el nombre real del símbolo simbólico.Normalmente el nombre se almacena en sym.Name,pero si tiene más de 8 caracteres,se almacena en la tabla de cadenas de COFF en su lugar.</target>
        </trans-unit>
        <trans-unit id="7902524eb980d3f158a430d41566b78e54c0f4a8" translate="yes" xml:space="preserve">
          <source>FullName returns the package- or receiver-type-qualified name of function or method obj.</source>
          <target state="translated">FullName devuelve el nombre calificado de la función o del método del paquete o del receptor.</target>
        </trans-unit>
        <trans-unit id="b3483c701e937232d5e060b21f7fb965b230aa71" translate="yes" xml:space="preserve">
          <source>FullRune</source>
          <target state="translated">FullRune</target>
        </trans-unit>
        <trans-unit id="81aa0878662ea86cc86d82ed1ab7992029d672d9" translate="yes" xml:space="preserve">
          <source>FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</source>
          <target state="translated">FullRune informa si los bytes en p comienzan con una codificación UTF-8 completa de una runa.Una codificación inválida se considera una Runa completa ya que se convertirá en una runa de error width-1.</target>
        </trans-unit>
        <trans-unit id="e05115514df90c085c4af490f89158b561b0d92c" translate="yes" xml:space="preserve">
          <source>FullRuneInString</source>
          <target state="translated">FullRuneInString</target>
        </trans-unit>
        <trans-unit id="95812f07b4917317402c5d2167338a188da0ce79" translate="yes" xml:space="preserve">
          <source>FullRuneInString is like FullRune but its input is a string.</source>
          <target state="translated">FullRuneInString es como FullRune pero su entrada es una cadena.</target>
        </trans-unit>
        <trans-unit id="279955fd7d680432dfab90fbe069c9bfd8dc8495" translate="yes" xml:space="preserve">
          <source>Func implements Var by calling the function and formatting the returned value using JSON.</source>
          <target state="translated">Func implementa Var llamando a la función y formateando el valor devuelto usando JSON.</target>
        </trans-unit>
        <trans-unit id="524a0d206f4cbf19e946f5d4ed3f42690d7a8676" translate="yes" xml:space="preserve">
          <source>Func is a wrapped Go function to be called by JavaScript.</source>
          <target state="translated">Func es una función Go envuelta que debe ser llamada por JavaScript.</target>
        </trans-unit>
        <trans-unit id="9f43fd9d5faa1fad98bda7488e8199738c579a5f" translate="yes" xml:space="preserve">
          <source>Func is the documentation for a func declaration.</source>
          <target state="translated">Func es la documentación para una declaración de func.</target>
        </trans-unit>
        <trans-unit id="1428a5974ab9a5d9bb8050c81e92e9a085606a0b" translate="yes" xml:space="preserve">
          <source>Func values are deeply equal if both are nil; otherwise they are not deeply equal.</source>
          <target state="translated">Los valores Func son profundamente iguales si ambos son nulos;de lo contrario no son profundamente iguales.</target>
        </trans-unit>
        <trans-unit id="c6b073315fc317c2d847f10bda8f819f0b734264" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be invoked any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4c67efe336d8800eb50760aa412d1cd7318a96" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be used any more.</source>
          <target state="translated">Func.Release debe ser llamado para liberar recursos cuando la función no se use más.</target>
        </trans-unit>
        <trans-unit id="79c0844aa92a7c85df75b63db88d3ac85acf1947" translate="yes" xml:space="preserve">
          <source>FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.</source>
          <target state="translated">FuncForPC devuelve un *Func que describe la función que contiene la dirección del contador del programa dado,o bien nulo.</target>
        </trans-unit>
        <trans-unit id="2f873cfa96e723fb817cda8756e298acee836d4d" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in &quot;text/template&quot;, copied here so clients need not import &quot;text/template&quot;.</source>
          <target state="translated">FuncMap es el tipo de mapa que define el mapeo desde los nombres hasta las funciones.Cada función debe tener un único valor de retorno,o dos valores de retorno de los cuales el segundo tiene el tipo de error.En ese caso,si el segundo argumento (de error)se evalúa a no nulo durante la ejecución,ésta termina y Execute devuelve ese error.FuncMap tiene el mismo tipo de base que FuncMap en &quot;text/template&quot;,copiado aquí para que los clientes no tengan que importar &quot;text/template&quot;.</target>
        </trans-unit>
        <trans-unit id="c663a8fdf1b0c07a4b3a9bf988b2301d91e56916" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.</source>
          <target state="translated">FuncMap es el tipo de mapa que define el mapeo desde los nombres hasta las funciones.Cada función debe tener un único valor de retorno,o dos valores de retorno de los cuales el segundo tiene el tipo de error.En ese caso,si el segundo valor de retorno (de error)se evalúa a no nulo durante la ejecución,ésta termina y Execute devuelve ese error.</target>
        </trans-unit>
        <trans-unit id="e6a6e8cadfebe9c4799e999d069f9213bb24bed9" translate="yes" xml:space="preserve">
          <source>FuncOf</source>
          <target state="translated">FuncOf</target>
        </trans-unit>
        <trans-unit id="727153d867d797c3632d8920f9ed42e20c01b542" translate="yes" xml:space="preserve">
          <source>FuncOf returns a function to be used by JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d863a41e98edea4d63050f4d41d85e38ee53432a" translate="yes" xml:space="preserve">
          <source>FuncOf returns a wrapped function.</source>
          <target state="translated">FuncOf devuelve una función envuelta.</target>
        </trans-unit>
        <trans-unit id="93a168211e34460ad795ada01d7598344ab1ff0e" translate="yes" xml:space="preserve">
          <source>FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</source>
          <target state="translated">FuncOf devuelve el tipo de función con los tipos de argumento y resultado dados.Por ejemplo,si k representa int y e representa cadena,FuncOf([]Type{k},[]Type{e},false)representa la cadena func(int).</target>
        </trans-unit>
        <trans-unit id="e545c5b7597389c332937a417c6dbb10d7b9c2b9" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs añade los elementos del mapa de argumentos al mapa de funciones de la plantilla.Debe ser llamado antes de que la plantilla sea analizada.Entra en pánico si un valor del mapa no es una función con el tipo de retorno apropiado o si el nombre no puede ser usado sintácticamente como una función en una plantilla.Es legal sobrescribir elementos del mapa.El valor de retorno es la plantilla,por lo que las llamadas pueden ser encadenadas.</target>
        </trans-unit>
        <trans-unit id="d356e92562acfcaf97196969d96dd79e05dacf25" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs añade los elementos del mapa de argumentos al mapa de funciones de la plantilla.Debe ser llamado antes de que la plantilla sea analizada.Entra en pánico si un valor del mapa no es una función con el tipo de retorno apropiado.Sin embargo,es legal sobrescribir elementos del mapa.El valor de retorno es la plantilla,así que las llamadas pueden ser encadenadas.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="8c10d9660a016948a806bd8cbcad3722d8e6bc88" translate="yes" xml:space="preserve">
          <source>Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.</source>
          <target state="translated">Las funciones y los canales no se enviarán en un gob.Intentar codificar tal valor en el nivel superior fallará.Un campo estructural de tipo chan o func se trata exactamente como un campo no exportado y se ignora.</target>
        </trans-unit>
        <trans-unit id="515fb65b2b3a55f3a5ea9024aecd183d10145a5b" translate="yes" xml:space="preserve">
          <source>Functions of the form</source>
          <target state="translated">Funciones de la forma</target>
        </trans-unit>
        <trans-unit id="5bde1b79ff9cf2a64313aa293a07d05136a9d65d" translate="yes" xml:space="preserve">
          <source>Functions starting with &quot;Is&quot; can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range.</source>
          <target state="translated">Las funciones que empiezan con &quot;Es&quot; pueden utilizarse para inspeccionar a qué tabla de rango pertenece una runa.Tenga en cuenta que las runas pueden caber en más de un rango.</target>
        </trans-unit>
        <trans-unit id="14038939956e123c4daa0060310ed80bf1b7a49d" translate="yes" xml:space="preserve">
          <source>GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.</source>
          <target state="translated">GC dirige una recogida de basura y bloquea la llamada hasta que la recogida de basura esté completa.También puede bloquear todo el programa.</target>
        </trans-unit>
        <trans-unit id="c7f87699bcc973fce315d8d3ae36debdf341faa6" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dacc63b01c8608c5a77320640ce147950f96e1" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b, which both must be &amp;gt; 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is &amp;lt;= 0, GCD sets z = x = y = 0.</source>
          <target state="translated">GCD establece z en el m&amp;aacute;ximo com&amp;uacute;n divisor de ayb, que deben ser&amp;gt; 0, y devuelve z. Si xoy no son nulos, MCD establece su valor de manera que z = a * x + b * y. Si aob es &amp;lt;= 0, MCD establece z = x = y = 0.</target>
        </trans-unit>
        <trans-unit id="19dd357da96d7272320f7fadf3fd2965c024dba5" translate="yes" xml:space="preserve">
          <source>GCStats collect information about recent garbage collections.</source>
          <target state="translated">Los GCStats recogen información sobre las recientes recogidas de basura.</target>
        </trans-unit>
        <trans-unit id="d010209a0c3d0dee637f5259dfa34515f68772df" translate="yes" xml:space="preserve">
          <source>GIF represents the possibly multiple images stored in a GIF file.</source>
          <target state="translated">GIF representa las posibles múltiples imágenes almacenadas en un archivo GIF.</target>
        </trans-unit>
        <trans-unit id="f62024646db1c94f452ef8c25337fad08f62d18e" translate="yes" xml:space="preserve">
          <source>GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.</source>
          <target state="translated">GOARCH es el objetivo de la arquitectura del programa en ejecución:uno de 386,amd64,arm,s390x,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="cb34b31ce447e79881d19460e35c7075fc05a81a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS establece el n&amp;uacute;mero m&amp;aacute;ximo de CPU que se pueden ejecutar simult&amp;aacute;neamente y devuelve la configuraci&amp;oacute;n anterior. Si n &amp;lt;1, no cambia la configuraci&amp;oacute;n actual. El n&amp;uacute;mero de CPU l&amp;oacute;gicas en la m&amp;aacute;quina local se puede consultar con NumCPU. Esta llamada desaparecer&amp;aacute; cuando el planificador mejore.</target>
        </trans-unit>
        <trans-unit id="ad65293e987b4a4c08430d0e000aecbc1854ac24" translate="yes" xml:space="preserve">
          <source>GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run &quot;go tool dist list&quot;.</source>
          <target state="translated">El GOOS es el objetivo del sistema operativo del programa en ejecución:uno de darwin,freebsd,linux,etc.Para ver las posibles combinaciones de GOOS y GOARCH,ejecute &quot;go tool dist list&quot;.</target>
        </trans-unit>
        <trans-unit id="7bb230fcc10199af1bb88085306db7998e9674cd" translate="yes" xml:space="preserve">
          <source>GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.</source>
          <target state="translated">GOROOT devuelve la raíz del árbol de Go.Utiliza la variable de entorno GOROOT,si se establece al inicio del proceso,o la raíz utilizada durante la construcción de Go.</target>
        </trans-unit>
        <trans-unit id="3552a70e477a364f8e82a292dad18f46a2ad988b" translate="yes" xml:space="preserve">
          <source>Gamma returns the Gamma function of x.</source>
          <target state="translated">Gamma devuelve la función Gamma de x.</target>
        </trans-unit>
        <trans-unit id="a2672eb4dac0440844556fb66fa39b9edb2d2041" translate="yes" xml:space="preserve">
          <source>General:</source>
          <target state="translated">General:</target>
        </trans-unit>
        <trans-unit id="453efae49cba4a01a09c987414ab329ee6c4a305" translate="yes" xml:space="preserve">
          <source>Generally Get, Post, or PostForm will be used instead of Do.</source>
          <target state="translated">Generalmente se usará Get,Post o PostForm en lugar de Do.</target>
        </trans-unit>
        <trans-unit id="1c57b54aace051c9a60fd146f5087c013aa2d721" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public and private key pair.</source>
          <target state="translated">GenerateKey genera un par de claves públicas y privadas.</target>
        </trans-unit>
        <trans-unit id="db1ff76045ebe9cc510f3c31601ddcbcd7fd57de" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public&amp;amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).</source>
          <target state="translated">GenerateKey genera un par de claves p&amp;uacute;blica y privada. Los par&amp;aacute;metros de PrivateKey ya deben ser v&amp;aacute;lidos (ver GenerateParameters).</target>
        </trans-unit>
        <trans-unit id="e650907b55be64a19300b70e59344d22b7245e9b" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used.</source>
          <target state="translated">GenerateKey genera un par de claves públicas/privadas usando entropía de rand.Si rand es nulo,se usará crypto/rand.Reader.</target>
        </trans-unit>
        <trans-unit id="7f11f0f6942fab0ca9f944e5798d7d37395d774c" translate="yes" xml:space="preserve">
          <source>GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).</source>
          <target state="translated">GenerateKey genera un par de claves RSA del tamaño de bit dado utilizando la fuente aleatoria aleatoria (por ejemplo,crypto/rand.Reader).</target>
        </trans-unit>
        <trans-unit id="80806cb0e126f8dd45cfba36eccecc7429a61358" translate="yes" xml:space="preserve">
          <source>GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.</source>
          <target state="translated">GenerateKey devuelve un par de claves públicas y privadas.La clave privada se genera usando el lector dado,que debe devolver datos aleatorios.</target>
        </trans-unit>
        <trans-unit id="94cfc2c7f30a1879e413d8411b7005501c966655" translate="yes" xml:space="preserve">
          <source>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.</source>
          <target state="translated">GenerateMultiPrimeKey genera un par de claves RSA multi-prime del tamaño de bits dado y la fuente aleatoria dada,como se sugiere en [1].Aunque las claves públicas son compatibles (en realidad,indistinguibles)con el caso de las 2 primas,las claves privadas no lo son.Así pues,tal vez no sea posible exportar claves privadas de múltiples primos en determinados formatos o importarlas posteriormente en otro código.</target>
        </trans-unit>
        <trans-unit id="51625703089c85c9211c0ab627055dec67c2bfaf" translate="yes" xml:space="preserve">
          <source>GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.</source>
          <target state="translated">GenerateParameters pone un conjunto aleatorio y válido de parámetros DSA en parámentros.Esta función puede tomar muchos segundos,incluso en máquinas rápidas.</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="2fe964aa376032085805189a0397b3cdcf676226" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get obtiene el primer valor asociado a la clave dada.Si no hay valores asociados a la clave,Get devuelve &quot;&quot;.Es insensible a las mayúsculas y minúsculas;textproto.CanonicalMIMEHeaderKey se usa para canonizar la clave proporcionada.Para acceder a múltiples valores de una clave,o para usar claves no canónicas,acceda al mapa directamente.</target>
        </trans-unit>
        <trans-unit id="3baa902f39cd83b30a85e419cba3b5af01d1e3ff" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5819a3dfa32fe18b54e30756235c5c0b3e71efb0" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.</source>
          <target state="translated">Get obtiene el primer valor asociado a la clave dada.Si no hay valores asociados a la clave,Get devuelve la cadena vacía.Para acceder a múltiples valores,utilice el mapa directamente.</target>
        </trans-unit>
        <trans-unit id="322573da1168297393f519b4b988bc100cbe0b6c" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get obtiene el primer valor asociado a la clave dada.Es insensible a las mayúsculas y minúsculas;CanonicalMIMEHeaderKey se utiliza para canonizar la clave proporcionada.Si no hay valores asociados a la clave,Get devuelve &quot;&quot;.Para acceder a múltiples valores de una clave,o para usar claves no canónicas,acceda al mapa directamente.</target>
        </trans-unit>
        <trans-unit id="70b433c8accfde2bcfff0de0db7ea43f32e215fb" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To use non-canonical keys, access the map directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73d0c593dbece5412fe884185bdca68896527d" translate="yes" xml:space="preserve">
          <source>Get is a wrapper around DefaultClient.Get.</source>
          <target state="translated">Get es un envoltorio alrededor del cliente predeterminado.Get.</target>
        </trans-unit>
        <trans-unit id="e51f2ab7d6fbd0e2ffab583f80049b3cfc794ac8" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Consigue que los problemas se envíen a la URL especificada.Si la respuesta es uno de los siguientes códigos de redireccionamiento,Get sigue el redireccionamiento después de llamar a la función CheckRedirect del cliente:</target>
        </trans-unit>
        <trans-unit id="cff58f3ccfaec37f9252515e01360ee67558791b" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Consigue que los problemas se envíen a la URL especificada.Si la respuesta es uno de los siguientes códigos de redireccionamiento,Get sigue el redireccionamiento,hasta un máximo de 10 redirecciones:</target>
        </trans-unit>
        <trans-unit id="4af41ae2934aaf3ecc571a5a758befaaf5dd46ec" translate="yes" xml:space="preserve">
          <source>Get retrieves a named exported variable. It returns nil if the name has not been registered.</source>
          <target state="translated">Get recupera una variable exportada con nombre.Devuelve cero si el nombre no ha sido registrado.</target>
        </trans-unit>
        <trans-unit id="afa92ba06d138d5628558f74ba88a7e263aff277" translate="yes" xml:space="preserve">
          <source>Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Get devuelve la propiedad JavaScript p de valor v.Entra en pánico si v no es un objeto JavaScript.</target>
        </trans-unit>
        <trans-unit id="1f152948d80d4df7cedf020669e282541979aaff" translate="yes" xml:space="preserve">
          <source>Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.</source>
          <target state="translated">Get devuelve el valor asociado a la clave en la cadena de la etiqueta.Si no hay tal clave en la etiqueta,Get devuelve la cadena vacía.Si la etiqueta no tiene el formato convencional,el valor devuelto por Get no está especificado.Para determinar si una etiqueta se establece explícitamente en la cadena vacía,utilice Lookup.</target>
        </trans-unit>
        <trans-unit id="1c95403f4621e18fe8ba30c67d76e285e8214f43" translate="yes" xml:space="preserve">
          <source>Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.</source>
          <target state="translated">Get selecciona un elemento arbitrario del Pool,lo quita del Pool y lo devuelve al llamador.Get puede elegir ignorar el pool y tratarlo como vacío.Los llamadores no deben asumir ninguna relación entre los valores pasados a Put y los valores devueltos por Get.</target>
        </trans-unit>
        <trans-unit id="c21e6716a05006be2a3b33da22f790cc4dacbd14" translate="yes" xml:space="preserve">
          <source>Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:</source>
          <target state="translated">Get,Head,Post y PostForm hacen peticiones HTTP (o HTTPS):</target>
        </trans-unit>
        <trans-unit id="c5763aa4654b9f9e755a5247c7e85bd6431154eb" translate="yes" xml:space="preserve">
          <source>Getegid returns the numeric effective group id of the caller.</source>
          <target state="translated">Getegid devuelve el id de grupo numérico efectivo del llamante.</target>
        </trans-unit>
        <trans-unit id="3ce86e952faaa112161293325cc18e1e8b1d1f86" translate="yes" xml:space="preserve">
          <source>Getenv</source>
          <target state="translated">Getenv</target>
        </trans-unit>
        <trans-unit id="83272f1d9be5d707a2abc299316ecf8c20c6572e" translate="yes" xml:space="preserve">
          <source>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.</source>
          <target state="translated">Getenv recupera el valor de la variable de entorno nombrada por la clave.Devuelve el valor,que estará vacío si la variable no está presente.Para distinguir entre un valor vacío y un valor no presente,usa LookupEnv.</target>
        </trans-unit>
        <trans-unit id="fb87cd5bc3aee2814b4736bc86345f331ef466ad" translate="yes" xml:space="preserve">
          <source>Geteuid returns the numeric effective user id of the caller.</source>
          <target state="translated">Geteuid devuelve el número de identificación de usuario efectivo de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="ba1ccf148fadcaa5a423e416bb3b76de027035d5" translate="yes" xml:space="preserve">
          <source>Getgid returns the numeric group id of the caller.</source>
          <target state="translated">Getgid devuelve el identificador de grupo numérico de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="1a0d3dfabc3d14d5473d84c935b43760abff4984" translate="yes" xml:space="preserve">
          <source>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</source>
          <target state="translated">Getgroups devuelve una lista de los números de identificación de los grupos a los que pertenece la persona que llama.</target>
        </trans-unit>
        <trans-unit id="cf37c04d335f6576ae2f027091318c6f433db063" translate="yes" xml:space="preserve">
          <source>Getpagesize returns the underlying system's memory page size.</source>
          <target state="translated">Getpagesize devuelve el tamaño de la página de memoria del sistema subyacente.</target>
        </trans-unit>
        <trans-unit id="98c30bd03388e6d00325569f2c09cb7a5c1f7d76" translate="yes" xml:space="preserve">
          <source>Getpid returns the process id of the caller.</source>
          <target state="translated">Getpid devuelve el identificador de proceso de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="7d80618e0017c08138a1fb60fea1c4ec0dbcc585" translate="yes" xml:space="preserve">
          <source>Getppid returns the process id of the caller's parent.</source>
          <target state="translated">Getppid devuelve la identificación de proceso del padre de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="ed660f2b70ea9d5fc73733f3c8d0fe3252a11e78" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.</source>
          <target state="translated">Getter es una interfaz que permite recuperar el contenido de un Valor.Envuelve la interfaz del Valor,en lugar de ser parte de ella,porque apareció después de Go 1 y sus reglas de compatibilidad.Todos los tipos de Valores proporcionados por este paquete satisfacen la interfaz de Getter.</target>
        </trans-unit>
        <trans-unit id="87c5badfd378b66a2a7ada85f8b7415911742baa" translate="yes" xml:space="preserve">
          <source>Getuid returns the numeric user id of the caller.</source>
          <target state="translated">Getuid devuelve el ID de usuario numérico de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="55e12168bb983e41918aba1691a9e5f495430b36" translate="yes" xml:space="preserve">
          <source>Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.</source>
          <target state="translated">Getwd devuelve un nombre de ruta arraigada correspondiente al directorio actual.Si se puede llegar al directorio actual a través de múltiples rutas (debido a los enlaces simbólicos),Getwd puede devolver cualquiera de ellas.</target>
        </trans-unit>
        <trans-unit id="db8c30ea4bb862dc2beac406c90a324c6875e53e" translate="yes" xml:space="preserve">
          <source>Given that input, ReadMIMEHeader returns the map:</source>
          <target state="translated">Dada esa entrada,ReadMIMEHeader devuelve el mapa:</target>
        </trans-unit>
        <trans-unit id="0d7c5c492a7ddeb919966cbf89bf311a727d8ab3" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Glob ignora los errores del sistema de archivos como los errores de E/S que leen los directorios.El único error posible que se devuelve es ErrBadPattern,cuando el patrón está malformado.</target>
        </trans-unit>
        <trans-unit id="5a57ea57c1f0982972dd2d2f408926f91cf67c45" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').</source>
          <target state="translated">Glob devuelve los nombres de todos los archivos que coinciden con el patrón o nulo si no hay ningún archivo que coincida.La sintaxis de los patrones es la misma que en Match.El patrón puede describir nombres jerárquicos como /usr/*/bin/ed (asumiendo que el separador es '/').</target>
        </trans-unit>
        <trans-unit id="599aa1de3cf0d500e8e5f7d1a178d0ab1cc0a630" translate="yes" xml:space="preserve">
          <source>Global returns the JavaScript global object, usually &quot;window&quot; or &quot;global&quot;.</source>
          <target state="translated">Global devuelve el objeto global JavaScript,normalmente &quot;ventana&quot; o &quot;global&quot;.</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="e2b7859482bcbcd7f30181447cb1227d814aecb3" translate="yes" xml:space="preserve">
          <source>Go Path</source>
          <target state="translated">Camino de ida</target>
        </trans-unit>
        <trans-unit id="31c51be344c4f61c8aa40bf7e10aeaf5b3b1af91" translate="yes" xml:space="preserve">
          <source>Go Programming Language</source>
          <target state="translated">Lenguaje de programación Go</target>
        </trans-unit>
        <trans-unit id="2c968e5f87e6cf184e435232ef5dd7937823c72a" translate="yes" xml:space="preserve">
          <source>Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.</source>
          <target state="translated">El código Go construido con -buildmode=c-archivo o -buildmode=c-compartido no instalará ningún otro manejador de señales por defecto.Si hay un manejador de señal existente,el tiempo de ejecución de Go activará la bandera SA_ONSTACK y de lo contrario mantendrá el manejador de señal.Si se llama a Notify para una señal asíncrona,se instalará un manejador de señal Go para esa señal.Si,más tarde,se llama Reset para esa señal,se reinstalará el manejador original para esa señal,restaurando el manejador de señal no-Go si lo hubiera.</target>
        </trans-unit>
        <trans-unit id="799dd6ab824dcf093ff420451386c628fa2a9520" translate="yes" xml:space="preserve">
          <source>Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.</source>
          <target state="translated">El código Go construido sin -buildmode=c-archivo o -buildmode=c-compartido instalará un manejador de señales para las señales asíncronas listadas arriba,y guardará cualquier manejador de señales existente.Si una señal se entrega a un hilo no-Go,actuará como se describe arriba,excepto que si hay un manejador de señales no-Go existente,ese manejador se instalará antes de elevar la señal.</target>
        </trans-unit>
        <trans-unit id="eb5d4b3ab79b5b09438ad686f6a173b50aeb10bd" translate="yes" xml:space="preserve">
          <source>Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link.</source>
          <target state="translated">Los identificadores Go que aparecen en el mapa de palabras están en cursiva;si el valor correspondiente del mapa no es la cadena vacía,se considera una URL y la palabra se convierte en un enlace.</target>
        </trans-unit>
        <trans-unit id="ea224aeb731dc78304c02f088e7a39cfe984c1f7" translate="yes" xml:space="preserve">
          <source>Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.</source>
          <target state="translated">Go invoca la función asincrónicamente.Devuelve la estructura de llamada que representa la invocación.El canal hecho señalará cuando la llamada se complete devolviendo el mismo objeto de la llamada.Si done es nulo,Go asignará un nuevo canal.Si no es nulo,done debe ser almacenado en el buffer o Go se bloqueará deliberadamente.</target>
        </trans-unit>
        <trans-unit id="a7c304672885987fa9e2bc01caee3388d0b9796b" translate="yes" xml:space="preserve">
          <source>Go programs that use cgo or SWIG</source>
          <target state="translated">Los programas Go que usan cgo o SWIG</target>
        </trans-unit>
        <trans-unit id="f00375ef44991e7032fc680e2e8afc5d4b4ddcac" translate="yes" xml:space="preserve">
          <source>GoStringer</source>
          <target state="translated">GoStringer</target>
        </trans-unit>
        <trans-unit id="776ec360ea626f63aba6d19bf197cc0106f28f0c" translate="yes" xml:space="preserve">
          <source>GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.</source>
          <target state="translated">GoStringer es implementado por cualquier valor que tenga un método GoString,que define la sintaxis Go para ese valor.El método GoString se utiliza para imprimir valores pasados como operando a un formato %#v.</target>
        </trans-unit>
        <trans-unit id="06664245ef1dbe050dbc75990b043c9e9da34427" translate="yes" xml:space="preserve">
          <source>GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters.</source>
          <target state="translated">GoWhitespace es el valor por defecto del campo Espacio Blanco del Escáner.Su valor selecciona los caracteres del espacio blanco de Go.</target>
        </trans-unit>
        <trans-unit id="13594eb4e63d05205c24ee0d18474bb09fad234a" translate="yes" xml:space="preserve">
          <source>Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference.</source>
          <target state="translated">Gob puede decodificar un valor de cualquier tipo implementando las interfaces GobDecoder o encoding.BinaryUnmarshaler llamando al método correspondiente,de nuevo en ese orden de preferencia.</target>
        </trans-unit>
        <trans-unit id="7274c1618f0661ff86ead432a84f718728e78907" translate="yes" xml:space="preserve">
          <source>Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference.</source>
          <target state="translated">Gob puede codificar un valor de cualquier tipo implementando las interfaces GobEncoder o encoding.BinaryMarshaler llamando al método correspondiente,en ese orden de preferencia.</target>
        </trans-unit>
        <trans-unit id="3f0664b183bab943699d699e2b7fa06d50e41b1a" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface.</source>
          <target state="translated">GobDecode implementa la interfaz gob.GobDecoder.</target>
        </trans-unit>
        <trans-unit id="d350a1211682bc77e1cf31df3df91c75eb68270c" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.</source>
          <target state="translated">GobDecode implementa la interfaz gob.GobDecoder.El resultado se redondea según la precisión y el modo de redondeo de z,a menos que la precisión de z sea 0,en cuyo caso z se ajusta exactamente al valor decodificado.</target>
        </trans-unit>
        <trans-unit id="dd719ca2cfb03b3cfba4caf011be5a1140872694" translate="yes" xml:space="preserve">
          <source>GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.</source>
          <target state="translated">GobDecoder es la interfaz que describe los datos que proporciona su propia rutina para decodificar los valores transmitidos enviados por un GobEncoder.</target>
        </trans-unit>
        <trans-unit id="d5aa87ccb7988a5106efef8e6d2f9cae7932e9c6" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface.</source>
          <target state="translated">GobEncode implementa la interfaz gob.GobEncoder.</target>
        </trans-unit>
        <trans-unit id="20cb90d239fa73b1f6938fdb92b390d973a1de7f" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.</source>
          <target state="translated">GobEncode implementa la interfaz gob.GobEncoder.El valor de Float y todos sus atributos (precisión,modo de redondeo,exactitud)son clasificados.</target>
        </trans-unit>
        <trans-unit id="a019b8cdacb9fe6be4bcfe375ae2210cd1a4074d" translate="yes" xml:space="preserve">
          <source>GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.</source>
          <target state="translated">GobEncoder es la interfaz que describe los datos que proporciona su propia representación para codificar los valores para la transmisión a un GobDecoder.Un tipo que implementa GobEncoder y GobDecoder tiene un control completo sobre la representación de sus datos y por lo tanto puede contener cosas como campos privados,canales y funciones,que no suelen ser transmisibles en los flujos de gob.</target>
        </trans-unit>
        <trans-unit id="3af908c6818caa06d786a8ce4e61618d352da418" translate="yes" xml:space="preserve">
          <source>Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.</source>
          <target state="translated">Goexit termina el goroutine que lo llama.Ninguna otra gorutita se ve afectada.Goexit ejecuta todas las llamadas diferidas antes de terminar el goroutine.Debido a que Goexit no es un pánico,cualquier llamada de recuperación en esas funciones diferidas volverá a ser nula.</target>
        </trans-unit>
        <trans-unit id="92c1b5045c151c8351b05867329857d4da35385e" translate="yes" xml:space="preserve">
          <source>GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &amp;gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, GoroutineProfile does not change p and returns n, false.</source>
          <target state="translated">GoroutineProfile devuelve n, el n&amp;uacute;mero de registros en el perfil de pila de goroutine activo. Si len (p)&amp;gt; = n, GoroutineProfile copia el perfil en py devuelve n, verdadero. Si len (p) &amp;lt;n, GoroutineProfile no cambia py devuelve n, falso.</target>
        </trans-unit>
        <trans-unit id="62967be4b08298e25e7959a7cdc5602a2a2be72a" translate="yes" xml:space="preserve">
          <source>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.</source>
          <target state="translated">Gosched produce el procesador,permitiendo que otros goroutines corran.No suspende el goroutine actual,por lo que la ejecución se reanuda automáticamente.</target>
        </trans-unit>
        <trans-unit id="1c2aaf1310e2e413d539667c1a3e7771e58933c6" translate="yes" xml:space="preserve">
          <source>GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.</source>
          <target state="translated">GotConnInfo es el argumento de la función ClientTrace.GotConn y contiene información sobre la conexión obtenida.</target>
        </trans-unit>
        <trans-unit id="8aa6da089a7b549e351002a5e03605264795ad2e" translate="yes" xml:space="preserve">
          <source>GraphicRanges defines the set of graphic characters according to Unicode.</source>
          <target state="translated">GraphicRanges define el conjunto de caracteres gráficos según el Unicode.</target>
        </trans-unit>
        <trans-unit id="e7195fa4641b119dd2889d0a417f633c2b3c037d" translate="yes" xml:space="preserve">
          <source>Gray is an in-memory image whose At method returns color.Gray values.</source>
          <target state="translated">El gris es una imagen en memoria cuyo método At devuelve el color.Valores de gris.</target>
        </trans-unit>
        <trans-unit id="8551691479e553fcfd58c230f9f1c7702a08e936" translate="yes" xml:space="preserve">
          <source>Gray represents an 8-bit grayscale color.</source>
          <target state="translated">El gris representa un color de escala de grises de 8 bits.</target>
        </trans-unit>
        <trans-unit id="8be44534e41a9fdc599304347782cb967b0bd62b" translate="yes" xml:space="preserve">
          <source>Gray16 is an in-memory image whose At method returns color.Gray16 values.</source>
          <target state="translated">Gray16 es una imagen en memoria cuyo método At devuelve valores de color.Gray16.</target>
        </trans-unit>
        <trans-unit id="b7ee628ee7a9a7bf06c313fa8d8dc808a58abb8f" translate="yes" xml:space="preserve">
          <source>Gray16 represents a 16-bit grayscale color.</source>
          <target state="translated">El gris 16 representa un color de escala de grises de 16 bits.</target>
        </trans-unit>
        <trans-unit id="6e09be6a83f7d3163e99081e0c679a65e139fc8d" translate="yes" xml:space="preserve">
          <source>Group represents a grouping of users.</source>
          <target state="translated">El grupo representa una agrupación de usuarios.</target>
        </trans-unit>
        <trans-unit id="7de1bb0487db53a77d3d5fa786aa26f9027ba7c1" translate="yes" xml:space="preserve">
          <source>GroupIds returns the list of group IDs that the user is a member of.</source>
          <target state="translated">GroupIds devuelve la lista de ID de grupo de la que el usuario es miembro.</target>
        </trans-unit>
        <trans-unit id="d0e679bf3eeb0246c0708b92532613618a2a5627" translate="yes" xml:space="preserve">
          <source>Grouping:</source>
          <target state="translated">Grouping:</target>
        </trans-unit>
        <trans-unit id="a3dd80da68d80e7f0e9f29bcc9f5cb31d2777884" translate="yes" xml:space="preserve">
          <source>Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.</source>
          <target state="translated">El crecimiento aumenta la capacidad de b,si es necesario,para garantizar el espacio para otros n bytes.Después de Grow(n),al menos n bytes pueden ser escritos a b sin otra asignación.Si n es negativo,Grow entra en pánico.</target>
        </trans-unit>
        <trans-unit id="ea6ca3eab6713cfdabbbddc578b2358a70e4ccb7" translate="yes" xml:space="preserve">
          <source>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.</source>
          <target state="translated">Crece la capacidad del buffer,si es necesario,para garantizar espacio para otros n bytes.Después de Grow(n),al menos n bytes pueden ser escritos en el buffer sin otra asignación.Si n es negativo,Grow entrará en pánico.Si el buffer no puede crecer entrará en pánico con ErrTooLarge.</target>
        </trans-unit>
        <trans-unit id="fcfc665b9c38534864ef4c48c8a42633500c63ee" translate="yes" xml:space="preserve">
          <source>Gzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data.</source>
          <target state="translated">Los archivos Gzip almacenan una longitud y una suma de control de los datos sin comprimir.El lector devolverá una suma de comprobación cuando el lector llegue al final de los datos sin comprimir si no tiene la longitud o la suma de comprobación esperada.Los clientes deben tratar los datos devueltos por la Lectura como tentativos hasta que reciban el io.EOF que marca el final de los datos.</target>
        </trans-unit>
        <trans-unit id="5d71851e777cb11c10615f1403f7831b2abdc279" translate="yes" xml:space="preserve">
          <source>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.</source>
          <target state="translated">El HTML encapsula un fragmento de documento HTML seguro conocido.No debe ser usado para HTML de un tercero,o HTML con etiquetas o comentarios no cerrados.Los resultados de un desinfectante HTML de sonido y una plantilla escapada por este paquete están bien para ser usados con HTML.</target>
        </trans-unit>
        <trans-unit id="b3eeeba32a88681f357c6658794b2cde0a1ffee1" translate="yes" xml:space="preserve">
          <source>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.</source>
          <target state="translated">Las plantillas HTML tratan los valores de los datos como texto plano que debe ser codificado para que puedan ser incrustados con seguridad en un documento HTML.La fuga es contextual,por lo que las acciones pueden aparecer dentro de los contextos de JavaScript,CSS y URI.</target>
        </trans-unit>
        <trans-unit id="9941fc69ceb0b7c4c9cd661ccc1d3296d53a1466" translate="yes" xml:space="preserve">
          <source>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=&quot;ltr&quot;`.</source>
          <target state="translated">HTMLAttr encapsula un atributo HTML de una fuente de confianza,por ejemplo,` dir=&quot;ltr&quot;`.</target>
        </trans-unit>
        <trans-unit id="56515df9ce780f70db2a14123d61a78cb0491ced" translate="yes" xml:space="preserve">
          <source>HTMLAutoClose is the set of HTML elements that should be considered to close automatically.</source>
          <target state="translated">HTMLAutoClose es el conjunto de elementos HTML que se debe considerar que se cierran automáticamente.</target>
        </trans-unit>
        <trans-unit id="e3ae2c19a119f12f6bd7618bea966cc88fb1903b" translate="yes" xml:space="preserve">
          <source>HTMLEntity is an entity map containing translations for the standard HTML entity characters.</source>
          <target state="translated">HTMLEntity es un mapa de entidad que contiene traducciones para los caracteres de entidad HTML estándar.</target>
        </trans-unit>
        <trans-unit id="0502b94bdac42557ec458b2bcfd7d81519bb7f5f" translate="yes" xml:space="preserve">
          <source>HTMLEscape</source>
          <target state="translated">HTMLEscape</target>
        </trans-unit>
        <trans-unit id="108bb0274697ed474af72c0af28941c4694cc443" translate="yes" xml:space="preserve">
          <source>HTMLEscape appends to dst the JSON-encoded src with &amp;lt;, &amp;gt;, &amp;amp;, U+2028 and U+2029 characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029 so that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &amp;lt;script&amp;gt; tags, so an alternative JSON encoding must be used.</source>
          <target state="translated">HTMLEscape agrega a dst el src codificado en JSON con &amp;lt;,&amp;gt;, &amp;amp;, U + 2028 y U + 2029 caracteres dentro de los literales de cadena cambiados a \ u003c, \ u003e, \ u0026, \ u2028, \ u2029 para que el JSON sea seguro para incrustar dentro de las etiquetas HTML &amp;lt;script&amp;gt;. Por motivos hist&amp;oacute;ricos, los navegadores web no respetan el escape HTML est&amp;aacute;ndar dentro de las etiquetas &amp;lt;script&amp;gt;, por lo que se debe utilizar una codificaci&amp;oacute;n JSON alternativa.</target>
        </trans-unit>
        <trans-unit id="eaa5eff89dbdb13500c068f0e84bf21b7f3be3fb" translate="yes" xml:space="preserve">
          <source>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</source>
          <target state="translated">HTMLEscape escribe a w el equivalente HTML escapado de los datos de texto plano b.</target>
        </trans-unit>
        <trans-unit id="eba1f3f7ea429a820bedfa415a707d8da7ce1238" translate="yes" xml:space="preserve">
          <source>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</source>
          <target state="translated">HTMLEscapeString devuelve el equivalente HTML escapado de los datos de texto plano s.</target>
        </trans-unit>
        <trans-unit id="8b2dbe52305b6c07dd244c27d634207753a8523e" translate="yes" xml:space="preserve">
          <source>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.</source>
          <target state="translated">HTMLEscaper devuelve el equivalente HTML escapado de la representación textual de sus argumentos.</target>
        </trans-unit>
        <trans-unit id="9304c86e0fba62ba5daa5297c254f425c77df161" translate="yes" xml:space="preserve">
          <source>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before.</source>
          <target state="translated">Los Trailers HTTP son un conjunto de pares clave/valor como cabeceras que vienen después de la respuesta HTTP,en lugar de antes.</target>
        </trans-unit>
        <trans-unit id="0f4dea56c9591992aae081556a866da7a62d7c76" translate="yes" xml:space="preserve">
          <source>HTTP status codes as registered with IANA. See: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</source>
          <target state="translated">C&amp;oacute;digos de estado HTTP registrados en IANA. Ver: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ffb0634925a034a37cf81c8bf163966c760740e9" translate="yes" xml:space="preserve">
          <source>HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with &quot;h2&quot; in the TLS Config.NextProtos.</source>
          <target state="translated">El soporte HTTP/2 sólo está habilitado si el Escuchador devuelve las conexiones *tls.Conn y fueron configuradas con &quot;h2&quot; en el TLS Config.NextProtos.</target>
        </trans-unit>
        <trans-unit id="5ee0353f20802f9b3b832dc664b1cf16f1dd8c83" translate="yes" xml:space="preserve">
          <source>HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.</source>
          <target state="translated">HalfReader devuelve un lector que implementa Read by reading la mitad de los bytes solicitados de r.</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="1f7743a2da5a9b87698980081ed0a9b4a848c67b" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">Handle registra el manejador para el patrón dado en el DefaultServeMux.La documentación de ServeMux explica cómo se emparejan los patrones.</target>
        </trans-unit>
        <trans-unit id="adfb5ece7bb714f07a8d92f38ecaccd93eb91488" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.</source>
          <target state="translated">Handle registra al manipulador para el patrón dado.Si un manejador ya existe para el patrón,Manejar entra en pánico.</target>
        </trans-unit>
        <trans-unit id="9df709e02c4285ab3a3440b49e05002a1810c202" translate="yes" xml:space="preserve">
          <source>HandleFunc</source>
          <target state="translated">HandleFunc</target>
        </trans-unit>
        <trans-unit id="ba3631b03a8549831c70fb0b756b06eb4ccdf22e" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">El HandleFunc registra la función del handler para el patrón dado en el DefaultServeMux.La documentación de ServeMux explica cómo se emparejan los patrones.</target>
        </trans-unit>
        <trans-unit id="671e02c9111874e0dde4ea20673fb01320ed5a12" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern.</source>
          <target state="translated">HandleFunc registra la función del manipulador para el patrón dado.</target>
        </trans-unit>
        <trans-unit id="b8bc0ae743c24154bab55e05ddac119f84a83a3e" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP registra un manejador HTTP para mensajes RPC en rpcPath,y un manejador de depuración en debugPath.Todavía es necesario invocar http.Serve(),típicamente en una sentencia go.</target>
        </trans-unit>
        <trans-unit id="104cf096656ffcb1565dfd1219d7035e43630f88" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP registra un manejador HTTP para mensajes RPC a DefaultServer en DefaultRPCPath y un manejador de depuración en DefaultDebugPath.Todavía es necesario invocar http.Serve(),típicamente en una sentencia go.</target>
        </trans-unit>
        <trans-unit id="a62b57b0720d266ed6489a123759bbfe855bf88a" translate="yes" xml:space="preserve">
          <source>Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect.</source>
          <target state="translated">Handler también devuelve el patrón registrado que coincide con la solicitud o,en el caso de redirecciones generadas internamente,el patrón que coincidirá después de seguir la redirección.</target>
        </trans-unit>
        <trans-unit id="0ddb06f6f85fc2ca7a7cc5302dfee4fc45947bee" translate="yes" xml:space="preserve">
          <source>Handler returns an HTTP handler that serves the named profile.</source>
          <target state="translated">El manipulador devuelve un manipulador HTTP que sirve el perfil nombrado.</target>
        </trans-unit>
        <trans-unit id="4065eef104a7b00ebd8ce9a91293334fd4bb0db9" translate="yes" xml:space="preserve">
          <source>Handler returns the expvar HTTP Handler.</source>
          <target state="translated">El Manejador devuelve el Manejador HTTP Expvar.</target>
        </trans-unit>
        <trans-unit id="e63273beb69f3454c447975682e44a2c5d4a0c1e" translate="yes" xml:space="preserve">
          <source>Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.</source>
          <target state="translated">El manejador devuelve el manejador para que lo use para la petición dada,consultando r.Method,r.Host,y r.URL.Path.Siempre devuelve un handler no nil.Si la ruta no está en su forma canónica,el manejador será un manejador generado internamente que redirige a la ruta canónica.Si el host contiene un puerto,se ignora al hacer coincidir los handlers.</target>
        </trans-unit>
        <trans-unit id="a812b2fb8f7451d8a9be630f8c521fc7613cf74d" translate="yes" xml:space="preserve">
          <source>Handler runs an executable in a subprocess with a CGI environment.</source>
          <target state="translated">El manipulador ejecuta un ejecutable en un subproceso con un entorno CGI.</target>
        </trans-unit>
        <trans-unit id="612e8566dcf29030b3f86ae45fac3cd161070575" translate="yes" xml:space="preserve">
          <source>Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of &quot;-&quot;.</source>
          <target state="translated">El manejo de campos estructurales anónimos es nuevo en Go 1.1.Antes de Go 1.1,los campos estructurales anónimos eran ignorados.Para forzar la ignorancia de un campo de estructura anónima tanto en la versión actual como en las anteriores,dale al campo una etiqueta JSON de &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="5bd11c3402a6253a1d760b097dca2d66d778e6dd" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd5447a341844b0e1ee2ac00ed949437eac1c43" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">Handshake ejecuta el protocolo de handshake del cliente o del servidor si aún no se ha ejecutado.La mayoría de los usos de este paquete no necesitan llamar a Handshake explícitamente:el primer Read or Write lo llamará automáticamente.</target>
        </trans-unit>
        <trans-unit id="0bf39eaf505133458b930fe0c34986ca5b577cc9" translate="yes" xml:space="preserve">
          <source>HasExpired reports whether certList should have been updated by now.</source>
          <target state="translated">Ha caducado el informe sobre si certList debería haber sido actualizado ya.</target>
        </trans-unit>
        <trans-unit id="d390517d58b930cb269df7a0b32aa914bfb5311d" translate="yes" xml:space="preserve">
          <source>HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.</source>
          <target state="translated">HasOk informa si la expresión correspondiente puede ser usada en los rhs de una asignación de coma-ok.</target>
        </trans-unit>
        <trans-unit id="e53848ef4c6fc884ed74c95d3ab525fa42a2bbe7" translate="yes" xml:space="preserve">
          <source>HasPrefix</source>
          <target state="translated">HasPrefix</target>
        </trans-unit>
        <trans-unit id="8d314f541aff1011d7ddb318695b8f61b2af6ec2" translate="yes" xml:space="preserve">
          <source>HasPrefix exists for historical compatibility and should not be used.</source>
          <target state="translated">HasPrefix existe para la compatibilidad histórica y no debe utilizarse.</target>
        </trans-unit>
        <trans-unit id="2669e9427d4779bbc09f60c5ccfd3fe6d15b6c70" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the byte slice s begins with prefix.</source>
          <target state="translated">HasPrefix comprueba si el byte slice s empieza con prefijo.</target>
        </trans-unit>
        <trans-unit id="5cd07ae1c7bc3b9ed87eb16cdb61e05184635090" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the string s begins with prefix.</source>
          <target state="translated">HasPrefix comprueba si la cadena s empieza con prefijo.</target>
        </trans-unit>
        <trans-unit id="117455f286c7643c45e4bb7a574dddee082000d6" translate="yes" xml:space="preserve">
          <source>HasSuffix</source>
          <target state="translated">HasSuffix</target>
        </trans-unit>
        <trans-unit id="0d84ad6d23e5d60c659894725feb80de1e5bc00b" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the byte slice s ends with suffix.</source>
          <target state="translated">HasSuffix comprueba si la rebanada de bytes s termina con el sufijo.</target>
        </trans-unit>
        <trans-unit id="71e6720e740d9f5d90d030cf5d260029a0041a76" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the string s ends with suffix.</source>
          <target state="translated">HasSuffix prueba si la s de la cadena termina con el sufijo.</target>
        </trans-unit>
        <trans-unit id="c07fb815b0dd23f98464b6c96ba0043996f42574" translate="yes" xml:space="preserve">
          <source>Hash identifies a cryptographic hash function that is implemented in another package.</source>
          <target state="translated">El hash identifica una función de hash criptográfica que se implementa en otro paquete.</target>
        </trans-unit>
        <trans-unit id="a8a4a81d7a93ec8ea6de29fca7e817e8b0ccf094" translate="yes" xml:space="preserve">
          <source>Hash implementations in the standard library (e.g. hash/crc32 and crypto/sha256) implement the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.</source>
          <target state="translated">Las implementaciones de hash en la biblioteca estándar (por ejemplo,hash/crc32 y crypto/sha256)implementan las interfaces encoding.BinaryMarshaler y encoding.BinaryUnmarshaler.La implementación de un hash permite que su estado interno se guarde y se utilice para un procesamiento adicional más adelante,sin tener que volver a escribir los datos previamente escritos en el hash.El estado de hash puede contener porciones de la entrada en su forma original,que se espera que los usuarios manejen para cualquier posible implicación de seguridad.</target>
        </trans-unit>
        <trans-unit id="afa3769866aaa8e9ccd0894bbb12db0f2a42b294" translate="yes" xml:space="preserve">
          <source>Hash is the common interface implemented by all hash functions.</source>
          <target state="translated">El hash es la interfaz común implementada por todas las funciones de hash.</target>
        </trans-unit>
        <trans-unit id="bbb248d3e1082f71a91f55221f9ef1629bac5c92" translate="yes" xml:space="preserve">
          <source>Hash32 is the common interface implemented by all 32-bit hash functions.</source>
          <target state="translated">Hash32 es la interfaz común implementada por todas las funciones de hash de 32 bits.</target>
        </trans-unit>
        <trans-unit id="05bc44af5e367ef4fc60329373f6d1a44dbf5c85" translate="yes" xml:space="preserve">
          <source>Hash64 is the common interface implemented by all 64-bit hash functions.</source>
          <target state="translated">Hash64 es la interfaz común implementada por todas las funciones de hash de 64 bits.</target>
        </trans-unit>
        <trans-unit id="4aa2a3cc436464a090fd637734a2095043d7b259" translate="yes" xml:space="preserve">
          <source>HashFunc returns opts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3959061e57c74057bbf958321e7f6031a26bba89" translate="yes" xml:space="preserve">
          <source>HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">HashFunc devuelve pssOpts.Hash para que PSSOptions implemente crypto.SignerOpts.</target>
        </trans-unit>
        <trans-unit id="860155016136afc0d36dbbc3f9fc98412399783e" translate="yes" xml:space="preserve">
          <source>HashFunc simply returns the value of h so that Hash implements SignerOpts.</source>
          <target state="translated">HashFunc simplemente devuelve el valor de h para que Hash implemente SignerOpts.</target>
        </trans-unit>
        <trans-unit id="cd2b2728ea1f997355e4a7e5005a26c5306f470a" translate="yes" xml:space="preserve">
          <source>Head is a wrapper around DefaultClient.Head</source>
          <target state="translated">La cabeza es una envoltura alrededor del cliente predeterminado.La cabeza</target>
        </trans-unit>
        <trans-unit id="93e59ac29bb3c357b0f9c42db1f78e97e116c128" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Head emite un HEAD a la URL especificada.Si la respuesta es uno de los siguientes códigos de redireccionamiento,Head sigue el redireccionamiento después de llamar a la función CheckRedirect del cliente:</target>
        </trans-unit>
        <trans-unit id="24094406af9408bd066ab26a0a1ef55bdcdead08" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Head emite un HEAD a la URL especificada.Si la respuesta es uno de los siguientes códigos de redireccionamiento,Head sigue el redireccionamiento,hasta un máximo de 10 redirecciones:</target>
        </trans-unit>
        <trans-unit id="a50c7cbf99b8cae529cf3d620f5022a1c82e8fca" translate="yes" xml:space="preserve">
          <source>Header implements http.ResponseWriter. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the Result method and see the returned Response value's Header.</source>
          <target state="translated">Header implementa http.ResponseWriter.Devuelve los encabezados de respuesta para que muten dentro de un manejador.Para probar los encabezados que se escribieron después de que un manejador se completa,utilice el método de resultado y vea el encabezado del valor de respuesta devuelto.</target>
        </trans-unit>
        <trans-unit id="2a403ca7fd2ae0865923ded1f911ee30d4fbde83" translate="yes" xml:space="preserve">
          <source>Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as &quot;localhost&quot; automatically otherwise. If Hello is called, it must be called before any of the other methods.</source>
          <target state="translated">Hello envía un HELO o EHLO al servidor como el nombre de host dado.Llamar a este método sólo es necesario si el cliente necesita controlar el nombre de host utilizado.De lo contrario,el cliente se presentará como &quot;localhost&quot; automáticamente.Si se llama HOLA,debe ser llamado antes que cualquiera de los otros métodos.</target>
        </trans-unit>
        <trans-unit id="0aed41610e50a1818172a103900a5a6fdac5322e" translate="yes" xml:space="preserve">
          <source>Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.</source>
          <target state="translated">El ayudante marca la función de llamada como una función de ayuda de prueba.Cuando se imprime la información de archivos y líneas,esa función se salta.El ayudante puede ser llamado simultáneamente desde varios goroutines.</target>
        </trans-unit>
        <trans-unit id="aa0b52b8a6b42d9b0905c653c010a924ae5e874a" translate="yes" xml:space="preserve">
          <source>Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word &quot;output&quot;:</source>
          <target state="translated">Aquí hay algunos ejemplos de plantillas de una línea que demuestran las tuberías y las variables.Todas producen la palabra citada &quot;salida&quot;:</target>
        </trans-unit>
        <trans-unit id="89620d229387855063bd56a8e6d5a3250086c9f0" translate="yes" xml:space="preserve">
          <source>Here is a simple example, opening a file and reading some of it.</source>
          <target state="translated">Aquí hay un ejemplo simple,abriendo un archivo y leyendo algo de él.</target>
        </trans-unit>
        <trans-unit id="2824caba6baa2187c9e56d7836920f8ff25bcc71" translate="yes" xml:space="preserve">
          <source>Here is a simple example. A server wishes to export an object of type Arith:</source>
          <target state="translated">Aquí hay un ejemplo simple.Un servidor desea exportar un objeto de tipo Arith:</target>
        </trans-unit>
        <trans-unit id="2c22db98d01fc50d0681541a0b0caf2c4141f0f4" translate="yes" xml:space="preserve">
          <source>Here is a trivial example that prints &quot;17 items are made of wool&quot;.</source>
          <target state="translated">He aquí un ejemplo trivial que imprime &quot;17 artículos están hechos de lana&quot;.</target>
        </trans-unit>
        <trans-unit id="dc0bea3647dd8635722162c3a9c56cc10d70b7ac" translate="yes" xml:space="preserve">
          <source>Here is the list of actions. &quot;Arguments&quot; and &quot;pipelines&quot; are evaluations of data, defined in detail in the corresponding sections that follow.</source>
          <target state="translated">Aquí está la lista de acciones.&quot;Argumentos&quot; y &quot;conductos&quot; son evaluaciones de datos,definidas en detalle en las secciones correspondientes que siguen.</target>
        </trans-unit>
        <trans-unit id="c3b612d75a40adadd01e188d1e2aba30e8b88d33" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from a directory.</source>
          <target state="translated">Aquí demostramos la carga de un conjunto de plantillas de un directorio.</target>
        </trans-unit>
        <trans-unit id="c18d789286c40d70b27c77faebcb174f22c85dbc" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from files in different directories</source>
          <target state="translated">Aquí demostramos la carga de un conjunto de plantillas de archivos en diferentes directorios</target>
        </trans-unit>
        <trans-unit id="bcef5f73d0a48aab25273d92f8664ff4fb80379d" translate="yes" xml:space="preserve">
          <source>Here's an example directory layout:</source>
          <target state="translated">Aquí hay un ejemplo de diseño de directorio:</target>
        </trans-unit>
        <trans-unit id="35d5d6962be99793c34862b1061c8b5cacf67fc9" translate="yes" xml:space="preserve">
          <source>HexEncoding is the &amp;ldquo;Extended Hex Alphabet&amp;rdquo; defined in RFC 4648. It is typically used in DNS.</source>
          <target state="translated">HexEncoding es el &quot;alfabeto hexadecimal extendido&quot; definido en RFC 4648. Se utiliza normalmente en DNS.</target>
        </trans-unit>
        <trans-unit id="e23f68e03ccbc9812663415a4a25267a75156114" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">El secuestro separa el ClientConn y devuelve la conexión subyacente así como el bufio de lectura que puede tener algunos datos sobrantes.El secuestro puede ser llamado antes de que el usuario o la lectura hayan señalado el final de la lógica de mantener la vida.El usuario no debe llamar al Hijack mientras la Lectura o la Escritura están en curso.</target>
        </trans-unit>
        <trans-unit id="9150896df8944dbbb2d645bc78167fd76df1dc80" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">El secuestro desconecta el ServerConn y devuelve la conexión subyacente así como el bufio de lectura que puede tener algunos datos sobrantes.El secuestro puede ser llamado antes de que la lectura haya señalado el final de la lógica de mantener la vida.El usuario no debe llamar al Hijack mientras la Lectura o la Escritura estén en curso.</target>
        </trans-unit>
        <trans-unit id="4a56321e103f0a1a522b694db3cb8d2d733e26fd" translate="yes" xml:space="preserve">
          <source>Hijacker</source>
          <target state="translated">Hijacker</target>
        </trans-unit>
        <trans-unit id="162450ef640a1216b7486b356d2e0daf7f97ce1d" translate="yes" xml:space="preserve">
          <source>Hostname returns the host name reported by the kernel.</source>
          <target state="translated">El nombre del host devuelve el nombre del host reportado por el núcleo.</target>
        </trans-unit>
        <trans-unit id="96c776e02774d643d6c9b2543ae4ea531e374ca6" translate="yes" xml:space="preserve">
          <source>Hostname returns u.Host, stripping any valid port number if present.</source>
          <target state="translated">El nombre de host devuelve u.Host,quitando cualquier número de puerto válido si está presente.</target>
        </trans-unit>
        <trans-unit id="c10a91f09a43d36b8c063665239759dddfc07545" translate="yes" xml:space="preserve">
          <source>HostnameError results when the set of authorized names doesn't match the requested name.</source>
          <target state="translated">HostnameError resulta cuando el conjunto de nombres autorizados no coincide con el nombre solicitado.</target>
        </trans-unit>
        <trans-unit id="a732fe7ae23ec635b26f3cda289c15cbca4f3d8c" translate="yes" xml:space="preserve">
          <source>Hour returns the hour within the day specified by t, in the range [0, 23].</source>
          <target state="translated">La hora devuelve la hora dentro del día especificado por t,en el rango [0,23].</target>
        </trans-unit>
        <trans-unit id="316afefe22138dc95ee9f3b2f4bc4164e8b8424e" translate="yes" xml:space="preserve">
          <source>Hours returns the duration as a floating point number of hours.</source>
          <target state="translated">Horas devuelve la duración como un número de horas de punto flotante.</target>
        </trans-unit>
        <trans-unit id="29032d83edd3b2c57e81fe35f7063e01de42a614" translate="yes" xml:space="preserve">
          <source>However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; for details.</source>
          <target state="translated">Sin embargo, puede haber varias coincidencias m&amp;aacute;s largas a la izquierda, con diferentes opciones de subcoincidencia, y aqu&amp;iacute; este paquete difiere de POSIX. Entre las posibles coincidencias m&amp;aacute;s largas a la izquierda, este paquete elige la que una b&amp;uacute;squeda de retroceso habr&amp;iacute;a encontrado primero, mientras que POSIX especifica que la coincidencia se elija para maximizar la longitud de la primera subexpresi&amp;oacute;n, luego la segunda, y as&amp;iacute; sucesivamente de izquierda a derecha . La regla POSIX es computacionalmente prohibitiva y ni siquiera est&amp;aacute; bien definida. Consulte &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="40708df18a19eb4cd04fce64de3e8c9f00288cb2" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and ASCII space character (&quot;{{- &quot;), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by a space and minus sign (&quot; -}}&quot;), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">Sin embargo,para ayudar a formatear el código fuente de la plantilla,si el delimitador izquierdo de una acción (por defecto &quot;{{&quot;)va seguido inmediatamente de un signo menos y un carácter de espacio ASCII (&quot;{{-&quot;),todos los espacios en blanco posteriores se recortan del texto inmediatamente anterior.De manera similar,si el delimitador derecho (&quot;}}&quot;)está precedido por un espacio y un signo menos (&quot; -}}&quot;),todos los espacios en blanco anteriores se recortan del texto inmediatamente posterior.En estos marcadores de recorte,el espacio ASCII debe estar presente;&quot;{{-3}}&quot; se analiza como una acción que contiene el número -3.</target>
        </trans-unit>
        <trans-unit id="d4e4742177e63cc124605c711f8542e79a9c655e" translate="yes" xml:space="preserve">
          <source>However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.</source>
          <target state="translated">Sin embargo,cuando se imprime un trozo de byte con un verbo en forma de cuerda (%s %q %x %X),se trata de forma idéntica a una cuerda,como un único elemento.</target>
        </trans-unit>
        <trans-unit id="5c4cbffa6231f3b3c2514644d0fee825e224c80d" translate="yes" xml:space="preserve">
          <source>Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.</source>
          <target state="translated">Hypot devuelve Sqrt(p*p+q*q),teniendo cuidado de evitar desbordamientos y desbordamientos innecesarios.</target>
        </trans-unit>
        <trans-unit id="576b7847aead683e23b77c003ff6f222a841ef25" translate="yes" xml:space="preserve">
          <source>IEEETable is the table for the IEEE polynomial.</source>
          <target state="translated">IEEETable es la tabla para el polinomio IEEE.</target>
        </trans-unit>
        <trans-unit id="a220db6c90383cf3092dacd6831c2890463d8ced" translate="yes" xml:space="preserve">
          <source>IMAGE_DIRECTORY_ENTRY constants</source>
          <target state="translated">IMAGE_DIRECTORY_ENTRY constants</target>
        </trans-unit>
        <trans-unit id="f585c9fe77a34e4b203ca7586560b165b3fa9e06" translate="yes" xml:space="preserve">
          <source>IP address lengths (bytes).</source>
          <target state="translated">Longueur des adresses IP (octets).</target>
        </trans-unit>
        <trans-unit id="8f3823940310cc4dda7efac459317d31719ee534" translate="yes" xml:space="preserve">
          <source>IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the left-most label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e746cf97286466a3ee7a6da22134f5658e5d9835" translate="yes" xml:space="preserve">
          <source>IP.DefaultMask</source>
          <target state="translated">IP.DefaultMask</target>
        </trans-unit>
        <trans-unit id="11cb3659b8e0ce7581cbb847a5c82b1c9f0fd371" translate="yes" xml:space="preserve">
          <source>IP.Mask</source>
          <target state="translated">IP.Mask</target>
        </trans-unit>
        <trans-unit id="afa88b5842f11425f491e338d7ab921fd1ba5273" translate="yes" xml:space="preserve">
          <source>IPAddr represents the address of an IP end point.</source>
          <target state="translated">IPAddr représente l'adresse d'un point final IP.</target>
        </trans-unit>
        <trans-unit id="62bf2467f82c0177288446c3c53fcfe1388fdbf4" translate="yes" xml:space="preserve">
          <source>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.</source>
          <target state="translated">IPConn est l'implémentation des interfaces Conn et PacketConn pour les connexions au réseau IP.</target>
        </trans-unit>
        <trans-unit id="f8a4e52fe170a6b87d8e8f324c9e46497e3e1a1e" translate="yes" xml:space="preserve">
          <source>IPv4</source>
          <target state="translated">IPv4</target>
        </trans-unit>
        <trans-unit id="01eafbb77fe2e5da4ec4f2fa2166e61bdbf17fda" translate="yes" xml:space="preserve">
          <source>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.</source>
          <target state="translated">IPv4 renvoie l'adresse IP (sous forme de 16 octets)de l'adresse IPv4 a.b.c.d.</target>
        </trans-unit>
        <trans-unit id="3e2065fb2c469f55091e83e0c17ec6c33b2ade3a" translate="yes" xml:space="preserve">
          <source>IPv4Mask</source>
          <target state="translated">IPv4Mask</target>
        </trans-unit>
        <trans-unit id="d0818e19fd482dbfdc092a8f03eecab69f4f02c6" translate="yes" xml:space="preserve">
          <source>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.</source>
          <target state="translated">IPv4Mask renvoie le masque IP (sous forme de 4 octets)du masque IPv4 a.b.c.d.</target>
        </trans-unit>
        <trans-unit id="84f775d13ea13d9914f862669240b386b5b2ce40" translate="yes" xml:space="preserve">
          <source>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.</source>
          <target state="translated">ISOWeek renvoie le numéro de l'année et de la semaine ISO 8601 dans laquelle t se produit.La semaine va de 1 à 53.Les mois de janvier 01 à janvier 03 de l'année n peuvent appartenir à la semaine 52 ou 53 de l'année n-1,et les mois de décembre 29 à décembre 31 peuvent appartenir à la semaine 1 de l'année n+1.</target>
        </trans-unit>
        <trans-unit id="08d6764cba419802272bb09d455c908144b957aa" translate="yes" xml:space="preserve">
          <source>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</source>
          <target state="translated">Id est une enveloppe pour Id(obj.Pkg(),obj.Name()).</target>
        </trans-unit>
        <trans-unit id="1d68ea4276c501cd9a850a1820a4a4d86fcccd10" translate="yes" xml:space="preserve">
          <source>Id returns name if it is exported, otherwise it returns the name qualified with the package path.</source>
          <target state="translated">Id renvoie le nom s'il est exporté,sinon il renvoie le nom qualifié avec le chemin du paquet.</target>
        </trans-unit>
        <trans-unit id="fa08cb5f856950ffd31e99879394c8d2ecd78b73" translate="yes" xml:space="preserve">
          <source>Identical reports whether x and y are identical types. Receivers of Signature types are ignored.</source>
          <target state="translated">Rapports identiques si x et y sont de types identiques.Les destinataires des types de signature sont ignorés.</target>
        </trans-unit>
        <trans-unit id="62582ea142e0c589620d5bd10a3675dc62d150bc" translate="yes" xml:space="preserve">
          <source>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.</source>
          <target state="translated">IdenticalIgnoreTags indique si x et y sont des types identiques si les balises sont ignorées.Les récepteurs des types de signature sont ignorés.</target>
        </trans-unit>
        <trans-unit id="1b283807cc15b11d0882e9fd847033d20b983bd2" translate="yes" xml:space="preserve">
          <source>IdentifierNode holds an identifier.</source>
          <target state="translated">IdentifierNode contient un identifiant.</target>
        </trans-unit>
        <trans-unit id="e3f7a148cc891203b5f7d36d2d9e45cad70d628a" translate="yes" xml:space="preserve">
          <source>If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n &amp;gt;= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.</source>
          <target state="translated">Si 'All' est&amp;aacute; presente, la rutina coincide con coincidencias sucesivas no superpuestas de toda la expresi&amp;oacute;n. Las coincidencias vac&amp;iacute;as que lindan con una coincidencia anterior se ignoran. El valor de retorno es un segmento que contiene los valores de retorno sucesivos de la rutina correspondiente que no es &quot;Todos&quot;. Estas rutinas toman un argumento entero adicional, n. Si n&amp;gt; = 0, la funci&amp;oacute;n devuelve como m&amp;aacute;ximo n coincidencias / subcoincidencias; de lo contrario, los devuelve todos.</target>
        </trans-unit>
        <trans-unit id="4bc5ea7c2a0ba24905139043c1e06d713fc4b624" translate="yes" xml:space="preserve">
          <source>If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.</source>
          <target state="translated">Si &quot;Index&quot; est présent,les correspondances et les sous-correspondances sont identifiées par des paires d'index d'octets dans la chaîne de saisie:le résultat [2*n:2*n+1]identifie les index de la nième sous-correspondance.La paire pour n==0 identifie la correspondance de l'expression entière.Si &quot;Index&quot; n'est pas présent,la correspondance est identifiée par le texte de la correspondance/sous-correspondance.Si un index est négatif ou si le texte est nul,cela signifie que la sous-expression ne correspond à aucune chaîne de l'entrée.Pour les versions &quot;String&quot;,une chaîne vide signifie soit aucune correspondance,soit une correspondance vide.</target>
        </trans-unit>
        <trans-unit id="750f20e67d15d8b15512065e634f8a04cd24649d" translate="yes" xml:space="preserve">
          <source>If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.</source>
          <target state="translated">Si &quot;String&quot; est présent,l'argument est une chaîne de caractères;sinon,c'est une tranche d'octets;les valeurs de retour sont ajustées comme il convient.</target>
        </trans-unit>
        <trans-unit id="6b5422b81678b9d8d259a31067e6668262dc0a15" translate="yes" xml:space="preserve">
          <source>If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on.</source>
          <target state="translated">Si &quot;Submatch&quot; est présent,la valeur de retour est une tranche identifiant les sous-parties successives de l'expression.Les sous-correspondances sont des correspondances de sous-expressions entre parenthèses (également appelées groupes de capture)dans l'expression régulière,numérotées de gauche à droite dans l'ordre de la parenthèse ouvrante.La sous-partie 0 est la correspondance de l'expression entière,la sous-partie 1 la correspondance de la première sous-expression entre parenthèses,et ainsi de suite.</target>
        </trans-unit>
        <trans-unit id="c8e129ec8b814ed3ea9bfb24aed18824a3379050" translate="yes" xml:space="preserve">
          <source>If Body is present, Content-Length is &amp;lt;= 0 and TransferEncoding hasn't been set to &quot;identity&quot;, Write adds &quot;Transfer-Encoding: chunked&quot; to the header. Body is closed after it is sent.</source>
          <target state="translated">Si Body est&amp;aacute; presente, Content-Length es &amp;lt;= 0 y TransferEncoding no se ha establecido en &quot;identidad&quot;, Write agrega &quot;Transfer-Encoding: fragmentado&quot; al encabezado. El cuerpo se cierra despu&amp;eacute;s de su env&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="a4c660d2d836ce5011f39f208170601c14fc3f84" translate="yes" xml:space="preserve">
          <source>If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in the final query arguments. This may be used to pass special options to the query itself.</source>
          <target state="translated">Si CheckNamedValue renvoie ErrRemoveArgument,la NamedValue ne sera pas incluse dans les arguments de la requête finale.Cela peut être utilisé pour passer des options spéciales à la requête elle-même.</target>
        </trans-unit>
        <trans-unit id="16a03bedfc442181d888e7b8ec8eee1e7e8562bb" translate="yes" xml:space="preserve">
          <source>If Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove the Conn from pool.</source>
          <target state="translated">Si Conn.Ping renvoie ErrBadConn,DB.Ping et DB.PingContext retireront le Conn du pool.</target>
        </trans-unit>
        <trans-unit id="9bf5fb8d1ebbb6dc425efaa4065a072560c9aaa0" translate="yes" xml:space="preserve">
          <source>If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as &quot;foo/bar&quot; and has its compiled form installed to &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (or, for gccgo, &quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</source>
          <target state="translated">Si DIR est un répertoire listé dans le chemin de Go,un paquet dont les sources se trouvent dans DIR/src/foo/bar peut être importé en tant que &quot;foo/bar&quot; et a sa forme compilée installée dans &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (ou,pour gccgo,&quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</target>
        </trans-unit>
        <trans-unit id="626d82422a444f8260197f6a255b844b957560c9" translate="yes" xml:space="preserve">
          <source>If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.</source>
          <target state="translated">Si Dir est SelectDefault,le cas représente un cas par défaut.Chan et Send doivent avoir des valeurs nulles.</target>
        </trans-unit>
        <trans-unit id="b64c8a9a4dd6bc23186cb39d29f2d6a941b37467" translate="yes" xml:space="preserve">
          <source>If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.</source>
          <target state="translated">Si Dir est SelectRecv,l'affaire représente une opération de réception.Normalement,la valeur sous-jacente de Chan doit être un canal et Send doit être une valeur nulle.Si Chan est une valeur zéro,alors le cas est ignoré,mais Send doit toujours être une valeur zéro.Lorsqu'une opération de réception est sélectionnée,la valeur reçue est renvoyée par Select.</target>
        </trans-unit>
        <trans-unit id="fc3241471000ca543780e2776c12ce2c0f98b518" translate="yes" xml:space="preserve">
          <source>If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.</source>
          <target state="translated">Si Dir est SelectSend,l'affaire représente une opération d'envoi.Normalement,la valeur sous-jacente de Chan doit être un canal,et la valeur sous-jacente de Send doit être assignable au type d'élément du canal.Dans un cas particulier,si Chan est une valeur zéro,alors le cas est ignoré,et le champ Send sera également ignoré et peut être soit zéro soit non zéro.</target>
        </trans-unit>
        <trans-unit id="3e5a9a392b54a0f9dbcf70e078d697829fda46e7" translate="yes" xml:space="preserve">
          <source>If Discard skips fewer than n bytes, it also returns an error. If 0 &amp;lt;= n &amp;lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader.</source>
          <target state="translated">Si Descartar omite menos de n bytes, tambi&amp;eacute;n devuelve un error. Si 0 &amp;lt;= n &amp;lt;= b.Buffered (), se garantiza que Discard tendr&amp;aacute; &amp;eacute;xito sin leer desde el io.Reader subyacente.</target>
        </trans-unit>
        <trans-unit id="5388f313bdebc1cd743073994620f637168dfccb" translate="yes" xml:space="preserve">
          <source>If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or &quot;soft&quot;) tabs are discarded. Columns terminated by horizontal (or &quot;hard&quot;) tabs are not affected by this flag.</source>
          <target state="translated">Si l'option DiscardEmptyColumns est activée,les colonnes vides qui se terminent entièrement par des onglets verticaux (ou &quot;soft&quot;)sont rejetées.Les colonnes terminées par des onglets horizontaux (ou &quot;durs&quot;)ne sont pas affectées par ce drapeau.</target>
        </trans-unit>
        <trans-unit id="c9deb8e1a0cfa1d1825dc49ade2afa7eec850bd3" translate="yes" xml:space="preserve">
          <source>If ErrSkip is returned the column converter error checking path is used for the argument. Drivers may wish to return ErrSkip after they have exhausted their own special cases.</source>
          <target state="translated">Si ErrSkip est renvoyé,le chemin de vérification des erreurs du convertisseur de colonnes est utilisé pour l'argument.Les pilotes peuvent souhaiter renvoyer ErrSkip après avoir épuisé leurs propres cas particuliers.</target>
        </trans-unit>
        <trans-unit id="acb8bfb04c68aa06cf649fa65fe83fd0ec6ad99b" translate="yes" xml:space="preserve">
          <source>If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New.</source>
          <target state="translated">Si Get retournerait sinon zéro et que p.New est non nul,Get retourne le résultat de l'appel de p.New.</target>
        </trans-unit>
        <trans-unit id="cbb35dd622fd4fc40d747d7fe8a39806c85598b4" translate="yes" xml:space="preserve">
          <source>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.</source>
          <target state="translated">Si le MaxIdleConns est supérieur à 0 et que le nouveau MaxOpenConns est inférieur au MaxIdleConns,alors le MaxIdleConns sera réduit pour correspondre à la nouvelle limite MaxOpenConns.</target>
        </trans-unit>
        <trans-unit id="0566ce3b75e32de588395cc9db25a53062d79613" translate="yes" xml:space="preserve">
          <source>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.</source>
          <target state="translated">Si les MaxOpenConns sont supérieures à 0 mais inférieures aux nouvelles MaxIdleConns,alors les nouvelles MaxIdleConns seront réduites pour correspondre à la limite des MaxOpenConns.</target>
        </trans-unit>
        <trans-unit id="ba59fc6bf9458413409db5ff0b9045c64e756bcb" translate="yes" xml:space="preserve">
          <source>If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">Si le ReadAt est une lecture à partir d'une source d'entrée avec un décalage de recherche,le ReadAt ne doit pas affecter ni être affecté par le décalage de recherche sous-jacent.</target>
        </trans-unit>
        <trans-unit id="cc3d6766541295fe523ec22933263aa9a06c4657" translate="yes" xml:space="preserve">
          <source>If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.</source>
          <target state="translated">Si le ServeurHTTP panique,le serveur (l'appelant du ServeHTTP)suppose que l'effet de la panique a été isolé à la requête active.Il récupère la panique,enregistre une trace de la pile dans le journal des erreurs du serveur,et soit ferme la connexion réseau,soit envoie un HTTP/2 RST_STREAM,selon le protocole HTTP.Pour interrompre un gestionnaire afin que le client voit une réponse interrompue mais que le serveur ne consigne pas d'erreur,il faut paniquer avec la valeur ErrAbortHandler.</target>
        </trans-unit>
        <trans-unit id="c9df130ceb3ae952587ab322cca16f6a65e29d84" translate="yes" xml:space="preserve">
          <source>If Start returns successfully, the c.Process field will be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed6a51dc00d92ad58016afb39e08c5356592608" translate="yes" xml:space="preserve">
          <source>If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30ed6f837b3e7a9558eb599fa8c56e0e97063b" translate="yes" xml:space="preserve">
          <source>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.</source>
          <target state="translated">Si les temps t et u contiennent tous deux des lectures d'horloge monotones,les opérations t.After(u),t.Before(u),t.Equal(u),et t.Sub(u)sont effectuées en utilisant uniquement les lectures d'horloge monotones,en ignorant les lectures d'horloge murale.Si t ou u ne contient aucune lecture de l'horloge monotone,ces opérations reviennent à utiliser les lectures de l'horloge murale.</target>
        </trans-unit>
        <trans-unit id="bc4d8baa4dbb3f1a94db59ec9aa34f357782809d" translate="yes" xml:space="preserve">
          <source>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.</source>
          <target state="translated">Si Unmarshal rencontre un type de champ qui implémente l'interface Unmarshal,Unmarshal appelle sa méthode UnmarshalXML pour produire la valeur à partir de l'élément XML.Sinon,si la valeur implémente l'encodage .TextUnmarshaler,Unmarshal appelle la méthode UnmarshalText de cette valeur.</target>
        </trans-unit>
        <trans-unit id="e7b1cef9234b9022f80f99b102d2ffde95658f55" translate="yes" xml:space="preserve">
          <source>If UseCRLF is true, the Writer ends each output line with \r\n instead of \n.</source>
          <target state="translated">Si UseCRLF est vrai,le rédacteur termine chaque ligne de sortie par \r\n au lieu de \n.</target>
        </trans-unit>
        <trans-unit id="24f02297c63afdceb90dae9a889e378f8f5dc1c7" translate="yes" xml:space="preserve">
          <source>If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">Si WriteAt écrit vers une destination avec une compensation de recherche,WriteAt ne doit pas affecter ni être affecté par la compensation de recherche sous-jacente.</target>
        </trans-unit>
        <trans-unit id="93383c5ea1d8fe26c2febc3914b065857796c533" translate="yes" xml:space="preserve">
          <source>If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ec25dfc6204eb6897de5935b9779223b3cad13" translate="yes" xml:space="preserve">
          <source>If a &quot;range&quot; action initializes a variable, the variable is set to the successive elements of the iteration. Also, a &quot;range&quot; may declare two variables, separated by a comma:</source>
          <target state="translated">Si une action de type &quot;gamme&quot; initialise une variable,celle-ci est fixée aux éléments successifs de l'itération.De plus,une &quot;plage&quot; peut déclarer deux variables,séparées par une virgule :</target>
        </trans-unit>
        <trans-unit id="630b98d4876b039ef4109d3fcef4537345f5b1cb" translate="yes" xml:space="preserve">
          <source>If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d609c4002ae17b5c018b505462be8ebae980f7" translate="yes" xml:space="preserve">
          <source>If a == b == 0, GCD sets z = x = y = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d444ec12c7fa5d6e872ab50772870b5a393d01" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement ExecerContext, the sql package's DB.Exec will fall back to Execer; if the Conn does not implement Execer either, DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Si un Conn n'implémente pas ExecerContext,le DB.Exec du paquet sql reviendra à Execer;si le Conn n'implémente pas non plus Execer,DB.Exec préparera d'abord une requête,exécutera l'instruction,puis fermera l'instruction.</target>
        </trans-unit>
        <trans-unit id="44e6dfb38005e87694379cf1c0216f95562e9cfb" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement Pinger, the sql package's DB.Ping and DB.PingContext will check if there is at least one Conn available.</source>
          <target state="translated">Si un Conn n'implémente pas Pinger,le DB.Ping et le DB.PingContext du paquet sql vérifieront s'il y a au moins un Conn disponible.</target>
        </trans-unit>
        <trans-unit id="21128809a4ab46817c40f8b5969689593dcd6f72" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement QueryerContext, the sql package's DB.Query will fall back to Queryer; if the Conn does not implement Queryer either, DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Si un Conn n'implémente pas QueryerContext,le DB.Query du paquet sql reviendra à Queryer;si le Conn n'implémente pas non plus Queryer,DB.Query préparera d'abord une requête,exécutera l'instruction,puis fermera l'instruction.</target>
        </trans-unit>
        <trans-unit id="45c4be212f44031bede2b5276a4a3589a0dc2b98" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither ExecerContext nor Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Si un Conn n'implémente ni ExecerContext ni Execer,le DB.Exec du paquet sql préparera d'abord une requête,exécutera l'instruction,puis fermera l'instruction.</target>
        </trans-unit>
        <trans-unit id="1cb5d6dd6f4d516d1ae37935040abf369ba105f8" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither QueryerContext nor Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Si un Conn n'implémente ni QueryerContext ni Queryer,le DB.Query du paquet sql préparera d'abord une requête,exécutera l'instruction,puis fermera l'instruction.</target>
        </trans-unit>
        <trans-unit id="71c0f29e06c175a2adb537fdf47269746a601d0d" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">Si un pilote implémente DriverContext,alors sql.DB appellera OpenConnector pour obtenir un connecteur et ensuite invoquera la méthode Conn de ce connecteur pour obtenir chaque connexion nécessaire,au lieu d'invoquer la méthode Open du pilote pour chaque connexion.La séquence en deux étapes permet aux pilotes d'analyser le nom une seule fois et donne également accès aux contextes par Conn.</target>
        </trans-unit>
        <trans-unit id="56a7870f9afac036630f51a12d5ce02b7331bec6" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Connect method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232b341436c8f9f54c10a5dba1cf92c214798814" translate="yes" xml:space="preserve">
          <source>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</source>
          <target state="translated">Si une valeur JSON n'est pas appropriée pour un type de cible donné,ou si un nombre JSON dépasse le type de cible,Unmarshal saute ce champ et complète la démarchage du mieux qu'il peut.Si aucune erreur plus grave n'est rencontrée,Unmarshal renvoie une UnmarshalTypeError décrivant la première erreur de ce type.Dans tous les cas,il n'est pas garanti que tous les champs qui suivent le champ problématique seront démarchés dans l'objet cible.</target>
        </trans-unit>
        <trans-unit id="07bd09bc1ed04a73b33dd796fe781c9034c95572" translate="yes" xml:space="preserve">
          <source>If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</source>
          <target state="translated">Si une Stmt est préparée sur un Tx ou un Conn,elle sera liée à un seul lien sous-jacent pour toujours.Si le Tx ou le Conn se ferme,la Stmt deviendra inutilisable et toutes les opérations retourneront une erreur.Si un Stmt est préparé sur une DB,il restera utilisable pendant toute la durée de vie de la DB.Lorsque le Stmt doit s'exécuter sur une nouvelle connexion sous-jacente,il se préparera automatiquement sur la nouvelle connexion.</target>
        </trans-unit>
        <trans-unit id="3b80dd32b6041fa4ef2f09439544647455bd33ab" translate="yes" xml:space="preserve">
          <source>If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.</source>
          <target state="translated">Si une valeur a une méthode IsBoolFlag()bool retournant true,l'analyseur de ligne de commande rend -name équivalent à -name=true plutôt que d'utiliser le prochain argument de la ligne de commande.</target>
        </trans-unit>
        <trans-unit id="1d651c7c470bed2709ac735baaeec98dda753ea4" translate="yes" xml:space="preserve">
          <source>If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.</source>
          <target state="translated">Si un rédacteur est configuré pour filtrer le HTML,les balises et entités HTML sont passées au travers.Les largeurs des balises et des entités sont supposées être de zéro (balises)et de un (entités)à des fins de formatage.</target>
        </trans-unit>
        <trans-unit id="52438c4d80c78ea57962cd3af33f715085501ef6" translate="yes" xml:space="preserve">
          <source>If a benchmark needs some expensive setup before running, the timer may be reset:</source>
          <target state="translated">Si un benchmark nécessite une configuration coûteuse avant de fonctionner,le minuteur peut être réinitialisé :</target>
        </trans-unit>
        <trans-unit id="d7727dcc2593fe8b30c299beed7e6a6b86f7e22b" translate="yes" xml:space="preserve">
          <source>If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:</source>
          <target state="translated">Si un benchmark doit tester les performances dans un environnement parallèle,il peut utiliser la fonction d'aide RunParallel;ces benchmarks sont destinés à être utilisés avec le drapeau go test -cpu :</target>
        </trans-unit>
        <trans-unit id="a54ff063e15dbe9b378b4160c9280c7409b22dcb" translate="yes" xml:space="preserve">
          <source>If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.</source>
          <target state="translated">Si un argument dest a le type *[]octet,Scan enregistre dans cet argument une copie des données correspondantes.Cette copie est la propriété de l'appelant et peut être modifiée et conservée indéfiniment.La copie peut être évitée en utilisant un argument de type *RawBytes à la place;voir la documentation sur les RawBytes pour les restrictions d'utilisation.</target>
        </trans-unit>
        <trans-unit id="20186d29e290366ced58a159801092dd58a776e3" translate="yes" xml:space="preserve">
          <source>If a field uses a tag &quot;a&amp;gt;b&amp;gt;c&quot;, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</source>
          <target state="translated">Si un campo usa una etiqueta &quot;a&amp;gt; b&amp;gt; c&quot;, entonces el elemento c se anidar&amp;aacute; dentro de los elementos padres ay b. Los campos que aparecen uno al lado del otro que nombran al mismo padre se incluir&amp;aacute;n en un elemento XML.</target>
        </trans-unit>
        <trans-unit id="9df6c8e2aa87346f45992618c6d030de25253b4a" translate="yes" xml:space="preserve">
          <source>If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:</source>
          <target state="translated">Si le nom d'un fichier,après avoir supprimé l'extension et un éventuel suffixe _test,correspond à l'un des modèles suivants :</target>
        </trans-unit>
        <trans-unit id="d6c46042317668db3b232f00f55a1ab61b108925" translate="yes" xml:space="preserve">
          <source>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.</source>
          <target state="translated">Si un goroutin détient un RWMutex pour la lecture et qu'un autre goroutin pourrait appeler Lock,aucun goroutin ne devrait s'attendre à pouvoir acquérir un verrouillage de lecture avant que le verrouillage de lecture initial ne soit libéré.En particulier,cela interdit le verrouillage de lecture récursif.Cela permet de s'assurer que le verrou devient finalement disponible;un appel de Lock bloqué empêche les nouveaux lecteurs d'acquérir le verrou.</target>
        </trans-unit>
        <trans-unit id="54b696ffb9e87ece68a0d432b267874461da7b0c" translate="yes" xml:space="preserve">
          <source>If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:</source>
          <target state="translated">Si un argument de pointeur doit être converti en uintptr pour être utilisé comme argument,cette conversion doit apparaître dans l'expression d'appel elle-même :</target>
        </trans-unit>
        <trans-unit id="a7be185efba59538fbd160cb8d8144506dd7c57d" translate="yes" xml:space="preserve">
          <source>If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has been registered separately.</source>
          <target state="translated">Si un sous-arbre a été enregistré et qu'une requête est reçue nommant la racine du sous-arbre sans sa barre oblique,ServeMux redirige cette requête vers la racine du sous-arbre (en ajoutant la barre oblique).Ce comportement peut être remplacé par un enregistrement séparé pour le chemin d'accès sans la barre oblique de fin.Par exemple,en enregistrant &quot;/images/&quot;,ServeMux redirige une requête pour &quot;/images&quot; vers &quot;/images/&quot;,à moins que &quot;/images&quot; n'ait été enregistré séparément.</target>
        </trans-unit>
        <trans-unit id="104ed2563a73defc4faea46be899a20063ec818c" translate="yes" xml:space="preserve">
          <source>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t.</source>
          <target state="translated">Si un modèle portant le prénom existe déjà,le nouveau modèle HTML le remplacera.Le modèle existant sera réinitialisé et dissocié de t.</target>
        </trans-unit>
        <trans-unit id="463d47c06a7100464461b73a8101f7660c223839" translate="yes" xml:space="preserve">
          <source>If a value is passed to Encode and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.</source>
          <target state="translated">Si une valeur est transmise à Encode et que le type n'est pas une struct (ou un pointeur vers struct,etc.),pour simplifier le traitement,elle est représentée comme une struct d'un champ.Le seul effet visible est de coder un octet zéro après la valeur,tout comme après le dernier champ d'une struct codée,de sorte que l'algorithme de décodage sache quand la valeur de niveau supérieur est complète.</target>
        </trans-unit>
        <trans-unit id="d7d467cb048cd5252bcf40b068f20c227a6c5268" translate="yes" xml:space="preserve">
          <source>If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(&quot;bad&quot;), the resulting formatted message will look like</source>
          <target state="translated">Si une méthode Erreur ou Chaîne déclenche une panique lorsqu'elle est appelée par une routine d'impression,le paquet fmt reformate le message d'erreur de la panique,en le décorant avec une indication qu'il est venu par le paquet fmt.Par exemple,si une méthode String appelle panic(&quot;bad&quot;),le message formaté qui en résulte ressemblera à</target>
        </trans-unit>
        <trans-unit id="cd5fac95dd3eef4d9d21db69e86463f17f12f02f" translate="yes" xml:space="preserve">
          <source>If an X-Forwarded-For header already exists, the client IP is appended to the existing values. As a special case, if the header exists in the Request.Header map but has a nil value (such as when set by the Director func), the X-Forwarded-For header is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3278ea50ebebf5ea6289948b73b15f204c549e9" translate="yes" xml:space="preserve">
          <source>If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.</source>
          <target state="translated">Si un argument a le type *interface{},Scan copie la valeur fournie par le pilote sous-jacent sans conversion.Lors d'un balayage à partir d'une valeur source de type []octet vers *interface{},une copie de la tranche est effectuée et l'appelant est propriétaire du résultat.</target>
        </trans-unit>
        <trans-unit id="4329d9c7e154311e6c7d29f0986dc75dbddb37fd" translate="yes" xml:space="preserve">
          <source>If an attribute has both a namespace and a &quot;data-&quot; prefix, only the namespace will be removed when determining the context. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7525fb96a9e6dded8b4dd1c94198523c01a7a6" translate="yes" xml:space="preserve">
          <source>If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</source>
          <target state="translated">Si une erreur se produit,Import renvoie une erreur non nulle et un *Package non nul contenant des informations partielles.</target>
        </trans-unit>
        <trans-unit id="22a8988276a496bd99d453fc14d11bfb8cde90f0" translate="yes" xml:space="preserve">
          <source>If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:</source>
          <target state="translated">Si un argument non valide est donné pour un verbe,comme par exemple fournir une chaîne à %d,la chaîne générée contiendra une description du problème,comme dans ces exemples :</target>
        </trans-unit>
        <trans-unit id="2f5f672edd948d125f1a8e2164d6570e08508e2a" translate="yes" xml:space="preserve">
          <source>If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete.</source>
          <target state="translated">Si l'un des fichiers c.Stdin,c.Stdout ou c.Stderr n'est pas un fichier *os.file,Wait attend également la fin de la copie de la boucle E/S respective vers ou depuis le processus.</target>
        </trans-unit>
        <trans-unit id="f2c348eae7d177d9986e66ac0dbb1fa9c1c8eff2" translate="yes" xml:space="preserve">
          <source>If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use Encode instead.</source>
          <target state="translated">Si b a des en-têtes non valides et ne peut pas être encodé,EncodeToMemory renvoie nil.S'il est important de rapporter des détails sur ce cas d'erreur,utilisez plutôt Encode.</target>
        </trans-unit>
        <trans-unit id="81446ee41b4f44409d6c98445688e2c9dc448484" translate="yes" xml:space="preserve">
          <source>If base == 0, the base is implied by the string's prefix: base 2 for &quot;0b&quot;, base 8 for &quot;0&quot; or &quot;0o&quot;, base 16 for &quot;0x&quot;, and base 10 otherwise. Also, for base == 0 only, underscore characters are permitted per the Go integer literal syntax. If base is below 0, is 1, or is above 36, an error is returned.</source>
          <target state="translated">Si la base ==0,la base est impliquée par le préfixe de la chaîne:base 2 pour &quot;0b&quot;,base 8 pour &quot;0&quot; ou &quot;0o&quot;,base 16 pour &quot;0x&quot;,et base 10 autrement.De plus,pour la base ==0 uniquement,les caractères de soulignement sont autorisés selon la syntaxe littérale des entiers de Go.Si la base est inférieure à 0,égale à 1 ou supérieure à 36,une erreur est renvoyée.</target>
        </trans-unit>
        <trans-unit id="ff7cc9932856849c823dcd514ebeb18a3facfdc3" translate="yes" xml:space="preserve">
          <source>If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.</source>
          <target state="translated">Si body est de type *bytes.Buffer,*bytes.Reader ou *strings.Reader,la ContentLength de la requête renvoyée est fixée à sa valeur exacte (au lieu de -1),GetBody est rempli (de sorte que 307 et 308 redirections peuvent rejouer le body),et Body est fixé à NoBody si la ContentLength est 0.</target>
        </trans-unit>
        <trans-unit id="07cc785c40dfb93b351fa360eaf5c11b3a687a2b" translate="yes" xml:space="preserve">
          <source>If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.</source>
          <target state="translated">Si le corps est vrai,DumpRequest rend également le corps.Pour ce faire,il consomme req.Body et le remplace ensuite par un nouveau io.ReadCloser qui produit les mêmes octets.Si DumpRequest renvoie une erreur,l'état de req est indéfini.</target>
        </trans-unit>
        <trans-unit id="f6ca8f7ad0c62b57590e8d1aff231f008b51eef8" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's age.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a796f4a07dcd83603a859bc99893a18fb6d4d814" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's idle time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8579022b484933fe4198bbc194c8a61565aa3ef" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are reused forever.</source>
          <target state="translated">Si d &amp;lt;= 0, las conexiones se reutilizan para siempre.</target>
        </trans-unit>
        <trans-unit id="11054b794a9e66d49b745938ef3b656c43f6d39e" translate="yes" xml:space="preserve">
          <source>If data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print.</source>
          <target state="translated">Si les données sont une reflect.Value,le modèle s'applique à la valeur concrète que la reflect.Value détient,comme dans fmt.Print.</target>
        </trans-unit>
        <trans-unit id="f83ceb0ced26c1c764536b5ff1b4fa15e74b62ce" translate="yes" xml:space="preserve">
          <source>If dst implements the ReaderFrom interface, the copy is implemented using it.</source>
          <target state="translated">Si dst implémente l'interface ReaderFrom,la copie est implémentée en l'utilisant.</target>
        </trans-unit>
        <trans-unit id="6833b17cfcf75e1b486e6c702d0520e85f9b86a2" translate="yes" xml:space="preserve">
          <source>If e.Unwrap() returns a non-nil error w, then we say that e wraps w.</source>
          <target state="translated">Si e.Unwrap()renvoie une erreur non nulle w,alors nous disons que e wraps w.</target>
        </trans-unit>
        <trans-unit id="f550577a407a74d547ca6987c46308a4d94fb754" translate="yes" xml:space="preserve">
          <source>If either src implements WriterTo or dst implements ReaderFrom, buf will not be used to perform the copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81786ec59b1db1b26068cac6cb2b8f77c848e02c" translate="yes" xml:space="preserve">
          <source>If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers.</source>
          <target state="translated">S'il est activé (par défaut),le lecteur s'attend à ce que l'entrée soit une séquence de flux de données gzippées individuellement,chacune avec son propre en-tête et sa propre fin,se terminant par EOF.L'effet est que la concaténation d'une séquence de fichiers gzippés est traitée comme équivalente au gzip de la concaténation de la séquence.C'est un comportement standard pour les lecteurs de gzip.</target>
        </trans-unit>
        <trans-unit id="eddf53f9cf1fca82486b2bf4ab21846e817aba06" translate="yes" xml:space="preserve">
          <source>If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.</source>
          <target state="translated">Si f appelle Run,le résultat sera une estimation de l'exécution de tous ses sous-repères qui n'appellent pas Run en séquence dans un seul repère.</target>
        </trans-unit>
        <trans-unit id="24aa535ef0441b2f9dcbe0e4bbff395ed6067287" translate="yes" xml:space="preserve">
          <source>If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse.</source>
          <target state="translated">Si f dépend du test des drapeaux,alors Init doit être utilisé pour enregistrer ces drapeaux avant d'appeler Benchmark et avant d'appeler flag.Parse.</target>
        </trans-unit>
        <trans-unit id="08b53793b968ecc1f35e8cac439169b17517c834" translate="yes" xml:space="preserve">
          <source>If f has a symbol version table, the returned Symbols will have initialized Version and Library fields.</source>
          <target state="translated">Si f a une table de version de symbole,les symboles retournés auront des champs Version et Bibliothèque initialisés.</target>
        </trans-unit>
        <trans-unit id="c8478592007a3bacbc2da6cefaa1115496c485ee" translate="yes" xml:space="preserve">
          <source>If f is a directory, the behavior of Seek varies by operating system; you can seek to the beginning of the directory on Unix-like operating systems, but not on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c9bcc7ac7c9df2b87a2dbabc8c6ec7964d0a03" translate="yes" xml:space="preserve">
          <source>If f panics, Do considers it to have returned; future calls of Do return without calling f.</source>
          <target state="translated">Si f panique,Do considère qu'il est revenu;les appels futurs de Do reviennent sans appeler f.</target>
        </trans-unit>
        <trans-unit id="cfdf3a788dfda0a29c8d0cf447a4cec60c0bc739" translate="yes" xml:space="preserve">
          <source>If file was opened with the O_APPEND flag, WriteAt returns an error.</source>
          <target state="translated">Si le fichier a été ouvert avec le drapeau O_APPEND,WriteAt renvoie une erreur.</target>
        </trans-unit>
        <trans-unit id="822b75e4d85498d0d8696aa19251040ab86e6e90" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">Si filtre !=nul,seuls les fichiers dont les entrées os.FileInfo passent à travers le filtre (et se terminant par &quot;.go&quot;)sont pris en compte.Les bits de mode sont transmis à ParseFile sans modification.Les informations de position sont enregistrées dans fset,qui ne doit pas être nul.</target>
        </trans-unit>
        <trans-unit id="78e87476be473e05171bc062a52f2074d7a8ce2f" translate="yes" xml:space="preserve">
          <source>If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.</source>
          <target state="translated">Si le flush est vrai,Decode suppose que src représente la fin du flux d'entrée et le traite complètement plutôt que d'attendre l'achèvement d'un autre bloc de 32 bits.</target>
        </trans-unit>
        <trans-unit id="abcd3e65f17be630b169b8e4f1f0e366085cdf18" translate="yes" xml:space="preserve">
          <source>If format is a different character, Text returns a &quot;%&quot; followed by the unrecognized format character.</source>
          <target state="translated">Si le format est un caractère différent,Texte renvoie un &quot;%&quot; suivi du caractère de format non reconnu.</target>
        </trans-unit>
        <trans-unit id="5da5429fa2e44a95884b22d9fe6c9389416883fa" translate="yes" xml:space="preserve">
          <source>If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses.</source>
          <target state="translated">Si id est un champ de structure intégré,ObjectOf renvoie le champ (*Var)qu'il définit,et non le type (*TypeName)qu'il utilise.</target>
        </trans-unit>
        <trans-unit id="94590e2c870c388ec6ffdc4a336f130561479132" translate="yes" xml:space="preserve">
          <source>If implemented, drivers may return the underlying error from queries, even if the connection should be discarded by the connection pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f15fee8dc8778902e45311fbf0205cb96dcffed" translate="yes" xml:space="preserve">
          <source>If inuseZero is true, the profile includes allocation records where r.AllocBytes &amp;gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.</source>
          <target state="translated">Si inuseZero es verdadero, el perfil incluye registros de asignaci&amp;oacute;n donde r.AllocBytes&amp;gt; 0 pero r.AllocBytes == r.FreeBytes. Estos son sitios en los que se asign&amp;oacute; memoria, pero toda se ha devuelto al tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="892475b4c6ec1f9a63d5df678595d2602a01d9d3" translate="yes" xml:space="preserve">
          <source>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.</source>
          <target state="translated">Si laddr est nul,une adresse locale est automatiquement choisie.Si le champ IP de raddr est nul ou une adresse IP non spécifiée,le système local est supposé.</target>
        </trans-unit>
        <trans-unit id="ba24dc1c2b3bf1cedb83b06f2414cb64ac15d1da" translate="yes" xml:space="preserve">
          <source>If laddr is non-nil, it is used as the local address for the connection.</source>
          <target state="translated">Si laddr est non-nul,il est utilisé comme adresse locale pour la connexion.</target>
        </trans-unit>
        <trans-unit id="9842a555fc5ba63bad435c92db4ce21af1894ec3" translate="yes" xml:space="preserve">
          <source>If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.</source>
          <target state="translated">Si le niveau est dans la plage [-2,9],l'erreur renvoyée sera nulle.Dans le cas contraire,l'erreur renvoyée sera non nulle.</target>
        </trans-unit>
        <trans-unit id="550da103e5e342ac2c8eff3e35ca3b010db8375f" translate="yes" xml:space="preserve">
          <source>If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.</source>
          <target state="translated">Si el modtime no es el tiempo cero o la época de Unix,ServeContent lo incluye en un encabezado Last-Modified en la respuesta.Si la solicitud incluye un encabezado &quot;If-Modified-Since&quot;,ServeContent utiliza modtime para decidir si el contenido debe ser enviado en absoluto.</target>
        </trans-unit>
        <trans-unit id="df0b7b2149e75e7925ff056e6fc4f402a865000a" translate="yes" xml:space="preserve">
          <source>If multiple result sets are supported, Rows should implement RowsNextResultSet. If the driver knows how to describe the types present in the returned result it should implement the following interfaces: RowsColumnTypeScanType, RowsColumnTypeDatabaseTypeName, RowsColumnTypeLength, RowsColumnTypeNullable, and RowsColumnTypePrecisionScale. A given row value may also return a Rows type, which may represent a database cursor value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6876f56eb90009b843d2c55675ac1e4df7f277" translate="yes" xml:space="preserve">
          <source>If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4498ca26095d9f0afc17fc3d124ee10f9b929767" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">Si n&amp;gt; 0, Readdir devuelve como m&amp;aacute;ximo n estructuras FileInfo. En este caso, si Readdir devuelve un segmento vac&amp;iacute;o, devolver&amp;aacute; un error no nulo que explica por qu&amp;eacute;. Al final de un directorio, el error es io.EOF.</target>
        </trans-unit>
        <trans-unit id="fc3b271d5f3a597b07b28cf1083fa8b465cfe35b" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">Si n&amp;gt; 0, Readdirnames devuelve como m&amp;aacute;ximo n nombres. En este caso, si Readdirnames devuelve un segmento vac&amp;iacute;o, devolver&amp;aacute; un error no nulo que explica el motivo. Al final de un directorio, el error es io.EOF.</target>
        </trans-unit>
        <trans-unit id="eac4c3ba5a8c94ad8cb8a4a397c8ee90135cea13" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error.</source>
          <target state="translated">Si n &amp;lt;= 0, Readdir devuelve toda la FileInfo del directorio en un solo segmento. En este caso, si Readdir tiene &amp;eacute;xito (lee hasta el final del directorio), devuelve el segmento y un error nulo. Si encuentra un error antes del final del directorio, Readdir devuelve el FileInfo le&amp;iacute;do hasta ese punto y un error no nulo.</target>
        </trans-unit>
        <trans-unit id="c3cc55f92ff37a98b5144ea82d578410d2c8c458" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error.</source>
          <target state="translated">Si n &amp;lt;= 0, Readdirnames devuelve todos los nombres del directorio en un solo segmento. En este caso, si Readdirnames tiene &amp;eacute;xito (lee hasta el final del directorio), devuelve el segmento y un error nulo. Si encuentra un error antes del final del directorio, Readdirnames devuelve los nombres le&amp;iacute;dos hasta ese punto y un error no nulo.</target>
        </trans-unit>
        <trans-unit id="2b903f7cf121247bf3e7b3aca6c7022dbb5df0e4" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, no idle connections are retained.</source>
          <target state="translated">Si n &amp;lt;= 0, no se retienen conexiones inactivas.</target>
        </trans-unit>
        <trans-unit id="be61ba0537fe2779cebfab91a18a370978aeba0f" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited).</source>
          <target state="translated">Si n &amp;lt;= 0, entonces no hay l&amp;iacute;mite en el n&amp;uacute;mero de conexiones abiertas. El valor predeterminado es 0 (ilimitado).</target>
        </trans-unit>
        <trans-unit id="3ffbdba0310e5330b6e39ba21df32f4ec64c1673" translate="yes" xml:space="preserve">
          <source>If name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path.</source>
          <target state="translated">Si el nombre no contiene separadores de ruta,Command utiliza LookPath para resolver el nombre a una ruta completa si es posible.De lo contrario,utiliza el nombre directamente como Ruta.</target>
        </trans-unit>
        <trans-unit id="bda6ab9657711e238f41fc5c82fabb4f059d8032" translate="yes" xml:space="preserve">
          <source>If named parameters or context are supported, the driver's Conn should implement: ExecerContext, QueryerContext, ConnPrepareContext, and ConnBeginTx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e919c20774517f309335e67ee8266068c715cb69" translate="yes" xml:space="preserve">
          <source>If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:</source>
          <target state="translated">Si no se encuentra ninguna entrada,se devuelve un objeto nulo.En este caso,el índice devuelto y los valores indirectos tienen el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="2a51e78e82aff9bdb39269ef8cd918a49b097d8e" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">Si opts.Roots es nulo y las raíces del sistema no están disponibles el error devuelto será del tipo SystemRootsError.</target>
        </trans-unit>
        <trans-unit id="6ec80a61e5ca904701ff45ad5637a764d8777e22" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b29b6dd544ee070bf7867f11c38d0b30ce0f19" translate="yes" xml:space="preserve">
          <source>If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.</source>
          <target state="translated">Si p apunta a un objeto asignado,se puede avanzar a través del objeto mediante la conversión a uintptr,la adición de un offset y la conversión de nuevo a Pointer.</target>
        </trans-unit>
        <trans-unit id="9c4a4899af1972effe20bb6d4fb3e2cc68991f24" translate="yes" xml:space="preserve">
          <source>If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified.</source>
          <target state="translated">Si pc no está cubierto por ninguna entrada en esta tabla de líneas,SeekPC devuelve ErrUnknownPC.En este caso,la *entrada y la posición final de la búsqueda no están especificadas.</target>
        </trans-unit>
        <trans-unit id="400c0cdcf2667212ffa50be895764e1b4992a8e1" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b9ebf87a72a4fc29d6e9526a5e472474f83dfe" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the a *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">Si pc representa múltiples funciones debido a la inlining,devuelve la a *Func que describe la función más interna,pero con una entrada de la función más externa.</target>
        </trans-unit>
        <trans-unit id="8759c1ffe2421dc4e493bad121916d1c4a784268" translate="yes" xml:space="preserve">
          <source>If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.</source>
          <target state="translated">Si pkg ==nil,se utiliza el alcance del Universo y se ignora la posición proporcionada pos.Si pkg !=nil,y pos es inválido,se utiliza el paquete scope.De lo contrario,la posición debe pertenecer al paquete.</target>
        </trans-unit>
        <trans-unit id="3b501d10f0b3315a0edcb0a3aa0bfa72db3f19b3" translate="yes" xml:space="preserve">
          <source>If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.</source>
          <target state="translated">Si el paquete se cargó a partir de los datos de exportación,Importaciones incluye paquetes que proporcionan objetos a nivel de paquete referenciados por el paquete.Esto puede ser más o menos que el conjunto de paquetes importados directamente por el código fuente de pkg.</target>
        </trans-unit>
        <trans-unit id="a13dac68b11bffa0323115aff464b296dab14f09" translate="yes" xml:space="preserve">
          <source>If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion.</source>
          <target state="translated">Si r y s apuntan a diferentes anillos,al unirlos se crea un solo anillo con los elementos de s insertados después de r.El resultado apunta al elemento que sigue al último elemento de s después de la inserción.</target>
        </trans-unit>
        <trans-unit id="b045896c9ac0e612d840b26fdcd16f9492dfd688" translate="yes" xml:space="preserve">
          <source>If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).</source>
          <target state="translated">Si la r y la s apuntan al mismo anillo,al unirlas se eliminan los elementos entre la r y la s del anillo.Los elementos eliminados forman una subring y el resultado es una referencia a esa subring (si no se eliminaron elementos,el resultado sigue siendo el valor original de r.Next(),y no nil).</target>
        </trans-unit>
        <trans-unit id="8848277c3a29719067a054c042f2cd449fd3596a" translate="yes" xml:space="preserve">
          <source>If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.</source>
          <target state="translated">Si el rand no es nulo,se usará el cegamiento RSA para evitar los ataques de canal lateral.</target>
        </trans-unit>
        <trans-unit id="a19e63938d7a0894376439e5599ffa43b250a5d4" translate="yes" xml:space="preserve">
          <source>If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered.</source>
          <target state="translated">Si rt.RoundTrip devuelve ErrSkipAltProtocol,el Transporte manejará el RoundTrip por sí mismo para esa única solicitud,como si el protocolo no estuviera registrado.</target>
        </trans-unit>
        <trans-unit id="54ad40399e089deda52c88ae3ba4659988c86560" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.</source>
          <target state="translated">Si s no contiene sep y sep no está vacío,Split devuelve un trozo de longitud 1 cuyo único elemento es s.</target>
        </trans-unit>
        <trans-unit id="9daee5dcf8a47681ddd5e5f835fb1dbed1f83aea" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.</source>
          <target state="translated">Si s no contiene sep y sep no está vacío,SplitAfter devuelve un trozo de longitud 1 cuyo único elemento es s.</target>
        </trans-unit>
        <trans-unit id="9684a535d56fa8216893011aa4860380b4410933" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95759bb8e19ebcbb98672ac7fdd18943d4708775" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</source>
          <target state="translated">Si la s no está bien formada sintácticamente,ParseFloat devuelve err.Err=ErrSyntax.</target>
        </trans-unit>
        <trans-unit id="07f06b052060daddabd04efc8e7cdb5992bfb2f4" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = &amp;plusmn;Inf for the respective component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e257c93b527ddb828e688937de0ccc11edf5f79" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = &amp;plusmn;Inf, err.Err = ErrRange.</source>
          <target state="translated">Si s est&amp;aacute; bien formado sint&amp;aacute;cticamente pero est&amp;aacute; a m&amp;aacute;s de 1/2 ULP del n&amp;uacute;mero de punto flotante m&amp;aacute;s grande del tama&amp;ntilde;o dado, ParseFloat devuelve f = &amp;plusmn; Inf, err.Err = ErrRange.</target>
        </trans-unit>
        <trans-unit id="2958c3475b5e1c01d3ef1742914960b9002f7a9e" translate="yes" xml:space="preserve">
          <source>If sec &amp;gt; 0, the data is sent in the background as with sec &amp;lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded.</source>
          <target state="translated">Si sec&amp;gt; 0, los datos se env&amp;iacute;an en segundo plano como con sec &amp;lt;0. En algunos sistemas operativos, despu&amp;eacute;s de que hayan transcurrido los segundos, los datos restantes no enviados pueden descartarse.</target>
        </trans-unit>
        <trans-unit id="f56f69cce6422c40a21ab01c5418cdbd4bf77063" translate="yes" xml:space="preserve">
          <source>If sec &amp;lt; 0 (the default), the operating system finishes sending the data in the background.</source>
          <target state="translated">Si sec &amp;lt;0 (el valor predeterminado), el sistema operativo termina de enviar los datos en segundo plano.</target>
        </trans-unit>
        <trans-unit id="d8d3489dffe9a7fe6c9ad9a620bad31395af4507" translate="yes" xml:space="preserve">
          <source>If sec == 0, the operating system discards any unsent or unacknowledged data.</source>
          <target state="translated">Si sec ==0,el sistema operativo descarta cualquier dato no enviado o no reconocido.</target>
        </trans-unit>
        <trans-unit id="be66aebe1a8866a8f4dc281f1bd57616b1f982bc" translate="yes" xml:space="preserve">
          <source>If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.</source>
          <target state="translated">Si sep está vacío,Split se divide después de cada secuencia UTF-8.Si tanto s como sep están vacíos,Split devuelve una parte vacía.</target>
        </trans-unit>
        <trans-unit id="489ca1eca08b1f0a405730583d47d533fb4b076e" translate="yes" xml:space="preserve">
          <source>If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.</source>
          <target state="translated">Si el sep está vacío,el SplitAfter se divide después de cada secuencia de UTF-8.Si tanto s como sep están vacíos,SplitAfter devuelve una parte vacía.</target>
        </trans-unit>
        <trans-unit id="2a3657d8164caf54f78f733fc8ef2ecda3905624" translate="yes" xml:space="preserve">
          <source>If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename.</source>
          <target state="translated">Si src !=nil,ParseFile analiza la fuente de src y el nombre del archivo sólo se utiliza cuando se registra la información de posición.El tipo de argumento del parámetro src debe ser string,[]byte,o io.Reader.Si src ==nil,ParseFile analiza el archivo especificado por nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="fe8d7fb1ea6082771e2bec41671407fae46d618e" translate="yes" xml:space="preserve">
          <source>If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src).</source>
          <target state="translated">Si src implementa la interfaz WriterTo,la copia se implementa llamando a src.WriteTo(dst).De lo contrario,si dst implementa la interfaz ReaderFrom,la copia se implementa llamando a dst.ReadFrom(src).</target>
        </trans-unit>
        <trans-unit id="e40b342e6817ab9c3ac4432d840f11c1f0b22325" translate="yes" xml:space="preserve">
          <source>If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.</source>
          <target state="translated">Si src es un archivo fuente parcial,el espacio de entrada y salida de src se aplica al resultado (de tal manera que tiene el mismo espacio de entrada y salida que src),y el resultado se indentifica en la misma cantidad que la primera línea de src que contiene el código.Las importaciones no se clasifican para los archivos fuente parciales.</target>
        </trans-unit>
        <trans-unit id="7c67bad25cffc131c00d1eef36d585ec638c9170" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:http&quot; is used.</source>
          <target state="translated">Si srv.Addr está en blanco,se usa &quot;:http&quot;.</target>
        </trans-unit>
        <trans-unit id="f9e50e1a49136013b88aa780931a141882ea6f39" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:https&quot; is used.</source>
          <target state="translated">Si srv.Addr está en blanco,se usa &quot;:https&quot;.</target>
        </trans-unit>
        <trans-unit id="ad0892d319e6dc448b8b5b8890782a44c3d82311" translate="yes" xml:space="preserve">
          <source>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.</source>
          <target state="translated">Si tiene éxito,el tmpl será ahora seguro para las inyecciones.De lo contrario,err es un error definido en los documentos de ErrorCode.</target>
        </trans-unit>
        <trans-unit id="451a36f1b0a3d42a37ffc7ced9db73e72d35532d" translate="yes" xml:space="preserve">
          <source>If syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178b407eef387370d388c8cfe01edb64789c6b52" translate="yes" xml:space="preserve">
          <source>If the Client's Transport does not have a CloseIdleConnections method then this method does nothing.</source>
          <target state="translated">Si el transporte del cliente no tiene un método de CloseIdleConnections entonces este método no hace nada.</target>
        </trans-unit>
        <trans-unit id="a2836eacebc948128e4aa3ce4d8b1d3fc7d6a477" translate="yes" xml:space="preserve">
          <source>If the Content-Type header has not been set, Redirect sets it to &quot;text/html; charset=utf-8&quot; and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.</source>
          <target state="translated">Si no se ha establecido el encabezado Content-Type,Redirect lo establece como &quot;text/html;charset=utf-8&quot; y escribe un pequeño cuerpo de HTML.Establecer el encabezado Content-Type a cualquier valor,incluso a cero,deshabilita ese comportamiento.</target>
        </trans-unit>
        <trans-unit id="3ae6135ca1107639811cd5daef71ae7fca79e2f6" translate="yes" xml:space="preserve">
          <source>If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.</source>
          <target state="translated">Si el campo Contexto es 0,se llama a la función de contexto para registrar el contexto de rastreo actual.Debe registrar en el campo Contexto toda la información necesaria sobre el punto actual de ejecución para producir más tarde una traza de la pila,probablemente el puntero de la pila y el PC.En este caso la función de contexto será llamada desde el código C.</target>
        </trans-unit>
        <trans-unit id="42011269501bbfe9917fe4565b51ba6a042b7ead" translate="yes" xml:space="preserve">
          <source>If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.</source>
          <target state="translated">Si el campo Contexto no es 0,entonces es un valor devuelto por una llamada previa a la función de contexto.Este caso se llama cuando el contexto ya no es necesario;es decir,cuando el código Go está volviendo a su llamador de código C.Esto permite a la función de contexto liberar cualquier recurso asociado.</target>
        </trans-unit>
        <trans-unit id="084a8ea923e025ba6d8130824462ac823dad2f19" translate="yes" xml:space="preserve">
          <source>If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower.</source>
          <target state="translated">Si el campo Delta de un CaseRange es UpperLower,significa que este CaseRange representa una secuencia de la forma (digamos)Upper Lower Upper Lower.</target>
        </trans-unit>
        <trans-unit id="99155dad735e31c1f83383d55994a89a1d5b0d8e" translate="yes" xml:space="preserve">
          <source>If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask.</source>
          <target state="translated">Si el programa Go se inicia con una máscara de señal no vacía,eso generalmente se honrará.Sin embargo,algunas señales se desbloquean explícitamente:las señales síncronas,SIGILL,SIGTRAP,SIGSTKFLT,SIGCHLD,SIGPROF,y,en GNU/Linux,las señales 32 (SIGCANCEL)y 33 (SIGSETXID)(SIGCANCEL y SIGSETXID son usadas internamente por glibc).Los subprocesos iniciados por os.Exec,o por el paquete os/exec,heredarán la máscara de la señal modificada.</target>
        </trans-unit>
        <trans-unit id="9a19e7607fdf15201f487fc6adac4a654bb31d6b" translate="yes" xml:space="preserve">
          <source>If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.</source>
          <target state="translated">Si el programa Go se inicia con SIGHUP o SIGINT ignorado (el manejador de la señal está en SIG_IGN),permanecerán ignorados.</target>
        </trans-unit>
        <trans-unit id="bb2401bc392b8c040ae8577c33db0583e1939491" translate="yes" xml:space="preserve">
          <source>If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.</source>
          <target state="translated">Si el tiempo de ejecución de Go ve un manejador de señales existente para las señales SIGCANCEL o SIGSETXID (que se usan sólo en GNU/Linux),activará la bandera SA_ONSTACK y de lo contrario mantendrá el manejador de señales.</target>
        </trans-unit>
        <trans-unit id="b8c9bbe3199fe348a3ebb3c33bad8f777f2557ca" translate="yes" xml:space="preserve">
          <source>If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.</source>
          <target state="translated">Si se invoca el manejador de la señal Go en un hilo no Go que no esté ejecutando código Go,el manejador generalmente reenvía la señal al código no Go,de la siguiente manera.Si la señal es SIGPROF,el manejador Go no hace nada.De lo contrario,el manejador Go se elimina a sí mismo,desbloquea la señal,y la levanta de nuevo,para invocar cualquier manejador no-Go o manejador del sistema por defecto.Si el programa no sale,el manejador Go se reinstala y continúa la ejecución del programa.</target>
        </trans-unit>
        <trans-unit id="d1450a83e799c9f838308f1831ad2410ca5837bc" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.</source>
          <target state="translated">Si el campo IP de laddr es nulo o una dirección IP no especificada,ListenIP escucha todas las direcciones IP disponibles del sistema local excepto las direcciones IP multicast.</target>
        </trans-unit>
        <trans-unit id="af82767d02391b6e900db2816b87a4fb9f84a234" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">Si el campo IP de laddr es nulo o una dirección IP no especificada,ListenTCP escucha todas las direcciones IP disponibles unicast y anycast del sistema local.Si el campo Puerto de laddr es 0,se elige automáticamente un número de puerto.</target>
        </trans-unit>
        <trans-unit id="af86e9317bf51d088cb071c3ee8a01bff50d7b6b" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">Si el campo IP de laddr es nulo o una dirección IP no especificada,ListenUDP escucha todas las direcciones IP disponibles del sistema local,excepto las direcciones IP multicast.Si el campo Puerto de laddr es 0,se elige automáticamente un número de puerto.</target>
        </trans-unit>
        <trans-unit id="5b648936c52bc2fbcc7b753478ee856cc09da205" translate="yes" xml:space="preserve">
          <source>If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.</source>
          <target state="translated">Si el nombre XML de un campo de estructura se define tanto por la etiqueta del campo como por el campo XMLName de la estructura,los nombres deben coincidir.</target>
        </trans-unit>
        <trans-unit id="5d4098baadc84b2ed5afee57ad7e0f2a2a2618b1" translate="yes" xml:space="preserve">
          <source>If the absolute value of x doesn't fit in buf, FillBytes will panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2bd83aa910968ed65b7f3c442134176bd4b3dd" translate="yes" xml:space="preserve">
          <source>If the base argument is 0, the true base is implied by the string's prefix: 2 for &quot;0b&quot;, 8 for &quot;0&quot; or &quot;0o&quot;, 16 for &quot;0x&quot;, and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for integer literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef1f744f6bc6158c837d3a4a05d2dd7419e3d5c" translate="yes" xml:space="preserve">
          <source>If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.</source>
          <target state="translated">Si el llamante ha configurado la cabecera del ETag de w con el formato RFC 7232,sección 2.3,ServeContent lo utiliza para manejar las peticiones usando If-Match,If-None-Match,o If-Range.</target>
        </trans-unit>
        <trans-unit id="7fe34f55752121c99936b8403a6063a8914cb06e" translate="yes" xml:space="preserve">
          <source>If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.</source>
          <target state="translated">Si el goroutine de llamada ha bloqueado el hilo del sistema operativo con runtime.LockOSThread y ha modificado cualquier estado de hilo heredable a nivel de sistema operativo (por ejemplo,los espacios de nombres de Linux o de Plan 9),el nuevo proceso heredará el estado de hilo del llamante.</target>
        </trans-unit>
        <trans-unit id="259a07efdd482c1e280dc36d61c76b7e373057fb" translate="yes" xml:space="preserve">
          <source>If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems.</source>
          <target state="translated">Si el comando no se ejecuta o no se completa con éxito,el error es del tipo *ExitError.Otros tipos de error pueden ser devueltos por problemas de E/S.</target>
        </trans-unit>
        <trans-unit id="b33403be418b27f91a2d42d554ef5c02f7c63947" translate="yes" xml:space="preserve">
          <source>If the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations.</source>
          <target state="translated">Si el comando se inicia pero no se completa con éxito,el error es del tipo *ExitError.Otros tipos de error pueden ser devueltos para otras situaciones.</target>
        </trans-unit>
        <trans-unit id="5a122d2b8c97a37a880702f2a3fbe016e3749fd3" translate="yes" xml:space="preserve">
          <source>If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.</source>
          <target state="translated">Si el archivo actual es escaso,entonces las regiones marcadas como agujero se leen como NUL-bytes.</target>
        </trans-unit>
        <trans-unit id="3b03d20f1b9fd110420a18ed294f7f997d1375b2" translate="yes" xml:space="preserve">
          <source>If the deadline is exceeded a call to Read or Write or to other I/O methods will return an error that wraps ErrDeadlineExceeded. This can be tested using errors.Is(err, os.ErrDeadlineExceeded). That error implements the Timeout method, and calling the Timeout method will return true, but there are other possible errors for which the Timeout will return true even if the deadline has not been exceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6253658c1bbbfe0517d9a4b3227473cd894d597c" translate="yes" xml:space="preserve">
          <source>If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.</source>
          <target state="translated">Si el directorio no se pudo leer,se devuelve un mapa nulo y el error respectivo.Si se produjo un error de análisis,se devuelve un mapa no nulo pero incompleto y el primer error encontrado.</target>
        </trans-unit>
        <trans-unit id="01b40bd5ac5583f9db3311853c6994966859d236" translate="yes" xml:space="preserve">
          <source>If the driver supports cursors, a returned Value may also implement the Rows interface in this package. This is used, for example, when a user selects a cursor such as &quot;select cursor(select * from my_table) from dual&quot;. If the Rows from the select is closed, the cursor Rows will also be closed.</source>
          <target state="translated">Si el controlador soporta los cursores,un valor devuelto también puede implementar la interfaz de las filas en este paquete.Esto se utiliza,por ejemplo,cuando un usuario selecciona un cursor como &quot;seleccionar cursor(seleccionar*de mi_tabla)de dual&quot;.Si se cierra la opción Rows from the select,el cursor Rows también se cerrará.</target>
        </trans-unit>
        <trans-unit id="cf50ebb80b297da2b505a620be031cb25dcead76" translate="yes" xml:space="preserve">
          <source>If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply:</source>
          <target state="translated">Si el formato (que es implícitamente %v para Println etc.)es válido para una cadena (%s %q %v %x %X),se aplican las dos reglas siguientes:</target>
        </trans-unit>
        <trans-unit id="0f42e25dba03dca0e51f87ed12e981c71373e332" translate="yes" xml:space="preserve">
          <source>If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. It is invalid to include more than one %w verb or to supply it with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.</source>
          <target state="translated">Si el especificador de formato incluye un verbo %w con un operando de error,el error devuelto implementará un método Unwrap devolviendo el operando.No es válido incluir más de un verbo %w o suministrarlo con un operando que no implemente la interfaz de error.El verbo %w es de otra manera un sinónimo de %v.</target>
        </trans-unit>
        <trans-unit id="b70a519f0eee1914e654572a47f9ae5a7a8a3889" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Si el host en el parámetro de dirección no es una dirección IP literal o el puerto no es un número de puerto literal,ResolveTCPAddr resuelve la dirección a una dirección de punto final TCP.De lo contrario,analiza la dirección como un par de direcciones IP literales y un número de puerto.El parámetro de dirección puede usar un nombre de host,pero esto no es recomendado,porque devolverá como máximo una de las direcciones IP del nombre de host.</target>
        </trans-unit>
        <trans-unit id="60603d4b10b0e1d0e446fdae0a4a44c25a6c45b7" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Si el host en el parámetro de dirección no es una dirección IP literal o el puerto no es un número de puerto literal,ResolveUDPAddr resuelve la dirección a una dirección de punto final UDP.De lo contrario,analiza la dirección como un par de direcciones IP literales y un número de puerto.El parámetro de dirección puede usar un nombre de host,pero no se recomienda,porque devolverá como máximo una de las direcciones IP del nombre de host.</target>
        </trans-unit>
        <trans-unit id="cd0fc2990a9a9cf8fad81f64436555d3d6b35355" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Si el host en el parámetro de dirección no es una dirección IP literal,ResolveIPAddr resuelve la dirección a una dirección de punto final IP.De lo contrario,analiza la dirección como una dirección IP literal.El parámetro de dirección puede utilizar un nombre de host,pero no se recomienda,porque devolverá como máximo una de las direcciones IP del nombre de host.</target>
        </trans-unit>
        <trans-unit id="199da3dce7215d4cebc5f4fd0619e8dbc8fd6d9d" translate="yes" xml:space="preserve">
          <source>If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.</source>
          <target state="translated">Si el tipo de clave no es un tipo de clave de mapa válido (es decir,si no implementa el operador Go ==),MapOf entra en pánico.</target>
        </trans-unit>
        <trans-unit id="fdcae4b6d304718d87888a4b14792a984d6db584" translate="yes" xml:space="preserve">
          <source>If the location cannot be determined (for example, $HOME is not defined), then it will return an error.</source>
          <target state="translated">Si no se puede determinar la ubicación (por ejemplo,$HOME no está definido),entonces devolverá un error.</target>
        </trans-unit>
        <trans-unit id="83fc45c3d88185bce6b913b6fba87e76a3564c14" translate="yes" xml:space="preserve">
          <source>If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.</source>
          <target state="translated">Si los n=len(p)bytes devueltos por ReadAt están al final de la fuente de entrada,ReadAt puede devolver o bien err ==EOF o bien err ==nil.</target>
        </trans-unit>
        <trans-unit id="96928e9a3e37cddefc97fd6808cb69e209a645f8" translate="yes" xml:space="preserve">
          <source>If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. If the name is &quot;Local&quot;, LoadLocation returns Local.</source>
          <target state="translated">Si el nombre es &quot;&quot; o &quot;UTC&quot;,LoadLocation devuelve UTC.Si el nombre es &quot;Local&quot;,LoadLocation devuelve Local.</target>
        </trans-unit>
        <trans-unit id="71bd5d676aea790d3104c9356a66a88a54f27219" translate="yes" xml:space="preserve">
          <source>If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.</source>
          <target state="translated">Si el código no-Go llamado por el programa Go no cambia ningún manejador de señales o máscaras,entonces el comportamiento es el mismo que para un programa Go puro.</target>
        </trans-unit>
        <trans-unit id="7ff28c4dacda2b677d57a006ed06c589035c4906" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.</source>
          <target state="translated">Si el código no-Go instala un manejador de señales para cualquiera de las señales asincrónicas,puede invocar el manejador de la señal Go o no,según su elección.Naturalmente,si no invoca el manejador de la señal Go,el comportamiento Go descrito anteriormente no se producirá.Esto puede ser un problema con la señal SIGPROF en particular.</target>
        </trans-unit>
        <trans-unit id="abd2048f2311a9e6d64b579961e64f72d37d33a6" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.</source>
          <target state="translated">Si el código no-Go instala un manejador de señales para cualquiera de las señales síncronas (SIGBUS,SIGFPE,SIGSEGV),entonces debería registrar el manejador de señales Go existente.Si esas señales ocurren mientras se ejecuta el código Go,debería invocar el manejador de la señal Go (si la señal ocurre mientras se ejecuta el código Go puede determinarse mirando el PC pasado al manejador de la señal).De lo contrario,algunos pánicos en tiempo de ejecución de Go no ocurrirán como se esperaba.</target>
        </trans-unit>
        <trans-unit id="bb19b115a2d359b987ea5bcb60343aca9ae430dd" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return &quot;interrupted system call&quot; errors.</source>
          <target state="translated">Si el código no-Go instala algún manejador de señales,debe usar la bandera SA_ONSTACK con sigilo.Si no lo hace,es probable que el programa se bloquee si se recibe la señal.Los programas Go se ejecutan rutinariamente con una pila limitada,y por lo tanto establecen una pila de señales alternativa.Además,la biblioteca estándar de Go espera que cualquier manejador de señales utilice la bandera SA_RESTART.El no hacerlo puede causar que algunas llamadas a la biblioteca devuelvan errores de &quot;llamada de sistema interrumpida&quot;.</target>
        </trans-unit>
        <trans-unit id="7e1d203998def7d0f58007e88176f92e21a64b50" translate="yes" xml:space="preserve">
          <source>If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.</source>
          <target state="translated">Si el código no-Go inicia un nuevo hilo,cambia la máscara de la señal y luego invoca una función Go en ese hilo,el tiempo de ejecución Go desbloqueará automáticamente ciertas señales:las señales síncronas,SIGILL,SIGTRAP,SIGSTKFLT,SIGCHLD,SIGPROF,SIGCANCEL y SIGSETXID.Cuando vuelva la función Go,se restaurará la máscara de la señal no Go.</target>
        </trans-unit>
        <trans-unit id="91074ebc7a3334ebd4f37cdfabaa9ca32fd24f74" translate="yes" xml:space="preserve">
          <source>If the open fails, the error string will be self-explanatory, like</source>
          <target state="translated">Si la apertura falla,la cadena de error se explica por sí misma,como</target>
        </trans-unit>
        <trans-unit id="54fcc24f407eeb4900b5f210d5d49a96c53bb1c9" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">Si el prefijo del estado no coincide con los d&amp;iacute;gitos en esperabaCode, ReadCodeLine regresa con err establecido en &amp;amp; Error {c&amp;oacute;digo, mensaje}. Por ejemplo, si esperabaCode es 31, se devolver&amp;aacute; un error si el estado no est&amp;aacute; en el rango [310,319].</target>
        </trans-unit>
        <trans-unit id="86837437a16860a8105279be00bffc491da5bba2" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">Si el prefijo del estado no coincide con los d&amp;iacute;gitos en esperabaCode, ReadResponse regresa con err establecido en &amp;amp; Error {c&amp;oacute;digo, mensaje}. Por ejemplo, si esperabaCode es 31, se devolver&amp;aacute; un error si el estado no est&amp;aacute; en el rango [310,319].</target>
        </trans-unit>
        <trans-unit id="5ebf5ba32952d52f53e121ccb89f42cb9010f630" translate="yes" xml:space="preserve">
          <source>If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.</source>
          <target state="translated">Si el programa ha llamado a Notify para recibir las señales de SIGPIPE,el número del descriptor del archivo no importa.La señal de SIGPIPE será entregada al canal de Notify,y la escritura fallará con un error de EPIPE.</target>
        </trans-unit>
        <trans-unit id="7cf239f9c12fb938b9596c568e4f45900dce20bb" translate="yes" xml:space="preserve">
          <source>If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.</source>
          <target state="translated">Si el programa no ha llamado a Notify para recibir las señales de SIGPIPE,entonces el comportamiento depende del número del descriptor del archivo.Una escritura en un tubo roto en los descriptores de archivo 1 o 2 (salida estándar o error estándar)hará que el programa salga con una señal de SIGPIPE.Una escritura en una tubería rota en algún otro descriptor de archivo no tomará ninguna acción en la señal de SIGPIPE,y la escritura fallará con un error de EPIPE.</target>
        </trans-unit>
        <trans-unit id="111ef080bfe5d9de228261353c72d73b391743f0" translate="yes" xml:space="preserve">
          <source>If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.</source>
          <target state="translated">Si el programa se inicia con una máscara de señal no vacía,algunas señales se desbloquearán explícitamente como se ha descrito anteriormente.Si se llama a Notify para una señal bloqueada,se desbloqueará.Si,más tarde,se llama a Reset para esa señal,o a Stop en todos los canales pasados a Notify para esa señal,la señal se bloqueará de nuevo.</target>
        </trans-unit>
        <trans-unit id="6b4f665c5cfb9144d49b7e1dcb5bc2df2bfa007a" translate="yes" xml:space="preserve">
          <source>If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.</source>
          <target state="translated">Si el programa se inició con SIGHUP o SIGINT ignorado,y se llama a Notify para cualquiera de las dos señales,se instalará un manejador de señales para esa señal y ya no se ignorará.Si,más tarde,se llama Reset o Ignorar para esa señal,o se llama Stop en todos los canales pasados a Notificar para esa señal,la señal volverá a ser ignorada.Restablecer restaurará el comportamiento predeterminado del sistema para la señal,mientras que Ignorar hará que el sistema ignore la señal por completo.</target>
        </trans-unit>
        <trans-unit id="a50b71ad5f04ba376647400ad12d829202f07d7f" translate="yes" xml:space="preserve">
          <source>If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.</source>
          <target state="translated">Si el cuerpo provisto es también un io.Closer,el cuerpo de la solicitud devuelta se establece en el cuerpo y se cerrará por los métodos del cliente Do,Post,y PostForm,y Transport.RoundTrip.</target>
        </trans-unit>
        <trans-unit id="a90f0974cd32b46dcc6c15c91f94c9f93252ae8b" translate="yes" xml:space="preserve">
          <source>If the provided body is an io.Closer, it is closed after the request.</source>
          <target state="translated">Si el cuerpo provisto es un io.más cercano,se cierra después de la solicitud.</target>
        </trans-unit>
        <trans-unit id="76a4a3b11148dd18ae8c95298059edf28df076dc" translate="yes" xml:space="preserve">
          <source>If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.</source>
          <target state="translated">Si el nombre de archivo o directorio proporcionado es una ruta relativa,se interpreta en relación con el directorio actual y puede ascender a los directorios superiores.Si el nombre proporcionado se construye a partir de la entrada del usuario,debe ser saneado antes de llamar a ServeFile.</target>
        </trans-unit>
        <trans-unit id="4e3cf22a6ffbc844d8cc7293fe5c88e56a31e62d" translate="yes" xml:space="preserve">
          <source>If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).</source>
          <target state="translated">Si la precisión del resultado proporcionado es 0 (véase más abajo),se ajusta a la precisión del argumento con el mayor valor de precisión antes de que se produzca cualquier redondeo,y el modo de redondeo permanece inalterado.Así,los Floats no inicializados proporcionados como argumentos de resultado tendrán su precisión fijada en un valor razonable determinado por los operandos,y su modo es el valor cero para RoundingMode (ToNearestEven).</target>
        </trans-unit>
        <trans-unit id="2b88a75837ac44c3ec57492aadd63fbc336940cb" translate="yes" xml:space="preserve">
          <source>If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.</source>
          <target state="translated">Si el tamaño del cuerpo de la solicitud no ha sido ya limitado por el MaxBytesReader,el tamaño se limita a 10MB.</target>
        </trans-unit>
        <trans-unit id="202ca334b5c1306191933ea4f4be7458350d5dde" translate="yes" xml:space="preserve">
          <source>If the response is multi-line, ReadCodeLine returns an error.</source>
          <target state="translated">Si la respuesta es multilínea,ReadCodeLine devuelve un error.</target>
        </trans-unit>
        <trans-unit id="cca7e3754527e1fa0174f20268f5f2115cb686b6" translate="yes" xml:space="preserve">
          <source>If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.</source>
          <target state="translated">Si la cabecera Content-Type de la respuesta no está configurada,ServeContent primero intenta deducir el tipo a partir de la extensión del archivo del nombre y,si eso falla,vuelve a leer el primer bloque del contenido y lo pasa a DetectContentType.Por lo demás,el nombre no se utiliza;en particular,puede estar vacío y nunca se envía en la respuesta.</target>
        </trans-unit>
        <trans-unit id="4adb610dc4446d1c29fb56aaef6e5c8a55dbd30c" translate="yes" xml:space="preserve">
          <source>If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result.</source>
          <target state="translated">Si el resultado está entre corchetes,como las direcciones IPv6 literales,los corchetes se eliminan del resultado.</target>
        </trans-unit>
        <trans-unit id="46d8ee162d5e124f43ba34e4b526da01d3ba6f66" translate="yes" xml:space="preserve">
          <source>If the result of this process is an empty string, Clean returns the string &quot;.&quot;.</source>
          <target state="translated">Si el resultado de este proceso es una cadena vacía,Clean devuelve la cadena &quot;.&quot;.</target>
        </trans-unit>
        <trans-unit id="63039cb93ec1523520a70aa02f8add44a72d2dcc" translate="yes" xml:space="preserve">
          <source>If the resulting type would be larger than the available address space, ArrayOf panics.</source>
          <target state="translated">Si el tipo resultante fuera más grande que el espacio de direcciones disponible,ArrayOf entra en pánico.</target>
        </trans-unit>
        <trans-unit id="49eb9c6b19926a8575c169e52f8df687a6338f21" translate="yes" xml:space="preserve">
          <source>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</source>
          <target state="translated">Si el error devuelto es nulo,la Respuesta contendrá un Cuerpo no nulo que se espera que el usuario cierre.Si el Cuerpo no se lee a EOF y se cierra,es posible que el RoundTripper subyacente del Cliente (típicamente Transporte)no pueda reutilizar una conexión TCP persistente al servidor para una solicitud posterior de &quot;mantener vivo&quot;.</target>
        </trans-unit>
        <trans-unit id="2bd3e276f21c33ca258e2835ea6ef2502ea92047" translate="yes" xml:space="preserve">
          <source>If the returned token is a keyword, the literal string is the keyword.</source>
          <target state="translated">Si la ficha devuelta es una palabra clave,la cadena literal es la palabra clave.</target>
        </trans-unit>
        <trans-unit id="d7865630a2cf1e24a8ed7ed472ba9beeb25fa193" translate="yes" xml:space="preserve">
          <source>If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value.</source>
          <target state="translated">Si la ficha devuelta es un literal (ficha.IDENT,ficha.INT,ficha.FLOAT,ficha.IMAG,ficha.CHAR,ficha.STRING)o ficha.COMENTARIO,la cadena literal tiene el valor correspondiente.</target>
        </trans-unit>
        <trans-unit id="7b330824cf4af38e2c2f1237e0044975056d896f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.ILLEGAL, the literal string is the offending character.</source>
          <target state="translated">Si la ficha devuelta es ficha.ILEGAL,la cadena literal es el carácter ofensivo.</target>
        </trans-unit>
        <trans-unit id="f2065d9b79fae019bc66ef4f832603a41d2a079f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.SEMICOLON, the corresponding literal string is &quot;;&quot; if the semicolon was present in the source, and &quot;\n&quot; if the semicolon was inserted because of a newline or at EOF.</source>
          <target state="translated">Si la ficha devuelta es ficha.SEMICOLON,la cadena literal correspondiente es &quot;;&quot; si el punto y coma estaba presente en la fuente,y &quot;\n&quot; si el punto y coma se insertó debido a una nueva línea o en EOF.</target>
        </trans-unit>
        <trans-unit id="6d82694c27c567dcf0d737897e646720cd59f4a9" translate="yes" xml:space="preserve">
          <source>If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types.</source>
          <target state="translated">Si el servidor responde con una redirección,el cliente utiliza primero la función CheckRedirect para determinar si se debe seguir la redirección.Si está permitido,una redirección 301,302 o 303 hace que las peticiones subsiguientes utilicen el método HTTP GET (o HEAD si la petición original era HEAD),sin ningún cuerpo.Una redirección 307 o 308 conserva el método HTTP y el cuerpo originales,siempre que se defina la función Request.GetBody.La función NewRequest establece automáticamente GetBody para los tipos de cuerpo de las bibliotecas estándar comunes.</target>
        </trans-unit>
        <trans-unit id="8bef3b53d6d7bb99946b130aacd06c58001e65ba" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position.</source>
          <target state="translated">Si no se pudo leer la fuente,la AST devuelta es nula y el error indica la falla específica.Si se leyó la fuente pero se encontraron errores de sintaxis,el resultado es una AST parcial (con nodos ast.Bad*que representan los fragmentos de código fuente erróneo).Los múltiples errores son devueltos a través de un scanner.ErrorList que se ordena por la posición del archivo.</target>
        </trans-unit>
        <trans-unit id="0ea17fae18048ca3efef70d260f3befe5169300a" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66a139f57b43b60f302e27759bd0543bc9c0e26" translate="yes" xml:space="preserve">
          <source>If the time has a monotonic clock reading, the returned string includes a final field &quot;m=&amp;plusmn;&amp;lt;value&amp;gt;&quot;, where value is the monotonic clock reading formatted as a decimal number of seconds.</source>
          <target state="translated">Si la hora tiene una lectura de reloj mon&amp;oacute;tona, la cadena devuelta incluye un campo final &quot;m = &amp;plusmn; &amp;lt;valor&amp;gt;&quot;, donde valor es la lectura de reloj mon&amp;oacute;tona formateada como un n&amp;uacute;mero decimal de segundos.</target>
        </trans-unit>
        <trans-unit id="251f36d24e83127f4dd9319d7cdbc49677b94325" translate="yes" xml:space="preserve">
          <source>If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.</source>
          <target state="translated">Si la función de rastreo se llama desde un manejador de señales en un sistema Unix,SigContext será el argumento de contexto de la señal pasado al manejador de la señal (un C ucontext_t*lanzado a uintptr_t).Esto puede ser usado para comenzar el rastreo en el punto donde la señal ocurrió.Si la función de rastreo no es llamada desde un manejador de señal,SigContext será cero.</target>
        </trans-unit>
        <trans-unit id="07b1d78b08994662a459431d46bce8768415b25a" translate="yes" xml:space="preserve">
          <source>If the type name of a slice element ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">Si el nombre de tipo de un elemento de la rebanada termina con &quot;SET&quot;,entonces se trata como si la etiqueta &quot;set&quot; estuviera puesta en él.Esto puede ser usado con rebanadas anidadas donde no se puede dar una etiqueta de estructura.</target>
        </trans-unit>
        <trans-unit id="b1b298da75673ff2dc00ea6d79d2dbf4f6d4ad81" translate="yes" xml:space="preserve">
          <source>If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.</source>
          <target state="translated">Si el tipo del primer campo de una estructura es RawContent,entonces el contenido crudo de ASN1 de la estructura se almacenará en él.</target>
        </trans-unit>
        <trans-unit id="94580cf18c0cdda91d151e0855e03334c0926847" translate="yes" xml:space="preserve">
          <source>If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.</source>
          <target state="translated">Si hay identificaciones de tipo anidadas,los tipos para todas las identificaciones de tipo internas deben definirse antes de que se utilice la identificación de tipo de nivel superior para describir una V codificada.</target>
        </trans-unit>
        <trans-unit id="a4b08581fb59710f6d84824026b409a7e3fe2aea" translate="yes" xml:space="preserve">
          <source>If there is an error, it will be of type *PathError.</source>
          <target state="translated">Si hay un error,será del tipo *PathError.</target>
        </trans-unit>
        <trans-unit id="d59b10d118f91edc83c197a1ea597908270dd51e" translate="yes" xml:space="preserve">
          <source>If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</source>
          <target state="translated">Si no hay un controlador registrado que se aplique a la solicitud, Handler devuelve un controlador de &quot;p&amp;aacute;gina no encontrada&quot; y un patr&amp;oacute;n vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="1a7ace82b8245bf4439307ba5dfdbd1b825dcfff" translate="yes" xml:space="preserve">
          <source>If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). In the case of an error, the info argument will be nil. If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory.</source>
          <target state="translated">Si hubo un problema al caminar hacia el archivo o directorio nombrado por la ruta,el error entrante describirá el problema y la función puede decidir cómo manejar ese error (y Caminar no descenderá a ese directorio).En el caso de un error,el argumento de información será nulo.Si se devuelve un error,el procesamiento se detiene.La única excepción es cuando la función devuelve el valor especial SkipDir.Si la función devuelve SkipDir cuando se invoca en un directorio,Walk se salta todo el contenido del directorio.Si la función devuelve SkipDir cuando se invoca en un archivo que no es de directorio,Walk se salta los archivos restantes del directorio que lo contiene.</target>
        </trans-unit>
        <trans-unit id="b1b4c374c9ed31601280332f5174e595585d5e35" translate="yes" xml:space="preserve">
          <source>If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated Config. Note that if GetConfigForClient returns a different Config, the change can't be accounted for by this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f28f83ac01122a6b8eb17da82fc365cf06db186" translate="yes" xml:space="preserve">
          <source>If this compilation unit has no line table, it returns nil, nil.</source>
          <target state="translated">Si esta unidad de compilación no tiene una tabla de líneas,devuelve cero,cero.</target>
        </trans-unit>
        <trans-unit id="36cfd61621ceef678850032683735978215f2feb" translate="yes" xml:space="preserve">
          <source>If u.Host doesn't contain a valid numeric port, Port returns an empty string.</source>
          <target state="translated">Si u.Host no contiene un puerto numérico válido,Port devuelve una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="1f16e20c1b2a3c0d7a413b8fa21221a527ff3a01" translate="yes" xml:space="preserve">
          <source>If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. Any non-ASCII characters in host are escaped. To obtain the path, String uses u.EscapedPath().</source>
          <target state="translated">Si u.Opaque no está vacío,String utiliza la primera forma;de lo contrario,utiliza la segunda forma.Cualquier carácter no ASCII en el anfitrión se escapa.Para obtener la ruta,String usa u.EscapedPath().</target>
        </trans-unit>
        <trans-unit id="8013c9355c400aa79a6367baa057f4b9d4888841" translate="yes" xml:space="preserve">
          <source>If used in an unsafe context, then the value might be filtered out:</source>
          <target state="translated">Si se utiliza en un contexto inseguro,entonces el valor puede ser filtrado:</target>
        </trans-unit>
        <trans-unit id="169176f5802d140421e02d07f71892f55914e587" translate="yes" xml:space="preserve">
          <source>If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</source>
          <target state="translated">Si v's Kind is Func,el puntero devuelto es un puntero de código subyacente,pero no necesariamente suficiente para identificar una función única.La única garantía es que el resultado es cero si y sólo si v es un valor de función nulo.</target>
        </trans-unit>
        <trans-unit id="ee9b69667b384fa6c8c1419304597f7a05f5dda4" translate="yes" xml:space="preserve">
          <source>If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</source>
          <target state="translated">Si el tipo de V es &quot;rebanada&quot;,el puntero devuelto es al primer elemento de la rebanada.Si la rebanada es nula el valor devuelto es 0.Si la rebanada está vacía pero no es nula el valor devuelto es distinto de cero.</target>
        </trans-unit>
        <trans-unit id="ccce50575e90f1da7bb594b206672d76cc0b7fdc" translate="yes" xml:space="preserve">
          <source>If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most &amp;frac14;ⁿ.</source>
          <target state="translated">Si x es primo, ProbablyPrime devuelve verdadero. Si x se elige al azar y no es primo, ProbablyPrime probablemente devuelva falso. La probabilidad de que el resultado sea verdadero para un no primo elegido al azar es como m&amp;aacute;ximo &amp;frac14;ⁿ.</target>
        </trans-unit>
        <trans-unit id="e8a427ffc0c17926670bab4065e96207d4a28d2f" translate="yes" xml:space="preserve">
          <source>If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8bf41d1552e2a2314c86bbee51c546608c7502" translate="yes" xml:space="preserve">
          <source>If you like, you can bind the flag to a variable using the Var() functions.</source>
          <target state="translated">Si lo desea,puede vincular la bandera a una variable utilizando las funciones Var().</target>
        </trans-unit>
        <trans-unit id="8a6f437f93f8b5dbc142b89b4316e10878736145" translate="yes" xml:space="preserve">
          <source>If your application is not already running an http server, you need to start one. Add &quot;net/http&quot; and &quot;log&quot; to your imports and the following code to your main function:</source>
          <target state="translated">Si su aplicación no está ya ejecutando un servidor http,necesita iniciar uno.Añade &quot;net/http&quot; y &quot;log&quot; a tus importaciones y el siguiente código a tu función principal:</target>
        </trans-unit>
        <trans-unit id="e08bef57a6d48a73f233b8062ac1ffdd047f7ffe" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode, but z's accuracy is not computed. Specifically, the result of z.Acc() is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a7bb87f973e19b80ef2f0c235948e2ab80ca50" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode.</source>
          <target state="translated">Si la precisión de z es 0,se cambia a la precisión de x antes de la operación.El redondeo se realiza según la precisión de z y el modo de redondeo.</target>
        </trans-unit>
        <trans-unit id="bf3bdba69c06f396d015a2e68cfa8b8e0dc2a553" translate="yes" xml:space="preserve">
          <source>If {{.}} is the innocuous word, `left`, then it can appear more widely,</source>
          <target state="translated">Si la palabra inocua es &quot;izquierda&quot;,entonces puede aparecer más ampliamente,</target>
        </trans-unit>
        <trans-unit id="35dc1b1b93ecc62032ac0000d9cf5065af4bc463" translate="yes" xml:space="preserve">
          <source>IfNode represents an {{if}} action and its commands.</source>
          <target state="translated">Si el Nodo representa una acción y sus comandos.</target>
        </trans-unit>
        <trans-unit id="a40a74611ce76ddfa9aec134c7c4d57d7e7d1a0b" translate="yes" xml:space="preserve">
          <source>Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.</source>
          <target state="translated">Ignorar hace que las señales proporcionadas sean ignoradas.Si el programa las recibe,no pasará nada.Ignorar deshace el efecto de cualquier llamada previa a Notificar por las señales proporcionadas.Si no se proporcionan señales,todas las señales entrantes serán ignoradas.</target>
        </trans-unit>
        <trans-unit id="98d36857a614a1e009d79e216b4eb0d9115f0404" translate="yes" xml:space="preserve">
          <source>Ignored reports whether sig is currently ignored.</source>
          <target state="translated">Ignoró los informes sobre si la sig es actualmente ignorada.</target>
        </trans-unit>
        <trans-unit id="4d88a112acad4eaba636cd685d95e848e229a4fb" translate="yes" xml:space="preserve">
          <source>Ilogb returns the binary exponent of x as an integer.</source>
          <target state="translated">Ilogb devuelve el exponente binario de x como un entero.</target>
        </trans-unit>
        <trans-unit id="44e069a8f4a7e1ac23418ede1f9fbec843a967dd" translate="yes" xml:space="preserve">
          <source>Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Imagina devuelve la parte imaginaria de x,que debe ser un valor numérico o desconocido.Si x es Desconocida,el resultado es Desconocido.</target>
        </trans-unit>
        <trans-unit id="30d40b43edb0bdc3eabf2d534c36f9d06f964b6e" translate="yes" xml:space="preserve">
          <source>Image is a finite rectangular grid of color.Color values taken from a color model.</source>
          <target state="translated">La imagen es una cuadrícula rectangular finita de color.Valores de color tomados de un modelo de color.</target>
        </trans-unit>
        <trans-unit id="26d71317c3ede5b3f54e923608b8db6326957a5e" translate="yes" xml:space="preserve">
          <source>Image is an image.Image with a Set method to change a single pixel.</source>
          <target state="translated">La imagen es una imagen.Una imagen con un método de ajuste para cambiar un solo píxel.</target>
        </trans-unit>
        <trans-unit id="b146748a0514484acff9fb056c40176e7e0d62af" translate="yes" xml:space="preserve">
          <source>Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.</source>
          <target state="translated">Restricción de la aplicación:Los formularios de recuento x{n,m},x{n,},y x{n}rechazan los formularios que crean un recuento mínimo o máximo de repetición por encima de 1000.Las repeticiones ilimitadas no están sujetas a esta restricción.</target>
        </trans-unit>
        <trans-unit id="75c9903908feb1732654db7dd3662c68681cf3c0" translate="yes" xml:space="preserve">
          <source>Implementations must not retain p.</source>
          <target state="translated">Las implementaciones no deben retener p.</target>
        </trans-unit>
        <trans-unit id="baccfe949bd483e0aa453da0b286a6848971e885" translate="yes" xml:space="preserve">
          <source>Implementations of CookieJar must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Las implementaciones de CookieJar deben ser seguras para el uso simultáneo de varios goroutines.</target>
        </trans-unit>
        <trans-unit id="2496dd56381c55b51499d5f91502dcff20d2b771" translate="yes" xml:space="preserve">
          <source>Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Las implementaciones de PublicSuffixList deben ser seguras para el uso simultáneo de múltiples goroutines.</target>
        </trans-unit>
        <trans-unit id="f73bf070b6238c284ef7b4d02061d370d3bb9d34" translate="yes" xml:space="preserve">
          <source>Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">Se desaconseja a las implementaciones de Read que devuelvan una cuenta de cero bytes con un error nulo,excepto cuando len(p)==0.Los que llaman deben tratar una devolución de 0 y nulo como una indicación de que no ha pasado nada;en particular,no indica EOF.</target>
        </trans-unit>
        <trans-unit id="9c4eb58019f122cd6fcd79f868e42855509e5b17" translate="yes" xml:space="preserve">
          <source>Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">Las implementaciones de Token son desalentadas de devolver una ficha con un error nulo.Los llamantes deben tratar la devolución de cero,cero como una indicación de que no pasó nada;en particular no indica EOF.</target>
        </trans-unit>
        <trans-unit id="3b31ef7323ed3ca421b9bab6f7dbaab32c7ce726" translate="yes" xml:space="preserve">
          <source>Implements reports whether type V implements interface T.</source>
          <target state="translated">Implementa informes si el tipo V implementa la interfaz T.</target>
        </trans-unit>
        <trans-unit id="5ba5f70840c67e6a055ce04e03bb2454bb162d9f" translate="yes" xml:space="preserve">
          <source>Import is shorthand for Default.Import.</source>
          <target state="translated">Importar es la abreviatura de Default.Import.</target>
        </trans-unit>
        <trans-unit id="6afc9b3e57abb6585be9561d376bdea28ca944ae" translate="yes" xml:space="preserve">
          <source>Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.</source>
          <target state="translated">Importar devuelve detalles sobre el paquete Go nombrado por la ruta de importación,interpretando las rutas de importación locales en relación con el directorio srcDir.Si la ruta es una ruta de importación local que nombra un paquete que puede ser importado usando una ruta de importación estándar,el paquete devuelto establecerá p.ImportPath en esa ruta.</target>
        </trans-unit>
        <trans-unit id="93d88a517c9d75699c2e4045b6e3fc932cd88482" translate="yes" xml:space="preserve">
          <source>ImportDir is like Import but processes the Go package found in the named directory.</source>
          <target state="translated">ImportDir es como Import pero procesa el paquete Go que se encuentra en el directorio nombrado.</target>
        </trans-unit>
        <trans-unit id="58d6f3af90d9fbc41be2c405bfa8615d93151250" translate="yes" xml:space="preserve">
          <source>ImportDir is shorthand for Default.ImportDir.</source>
          <target state="translated">ImportDir es la abreviatura de Default.ImportDir.</target>
        </trans-unit>
        <trans-unit id="2d321830ed77e3baaf4ac8b7f7efc36408c85002" translate="yes" xml:space="preserve">
          <source>ImportMode is reserved for future use.</source>
          <target state="translated">ImportMode está reservado para un uso futuro.</target>
        </trans-unit>
        <trans-unit id="81d5bfd42309b64b183f9701f930099193a14426" translate="yes" xml:space="preserve">
          <source>Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.</source>
          <target state="translated">Importado devuelve el paquete que fue importado.Es distinto de Pkg(),que es el paquete que contiene la declaración de importación.</target>
        </trans-unit>
        <trans-unit id="98f8e071166bb5be3aecf52c0312f3d8e38c742a" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries devuelve los nombres de todas las bibliotecas a las que se refiere la f binaria que se espera que estén enlazadas con la f binaria en el momento del enlace dinámico.</target>
        </trans-unit>
        <trans-unit id="6d0d053d5be94190ae4125e53a45e74c9bfff903" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries devuelve las rutas de todas las bibliotecas a las que se refiere la f binaria que se espera que estén enlazadas con la f binaria en el momento del enlace dinámico.</target>
        </trans-unit>
        <trans-unit id="27f49356d80e117cb6ff37f13e3b8dc616e332cb" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.</source>
          <target state="translated">ImportedSymbols devuelve los nombres de todos los símbolos a los que se refiere la f binaria que se espera sean satisfechos por otras bibliotecas en tiempo de carga dinámica.</target>
        </trans-unit>
        <trans-unit id="80301d15602072b275cf4e9d642684ee556fd2a0" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.</source>
          <target state="translated">ImportedSymbols devuelve los nombres de todos los símbolos a los que se refiere la f binaria que se espera sean satisfechos por otras bibliotecas en tiempo de carga dinámica.No devuelve los símbolos débiles.</target>
        </trans-unit>
        <trans-unit id="75eb201c4952cde504ceda9eb34765cbfc018641" translate="yes" xml:space="preserve">
          <source>Imports returns the list of packages directly imported by pkg; the list is in source order.</source>
          <target state="translated">Importaciones devuelve la lista de paquetes importados directamente por paquete;la lista está en orden de origen.</target>
        </trans-unit>
        <trans-unit id="cb7bc76d7380682c92ffb45e3be0edf510619c0c" translate="yes" xml:space="preserve">
          <source>In C syntax, this struct will be</source>
          <target state="translated">En la sintaxis C,esta estructura será</target>
        </trans-unit>
        <trans-unit id="031e67b82062bc206ba16bfbb78969301350778f" translate="yes" xml:space="preserve">
          <source>In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.</source>
          <target state="translated">En Go 1 y Go 1.1,cada paquete producía un Objeto para todas las fuentes de Go y un archivo de fuente de un Objeto por C.</target>
        </trans-unit>
        <trans-unit id="f1a4145c4d681021c6b688a748d3fd850af7e56f" translate="yes" xml:space="preserve">
          <source>In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.</source>
          <target state="translated">En Go 1.1 y anteriores,cada función (representada por un Func)tenía su propia Tabla de Líneas,y el número de línea correspondía a una numeración de todas las líneas de origen del programa,en todos los archivos.Ese número de línea absoluto tendría que convertirse entonces por separado en un nombre de archivo y un número de línea dentro del archivo.</target>
        </trans-unit>
        <trans-unit id="35c4a15e4a2e0d9709fe9d9d2d8891336f5119ee" translate="yes" xml:space="preserve">
          <source>In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</source>
          <target state="translated">En Go 1.12 y anteriores,era posible distribuir los paquetes en forma binaria sin incluir el código fuente utilizado para compilar el paquete.El paquete se distribuía con un archivo fuente no excluido por las restricciones de compilación y que contenía un comentario &quot;//go:binary-only-package&quot;.Al igual que una restricción de compilación,este comentario aparecía en la parte superior del archivo,precedido únicamente por líneas en blanco y otros comentarios de línea y con una línea en blanco después del comentario,para separarlo de la documentación del paquete.A diferencia de las restricciones de compilación,este comentario sólo se reconoce en los archivos de origen que no son de prueba de Go.</target>
        </trans-unit>
        <trans-unit id="cc8775c16cc6c9f67e9f67d2c4b9b38bd2343802" translate="yes" xml:space="preserve">
          <source>In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.</source>
          <target state="translated">En Go 1.2,el formato de los datos cambió para que haya una sola Tabla de Líneas para todo el programa,compartida por todos los Funcs,y no hay números de línea absolutos,sólo números de línea dentro de archivos específicos.</target>
        </trans-unit>
        <trans-unit id="94c3f9b8a2f1195c43f29bc6d1587c741d49bcbe" translate="yes" xml:space="preserve">
          <source>In Go 1.2, there is a single Obj for the entire program.</source>
          <target state="translated">En Go 1.2,hay un solo Objeto para todo el programa.</target>
        </trans-unit>
        <trans-unit id="fc1a1510c05c5e605f2bf42bab100aff6fd4f01e" translate="yes" xml:space="preserve">
          <source>In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.</source>
          <target state="translated">En Printf,Sprintf y Fprintf,el comportamiento por defecto es para cada verbo de formato para formatear los sucesivos argumentos pasados en la llamada.Sin embargo,la notación [n]inmediatamente antes del verbo indica que el argumento n-ésimo de un índice debe ser formateado en su lugar.La misma notación antes de un '*' para un ancho o precisión selecciona el índice del argumento que contiene el valor.Después de procesar una expresión entre corchetes [n],los verbos subsiguientes utilizarán los argumentos n+1,n+2,etc.a menos que se indique lo contrario.</target>
        </trans-unit>
        <trans-unit id="6f69301b556dc9f571bc4bb3612422a63af49e86" translate="yes" xml:space="preserve">
          <source>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.</source>
          <target state="translated">En TLS 1.3,este tipo se llama NamedGroup,pero en este momento esta biblioteca sólo soporta grupos basados en Curvas Elípticas.Ver RFC 8446,Sección 4.2.7.</target>
        </trans-unit>
        <trans-unit id="93a2aff531fe6a26d094463bdd12d8ce980726db" translate="yes" xml:space="preserve">
          <source>In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.</source>
          <target state="translated">En un programa Go que incluye un código no Go,típicamente código C/C++al que se accede usando cgo o SWIG,el código de inicio de Go normalmente se ejecuta primero.Configura los manejadores de señal como se espera en el tiempo de ejecución de Go,antes de que se ejecute el código de inicio no-Go.Si el código de inicio no-Go desea instalar sus propios manejadores de señal,debe tomar ciertos pasos para que Go siga funcionando bien.Esta sección documenta esos pasos y el efecto general que los cambios en la configuración de los manejadores de señales por el código no-Go pueden tener en los programas Go.En raras ocasiones,el código no-Go puede ejecutarse antes que el código Go,en cuyo caso también se aplica la siguiente sección.</target>
        </trans-unit>
        <trans-unit id="b709a8b5c95be5a899a7612ec04af9fcd8c6fe68" translate="yes" xml:space="preserve">
          <source>In addition to adding the HTTP handler, this package registers the following variables:</source>
          <target state="translated">Además de añadir el manejador HTTP,este paquete registra las siguientes variables:</target>
        </trans-unit>
        <trans-unit id="c7232c786e65fae897885a5d1905f0858ffd2ae2" translate="yes" xml:space="preserve">
          <source>In addition to the required &amp;ldquo;wall clock&amp;rdquo; reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the &amp;ldquo;Monotonic Clocks&amp;rdquo; section in the package documentation for details.</source>
          <target state="translated">Adem&amp;aacute;s de la lectura requerida del &amp;ldquo;reloj de pared&amp;rdquo;, una Hora puede contener una lectura opcional del reloj mon&amp;oacute;tono del proceso actual, para proporcionar precisi&amp;oacute;n adicional para la comparaci&amp;oacute;n o resta. Consulte la secci&amp;oacute;n &quot;Relojes monot&amp;oacute;nicos&quot; en la documentaci&amp;oacute;n del paquete para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="965439857efd394443e37d36ace60b7ac7d83473" translate="yes" xml:space="preserve">
          <source>In addition to the struct tags recognised by Unmarshal, the following can be used:</source>
          <target state="translated">Además de las etiquetas de estructura reconocidas por Unmarshal:</target>
        </trans-unit>
        <trans-unit id="d07fa607208161c419b4aff2675e4f243b41086c" translate="yes" xml:space="preserve">
          <source>In all other cases, Scan returns an empty literal string.</source>
          <target state="translated">En todos los demás casos,Scan devuelve una cadena literal vacía.</target>
        </trans-unit>
        <trans-unit id="dc451d8d43456b62826bda28dfbc96cdb2eb2524" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\r\n means the same as \n).</source>
          <target state="translated">En todas las funciones de escaneo,un retorno de carro seguido inmediatamente de una nueva línea se trata como una nueva línea simple (\r\ ~ significa lo mismo que \ ~ -).</target>
        </trans-unit>
        <trans-unit id="fedccbf24f7f68d8101f599e3218a03c5ffaf765" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.</source>
          <target state="translated">En todas las funciones de escaneo,si un operando implementa el método Scan (es decir,implementa la interfaz de Scanner)ese método se utilizará para escanear el texto para ese operando.Además,si el número de argumentos escaneados es menor que el número de argumentos proporcionados,se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="a1bf502195aaabff9af8feae702eb1ba2c806b3d" translate="yes" xml:space="preserve">
          <source>In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.</source>
          <target state="translated">En una lista de errores,un error se representa con un *Error.La posición Pos,si es válida,apunta al comienzo de la ficha de infracción,y la condición de error es descrita por Msg.</target>
        </trans-unit>
        <trans-unit id="c43ce5959f73c41a703ce648d64371023d38a1e1" translate="yes" xml:space="preserve">
          <source>In early versions of Go each source file became a different Obj.</source>
          <target state="translated">En las primeras versiones de Go,cada archivo fuente se convirtió en un objeto diferente.</target>
        </trans-unit>
        <trans-unit id="42a68547a9dca9735cb7eba8147953340f09b72e" translate="yes" xml:space="preserve">
          <source>In effect, the method must look schematically like</source>
          <target state="translated">En efecto,el método debe parecer esquemáticamente como</target>
        </trans-unit>
        <trans-unit id="b72051420981768a1127b1640516d07dc80b1c1a" translate="yes" xml:space="preserve">
          <source>In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</source>
          <target state="translated">En general DeepEqual es una relajación recursiva del operador de Go ==.Sin embargo,esta idea es imposible de implementar sin alguna inconsistencia.Concretamente,es posible que un valor sea desigual a sí mismo,ya sea porque es de tipo func (no comparable en general)o porque es un valor NaN de punto flotante (no igual a sí mismo en la comparación de puntos flotantes),o porque es una matriz,estructura o interfaz que contiene tal valor.Por otra parte,los valores de los punteros son siempre iguales a sí mismos,aunque apunten o contengan tales valores problemáticos,porque se comparan iguales utilizando el operador Go's ==,y esa es una condición suficiente para ser profundamente iguales,independientemente del contenido.DeepEqual se ha definido de manera que el mismo atajo se aplica a los trozos y a los mapas:si x e y son el mismo trozo o el mismo mapa,son profundamente iguales independientemente del contenido.</target>
        </trans-unit>
        <trans-unit id="07b960c708d879d40875264c73a08a0683383d6b" translate="yes" xml:space="preserve">
          <source>In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.</source>
          <target state="translated">En general,el valor de un atributo dado puede adoptar una de varias clases posibles definidas por DWARF,cada una de las cuales conduce a una interpretación ligeramente diferente del atributo.</target>
        </trans-unit>
        <trans-unit id="2e9ecaaf397056078378f799dda9c4e1072c7928" translate="yes" xml:space="preserve">
          <source>In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.</source>
          <target state="translated">En general,un archivo gzip puede ser una concatenación de archivos gzip,cada uno con su propio encabezado.Las lecturas del lector devuelven la concatenación de los datos no comprimidos de cada uno.Sólo el primer encabezado se registra en los campos del Lector.</target>
        </trans-unit>
        <trans-unit id="b6ffd0a95c8557850de7ace105d0c02e95a18d70" translate="yes" xml:space="preserve">
          <source>In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.</source>
          <target state="translated">En general,si se requiere una asignación,el decodificador asignará la memoria.Si no,actualizará las variables de destino con los valores leídos de la corriente.No las inicializa primero,por lo que si el destino es un valor compuesto como un mapa,una estructura o una rebanada,los valores decodificados se fusionarán por elementos en las variables existentes.</target>
        </trans-unit>
        <trans-unit id="d1a73603a88217147c68ec9c324a3f4cba1ebddc" translate="yes" xml:space="preserve">
          <source>In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.</source>
          <target state="translated">En general,reflect.SliceHeader y reflect.StringHeader sólo deben usarse como *reflejo.SliceHeader y *reflejo.StringHeader apuntando a cortes o cadenas reales,nunca como estructuras simples.Un programa no debe declarar o asignar variables de estos tipos de estructuras.</target>
        </trans-unit>
        <trans-unit id="99dc4b6fd44a858b786d20b64de92f5f16319ca0" translate="yes" xml:space="preserve">
          <source>In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying Block was created by aes.NewCipher on systems with hardware support for AES. See the crypto/aes package documentation for details.</source>
          <target state="translated">En general,la operación de GHASH realizada por esta implementación del GCM no es de tiempo constante.Una excepción es cuando el Bloque subyacente fue creado por aes.NewCipher en sistemas con soporte de hardware para AES.Vea la documentación del paquete crypto/aes para más detalles.</target>
        </trans-unit>
        <trans-unit id="63a94d50c6e71995bfdddbf6d3b7ddbbd572fca1" translate="yes" xml:space="preserve">
          <source>In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.</source>
          <target state="translated">En la mayoría de los casos,un nuevo (Buffer)(o simplemente declarando una variable de Buffer)es suficiente para inicializar un Buffer.</target>
        </trans-unit>
        <trans-unit id="ce6abe6e4a1757599621f3d92af6850089e3e51d" translate="yes" xml:space="preserve">
          <source>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</source>
          <target state="translated">En los entornos no HTML donde el escape interfiere con la legibilidad de la salida,SetEscapeHTML(false)deshabilita este comportamiento.</target>
        </trans-unit>
        <trans-unit id="7077ca93ebf4ef49120708550f14d220620ccf80" translate="yes" xml:space="preserve">
          <source>In panics if loc is nil.</source>
          <target state="translated">En pánico si la locación es nula.</target>
        </trans-unit>
        <trans-unit id="f52d38c87623b45c8b7767cba23884c87bb2c3a8" translate="yes" xml:space="preserve">
          <source>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</source>
          <target state="translated">En particular,implementa el LZW tal como lo utilizan los formatos de archivo GIF y PDF,lo que significa códigos de ancho variable de hasta 12 bits y los dos primeros códigos no literales son un código claro y un código EOF.</target>
        </trans-unit>
        <trans-unit id="4026aa85ef00c786dfe0c796e4b667cd2644b68d" translate="yes" xml:space="preserve">
          <source>In performance critical applications, Reset can be used to discard the current compressor or decompressor state and reinitialize them quickly by taking advantage of previously allocated memory.</source>
          <target state="translated">En las aplicaciones de rendimiento crítico,la función Reset puede utilizarse para descartar el estado actual del compresor o del descompresor y reiniciarlos rápidamente aprovechando la memoria asignada previamente.</target>
        </trans-unit>
        <trans-unit id="6db233d0c99db26b8c12c611c05604abfea98d46" translate="yes" xml:space="preserve">
          <source>In reports whether every point in r is in s.</source>
          <target state="translated">En los informes si cada punto de la r está en la s.</target>
        </trans-unit>
        <trans-unit id="84fe4eae8d319a1913e35010d51f1271fd7ded56" translate="yes" xml:space="preserve">
          <source>In reports whether p is in r.</source>
          <target state="translated">En los informes si p está en r.</target>
        </trans-unit>
        <trans-unit id="0fd55e418f00485b3f2efc5b428b0418b6a94be8" translate="yes" xml:space="preserve">
          <source>In reports whether the rune is a member of one of the ranges.</source>
          <target state="translated">En los informes si la runa es un miembro de uno de los rangos.</target>
        </trans-unit>
        <trans-unit id="472b3dea5785c77ec21b439277ea93730e47a2be" translate="yes" xml:space="preserve">
          <source>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.</source>
          <target state="translated">En las devoluciones una copia de t representando el mismo instante de tiempo,pero con la información de la ubicación de la copia fijada para localizarla con fines de visualización.</target>
        </trans-unit>
        <trans-unit id="711d8c9ceb05e3476e4192e2fd5e66ccc3b3ba1b" translate="yes" xml:space="preserve">
          <source>In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.</source>
          <target state="translated">En rebanadas y arreglos,así como en los mapas,se transmiten todos los elementos,incluso los de valor cero,aunque todos los elementos sean cero.</target>
        </trans-unit>
        <trans-unit id="9f17f1b7292d381dce79c4e2b9b83d7f1d5da96e" translate="yes" xml:space="preserve">
          <source>In summary, a gob stream looks like</source>
          <target state="translated">En resumen,una corriente de gota se parece a</target>
        </trans-unit>
        <trans-unit id="2d78ddedbd337c0bea6888e7055a4838325b74f8" translate="yes" xml:space="preserve">
          <source>In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</source>
          <target state="translated">En el formulario de $nombre,se toma el nombre lo más largo posible:$1x equivale a ${1x},no ${1}x,y,$10 equivale a ${10},no ${1}0.</target>
        </trans-unit>
        <trans-unit id="37a0ec0d20103e0c83570c4610c7755ff7ac53c0" translate="yes" xml:space="preserve">
          <source>In the absence of a time zone indicator, Parse returns a time in UTC.</source>
          <target state="translated">En ausencia de un indicador de zona horaria,Parse devuelve una hora en UTC.</target>
        </trans-unit>
        <trans-unit id="b029486adc899e6b2e4bce186582f459ceb89a34" translate="yes" xml:space="preserve">
          <source>In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:</source>
          <target state="translated">En el directorio que contiene el paquete,los archivos .go,.c,.h,y .s se consideran parte del paquete excepto por:</target>
        </trans-unit>
        <trans-unit id="fa1c6c88c18a52fe6d2731df7b2ac739dc65317f" translate="yes" xml:space="preserve">
          <source>In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.</source>
          <target state="translated">En la cadena de formato,un verbo introducido por el carácter % consume y analiza la entrada;estos verbos se describen con más detalle a continuación.Un carácter que no sea %,espacio o línea nueva en el formato consume exactamente ese carácter introducido,que debe estar presente.Una nueva línea con cero o más espacios antes de ella en la cadena del formato consume cero o más espacios en la entrada seguida de una sola nueva línea o el final de la entrada.Un espacio que sigue a una nueva línea en la cadena de formato consume cero o más espacios en la entrada.De lo contrario,cualquier ejecución de uno o más espacios en la cadena de formato consume tantos espacios como sea posible en la entrada.A menos que la serie de espacios en la cadena de formato aparezca adyacente a una nueva línea,la serie debe consumir al menos un espacio de la entrada o encontrar el final de la misma.</target>
        </trans-unit>
        <trans-unit id="ed1a2050a365f5d52ef37144115d11517ff42bc2" translate="yes" xml:space="preserve">
          <source>In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.</source>
          <target state="translated">En el caso más simple,si el tipo del valor de la columna de origen es un entero,bool o cadena tipo T y el destino es del tipo *T,Scan simplemente asigna el valor a través del puntero.</target>
        </trans-unit>
        <trans-unit id="5c811352496639bcd7be1278e40839e6992f883a" translate="yes" xml:space="preserve">
          <source>In the second form, the following rules apply:</source>
          <target state="translated">En la segunda forma,se aplican las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="9ca6beb2058ca8ef81c9dbee1705e13b3578af1f" translate="yes" xml:space="preserve">
          <source>In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&amp;lt;name&amp;gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.</source>
          <target state="translated">En la plantilla, una variable se indica mediante una subcadena de la forma $ nombre o $ {nombre}, donde nombre es una secuencia no vac&amp;iacute;a de letras, d&amp;iacute;gitos y guiones bajos. Un nombre puramente num&amp;eacute;rico como $ 1 se refiere a la subcoincidencia con el &amp;iacute;ndice correspondiente; otros nombres se refieren a la captura de par&amp;eacute;ntesis nombrados con la sintaxis (? P &amp;lt;nombre&amp;gt; ...). Una referencia a un &amp;iacute;ndice fuera de rango o no coincidente o un nombre que no est&amp;aacute; presente en la expresi&amp;oacute;n regular se reemplaza con un segmento vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="5a1c160af25c73f96bab58b7ac18692fbbe1ffa1" translate="yes" xml:space="preserve">
          <source>In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</source>
          <target state="translated">En la terminología de la biblioteca zlib,Flush es equivalente a Z_SYNC_FLUSH.</target>
        </trans-unit>
        <trans-unit id="2dd7b02fa4aa241d6b5f4aad090e1521eaf7af73" translate="yes" xml:space="preserve">
          <source>In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.</source>
          <target state="translated">En este uso,hdr.Data es realmente una forma alternativa de referirse al puntero subyacente en el encabezado de la cadena,no una variable uintptr en sí misma.</target>
        </trans-unit>
        <trans-unit id="b66dfbc84a8b6f209be163efb64c95ba40440449" translate="yes" xml:space="preserve">
          <source>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).</source>
          <target state="translated">InUseBytes devuelve el número de bytes en uso (AllocBytes-FreeBytes).</target>
        </trans-unit>
        <trans-unit id="d6ed56286846a6cf59f0baa7c19dd1836590eeba" translate="yes" xml:space="preserve">
          <source>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).</source>
          <target state="translated">InUseObjects devuelve el número de objetos en uso (AllocObjects-FreeObjects).</target>
        </trans-unit>
        <trans-unit id="dfe141017385b1d5692d01442e77119d4a1ae1e2" translate="yes" xml:space="preserve">
          <source>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</source>
          <target state="translated">Las solicitudes entrantes a un servidor deben crear un contexto,y las llamadas salientes a los servidores deben aceptar un contexto.La cadena de llamadas de función entre ellos debe propagar el Contexto,opcionalmente sustituyéndolo por un Contexto derivado creado usando WithCancel,WithDeadline,WithTimeout,o WithValue.Cuando se cancela un Contexto,todos los Contextos derivados del mismo también se cancelan.</target>
        </trans-unit>
        <trans-unit id="f3527c443ffc9a19a79c9a5af60b69f82dd615d1" translate="yes" xml:space="preserve">
          <source>IncorrectPasswordError is returned when an incorrect password is detected.</source>
          <target state="translated">IncorrectoContraseñaError que se devuelve cuando se detecta una contraseña incorrecta.</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="ffaaf5870213dda02bfcfd6086cb6c73c505917c" translate="yes" xml:space="preserve">
          <source>Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.</source>
          <target state="translated">La sangría se añade a una forma sangrante del círculo codificado JSON.Cada elemento de un objeto o matriz JSON comienza en una nueva línea sangrada que empieza con un prefijo seguido de una o más copias de sangría según el anidamiento de la sangría.Los datos añadidos a la dst no comienzan con el prefijo ni con ninguna sangría,para facilitar la inserción en otros datos JSON formateados.Aunque se eliminan los caracteres de espacio inicial (espacio,tabulador,retorno de carro,línea nueva)al principio del src,los caracteres de espacio final al final del src se conservan y se copian a la dst.Por ejemplo,si src no tiene espacios finales,tampoco lo hará dst;si src termina en una línea nueva final,también lo hará dst.</target>
        </trans-unit>
        <trans-unit id="68e20af4dfa7d94d1e8e99b5a45a2168cf2653cc" translate="yes" xml:space="preserve">
          <source>Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">Indent establece el codificador para generar XML en el que cada elemento comienza en una nueva línea sangrada que empieza con un prefijo y va seguida de una o más copias de sangría según la profundidad de anidación.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="421722312ce68c9bf9eb41def321649c4712dbd6" translate="yes" xml:space="preserve">
          <source>Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:</source>
          <target state="translated">El índice describe el camino de x a f en x.f.La última entrada del índice es el campo o índice del método del tipo que declara f;cualquiera:</target>
        </trans-unit>
        <trans-unit id="1d0b49853e61d44f4f8b07282b1903e9f2bc5158" translate="yes" xml:space="preserve">
          <source>Index implements a suffix array for fast substring search.</source>
          <target state="translated">Index implementa una matriz de sufijos para una búsqueda rápida de subcadenas.</target>
        </trans-unit>
        <trans-unit id="af573efacc3f6c1539d934e082a33b7c5805e74a" translate="yes" xml:space="preserve">
          <source>Index responds with the pprof-formatted profile named by the request. For example, &quot;/debug/pprof/heap&quot; serves the &quot;heap&quot; profile. Index responds to a request for &quot;/debug/pprof/&quot; with an HTML page listing the available profiles.</source>
          <target state="translated">El índice responde con el perfil de formato pprof nombrado por la solicitud.Por ejemplo,&quot;/debug/pprof/heap&quot; sirve para el perfil &quot;heap&quot;.Index responde a una solicitud de &quot;/debug/pprof/&quot; con una página HTML que enumera los perfiles disponibles.</target>
        </trans-unit>
        <trans-unit id="fd5b04a55e6c188f04225c052c3a4ebb3eecf806" translate="yes" xml:space="preserve">
          <source>Index returns JavaScript index i of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">El índice devuelve el índice JavaScript i del valor v.Se asusta si v no es un objeto JavaScript.</target>
        </trans-unit>
        <trans-unit id="41cc91c9bcf3f0a08fb627d21f4a77281aee4bad" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">El índice devuelve el índice de la primera instancia de sep en s,o -1 si sep no está presente en s.</target>
        </trans-unit>
        <trans-unit id="1f02d6f4db0fe2bb71d169a720ea48dacd4410f7" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">El índice devuelve el índice de la primera instancia de la substr en s,o -1 si la substr no está presente en s.</target>
        </trans-unit>
        <trans-unit id="6672a7ad3732041777afcc9d59e94790fa08598a" translate="yes" xml:space="preserve">
          <source>Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.</source>
          <target state="translated">El índice devuelve el índice del color de la paleta más cercano a la c en el espacio euclidiano R,G,B,A.</target>
        </trans-unit>
        <trans-unit id="08cc5090355bf36192f88d52e3809f63b35b1be3" translate="yes" xml:space="preserve">
          <source>Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.</source>
          <target state="translated">El índice devuelve el elemento de V'th.Entra en pánico si el tipo de V no es Array,Slice o String o si está fuera de rango.</target>
        </trans-unit>
        <trans-unit id="f604fe204d59450e53c6f0f981bb463a3da262fc" translate="yes" xml:space="preserve">
          <source>Index.Lookup</source>
          <target state="translated">Index.Lookup</target>
        </trans-unit>
        <trans-unit id="693f6afea6d2763baec63c4f683ab836809a8526" translate="yes" xml:space="preserve">
          <source>IndexAny</source>
          <target state="translated">IndexAny</target>
        </trans-unit>
        <trans-unit id="227cd6f0abdfd091813bf35b8fd1dcfbc25cecd9" translate="yes" xml:space="preserve">
          <source>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">IndexAny interpreta la s como una secuencia de puntos de código Unicode codificados en UTF-8.Devuelve el índice de bytes de la primera ocurrencia en s de cualquiera de los puntos de código Unicode en caracteres.Devuelve -1 si los caracteres están vacíos o si no hay ningún punto de código en común.</target>
        </trans-unit>
        <trans-unit id="1adf36d0e196212f2787325e2cb626ccc3228c3b" translate="yes" xml:space="preserve">
          <source>IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">IndexAny devuelve el índice de la primera instancia de cualquier punto de código Unicode a partir de los caracteres en s,o -1 si no hay ningún punto de código Unicode a partir de los caracteres en s.</target>
        </trans-unit>
        <trans-unit id="91d007c3332e259ec2e02f981423ecacc90c6ee6" translate="yes" xml:space="preserve">
          <source>IndexByte</source>
          <target state="translated">IndexByte</target>
        </trans-unit>
        <trans-unit id="c4f06e8f47e53dedfca453887d03a95ac035b5de" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</source>
          <target state="translated">IndexByte devuelve el índice de la primera instancia de c en b,o -1 si c no está presente en b.</target>
        </trans-unit>
        <trans-unit id="c369952c4d2f42c9a51eabe33a7908d4c8f60ad4" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">IndexByte devuelve el índice de la primera instancia de c en s,o -1 si c no está presente en s.</target>
        </trans-unit>
        <trans-unit id="4b29f4c46fd4242b96d7f6d96005476262ea25b4" translate="yes" xml:space="preserve">
          <source>IndexFunc</source>
          <target state="translated">IndexFunc</target>
        </trans-unit>
        <trans-unit id="fd5aa7f0734b2b2162a12de708cba7a93a1ba269" translate="yes" xml:space="preserve">
          <source>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc interpreta la s como una secuencia de puntos de código codificados en UTF-8.Devuelve el índice de bytes en s del primer punto de código Unicode que satisface f(c),o -1 si no hay ninguno.</target>
        </trans-unit>
        <trans-unit id="67453fcd073346734a7503bb3d4207a4ffac0a81" translate="yes" xml:space="preserve">
          <source>IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc devuelve el índice en s del primer punto de código Unicode que satisface f(c),o -1 si no hay ninguno.</target>
        </trans-unit>
        <trans-unit id="0404886738141ffe45c4d013ff978a64bde2ba63" translate="yes" xml:space="preserve">
          <source>IndexRune</source>
          <target state="translated">IndexRune</target>
        </trans-unit>
        <trans-unit id="f4318ccac75e1dd461aaa7a9c7842e97a421edce" translate="yes" xml:space="preserve">
          <source>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune interpreta la s como una secuencia de puntos de código codificados en UTF-8.Devuelve el índice de bytes de la primera ocurrencia en s de la runa dada.Devuelve -1 si la runa no está presente en s.Si r es utf8.RuneError,devuelve la primera instancia de cualquier secuencia de bytes UTF-8 inválida.</target>
        </trans-unit>
        <trans-unit id="042bb768e6a79fc4f2a8939cb46f8d887178fb46" translate="yes" xml:space="preserve">
          <source>IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune devuelve el índice de la primera instancia del punto de código Unicode r,o -1 si la runa no está presente en s.Si r es utf8.RuneError,devuelve la primera instancia de cualquier secuencia de bytes UTF-8 inválida.</target>
        </trans-unit>
        <trans-unit id="a85d156f8eef16ea6fae8f47130c09e7ab738f38" translate="yes" xml:space="preserve">
          <source>Indexes into the Header.Ident array.</source>
          <target state="translated">Índices en la matriz Header.Ident.</target>
        </trans-unit>
        <trans-unit id="bee82bdb7da751fd64eea7f5143956992f5aed77" translate="yes" xml:space="preserve">
          <source>Indices into the Delta arrays inside CaseRanges for case mapping.</source>
          <target state="translated">Indices en los arreglos Delta dentro de CaseRanges para el mapeo de casos.</target>
        </trans-unit>
        <trans-unit id="22023c8031bf3535a364147cd1c4ebacba51eca8" translate="yes" xml:space="preserve">
          <source>Indirect reports whether any pointer indirection was required to get from x to f in x.f.</source>
          <target state="translated">Informa indirectamente si se requería algún indicador indirecto para pasar de x a f en x.f.</target>
        </trans-unit>
        <trans-unit id="1dbf2dfd2ac6c93be252e418d12775d2db6f53d8" translate="yes" xml:space="preserve">
          <source>Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</source>
          <target state="translated">Indirecto devuelve el valor al que v apunta.Si v es un puntero nulo,Indirecto devuelve un valor cero.Si v no es un puntero,el Indirecto devuelve v.</target>
        </trans-unit>
        <trans-unit id="fe7ad1fbee745b4ca3d08d7729476db7d9fb4fe9" translate="yes" xml:space="preserve">
          <source>Inf returns a complex infinity, complex(+Inf, +Inf).</source>
          <target state="translated">Inf devuelve un complejo infinito,complejo(+Inf,+Inf).</target>
        </trans-unit>
        <trans-unit id="0125073a5f3757f1dc62bea262918d4c5b3bae8e" translate="yes" xml:space="preserve">
          <source>Inf returns positive infinity if sign &amp;gt;= 0, negative infinity if sign &amp;lt; 0.</source>
          <target state="translated">Inf devuelve infinito positivo si signo&amp;gt; = 0, infinito negativo si signo &amp;lt;0.</target>
        </trans-unit>
        <trans-unit id="fd7feb1c61f7423453cbee79d9998496c4df75f3" translate="yes" xml:space="preserve">
          <source>Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.</source>
          <target state="translated">La recursión infinita también puede ser desencadenada por estructuras de datos autorreferenciales,como un trozo que se contiene a sí mismo como un elemento,si ese tipo tiene un método String.Sin embargo,estas patologías son raras y el paquete no protege contra ellas.</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="0e2ca261be59b2db86de1819fd95c5c62808d215" translate="yes" xml:space="preserve">
          <source>Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.</source>
          <target state="translated">La información contiene la información del tipo de resultado para un paquete de tipo comprobado.Sólo se recoge la información para la que se proporciona un mapa.Si el paquete tiene errores de tipo,la información recogida puede estar incompleta.</target>
        </trans-unit>
        <trans-unit id="829a6f4d1b71214eb93db4bdc76fb1b790f4e5d1" translate="yes" xml:space="preserve">
          <source>Info logs a message with severity LOG_INFO, ignoring the severity passed to New.</source>
          <target state="translated">Info registra un mensaje con la severidad LOG_INFO,ignorando la severidad pasada a New.</target>
        </trans-unit>
        <trans-unit id="d0968061a8aa60c3762f0e765c2376d0827896c3" translate="yes" xml:space="preserve">
          <source>Info returns information about properties of basic type b.</source>
          <target state="translated">Info devuelve información sobre las propiedades del tipo básico b.</target>
        </trans-unit>
        <trans-unit id="4bebef89f6713b109d9329a6bfe51cba5fd0be4f" translate="yes" xml:space="preserve">
          <source>Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().</source>
          <target state="translated">Init establece las invariantes de pila requeridas por las otras rutinas de este paquete.Init es idempotente con respecto a las invariantes de cúmulo y puede ser llamado siempre que las invariantes de cúmulo puedan haber sido invalidadas.La complejidad es O(n)donde n=h.Len().</target>
        </trans-unit>
        <trans-unit id="e025530212d94f43014839edcd8664101cb1d082" translate="yes" xml:space="preserve">
          <source>Init has no effect if it was already called.</source>
          <target state="translated">El Init no tiene ningún efecto si ya fue llamado.</target>
        </trans-unit>
        <trans-unit id="ab8a6a690d98493f29c3a7eded17da06a0fe4963" translate="yes" xml:space="preserve">
          <source>Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace.</source>
          <target state="translated">Init inicializa un Escáner con una nueva fuente y devuelve s.Error se pone a cero,ErrorCount se pone a 0,Mode se pone a GoTokens,y Whitespace se pone a GoWhitespace.</target>
        </trans-unit>
        <trans-unit id="38f2f0576d19cc2c5fa27415d0b566e72a9f5fcc" translate="yes" xml:space="preserve">
          <source>Init initializes or clears list l.</source>
          <target state="translated">Inicializa o borra la lista l.</target>
        </trans-unit>
        <trans-unit id="4828f42508fc3abcabc5d7577bba28e3151a2a20" translate="yes" xml:space="preserve">
          <source>Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.</source>
          <target state="translated">El Init prepara al escáner s para que el texto src se fije en el inicio del src.El escáner usa el archivo del conjunto de archivos para la información de posición y agrega información de línea para cada línea.Está bien volver a utilizar el mismo archivo cuando se vuelve a escanear el mismo archivo,ya que se ignora la información de línea que ya está presente.El init causa pánico si el tamaño del archivo no coincide con el tamaño del src.</target>
        </trans-unit>
        <trans-unit id="1ff5728fd1958fa03cc23f0615bd53c6b8512d71" translate="yes" xml:space="preserve">
          <source>Init registers testing flags. These flags are automatically registered by the &quot;go test&quot; command before running test functions, so Init is only needed when calling functions such as Benchmark without using &quot;go test&quot;.</source>
          <target state="translated">El Init registra las banderas de prueba.Estos indicadores se registran automáticamente mediante el comando &quot;go test&quot; antes de ejecutar las funciones de prueba,por lo que el Init sólo es necesario cuando se llaman funciones como Benchmark sin utilizar &quot;go test&quot;.</target>
        </trans-unit>
        <trans-unit id="e71fb65b44dd31464c3ab6d5dc9c1b767849af42" translate="yes" xml:space="preserve">
          <source>Init removes all keys from the map.</source>
          <target state="translated">Init elimina todas las claves del mapa.</target>
        </trans-unit>
        <trans-unit id="2f9d5d06290960b800b664c463e2749afea3e374" translate="yes" xml:space="preserve">
          <source>Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.</source>
          <target state="translated">Init establece el nombre y la propiedad de manejo de errores para un conjunto de banderas.Por defecto,el FlagSet cero utiliza un nombre vacío y la política de tratamiento de errores ContinueOnError.</target>
        </trans-unit>
        <trans-unit id="1ff277aa8c5f044965228237465cbaf43a54dec6" translate="yes" xml:space="preserve">
          <source>Initial magic number for ELF files.</source>
          <target state="translated">Número mágico inicial para los archivos de la ELF.</target>
        </trans-unit>
        <trans-unit id="7ceb1ca1dad4f40542d5a478441bc59f2f8873ca" translate="yes" xml:space="preserve">
          <source>Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">El interior devuelve el alcance más interno (infantil)que contiene pos.Si la posición no está dentro de ningún ámbito,el resultado es nulo.El resultado también es nulo para el alcance del Universo.Se garantiza que el resultado es válido sólo si el AST verificado tiene la información de posición completa.</target>
        </trans-unit>
        <trans-unit id="d3d677ba8b8fb62d3d734397c41c430f5735b25c" translate="yes" xml:space="preserve">
          <source>Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.</source>
          <target state="translated">La entrada procesada por los verbos está implícitamente limitada por el espacio:la implementación de cada verbo,excepto %c,comienza descartando los espacios de la entrada restante,y el verbo %s (y %v que se lee en una cadena)deja de consumir entrada en el primer espacio o carácter de nueva línea.</target>
        </trans-unit>
        <trans-unit id="f2b998d9fdcbc1c4a3ffebeea1625f9214a80db4" translate="yes" xml:space="preserve">
          <source>InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.</source>
          <target state="translated">InputOffset devuelve el offset de bytes del flujo de entrada de la posición actual del decodificador.El offset da la ubicación del final del último token devuelto y el comienzo del siguiente token.</target>
        </trans-unit>
        <trans-unit id="e966ee10eb4ce3215fa8906700a612e44342e126" translate="yes" xml:space="preserve">
          <source>InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bdbccac97746d550ea930e761dad7ffa800d06" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.</source>
          <target state="translated">Insert intenta insertar un objeto con nombre en el ámbito s.Si el ámbito ya contiene un objeto alt con el mismo nombre,Insert deja el ámbito sin cambios y devuelve alt.En caso contrario,inserta el objeto y devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="3c51f0bca7bc21285dde2f4365d66539c9045fbd" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.</source>
          <target state="translated">Insert intenta insertar un objeto objeto en el ámbito s.Si s ya contiene un objeto alternativo alt con el mismo nombre,Insert deja s sin modificar y devuelve alt.En caso contrario,inserta un objeto,establece el ámbito superior del objeto si no está ya establecido y devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="e5d297ca4eb4122848b745777ba08d9e98e99026" translate="yes" xml:space="preserve">
          <source>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertarDespués inserta un nuevo elemento e con el valor v inmediatamente después de la marca y devuelve e.Si la marca no es un elemento de l,la lista no se modifica.La marca no debe ser nula.</target>
        </trans-unit>
        <trans-unit id="f8690dfd3964564996a8ec4c6a534ffd7d8cce51" translate="yes" xml:space="preserve">
          <source>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertarAntes inserta un nuevo elemento e con el valor v inmediatamente antes de la marca y devuelve e.Si la marca no es un elemento de l,la lista no se modifica.La marca no debe ser nula.</target>
        </trans-unit>
        <trans-unit id="1a44ed1d9fdf3b19a9445ead705835b2d7701bba" translate="yes" xml:space="preserve">
          <source>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.</source>
          <target state="translated">Inset devuelve el rectángulo r insertado por n,que puede ser negativo.Si cualquiera de las dimensiones de r es menor de 2*n,entonces se devolverá un rectángulo vacío cerca del centro de r.</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="165da1fa673b9fd9a581f6c1c726cccbffc7e2ca" translate="yes" xml:space="preserve">
          <source>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).</source>
          <target state="translated">Inspecciona atraviesa un AST en profundidad-en primer orden:Comienza llamando a f(nodo);el nodo no debe ser nulo.Si f devuelve true,Inspeccionar invoca f recursivamente para cada uno de los hijos no nulos del nodo,seguido de una llamada de f(nil).</target>
        </trans-unit>
        <trans-unit id="a6a380194dfce8d967bc921f5f0bd2558e839e1f" translate="yes" xml:space="preserve">
          <source>InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.</source>
          <target state="translated">La instancia de informes si v es una instancia de tipo t según la instancia de operador de JavaScript.</target>
        </trans-unit>
        <trans-unit id="ebf808b93582c50b9dee098ffbc7851e8bbd1bc5" translate="yes" xml:space="preserve">
          <source>Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.</source>
          <target state="translated">Int define un indicador int con un nombre especificado,un valor predeterminado y una cadena de uso.El valor de retorno es la dirección de una variable int que almacena el valor del indicador.</target>
        </trans-unit>
        <trans-unit id="4a82193f61167eeb73caee70b7d931807aee1e38" translate="yes" xml:space="preserve">
          <source>Int is a 64-bit integer variable that satisfies the Var interface.</source>
          <target state="translated">Int es una variable entera de 64 bits que satisface la interfaz Var.</target>
        </trans-unit>
        <trans-unit id="af260c99fb6b16af9acf30bb7ef7c67bfd7f461c" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int from the default Source.</source>
          <target state="translated">Int devuelve un int pseudo-aleatorio no negativo de la Fuente por defecto.</target>
        </trans-unit>
        <trans-unit id="381ad8d2cdfa2db4d632061cd5638bdb827c118f" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int.</source>
          <target state="translated">Int devuelve un int pseudo-aleatorio no negativo.</target>
        </trans-unit>
        <trans-unit id="78b2c6c511c1ed56b26a62f7cd24e23bebce41b7" translate="yes" xml:space="preserve">
          <source>Int returns a uniform random value in [0, max). It panics if max &amp;lt;= 0.</source>
          <target state="translated">Int devuelve un valor aleatorio uniforme en [0, max). Entra en p&amp;aacute;nico si max &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="5333a3a7b26511027f14a3034f5b9a08970c91dc" translate="yes" xml:space="preserve">
          <source>Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &amp;gt; 0, and Above for x &amp;lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.</source>
          <target state="translated">Int devuelve el resultado de truncar x hacia cero; o nulo si x es infinito. El resultado es Exacto si x.IsInt (); de lo contrario, es Inferior para x&amp;gt; 0 y Superior para x &amp;lt;0. Si se proporciona un argumento z no * Int nulo, Int almacena el resultado en z en lugar de asignar un nuevo Int.</target>
        </trans-unit>
        <trans-unit id="b48fef275365436d3178b531a98b6df9140d4a4e" translate="yes" xml:space="preserve">
          <source>Int returns the value v truncated to an int. It panics if v is not a JavaScript number.</source>
          <target state="translated">Int devuelve el valor v truncado a un int.Le entra el pánico si v no es un número de JavaScript.</target>
        </trans-unit>
        <trans-unit id="7aeadc703783366afed8a63b0734b22311f2a7e4" translate="yes" xml:space="preserve">
          <source>Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">Int devuelve el valor subyacente de v,como un int64.Entra en pánico si el tipo de v no es Int,Int8,Int16,Int32,o Int64.</target>
        </trans-unit>
        <trans-unit id="53c091a9597bdba1f2ca46d491f5c108342e031f" translate="yes" xml:space="preserve">
          <source>Int.Scan</source>
          <target state="translated">Int.Scan</target>
        </trans-unit>
        <trans-unit id="5de699e08eb78e768e5b08ea65a2d2d995d6cca4" translate="yes" xml:space="preserve">
          <source>Int.SetString</source>
          <target state="translated">Int.SetString</target>
        </trans-unit>
        <trans-unit id="25863d22096f1ba104e899340881b4d53e78900e" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.</source>
          <target state="translated">Int31 devuelve un entero pseudo-aleatorio de 31 bits no negativo como un int32 de la Fuente por defecto.</target>
        </trans-unit>
        <trans-unit id="8668fa86efe442ed5c0ddfb6799eac348a1585d9" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32.</source>
          <target state="translated">El Int31 devuelve un entero no negativo y pseudo-aleatorio de 31 bits como un int32.</target>
        </trans-unit>
        <trans-unit id="4ef488a0ec898f126b9413bbb42319fb0eaeff13" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n devuelve, como int32, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n) de la fuente predeterminada. Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="90d847f9e26c6ab28ce7fd160e1218ad35e875d4" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n devuelve, como int32, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n). Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="848b71a013b8e0169e247e647c756adf54d70a3d" translate="yes" xml:space="preserve">
          <source>Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value.</source>
          <target state="translated">Int32 es un ValueConverter que convierte los valores de entrada en int64,respetando los límites de un valor int32.</target>
        </trans-unit>
        <trans-unit id="40feceb2effc4993d828a64f0bbc7bd4b65472d1" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.</source>
          <target state="translated">Int63 devuelve un entero pseudo-aleatorio no negativo de 63 bits como un int64 de la Fuente por defecto.</target>
        </trans-unit>
        <trans-unit id="73b13ad335bd8c446e54125036bbdb60110b8a67" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</source>
          <target state="translated">Int63 devuelve un entero de 63 bits no negativo y pseudo-aleatorio como un int64.</target>
        </trans-unit>
        <trans-unit id="ccf199104b81302e6aa6420d9d53fbe6d1e5e481" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n devuelve, como int64, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n) de la fuente predeterminada. Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="adc50ec6888e251cb9eb8237744893f852c6674f" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n devuelve, como int64, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n). Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="caf7332f4387883214a684cf486e59d1298af5e4" translate="yes" xml:space="preserve">
          <source>Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.</source>
          <target state="translated">Int64 define una bandera int64 con un nombre especificado,un valor predeterminado y una cadena de uso.El valor de retorno es la dirección de una variable int64 que almacena el valor del indicador.</target>
        </trans-unit>
        <trans-unit id="5ea42bb5a91b0f37c1c104284dddf7aee6dd3d40" translate="yes" xml:space="preserve">
          <source>Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.</source>
          <target state="translated">Int64 devuelve la representación de x en el int64.Si x no puede ser representada en un int64,el resultado es indefinido.</target>
        </trans-unit>
        <trans-unit id="024ee0329e5ac0182a79c3f0f817ea471b5da8f4" translate="yes" xml:space="preserve">
          <source>Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &amp;lt; 0) or Below (x &amp;gt; 0) otherwise. The result is (math.MinInt64, Above) for x &amp;lt; math.MinInt64, and (math.MaxInt64, Below) for x &amp;gt; math.MaxInt64.</source>
          <target state="translated">Int64 devuelve el n&amp;uacute;mero entero resultante de truncar x hacia cero. Si math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, el resultado es Exacto si x es un n&amp;uacute;mero entero, y Superior (x &amp;lt;0) o Inferior (x&amp;gt; 0) en caso contrario. El resultado es (math.MinInt64, Above) para x &amp;lt;math.MinInt64, y (math.MaxInt64, Below) para x&amp;gt; math.MaxInt64.</target>
        </trans-unit>
        <trans-unit id="a7858f715e5515e9b11682c98c7e956884fa03d3" translate="yes" xml:space="preserve">
          <source>Int64 returns the number as an int64.</source>
          <target state="translated">Int64 devuelve el número como un int64.</target>
        </trans-unit>
        <trans-unit id="e87b1cbe8a7626b33b6c26f9454e9b97aa48ff20" translate="yes" xml:space="preserve">
          <source>Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Int64Val devuelve el valor Go int64 de x y si el resultado es exacto;x debe ser un Int o un Desconocido.Si el resultado no es exacto,su valor es indefinido.Si x es Desconocida,el resultado es (0,falso).</target>
        </trans-unit>
        <trans-unit id="e48ba0f308dabec3542a772cd98df7b4a194464a" translate="yes" xml:space="preserve">
          <source>Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.</source>
          <target state="translated">Int64Var define una bandera int64 con el nombre,el valor predeterminado y la cadena de uso especificados.El argumento p apunta a una variable int64 en la que almacenar el valor del indicador.</target>
        </trans-unit>
        <trans-unit id="826fdf675ec889637dd1607e0ecbc7b4617ed6b5" translate="yes" xml:space="preserve">
          <source>IntSize is the size in bits of an int or uint value.</source>
          <target state="translated">IntSize es el tamaño en bits de un valor int o uint.</target>
        </trans-unit>
        <trans-unit id="7d0ad3a5fc2c5562d1a3d5edaf660d5681e2e7dd" translate="yes" xml:space="preserve">
          <source>IntSlice attaches the methods of Interface to []int, sorting in increasing order.</source>
          <target state="translated">IntSlice adjunta los métodos de Interface a []int,clasificando en orden creciente.</target>
        </trans-unit>
        <trans-unit id="259cdcc1487407a0effb8761c09ff465d822351b" translate="yes" xml:space="preserve">
          <source>IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.</source>
          <target state="translated">IntVar define un indicador int con un nombre específico,un valor predeterminado y una cadena de uso.El argumento p apunta a una variable int en la que almacenar el valor del indicador.</target>
        </trans-unit>
        <trans-unit id="e927198b4dfea79ca477c6ca320b7977e5f907d8" translate="yes" xml:space="preserve">
          <source>Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:</source>
          <target state="translated">Las banderas de números enteros aceptan 1234,0664,0x1234 y pueden ser negativos.Las banderas booleanas pueden serlo:</target>
        </trans-unit>
        <trans-unit id="d8d2cb0f1ba846253e8f8508e7b268037f761677" translate="yes" xml:space="preserve">
          <source>Integer limit values.</source>
          <target state="translated">Valores límite enteros.</target>
        </trans-unit>
        <trans-unit id="8e6549b1b15bddbc7e4ca51ecb54082a0c50f802" translate="yes" xml:space="preserve">
          <source>Integer:</source>
          <target state="translated">Integer:</target>
        </trans-unit>
        <trans-unit id="8ef45f34654a956038b7d2e46f7b980bceca0a1e" translate="yes" xml:space="preserve">
          <source>IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.</source>
          <target state="translated">IntegerType está aquí sólo para fines de documentación.Es un sustituto de cualquier tipo de entero:int,uint,int8 etc.</target>
        </trans-unit>
        <trans-unit id="5a289c0331a1e2ae1cddd468bdbd08515a751488" translate="yes" xml:space="preserve">
          <source>Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below).</source>
          <target state="translated">Los números enteros se transmiten de dos maneras:números enteros con signo de precisión arbitraria o números enteros sin signo de precisión arbitraria.No hay discriminación de int8,int16 etc.en el formato gob;sólo hay enteros con y sin signo.Como se describe a continuación,el emisor envía el valor en una codificación de longitud variable;el receptor acepta el valor y lo almacena en la variable de destino.Los números en coma flotante siempre se envían utilizando la precisión de 64 bits del IEEE-754 (véase más abajo).</target>
        </trans-unit>
        <trans-unit id="8a7e153030b338cdad7a41aa466f441af45e4a11" translate="yes" xml:space="preserve">
          <source>Interface represents a mapping between network interface name and index. It also represents network interface facility information.</source>
          <target state="translated">Interfaz representa un mapeo entre el nombre de la interfaz de la red y el índice.También representa la información de la instalación de la interfaz de la red.</target>
        </trans-unit>
        <trans-unit id="6da3607f32beaa93e64c1a37a2f36fbed997c327" translate="yes" xml:space="preserve">
          <source>Interface returns v's current value as an interface{}. It is equivalent to:</source>
          <target state="translated">Interfaz devuelve el valor actual de v como una interfaz{}.Es equivalente a:</target>
        </trans-unit>
        <trans-unit id="5ea5c3979b46b5a2713cc2d1786a81b1f8ec63c2" translate="yes" xml:space="preserve">
          <source>Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single &quot;interface&quot; type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.</source>
          <target state="translated">No se comprueba la compatibilidad de los tipos de interfaz;todos los tipos de interfaz se tratan,para su transmisión,como miembros de un único tipo de &quot;interfaz&quot;,análogo a int o []byte-en efecto,todos se tratan como interfaz{}.Los valores de interfaz se transmiten como una cadena que identifica el tipo concreto que se está enviando (un nombre que debe ser predefinido llamando a Register),seguido de un recuento de bytes de la longitud de los datos siguientes (de modo que el valor puede ser omitido si no puede ser almacenado),seguido de la codificación habitual del valor concreto (dinámico)almacenado en el valor de la interfaz.(Un valor de interfaz nulo se identifica por la cadena vacía y no transmite ningún valor).Al recibirlo,el decodificador verifica que el elemento concreto desempaquetado satisface la interfaz de la variable receptora.</target>
        </trans-unit>
        <trans-unit id="74b4a1f2cd95d6ac03afcfd27826497cd84b5ae7" translate="yes" xml:space="preserve">
          <source>Interface values are deeply equal if they hold deeply equal concrete values.</source>
          <target state="translated">Los valores de la interfaz son profundamente iguales si mantienen valores concretos profundamente iguales.</target>
        </trans-unit>
        <trans-unit id="09203e8778d59b495323467d890a95f5807f26bf" translate="yes" xml:space="preserve">
          <source>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.</source>
          <target state="translated">Los valores de la interfaz se codifican como el valor contenido en la interfaz.Un valor nulo de la interfaz se codifica como el valor nulo de JSON.</target>
        </trans-unit>
        <trans-unit id="360b50370b24932254b26c7af3e111445c188db0" translate="yes" xml:space="preserve">
          <source>InterfaceAddrs returns a list of the system's unicast interface addresses.</source>
          <target state="translated">InterfaceAddrs devuelve una lista de las direcciones de la interfaz unicast del sistema.</target>
        </trans-unit>
        <trans-unit id="9ce937dfbe60c7ef5a110a8b5806627105e626f1" translate="yes" xml:space="preserve">
          <source>InterfaceByIndex returns the interface specified by index.</source>
          <target state="translated">InterfaceByIndex devuelve la interfaz especificada por el índice.</target>
        </trans-unit>
        <trans-unit id="4245d4428eaccf8da6182470aec7d558cea28a53" translate="yes" xml:space="preserve">
          <source>InterfaceByName returns the interface specified by name.</source>
          <target state="translated">InterfaceByName devuelve la interfaz especificada por nombre.</target>
        </trans-unit>
        <trans-unit id="a63d53fbc696efd4a28db884d8645a21dcabe121" translate="yes" xml:space="preserve">
          <source>InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.</source>
          <target state="translated">InterfaceData devuelve el valor de la interfaz v como un par de uintptr.Entra en pánico si el tipo de v no es Interface.</target>
        </trans-unit>
        <trans-unit id="470a021de3b9df70021376a7834ee99ab5ab1f2e" translate="yes" xml:space="preserve">
          <source>Interfaces returns a list of the system's network interfaces.</source>
          <target state="translated">Interfaces devuelve una lista de las interfaces de red del sistema.</target>
        </trans-unit>
        <trans-unit id="faba134b29aa30840bd61a266830217b82a22fc4" translate="yes" xml:space="preserve">
          <source>InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce46964418231d76007ec656366d43d02eb959b8" translate="yes" xml:space="preserve">
          <source>InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60781d644f0c18cd790184e8cc93bbf04ff58fe" translate="yes" xml:space="preserve">
          <source>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.</source>
          <target state="translated">Intersect devuelve el mayor rectángulo contenido tanto por r como por s.Si los dos rectángulos no se superponen,entonces se devolverá el rectángulo cero.</target>
        </trans-unit>
        <trans-unit id="37b82affb5d88e1d235360ffb5b4876b9c358ef4" translate="yes" xml:space="preserve">
          <source>Intn</source>
          <target state="translated">Intn</target>
        </trans-unit>
        <trans-unit id="54d0c13534e6e00abbb2d04b4cb149c7d0ddea38" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn devuelve, como un int, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n) de la fuente predeterminada. Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="8f26feb5337a07fc6e35ec73e1c6b06a4a8f7c21" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn devuelve, como int, un n&amp;uacute;mero pseudoaleatorio no negativo en [0, n). Entra en p&amp;aacute;nico si n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b7f44e53c873fdc1db7cef7777af521f4a3b60c1" translate="yes" xml:space="preserve">
          <source>Ints</source>
          <target state="translated">Ints</target>
        </trans-unit>
        <trans-unit id="0d62fa520893beed143100d8873cdbc43cfe7428" translate="yes" xml:space="preserve">
          <source>Ints sorts a slice of ints in increasing order.</source>
          <target state="translated">Los ints clasifican una rebanada de ints en orden creciente.</target>
        </trans-unit>
        <trans-unit id="00382ca46ab71a1b23e2790f3cf0a66b6faa90df" translate="yes" xml:space="preserve">
          <source>IntsAreSorted</source>
          <target state="translated">IntsAreSorted</target>
        </trans-unit>
        <trans-unit id="d11bf023986ecfce333bd8a5477d90f31eb1db0a" translate="yes" xml:space="preserve">
          <source>IntsAreSorted tests whether a slice of ints is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted comprueba si un trozo de ints se clasifica en orden creciente.</target>
        </trans-unit>
        <trans-unit id="e6124bd83c6b099c79f4ac3379192d76121e3dfb" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z.</source>
          <target state="translated">Inv fija z a 1/x y devuelve z.</target>
        </trans-unit>
        <trans-unit id="496bc61a17df218d2461a9eddcde86416579b01a" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z. If x == 0, Inv panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f0200085fa1268ae261758bfb7dee5795a5704" translate="yes" xml:space="preserve">
          <source>InvalidByteError values describe errors resulting from an invalid byte in a hex string.</source>
          <target state="translated">Los valores de InvalidByteError describen los errores que resultan de un byte inválido en una cadena hexagonal.</target>
        </trans-unit>
        <trans-unit id="fc945344ffab3c8e0685a8f6f0b347b0e1b5f04c" translate="yes" xml:space="preserve">
          <source>Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">Invoke hace una llamada en JavaScript del valor v con los argumentos dados.Entra en pánico si v no es una función de JavaScript.Los argumentos se asignan a valores de JavaScript según la función ValueOf.</target>
        </trans-unit>
        <trans-unit id="a8bc24ce97a4c19ceec821a6c13e305d4cc7093a" translate="yes" xml:space="preserve">
          <source>Invoking the JavaScript function will synchronously call the Go function fn with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">Invocando la función de JavaScript llamará sincrónicamente a la función Go fn con el valor de la palabra clave &quot;this&quot; de JavaScript y los argumentos de la invocación.El valor de retorno de la invocación es el resultado de la función Go asignada a JavaScript según ValueOf.</target>
        </trans-unit>
        <trans-unit id="cf66655914f273806173ce98e001321c956d8544" translate="yes" xml:space="preserve">
          <source>Invoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079bc3b6a59d995ce86a46665da2718451aea120" translate="yes" xml:space="preserve">
          <source>Is</source>
          <target state="translated">Is</target>
        </trans-unit>
        <trans-unit id="b80342e2833069978eb2ebabac8e59ca1a3fbfc5" translate="yes" xml:space="preserve">
          <source>Is reports whether any error in err's chain matches target.</source>
          <target state="translated">es informar si algún error en la cadena de errores coincide con el objetivo.</target>
        </trans-unit>
        <trans-unit id="2dcad3f5fb898f44a28ca9cc90eb869f037180e6" translate="yes" xml:space="preserve">
          <source>Is reports whether the rune is in the specified table of ranges.</source>
          <target state="translated">es informar si la runa está en la tabla de rangos especificada.</target>
        </trans-unit>
        <trans-unit id="d895a1147fb9e99c093e2c8e3aa2a3a161a62599" translate="yes" xml:space="preserve">
          <source>Is unwraps its first argument sequentially looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:</source>
          <target state="translated">es desenvolver su primer argumento secuencialmente buscando un error que coincida con el segundo.Informa si encuentra una coincidencia.Debería ser usado en lugar de simples comprobaciones de igualdad:</target>
        </trans-unit>
        <trans-unit id="4240feb2e7eac03ab7672bf3d52cbd0df60964bf" translate="yes" xml:space="preserve">
          <source>IsAbs</source>
          <target state="translated">IsAbs</target>
        </trans-unit>
        <trans-unit id="6ba3e5deb5d3ce3b158c2019d9e58f42637cf610" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.</source>
          <target state="translated">IsAbs informa si la URL es absoluta.Absoluto significa que tiene un esquema no vacío.</target>
        </trans-unit>
        <trans-unit id="36a0d5f9413d1e35ae6366ef607edd836694bee0" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the path is absolute.</source>
          <target state="translated">IsAbs informa si el camino es absoluto.</target>
        </trans-unit>
        <trans-unit id="e1eaf7841a07f287f076c00cb20e44f9651ff13f" translate="yes" xml:space="preserve">
          <source>IsAlias reports whether obj is an alias name for a type.</source>
          <target state="translated">IsAlias informa si obj es un alias para un tipo.</target>
        </trans-unit>
        <trans-unit id="0e84022f347580b90f81c69d614f481de5c48849" translate="yes" xml:space="preserve">
          <source>IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.</source>
          <target state="translated">IsBuiltin informa si la expresión correspondiente denota una función incorporada (posiblemente entre paréntesis).</target>
        </trans-unit>
        <trans-unit id="c915051f076524ecaa2f5d332eb2bb4d2765eefa" translate="yes" xml:space="preserve">
          <source>IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named &quot;main&quot; are treated as commands.</source>
          <target state="translated">IsCommand informa si el paquete se considera un comando a instalar (no sólo una biblioteca).Los paquetes llamados &quot;main&quot; son tratados como comandos.</target>
        </trans-unit>
        <trans-unit id="2cd3abc2f41e5f98828e0ebaee47dfbcd10387ad" translate="yes" xml:space="preserve">
          <source>IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.</source>
          <target state="translated">IsControl informa si la runa es un personaje de control.La categoría C (Otro)Unicode incluye más puntos de código como los sustitutos;use Is(C,r)para comprobarlos.</target>
        </trans-unit>
        <trans-unit id="c746a0807bba76d32760f9142c884716d0699c51" translate="yes" xml:space="preserve">
          <source>IsDigit reports whether the rune is a decimal digit.</source>
          <target state="translated">IsDigit informa si la runa es un dígito decimal.</target>
        </trans-unit>
        <trans-unit id="3dc4a185454e26efa4716393eed4775f2e55fe7c" translate="yes" xml:space="preserve">
          <source>IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.</source>
          <target state="translated">IsDir informa si m describe un directorio.Es decir,comprueba si el bit de ModeDir está configurado en m.</target>
        </trans-unit>
        <trans-unit id="5fd80e2b1854e3452cd6bfd7234aa8fa8ddcdc63" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space.</source>
          <target state="translated">IsEmptyTree informa si este árbol (nodo)está vacío de todo menos del espacio.</target>
        </trans-unit>
        <trans-unit id="cd43f5281afe605e10c23fa5e5c73089248f9feb" translate="yes" xml:space="preserve">
          <source>IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.</source>
          <target state="translated">IsEnabled informa si el rastreo está habilitado.La información es sólo de carácter consultivo.El estado de la localización puede haber cambiado en el momento en que esta función vuelve.</target>
        </trans-unit>
        <trans-unit id="39e18e7e1b9d6fbe4b3f09d74593704f059a0c0a" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns if the PEM block is password encrypted.</source>
          <target state="translated">IsEncryptedPEMBlock regresa si el bloque PEM está encriptado con contraseña.</target>
        </trans-unit>
        <trans-unit id="bc66205543d841780222acbebc983e058e70415a" translate="yes" xml:space="preserve">
          <source>IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.</source>
          <target state="translated">IsExist devuelve un booleano que indica si se sabe que el error informa de que un archivo o directorio ya existe.Se satisface con ErrExist así como con algunos errores de llamada al sistema.</target>
        </trans-unit>
        <trans-unit id="fc56fa9983588228bd9fa3b0b5a7931ac3cb75f1" translate="yes" xml:space="preserve">
          <source>IsExported reports whether id starts with an upper-case letter.</source>
          <target state="translated">IsExported informa si la identificación comienza con una letra mayúscula.</target>
        </trans-unit>
        <trans-unit id="3c6d4e31e0d52ed1d2823481dfa21ed80c9b776d" translate="yes" xml:space="preserve">
          <source>IsExported reports whether name starts with an upper-case letter.</source>
          <target state="translated">IsExported informa si el nombre comienza con una letra mayúscula.</target>
        </trans-unit>
        <trans-unit id="504274dd55fc2a273ebc2bd501f5695303ffe229" translate="yes" xml:space="preserve">
          <source>IsField reports whether the variable is a struct field.</source>
          <target state="translated">IsField informa si la variable es un campo estructural.</target>
        </trans-unit>
        <trans-unit id="d9bdbeb50a8c37eb5d00e31069315d70d10359d6" translate="yes" xml:space="preserve">
          <source>IsGlobalUnicast reports whether ip is a global unicast address.</source>
          <target state="translated">IsGlobalUnicast informa si la IP es una dirección de unicast global.</target>
        </trans-unit>
        <trans-unit id="d72f8c1ccd0ac092185d981b6c61eacc3c121ef6" translate="yes" xml:space="preserve">
          <source>IsGraphic</source>
          <target state="translated">IsGraphic</target>
        </trans-unit>
        <trans-unit id="56022820abfd812a684373d7b12ff29c87996877" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.</source>
          <target state="translated">IsGraphic informa si la runa está definida como un gráfico por Unicode.Estos caracteres incluyen letras,marcas,números,puntuación,símbolos y espacios,de las categorías L,M,N,P,S,Zs.</target>
        </trans-unit>
        <trans-unit id="3bed5baca126f10003a7fc44f4e55808b330feda" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.</source>
          <target state="translated">IsGraphic informa si la runa está definida como un gráfico por Unicode.Estos caracteres incluyen letras,marcas,números,puntuación,símbolos y espacios,de las categorías L,M,N,P,S y Zs.</target>
        </trans-unit>
        <trans-unit id="93d167ded0e381246ad35c4922eb8c26e2a4fc55" translate="yes" xml:space="preserve">
          <source>IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.</source>
          <target state="translated">IsIdentifier informa si el nombre es un identificador Go,es decir,una cadena no vacía compuesta por letras,dígitos y guiones bajos,donde el primer carácter no es un dígito.Las palabras clave no son identificadores.</target>
        </trans-unit>
        <trans-unit id="679d30c5187a96f463dfbcdfb594ecc9983403ef" translate="yes" xml:space="preserve">
          <source>IsInf reports whether either real(x) or imag(x) is an infinity.</source>
          <target state="translated">IsInf informa si real(x)o imag(x)es un infinito.</target>
        </trans-unit>
        <trans-unit id="13dd75a92325ad267d0a2fa14c6cb50f24a9dd7b" translate="yes" xml:space="preserve">
          <source>IsInf reports whether f is an infinity, according to sign. If sign &amp;gt; 0, IsInf reports whether f is positive infinity. If sign &amp;lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.</source>
          <target state="translated">IsInf informa si f es infinito, seg&amp;uacute;n el signo. Si signo&amp;gt; 0, IsInf informa si f es infinito positivo. Si signo &amp;lt;0, IsInf informa si f es infinito negativo. Si sign == 0, IsInf informa si f es infinito.</target>
        </trans-unit>
        <trans-unit id="8e1783a22a02fb29f43965c4b4c975183d78e4dd" translate="yes" xml:space="preserve">
          <source>IsInf reports whether x is +Inf or -Inf.</source>
          <target state="translated">IsInf informa si x es +Inf o -Inf.</target>
        </trans-unit>
        <trans-unit id="1b05edd34484393d17b771d708b4b2dd276cb90e" translate="yes" xml:space="preserve">
          <source>IsInt reports whether the denominator of x is 1.</source>
          <target state="translated">IsInt informa si el denominador de x es 1.</target>
        </trans-unit>
        <trans-unit id="63c80063be9af3740f75431caecb4e56ba22484c" translate="yes" xml:space="preserve">
          <source>IsInt reports whether x is an integer. &amp;plusmn;Inf values are not integers.</source>
          <target state="translated">IsInt informa si x es un n&amp;uacute;mero entero. &amp;plusmn; Los valores Inf no son n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="00a1b79e443959417f450c9b16cf5f48a8929d0f" translate="yes" xml:space="preserve">
          <source>IsInt64 reports whether x can be represented as an int64.</source>
          <target state="translated">IsInt64 informa si x puede ser representada como un int64.</target>
        </trans-unit>
        <trans-unit id="ab97d0f94b18fe8f3b28313a45a877858cc4fa50" translate="yes" xml:space="preserve">
          <source>IsInterface reports whether typ is an interface type.</source>
          <target state="translated">IsInterface informa si el tipo es un tipo de interfaz.</target>
        </trans-unit>
        <trans-unit id="c6bdcbe107886851b028b532be31d52568400157" translate="yes" xml:space="preserve">
          <source>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.</source>
          <target state="translated">IsInterfaceLocalMulticast informa si la ip es una dirección multicast de interfaz local.</target>
        </trans-unit>
        <trans-unit id="203bcfa02f0ff2531137c0e97e09e91145ccf765" translate="yes" xml:space="preserve">
          <source>IsKeyword reports whether name is a Go keyword, such as &quot;func&quot; or &quot;return&quot;.</source>
          <target state="translated">IsKeyword informa si el nombre es una palabra clave de Go,como &quot;func&quot; o &quot;return&quot;.</target>
        </trans-unit>
        <trans-unit id="b1af467f9e4844b489b1e4d07d7f23c5a24e49f8" translate="yes" xml:space="preserve">
          <source>IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.</source>
          <target state="translated">IsKeyword devuelve verdadero para las fichas correspondientes a las palabras clave;devuelve falso de otra manera.</target>
        </trans-unit>
        <trans-unit id="9e659e799b643d193bc338fa878bc56e93c2043d" translate="yes" xml:space="preserve">
          <source>IsLetter reports whether the rune is a letter (category L).</source>
          <target state="translated">IsLetter informa si la runa es una letra (categoría L).</target>
        </trans-unit>
        <trans-unit id="796f0c2eac4ef075bdac49252f1a8a9437f7cb5a" translate="yes" xml:space="preserve">
          <source>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</source>
          <target state="translated">IsLinkLocalMulticast informa si la IP es una dirección multicast de enlace local.</target>
        </trans-unit>
        <trans-unit id="bb398472e4891951632d23a856db9700a4f1260f" translate="yes" xml:space="preserve">
          <source>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</source>
          <target state="translated">IsLinkLocalUnicast informa si la IP es una dirección unicast de enlace local.</target>
        </trans-unit>
        <trans-unit id="338823e775821fbbffd934b6dc8f8c7b06cf31f5" translate="yes" xml:space="preserve">
          <source>IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.</source>
          <target state="translated">IsLiteral devuelve verdadero para las fichas correspondientes a identificadores y literales de tipo básico;devuelve falso en caso contrario.</target>
        </trans-unit>
        <trans-unit id="a302aa5062a5a2939f950e77a3b1bd2cffbbb134" translate="yes" xml:space="preserve">
          <source>IsLocalImport reports whether the import path is a local import path, like &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;, or &quot;../foo&quot;.</source>
          <target state="translated">IsLocalImport informa si la ruta de importación es una ruta de importación local,como &quot;.&quot;,&quot;..&quot;,&quot;./foo&quot;,o &quot;../foo&quot;.</target>
        </trans-unit>
        <trans-unit id="a279a0dd486da312eb888a933fcd3c106d5ddf1b" translate="yes" xml:space="preserve">
          <source>IsLoopback reports whether ip is a loopback address.</source>
          <target state="translated">IsLoopback informa si ip es una dirección loopback.</target>
        </trans-unit>
        <trans-unit id="4c6115a445a46684f9b4821abab1454dcf00a510" translate="yes" xml:space="preserve">
          <source>IsLower reports whether the rune is a lower case letter.</source>
          <target state="translated">IsLower informa si la runa es una letra minúscula.</target>
        </trans-unit>
        <trans-unit id="e316f3e3a4a4a943e13f969fe03fe3e6888a42f0" translate="yes" xml:space="preserve">
          <source>IsMark reports whether the rune is a mark character (category M).</source>
          <target state="translated">IsMark informa si la runa es un personaje de marca (categoría M).</target>
        </trans-unit>
        <trans-unit id="e919a8a1e5af711657ece2a09a282e053c84e876" translate="yes" xml:space="preserve">
          <source>IsMulticast reports whether ip is a multicast address.</source>
          <target state="translated">IsMulticast informa si la ip es una dirección multicast.</target>
        </trans-unit>
        <trans-unit id="0d71475a6ac8cde45586a2e1ee4e9f1a73195c46" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.</source>
          <target state="translated">IsNaN informa si real(x)o imag(x)es NaN y ninguno de los dos es un infinito.</target>
        </trans-unit>
        <trans-unit id="51cb1fb375010c76e1d272e937551b9aa294ed29" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether f is an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">IsNaN informa si f es un valor IEEE 754 &amp;ldquo;no es un n&amp;uacute;mero&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="e6682a80abf1bf240c434de0a86adc44d2b4fa9e" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether v is the JavaScript value &quot;NaN&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a70a6c8c78f197d95d9931060aaaff0e1ad7ace" translate="yes" xml:space="preserve">
          <source>IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</source>
          <target state="translated">IsNil informa si su argumento v es nulo.El argumento debe ser un valor de chan,func,interface,mapa,puntero o rebanada;si no lo es,IsNil entra en pánico.Observe que IsNil no siempre equivale a una comparación regular con nil en Go.Por ejemplo,si v se creó llamando al Valor de con una variable de interfaz no inicializada i,i==nil será verdadero pero v.IsNil entrará en pánico ya que v será el Valor cero.</target>
        </trans-unit>
        <trans-unit id="d1cbf137d274a495776ae13213f6abf32b87d01c" translate="yes" xml:space="preserve">
          <source>IsNil reports whether the corresponding expression denotes the predeclared value nil.</source>
          <target state="translated">IsNil informa si la expresión correspondiente denota el valor predeclarado nulo.</target>
        </trans-unit>
        <trans-unit id="299ff42ffbb3020ccb3e165c3f47990aa016cf3b" translate="yes" xml:space="preserve">
          <source>IsNotExist</source>
          <target state="translated">IsNotExist</target>
        </trans-unit>
        <trans-unit id="03c20e37da945e513d60a4c872afa073a5099855" translate="yes" xml:space="preserve">
          <source>IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</source>
          <target state="translated">IsNotExist devuelve un booleano que indica si se sabe que el error informa de que un archivo o directorio no existe.Se satisface con ErrNotExist así como con algunos errores de llamada al sistema.</target>
        </trans-unit>
        <trans-unit id="05e6aafd3bbc506bf83192365d5b5ee27918dfa7" translate="yes" xml:space="preserve">
          <source>IsNull reports whether v is the JavaScript value &quot;null&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c323038256b2a2953181c6a475ccd896ada404" translate="yes" xml:space="preserve">
          <source>IsNumber reports whether the rune is a number (category N).</source>
          <target state="translated">IsNumber informa si la runa es un número (categoría N).</target>
        </trans-unit>
        <trans-unit id="245475f668f23bbed41324e2de1b4948cc531ddc" translate="yes" xml:space="preserve">
          <source>IsOneOf reports whether the rune is a member of one of the ranges. The function &quot;In&quot; provides a nicer signature and should be used in preference to IsOneOf.</source>
          <target state="translated">IsOneOf informa si la runa es miembro de uno de los rangos.La función &quot;In&quot; proporciona una firma más agradable y debe utilizarse con preferencia a IsOneOf.</target>
        </trans-unit>
        <trans-unit id="a20bd2f5568b340e7370b04b798bc3f83596bcce" translate="yes" xml:space="preserve">
          <source>IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.</source>
          <target state="translated">IsOperador devuelve verdadero para las fichas correspondientes a los operadores y delimitadores;devuelve falso en caso contrario.</target>
        </trans-unit>
        <trans-unit id="73c5624da9ca6fbf3e420dbf86786a852cc89a14" translate="yes" xml:space="preserve">
          <source>IsPathSeparator reports whether c is a directory separator character.</source>
          <target state="translated">IsPathSeparator informa si c es un carácter separador de directorios.</target>
        </trans-unit>
        <trans-unit id="8bd40ac27999a79bc28cf90f839e43d8f9372279" translate="yes" xml:space="preserve">
          <source>IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.</source>
          <target state="translated">IsPermission devuelve un booleano que indica si se sabe que el error informa de que el permiso está denegado.Se satisface con ErrPermission así como con algunos errores del sistema de llamada.</target>
        </trans-unit>
        <trans-unit id="e48f3df15b49da83d51099ad5b3eb8bbfd8edc75" translate="yes" xml:space="preserve">
          <source>IsPredeclared reports whether s is a predeclared identifier.</source>
          <target state="translated">IsPredeclarado informa si s es un identificador predeclarado.</target>
        </trans-unit>
        <trans-unit id="36ebaf4d189aca534d273d48d5ddeec782d7bed9" translate="yes" xml:space="preserve">
          <source>IsPrint</source>
          <target state="translated">IsPrint</target>
        </trans-unit>
        <trans-unit id="9798b863454466bfa901e359486dca8125aebd8e" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.</source>
          <target state="translated">IsPrint informa si la runa está definida como imprimible por Go,con la misma definición que unicode.IsPrint:letras,números,puntuación,símbolos y espacio ASCII.</target>
        </trans-unit>
        <trans-unit id="98481c27a5fae0a861fa7de3b6778c4d86a82e18" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.</source>
          <target state="translated">IsPrint informa si la runa está definida como imprimible por Go.Estos caracteres incluyen letras,marcas,números,puntuación,símbolos y el espacio ASCII,de las categorías L,M,N,P,S y el espacio ASCII.Esta categorización es la misma que la de IsGraphic,excepto que el único carácter de espacio es el espacio ASCII,U+0020.</target>
        </trans-unit>
        <trans-unit id="8d669f2d873d45ac65ae33ba5fc527f66e56a570" translate="yes" xml:space="preserve">
          <source>IsPunct reports whether the rune is a Unicode punctuation character (category P).</source>
          <target state="translated">IsPunct informa si la runa es un carácter de puntuación de Unicode (categoría P).</target>
        </trans-unit>
        <trans-unit id="09f51db22f739274d216b281ce628857122cde77" translate="yes" xml:space="preserve">
          <source>IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.</source>
          <target state="translated">IsRegular informa si m describe un archivo regular.Es decir,comprueba que no se han fijado bits de tipo de modo.</target>
        </trans-unit>
        <trans-unit id="7aa02fb0658d675b5c73f5d774f227af20e5eda3" translate="yes" xml:space="preserve">
          <source>IsScanValue is equivalent to IsValue. It exists for compatibility.</source>
          <target state="translated">IsScanValue es equivalente a IsValue.Existe para la compatibilidad.</target>
        </trans-unit>
        <trans-unit id="02fd007fd97349a8b2fafa3e48b3fe7f504ea24c" translate="yes" xml:space="preserve">
          <source>IsSorted reports whether data is sorted.</source>
          <target state="translated">IsSorted informa si los datos están ordenados.</target>
        </trans-unit>
        <trans-unit id="514d21d401add5f58b109e05d3a8a2615962f831" translate="yes" xml:space="preserve">
          <source>IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is</source>
          <target state="translated">IsSpace informa si la runa es un carácter espacial como se define en la propiedad Espacio Blanco de Unicode;en el espacio Latin-1 esto es</target>
        </trans-unit>
        <trans-unit id="b8364c32e39bc01deb2db29de008f790b53e0511" translate="yes" xml:space="preserve">
          <source>IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.</source>
          <target state="translated">IsSurrogate informa si el punto de código Unicode especificado puede aparecer en un par de sustitutos.</target>
        </trans-unit>
        <trans-unit id="94ff69a73ee80e68160fc5d14463531f326feb1a" translate="yes" xml:space="preserve">
          <source>IsSymbol reports whether the rune is a symbolic character.</source>
          <target state="translated">IsSymbol informa si la runa es un personaje simbólico.</target>
        </trans-unit>
        <trans-unit id="80e8a9046c478caac6544a67a67898f6f56d102d" translate="yes" xml:space="preserve">
          <source>IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.</source>
          <target state="translated">IsTimeout devuelve un booleano que indica si se sabe que el error informa de que se ha producido un timeout.</target>
        </trans-unit>
        <trans-unit id="5dae031aae8f79fce18391198feff6e45790996f" translate="yes" xml:space="preserve">
          <source>IsTitle reports whether the rune is a title case letter.</source>
          <target state="translated">IsTitle informa si la runa es una letra de caso de título.</target>
        </trans-unit>
        <trans-unit id="47cdd782e568065cbc896003cc3080e6fa343e64" translate="yes" xml:space="preserve">
          <source>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.</source>
          <target state="translated">IsTrue informa si el valor es &quot;verdadero&quot;,en el sentido de no el cero de su tipo,y si el valor tiene un valor de verdad significativo.Esta es la definición de verdad usada por if y otras acciones similares.</target>
        </trans-unit>
        <trans-unit id="f386d0c906e9366cb699b0ae4451bc9d70023dc4" translate="yes" xml:space="preserve">
          <source>IsType reports whether the corresponding expression specifies a type.</source>
          <target state="translated">IsType informa si la expresión correspondiente especifica un tipo.</target>
        </trans-unit>
        <trans-unit id="bd72caa363338547d5699b96c1b4ac80c8cd24c1" translate="yes" xml:space="preserve">
          <source>IsUint64 reports whether x can be represented as a uint64.</source>
          <target state="translated">IsUint64 informa si x puede ser representada como un uint64.</target>
        </trans-unit>
        <trans-unit id="85a3cd11f8d331b3763c1e34e0ce1cfca9c37e79" translate="yes" xml:space="preserve">
          <source>IsUndefined reports whether v is the JavaScript value &quot;undefined&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3721da2086f5e9441475d80b1c204e06489512" translate="yes" xml:space="preserve">
          <source>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.</source>
          <target state="translated">IsUnspecified informa si ip es una dirección no especificada,ya sea la dirección IPv4 &quot;0.0.0.0&quot; o la dirección IPv6 &quot;::&quot;.</target>
        </trans-unit>
        <trans-unit id="b72d29b8198db403c8169f5f00434fb729acb678" translate="yes" xml:space="preserve">
          <source>IsUpper reports whether the rune is an upper case letter.</source>
          <target state="translated">IsUpper informa si la runa es una letra mayúscula.</target>
        </trans-unit>
        <trans-unit id="ecc382ac4eeae90631c4ff786a142c8cd4a2a1e3" translate="yes" xml:space="preserve">
          <source>IsValid reports whether the position is valid.</source>
          <target state="translated">IsValid informa si la posición es válida.</target>
        </trans-unit>
        <trans-unit id="fa9386e1dba484fd3efd4626c53284c1fe827e1b" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4d65bab951e443a5b5a6cb70b5527aa329d397" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid informa si v representa un valor.Devuelve falso si v es el valor cero.Si IsValid devuelve false,todos los demás métodos excepto el pánico a las cadenas.La mayoría de las funciones y métodos nunca devuelven un valor inválido.Si lo hace,su documentación establece las condiciones explícitamente.</target>
        </trans-unit>
        <trans-unit id="55d30ff7d3d863a32468776759178dbe0451ccce" translate="yes" xml:space="preserve">
          <source>IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.</source>
          <target state="translated">IsValue informa si la expresión correspondiente es un valor.Los construidos no se consideran valores.Los valores constantes tienen un valor no nulo.</target>
        </trans-unit>
        <trans-unit id="9d7a5d3a7652824e4f9b549a7d5a262a10ef59c5" translate="yes" xml:space="preserve">
          <source>IsValue reports whether v is a valid Value parameter type.</source>
          <target state="translated">IsValue informa si v es un tipo de parámetro de valor válido.</target>
        </trans-unit>
        <trans-unit id="65e1a871482dad54f08e17dd72762a3fd2f75d74" translate="yes" xml:space="preserve">
          <source>IsVoid reports whether the corresponding expression is a function call without results.</source>
          <target state="translated">IsVoid informa si la expresión correspondiente es una llamada de función sin resultados.</target>
        </trans-unit>
        <trans-unit id="297c16f9ae029663b610c3b616363007a062b053" translate="yes" xml:space="preserve">
          <source>IsWordChar reports whether r is consider a &amp;ldquo;word character&amp;rdquo; during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</source>
          <target state="translated">IsWordChar informa si r se considera un &quot;car&amp;aacute;cter de palabra&quot; durante la evaluaci&amp;oacute;n de las aserciones \ by \ B de ancho cero. Estas afirmaciones son solo ASCII: los caracteres de la palabra son [A-Za-z0-9_].</target>
        </trans-unit>
        <trans-unit id="5f0397c5af2b47c485a6cac89d344b49d39148e5" translate="yes" xml:space="preserve">
          <source>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.</source>
          <target state="translated">IsZero informa si t representa el instante de tiempo cero,1 de enero,año 1,00:00:00 UTC.</target>
        </trans-unit>
        <trans-unit id="14b29f8979f8b38e486b8c2fc265fcec75315a1b" translate="yes" xml:space="preserve">
          <source>IsZero reports whether v is the zero value for its type. It panics if the argument is invalid.</source>
          <target state="translated">IsZero informa si v es el valor cero para su tipo.Se asusta si el argumento es inválido.</target>
        </trans-unit>
        <trans-unit id="2e5ba7b50d53dc66de9ac76f94ae84e19ac42a4e" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level stored in TxOptions.</source>
          <target state="translated">IsolationLevel es el nivel de aislamiento de la transacción almacenado en TxOptions.</target>
        </trans-unit>
        <trans-unit id="00b8885e61c34531225b38e32ae41a763eb82a05" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level used in TxOptions.</source>
          <target state="translated">IsolationLevel es el nivel de aislamiento de la transacción utilizado en TxOptions.</target>
        </trans-unit>
        <trans-unit id="d76fb5eb8c221bc52330dc2413a54b325f8af681" translate="yes" xml:space="preserve">
          <source>It does nothing if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">No hace nada si el esquema de la URL no es HTTP o HTTPS.</target>
        </trans-unit>
        <trans-unit id="730fc66fc7c6f8658abbd279912d4debd6897a14" translate="yes" xml:space="preserve">
          <source>It is allowed but not required for the caller to hold c.L during the call.</source>
          <target state="translated">Se permite pero no se requiere que la persona que llama retenga C.L.durante la llamada.</target>
        </trans-unit>
        <trans-unit id="64b18effbf60d196d9c9972b0f4752ad49d90515" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.</source>
          <target state="translated">Se permite llamar a Notify varias veces con diferentes canales y las mismas señales:cada canal recibe copias de las señales entrantes de forma independiente.</target>
        </trans-unit>
        <trans-unit id="2b72f5a15cc86252895b6a5820ed7c36974cccb2" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop.</source>
          <target state="translated">Se permite llamar a Notificar varias veces con el mismo canal:cada llamada expande el conjunto de señales enviadas a ese canal.La única manera de eliminar las señales del conjunto es llamar a Stop.</target>
        </trans-unit>
        <trans-unit id="64b9ab50226fefd57abe4e106fe4fbde6d348569" translate="yes" xml:space="preserve">
          <source>It is defined in RFC 1950:</source>
          <target state="translated">Se define en el RFC 1950:</target>
        </trans-unit>
        <trans-unit id="3527f9b32341885623b87c38f5f98392bdedd8dc" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">Es equivalente a SplitAfterN con una cuenta de -1.</target>
        </trans-unit>
        <trans-unit id="dbac3455f5dcff27b15907e612c36dc6d6627118" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">Es equivalente a SplitN con una cuenta de -1.</target>
        </trans-unit>
        <trans-unit id="9bc89c86db3c02e15ec65887cfcf0cc312b36a24" translate="yes" xml:space="preserve">
          <source>It is not associated with any particular color profile.</source>
          <target state="translated">No está asociado con ningún perfil de color en particular.</target>
        </trans-unit>
        <trans-unit id="8b9cf269b7a066efe335dc4941105afdd2791a76" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.</source>
          <target state="translated">No se garantiza que se ejecute un finalizador para los objetos asignados en los inicializadores para las variables de nivel de paquete.Tales objetos pueden ser asignados por el enlazador,no por la pila.</target>
        </trans-unit>
        <trans-unit id="185afc47d5312f1df75d7c2e1fd8c497c93c1bee" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run if the size of *obj is zero bytes.</source>
          <target state="translated">No se garantiza que un finalizador funcione si el tamaño del *objeto es de cero bytes.</target>
        </trans-unit>
        <trans-unit id="e276973efe0e06473fcbf2184470a55ce905f9ea" translate="yes" xml:space="preserve">
          <source>It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines.</source>
          <target state="translated">Es raro cerrar una DB,ya que la manija de la DB está pensada para ser de larga vida y compartida entre muchos goroutines.</target>
        </trans-unit>
        <trans-unit id="9a7d91a6cfdd5d25c7a9aebf66715a0621fd64e1" translate="yes" xml:space="preserve">
          <source>It is safe to call Dialer's methods concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c70c7692f708ab80a79d217ba3b943c3b63874" translate="yes" xml:space="preserve">
          <source>It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.</source>
          <target state="translated">Es seguro llamar a Lectura y Escritura en paralelo con cada uno o con Close.Las llamadas paralelas a Lectura y las llamadas paralelas a Escritura también son seguras:las llamadas individuales serán cerradas secuencialmente.</target>
        </trans-unit>
        <trans-unit id="8e87bdde62b3a11cc618f6eef7d1ef7e95ea027e" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function:</source>
          <target state="translated">A veces es necesario que un programa de pruebas haga un montaje o desmontaje extra antes o después de la prueba.También es a veces necesario que una prueba controle qué código se ejecuta en el hilo principal.Para apoyar estos y otros casos,si un archivo de prueba contiene una función:</target>
        </trans-unit>
        <trans-unit id="c4c640b2d1c13408fc0addbe9ca9b3e33c914d4c" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Reader when done.</source>
          <target state="translated">Es responsabilidad de la persona que llama llamar a Close on the Reader cuando termine.</target>
        </trans-unit>
        <trans-unit id="986480998eaebed4b6a54647e1482613d046d84f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.</source>
          <target state="translated">Es responsabilidad del llamante llamar a Close en el Escritor cuando termine.Las escrituras pueden ser almacenadas en un buffer y no ser eliminadas hasta el cierre.</target>
        </trans-unit>
        <trans-unit id="5d5e9d1ff14ea8de0b89e8865f3f584d482a0afe" translate="yes" xml:space="preserve">
          <source>It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">Es útil sobre todo en los protocolos de red comprimidos,para asegurar que un lector remoto tenga suficientes datos para reconstruir un paquete.La descarga no vuelve hasta que los datos han sido escritos.Si el escritor subyacente devuelve un error,Flush devuelve ese error.</target>
        </trans-unit>
        <trans-unit id="31cc99464ed62136a451655119e840afa7451b83" translate="yes" xml:space="preserve">
          <source>It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use &amp;amp;^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.</source>
          <target state="translated">Es v&amp;aacute;lido tanto sumar como restar compensaciones de un puntero de esta forma. Tambi&amp;eacute;n es v&amp;aacute;lido usar &amp;amp; ^ para redondear punteros, generalmente para alineaci&amp;oacute;n. En todos los casos, el resultado debe seguir apuntando al objeto asignado original.</target>
        </trans-unit>
        <trans-unit id="dd1e16d418b70f8a4bcbc355b1da37369ffe8113" translate="yes" xml:space="preserve">
          <source>It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap.</source>
          <target state="translated">Hace una llamada a datos.Len para determinar n,O(n*log(n))llamadas a datos.Less y O(n*log(n)*log(n))llamadas a datos.Swap.</target>
        </trans-unit>
        <trans-unit id="49a3b03dcb3864c71030445c5ba5bfe2611711d2" translate="yes" xml:space="preserve">
          <source>It may also be received into any of these:</source>
          <target state="translated">También puede ser recibido en cualquiera de estos:</target>
        </trans-unit>
        <trans-unit id="7b88fc3e61debf0d0f1a1581e71a0996edf539a5" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(b) * count) overflows.</source>
          <target state="translated">Entra en pánico si el recuento es negativo o si el resultado de (len(b)*recuento)se desborda.</target>
        </trans-unit>
        <trans-unit id="8b61a1a4bb411ee036d7d3cc509678ace33cef83" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(s) * count) overflows.</source>
          <target state="translated">Entra en pánico si el recuento es negativo o si el resultado de (lente(s)*recuento)se desborda.</target>
        </trans-unit>
        <trans-unit id="652db58383317d0338f369bbd62022ed3ab07600" translate="yes" xml:space="preserve">
          <source>It panics if the Value was obtained by accessing unexported struct fields.</source>
          <target state="translated">Entra en pánico si el valor se obtuvo accediendo a campos estructurales no exportados.</target>
        </trans-unit>
        <trans-unit id="564d342d70ea92defe3199a234b7ca21ece54f95" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PrivateKey, a *ecdsa.PrivateKey, or a ed25519.PrivateKey. More types might be supported in the future.</source>
          <target state="translated">Devuelve una *rsa.PrivateKey,una *ecdsa.PrivateKey,o una ed25519.PrivateKey.Más tipos podrían ser soportados en el futuro.</target>
        </trans-unit>
        <trans-unit id="9f11d9cd546ed2abe8e697fa6f8bbdc2a3d2e5ef" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey, or ed25519.PublicKey. More types might be supported in the future.</source>
          <target state="translated">Devuelve una *rsa.PublicKey,*dsa.PublicKey,*ecdsa.PublicKey,o ed25519.PublicKey.Más tipos podrían ser soportados en el futuro.</target>
        </trans-unit>
        <trans-unit id="e5010d434ca33dd92d7a44910817533939048059" translate="yes" xml:space="preserve">
          <source>It returns an empty slice if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">Devuelve una parte vacía si el esquema de la URL no es HTTP o HTTPS.</target>
        </trans-unit>
        <trans-unit id="2b565edf53edd5e13295b4a395aad926eda82327" translate="yes" xml:space="preserve">
          <source>It returns an error if t has already been executed.</source>
          <target state="translated">Devuelve un error si t ya ha sido ejecutado.</target>
        </trans-unit>
        <trans-unit id="a56353db7fb203c22e0bfd117b292abd05c5de94" translate="yes" xml:space="preserve">
          <source>It returns an error if t or any associated template has already been executed.</source>
          <target state="translated">Devuelve un error si t o cualquier plantilla asociada ya ha sido ejecutada.</target>
        </trans-unit>
        <trans-unit id="e63a57b040488970eacecfd2272a9deb62e2be3e" translate="yes" xml:space="preserve">
          <source>It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form &quot;Type.Method&quot;, where Type is the receiver's concrete type.</source>
          <target state="translated">Devuelve un error si el receptor no es un tipo exportado o no tiene métodos adecuados.También registra el error utilizando el registro de paquetes.El cliente accede a cada método utilizando una cadena del formulario &quot;Type.Method&quot;,donde Type es el tipo concreto del receptor.</target>
        </trans-unit>
        <trans-unit id="4dde580c3be3f14ce5fe15d368688767eafb64f5" translate="yes" xml:space="preserve">
          <source>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.</source>
          <target state="translated">Devuelve la dirección IP y la red implícita en la longitud del IP y del prefijo.Por ejemplo,ParseCIDR(&quot;192.0.2.1/24&quot;)devuelve la dirección IP 192.0.2.1 y la red 192.0.2.0/24.</target>
        </trans-unit>
        <trans-unit id="0b053a1afdc2a3fb959c27dc82bd3e04e4d3478f" translate="yes" xml:space="preserve">
          <source>It sets only the Path and Args in the returned structure.</source>
          <target state="translated">Sólo establece el camino y los arcos en la estructura devuelta.</target>
        </trans-unit>
        <trans-unit id="810599e9d82ed867f48c9be47863d26eaa5d33f3" translate="yes" xml:space="preserve">
          <source>It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:</source>
          <target state="translated">Establece z al valor (posiblemente redondeado)del correspondiente valor de punto flotante,y devuelve z,la base real b,y un error de error,si lo hay.La cadena entera (no sólo un prefijo)debe ser consumida para el éxito.Si la precisión de z es 0,se cambia a 64 antes de que el redondeo tenga efecto.El número debe ser de la forma:</target>
        </trans-unit>
        <trans-unit id="4b0e67dd55e6df4a3c7132865324312cab9fb6a8" translate="yes" xml:space="preserve">
          <source>It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the RWMutex type.</source>
          <target state="translated">No debe utilizarse para el bloqueo de lectura recursivo;una llamada de bloqueo excluye a los nuevos lectores de la adquisición del bloqueo.Vea la documentación sobre el tipo RWMutex.</target>
        </trans-unit>
        <trans-unit id="ff62c59d333b6b7669c7f0b6568819a5dff0f396" translate="yes" xml:space="preserve">
          <source>Iterate calls f for the files in the file set in the order they were added until f returns false.</source>
          <target state="translated">Iterar las llamadas f de los archivos en el orden en que fueron añadidos hasta que la f devuelva false.</target>
        </trans-unit>
        <trans-unit id="380c384a3bc4560682612879309496ebdde5cfd3" translate="yes" xml:space="preserve">
          <source>Itoa</source>
          <target state="translated">Itoa</target>
        </trans-unit>
        <trans-unit id="aac52064292950f4b3f0337ac6b1ebbc54bd40af" translate="yes" xml:space="preserve">
          <source>Itoa is equivalent to FormatInt(int64(i), 10).</source>
          <target state="translated">Itoa equivale a FormatInt(int64(i),10).</target>
        </trans-unit>
        <trans-unit id="2d1e23b725be8aad6b338015ecefbc3479bf797c" translate="yes" xml:space="preserve">
          <source>J0 returns the order-zero Bessel function of the first kind.</source>
          <target state="translated">J0 devuelve la función de Bessel de orden cero de la primera clase.</target>
        </trans-unit>
        <trans-unit id="9b402d642da0f20c362bc1bcf6bfd3cb9482a1ee" translate="yes" xml:space="preserve">
          <source>J1 returns the order-one Bessel function of the first kind.</source>
          <target state="translated">J1 devuelve el orden-una función de Bessel de la primera clase.</target>
        </trans-unit>
        <trans-unit id="0a183d189787e52c86d1ff01f1f68fc26c61737d" translate="yes" xml:space="preserve">
          <source>JPEG is defined in ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt;.</source>
          <target state="translated">JPEG se define en ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd49e7822aebcb558798ee4f0f590d63e8da7cc1" translate="yes" xml:space="preserve">
          <source>JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.</source>
          <target state="translated">JPEG,VP8,la familia MPEG y otros códecs usan este modelo de color.Tales códecs a menudo usan los términos YUV y Y'CbCr indistintamente,pero estrictamente hablando,el término YUV se aplica sólo a las señales de vídeo analógicas,y Y' (luma)es Y (luminancia)después de aplicar la corrección gamma.</target>
        </trans-unit>
        <trans-unit id="922b9fe605d8db0c621e15bc38a3c570a5ce91fd" translate="yes" xml:space="preserve">
          <source>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like &quot;{ foo: bar() }\n['foo']()&quot;, which is both a valid Expression and a valid Program with a very different meaning.</source>
          <target state="translated">JS encapsula una Expresión de EcmaScript5 conocida y segura,por ejemplo,`(x+y*z())`.Los autores de las plantillas son responsables de asegurar que las expresiones mecanografiadas no rompan la precedencia pretendida y que no haya ambigüedad de declaración/expresión como cuando se pasa una expresión como &quot;{foo:bar()}\n['foo']()&quot;,que es tanto una Expresión válida como un Programa válido con un significado muy diferente.</target>
        </trans-unit>
        <trans-unit id="26cbdc0eb97f168871a53f6c7842d5c136b64697" translate="yes" xml:space="preserve">
          <source>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</source>
          <target state="translated">JSEscape escribe a w el equivalente en JavaScript de los datos de texto plano b.</target>
        </trans-unit>
        <trans-unit id="bd3faa1039cdd3fc555ce394120927a3ffbfdfd6" translate="yes" xml:space="preserve">
          <source>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</source>
          <target state="translated">JSEscapeString devuelve el equivalente en JavaScript de los datos en texto plano.</target>
        </trans-unit>
        <trans-unit id="0657ce896f15a5407782a5a0cb9e814dbb9243d9" translate="yes" xml:space="preserve">
          <source>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.</source>
          <target state="translated">JSEscaper devuelve el equivalente en JavaScript de la representación textual de sus argumentos.</target>
        </trans-unit>
        <trans-unit id="69a10a5b123daa69a949ffea8479901f451d66ee" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd554b8109b0533f9a7bb62634a7c4956ea4b3a" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</source>
          <target state="translated">JSON no puede representar estructuras de datos cíclicos y Marshal no las maneja.Pasar las estructuras cíclicas a Marshal resultará en una recursividad infinita.</target>
        </trans-unit>
        <trans-unit id="16c95a3afe47aa9594cf8938af617a9901298497" translate="yes" xml:space="preserve">
          <source>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:</source>
          <target state="translated">La JSStr encapsula una secuencia de caracteres destinados a ser incrustados entre comillas en una expresión de JavaScript.La cadena debe coincidir con una serie de StringCharacters:</target>
        </trans-unit>
        <trans-unit id="7ee415a9e606531fbf364133b0de844b1078510a" translate="yes" xml:space="preserve">
          <source>JSValue implements Wrapper interface.</source>
          <target state="translated">JSValue implementa la interfaz de Wrapper.</target>
        </trans-unit>
        <trans-unit id="b800dfb6df40a19873f9dc7ec5927a93b2cfe769" translate="yes" xml:space="preserve">
          <source>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.</source>
          <target state="translated">Jacobi devuelve el símbolo Jacobi (x/y),ya sea +1,-1,o 0.El argumento y debe ser un número entero impar.</target>
        </trans-unit>
        <trans-unit id="173acb21066734464813cc933e35bf49fb5074d7" translate="yes" xml:space="preserve">
          <source>Jar implements the http.CookieJar interface from the net/http package.</source>
          <target state="translated">Jar implementa la interfaz http.CookieJar del paquete net/http.</target>
        </trans-unit>
        <trans-unit id="0a5f33ea0d4d273fa523aad519e0bd5003a1f2a2" translate="yes" xml:space="preserve">
          <source>Jn returns the order-n Bessel function of the first kind.</source>
          <target state="translated">Jn devuelve el orden:la función de Bessel de la primera clase.</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="b160ff3535de402a5c7113020ea1b5b48c93aaa3" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join concatena los elementos de a para crear una sola cadena.El separador de la cadena se coloca entre los elementos de la cadena resultante.</target>
        </trans-unit>
        <trans-unit id="eb1bffc0eefb099fa476568b7bfaeb338665eac0" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6badcc1917f6227c17c3b5a3bb3a7ab0dac561dd" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.</source>
          <target state="translated">La unión concatena los elementos de s para crear un nuevo trozo de byte.El separador sep se coloca entre los elementos de la rebanada resultante.</target>
        </trans-unit>
        <trans-unit id="aa67e6029ba49c3f992d57c2d0ab202a04ec1080" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.</source>
          <target state="translated">Join une cualquier número de elementos del camino en un solo camino,añadiendo un Separador si es necesario.Join llama a Clean en el resultado;en particular,todas las cadenas vacías son ignoradas.En Windows,el resultado es una ruta UNC si y sólo si el primer elemento de la ruta es una ruta UNC.</target>
        </trans-unit>
        <trans-unit id="945c23e567973c47ce3562fa8cf5ef5f3d5533ea" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.</source>
          <target state="translated">Join une cualquier número de elementos del camino en un solo camino,añadiendo una barra de separación si es necesario.El resultado es Limpio;en particular,todas las cadenas vacías son ignoradas.</target>
        </trans-unit>
        <trans-unit id="a3a49c8f80c8e5d91256710add83dcb9a3a81e62" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with an OS specific Separator. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2d5664268a2d39abd731e2e8cd12f3a113ecce" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f25f02ad0ad7ded23a0d09d8ea462e385b6164c" translate="yes" xml:space="preserve">
          <source>JoinHostPort combines host and port into a network address of the form &quot;host:port&quot;. If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.</source>
          <target state="translated">JoinHostPort combina el host y el puerto en una dirección de red de la forma &quot;host:port&quot;.Si el host contiene dos puntos,como se encuentra en las direcciones IPv6 literales,entonces JoinHostPort devuelve &quot;[host]:port&quot;.</target>
        </trans-unit>
        <trans-unit id="0cf4b24840f4e27435d8326ea5a70f3fed6a3f6e" translate="yes" xml:space="preserve">
          <source>KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.</source>
          <target state="translated">KeepAlive marca su argumento como actualmente alcanzable.Esto asegura que el objeto no se libere,y su finalizador no se ejecute,antes del punto del programa donde se llama KeepAlive.</target>
        </trans-unit>
        <trans-unit id="4901b1829f2829b984a0de81f7472f13edad3727" translate="yes" xml:space="preserve">
          <source>Key returns the key of the iterator's current map entry.</source>
          <target state="translated">La tecla devuelve la clave de la entrada actual del mapa del iterador.</target>
        </trans-unit>
        <trans-unit id="91d7c5c0cb63de8145a0cccf24bc8d2f799ffa8e" translate="yes" xml:space="preserve">
          <source>Key returns the key type of map m.</source>
          <target state="translated">La clave devuelve el tipo de clave del mapa m.</target>
        </trans-unit>
        <trans-unit id="376426fe335e339ad2d0569150ad1299f858528e" translate="yes" xml:space="preserve">
          <source>KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.</source>
          <target state="translated">KeyUsage representa el conjunto de acciones que son válidas para una clave determinada.Es un mapa de bits de las constantes de KeyUsage*.</target>
        </trans-unit>
        <trans-unit id="096044ddbad86155a76b804e09110be8b259d0c6" translate="yes" xml:space="preserve">
          <source>KeyValue represents a single entry in a Map.</source>
          <target state="translated">El Valor Clave representa una única entrada en un Mapa.</target>
        </trans-unit>
        <trans-unit id="054ac770f511da2fe690104026b09ee1f229a5cb" translate="yes" xml:space="preserve">
          <source>Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.</source>
          <target state="translated">Matar hace que el proceso salga inmediatamente.Matar no espera hasta que el Proceso haya salido realmente.Esto sólo mata al propio Proceso,no a otros procesos que pueda haber iniciado.</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="2f96efc28c6a98b35f43fa160b16237570ef8889" translate="yes" xml:space="preserve">
          <source>Kind returns the kind of basic type b.</source>
          <target state="translated">El tipo devuelve el tipo básico de tipo b.</target>
        </trans-unit>
        <trans-unit id="1333bd1a9ccf64ac482cd7154071753a44d2a74b" translate="yes" xml:space="preserve">
          <source>Kind returns the selection kind.</source>
          <target state="translated">La amabilidad devuelve el tipo de selección.</target>
        </trans-unit>
        <trans-unit id="1c89bd23580c2ae3925d134637371987fedb05e1" translate="yes" xml:space="preserve">
          <source>Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</source>
          <target state="translated">Kind devuelve a V's Kind.Si v es el valor cero (IsValid devuelve falso),Kind devuelve Invalid.</target>
        </trans-unit>
        <trans-unit id="069ade3ad94bb7d5e1d27e83fcea3337da44893d" translate="yes" xml:space="preserve">
          <source>Kind specifies the kind of value represented by a Value.</source>
          <target state="translated">La clase especifica el tipo de valor representado por un Valor.</target>
        </trans-unit>
        <trans-unit id="4774d947be420886f05bc80b8d7b99a878f5521e" translate="yes" xml:space="preserve">
          <source>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">Las redes conocidas son &quot;tcp&quot;,&quot;tcp4&quot; (sólo IPv4),&quot;tcp6&quot; (sólo IPv6),&quot;udp&quot;,&quot;udp4&quot; (sólo IPv4),&quot;udp6&quot; (sólo IPv6),&quot;ip&quot;,&quot;ip4&quot; (sólo IPv4),&quot;ip6&quot; (sólo IPv6),&quot;unix&quot;,&quot;unixgram&quot; y &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="b8b88dd6dbbf9262e1174af16ab3d22e577d2db5" translate="yes" xml:space="preserve">
          <source>Known options:</source>
          <target state="translated">Opciones conocidas:</target>
        </trans-unit>
        <trans-unit id="14eee53dd9c3bca9efa386f9ef53c298322ea056" translate="yes" xml:space="preserve">
          <source>Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.</source>
          <target state="translated">Label devuelve el valor de la etiqueta con la tecla dada en el ctx,y un booleano que indica si esa etiqueta existe.</target>
        </trans-unit>
        <trans-unit id="17f6783a9c705de835debb13cac8a07e2f5a8b94" translate="yes" xml:space="preserve">
          <source>LabelSet is a set of labels.</source>
          <target state="translated">LabelSet es un conjunto de etiquetas.</target>
        </trans-unit>
        <trans-unit id="bd752eb91afd54f78c7060bac232ea7dd334932f" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only CPU profile utilizes labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">Labels toma un n&amp;uacute;mero par de cadenas que representan pares clave-valor y crea un LabelSet que los contiene. Una etiqueta sobrescribe una etiqueta anterior con la misma clave. Actualmente, solo el perfil de la CPU utiliza informaci&amp;oacute;n de etiquetas. Consulte &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="7b4c0dd78376377f6719d381d9475b9c65e91949" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only the CPU and goroutine profiles utilize any labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80c2e659a9bc68c02557be9a6c755aeed779cd0" translate="yes" xml:space="preserve">
          <source>LastIndex</source>
          <target state="translated">LastIndex</target>
        </trans-unit>
        <trans-unit id="c2daa604f07bcb24a260e4fea3217009758689c4" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">El LastIndex devuelve el índice del último caso de sep en s,o -1 si sep no está presente en s.</target>
        </trans-unit>
        <trans-unit id="b07643ffeaf5942b3f11986d945cbd1ca4dc0db5" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">El LastIndex devuelve el índice de la última instancia de la substr en s,o -1 si la substr no está presente en s.</target>
        </trans-unit>
        <trans-unit id="a55ae6e0d05b49527c27558955cfb6017a5cb79e" translate="yes" xml:space="preserve">
          <source>LastIndexAny</source>
          <target state="translated">LastIndexAny</target>
        </trans-unit>
        <trans-unit id="c468ec7af80d497e073da5281108fc969df48a62" translate="yes" xml:space="preserve">
          <source>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">LastIndexAny interpreta la s como una secuencia de puntos de código Unicode codificados en UTF-8.Devuelve el índice de bytes de la última ocurrencia en s de cualquiera de los puntos de código Unicode en caracteres.Devuelve -1 si los caracteres están vacíos o si no hay ningún punto de código en común.</target>
        </trans-unit>
        <trans-unit id="f35ff2cbc15f8519c2de1c522556210dbec6f0d9" translate="yes" xml:space="preserve">
          <source>LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">LastIndexAny devuelve el índice de la última instancia de cualquier punto de código Unicode de los caracteres en s,o -1 si no hay ningún punto de código Unicode de los caracteres en s.</target>
        </trans-unit>
        <trans-unit id="e5af45bb29df606a6ad9f71c5f8ffe801cf806e3" translate="yes" xml:space="preserve">
          <source>LastIndexByte</source>
          <target state="translated">LastIndexByte</target>
        </trans-unit>
        <trans-unit id="715ec7346f22f455ae3b4f77928429d6e6ea2e7d" translate="yes" xml:space="preserve">
          <source>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">El LastIndexByte devuelve el índice de la última instancia de c en s,o -1 si c no está presente en s.</target>
        </trans-unit>
        <trans-unit id="0052a6c35642a0a5651d0e514c35ebcc1b001ad3" translate="yes" xml:space="preserve">
          <source>LastIndexFunc</source>
          <target state="translated">LastIndexFunc</target>
        </trans-unit>
        <trans-unit id="e9e6d245d6f60be69d3deb822ef844937727defc" translate="yes" xml:space="preserve">
          <source>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">El LastIndexFunc interpreta la s como una secuencia de puntos de código codificados en UTF-8.Devuelve el índice de bytes en s del último punto de código Unicode que satisface f(c),o -1 si ninguno lo hace.</target>
        </trans-unit>
        <trans-unit id="573828a944fe303002f7c0336cac457a4d45085f" translate="yes" xml:space="preserve">
          <source>LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc devuelve el índice en s del último punto de código Unicode que satisface f(c),o -1 si no hay ninguno.</target>
        </trans-unit>
        <trans-unit id="cdb76fffe46f91856747d3f589e0a3ea42a00f8c" translate="yes" xml:space="preserve">
          <source>Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lchown cambia el uid y gid numérico del archivo nombrado.Si el archivo es un enlace simbólico,cambia el uid y gid del propio enlace.Si hay un error,será del tipo *PathError.</target>
        </trans-unit>
        <trans-unit id="9f1275e6821f8a51315e2ca81450b41140587c42" translate="yes" xml:space="preserve">
          <source>Ldexp is the inverse of Frexp. It returns frac &amp;times; 2**exp.</source>
          <target state="translated">Ldexp es el inverso de Frexp. Devuelve frac &amp;times; 2 ** exp.</target>
        </trans-unit>
        <trans-unit id="0bfbea9fa1b1bd75227de20412ea5faba23da169" translate="yes" xml:space="preserve">
          <source>LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">LeadingZeros devuelve el número de bits de cero al principio en x;el resultado es UintSize para x ==0.</target>
        </trans-unit>
        <trans-unit id="e3dbef4bbdf5cce299ff063f0c95032879c3da58" translate="yes" xml:space="preserve">
          <source>LeadingZeros16</source>
          <target state="translated">LeadingZeros16</target>
        </trans-unit>
        <trans-unit id="44f8376c5ec759270046aff7d8e5b19117ded5c1" translate="yes" xml:space="preserve">
          <source>LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">LeadingZeros16 devuelve el número de bits de cero a la izquierda en x;el resultado es 16 para x ==0.</target>
        </trans-unit>
        <trans-unit id="e9ed6b4c7187930afe2c50c883fcac4812515684" translate="yes" xml:space="preserve">
          <source>LeadingZeros32</source>
          <target state="translated">LeadingZeros32</target>
        </trans-unit>
        <trans-unit id="d0f408a69a9bfc0c9d5428df849a3e3f9c88b61c" translate="yes" xml:space="preserve">
          <source>LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">LeadingZeros32 devuelve el número de bits de cero inicial en x;el resultado es 32 para x ==0.</target>
        </trans-unit>
        <trans-unit id="f987ddc8abdaac6d127e5eafa8b11404f85e5b1a" translate="yes" xml:space="preserve">
          <source>LeadingZeros64</source>
          <target state="translated">LeadingZeros64</target>
        </trans-unit>
        <trans-unit id="fda83273480c3e8d70a28c2f123cbf299bd51fd9" translate="yes" xml:space="preserve">
          <source>LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">LeadingZeros64 devuelve el número de bits de cero a la izquierda en x;el resultado es 64 para x ==0.</target>
        </trans-unit>
        <trans-unit id="fda98988d92b8709dacc15db674b3e6e61682f64" translate="yes" xml:space="preserve">
          <source>LeadingZeros8</source>
          <target state="translated">LeadingZeros8</target>
        </trans-unit>
        <trans-unit id="d8a16180e08b654e4c4467808de5826069ff567a" translate="yes" xml:space="preserve">
          <source>LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">LeadingZeros8 devuelve el número de bits de cero inicial en x;el resultado es 8 para x ==0.</target>
        </trans-unit>
        <trans-unit id="721bda08d146a886975a86dd204cbec756066f9e" translate="yes" xml:space="preserve">
          <source>Least Surprise Property: &quot;A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.&quot;</source>
          <target state="translated">La propiedad menos sorprendente:&quot;Un desarrollador (o revisor de código)familiarizado con HTML,CSS y JavaScript,que sabe que la auto-escapada contextual ocurre debe ser capaz de mirar un {{.}}e inferir correctamente qué higienización ocurre&quot;.</target>
        </trans-unit>
        <trans-unit id="8d92112ff544a635650fbaf730715150d27bea5c" translate="yes" xml:space="preserve">
          <source>Len computes the number of elements in ring r. It executes in time proportional to the number of elements.</source>
          <target state="translated">Len calcula el número de elementos en el anillo r.Se ejecuta en tiempo proporcional al número de elementos.</target>
        </trans-unit>
        <trans-unit id="1399044ec4cebde1e345bfb6e7bc0665028c448d" translate="yes" xml:space="preserve">
          <source>Len returns the length of array a. A negative result indicates an unknown length.</source>
          <target state="translated">Len devuelve la longitud de la matriz a.Un resultado negativo indica una longitud desconocida.</target>
        </trans-unit>
        <trans-unit id="93ef3e242273d75e5bb1dbc766c5fd7830570833" translate="yes" xml:space="preserve">
          <source>Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len devuelve el número mínimo de bits necesarios para representar x;el resultado es 0 para x ==0.</target>
        </trans-unit>
        <trans-unit id="ca5afaea7adacd073486db0f70027386a60f94b6" translate="yes" xml:space="preserve">
          <source>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</source>
          <target state="translated">Len devuelve el número de bytes acumulados;b.Len()==len(b.String()).</target>
        </trans-unit>
        <trans-unit id="ee2f279ceb0f8a58afdf88fefe8cee3f9c31fa50" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).</source>
          <target state="translated">Len devuelve el número de bytes de la porción no leída de la memoria intermedia;b.Len()==len(b.Bytes()).</target>
        </trans-unit>
        <trans-unit id="67467f9c2f5df39d1ac34826fd0579c560dedb06" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the slice.</source>
          <target state="translated">Len devuelve el número de bytes de la porción no leída del trozo.</target>
        </trans-unit>
        <trans-unit id="9a34422a61609509fefc4a297f2f9c07ff69ccf9" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the string.</source>
          <target state="translated">Len devuelve el número de bytes de la parte no leída de la cadena.</target>
        </trans-unit>
        <trans-unit id="be3ac6245438d5424b518ab2335163e6f1965692" translate="yes" xml:space="preserve">
          <source>Len returns the number of elements of list l. The complexity is O(1).</source>
          <target state="translated">Len devuelve el número de elementos de la lista l.La complejidad es O(1).</target>
        </trans-unit>
        <trans-unit id="a7b0b1334a129ccc7a0e235fc902ddfdb01aa234" translate="yes" xml:space="preserve">
          <source>Len returns the number of methods in s.</source>
          <target state="translated">Len devuelve el número de métodos en s.</target>
        </trans-unit>
        <trans-unit id="9909b01102ccbea5c34e603dc1a8df16cade5eea" translate="yes" xml:space="preserve">
          <source>Len returns the number of scope elements.</source>
          <target state="translated">Len devuelve el número de elementos del alcance.</target>
        </trans-unit>
        <trans-unit id="8315c44360f57db88aab9b44a76e81307e540e3a" translate="yes" xml:space="preserve">
          <source>Len returns the number variables of tuple t.</source>
          <target state="translated">Len devuelve las variables numéricas de la tupla t.</target>
        </trans-unit>
        <trans-unit id="ca8349640e110d5798f69868438b094ed5d5cb6c" translate="yes" xml:space="preserve">
          <source>Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.</source>
          <target state="translated">Len devuelve la longitud de V.Entra en pánico si el tipo de V no es Array,Chan,Map,Slice o String.</target>
        </trans-unit>
        <trans-unit id="b58611e03df383dbaa4dc9ba6fd2e4a6b8e52327" translate="yes" xml:space="preserve">
          <source>Len16</source>
          <target state="translated">Len16</target>
        </trans-unit>
        <trans-unit id="f5e60795826c955dcfd526c1230894564783d120" translate="yes" xml:space="preserve">
          <source>Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len16 devuelve el número mínimo de bits necesarios para representar x;el resultado es 0 para x ==0.</target>
        </trans-unit>
        <trans-unit id="76efc8ef8d6465f58231c9d295309a299f1d8534" translate="yes" xml:space="preserve">
          <source>Len32</source>
          <target state="translated">Len32</target>
        </trans-unit>
        <trans-unit id="2bdd325b510dd0548fcbb4a4b3c4d52a4f66d711" translate="yes" xml:space="preserve">
          <source>Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len32 devuelve el número mínimo de bits necesarios para representar x;el resultado es 0 para x ==0.</target>
        </trans-unit>
        <trans-unit id="5bed2d704a16234c65f3795d3067f97369c94923" translate="yes" xml:space="preserve">
          <source>Len64</source>
          <target state="translated">Len64</target>
        </trans-unit>
        <trans-unit id="67dd373d63df43f7c3cfe611f388cdd1def82589" translate="yes" xml:space="preserve">
          <source>Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len64 devuelve el número mínimo de bits necesarios para representar x;el resultado es 0 para x ==0.</target>
        </trans-unit>
        <trans-unit id="5877dcf480cd63f747b4cd7b2e4473a4fb01962a" translate="yes" xml:space="preserve">
          <source>Len8</source>
          <target state="translated">Len8</target>
        </trans-unit>
        <trans-unit id="ead2ce671d2982c7db8677f2bb62a7b4fdd9a8e8" translate="yes" xml:space="preserve">
          <source>Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len8 devuelve el número mínimo de bits necesarios para representar x;el resultado es 0 para x ==0.</target>
        </trans-unit>
        <trans-unit id="2981abdd30fd95f0ea0e0799884f920048d0fba8" translate="yes" xml:space="preserve">
          <source>Length returns the JavaScript property &quot;length&quot; of v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Longitud devuelve la propiedad JavaScript &quot;longitud&quot; de v.Entra en pánico si v no es un objeto JavaScript.</target>
        </trans-unit>
        <trans-unit id="f0f51015552f0c7df8f3dcfecc5c896adfb05b7f" translate="yes" xml:space="preserve">
          <source>Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.</source>
          <target state="translated">Longitud devuelve la longitud del tipo de columna para los tipos de columna de longitud variable como los tipos de campo de texto y binario.Si la longitud del tipo es ilimitada,el valor será math.MaxInt64 (cualquier límite de la base de datos seguirá siendo aplicable).Si el tipo de columna no es de longitud variable,como un int,o si no está soportado por el controlador ok es falso.</target>
        </trans-unit>
        <trans-unit id="7467b2c9a7e459bce96e4603f4b9c0fecbbea6e6" translate="yes" xml:space="preserve">
          <source>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</source>
          <target state="translated">Lgamma devuelve el logaritmo natural y el signo (-1 o +1)de Gamma(x).</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">Licenciado bajo la Creative Commons Attribution License 3.0.</target>
        </trans-unit>
        <trans-unit id="7d9d345bfff5b874e03396293193a78237bde2df" translate="yes" xml:space="preserve">
          <source>Like Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.</source>
          <target state="translated">Al igual que Scanf y Fscanf,Sscanf no necesita consumir toda su entrada.No hay forma de recuperar la cantidad de la cadena de entrada que usó Sscanf.</target>
        </trans-unit>
        <trans-unit id="7e1cb140c6b5c5e4e4aa15375a7a581d31852d58" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">Como en las pruebas,los registros de referencia se acumulan durante la ejecución y se vuelcan al error estándar cuando se hace.A diferencia de las pruebas,los registros de referencia se imprimen siempre,para no ocultar la salida cuya existencia puede estar afectando a los resultados de la referencia.</target>
        </trans-unit>
        <trans-unit id="eb83a6fa3fb8d575ea5425178090b707c4e5b7e9" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d7a9c098ae2cc78ad63fdda4f717ce942dd2cc" translate="yes" xml:space="preserve">
          <source>Like the RoundTripper interface, the error types returned by RoundTrip are unspecified.</source>
          <target state="translated">Al igual que la interfaz del RoundTripper,los tipos de error devueltos por el RoundTrip no están especificados.</target>
        </trans-unit>
        <trans-unit id="8c3e2cc8bde5ef9c910164a74c49f21b4ecb6bc1" translate="yes" xml:space="preserve">
          <source>LimitReader</source>
          <target state="translated">LimitReader</target>
        </trans-unit>
        <trans-unit id="82f17ce7a899200e83a237fbfff2e0aec18adc46" translate="yes" xml:space="preserve">
          <source>LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.</source>
          <target state="translated">LimitReader devuelve un lector que lee de r pero se detiene con EOF después de n bytes.La implementación subyacente es un *LimitedReader.</target>
        </trans-unit>
        <trans-unit id="dfc4ccc73713d6d0c21377e9d4eb82cf06cf9ec2" translate="yes" xml:space="preserve">
          <source>Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.</source>
          <target state="translated">Line devuelve el número de línea para la posición p del archivo dado;p debe ser un valor Pos en ese archivo o NoPos.</target>
        </trans-unit>
        <trans-unit id="c80f69f5d4f28c6e33fd6610f08a1143f38de111" translate="yes" xml:space="preserve">
          <source>LineCount returns the number of lines in file f.</source>
          <target state="translated">LineCount devuelve el número de líneas del archivo f.</target>
        </trans-unit>
        <trans-unit id="8021239ce81a740af9d1126d1dcb955373ee8d6d" translate="yes" xml:space="preserve">
          <source>LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.</source>
          <target state="translated">LineReader devuelve un nuevo lector para la tabla de líneas de la unidad de compilación cu,que debe ser una entrada con la etiqueta TagCompileUnit.</target>
        </trans-unit>
        <trans-unit id="d6e6998fd35451f00c85f965d2d22dc96e7bd958" translate="yes" xml:space="preserve">
          <source>LineStart returns the Pos value of the start of the specified line. It ignores any alternative positions set using AddLineColumnInfo. LineStart panics if the 1-based line number is invalid.</source>
          <target state="translated">LineStart devuelve el valor Pos del inicio de la línea especificada.Ignora cualquier posición alternativa establecida usando AddLineColumnInfo.LineStart entra en pánico si el número de línea basado en 1 es inválido.</target>
        </trans-unit>
        <trans-unit id="4776e3cbe12ee14e372370ae9f2a2f5ec9999059" translate="yes" xml:space="preserve">
          <source>LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.</source>
          <target state="translated">LineToPC busca el primer contador de programa en la línea dada en el archivo nombrado.Devuelve &quot;UnknownPathError&quot; o &quot;UnknownLineError&quot; si hay un error en la búsqueda de esta línea.</target>
        </trans-unit>
        <trans-unit id="e41c87878f5ec2dd68efcc90f4932d27c2b8d1c2" translate="yes" xml:space="preserve">
          <source>LineToPC returns the program counter for the given line number, considering only program counters before maxpc.</source>
          <target state="translated">LineToPC devuelve el contador de programa para el número de línea dado,considerando sólo los contadores de programa antes de maxpc.</target>
        </trans-unit>
        <trans-unit id="d3ece36672b155d5080f24d88b4ef4dc56af15c6" translate="yes" xml:space="preserve">
          <source>Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.</source>
          <target state="translated">El enlace conecta el anillo r con el anillo s de tal manera que r.Next()se convierte en s y devuelve el valor original de r.Next().r no debe estar vacío.</target>
        </trans-unit>
        <trans-unit id="61bc01a247b2210bb40d4dab78269bb633df6036" translate="yes" xml:space="preserve">
          <source>Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">El enlace crea un nuevo nombre como un enlace duro al archivo del nombre antiguo.Si hay un error,será del tipo *LinkError.</target>
        </trans-unit>
        <trans-unit id="8c53bb40a220e2f4f66bfd2012a9dda9a12bc64f" translate="yes" xml:space="preserve">
          <source>LinkError records an error during a link or symlink or rename system call and the paths that caused it.</source>
          <target state="translated">LinkError registra un error durante una llamada de sistema de enlace o simbólico o renombrado y las rutas que lo causaron.</target>
        </trans-unit>
        <trans-unit id="2ca439921c0481dec50573fdcf5a08b538a5f2a3" translate="yes" xml:space="preserve">
          <source>List represents a doubly linked list. The zero value for List is an empty list ready to use.</source>
          <target state="translated">La lista representa una lista doblemente vinculada.El valor cero de Lista es una lista vacía lista lista para ser usada.</target>
        </trans-unit>
        <trans-unit id="ed96ea56ffbf3b559f9c41465dc17435379898fd" translate="yes" xml:space="preserve">
          <source>ListNode holds a sequence of nodes.</source>
          <target state="translated">El ListNode contiene una secuencia de nodos.</target>
        </trans-unit>
        <trans-unit id="ca24c0263416d5489002e073f3f7f972b1a2c801" translate="yes" xml:space="preserve">
          <source>Listen announces on the local network address.</source>
          <target state="translated">Escuchar anuncia en la dirección de la red local.</target>
        </trans-unit>
        <trans-unit id="fbc501a375c74f3f294816964a99702dd99275fe" translate="yes" xml:space="preserve">
          <source>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Listen crea un oyente TLS que acepta conexiones en la dirección de red dada usando net.Listen.La configuración debe ser no nula y debe incluir al menos un certificado o bien establecer GetCertificate.</target>
        </trans-unit>
        <trans-unit id="6c1bd8cd11c9c376470f7f547014d7596b4d2372" translate="yes" xml:space="preserve">
          <source>ListenAndServe</source>
          <target state="translated">ListenAndServe</target>
        </trans-unit>
        <trans-unit id="ca4b599f82e29135dc1efc68105574de3edf6ae1" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error.</source>
          <target state="translated">ListenAndServe siempre devuelve un error no nulo.</target>
        </trans-unit>
        <trans-unit id="5dd294a2ba295a8af34a90f46a25099808a8e7bb" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServe siempre devuelve un error no nulo.Después de apagar o cerrar,el error devuelto es ErrServerClosed.</target>
        </trans-unit>
        <trans-unit id="0e017d6f66fb57e5159203491154acdfd7f3155e" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe escucha en la dirección de la red TCP y luego llama a Serve con handler para manejar las solicitudes en las conexiones entrantes.Las conexiones aceptadas se configuran para habilitar TCP keep-alives.</target>
        </trans-unit>
        <trans-unit id="1eb6871fd885bb71d1764b988ed8e0b1207dbd10" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe escucha en la dirección de la red TCP srv.Addr y luego llama a Serve para manejar las solicitudes en las conexiones entrantes.Las conexiones aceptadas se configuran para habilitar TCP keep-alives.</target>
        </trans-unit>
        <trans-unit id="f672409681724db7975a81f059dabf70eb0a6552" translate="yes" xml:space="preserve">
          <source>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</source>
          <target state="translated">ListenAndServe inicia un servidor HTTP con una dirección y un controlador determinados.El manejador es usualmente nil,lo que significa que se usa DefaultServeMux.Handle y HandleFunc agregan handlers a DefaultServeMux:</target>
        </trans-unit>
        <trans-unit id="b1444c4d4c91aea2ff2c287b0f4c6b6c33effbc6" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS</source>
          <target state="translated">ListenAndServeTLS</target>
        </trans-unit>
        <trans-unit id="4b13ffad776ec4c1e6e622baa48939390c7f43be" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">ListenAndServeTLS actúa de forma idéntica a ListenAndServe,excepto que espera conexiones HTTPS.Además,se deben proporcionar archivos que contengan un certificado y una clave privada que coincida con el servidor.Si el certificado está firmado por una autoridad de certificación,el certFile debe ser la concatenación del certificado del servidor,cualquier intermediario y el certificado de la CA.</target>
        </trans-unit>
        <trans-unit id="e993bc61c7cd05bdd6aa504a7bf534f06ff70ebd" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServeTLS siempre devuelve un error no nulo.Después de apagar o cerrar,el error devuelto es ErrServerClosed.</target>
        </trans-unit>
        <trans-unit id="4de6956912052ccb175eeb5c4727583b8c87a58f" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServeTLS escucha en la dirección de la red TCP srv.Addr y luego llama a ServeTLS para manejar las solicitudes en las conexiones TLS entrantes.Las conexiones aceptadas están configuradas para habilitar TCP keep-alives.</target>
        </trans-unit>
        <trans-unit id="2ef32140a96f71533a922e8af1a4a1287b2aa08c" translate="yes" xml:space="preserve">
          <source>ListenConfig contains options for listening to an address.</source>
          <target state="translated">ListenConfig contiene opciones para escuchar una dirección.</target>
        </trans-unit>
        <trans-unit id="56e637fe09ab78156ad9d4b14c696af0fcd5c313" translate="yes" xml:space="preserve">
          <source>ListenIP acts like ListenPacket for IP networks.</source>
          <target state="translated">ListenIP actúa como ListenPacket para las redes IP.</target>
        </trans-unit>
        <trans-unit id="f21580354d675fc10d1e9ee1c4db6486064ec455" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.</source>
          <target state="translated">ListenMulticastUDP actúa como ListenPacket para las redes UDP pero toma una dirección de grupo en una interfaz de red específica.</target>
        </trans-unit>
        <trans-unit id="867f2d87132f64efe5f8f6f86d2c98549b471fdb" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.</source>
          <target state="translated">ListenMulticastUDP es sólo para la conveniencia de aplicaciones simples y pequeñas.Hay paquetes golang.org/x/net/ipv4 y golang.org/x/net/ipv6 para usos generales.</target>
        </trans-unit>
        <trans-unit id="bd5f6e57a541e39939141511f957be405b380471" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.</source>
          <target state="translated">ListenMulticastUDP escucha todas las direcciones IP disponibles del sistema local incluyendo el grupo,dirección IP multicast.Si es nula,ListenMulticastUDP utiliza la interfaz multicast asignada por el sistema,aunque no se recomienda porque la asignación depende de las plataformas y a veces puede requerir la configuración del enrutamiento.Si el campo Port de gaddr es 0,se elige automáticamente un número de puerto.</target>
        </trans-unit>
        <trans-unit id="468da55aa49f2b551af4d2ec242f5d19018b56ca" translate="yes" xml:space="preserve">
          <source>ListenPacket announces on the local network address.</source>
          <target state="translated">ListenPacket anuncia en la dirección de la red local.</target>
        </trans-unit>
        <trans-unit id="df604088a8b978cdce196e569a7b165e976e6869" translate="yes" xml:space="preserve">
          <source>ListenTCP acts like Listen for TCP networks.</source>
          <target state="translated">ListenTCP actúa como Listen para las redes TCP.</target>
        </trans-unit>
        <trans-unit id="9851cfe87c5b9ef168f40038c7d75b3a82ee3529" translate="yes" xml:space="preserve">
          <source>ListenUDP acts like ListenPacket for UDP networks.</source>
          <target state="translated">ListenUDP actúa como ListenPacket para las redes UDP.</target>
        </trans-unit>
        <trans-unit id="5b7757b4611e8ba6d66b663a1f48d50bfcf3ecc4" translate="yes" xml:space="preserve">
          <source>ListenUnix acts like Listen for Unix networks.</source>
          <target state="translated">ListenUnix actúa como las redes Listen for Unix.</target>
        </trans-unit>
        <trans-unit id="df0abb591dbf2fca4d32aeb087ddbb3eb5bf7905" translate="yes" xml:space="preserve">
          <source>ListenUnixgram acts like ListenPacket for Unix networks.</source>
          <target state="translated">ListenUnixgram actúa como ListenPacket para las redes Unix.</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="0391fe0f913571d2818f72cca0ff528d31c4414b" translate="yes" xml:space="preserve">
          <source>LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.</source>
          <target state="translated">LiteralPrefix devuelve una cadena literal que debe comenzar cualquier coincidencia de la expresión regular re.Devuelve el verdadero booleano si la cadena literal comprende toda la expresión regular.</target>
        </trans-unit>
        <trans-unit id="ecdd85ee0de784370070e365d9f936724803e148" translate="yes" xml:space="preserve">
          <source>LittleEndian is the little-endian implementation of ByteOrder.</source>
          <target state="translated">LittleEndian es la implementación little-endian de ByteOrder.</target>
        </trans-unit>
        <trans-unit id="d5ae70e267716ec3e2a976b68757e30ee0e214a8" translate="yes" xml:space="preserve">
          <source>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.</source>
          <target state="translated">La carga devuelve el valor establecido por la tienda más reciente.Devuelve cero si no ha habido ninguna llamada a Store para este valor.</target>
        </trans-unit>
        <trans-unit id="74c5a2d6710e8b201a98f6c2837198f613eec0fa" translate="yes" xml:space="preserve">
          <source>Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.</source>
          <target state="translated">Load devuelve el valor almacenado en el mapa para una tecla,o nulo si no hay ningún valor presente.El resultado ok indica si se encontró el valor en el mapa.</target>
        </trans-unit>
        <trans-unit id="bfe3a7d08b4bcafd9312e5433ad874e88e9a309d" translate="yes" xml:space="preserve">
          <source>LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881052b1a20f63445e79814467ecdb5374883ab0" translate="yes" xml:space="preserve">
          <source>LoadInt32 atomically loads *addr.</source>
          <target state="translated">LoadInt32 carga atómica *addr.</target>
        </trans-unit>
        <trans-unit id="2ac3794cf69cbb4165a4ee85d8ea313e85610e69" translate="yes" xml:space="preserve">
          <source>LoadInt64 atomically loads *addr.</source>
          <target state="translated">LoadInt64 carga atómicamente *addr.</target>
        </trans-unit>
        <trans-unit id="3cd00c96c1dde37f4e165d9dd83f094e52c09c97" translate="yes" xml:space="preserve">
          <source>LoadLocation</source>
          <target state="translated">LoadLocation</target>
        </trans-unit>
        <trans-unit id="942c4e15f8861257bc29d285e307a9855ad8da88" translate="yes" xml:space="preserve">
          <source>LoadLocation returns the Location with the given name.</source>
          <target state="translated">LoadLocation devuelve la localización con el nombre dado.</target>
        </trans-unit>
        <trans-unit id="452c7f6aa0b947a115cd7ebee668ccabc28767f6" translate="yes" xml:space="preserve">
          <source>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).</source>
          <target state="translated">LoadLocationFromTZData devuelve una localización con el nombre inicializado de la base de datos de zonas horarias de la IANA.Los datos deben tener el formato de un archivo estándar de zonas horarias de la IANA (por ejemplo,el contenido de /etc/localtime en sistemas Unix).</target>
        </trans-unit>
        <trans-unit id="730b9fd8d031760ad2f11544687c7f3a4c32ba10" translate="yes" xml:space="preserve">
          <source>LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.</source>
          <target state="translated">LoadOrStore devuelve el valor existente para la clave si está presente.En caso contrario,almacena y devuelve el valor dado.El resultado cargado es verdadero si el valor fue cargado,falso si fue almacenado.</target>
        </trans-unit>
        <trans-unit id="16e5531718ad0441ff996bffe1bdb2f9013072b8" translate="yes" xml:space="preserve">
          <source>LoadPointer atomically loads *addr.</source>
          <target state="translated">El LoadPointer carga atómicamente *addr.</target>
        </trans-unit>
        <trans-unit id="3a58860dce2950635c9b0aec0356bd0e023fcd4b" translate="yes" xml:space="preserve">
          <source>LoadUint32 atomically loads *addr.</source>
          <target state="translated">LoadUint32 cargas atómicas *addr.</target>
        </trans-unit>
        <trans-unit id="ed4689d0f224e4c5a01ae1b69433a91e9f118b20" translate="yes" xml:space="preserve">
          <source>LoadUint64 atomically loads *addr.</source>
          <target state="translated">LoadUint64 cargas atómicas *addr.</target>
        </trans-unit>
        <trans-unit id="9cfbde985c4614b9808e9de0d65afb5568c9c53d" translate="yes" xml:space="preserve">
          <source>LoadUintptr atomically loads *addr.</source>
          <target state="translated">LoadUintptr atomically loads *addr.</target>
        </trans-unit>
        <trans-unit id="e85b79501e4b543de03554e2a29fd9cbd965ec40" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair</source>
          <target state="translated">LoadX509KeyPair</target>
        </trans-unit>
        <trans-unit id="45fae6424c26a4b8eb19ae242ef820e6061dab08" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">LoadX509KeyPair lee y analiza un par de claves públicas/privadas de un par de archivos.Los archivos deben contener datos codificados PEM.El archivo de certificado puede contener certificados intermedios que siguen al certificado de hoja para formar una cadena de certificados.Cuando se devuelva con éxito,la hoja del certificado será nula porque no se conserva el formulario analizado del certificado.</target>
        </trans-unit>
        <trans-unit id="1da25ed4d4f6ff8e68f5335ba8ba070399bd7f5f" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone.</source>
          <target state="translated">Local representa la zona horaria local del sistema.</target>
        </trans-unit>
        <trans-unit id="4f717f0478e589f031d904c7f74748dd18f86eeb" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=&quot;&quot; means use UTC. TZ=&quot;foo&quot; means use file foo in the system timezone directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6d294473bbbfce0d1197b903b10c86fb6c3b7b" translate="yes" xml:space="preserve">
          <source>Local returns t with the location set to local time.</source>
          <target state="translated">Local regresa t con la ubicación ajustada a la hora local.</target>
        </trans-unit>
        <trans-unit id="4a5ab837cb8b234abbab484d911af5705d613e13" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address.</source>
          <target state="translated">La Dirección Local devuelve la dirección de la red local.</target>
        </trans-unit>
        <trans-unit id="c10eb870360e8baad53b9b506e944815aa5896df" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.</source>
          <target state="translated">La Dirección Local devuelve la dirección de la red local.La Dir Dir devuelta es compartida por todas las invocaciones de Dir Local,así que no la modifiquen.</target>
        </trans-unit>
        <trans-unit id="238b4cd4fe464f99416bb574ab9c5c6651970ad5" translate="yes" xml:space="preserve">
          <source>LocalhostCert is a PEM-encoded TLS cert with SAN IPs &quot;127.0.0.1&quot; and &quot;[::1]&quot;, expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</source>
          <target state="translated">LocalhostCert es un certificado TLS codificado con PEM con SAN IPs &quot;127.0.0.1&quot; y &quot;[::1]&quot;,que expira el 29 de Enero 16:00:00 2084 GMT.generado a partir de src/crypto/tls:go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</target>
        </trans-unit>
        <trans-unit id="2852b827de5091ca5aa6958386fa1405befa6094" translate="yes" xml:space="preserve">
          <source>LocalhostKey is the private key for localhostCert.</source>
          <target state="translated">LocalhostKey es la llave privada de localhostCert.</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="c9551a197b6ccbbe733e98e1afb44218648f365d" translate="yes" xml:space="preserve">
          <source>Location returns the URL of the response's &quot;Location&quot; header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.</source>
          <target state="translated">Ubicación devuelve la URL del encabezado de &quot;Ubicación&quot; de la respuesta,si está presente.Las redirecciones relativas se resuelven en relación con la solicitud de la respuesta.ErrNoLocation se devuelve si no hay un encabezado de &quot;Location&quot; presente.</target>
        </trans-unit>
        <trans-unit id="6b99376f9c15a7e92154da5850b5d13b41ab37cc" translate="yes" xml:space="preserve">
          <source>Location returns the time zone information associated with t.</source>
          <target state="translated">La ubicación devuelve la información de la zona horaria asociada a t.</target>
        </trans-unit>
        <trans-unit id="f30d8c256e2218530f9f115302f529d73fbbff9d" translate="yes" xml:space="preserve">
          <source>Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.</source>
          <target state="translated">La cerradura se bloquea m.Si la cerradura ya está en uso,la llamada goroutine se bloquea hasta que el mutex esté disponible.</target>
        </trans-unit>
        <trans-unit id="c3a987424c4290a7edfb3d1d597eb0eadb3ba378" translate="yes" xml:space="preserve">
          <source>Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</source>
          <target state="translated">La cerradura se cierra con llave para escribir.Si la cerradura ya está bloqueada para leer o escribir,Bloquea hasta que la cerradura esté disponible.</target>
        </trans-unit>
        <trans-unit id="5e340916752857a7b67a505378d157d115c1dd5a" translate="yes" xml:space="preserve">
          <source>LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.</source>
          <target state="translated">LockOSThread cablea la gorutita de llamada a su actual sistema operativo.La gorrutina de llamada siempre se ejecutará en ese hilo,y ninguna otra gorrutina se ejecutará en él,hasta que la gorrutina de llamada haya hecho tantas llamadas a UnlockOSThread como a LockOSThread.Si la gorrutina invocadora sale sin desbloquear el hilo,el hilo se terminará.</target>
        </trans-unit>
        <trans-unit id="8bf95ea372568c7a254ba9fada5f6f1701ebc5b5" translate="yes" xml:space="preserve">
          <source>Log</source>
          <target state="translated">Log</target>
        </trans-unit>
        <trans-unit id="fef609891d98d73a3ae686771d1e86e56fc90748" translate="yes" xml:space="preserve">
          <source>Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.</source>
          <target state="translated">El registro emite un evento único con la categoría y el mensaje dados.La categoría puede estar vacía y la API asume que sólo hay un puñado de categorías únicas en el sistema.</target>
        </trans-unit>
        <trans-unit id="2353b4e8ade1606ef5c45cccd26ad3ad6087c78a" translate="yes" xml:space="preserve">
          <source>Log emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called Log. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in Log.</source>
          <target state="translated">Log emite un mensaje con fecha y hora a la pista de ejecución junto con información adicional como la categoría del mensaje y que goroutine llamó Log.La traza de ejecución proporciona UI para filtrar y agrupar goroutines utilizando la categoría del log y el mensaje suministrado en Log.</target>
        </trans-unit>
        <trans-unit id="9821e0db1231d181423f2e3b3225f154baa6bcf6" translate="yes" xml:space="preserve">
          <source>Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">El registro da formato a sus argumentos usando un formato por defecto,análogo al de Println,y registra el texto en el registro de errores.Para las pruebas,el texto se imprimirá sólo si la prueba falla o si se fija el indicador -test.v.Para las pruebas de referencia,el texto se imprime siempre para evitar que el rendimiento dependa del valor del indicador -test.v.</target>
        </trans-unit>
        <trans-unit id="ad88d5c498edf7ea21028a5246446ba6a3bf9e4a" translate="yes" xml:space="preserve">
          <source>Log returns the natural logarithm of x.</source>
          <target state="translated">El registro devuelve el logaritmo natural de x.</target>
        </trans-unit>
        <trans-unit id="81d615cdf905d64451161a1aa0b68ae0ffb374e3" translate="yes" xml:space="preserve">
          <source>Log10</source>
          <target state="translated">Log10</target>
        </trans-unit>
        <trans-unit id="977a2b5c893e89719e9a7736a4e1f9cc525e8f11" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x.</source>
          <target state="translated">Log10 devuelve el logaritmo decimal de x.</target>
        </trans-unit>
        <trans-unit id="8671c0c40d7db0093d8bf62e5f04cba5c99ec3ea" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log10 devuelve el logaritmo decimal de x.Los casos especiales son los mismos que para Log.</target>
        </trans-unit>
        <trans-unit id="a5b2fd4cb1a8e2bb305b5672e391aef89a37298c" translate="yes" xml:space="preserve">
          <source>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</source>
          <target state="translated">Log1p devuelve el logaritmo natural de 1 más su argumento x.Es más preciso que Log(1+x)cuando x está cerca de cero.</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="7a0389c8675757d7572efc0a10b125d5c66b151f" translate="yes" xml:space="preserve">
          <source>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log2 devuelve el logaritmo binario de x.Los casos especiales son los mismos que para Log.</target>
        </trans-unit>
        <trans-unit id="5963a7c64c0149e44b174ff76b7f701d23bc3074" translate="yes" xml:space="preserve">
          <source>Logb returns the binary exponent of x.</source>
          <target state="translated">Logb devuelve el exponente binario de x.</target>
        </trans-unit>
        <trans-unit id="ea0c4052b7cdd5aadd9cd6f72174db65e462d77d" translate="yes" xml:space="preserve">
          <source>Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Logf formatea sus argumentos de acuerdo al formato,análogo a Printf,y registra el texto en el registro de errores.Se añade una nueva línea final si no se proporciona.Para las pruebas,el texto se imprimirá sólo si la prueba falla o si se fija el indicador -test.v.Para las pruebas,el texto se imprime siempre para evitar que el rendimiento dependa del valor del indicador -test.v.</target>
        </trans-unit>
        <trans-unit id="38de20acad3e04f48129d8399f6a41e7517acf40" translate="yes" xml:space="preserve">
          <source>Logf is like Log, but the value is formatted using the specified format spec.</source>
          <target state="translated">Logf es como Log,pero el valor se formatea usando el formato especificado.</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="71c466638d24f772f0edc78440c6db3a9b5a9e5d" translate="yes" xml:space="preserve">
          <source>Logger.Output</source>
          <target state="translated">Logger.Output</target>
        </trans-unit>
        <trans-unit id="00aa9c00206cc40c149f1a777f6bcbff0a6df954" translate="yes" xml:space="preserve">
          <source>Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.</source>
          <target state="translated">El más largo hace que las futuras búsquedas prefieran la coincidencia más larga de la izquierda.Es decir,al hacer la comparación con el texto,el regexp devuelve una coincidencia que comienza lo antes posible en la entrada (la más a la izquierda),y entre ellas elige una coincidencia que sea lo más larga posible.Este método modifica el Regexp y no puede ser llamado concurrentemente con ningún otro método.</target>
        </trans-unit>
        <trans-unit id="2397e2af778033b693f99aeecb7590b807be4783" translate="yes" xml:space="preserve">
          <source>LookPath</source>
          <target state="translated">LookPath</target>
        </trans-unit>
        <trans-unit id="3feb8389b758c68212533dd8278b352dcce121bf" translate="yes" xml:space="preserve">
          <source>LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</source>
          <target state="translated">LookPath busca un archivo ejecutable en los directorios nombrados por la variable de entorno PATH.Si el archivo contiene una barra,se intenta directamente y no se consulta el PATH.El resultado puede ser una ruta absoluta o una ruta relativa al directorio actual.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
