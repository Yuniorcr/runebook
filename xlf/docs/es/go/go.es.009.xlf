<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="043f79dd25246a384c5fa68242e8b0950e54d69e" translate="yes" xml:space="preserve">
          <source>The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">Las funciones de comparación funcionan sólo con tipos básicos (o tipos básicos nombrados,como el &quot;tipo Celsius float32&quot;).Aplican las reglas de Go para la comparación de valores,salvo que se ignoran el tamaño y el tipo exacto,por lo que cualquier valor entero,con o sin signo,puede compararse con cualquier otro valor entero.(Se compara el valor aritmético,no el patrón de bits,por lo que todos los números enteros negativos son menores que todos los números enteros sin signo).Sin embargo,como es habitual,no se puede comparar un int con un float32 y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">El compilador maneja un puntero convertido en uintptr en la lista de argumentos de una llamada a una función implementada en ensamblador disponiendo que el objeto asignado referenciado,si lo hay,se retenga y no se mueva hasta que la llamada se complete,aunque sólo por los tipos parezca que el objeto ya no se necesita durante la llamada.</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">La compleja función incorporada construye un valor complejo a partir de dos valores de punto flotante.Las partes real e imaginaria deben ser del mismo tamaño,ya sea float32 o float64 (o asignables a ellos),y el valor de retorno será el tipo de complejo correspondiente (complex64 para float32,complex128 para float64).</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">El nivel de compresión puede ser DefaultCompression,NoCompression,HuffmanOnly o cualquier valor entero entre BestSpeed y BestCompression inclusive.El error devuelto será nulo si el nivel es válido.</target>
        </trans-unit>
        <trans-unit id="0a1efe910d68e12343aa1a848eb28de270b6d379" translate="yes" xml:space="preserve">
          <source>The computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">La constante UpperLower tiene un valor delta que de otra manera sería imposible.</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">El método de búsqueda del contenido debe funcionar:ServeContent utiliza una búsqueda hasta el final del contenido para determinar su tamaño.</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">La función de contexto será llamada con un solo argumento,un puntero a una estructura:</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">Las reglas de conversión son:</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">La función de copia incorporada copia elementos de una rebanada de origen a una rebanada de destino.(Como caso especial,también copiará bytes de una cadena a una rebanada de bytes).La fuente y el destino pueden superponerse.Copia devuelve el número de elementos copiados,que será el mínimo de len(src)y len(dst).</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">El conteo determina el número de subcadenas a devolver:</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">El paquete crypto / tls solo implementa algunas contramedidas contra los ataques Lucky13 en el cifrado en modo CBC, y solo en las variantes SHA1. Ver &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; y &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">Las operaciones criptográficas se implementan utilizando algoritmos de tiempo constante.</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">Las operaciones criptográficas no utilizan algoritmos de tiempo constante.</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">Los tipos de claves actualmente soportados son *rsa.PublicKey,*ecdsa.PublicKey y ed25519.PublicKey.pub debe ser un tipo de clave soportado,y priv debe ser un cripto.Signer con una clave pública soportada.</target>
        </trans-unit>
        <trans-unit id="5f866cd795794ee9a8943b941d8f0f21dd57c5d8" translate="yes" xml:space="preserve">
          <source>The d argument is the fs.DirEntry for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">El parámetro de depuración permite una salida adicional.Pasando debug=0 se imprimen sólo las direcciones hexadecimales que pprof necesita.Pasando debug=1 añade comentarios que traducen las direcciones a nombres de funciones y números de línea,para que un programador pueda leer el perfil sin herramientas.</target>
        </trans-unit>
        <trans-unit id="0fb33327b278ec03a78f307167cc6e36a7617010" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview&lt;/a&gt;. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">La decisión también puede ser forzada mientras se construye el árbol de la fuente de Go fijando la etiqueta de construcción netgo o netcgo.</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">La forma decodificada devuelta por el método de Lectura del Lector reescribe los finales de línea de &quot;\r\N&quot; en la &quot;\N&quot; más simple,elimina los escapes de puntos de plomo si están presentes,y se detiene con error \N io.EOF después de consumir (y descartar)la línea de fin de secuencia.</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">El decodificador introduce su propio buffer y puede leer los datos de r más allá de los valores JSON solicitados.</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">Las implementaciones HTTP/1.x y HTTP/2 de ResponseWriter predeterminadas son compatibles con Flusher,pero es posible que las envolturas de ResponseWriter no lo sean.Los manipuladores siempre deben probar esta capacidad en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">El ResponseWriter predeterminado para conexiones HTTP/1.x soporta Hijacker,pero las conexiones HTTP/2 no lo hacen intencionadamente.Es posible que los envoltorios de ResponseWriter tampoco admitan Hijacker.Los manejadores siempre deben probar esta capacidad en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">El comportamiento predeterminado es desvincular el archivo de sockets sólo cuando el paquete net lo creó.Es decir,cuando el oyente y el archivo de socket subyacente fueron creados por una llamada a Listen o ListenUnix,entonces por defecto cerrar el oyente eliminará el archivo de socket.pero si el oyente fue creado por una llamada a FileListener para usar un archivo de socket ya existente,entonces por defecto cerrar el oyente no eliminará el archivo de socket.</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">El formato por defecto para %v es:</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">El máximo de conexiones inactivas por defecto es actualmente 2.Esto puede cambiar en una futura versión.</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">El conjunto predeterminado de banderas de la línea de mando está controlado por funciones de nivel superior.El tipo FlagSet permite definir conjuntos independientes de banderas,como para implementar subcomandos en una interfaz de línea de comandos.Los métodos de FlagSet son análogos a las funciones de nivel superior para el conjunto de banderas de la línea de comandos.</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">La acción definida nombra la plantilla que se está creando proporcionando una constante de cadena.Aquí hay un ejemplo simple:</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">Los bits del modo de archivo definido son los más significativos del modo de archivo.Los nueve bits menos significativos son los permisos estándar de Unix rwxrwxrwx.Los valores de estos bits deben considerarse parte de la API pública y pueden utilizarse en protocolos de cable o representaciones de disco:no deben modificarse,aunque pueden añadirse nuevos bits.</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">La función de supresión incorporada elimina el elemento con la tecla especificada (m[key])del mapa.Si m es nula o no existe tal elemento,la eliminación es un no-op.</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">El diccionario puede ser nulo.Si no,su contenido no debe ser modificado hasta que se cierre el Escritor.</target>
        </trans-unit>
        <trans-unit id="4b0f9980f9925bb5ac741f7cd28fdb88d41be31b" translate="yes" xml:space="preserve">
          <source>The difference is that &amp;lsquo;image/*&amp;rsquo; embeds &amp;lsquo;image/.tempfile&amp;rsquo; while &amp;lsquo;image&amp;rsquo; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f694bd36bf5619a0472bfb05ef008949d8b1c4" translate="yes" xml:space="preserve">
          <source>The differences between WalkDirFunc compared to filepath.WalkFunc are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">La dirección de un canal está indicada por una de estas constantes.</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">La dirección de un tipo de canal se indica mediante una máscara de bits que incluye una o ambas de las siguientes constantes.</target>
        </trans-unit>
        <trans-unit id="b6be0a4961d7acbc941fa11a19835445036b49c8" translate="yes" xml:space="preserve">
          <source>The directive must immediately precede a line containing the declaration of a single variable. Only blank lines and &amp;lsquo;//&amp;rsquo; line comments are permitted between the directive and the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee9b912ab49812886d0cf5f9ad11f8fdfc055f4" translate="yes" xml:space="preserve">
          <source>The directory and file are joined with Join, which may clean the directory name: if Walk is called with the root argument &quot;x/../dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;, not &quot;x/../dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">No se garantiza que el directorio exista ni que tenga permisos de acceso.</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">La documentación para http.Request.Write detalla los campos de solicitud que se incluyen en el vertedero.</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">La documentación aquí se centra en las características de seguridad del paquete.Para obtener información sobre cómo programar las plantillas en sí,consulte la documentación de texto/plantilla.</target>
        </trans-unit>
        <trans-unit id="155a6f0a50ad424a0f77dec85fedb05aad3e6814" translate="yes" xml:space="preserve">
          <source>The driver interface has evolved over time. Drivers should implement Connector and DriverContext interfaces. The Connector.Connect and Driver.Open methods should never return ErrBadConn. ErrBadConn should only be returned from Validator, SessionResetter, or a query method if the connection is already in an invalid (e.g. closed) state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">Las primeras entradas del índice son los índices de los campos incrustados atravesados implícitamente para llegar de (el tipo de)x a f,a partir de la profundidad de incrustación 0.</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">Las primeras entradas del índice son los índices de los campos estructurales incrustados atravesados para llegar a la entrada encontrada,comenzando en la profundidad 0.</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">La forma codificada es:</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">La codificación maneja trozos de 4 bytes,utilizando una codificación especial para el último fragmento,por lo que la codificación no es apropiada para su uso en bloques individuales de un gran flujo de datos.Usa NewEncoder()en su lugar.</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">La codificación de cada campo de estructura puede ser personalizada por la cadena de formato almacenada bajo la clave &quot;json&quot; en la etiqueta del campo de estructura.La cadena de formato da el nombre del campo,posiblemente seguido de una lista de opciones separadas por comas.El nombre puede estar vacío a fin de especificar opciones sin anular el nombre de campo predeterminado.</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">La codificación acopla la salida a un múltiplo de 4 bytes,por lo que la codificación no es apropiada para su uso en bloques individuales de un gran flujo de datos.Utilice NewEncoder()en su lugar.</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">La codificación acopla la salida a un múltiplo de 8 bytes,por lo que la codificación no es apropiada para su uso en bloques individuales de un gran flujo de datos.Utilice NewEncoder()en su lugar.</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">Todo el archivo de prueba se presenta como ejemplo cuando contiene una sola función de ejemplo,al menos otra función,tipo,variable o declaración constante,y ninguna función de prueba o de referencia.</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">Los valores del entorno pueden ser un URL completo o un &quot;host[:port]&quot;,en cuyo caso se asume el esquema &quot;http&quot;.Se devuelve un error si el valor es de una forma diferente.</target>
        </trans-unit>
        <trans-unit id="118f5185e20d76d2e409557c089e1ce07b52abd5" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that Walk will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause Walk to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282f6346653700d9616b9fe704e3acbbfd78027c" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that WalkDir will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">El tipo de interfaz incorporada de error es la interfaz convencional para representar una condición de error,en la que el valor nulo representa la ausencia de error.</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">El error es EOF sólo si no se han leído bytes.Si un EOF ocurre después de leer algunos pero no todos los bytes,la lectura devuelve ErrUnexpectedEOF.</target>
        </trans-unit>
        <trans-unit id="eeed3acdc77455956d53c59d08490cc51e5c519c" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how Walk continues. If the function returns the special value SkipDir, Walk skips the current directory (path if info.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, Walk stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdf1212e16d5b6273e524308d0d3b1c562326fa" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how WalkDir continues. If the function returns the special value SkipDir, WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b8936240ed1387970343e072546b9e5c4ce38c" translate="yes" xml:space="preserve">
          <source>The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">Los errores que devuelve ParseFloat tienen el tipo concreto *NumError e incluyen err.Num=s.</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">Los errores que devuelve ParseInt tienen un tipo concreto *NumError e incluyen err.Num=s.Si s está vacía o contiene dígitos inválidos,err.Err=ErrSyntax y el valor devuelto es 0;si el valor correspondiente a s no puede ser representado por un entero con signo del tamaño dado,err.Err=ErrRange y el valor devuelto es el máximo entero de magnitud del bitSize y el signo apropiados.</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">El método exacto de división de un binario en objetos separados es un detalle interno del formato de la tabla de símbolos.</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">El ejemplo ejecutable de Time.Format demuestra el funcionamiento de la cadena de diseño en detalle y es una buena referencia.</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">La traza de ejecución captura una amplia gama de eventos de ejecución como la creación/bloqueo/desbloqueo de gorutitas,entrada/salida/bloqueo de llamadas al sistema,eventos relacionados con el GC,cambios de tamaño de la pila,arranque/parada del procesador,etc.En la mayoría de los eventos se captura una marca de tiempo precisa de nanosegundos y un rastro de la pila.El rastro generado puede ser interpretado usando &quot;go tool trace&quot;.</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">Los conocidos prefijos de configuración de base 0b (binario),0o y 0 (octal)y 0x (hexadecimal)se aceptan cuando se escanean números enteros sin formato o con el verbo %v,al igual que los guiones bajos que separan los dígitos.</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">La semántica del campo difiere ligeramente entre el uso del cliente y el del servidor.Además de las notas sobre los campos que se indican a continuación,véase la documentación de Request.Write y RoundTripper.</target>
        </trans-unit>
        <trans-unit id="055e51145f588ea85435a4c1863b09a1b1141496" translate="yes" xml:space="preserve">
          <source>The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">Los datos del archivo pueden entonces ser leídos en una rebanada de bytes.Leer y escribir toman sus conteos de bytes de la longitud de la rebanada del argumento.</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">El paquete filepath utiliza barras de avance o retroceso,dependiendo del sistema operativo.Para procesar rutas como las URL que siempre usan barras inclinadas hacia adelante,independientemente del sistema operativo,vea el paquete de rutas.</target>
        </trans-unit>
        <trans-unit id="44d9396e877785e7c01e9d43d99cf0cdefb65dc4" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47cce3bdf876fa4c8fd7554f61be344c06ff401" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">El finalizador está programado para ejecutarse en algún momento arbitrario después de que el programa ya no pueda alcanzar el objeto al que apunta.No hay garantía de que los finalizadores se ejecuten antes de que salga un programa,por lo que normalmente sólo son útiles para liberar los recursos no memoria asociados a un objeto durante un programa de larga duración.Por ejemplo,un objeto os.File podría utilizar un finalizador para cerrar el descriptor de archivos del sistema operativo asociado cuando un programa descarta un archivo os.File sin llamar a Close,pero sería un error depender de un finalizador para eliminar un búfer de E/S en memoria,como un bufio.Writer,porque el búfer no se eliminaría al salir del programa.</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">La primera llamada a ReadContinuedLine devolverá &quot;Línea 1 continuada...&quot; y la segunda devolverá &quot;Línea 2&quot;.</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">La primera llamada almacenará la información actual del usuario.Las llamadas siguientes devolverán el valor almacenado en caché y no reflejarán los cambios del usuario actual.</target>
        </trans-unit>
        <trans-unit id="da786a1e6a510514415594e5971ba9d3b0ef0c66" translate="yes" xml:space="preserve">
          <source>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">El primer paso para hacer un perfil de un programa Go es habilitar el perfil.El soporte para el perfil de los puntos de referencia construidos con el paquete de pruebas estándar está incorporado en la prueba de Go.Por ejemplo,el siguiente comando ejecuta los benchmarks en el directorio actual y escribe los perfiles de la CPU y la memoria en cpu.prof y mem.prof:</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">La primera vez que se llame a la función para una determinada traza,todos los campos excepto el de PC serán 0.La función debe rellenar los demás campos si es posible,poniéndolos a 0/nulo si la información no está disponible.El campo Data puede ser utilizado para almacenar cualquier información útil a través de las llamadas.El campo More debe ser puesto a no cero si hay más información para este PC,cero en caso contrario.Si se ajusta Más a un valor distinto de cero,se volverá a llamar a la función con el mismo PC,y puede devolver información diferente (esto está pensado para su uso con funciones en línea).Si Más es cero,se llamará a la función con el siguiente valor de PC en la traza.Cuando se complete el rastreo,se llamará la función una vez más con el PC puesto a cero;esto puede utilizarse para liberar cualquier información.Cada llamada dejará los campos de la estructura establecidos con los mismos valores que tenían al regresar,excepto el campo PC cuando el campo Más es cero.La función no debe conservar una copia del puntero de la estructura entre las llamadas.</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">La función Errorf del paquete fmt nos permite usar las características de formato del paquete para crear mensajes de error descriptivos.</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">Las siguientes variables de entorno ($name o %name%,según el sistema operativo del host)controlan el comportamiento en tiempo de ejecución de los programas Go.Los significados y el uso pueden cambiar de una versión a otra.</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">El siguiente ejemplo muestra cómo mantener una estructura de datos escalable y de lectura frecuente,pero que se actualiza con poca frecuencia,utilizando el lenguaje de copia sobre escritura.</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">El siguiente ejemplo muestra cómo usar Value para las actualizaciones periódicas de la configuración del programa y la propagación de los cambios a los goroutines trabajadores.</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">Se permiten los siguientes formularios:</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">Actualmente se admiten los siguientes tipos clave:*rsa.PrivateKey,*ecdsa.PrivateKey y ed25519.PrivateKey.Los tipos de claves no admitidos dan lugar a un error.</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">Actualmente se admiten los siguientes tipos clave:*rsa.PublicKey,*ecdsa.PublicKey y ed25519.PublicKey.Los tipos de claves no soportados dan lugar a un error.</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">Las siguientes pautas relacionadas con Pointer son válidas.El código que no utilice estos patrones es probable que sea inválido hoy o que se vuelva inválido en el futuro.Incluso los patrones válidos de abajo vienen con importantes advertencias.</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">La siguiente tabla captura las capacidades de cada formato:</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">Las siguientes etiquetas en los campos de estructura tienen un significado especial para Unmarshal:</target>
        </trans-unit>
        <trans-unit id="b74a12e0ee03ebdd96a1e5698ef65e80645b4c11" translate="yes" xml:space="preserve">
          <source>The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">El formato fmt es uno de 'b' (-ddddp &amp;plusmn; ddd, un exponente binario), 'e' (-d.dddde &amp;plusmn; dd, un exponente decimal), 'E' (-d.ddddE &amp;plusmn; dd, un exponente decimal) ), 'f' (-ddd.dddd, sin exponente), 'g' ('e' para exponentes grandes, 'f' en caso contrario), 'G' ('E' para exponentes grandes, 'f' en caso contrario), ' x '(-0xd.ddddp &amp;plusmn; ddd, una fracci&amp;oacute;n hexadecimal y exponente binario), o' X '(-0Xd.ddddP &amp;plusmn; ddd, una fracci&amp;oacute;n hexadecimal y exponente binario).</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">Los formatos 2,_2 y 02 son sin acolchar,acolchado espacial y día del mes sin acolchar.Los formatos __2 y 002 son acolchados con espacio y cero acolchados de tres caracteres para el día del año;no hay un formato de día del año sin acolchar.</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">El carácter de alimentación de la forma actúa como una nueva línea pero también termina todas las columnas de la línea actual (efectivamente llamando a Flush).Las celdas terminadas por tabulaciones en la siguiente línea inician nuevas columnas.A menos que se encuentren dentro de una etiqueta HTML o dentro de un segmento de texto escapado,los caracteres de alimentación de formulario aparecen como nuevas líneas en la salida.</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">La función nunca se llama con una porción de datos vacía a menos que atEOF sea cierto.Sin embargo,si atEOF es verdadero,los datos pueden no estar vacíos y,como siempre,contienen texto sin procesar.</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">La función puede volver antes (antes de que se escriba el resultado completo)y devolver un error de formato,por ejemplo debido a una AST incorrecta.</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">La función entra en pánico si la interfaz proporcionada no es una rebanada.</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">La funci&amp;oacute;n entra en p&amp;aacute;nico si z &amp;lt;0. El valor de z no est&amp;aacute; definido en ese caso.</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">Las funciones de este paquete permiten que un programa cambie la forma en que los programas Go manejan las señales.</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">La interfaz fundamental se llama Imagen.Una imagen contiene colores,que se describen en el paquete imagen/color.</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">El tiempo de ejecución de GC impone un límite de 64 kB en los tipos de elementos del canal.Si el tamaño de t es igual o supera este límite,ChanOf entra en pánico.</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">La forma general representada es:</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">El archivo gzip almacena un encabezado que da metadatos sobre el archivo comprimido.Ese encabezado se expone como los campos de las estructuras del escritor y el lector.</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">El manejador es típicamente nulo,en cuyo caso se utiliza el DefaultServeMux.</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">El manejo de los espacios y las nuevas líneas difiere del de la familia scanf de C:en C,las nuevas líneas se tratan como cualquier otro espacio,y nunca es un error cuando una serie de espacios en la cadena de formato no encuentra espacios para consumir en la entrada.</target>
        </trans-unit>
        <trans-unit id="1093dd8291a3801884d5894ab223242420be1682" translate="yes" xml:space="preserve">
          <source>The hash functions are collision-resistant but not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eef6c0a2cccc47289259f60f06bd6983ba13a4d" translate="yes" xml:space="preserve">
          <source>The hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be9b697fdd2e64517c87254bb1809a8bac3a286" translate="yes" xml:space="preserve">
          <source>The hash value of a given byte sequence is consistent within a single process, but will be different in different processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">El formato de volcado de pila se define en &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">El perfil del montón informa de las estadísticas de la recogida de basura más reciente;elude la asignación más reciente para evitar que el perfil se desvíe de los datos en vivo y se dirija hacia la basura.Si no ha habido ninguna recogida de basura,el perfil de pila informa de todas las asignaciones conocidas.Esta excepción ayuda principalmente en los programas que se ejecutan sin recogida de basura habilitada,normalmente con fines de depuración.</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">El perfil de pila rastrea tanto los centros de asignación para todos los objetos vivos en la memoria de la aplicación como para todos los objetos asignados desde el inicio del programa.Los flags -inuse_space,-inuse_objects,-alloc_space y -alloc_objects de Pprof seleccionan qué se debe visualizar,por defecto -inuse_space (objetos activos,escalados por tamaño).</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">Tanto el transporte como el servidor del paquete http permiten automáticamente el soporte de HTTP/2 para configuraciones simples.Para habilitar el HTTP/2 para configuraciones más complejas,para usar características de HTTP/2 de nivel inferior,o para usar una versión más reciente del paquete http2 de Go,importe &quot;golang.org/x/net/http2&quot; directamente y use sus funciones ConfigureTransport y/o ConfigureServer.La configuración manual de HTTP/2 a través del paquete golang.org/x/net/http2 tiene prioridad sobre el soporte HTTP/2 incorporado en el paquete net/http.</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">La identificación de las direcciones unicast mundiales utiliza la identificación del tipo de dirección según se define en las normas RFC 1122,RFC 4632 y RFC 4291,con la excepción de las direcciones de difusión dirigidas a IPv4.Devuelve verdadero incluso si la ip está en el espacio de direcciones privadas de IPv4 o en el espacio de direcciones unicast locales de IPv6.</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">La función de imagen incorporada devuelve la parte imaginaria del complejo número c.El valor de retorno será de tipo de punto flotante correspondiente al tipo de c.</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">La implementación compila un códec personalizado para cada tipo de datos de la corriente y es más eficiente cuando se utiliza un único codificador para transmitir una corriente de valores,amortizando el costo de la compilación.</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">La implementación fn puede asumir que el argumento Value slice tiene el número y el tipo de argumentos dados por tipo.Si typ describe una función variádica,el Valor final es en sí mismo una rebanada que representa los argumentos variádicos,como en el cuerpo de una función variádica.La rebanada de Valor resultante devuelta por fn debe tener el número y el tipo de resultados dados por typ.</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">La implementación es suficiente para el HTTP (RFC 2388)y los cuerpos multipartes generados por los navegadores populares.</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">La aplicación proporciona filtros que se descomprimen durante la lectura y se comprimen durante la escritura.Por ejemplo,para escribir datos comprimidos en un buffer:</target>
        </trans-unit>
        <trans-unit id="624abcf8f99d9c1ecd5f126ae0b1b1d2736d4655" translate="yes" xml:space="preserve">
          <source>The info argument is the fs.FileInfo for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">El flujo de entrada consta de valores JSON b&amp;aacute;sicos (bool, string, number y null) junto con delimitadores [] {} de tipo Delim para marcar el inicio y el final de matrices y objetos. Se eliminan las comas y los dos puntos.</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">El texto de entrada de una plantilla es un texto codificado en UTF-8 en cualquier formato.Las &quot;acciones&quot; -evaluaciones de datos o estructuras de control-están delimitadas por &quot;{{&quot; y &quot;}}&quot;;todo el texto fuera de las acciones se copia en la salida sin cambios.Excepto las cadenas sin procesar,las acciones pueden no abarcar las nuevas líneas,aunque los comentarios sí.</target>
        </trans-unit>
        <trans-unit id="4540c375047525b02ad242a07ddc447e593cb543" translate="yes" xml:space="preserve">
          <source>The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba307a7ab47ab6e6c8f50d8bbcb53f28f406fab" translate="yes" xml:space="preserve">
          <source>The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">El nombre de la clave se usará si es una cadena no vacía que consista sólo en letras,dígitos y puntuación ASCII,excepto las comillas,la barra invertida y la coma.</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">Las llaves deben estar en forma canónica,como las devuelve CanonicalHeaderKey.</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">El parámetro de la etiqueta puede contener datos arbitrarios que no se cifrarán,pero que dan un contexto importante al mensaje.Por ejemplo,si se utiliza una clave pública determinada para descifrar dos tipos de mensajes,podrían utilizarse valores de etiqueta distintos para garantizar que un texto cifrado para un propósito no pueda ser utilizado para otro por un atacante.Si no se requiere,puede estar vacío.</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">El parámetro de la etiqueta debe coincidir con el valor dado al cifrar.Ver EncryptOAEP para más detalles.</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">La última entrada del índice es el campo o índice del método en el tipo (posiblemente incrustado)en el que se encontró la entrada:</target>
        </trans-unit>
        <trans-unit id="4b9b3d3444da612bde04769b5c20561ed18e861d" translate="yes" xml:space="preserve">
          <source>The legacy Common Name field is ignored unless it's a valid hostname, the certificate doesn't have any Subject Alternative Names, and the GODEBUG environment variable is set to &quot;x509ignoreCN=0&quot;. Support for Common Name is deprecated will be entirely removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">La función de lente incorporada devuelve la longitud de v,según su tipo:</target>
        </trans-unit>
        <trans-unit id="37c7e993d252a1780b2d17b25f28b15858ed3005" translate="yes" xml:space="preserve">
          <source>The less function must satisfy the same requirements as the Interface type's Less method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">El límite controla el número de hilos del sistema operativo,no el número de goroutines.Un programa Go crea un nuevo hilo sólo cuando un goroutino está listo para ejecutarse pero todos los hilos existentes están bloqueados en las llamadas del sistema,llamadas cgo,o están bloqueados a otros goroutines debido al uso del runtime.LockOSThread.</target>
        </trans-unit>
        <trans-unit id="b7d62826dea7a7db650a9558cf682cb6d6d5b0e1" translate="yes" xml:space="preserve">
          <source>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">La lista de posibles tipos de objetos.</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">La lista de fichas.</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">Las operaciones de carga y almacenamiento,implementadas por las funciones LoadT y StoreT,son los equivalentes atómicos de &quot;return *addr&quot; y &quot;*addr=val&quot;.</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">La función de búsqueda se llama cada vez que el importador resultante necesita resolver una ruta de importación.En este modo,el importador sólo puede ser invocado con rutas de importación canónicas (no relativas o absolutas);se supone que la traducción a las rutas de importación canónicas la realiza el cliente del importador.</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">Por lo tanto, el bit bajo es an&amp;aacute;logo a un bit de signo, pero convertirlo en el bit de complemento garantiza que el entero negativo m&amp;aacute;s grande no sea un caso especial. Por ejemplo, -129 = ^ 128 = (^ 256 &amp;gt;&amp;gt; 1) codifica como (FE 01 01).</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">El principal caso de uso es encontrar recursos ubicados en relación con un ejecutable.</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">La función &quot;make built-in&quot; asigna e inicializa un objeto de tipo &quot;slice&quot;,&quot;map&quot; o &quot;chan&quot; (solamente).Como nuevo,el primer argumento es un tipo,no un valor.A diferencia de new,el tipo de retorno de make es el mismo que el tipo de su argumento,no un puntero a él.La especificación del resultado depende del tipo:</target>
        </trans-unit>
        <trans-unit id="38a5e445a42e339cecb3a2e57e70485eff805e93" translate="yes" xml:space="preserve">
          <source>The map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the MapFile.Mode's ModeDir bit; this may be necessary for detailed control over the directory's FileInfo or to create an empty directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">El significado de los parámetros fset,pkg y pos es el mismo que en CheckExpr.Se devuelve un error si expr no puede ser analizado con éxito,o si el expr AST resultante no puede ser revisado.</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">El mensaje no debe ser más largo que la longitud del módulo público menos el doble de la longitud del hash,menos otros 2.</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">El método para resolver los nombres de dominio,ya sea indirectamente con funciones como Dial o directamente con funciones como LookupHost y LookupAddr,varía según el sistema operativo.</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">El primer argumento del método representa los argumentos proporcionados por el llamador;el segundo argumento representa los parámetros de resultado que deben devolverse al llamador.El valor de retorno del método,si no es nulo,se pasa como una cadena que el cliente ve como creada por errores.Si se devuelve un error,el parámetro de respuesta no se devolverá al cliente.</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">Los métodos deben comportarse de la misma manera que los de un *os.File.</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">Por lo tanto,el código fuente mínimo para un paquete de sólo binario era:</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">El elemento mínimo en el árbol es la raíz,en el índice 0.</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">El parámetro de modo controla la cantidad de texto fuente analizado y otras funciones opcionales del analizador.La información de posición se registra en el conjunto de archivos fset,que no debe ser nulo.</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">Los valores de mes,día,hora,min,s y nsec pueden estar fuera de sus rangos habituales y se normalizarán durante la conversión.Por ejemplo,el 32 de octubre se convierte en el 1 de noviembre.</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">Las conversiones numéricas más comunes son Atoi (cadena a int)e Itoa (int a cadena).</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">El uso más común de este patrón es acceder a los campos de una estructura o elementos de un conjunto:</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">El parámetro msg debe ser un correo electrónico tipo RFC 822 con encabezados primero,una línea en blanco,y luego el cuerpo del mensaje.Las líneas de msg deberían ser CRLF terminadas.Las cabeceras de msg deberían incluir normalmente campos como &quot;From&quot;,&quot;To&quot;,&quot;Subject&quot;,y &quot;Cc&quot;.El envío de mensajes &quot;CCO&quot; se realiza incluyendo una dirección de correo electrónico en el parámetro to pero sin incluirla en los encabezados msg.</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">El nombre de los elementos XML se toma de,en orden de preferencia:</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">La convención de nombres para declarar ejemplos para el paquete,una función F,un tipo T y el método M en el tipo T son:</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">Los paquetes net,net/http y crypto/tls también se refieren a las variables de depuración en GODEBUG.Vea la documentación de esos paquetes para más detalles.</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">El paquete net/http/cookiejar proporciona una implementación de CookieJar.</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">El paquete net/rpc está congelado y no acepta nuevas características.</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">La red debe ser &quot;tcp&quot;,&quot;tcp4&quot;,&quot;tcp6&quot;,&quot;unix&quot; o &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">La red debe ser &quot;udp&quot;,&quot;udp4&quot;,&quot;udp6&quot;,&quot;unixgram&quot;,o un transporte IP.Los transportes IP son &quot;ip&quot;,&quot;ip4&quot; o &quot;ip6&quot; seguidos de dos puntos y un número de protocolo literal o un nombre de protocolo,como en &quot;ip:1&quot; o &quot;ip:icmp&quot;.</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">La red debe ser &quot;unix&quot; o &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">La red debe ser &quot;unixgram&quot;.</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">La red debe ser un nombre de red TCP.</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">La red debe ser un nombre de red TCP;ver func Dial para más detalles.</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">La red debe ser un nombre de red UDP.</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">La red debe ser un nombre de red UDP;ver func Dial para más detalles.</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">La red debe ser un nombre de red Unix.</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">La red debe ser un nombre de red Unix;ver func Dial para más detalles.</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">La red debe ser un nombre de red IP.</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">La red debe ser un nombre de red IP;ver func Dial para más detalles.</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">El nuevo manejador llama a h.ServeHTTP para manejar cada solicitud,pero si una llamada se prolonga más allá de su límite de tiempo,el manejador responde con un error de Servicio No Disponible 503 y el mensaje dado en su cuerpo.(Si el msg está vacío,se enviará un mensaje por defecto adecuado.)Después de tal tiempo límite,escribe por h a su ResponseWriter devolverá ErrHandlerTimeout.</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">La nueva función incorporada asigna la memoria.El primer argumento es un tipo,no un valor,y el valor devuelto es un puntero a un nuevo valor cero asignado de ese tipo.</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">El tipo de nodo debe ser *ast.File,*printer.CommentedNode,[]ast.Decl,[]ast.Stmt,o asignación-compatible con ast.Expr,ast.Decl,ast.Spec,o ast.Stmt.Node no modifica el nodo.Las importaciones no se ordenan para los nodos que representan archivos fuente parciales (por ejemplo,si el nodo no es un *ast.File o un *printer.CommentedNode que no envuelve un *ast.File).</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">El código no-Go no debería cambiar la máscara de la señal en ningún hilo creado por el tiempo de ejecución de Go.Si el código no-Go inicia nuevos hilos propios,puede establecer la máscara de señal como le plazca.</target>
        </trans-unit>
        <trans-unit id="67289d2a1e8eb416b3a82eb9f3e75a285c0158f6" translate="yes" xml:space="preserve">
          <source>The number represented by s must be of the form N, Ni, or N&amp;plusmn;Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the &amp;plusmn;. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca31cdbe931eb86d33c507cac75f440d062f995" translate="yes" xml:space="preserve">
          <source>The ok result is false if the -timeout flag indicates &amp;ldquo;no timeout&amp;rdquo; (0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">Los únicos valores de la señal que se garantiza que están presentes en el paquete os en todos los sistemas son os.Interrumpir (enviar al proceso una interrupción)y os.Matar (obligar al proceso a salir).En Windows,el envío de os.Interrupt a un proceso con os.Process Signal no está implementado;devolverá un error en lugar de enviar una señal.</target>
        </trans-unit>
        <trans-unit id="ff422009eedfd53fa7602cbdd94de8292f5f25ce" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS #1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">La especificación original para el cifrado y las firmas con RSA es PKCS#1 y los términos &quot;cifrado RSA&quot; y &quot;firmas RSA&quot; por defecto se refieren a PKCS#1 versión 1.5.Sin embargo,esa especificación tiene fallas y los nuevos diseños deben utilizar la versión dos,normalmente llamada sólo OAEP y PSS,cuando sea posible.</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">El formato original del alquitrán se introdujo en Unix V7.Desde entonces,ha habido múltiples formatos que compiten entre sí tratando de estandarizar o ampliar el formato V7 para superar sus limitaciones.Los formatos más comunes son los formatos USTAR,PAX y GNU,cada uno con sus propias ventajas y limitaciones.</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">La interfaz del os está pensada para ser uniforme en todos los sistemas operativos.Las características que no están generalmente disponibles aparecen en el paquete específico del sistema syscall.</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Los demás métodos de notificación,como las variaciones de Log y Error,pueden ser llamados simultáneamente desde múltiples goroutines.</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">La salida de un comando será un valor o dos valores,el segundo de los cuales tiene error de tipo.Si ese segundo valor está presente y se evalúa a no cero,la ejecución termina y el error se devuelve al llamador de Ejecutar.</target>
        </trans-unit>
        <trans-unit id="8552b51b4b43726af9d21d2953952aab9f9eccb4" translate="yes" xml:space="preserve">
          <source>The package also exports a handler that serves execution trace data for the &quot;go tool trace&quot; command. To collect a 5-second execution trace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">El paquete también se ejecuta y verifica el código de ejemplo.Las funciones de ejemplo pueden incluir un comentario de línea final que comienza con &quot;Output:&quot; y se compara con la salida estándar de la función cuando se ejecutan las pruebas.(La comparación no tiene en cuenta el espacio de entrada y salida.)Estos son ejemplos de un ejemplo:</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">El paquete se marca como completo si no hay errores,de lo contrario está incompleto.Ver Config.Error para controlar el comportamiento en presencia de errores.</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">A veces el paquete sólo se importa por el efecto secundario de registrar su manejador de HTTP y las variables anteriores.Para usarlo de esta manera,enlaza este paquete a tu programa:</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">El paquete se especifica mediante una lista de archivos *ast.Files y el correspondiente conjunto de archivos,y la ruta del paquete con la que se identifica el mismo.La ruta limpia no debe estar vacía o con puntos (&quot;.&quot;).</target>
        </trans-unit>
        <trans-unit id="385716c34a6382063c2f2e6bebfaff89eee0a50e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. &quot;go/build&quot;.Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">Por lo general,el paquete sólo se importa por el efecto secundario de registrar sus manejadores de HTTP.Todas las rutas manejadas comienzan con /debug/pprof/.</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">El paquete utiliza el algoritmo Elastic Tabstops que se describe en &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">El paquete provee:</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">Los paquetes golang.org/x/net/ipv4 y golang.org/x/net/ipv6 pueden utilizarse para manipular las opciones de sockets de nivel IP en oob.</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">La función de pánico incorporada detiene la ejecución normal de la gorutita actual.Cuando una función F llama al pánico,la ejecución normal de F se detiene inmediatamente.Cualquier función cuya ejecución fue aplazada por F se ejecuta de la manera habitual,y luego F vuelve a su llamador.Para el llamador G,la invocación de F se comporta entonces como una llamada al pánico,terminando la ejecución de G y ejecutando cualquier función diferida.Esto continúa hasta que todas las funciones de la gorrona ejecutora se han detenido,en orden inverso.En ese momento,el programa se termina con un código de salida distinto de cero.Esta secuencia de terminación se llama pánico y puede ser controlada por la función incorporada de recuperación.</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">Las funciones de análisis devuelven el tipo más ancho (float64,int64,y uint64),pero si el argumento size especifica un ancho más estrecho,el resultado puede convertirse a ese tipo más estrecho sin pérdida de datos:</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">El analizador acepta un lenguaje más amplio que el permitido sintácticamente por la especificación Go,por simplicidad y por una mayor robustez en presencia de errores de sintaxis.Por ejemplo,en las declaraciones de métodos,el receptor se trata como una lista de parámetros ordinaria y,por lo tanto,puede contener múltiples entradas cuando la especulación permite exactamente una.Por consiguiente,el campo correspondiente en el campo AST (ast.FuncDecl.Recv)no se limita a una sola entrada.</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">La ruta y el host se usan sin cambios para las solicitudes de CONNECT.</target>
        </trans-unit>
        <trans-unit id="623d365b943b6e8d95767b246041604e7f8848f2" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to Walk as a prefix. That is, if Walk is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147552bd39d536fc2b6830c38de35cab2fd698e6" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to WalkDir as a prefix. That is, if WalkDir is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">El paquete de rutas sólo debe ser usado para rutas separadas por barras oblicuas,como las rutas en los URLs.Este paquete no se ocupa de las rutas de Windows con letras de unidad o barras invertidas;para manipular las rutas del sistema operativo,utilice el paquete path/filepath.</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">El directorio pkg/contiene los objetos del paquete instalados.Como en el árbol Go,cada par de sistema operativo y arquitectura de destino tiene su propio subdirectorio de pkg (pkg/GOOS_GOARCH).</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">La precisión prec controla el número de dígitos (excluyendo el exponente)impresos en los formatos &quot;e&quot;,&quot;E&quot;,&quot;f&quot;,&quot;g&quot;,&quot;G&quot;,&quot;x&quot; y &quot;X&quot;.Para &quot;e&quot;,&quot;E&quot;,&quot;f&quot;,&quot;x&quot; y &quot;X&quot;,es el número de dígitos después del punto decimal.Para &quot;g&quot; y &quot;G&quot; es el número máximo de dígitos significativos (se eliminan los ceros finales).La precisión especial -1 utiliza el menor número de dígitos necesario para que ParseFloat devuelva f exactamente.</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">La precisión prec controla el número de dígitos (excluyendo el exponente)impresos en los formatos &quot;e&quot;,&quot;E&quot;,&quot;f&quot;,&quot;g&quot;,&quot;G&quot; y &quot;x&quot;.Para &quot;e&quot;,&quot;E&quot;,&quot;f&quot; y &quot;x&quot;,es el número de dígitos después del punto decimal.Para &quot;g&quot; y &quot;G&quot; es el número total de dígitos.Una precisión negativa selecciona el menor número de dígitos decimales necesarios para identificar el valor x de forma única usando bits de mantisa x.Prec().El valor prec se ignora para los formatos 'b' y 'p'.</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">Los perfiles predefinidos pueden asignar un significado a otros valores de depuración;por ejemplo,cuando se imprime el perfil &quot;goroutine&quot;,debug=2 significa imprimir las pilas de goroutine en la misma forma que utiliza un programa Go al morir por un pánico no recuperado.</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">La función de impresión incorporada da formato a sus argumentos de forma específica para la implementación y escribe el resultado en un error estándar.La impresión es útil para el bootstrapping y la depuración;no se garantiza que permanezca en el lenguaje.</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">La función de impresión incorporada formatea sus argumentos de una forma específica de implementación y escribe el resultado en un error estándar.Siempre se añaden espacios entre los argumentos y se añade una nueva línea.Println es útil para el bootstrapping y la depuración;no se garantiza que permanezca en el lenguaje.</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">El contexto proporcionado debe ser no nulo.Si el contexto expira antes de que la conexión se complete,se devuelve un error.Una vez conectada con éxito,cualquier expiración del contexto no afectará a la conexión.</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">Las TxOpciones proporcionadas son opcionales y pueden ser nulas si se utilizan las predeterminadas.Si se utiliza un nivel de aislamiento no predeterminado que el controlador no soporta,se devolverá un error.</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">El cuerpo provisto puede ser nulo.Si el cuerpo es del tipo *bytes.Reader,*strings.Reader,o *bytes.Buffer,se establece la Request.ContentLength.</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">El código provisto debe estar en el rango de 3xx y suele ser StatusMovedPermanently,StatusFound o StatusSeeOther.</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">El contexto proporcionado se utiliza para la preparación de la declaración,no para la ejecución de la misma.</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">El contexto proporcionado se utiliza para matar el proceso (llamando a os.Process.Kill)si el contexto se hace antes de que el comando se complete por sí mismo.</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">El contexto proporcionado se utiliza hasta que la transacción se comete o se retrocede.Si el contexto se cancela,el paquete sql hará retroceder la transacción.Tx.Commit devolverá un error si se cancela el contexto proporcionado a BeginTx.</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">El contexto proporcionado se utilizará para la preparación del contexto,no para la ejecución de la declaración devuelta.La declaración devuelta se ejecutará en el contexto de la transacción.</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">La clave proporcionada debe ser comparable y no debe ser de tipo cadena o de cualquier otro tipo incorporado para evitar colisiones entre paquetes utilizando el contexto.Los usuarios de WithValue deben definir sus propios tipos de claves.Para evitar la asignación al asignar a una interfaz{},las claves de contexto suelen tener un tipo concreto struct{}.Alternativamente,el tipo estático de las variables de las claves de contexto exportadas debería ser un puntero o una interfaz.</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">El detector de carreras mata el programa si excede los 8192 goroutines concurrentes,así que ten cuidado al hacer pruebas paralelas con el conjunto de la bandera de carreras.</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">El parámetro rand se utiliza como fuente de entropía para asegurar que al cifrar dos veces el mismo mensaje no se obtenga el mismo texto cifrado.</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">El parámetro aleatorio se utiliza como fuente de entropía para asegurar que al cifrar dos veces el mismo mensaje no se obtenga el mismo texto cifrado.</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">El par&amp;aacute;metro aleatorio, si no es nulo, se utiliza para cegar la operaci&amp;oacute;n de clave privada y evitar la sincronizaci&amp;oacute;n de los ataques de canal lateral. El cegamiento es puramente interno a esta funci&amp;oacute;n: los datos aleatorios no tienen por qu&amp;eacute; coincidir con los que se utilizan al cifrar.</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">El rawurl puede ser relativo (un camino,sin un huésped)o absoluto (comenzando con un esquema).Intentar analizar un nombre de host y una ruta sin un esquema no es válido pero puede no devolver necesariamente un error,debido a las ambigüedades del análisis.</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">Las mitades de lectura y escritura de la conexión se serializan de forma independiente,por lo que no se requiere ningún enclavamiento.Sin embargo,se puede acceder a cada mitad de forma simultánea,por lo que la implementación de conn debería proteger contra lecturas o escrituras simultáneas.</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">La función real incorporada devuelve la parte real del complejo número c.El valor de retorno será del tipo de punto flotante correspondiente al tipo de c.</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">Los formatos reconocidos de día de la semana son &quot;Lun&quot; y &quot;Lunes&quot;.Los formatos reconocidos de mes son &quot;Ene&quot; y &quot;Enero&quot;.</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">La función de recuperación incorporada permite a un programa manejar el comportamiento de un gorrión en pánico.Ejecutar una llamada de recuperación dentro de una función diferida (pero no cualquier función llamada por ella)detiene la secuencia de pánico restaurando la ejecución normal y recupera el valor de error pasado a la llamada de pánico.Si se llama a recuperar fuera de la función diferida no se detendrá la secuencia de pánico.En este caso,o cuando la gorutita no está entrando en pánico,o si el argumento suministrado para entrar en pánico era nulo,la recuperación devuelve nulo.Por lo tanto,el valor de retorno de la recuperación informa si el gorotón está entrando en pánico.</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">La implementación de regexp proporcionada por este paquete está garantizada para funcionar en tiempo lineal en el tamaño de la entrada.(Esta es una propiedad que no está garantizada por la mayoría de las implementaciones de código abierto de expresiones regulares).Para más información sobre esta propiedad,véase</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">El regionType se utiliza para clasificar las regiones,por lo que sólo debería haber un puñado de tipos de regiones únicas.</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">La sintaxis de expresión regular que entiende este paquete al analizar la bandera de Perl es la siguiente.Partes de la sintaxis pueden ser desactivadas pasando banderas alternas al parseo.</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">Los patrones restantes enumeran las únicas conversiones válidas de uintptr a Pointer.</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">Las señales restantes son señales asincrónicas.No se activan por errores de programa,sino que se envían desde el núcleo o desde algún otro programa.</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">La representación de los tipos se describe a continuación.Cuando se define un tipo en una conexión dada entre un codificador y un decodificador,se le asigna un id de tipo entero con signo.Cuando se llama Encoder.Encode(v),se asegura de que hay un id asignado para el tipo de v y todos sus elementos y luego envía el par (typeid,codificado-v)donde typeid es el id del tipo codificado de v y codificado-v es la codificación de gob del valor v.</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">El cuerpo de la solicitud,si no es nulo,será cerrado por el transporte subyacente,incluso por errores.</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">La decisión de la resolución puede ser anulada estableciendo el valor de netdns de la variable de entorno GODEBUG (ver tiempo de ejecución del paquete)para ir o cgo,como en:</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">El resto del comentario de este paquete puede saltarse en la primera lectura;incluye los detalles necesarios para comprender los contextos de fuga y los mensajes de error.La mayoría de los usuarios no necesitarán entender estos detalles.</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">En el resto de esta sección se dan los detalles precisos de cómo las operaciones utilizan relojes monótonos,pero no es necesario comprender esos detalles para utilizar este paquete.</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">El resultado de Scan es una de estas fichas o un personaje Unicode.</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">Los resultados de una prueba de referencia.</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">El *Float f devuelto es nulo y el valor de z es válido pero no definido si se reporta un error.</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">El campo Args del Cmd devuelto se construye a partir del nombre del comando seguido de los elementos de arg,por lo que arg no debe incluir el nombre del comando en sí.Por ejemplo,Command(&quot;eco&quot;,&quot;hola&quot;).Args[0]es siempre el nombre,no el camino posiblemente resuelto.</target>
        </trans-unit>
        <trans-unit id="fe921f2e96cf2be56c2bf49f4740170d8dd45071" translate="yes" xml:space="preserve">
          <source>The returned Conn, if any, will always be of type *Conn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">El DB devuelto es seguro para su uso simultáneo por múltiples goroutines y mantiene su propia reserva de conexiones ociosas.Por lo tanto,la función Abrir debería ser llamada sólo una vez.Rara vez es necesario cerrar una DB.</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">El DB devuelto es seguro para su uso simultáneo por múltiples goroutines y mantiene su propia reserva de conexiones ociosas.Por lo tanto,la función OpenDB debería ser llamada sólo una vez.Rara vez es necesario cerrar una DB.</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">El RawConn devuelto sólo admite llamar a Control.Leer y escribir devuelve un error.</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">La respuesta devuelta tendrá al menos su código de estado,encabezado,cuerpo y opcionalmente el remolque poblado.Más campos pueden ser poblados en el futuro,por lo que los llamadores no deben profundizar en el resultado de las pruebas.</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">El contexto devuelto es siempre no nulo;por defecto es el contexto de fondo.</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">La función de final devuelto se utiliza para marcar el final de la tarea.La herramienta de rastreo mide la latencia de la tarea como el tiempo entre la creación de la tarea y cuando se llama a la función final,y proporciona la distribución de la latencia por tipo de tarea.Si la función final se llama varias veces,sólo se utiliza la primera llamada en la medición de la latencia.</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">El error devuelto es nulo si el comando se ejecuta,no tiene problemas para copiar stdin,stdout y stderr,y sale con un estado de salida cero.</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">La lista devuelta no identifica la interfaz asociada;utilice Interfaces e Interfaces.</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">Las estadísticas del asignador de memoria devueltas están actualizadas desde la llamada a ReadMemStats.Esto contrasta con un perfil de pila,que es una instantánea del ciclo de recolección de basura más reciente.</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">El descriptor del archivo os.file devuelto es diferente al de la conexión.Intentar cambiar las propiedades del original usando este duplicado puede o no tener el efecto deseado.</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">El camino devuelto termina en una barra sólo si es la raíz &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">La ruta devuelta termina en una barra sólo si representa un directorio raíz,como &quot;/&quot; en Unix o &quot;C:\&quot; en Windows.</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">El perfil devuelto puede tener hasta dos ciclos de recogida de basura.Esto es para evitar que el perfil se desvíe hacia las asignaciones;debido a que las asignaciones ocurren en tiempo real pero las liberaciones se retrasan hasta que el recolector de basura realiza el barrido,el perfil sólo tiene en cuenta las asignaciones que han tenido la oportunidad de ser liberadas por el recolector de basura.</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">El trozo devuelto es el certificado en codificación DER.</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">El trozo devuelto es la solicitud de certificado en codificación DER.</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">El estado de cuenta devuelto opera dentro de la transacción y ya no puede ser utilizado una vez que la transacción ha sido comprometida o devuelta.</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">El estado de cuenta devuelto opera dentro de la transacción y se cerrará cuando la transacción haya sido comprometida o devuelta.</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">La cadena devuelta está destinada a la depuración;para una representación serializada estable,utilice t.MarshalText,t.MarshalBinary,o t.Format con una cadena de formato explícita.</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">La regla que el Título usa para los límites de las palabras no maneja adecuadamente la puntuación de Unicode.</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">El mismo Contexto puede pasar a funciones que se ejecutan en diferentes goroutines;los Contextos son seguros para su uso simultáneo por varios goroutines.</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">El segundo argumento,la cita,especifica el tipo de literal que se analiza y por lo tanto se permite el carácter de cita que se escapa.Si se establece en una sola cita,permite la secuencia y no permite que se escape.Si se establece en una cita doble,permite y rechaza la fuga.Si se establece en cero,no permite ninguna de las dos comillas y permite que los dos caracteres de las comillas aparezcan como no escapados.</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">El modelo de seguridad utilizado por este paquete asume que los autores de la plantilla son de confianza,mientras que el parámetro de datos de Execute no lo es.A continuación se proporcionan más detalles.</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">El servidor llama (para el servicio HTTP):</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">El servidor puede manejar las solicitudes en una sola conexión llamando a ServeConn.Más típicamente creará un escuchador de red y llamará a Accept o,para un escuchador HTTP,a HandleHTTP y http.Serve.</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">El conjunto de CPUs disponibles se comprueba consultando el sistema operativo al inicio del proceso.Los cambios en la asignación de CPU del sistema operativo después del inicio del proceso no se reflejan.</target>
        </trans-unit>
        <trans-unit id="a4ffb207191c8f11d25b769c7eab3f4bd62e8f7a" translate="yes" xml:space="preserve">
          <source>The set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">Las señales SIGKILL y SIGSTOP no pueden ser capturadas por un programa,y por lo tanto no pueden ser afectadas por este paquete.</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">El uso más simple de un Escáner,para leer la entrada estándar como un conjunto de líneas.</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control de CRC-32 en bytes.</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control CRC-64 en bytes.</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control SHA-1 en bytes.</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control SHA224 en bytes.</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control SHA256 en bytes.</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de control de Adler-32 en bytes.</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">El tamaño de una suma de comprobación MD5 en bytes.</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">El parámetro de salto tiene el mismo significado que el tiempo de ejecución.El salto de la llamada y controla dónde comienza el rastro de la pila.Al pasar skip=0 comienza el rastreo en la función que llama a Add.Por ejemplo,dada esta pila de ejecución:</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">El trozo devuelto por este método consiste en todas las subcadenas de s no contenidas en el trozo devuelto por FindAllString.Cuando se recurre a una expresión que no contiene metacaracteres,es equivalente a las cadenas.SplitN.</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">El paquete smtp está congelado y no acepta nuevas características.Algunos paquetes externos proporcionan más funcionalidad.Vea:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">No se garantiza que el tipo sea estable.Para un tipo estable,usa el SliceStable.</target>
        </trans-unit>
        <trans-unit id="bda42a397fbbab417ff8adfb3aa5399f5d54b818" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use SliceStable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">Los valores/tipos de origen y destino no tienen por qué corresponderse exactamente.En el caso de las estructuras,se ignorarán los campos (identificados por su nombre)que se encuentren en la fuente pero que estén ausentes de la variable receptora.Los campos que están en la variable receptora pero que faltan en el tipo o valor transmitido serán ignorados en el destino.Si un campo con el mismo nombre está presente en ambos,sus tipos deben ser compatibles.Tanto el receptor como el transmisor harán toda la indirección y la desreferenciación necesarias para convertir entre gobs y valores reales de Go.Por ejemplo,un tipo de gota que es esquemáticamente,</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">El código fuente podría incluir código Go adicional.Ese código nunca fue compilado pero sería procesado por herramientas como Godoc y podría ser útil como documentación para el usuario final.</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">La fuente:</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">El paquete de sql comprueba el valor de las fichas en el siguiente orden,deteniéndose en la primera coincidencia encontrada:Stmt.NamedValueChecker,Conn.NamedValueChecker,Stmt.ColumnConverter,DefaultParameterConverter.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">El paquete sql crea y libera conexiones automáticamente;también mantiene un pool libre de conexiones ociosas.Si la base de datos tiene el concepto de estado por conexión,dicho estado puede observarse de forma fiable dentro de una transacción (Tx)o conexión (Conn).Una vez que se llama a DB.Begin,la Tx devuelta está vinculada a una única conexión.Una vez que se llama a Commit o Rollback en la transacción,la conexión de esa transacción se devuelve al pool de conexiones inactivas de la DB.El tamaño del pool se puede controlar con SetMaxIdleConns.</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">El paquete sql se debe utilizar junto con un controlador de base de datos. Consulte &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; para obtener una lista de controladores.</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">El directorio src/contiene el código fuente.La ruta debajo de 'src' determina la ruta de importación o el nombre del ejecutable.</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">Las declaraciones preparadas para una transacción llamando a los métodos Preparar o Stmt de la transacción se cierran con la llamada a Commit o Rollback.</target>
        </trans-unit>
        <trans-unit id="7aaae34f98e3bd969409b9d4ab9b72c26d296745" translate="yes" xml:space="preserve">
          <source>The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3f26a83995cf9b083b94337323c62f8d2e679a" translate="yes" xml:space="preserve">
          <source>The stop function unregisters the signal behavior, which, like signal.Reset, may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving os.Interrupt is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">La operación de intercambio,implementada por las funciones SwapT,es el equivalente atómico de:</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">La función de simbolizador puede ser nula,en cuyo caso los resultados de la función de rastreo se mostrarán como números.Si la función de rastreo es nula,nunca se llamará a la función de simbolizador.La función de contexto puede ser nula,en cuyo caso sólo se llamará a la función de rastreo con el campo de contexto puesto a cero.Si la función de contexto es nula,entonces las llamadas de Ir a C a Ir no mostrarán un rastreo para la porción C de la pila de llamadas.</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">La función de simbolizador se llamará con un solo argumento,un puntero a una estructura:</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">La sintaxis de tales definiciones consiste en rodear cada declaración modelo con una acción de &quot;definir&quot; y &quot;terminar&quot;.</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">La sintaxis de las expresiones regulares aceptadas es la misma sintaxis general utilizada por Perl, Python y otros lenguajes. M&amp;aacute;s precisamente, es la sintaxis aceptada por RE2 y descrita en &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt; , excepto para \ C. Para obtener una descripci&amp;oacute;n general de la sintaxis, ejecute</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">El paquete del syslog está congelado y no acepta nuevas características.Algunos paquetes externos proporcionan más funcionalidad.Vea:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">La parte inferior de la tabla muestra características especializadas de cada formato,como las codificaciones de cadena admitidas,la compatibilidad con marcas de tiempo de menos de un segundo o la compatibilidad con archivos dispersos.</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">En la parte superior de la tabla se muestran los campos de cabecera,en los que cada formato informa del número máximo de bytes permitidos para cada campo de cadena y el tipo de entero utilizado para almacenar cada campo numérico (en el que las marcas de tiempo se almacenan como el número de segundos desde la época de Unix).</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">La etiqueta debe ser una que tome valores de cadena:DT_NEEDED,DT_SONAME,DT_RPATH,o DT_RUNPATH.</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">El objetivo es el RFC 7230 &quot;request-target&quot;:puede ser una ruta o un URL absoluto.Si el objetivo es un URL absoluto,se utiliza el nombre del host del URL.En caso contrario,se utiliza &quot;ejemplo.com&quot;.</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">El TaskType se utiliza para clasificar las instancias de las tareas.Las herramientas de análisis como el rastreador de ejecución Go pueden asumir que sólo hay un número limitado de tipos de tareas únicas en el sistema.</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">La plantilla</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">El paquete de prueba/rápido está congelado y no acepta nuevas características.</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">El texto devuelto de ReadLine no incluye el final de línea (&quot;\r\N&quot; o &quot;\N&quot;).No se da ninguna indicación o error si la entrada termina sin un final de línea.Llamar a UnreadByte después de ReadLine siempre des leerá el último byte leído (posiblemente un carácter perteneciente al final de línea)incluso si ese byte no forma parte de la línea devuelta por ReadLine.</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">El paquete de texto/escritura está congelado y no acepta nuevas características.</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">La base de datos de zonas horarias que necesita LoadLocation puede no estar presente en todos los sistemas,especialmente en los que no son de la marca Unix.LoadLocation busca en el directorio o en el archivo zip descomprimido llamado por la variable de entorno ZONEINFO,si existe,luego busca en las ubicaciones de instalación conocidas en los sistemas Unix,y finalmente busca en $GOROOT/lib/time/zoneinfo.zip.</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">El tiempo de espera incluye la resolución del nombre,si es necesario.Cuando se utiliza TCP,y el host en el parámetro de dirección resuelve a múltiples direcciones IP,el tiempo de espera se reparte en cada marcación consecutiva,de tal manera que a cada uno se le da una fracción apropiada del tiempo para conectarse.</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">Las herramientas que procesan los perfiles de memoria asumen que la tasa de perfil es constante a lo largo de la vida del programa e igual al valor actual.Los programas que cambian la tasa de perfil de la memoria deben hacerlo sólo una vez,lo antes posible en la ejecución del programa (por ejemplo,al principio del principal).</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">La herramienta de rastreo calcula la latencia de una tarea midiendo el tiempo entre la creación de la tarea y el final de la misma y proporciona distribuciones de latencia para cada tipo de tarea que se encuentra en el rastreo.</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">Las funciones de rastreo y contexto pueden ser llamadas desde un manejador de señales y,por lo tanto,deben utilizar únicamente funciones seguras de señales asíncronas.La función de simbolización puede ser llamada mientras el programa está fallando,y por lo tanto debe tener cuidado con el uso de la memoria.Ninguna de las funciones puede volver a llamar a Go.</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">La función de rastreo será llamada con un solo argumento,un puntero a una estructura:</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Los dos métodos Red y Cuerda devuelven convencionalmente cuerdas que pueden pasarse como argumentos a Marcar,pero la forma y el significado exacto de las cuerdas depende de la aplicación.</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">El argumento de tipo puede ser un tipo definido (Named)o un tipo de alias.También puede ser nil,de manera que el TypeName devuelto puede ser usado como argumento para NewNamed,lo que establecerá el tipo de TypeName como un efecto secundario.</target>
        </trans-unit>
        <trans-unit id="626d44cfd72353f5912709705dc90b7455988913" translate="yes" xml:space="preserve">
          <source>The type of the variable must be a string type, or a slice of a byte type, or FS (or an alias of FS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">El caso típico de uso de NewFileTransport es registrar el protocolo de &quot;archivo&quot; con un Transport,como en:</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">El sistema de archivos subyacente puede truncar o redondear los valores a una unidad de tiempo menos precisa.Si hay un error,será del tipo *PathError.</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">El mensaje de uso aparecerá en una línea separada para todo lo que no sea un banderín con un nombre de un byte.Para los banderines,se omite el tipo y si el nombre del banderín es de un byte el mensaje de uso aparece en la misma línea.El valor por defecto entre paréntesis se omite si el valor por defecto es el valor cero para el tipo.El tipo listado,aquí int,puede cambiarse colocando un nombre entre comillas en la cadena de uso del indicador;el primero de estos elementos en el mensaje se considera un nombre de parámetro para mostrar en el mensaje y las comillas se eliminan del mensaje cuando se muestran.Por ejemplo,dado</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">El valor 0xff fue elegido porque no puede aparecer en una secuencia UTF-8 válida.</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">El argumento variado controla si la función es variada.FuncOf panics si la in[len(in)-1]no representa una rebanada y variadic es verdadera.</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">Las funciones varint codifican y decodifican valores enteros simples usando una codificaci&amp;oacute;n de longitud variable; los valores m&amp;aacute;s peque&amp;ntilde;os requieren menos bytes. Para obtener una especificaci&amp;oacute;n, consulte &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">Los verbos se comportan de manera análoga a los de Printf.Por ejemplo,%x escaneará un número entero como un número hexadecimal,y %v escaneará el formato de representación por defecto para el valor.Los verbos de Printf %p y %T y las banderas#y+no están implementados.Para los valores en coma flotante y complejos,todos los verbos de formato válidos (%b %e %E %f %F %g %G %x %X y %v)son equivalentes y aceptan tanto la notación decimal como la hexadecimal (por ejemplo:&quot;2.3e+7&quot;,&quot;0x4.5p-8&quot;)y los guiones bajos que separan los dígitos (por ejemplo:&quot;3.14159_26535_89793&quot;).</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">Los verbos:</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">Las escrituras de los registros individuales están almacenadas en un buffer.Después de que todos los datos han sido escritos,el cliente debe llamar al método Flush para garantizar que todos los datos han sido remitidos al io.Writer subyacente.Cualquier error que ocurra debe ser comprobado llamando al método de error.</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">El valor cero (no inicializado)para una Flota está listo para ser usado y representa el número +0.0 exactamente,con precisión 0 y redondeando el modo ToNearestEven.</target>
        </trans-unit>
        <trans-unit id="0956e2f948a72c4e4d0d06cd6f921545906690fb" translate="yes" xml:space="preserve">
          <source>The zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, Sum64, or Seed method. For control over the seed, use SetSeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">El mapa cero está vacío y listo para ser usado.Un mapa no debe ser copiado después del primer uso.</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">El valor cero no representa ning&amp;uacute;n valor. Su m&amp;eacute;todo IsValid devuelve falso, su m&amp;eacute;todo Kind devuelve Invalid, su m&amp;eacute;todo String devuelve &quot;&amp;lt;valor no v&amp;aacute;lido&amp;gt;&quot;, y todos los dem&amp;aacute;s m&amp;eacute;todos entran en p&amp;aacute;nico. La mayor&amp;iacute;a de las funciones y m&amp;eacute;todos nunca devuelven un valor no v&amp;aacute;lido. Si lo hace, su documentaci&amp;oacute;n establece las condiciones expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">El valor cero de Pos es NoPos;no hay ningún archivo ni información de línea asociados a él,y NoPos.IsValid()es falso.NoPos es siempre más pequeño que cualquier otro valor de Pos.El valor de Posición correspondiente para NoPos es el valor cero de Posición.</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">El valor cero de una Int,Rata o Flotador corresponde a 0.Por lo tanto,los nuevos valores pueden ser declarados de la manera habitual y denotan 0 sin más inicialización:</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">El valor cero de cada campo equivale a marcar sin esa opción.Marcar con el valor cero de Dialer equivale,por lo tanto,a sólo llamar a la función Dial.</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">El valor cero del tipo &quot;Tiempo&quot; es el 1 de enero del año 1,00:00:00.000000000 UTC.Como es poco probable que esta hora aparezca en la práctica,el método IsZero ofrece una forma sencilla de detectar una hora que no ha sido inicializada explícitamente.</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">Entonces puede hacer una llamada remota:</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">Entonces usa la herramienta pprof para ver el perfil del montón:</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">Hay 16 métodos de Regexp que coinciden con una expresión regular e identifican el texto coincidente.Sus nombres se corresponden con esta expresión regular:</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">Hay muchos comandos disponibles desde la línea de comandos pprof.Los comandos comúnmente usados incluyen &quot;top&quot;,que imprime un resumen de los principales puntos calientes del programa,y &quot;web&quot;,que abre un gráfico interactivo de los puntos calientes y sus gráficos de llamada.Utilice &quot;help&quot; para obtener información sobre todos los comandos de pprof.</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">No hay etiquetas de construcción para las versiones beta o menores.</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">Hay tres tipos de anotaciones de usuario:mensajes de registro,regiones y tareas.</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">También hay un conjunto de operadores de comparación binaria definidos como funciones:</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">También existe una interfaz HTTP estándar para el perfilado de datos.Añadiendo la siguiente línea se instalarán manejadores bajo la URL /debug/pprof/para descargar perfiles en vivo:</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">También hay una interfaz HTTP estándar para rastrear los datos.Añadiendo la siguiente línea se instalará un gestor bajo la URL de /debug/pprof/trace para descargar un rastreo en vivo:</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">También hay un subconjunto de métodos que se pueden aplicar al texto leído de un RuneReader:</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">No existe un mecanismo para el plegado completo de la caja,es decir,para los caracteres que implican múltiples runas en la entrada o la salida.</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">Estos son diseños predefinidos para su uso en formato de tiempo y análisis de tiempo.El tiempo de referencia utilizado en las disposiciones es el tiempo específico:</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">Estos son los errores que pueden ser devueltos en ParseError.Err.</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">Estos asumen el decimal y el tipo Go int.</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">Estas constantes se copian del paquete de flauta,de modo que el código que importa &quot;comprimir/girar&quot; no tiene que importar también &quot;comprimir/platar&quot;.</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">Estas constantes se copian del paquete de flauta,de modo que el código que importa &quot;comprimir/zlib&quot; no tiene que importar también &quot;comprimir/placa&quot;.</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">Estas constantes hacen que FlagSet.Parse se comporte como se describe si el parse falla.</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">Estas constantes definen los modos de redondeo soportados.</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">Estos ejemplos demuestran los fundamentos de la impresión utilizando una cadena de formato.Printf,Sprintf y Fprintf toman una cadena de formato que especifica cómo dar formato a los argumentos subsiguientes.Por ejemplo,%d (lo llamamos &quot;verbo&quot;)dice que se imprima el argumento correspondiente,que debe ser un entero (o algo que contenga un entero,como un trozo de ints)en decimal.El verbo %v ('v' por 'valor')siempre da formato al argumento en su forma por defecto,tal como lo mostrarían Print o Println.El verbo especial %T ('T' para 'Tipo')imprime el tipo de argumento en lugar de su valor.Los ejemplos no son exhaustivos;ver el comentario del paquete para todos los detalles.</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">Estas banderas definen el texto que debe anteponerse a cada entrada de bitácora generada por el Logger.Los bits son o'edados juntos para controlar lo que se imprime.No hay control sobre el orden en que aparecen (el orden listado aquí)o el formato que presentan (como se describe en los comentarios).El prefijo va seguido de dos puntos sólo cuando se especifica Llongfile o Lshortfile.Por ejemplo,las banderas Ldate | Ltime (o LstdFlags)producen,</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">Estas funciones tambi&amp;eacute;n son compatibles con la funci&amp;oacute;n &amp;ldquo;Ed25519&amp;rdquo; definida en RFC 8032. Sin embargo, a diferencia de la formulaci&amp;oacute;n de RFC 8032, la representaci&amp;oacute;n de clave privada de este paquete incluye un sufijo de clave p&amp;uacute;blica para hacer m&amp;aacute;s eficientes las operaciones de firma m&amp;uacute;ltiple con la misma clave. Este paquete se refiere a la clave privada RFC 8032 como la &quot;semilla&quot;.</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">Estas funciones requieren un gran cuidado para ser usadas correctamente.Excepto en aplicaciones especiales de bajo nivel,la sincronización se realiza mejor con los canales o las instalaciones del paquete de sincronización.Comparta la memoria comunicándose;no se comunique compartiendo la memoria.</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">Estos paquetes son parte del Proyecto Go pero est&amp;aacute;n fuera del &amp;aacute;rbol principal de Go. Se desarrollan bajo &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;requisitos de compatibilidad&lt;/a&gt; m&amp;aacute;s flexibles que el n&amp;uacute;cleo de Go. Inst&amp;aacute;lelos con &quot; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">Estos perfiles predefinidos se mantienen y entran en pánico con una llamada explícita del método &quot;Agregar o quitar&quot;.</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">Estos servicios pueden ayudarle a encontrar paquetes de código abierto proporcionados por la comunidad.</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">Estas tres rutinas de formateo llaman al Calificador para cada objeto de nivel de paquete O,y si el Calificador devuelve una cadena no vacía p,el objeto se imprime en la forma p.O.Si devuelve una cadena vacía,sólo se imprime el nombre del objeto O.</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">Estas variables tienen el tipo *RangeTable.</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">Esto no puede hacerse de forma simultánea a otras recepciones del canal del Temporizador.</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">Esto declara una bandera entera,-flagname,almacenada en el puntero ip,con el tipo *int.</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">Esto define dos plantillas,T1 y T2,y una tercera T3 que invoca a las otras dos cuando se ejecuta.Finalmente invoca a T3.Si se ejecuta esta plantilla producirá el texto</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">Este ejemplo crea una cola de prioridad con algunos artículos,añade y manipula un artículo y luego elimina los artículos en orden de prioridad.</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">Este ejemplo muestra una función personalizada para procesar el texto de la plantilla.Instala la función strings.Title y la usa para hacer que el texto del título se vea bien en la salida de nuestra plantilla.</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">Este ejemplo demuestra cómo se puede pasar un valor al contexto y también cómo recuperarlo si existe.</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">Este ejemplo demuestra cómo inspeccionar la AST de un programa Go.</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">Este ejemplo demuestra cómo usar big.Int para calcular el número de Fibonacci más pequeño con 100 dígitos decimales y para probar si es primo.</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">Este ejemplo demuestra cómo utilizar big.Rat para calcular los primeros 15 términos de la secuencia de convergencias racionales para la constante e (base del logaritmo natural).</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">Este ejemplo demuestra cómo utilizar un grupo de plantillas de controladores con distintos conjuntos de plantillas de ayuda.</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">Este ejemplo demuestra una forma de compartir algunas plantillas y utilizarlas en diferentes contextos.En esta variante añadimos a mano varias plantillas de controladores a un paquete de plantillas existente.</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">Este ejemplo demuestra la búsqueda de una lista ordenada en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">Este ejemplo demuestra la búsqueda de una lista ordenada en orden descendente.El enfoque es el mismo que el de buscar una lista en orden ascendente,pero con la condición invertida.</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">Este ejemplo demuestra el uso de un contexto cancelable para evitar una fuga de gorutitas.Al final de la función de ejemplo,el goroutine iniciado por el gen volverá sin fuga.</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">Este ejemplo demuestra c&amp;oacute;mo deshacer el ordenamiento de un extracto XML en un valor con algunos campos preestablecidos. Tenga en cuenta que el campo Tel&amp;eacute;fono no se modifica y que el elemento XML &amp;lt;Company&amp;gt; se ignora. Adem&amp;aacute;s, el campo Grupos se asigna teniendo en cuenta la ruta del elemento proporcionada en su etiqueta.</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">Este ejemplo obtiene varios URLs simultáneamente,usando un WaitGroup para bloquear hasta que se completen todas las búsquedas.</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">Este ejemplo ilustra cómo eliminar una declaración variable en un programa Go manteniendo la correcta asociación de comentarios mediante un ast.CommentMap.</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">Este ejemplo inserta varios ints en un IntHeap,comprueba el mínimo y los elimina en orden de prioridad.</target>
        </trans-unit>
        <trans-unit id="6720a93331216084a88085596ce48ea8bc49ea13" translate="yes" xml:space="preserve">
          <source>This example passes a context with a signal to tell a blocking function that it should abandon its work after a signal is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">Este ejemplo pasa un contexto con un timeout para indicar a una función de bloqueo que debe abandonar su trabajo una vez transcurrido el timeout.</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">Este ejemplo pasa un contexto con un plazo arbitrario para decirle a una función de bloqueo que debe abandonar su trabajo tan pronto como llegue a él.</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">Este ejemplo lee 10 números pseudoaleatorios criptográficamente seguros de rand.Reader y los escribe en un trozo de byte.</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">Este ejemplo muestra cómo csv.Reader puede ser configurado para manejar otros tipos de archivos CSV.</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">Este ejemplo muestra cómo codificar un valor de la interfaz.La distinción clave con respecto a los tipos normales es registrar el tipo concreto que implementa la interfaz.</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">Este ejemplo muestra cómo usar big.Float para calcular la raíz cuadrada de 2 con una precisión de 200 bits,y cómo imprimir el resultado como un número decimal.</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">Este ejemplo muestra el uso básico del paquete:Crear un codificador,transmitir algunos valores,recibirlos con un decodificador.</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">Este ejemplo muestra el uso de cada uno de los métodos en una *Rand.El uso de las funciones globales es el mismo,sin el receptor.</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">Este ejemplo muestra cómo se ve una AST cuando se imprime para su depuración.</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">Este ejemplo transmite un valor que implementa los métodos de codificación y descodificación personalizados.</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">Este ejemplo utiliza RawMessage para retrasar el análisis de parte de un mensaje JSON.</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">Este ejemplo utiliza RawMessage para usar un JSON precalculado durante el marshal.</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">Este ejemplo utiliza un decodificador para decodificar un flujo de valores JSON distintos.</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">Este ejemplo utiliza un decodificador para decodificar un conjunto de objetos JSON.</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">Esta función es determinista.Así,si el conjunto de posibles mensajes es pequeño,un atacante puede ser capaz de construir un mapa de los mensajes a las firmas e identificar los mensajes firmados.Como siempre,las firmas proporcionan autenticidad,no confidencialidad.</target>
        </trans-unit>
        <trans-unit id="fd018c9debfe4b296d2cfc4264240cd8fd943b8a" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is, and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as os.ErrDeadlineExceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b76ff62ea1ae6e83678ff4ff974ab310fb4c608" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac909599248ff292672881014f89872aa8e2750" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrNotExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4065f7f0b0bbe706f58a16388dc6fed510ded429" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrPermission).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">El tiempo de ejecución de esta función no depende de las entradas.</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">Esta funcionalidad solo debe usarse con sitios web heredados. RFC 2396 advierte que interpretar Userinfo de esta manera &quot;NO SE RECOMIENDA, porque el paso de informaci&amp;oacute;n de autenticaci&amp;oacute;n en texto sin cifrar (como URI) ha demostrado ser un riesgo de seguridad en casi todos los casos en los que se ha utilizado&quot;.</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">Esta implementación deriva el nonce de un CSPRNG AES-CTR tecleado por ChopMD(256,SHA2-512(priv.D || entropy || hash)).La clave CSPRNG es IRO por un resultado de Coron;la corriente AES-CTR es IRO bajo supuestos estándar.</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c1ec8dd63ceb69c820647454432eed0e8ec308" translate="yes" xml:space="preserve">
          <source>This interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">Esto sólo es necesario para instalar el manipulador en un lugar no estándar.</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">Esto es innecesario ya que la próxima llamada a WriteHeader o Close hará salir implícitamente el relleno del archivo.</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;EC PRIVATE KEY&quot;.Para un formato de clave más flexible que no sea específico de la CE,use MarshalPKCS8PrivateKey.</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;EC PUBLIC KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;CLAVE PRIVADA&quot;.</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;CLAVE PÚBLICA&quot;.</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;RSA PRIVATE KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;RSA PRIVATE KEY&quot;.Para un formato de clave más flexible que no es específico de RSA,usa MarshalPKCS8PrivateKey.</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">Este tipo de clave se codifica comúnmente en bloques PEM del tipo &quot;CLAVE PÚBLICA RSA&quot;.</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">Esto significa que,por defecto,los programas de línea de comandos se comportarán como los típicos programas de línea de comandos de Unix,mientras que otros programas no se bloquearán con SIGPIPE al escribir en una conexión de red cerrada.</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">Este mecanismo puede utilizarse para cancelar operaciones largas en el servidor si el cliente se ha desconectado antes de que la respuesta esté lista.</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">Este mecanismo está destinado únicamente a los remolques que no se conocen antes de que se escriban los encabezamientos.Si el conjunto de remolques es fijo o conocido antes de que se escriba el encabezamiento,se prefiere el mecanismo normal de remolques Go:</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">Este método consulta los siguientes campos de la respuesta r:</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">Este método implementa el crypto.Signer,que es una interfaz de soporte de claves donde la parte privada se guarda en,por ejemplo,un módulo de hardware.Los usos comunes deben utilizar directamente la función Sign en este paquete.</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">Este método implementa el crypto.Signer,que es una interfaz de soporte de claves donde la parte privada se guarda en,por ejemplo,un módulo de hardware.Los usos comunes deben utilizar directamente las funciones Sign*de este paquete.</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">Este paquete asume que los autores de las plantillas son de confianza,que el parámetro de datos de Execute no lo es,y busca preservar las propiedades de abajo frente a los datos no confiables:</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">Este paquete no garantiza resultados idénticos en todas las arquitecturas.</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">Este paquete no soporta la expansión del disco.</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">Este paquete favorece la simplicidad sobre la eficiencia.Los clientes que requieren una serialización de alto rendimiento,especialmente para estructuras de datos de gran tamaño,deberían buscar soluciones más avanzadas como el paquete de codificación/gob o los buffers de protocolo.</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">Este paquete es EXPERIMENTAL.Su alcance actual es sólo para permitir la ejecución de pruebas,pero no para proporcionar una API completa para los usuarios.Está exento de la promesa de compatibilidad con Go.</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">Este paquete no está implementado en NaCl (Cliente nativo).</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">Este paquete no se aplica en el Plan 9.</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">Este paquete no est&amp;aacute; implementado en Windows. Como el paquete syslog est&amp;aacute; congelado, se anima a los usuarios de Windows a utilizar un paquete fuera de la biblioteca est&amp;aacute;ndar. Para conocer los antecedentes, consulte &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37ad2d1270c390f993e16f89ffda81efa69cc5ba" translate="yes" xml:space="preserve">
          <source>This package parses both the original &amp;ldquo;// +build&amp;rdquo; syntax and the &amp;ldquo;//go:build&amp;rdquo; syntax that will be added in Go 1.17. The parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code to still be built against the Go 1.16 release. See &lt;a href=&quot;https://golang.org/design/draft-gobuild&quot;&gt;https://golang.org/design/draft-gobuild&lt;/a&gt; for details about the &amp;ldquo;//go:build&amp;rdquo; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a342a318c5bf238d0752ca434eaa7de9a66322" translate="yes" xml:space="preserve">
          <source>This package should normally be imported by a program's main package, not by a library. Libraries normally shouldn't decide whether to include the timezone database in a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4fcbbffc8fc9a4336682d220cd948063216551" translate="yes" xml:space="preserve">
          <source>This package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">Este paquete entiende HTML,CSS,JavaScript y URI.Añade funciones de desinfección a cada acción simple,así que dado el extracto</target>
        </trans-unit>
        <trans-unit id="df567a8ebe9ff3e3072f56ef8a4b9eaa7e757875" translate="yes" xml:space="preserve">
          <source>This package will be automatically imported if you build with -tags timetzdata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">Este paquete envuelve el texto/plantilla del paquete para que puedas compartir su API de plantillas para analizar y ejecutar plantillas HTML de forma segura.</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">Esta paleta se utiliz&amp;oacute; en el sistema operativo Plan 9, descrito en &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">Esto devuelve un Escritor al que se debe escribir el contenido del archivo.El contenido del archivo debe escribirse en el io.Writer antes de la siguiente llamada a Crear,CrearCabecera o Cerrar.</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">Este paquete de tiempo de ejecución/rastreo proporciona APIs para añadir soporte de rastreo equivalente a un programa autónomo.Consulte el ejemplo que muestra cómo utilizar esta API para habilitar el rastreo.</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">En esta sección se documenta la codificación,detalles que no son importantes para la mayoría de los usuarios.Los detalles se presentan de abajo hacia arriba.</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">Este conjunto puede crecer.Tenga en cuenta que las coincidencias de expresiones regulares pueden necesitar examinar el texto más allá del texto devuelto por una coincidencia,por lo que los métodos que coinciden con el texto de un RuneReader pueden leerse arbitrariamente lejos en la entrada antes de volver.</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">Esto no debe hacerse al mismo tiempo que otras recepciones del canal del Temporizador.</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">Este tipo debe considerarse idéntico al sql.IsolationLevel junto con cualquier valor definido en él.</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">Este tipo debe considerarse idéntico al sql.TxOptions.</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile devuelve n, el n&amp;uacute;mero de registros en el perfil de creaci&amp;oacute;n de subprocesos. Si len (p)&amp;gt; = n, ThreadCreateProfile copia el perfil en py devuelve n, verdadero. Si len (p) &amp;lt;n, ThreadCreateProfile no cambia py devuelve n, falso.</target>
        </trans-unit>
        <trans-unit id="053a6e5ff5756153adf26636a41ad3c9d51f80be" translate="yes" xml:space="preserve">
          <source>Thus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick ​​es un contenedor de conveniencia para NewTicker que proporciona acceso solo al canal de tictac. Si bien Tick es &amp;uacute;til para los clientes que no necesitan apagar el Ticker, tenga en cuenta que sin una forma de apagarlo, el recolector de basura no puede recuperar el Ticker subyacente; tiene &quot;fugas&quot;. A diferencia de NewTicker, Tick devolver&amp;aacute; nil si d &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">Los instantes de tiempo pueden ser comparados usando los métodos de Antes,Después e Igual.El método Sub resta dos instantes,produciendo una Duración.El método Add añade un Tiempo y una Duración,produciendo un Tiempo.</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">El formato de tiempo es el formato de tiempo que se utiliza para generar tiempos en los encabezados HTTP.Es como la hora.RFC1123 pero con el código duro GMT como zona horaria.La hora que se formatea debe estar en UTC para que el formato genere el formato correcto.</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">El tiempo de espera informa si se sabe que la búsqueda del DNS se ha agotado.Esto no siempre se sabe;una búsqueda DNS puede fallar debido a un tiempo muerto y devolver un DNSError para el cual el tiempo muerto devuelve falso.</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">Timeout informa si este error representa un timeout.</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler devuelve un Manejador que corre h con el límite de tiempo dado.</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler soporta las interfaces de Flusher y Pusher pero no soporta la interfaz de Hijacker.</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader devuelve ErrTimeout en la segunda lectura sin datos.Las llamadas posteriores a la lectura tienen éxito.</target>
        </trans-unit>
        <trans-unit id="092b95acf2f2e3d735b1b9d6eb619d6f9b285116" translate="yes" xml:space="preserve">
          <source>TimespecToNSec returns the time stored in ts as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec convierte un valor de Timespec en un número de nanosegundos desde la época de Unix.</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec convierte un valor de Timeval en un número de nanosegundos desde la época de Unix.</target>
        </trans-unit>
        <trans-unit id="88a226b5c5421dc95c12f9851cda7185d1ebf771" translate="yes" xml:space="preserve">
          <source>TimevalToNsec returns the time stored in tv as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">El título devuelve una copia de la s de la cadena con todas las letras de Unicode que comienzan las palabras mapeadas a su caja de título de Unicode.</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">El título trata la s como bytes codificados en UTF-8 y devuelve una copia con todas las letras de Unicode que comienzan las palabras mapeadas a su caja de título.</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">Para añadir un soporte de perfil equivalente a un programa autónomo,añada un código como el siguiente a su función principal:</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">Para evitar ataques de denegación de servicio,el bufio.Reader proporcionado debe leerse de un io.LimitReader o un Reader similar para limitar el tamaño de las respuestas.</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">Para evitar la recurrencia en casos como</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">Para ser compatible con el pasado,el FileHeader tiene campos de tamaño de 32 y 64 bits.Los campos de 64 bits siempre contendrán el valor correcto y para los archivos normales ambos campos serán los mismos.Para los archivos que requieren el formato ZIP64 los campos de 32 bits serán 0xffffffff y los campos de 64 bits deben ser usados en su lugar.</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">Para construir un archivo sólo cuando se usa cgo,y sólo en Linux y OS X:</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">Para construir cuerdas más eficientemente,vea el tipo de construcción de cuerdas.</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">Para cambiar el destino de los mensajes de bandera,llame a CommandLine.SetOutput.</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">Para comparar dos valores,compara los resultados del método de la Interfaz.Usando ==en dos Valores no se comparan los valores subyacentes que representan.</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">Para completar el ejemplo anterior,el siguiente código trata de encontrar el valor x en un dato de corte entero clasificado en orden ascendente:</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">Para calcular el número de asignaciones,la función se ejecutará primero una vez como calentamiento.El número medio de asignaciones sobre el número especificado de ejecuciones será entonces medido y devuelto.</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">Para convertir un número entero de unidades en una Duración,multiplique:</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">Para contar el número de unidades en una Duración,divídelo:</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">Para crear una nueva solicitud con un contexto,utilice NewRequestWithContext.Para cambiar el contexto de una solicitud (por ejemplo,una entrante)que también desea modificar para enviarla de nuevo,utilice Request.Clone.Entre estos dos usos,es raro que se necesite WithContext.</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">Para crear el valor Pos para un offset de fuente específico (medido en bytes),primero agregue el archivo respectivo al conjunto de archivos actual usando FileSet.AddFile y luego llame File.Pos(offset)para ese archivo.Dado un valor Pos p para un conjunto de archivos específicos fset,el valor de Posición correspondiente se obtiene llamando a fset.Position(p).</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">Para definir un tipo,el codificador elige un id de tipo positivo no utilizado y envía el par (-identificación de tipo,tipo codificado)en el que el tipo codificado es la codificación de una descripción wireType,construida a partir de estos tipos:</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">Para definir su propio formato,escriba cómo se vería el tiempo de referencia formateado a su manera;vea los valores de las constantes como ANSIC,StampMicro o Kitchen para ejemplos.El modelo consiste en demostrar cómo se ve el tiempo de referencia para que los métodos de Formato y Análisis puedan aplicar la misma transformación a un valor de tiempo general.</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">Para distinguir las restricciones de construcción de la documentación de los paquetes,una serie de restricciones de construcción debe ir seguida de una línea en blanco.</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">Para asegurarse de que el canal está vacío después de una llamada a Stop,compruebe el valor de retorno y drene el canal.Por ejemplo,asumiendo que el programa no ha recibido ya de T.C:</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">Para escapar de un segmento de texto,entre paréntesis con los caracteres de escape.Por ejemplo,la pestaña en esta cadena &quot;Ignorar esta pestaña:\xfft\xff&quot; no termina una celda y constituye un solo carácter de ancho uno para fines de formato.</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">Para forzar la división entera de los operandos Int,use op ==token.QUO_ASSIGN en lugar de token.QUO;el resultado está garantizado que es Int en este caso.La división por cero lleva a un pánico en el tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">Para generar la salida HTML,véase el paquete html/plantilla,que tiene la misma interfaz que este paquete pero asegura automáticamente la salida HTML contra ciertos ataques.</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">Para generar una petición HTTP de cliente en lugar de una petición de servidor,ver la función NewRequest en el paquete net/http.</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">Para incluir cada bloque asignado en el perfil,establezca la MemProfileRate en 1.Para desactivar completamente el perfil,establezca la MemProfileRate en 0.</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">Para incluir todos los eventos de bloqueo en el perfil, tasa de aprobaci&amp;oacute;n = 1. Para desactivar la creaci&amp;oacute;n de perfiles por completo, tasa de aprobaci&amp;oacute;n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">Para insertar un literal $ en la salida,usa $$ en la plantilla.</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">Para iterar sobre una lista (donde yo soy una *Lista):</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">Para evitar que un archivo sea considerado para la construcción:</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">Para hacer una solicitud con cabeceras personalizadas,utilice NewRequest y Client.Do.</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Para hacer una solicitud con cabeceras personalizadas,utilice NewRequest y DefaultClient.Do.</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">Para mapear la runa al caso especificado:Mayúscula,minúscula o mayúscula.</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">Para evitar la duplicación de operaciones,ErrBadConn NO debe ser devuelto si existe la posibilidad de que el servidor de la base de datos haya realizado la operación.Incluso si el servidor devuelve un error,no debería devolver ErrBadConn.</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">Para eliminar un prefijo,usa TrimPrefix en su lugar.</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">Para eliminar un sufijo,use TrimSuffix en su lugar.</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">Para establecer encabezados personalizados,use NewRequest y Client.Do.</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Para establecer encabezados personalizados,utilice NewRequest y DefaultClient.Do.</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9522949e411b2165edb986c411282650712ef336" translate="yes" xml:space="preserve">
          <source>To support tools that analyze Go packages, the patterns found in //go:embed lines are available in &amp;ldquo;go list&amp;rdquo; output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the &amp;ldquo;go help list&amp;rdquo; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">Para traducir estos PCs en información simbólica como nombres de funciones y números de línea,use CallersFrames.CallersFrames contabiliza las funciones en línea y ajusta los contadores de programa de retorno en contadores de programa de llamadas.Se desaconseja la fluctuación sobre la porción de PCs devueltos directamente,así como el uso de FuncForPC en cualquiera de los PCs devueltos,ya que estos no pueden tener en cuenta el ajuste de los contadores en línea o de los programas de devolución.go:noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">Para desactivar la creaci&amp;oacute;n de perfiles por completo, pasa la tasa 0. Para leer simplemente la tasa actual, pasa la tasa &amp;lt;0. (Para n&amp;gt; 1, los detalles del muestreo pueden cambiar).</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">Para desmarcar a JSON en un puntero,Unmarshal primero maneja el caso de que el JSON sea el JSON literalmente nulo.En ese caso,Unmarshal pone el puntero en nulo.De lo contrario,Unmarshal desmarca el JSON en el valor señalado por el puntero.Si el puntero es nulo,Unmarshal asigna un nuevo valor para que apunte.</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">Para desmarcar a JSON en una estructura,Unmarshal hace coincidir las claves de los objetos entrantes con las claves utilizadas por Marshal (ya sea el nombre de campo de la estructura o su etiqueta),prefiriendo una coincidencia exacta pero también aceptando una coincidencia que no distingue entre mayúsculas y minúsculas.Por defecto,las claves de objeto que no tienen un campo de estructura correspondiente son ignoradas (véase Decoder.DisallowUnknownFields para una alternativa).</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">Para desmarcar JSON en un valor implementando la interfaz del Desmarcador,el Desmarcador llama a ese valor el método UnmarshalJSON,incluso cuando la entrada es un JSON nulo.De lo contrario,si el valor implementa encoding.TextUnmarshaler y la entrada es una cadena de texto JSON cotizada,Unmarshal llama al método UnmarshalText de ese valor con la forma no cotizada de la cadena.</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">Para desmarcar a JSON en un valor de la interfaz,Unmarshal almacena uno de estos en el valor de la interfaz:</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">Para desmarcar una matriz JSON en una matriz Go,Unmarshal decodifica los elementos de la matriz JSON en los elementos correspondientes de la matriz Go.Si la matriz Go es más pequeña que la matriz JSON,los elementos adicionales de la matriz JSON son descartados.Si la matriz JSON es más pequeña que la matriz Go,los elementos adicionales de la matriz Go se ponen a cero.</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">Para desmarcar una matriz JSON en una rebanada,Unmarshal restablece la longitud de la rebanada a cero y luego agrega cada elemento a la rebanada.Como caso especial,para desmarcar una matriz JSON vacía en una rebanada,Unmarshal reemplaza la rebanada con una nueva rebanada vacía.</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">Para desmarcar un objeto JSON en un mapa,el Unmarshal primero establece un mapa para usar.Si el mapa es nulo,Unmarshal asigna un nuevo mapa.De lo contrario,Unmarshal reutiliza el mapa existente,manteniendo las entradas existentes.Unmarshal entonces almacena los pares clave-valor del objeto JSON en el mapa.El tipo de clave del mapa debe ser una cadena,un entero,o implementar la codificación.TextUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">Para usar un Pipeline p para manejar múltiples clientes en una conexión,cada cliente debe correr:</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">Para utilizar una declaración preparada existente sobre esta transacción,véase Tx.Stmt.</target>
        </trans-unit>
        <trans-unit id="2a7b3f715f9964aa312835dc3f2ae71cd3041225" translate="yes" xml:space="preserve">
          <source>To use an fs.FS implementation, use http.FS to convert it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">Para utilizar los gobs,cree un Encoder y preséntelo con una serie de datos como valores o direcciones que pueden ser desviados a los valores.El codificador se asegura de que toda la información de tipo se envíe antes de que se necesite.En el lado de recepción,un Decodificador recupera valores de la corriente codificada y los desempaqueta en variables locales.</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">Para usar pprof,enlaza este paquete a tu programa:</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">Para utilizar la implementación del sistema de archivos del sistema operativo,utilice http.Dir:</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">Para ver todos los perfiles disponibles, abra &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http: // localhost: 6060 / debug / pprof /&lt;/a&gt; en su navegador.</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">Para escribir un nuevo conjunto de pruebas, cree un archivo cuyo nombre termine en _test.go que contenga las funciones de TestXxx como se describe aqu&amp;iacute;. Coloque el archivo en el mismo paquete que el que se est&amp;aacute; probando. El archivo se excluir&amp;aacute; de las compilaciones de paquetes habituales, pero se incluir&amp;aacute; cuando se ejecute el comando &quot;go test&quot;. Para obtener m&amp;aacute;s detalles, ejecute &quot;go help test&quot; y &quot;go help testflag&quot;.</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16 convierte la dirección IP ip en una representación de 16 bytes.Si ip no es una dirección IP (es la longitud equivocada),To16 devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4 convierte la dirección IPv4 ip en una representación de 4 bytes.Si la ip no es una dirección IPv4,To4 devuelve cero.</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">ToComplex convierte x en un valor de Complejo si x es representable como un Complejo.De lo contrario,devuelve un Desconocido.</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">ToFloat convierte x en un valor de Float si x es representable como un Float.De lo contrario,devuelve un Desconocido.</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML convierte el texto de los comentarios en HTML formateado.El comentario fue preparado por DocReader,por lo que se sabe que no tiene líneas en blanco ni espacios al final de las líneas.Los marcadores de comentario ya han sido eliminados.</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">ToInt convierte x en un valor Int si x es representable como un Int.De lo contrario,devuelve un Desconocido.</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower mapea la runa en minúsculas dando prioridad al mapeo especial.</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower mapea la runa a minúsculas.</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower devuelve una copia de los trozos de bytes con todas las letras de Unicode mapeadas a sus minúsculas.</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower devuelve la s con todas las letras de Unicode mapeadas a sus minúsculas.</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial devuelve una copia de la cadena s con todas las letras Unicode mapeadas a sus minúsculas usando el mapeo de mayúsculas y minúsculas especificado por la c.</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial trata los s como bytes codificados en UTF-8 y devuelve una copia con todas las letras Unicode mapeadas a sus minúsculas,dando prioridad a las reglas de la carcasa especial.</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash devuelve el resultado de reemplazar cada carácter separador en el camino con un carácter de barra ('/').Los múltiples separadores son reemplazados por múltiples barras.</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText prepara el texto de los comentarios para su presentación en la salida de texto.Envuelve los párrafos de texto con un ancho o menos puntos de código Unicode y luego antepone a cada línea la sangría.En las secciones preformateadas (como el texto de un programa),antepone a cada línea que no sea en blanco la sangría.</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle mapea la runa al caso del título dando prioridad a la cartografía especial.</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle mapea la runa al caso del título.</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle devuelve una copia de la cadena s con todas las letras de Unicode asignadas a su caja de título de Unicode.</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle trata los s como bytes codificados en UTF-8 y devuelve una copia con todas las letras de Unicode asignadas a su caja de título.</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial devuelve una copia de la cadena s con todas las letras de Unicode asignadas a su caja de título de Unicode,dando prioridad a las reglas de la caja especial.</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial trata los s como bytes codificados en UTF-8 y devuelve una copia con todas las letras de Unicode asignadas a su caja de título,dando prioridad a las reglas de la caja especial.</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper mapea la runa a mayúsculas dando prioridad al mapeo especial.</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper mapea la runa a mayúsculas.</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper devuelve una copia de los trozos de bytes con todas las letras de Unicode mapeadas a su mayúscula.</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper devuelve s con todas las letras de Unicode mapeadas a su mayúscula.</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial devuelve una copia de la cadena s con todas las letras de Unicode mapeadas a su mayúscula usando el mapeo de mayúsculas especificado por la c.</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial trata los s como bytes codificados en UTF-8 y devuelve una copia con todas las letras Unicode mapeadas a su mayúscula,dando prioridad a las reglas de la carcasa especial.</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8 devuelve una copia de la cadena s con cada ejecución de secuencias de bytes UTF-8 inválidas reemplazadas por la cadena de reemplazo,que puede estar vacía.</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8 trata los s como bytes codificados en UTF-8 y devuelve una copia con cada corrida de bytes que representa el UTF-8 inválido reemplazado por los bytes en sustitución,que pueden estar vacíos.</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">Token expande elementos de cierre autom&amp;aacute;tico como &amp;lt;br/&amp;gt; en elementos de inicio y fin separados devueltos por llamadas sucesivas.</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">Token garantiza que las fichas de Comienzo y Fin de Elemento que devuelve están correctamente anidadas y emparejadas:si Token se encuentra con un elemento final inesperado o EOF antes de todos los elementos finales esperados,devolverá un error.</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">Token garantiza que los delimitadores[]{}que devuelve están correctamente anidados y emparejados:si Token encuentra un delimitador inesperado en la entrada,devolverá un error.</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">Token implementa espacios de nombres XML como se describe en &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt; . Cada una de las estructuras de Nombre contenidas en el Token tiene el Espacio configurado en la URL que identifica su espacio de nombre cuando se conoce. Si Token encuentra un prefijo de espacio de nombre no reconocido, usa el prefijo como espacio en lugar de informar un error.</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">Token es el conjunto de fichas léxicas del lenguaje de programación Go.</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">La ficha devuelve la siguiente ficha JSON en el flujo de entrada.Al final del flujo de entrada,la ficha devuelve cero,io.EOF.</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token devuelve el siguiente token XML en el flujo de entrada.Al final del flujo de entrada,Token devuelve nil,io.EOF.</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString devuelve una cadena imprimible para un token o un personaje Unicode.</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText devuelve la cadena correspondiente al último token escaneado.Válido después de llamar a Scan y en llamadas de Scanner.Error.</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir es el directorio que contiene las herramientas de construcción.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">El rastro responde con el rastro de ejecución en forma binaria.La traza dura la duración especificada en segundos en el parámetro GET,o durante 1 segundo si no se especifica.La inicialización del paquete lo registra como /debug/pprof/trace.</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">Rastreo de las actividades en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix es un prefijo mágico para las claves del mapa de ResponseWriter.Header que,si está presente,indica que la entrada del mapa es en realidad para los trailers de respuesta,y no los encabezados de respuesta.El prefijo se quita después de que la llamada ServeHTTP termina y los valores se envían en los trailers.</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits devuelve el número de bits cero consecutivos menos significativos de |x|.</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros devuelve el número de bits de cero en x;el resultado es UintSize para x ==0.</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16 devuelve el número de bits de cero arrastrados en x;el resultado es 16 para x ==0.</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32 devuelve el número de bits de cero arrastrados en x;el resultado es 32 para x ==0.</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64 devuelve el número de bits de cero en x;el resultado es 64 para x ==0.</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8 devuelve el número de bits de cero arrastrados en x;el resultado es 8 para x ==0.</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">El transporte es una implementación de RoundTripper que soporta proxies HTTP,HTTPS y HTTP (tanto para HTTP como para HTTPS con CONNECT).</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">Transporte sólo reintenta una solicitud cuando encuentra un error de red si la solicitud es idempotente y no tiene cuerpo o tiene su Request.GetBody definido.Las peticiones HTTP se consideran idempotentes si tienen los métodos HTTP GET,HEAD,OPTIONS o TRACE;o si su mapa de cabecera contiene una entrada &quot;Idempotency-Key&quot; o &quot;X-Idempotency-Key&quot;.Si el valor de la clave de idempotencia es un trozo de longitud cero,la solicitud se trata como idempotente pero el encabezado no se envía en el cable.</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">El transporte utiliza HTTP/1.1 para las direcciones URL HTTP y HTTP/1.1 o HTTP/2 para las direcciones URL HTTPS,dependiendo de si el servidor admite HTTP/2 y de cómo esté configurado el transporte.El Transporte por defecto soporta HTTP/2.Para habilitar explícitamente HTTP/2 en un transporte,utilice golang.org/x/net/http2 y llame a ConfigurarTransporte.Consulta los documentos del paquete para obtener más información sobre HTTP/2.</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Los transportes deben ser reutilizados en lugar de ser creados según se necesite.Los transportes son seguros para su uso simultáneo por múltiples goroutines.</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">El árbol es la representación de una única plantilla analizada.</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">Trim devuelve un trozo de la s de la cadena con todos los puntos de código Unicode contenidos en el juego de corte eliminados.</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim devuelve un subcorte de s cortando todos los puntos de código codificados en UTF-8 que contiene el juego de corte.</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes regresa b sin dirigir ni arrastrar el espacio ASCII.</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc devuelve un trozo de la cadena s con todos los puntos de código Unicode c que satisfacen f(c)eliminados.</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc devuelve un subcorte de s cortando todos los puntos c del código UTF-8 que satisfacen f(c).</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft devuelve un trozo de la cadena s con todos los puntos principales del código Unicode contenidos en el juego de cortes eliminados.</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft devuelve un subcorte de s cortando todos los puntos principales de código codificado UTF-8 contenidos en el juego de corte.</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc devuelve un trozo de la cadena s con todos los puntos principales del código Unicode c que satisfacen f(c)eliminados.</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc trata a s como bytes codificados en UTF-8 y devuelve un subcorte de s cortando todos los puntos c del código principal codificado en UTF-8 que satisfacen f(c).</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix devuelve s sin la cadena de prefijos provista.Si s no comienza con el prefijo,s se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight devuelve un trozo de la s de la cadena,con todos los puntos de código de Unicode contenidos en el juego de cortes eliminados.</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight devuelve un subcorte de s cortando todos los puntos de código UTF-8 que están contenidos en el juego de corte.</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc devuelve un trozo de la cadena s con todos los puntos de código de Unicode c que satisfacen f(c)eliminados.</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc devuelve un subcorte de s cortando todos los puntos c del código UTF-8 que satisfacen f(c).</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace devuelve una parte de la cadena s,con todos los espacios en blanco delanteros y traseros eliminados,según la definición de Unicode.</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace devuelve una subcategoría de s cortando todo el espacio en blanco de entrada y salida,tal y como lo define Unicode.</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString devuelve s sin dirigir ni arrastrar el espacio ASCII.</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix devuelve s sin la cadena de sufijo de arrastre proporcionada.Si s no termina con el sufijo,s se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc devuelve el valor entero de x.</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncar cambia el tamaño del archivo.No cambia el desplazamiento de E/S.Si hay un error,será del tipo *PathError.</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncar cambia el tamaño del archivo nombrado.Si el archivo es un enlace simbólico,cambia el tamaño del objetivo del enlace.Si hay un error,será del tipo *PathError.</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">Trunca descarta todos los bytes del búfer excepto los primeros n no leídos,pero sigue utilizando el mismo almacenamiento asignado.Entra en pánico si n es negativo o mayor que la longitud de la memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Truncado opera en el tiempo como una duración absoluta desde el tiempo cero;no opera en la forma de presentación del tiempo.Así,Trunca(Hora)puede devolver un tiempo con un minuto distinto de cero,dependiendo de la localización del tiempo.</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">Truncar devuelve el resultado de redondear d hacia cero a un m&amp;uacute;ltiplo de m. Si m &amp;lt;= 0, Truncar devuelve d sin cambios.</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Truncar devuelve el resultado de redondear t hacia abajo a un m&amp;uacute;ltiplo de d (desde el tiempo cero). Si d &amp;lt;= 0, Truncar devuelve t despojado de cualquier lectura de reloj mon&amp;oacute;tona, pero sin cambios.</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter devuelve un escritor que escribe a w pero se detiene silenciosamente después de n bytes.</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Verdad devuelve la &quot;veracidad&quot; de JavaScript del valor v. En JavaScript, falso, 0, &quot;&quot;, nulo, indefinido y NaN son &quot;falsos&quot;, y todo lo dem&amp;aacute;s es &quot;veraz&quot;. Consulte &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv intenta recibir un valor del canal v pero no se bloquea.Entra en pánico si el tipo de v no es Chan.Si la recepción entrega un valor,x es el valor transferido y ok es verdadero.Si la recepción no puede terminar sin bloquearse,x es el valor cero y ok es falso.Si el canal está cerrado,x es el valor cero del tipo de elemento del canal y ok es falso.</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend intenta enviar x en el canal v pero no se bloquea.Entra en pánico si el tipo de V no es Chan.Informa si el valor fue enviado.Como en Go,el valor de x debe ser asignable al tipo de elemento del canal.</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">Este paquete incluye dos conjuntos de interfaces.Cuando no es necesario un interfaz más abstracto,hay funciones para encriptar/desencriptar con la v1.5/OAEP y para firmar/verificar con la v1.5/PSS.Si uno necesita abstraerse sobre la primitiva llave pública,la estructura de la llave privada implementa las interfaces de desencriptación y firma del paquete de criptografía.</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx es una transacción.</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx es una transacción de base de datos en curso.</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions contiene las opciones de transacción para ser usadas en DB.BeginTx.</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions tiene las opciones de transacción.</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ contiene los predeclarados *Tipos Básicos indexados por su correspondiente BasicKind.</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Escriba las banderas para Header.Typeflag.</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">La inferencia de tipo computa el tipo (Type)de cada expresión (ast.Expr)y comprueba el cumplimiento de la especificación del lenguaje.Utilice Info.Types[expr].Type para los resultados de la inferencia de tipo.</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">El tipo se encuentra en Header.Type.</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">El tipo está aquí sólo para fines de documentación.Es un sustituto de cualquier tipo de Go,pero representa el mismo tipo para cualquier invocación de función dada.</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">El tipo es la documentación para una declaración de tipo.</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">El tipo es la representación de un tipo Go.</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Tipo lee el tipo en off en la secci&amp;oacute;n &quot;info&quot; de ENANOS.</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">El tipo representa el tipo de JavaScript de un Valor.</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">El tipo se devuelve a sí mismo y proporciona una fácil implementación por defecto para su incorporación en un Nodo.Embebido en todos los Nodos no triviales.</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type devuelve el tipo de JavaScript del valor v.Es similar al tipo de operador de JavaScript,excepto que devuelve TypeNull en lugar de TypeObject para null.</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">El tipo devuelve el tipo del objeto.</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">El tipo devuelve el tipo de x.f,que puede ser diferente del tipo de f.Ver Selección para más información.</target>
        </trans-unit>
        <trans-unit id="55e720628bd8b49b52419d5886faf349fa86465b" translate="yes" xml:space="preserve">
          <source>Type returns type bits in m (m &amp;amp; ModeType).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">El tipo devuelve el tipo de V.</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">Los valores de los tipos son comparables,como con el operador ==,por lo que pueden ser utilizados como claves de mapa.Dos valores de Type son iguales si representan tipos idénticos.</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">La verificación de tipo consiste en varias fases interdependientes:</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">El Tipo 1 está aquí sólo para fines de documentación.Es un sustituto de cualquier tipo de Go,pero representa el mismo tipo para cualquier invocación de función dada.</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue informa el tipo y el valor (para las constantes)de la expresión correspondiente.</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension devuelve el tipo MIME asociado a la extensión del archivo ext.La extensión ext debe comenzar con un punto inicial,como en &quot;.html&quot;.Cuando la extensión no tiene un tipo asociado,TypeByExtension devuelve &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf devuelve el tipo de reflexión que representa el tipo dinámico de i.Si i es un valor de interfaz nulo,TypeOf devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf devuelve el tipo de expresión e,o nulo si no se encuentra.Condición previa:los mapas de Tipos,Usos y Defs están poblados.</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString devuelve la representación de la cadena del tipo.El calificador controla la impresión de los objetos de nivel de paquete,y puede ser nulo.</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">Cuerdas mecanografiadas</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">Los tipos HTML,JS,URL,y otros de content.go pueden llevar contenido seguro que está exento de fuga.</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">Tipos y valores</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">Los tipos que implementan la interfaz de Valuer son capaces de convertirse en un conductor de Valor.</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">Tipos de señales</target>
        </trans-unit>
        <trans-unit id="4a68e8d3eb65d7282f5ff466196272be854598ae" translate="yes" xml:space="preserve">
          <source>Typical usage inside a test is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr representa la dirección de un punto final UDP.</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn es la implementación de las interfaces Conn y PacketConn para las conexiones de red UDP.</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL (Viaje de ida y vuelta)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL encapsula un URL seguro conocido o una subcadena de URL (ver RFC 3986).Una URL como `javascript:checkThatFormNotEditedBeforeLeavingPage()` de una fuente confiable debería ir en la página,pero por defecto las `javascript:` dinámicas son filtradas ya que son un vector de inyección frecuentemente explotado.</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">El método String de URL utiliza el método EscapedPath para obtener la ruta.Consulta el método EscapedPath para obtener más detalles.</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">La URLEncodificación es la codificación alternativa de base64 definida en el RFC 4648.Se usa típicamente en URLs y nombres de archivos.</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper devuelve el valor evadido de la representación textual de sus argumentos en una forma adecuada para su incrustación en una consulta URL.</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">Los URL en el texto del comentario se convierten en enlaces;si el URL también aparece en el mapa de palabras,el enlace se toma del mapa (si el valor correspondiente del mapa es la cadena vacía,el URL no se convierte en un enlace).</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">Los URLs que no empiezan con una barra después del esquema se interpretan como:</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC representa el Tiempo Universal Coordinado (UTC).</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC regresa t con la ubicación establecida en UTC.</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint define una bandera uint con nombre,valor predeterminado y cadena de uso especificados.El valor de retorno es la dirección de una variable uint que almacena el valor del flag.</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint devuelve el valor subyacente de V,como un Uint64.Entra en pánico si el tipo de v no es Uint,Uintptr,Uint8,Uint16,Uint32,o Uint64.</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32 devuelve un valor pseudo-aleatorio de 32 bits como uint32 de la Fuente por defecto.</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32 devuelve un valor pseudo-aleatorio de 32 bits como un uint32.</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64 define una bandera uint64 con un nombre especificado,un valor predeterminado y una cadena de uso.El valor de retorno es la dirección de una variable uint64 que almacena el valor del indicador.</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64 devuelve un valor pseudo-aleatorio de 64 bits como un uint64 de la Fuente por defecto.</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64 devuelve un valor pseudo-aleatorio de 64 bits como un uint64.</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64 devuelve un valor extraído de la distribución Zipf descrita por el objeto Zipf.</target>
        </trans-unit>
        <trans-unit id="1ef36be6f6e6e03fddea6aa5e34904aadf0ca3e4" translate="yes" xml:space="preserve">
          <source>Uint64 returns the internal uint64 value for the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64 devuelve la representación de x en uint64.Si x no puede ser representada en un uint64,el resultado es indefinido.</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64 devuelve el entero sin signo resultante de truncar x hacia cero. Si 0 &amp;lt;= x &amp;lt;= math.MaxUint64, el resultado es Exacto si x es un n&amp;uacute;mero entero y Inferior de lo contrario. El resultado es (0, Arriba) para x &amp;lt;0, y (math.MaxUint64, Abajo) para x&amp;gt; math.MaxUint64.</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val devuelve el valor Go uint64 de x y si el resultado es exacto;x debe ser un Int o un Desconocido.Si el resultado no es exacto,su valor es indefinido.Si x es Desconocida,el resultado es (0,falso).</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var define una bandera uint64 con un nombre especificado,un valor predeterminado y una cadena de uso.El argumento p apunta a una variable uint64 en la que almacenar el valor de la bandera.</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize es el tamaño de una uña en pedazos.</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar define una bandera uint con un nombre específico,un valor predeterminado y una cadena de uso.El argumento p apunta a una variable uint en la que almacenar el valor del flag.</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp devuelve el resultado de la expresi&amp;oacute;n unaria op y. La operaci&amp;oacute;n debe definirse para el operando. Si prec&amp;gt; 0 especifica el tama&amp;ntilde;o del resultado ^ (xor) en bits. Si y es Desconocido, el resultado es Desconocido.</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined devuelve el valor de JavaScript &quot;undefined&quot;.</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString elimina el escape de entidades como &quot;&amp;amp; lt;&quot; para convertirse en &quot;&amp;lt;&quot;. Elimina el escape de una gama m&amp;aacute;s amplia de entidades de las que EscapeString escapa. Por ejemplo, &quot;&amp;amp; aacute;&quot; desaparece a &quot;&amp;aacute;&quot;, al igual que &quot;&amp;amp; # 225;&quot; y &quot;&amp;amp; # xE1;&quot;. UnescapeString (EscapeString (s)) == s siempre se cumple, pero lo contrario no siempre es cierto.</target>
        </trans-unit>
        <trans-unit id="32ea3c11e3a0c9441edc34338d9ee1468d7b9e70" translate="yes" xml:space="preserve">
          <source>Unicode character classes are those in unicode.Categories and unicode.Scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">Uniforme es una imagen de tamaño infinito de color uniforme.Implementa las interfaces de color,color,modelo e imagen.</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">La unión devuelve el rectángulo más pequeño que contiene tanto la r como la s.</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">Unix devuelve t como una hora de Unix,el número de segundos transcurridos desde el 1 de enero de 1970 UTC.El resultado no depende de la ubicación asociada a t.</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">Unix devuelve la hora local correspondiente a la hora Unix dada, segundos segundos y nanosegundos nsec desde el 1 de enero de 1970 UTC. Es v&amp;aacute;lido pasar nsec fuera del rango [0, 999999999]. No todos los valores de segundos tienen un valor de tiempo correspondiente. Uno de esos valores es 1 &amp;lt;&amp;lt; 63-1 (el valor int64 m&amp;aacute;s grande).</target>
        </trans-unit>
        <trans-unit id="416b8be7737316cebb3c9cebf5753060cd3fcb1d" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in ts as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164bbe899c45be28d564c4c79dd8c5d574ad3bc8" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in tv as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix devuelve ts como el número de segundos y nanosegundos transcurridos desde la época de Unix.</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix devuelve la televisión como el número de segundos y nanosegundos transcurridos desde la época de Unix.</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr representa la dirección de un punto final de un socket de dominio Unix.</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn es una implementación de la interfaz Conn para conexiones a los enchufes de dominio Unix.</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials codifica las credenciales en un mensaje de control de zócalo para enviarlas a otro proceso.Esto puede ser usado para la autenticación.</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener es un escuchador de sockets de dominio Unix.Los clientes deberían utilizar típicamente variables del tipo Listener en lugar de asumir sockets de dominio Unix.</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano devuelve t como un tiempo de Unix,el número de nanosegundos transcurridos desde el 1 de enero de 1970 UTC.El resultado no está definido si la hora Unix en nanosegundos no puede ser representada por un int64 (una fecha anterior al año 1678 o posterior a 2262).Tenga en cuenta que esto significa que el resultado de llamar a UnixNano en el tiempo cero no está definido.El resultado no depende de la ubicación asociada a t.</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights codifica un conjunto de descriptores de archivos abiertos en un mensaje de control de zócalo para enviarlo a otro proceso.</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">Autoridad desconocidaEl error se produce cuando se desconoce el emisor del certificado</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError representa una falla en la búsqueda del archivo específico en la tabla de símbolos.</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">UnknownGroupError es devuelto por LookupGroup cuando un grupo no puede ser encontrado.</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">DesconocidoGrupoIdError es devuelto por BúsquedaGrupoId cuando un grupo no puede ser encontrado.</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError representa una falla en el mapeo de una línea a un contador de programa,ya sea porque la línea está más allá de los límites del archivo o porque no hay código en la línea dada.</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">DesconocidoUsuarioError es devuelto por Búsqueda cuando un usuario no puede ser encontrado.</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">UnknownUserIdError es devuelto por LookupId cuando un usuario no puede ser encontrado.</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">A menos que se establezca un códec explícito,se utiliza la codificación de paquetes/gob para transportar los datos.</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">A menos que se indique lo contrario,se definen en la RFC 7231 sección 4.3.</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">A menos que se especifique lo contrario,todas las operaciones (incluidas las colocadoras)que especifiquen una variable *Flotador para el resultado (normalmente a través del receptor con la excepción de MantExp),redondean el resultado numérico según la precisión y el modo de redondeo de la variable de resultado.</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">A diferencia de la C,no es válido adelantar un puntero más allá del final de su asignación original:</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">A diferencia del runtime.Callers,los valores de PC devueltos deben,cuando se pasan a la función de simbolizador,devolver el archivo/línea de la instrucción de llamada.No se requiere ni es apropiada ninguna sustracción adicional.</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">A diferencia de la llamada a la biblioteca del &quot;sistema&quot; desde C y otros idiomas,el paquete os/exec no invoca intencionadamente el shell del sistema y no expande ningún patrón de globos o maneja otras expansiones,tuberías o redirecciones típicas de los shells.El paquete se comporta más como la familia de funciones &quot;exec&quot; de C.Para expandir los patrones glob,o bien llama directamente al shell,teniendo cuidado de escapar de cualquier entrada peligrosa,o utiliza la función Glob del paquete path/filepath.Para expandir las variables de entorno,usa el paquete os's ExpandEnv.</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">Desenlazar elimina n % elementos r.Len()del anillo r,comenzando en r.Next().Si n % r.Len()==0,r permanece sin cambios.El resultado es el subring eliminado.r no debe estar vacío.</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">Desbloquear desbloquea m.Es un error en tiempo de ejecución si m no está bloqueado en la entrada a Desbloquear.</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">Desbloquear abre la puerta para escribir.Es un error en tiempo de ejecución si rw no está bloqueado para escribir en la entrada de Desbloquear.</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">Desbloquear el Hilo de Ocho Hilos deshace una llamada anterior al Hilo de Ocho Hilos.Si esto baja el número de llamadas activas de LockOSThread en el goroutine de llamada a cero,se deshace el goroutine de llamada de su hilo de sistema operativo fijo.Si no hay llamadas activas a LockOSThread,esto es un no-op.</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">Unmarshal convierte un punto,serializado por Marshal,en un par x,y.Es un error si el punto no está en forma no comprimida o no está en la curva.En el error,x=nil.</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal asigna un elemento XML o un valor de atributo a un bool estableciéndolo en el valor booleano representado por la cadena.Los espacios en blanco se recortan e ignoran.</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">Unmarshal asigna un valor de elemento o atributo XML a una rebanada ampliando la longitud de la misma y asignando el elemento o atributo al valor recién creado.</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal asigna un elemento o valor de atributo XML a un campo entero o de punto flotante estableciendo el campo al resultado de interpretar el valor de la cadena en decimal.No se comprueba el desbordamiento.Los espacios en blanco se recortan e ignoran.</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">Unmarshal mapea un elemento XML a un Nombre grabando el nombre del elemento.</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">Unmarshal asigna un elemento XML a un puntero estableciendo el puntero a un valor recién asignado y luego asignando el elemento a ese valor.</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">Unmarshal asigna un elemento XML a una cadena o []byte guardando la concatenación de los datos de los caracteres de ese elemento en la cadena o []byte.El []byte guardado nunca es nulo.</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">Unmarshal mapea un elemento XML a una estructura usando las siguientes reglas.En las reglas,la etiqueta de un campo se refiere al valor asociado a la clave 'xml' en la etiqueta del campo de la estructura (véase el ejemplo anterior).</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">Unmarshal asigna un valor de atributo a una cadena o []byte guardando el valor en la cadena o rebanada.</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="translated">Unmarshal asigna un valor de atributo a un Attr guardando el atributo,incluyendo su nombre,en el Attr.</target>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">Unmarshal analiza la estructura de datos ASN.1 codificada con DER b y utiliza el paquete reflect para rellenar un valor arbitrario señalado por val.Debido a que Unmarshal usa el paquete reflect,las estructuras a las que se escribe deben usar nombres de campo en mayúsculas.</target>
        </trans-unit>
        <trans-unit id="896b9d75411fe008ac002fa69d65a02d32ae68e8" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">Unmarshal analiza los datos codificados por JSON y almacena el resultado en el valor señalado por v.Si v es nulo o no es un puntero,Unmarshal devuelve un InvalidUnmarshalError.</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">Unmarshal analiza los datos codificados en XML y almacena el resultado en el valor señalado por v,que debe ser una estructura,un trozo o una cadena arbitraria.Los datos bien formados que no encajan en v son descartados.</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal utiliza el inverso de las codificaciones que usa Marshal,asignando mapas,rebanadas y punteros según sea necesario,con las siguientes reglas adicionales:</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary implementa la interfaz encoding.BinaryUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary debe ser capaz de decodificar la forma generada por MarshalBinary.UnmarshalBinary debe copiar los datos si desea conservar los datos después de regresar.</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON implementa la interfaz json.Unmarshaler.</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON implementa la interfaz json.Unmarshaler.Se espera que la hora sea una cadena de texto en formato RFC 3339.</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON establece *m a una copia de datos.</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText implementa la interfaz de codificación.TextUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText implementa la interfaz de codificación.TextUnmarshaler.La dirección IP se espera en una forma aceptada por ParseIP.</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText implementa la interfaz de codificación.TextUnmarshaler.El resultado se redondea según la precisión y el modo de redondeo de z.Si la precisión de z es 0,se cambia a 64 antes de que el redondeo tenga efecto.</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText implementa la interfaz de codificación.TextUnmarshaler.Se espera que la hora esté en formato RFC 3339.</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText debe ser capaz de decodificar la forma generada por MarshalText.UnmarshalText debe copiar el texto si desea conservar el texto después de regresar.</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams permite especificar parámetros de campo para el elemento de nivel superior.La forma de los parámetros es la misma que la de las etiquetas de campo.</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML decodifica un solo elemento XML comenzando con el elemento de inicio dado.Si devuelve un error,la llamada externa a Unmarshal se detiene y devuelve ese error.UnmarshalXML debe consumir exactamente un elemento XML.Una estrategia de implementación común es desmarcarse en un valor separado con una disposición que coincida con el XML esperado utilizando d.DecodeElement,y luego copiar los datos de ese valor en el receptor.Otra estrategia común es utilizar d.Token para procesar el objeto XML un token a la vez.UnmarshalXML puede no utilizar d.RawToken.</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr decodifica un único atributo XML.Si devuelve un error,la llamada externa a Unmarshal se detiene y devuelve ese error.UnmarshalXMLAttr se utiliza sólo para campos estructurales con la opción &quot;attr&quot; en la etiqueta del campo.</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">El desmarcador es la interfaz implementada por los objetos que pueden desmarcar un elemento XML de descripción de sí mismos.</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">El desmarcador es la interfaz implementada por tipos que pueden desmarcar una descripción JSON de sí mismos.Se puede asumir que la entrada es una codificación válida de un valor JSON.UnmarshalJSON debe copiar los datos JSON si desea conservar los datos después de regresar.</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr es la interfaz implementada por los objetos que pueden desmarcar una descripción de atributos XML de sí mismos.</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Unquote and UnquoteChar unquote Go string and rune literals.</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote interpreta la s como una cadena de Go literal de una sola cita,doble cita o cita inversa,devolviendo el valor de la cadena que s cita.(Si s se cita una sola vez,sería un literal de carácter Go;Unquote devuelve la correspondiente cadena de un carácter).</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar decodifica el primer carácter o byte de la cadena escapada o el carácter literal representado por la cadena s.Devuelve cuatro valores:</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage extrae un nombre entre comillas de la cadena de uso de una bandera y lo devuelve junto con el uso no entre comillas.Si se le da &quot;un nombre para mostrar&quot;,devuelve (&quot;nombre&quot;,&quot;un nombre para mostrar&quot;).Si no hay comillas,el nombre es una suposición educada del tipo de valor de la bandera,o la cadena vacía si la bandera es booleana.</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte hace que la siguiente llamada a ReadByte devuelva el mismo byte que la anterior llamada a ReadByte.Puede ser un error llamar a UnreadByte dos veces sin una llamada intermedia a ReadByte.</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte complementa a ReadByte en la implementación de la interfaz io.ByteScanner.</target>
        </trans-unit>
        <trans-unit id="5f3d5858f8afa80b57a7c212de39d0a9aff8df3f" translate="yes" xml:space="preserve">
          <source>UnreadByte implements the io.ByteScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">El UnreadByte devuelve un error si el método más reciente llamado en el Lector no fue una operación de lectura.Notablemente,Peek no se considera una operación de lectura.</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte no lee el último byte devuelto por la más reciente operación de lectura exitosa que leyó al menos un byte.Si se ha producido una escritura desde la última lectura,si la última lectura ha devuelto un error,o si la lectura ha sido de cero bytes,UnreadByte devuelve un error.</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte no lee el último byte.Sólo el último byte leído puede ser no leído.</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune hace que la siguiente llamada a ReadRune devuelva la misma runa que la anterior llamada a ReadRune.Puede ser un error llamar a UnreadRune dos veces sin una llamada intermedia a ReadRune.</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune complementa a ReadRune en la implementación de la interfaz io.RuneScanner.</target>
        </trans-unit>
        <trans-unit id="8842945f04ec11d52129a0fe96a5f0b4f9dd3388" translate="yes" xml:space="preserve">
          <source>UnreadRune implements the io.RuneScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune no lee la última runa devuelta por ReadRune.Si la más reciente operación de lectura o escritura en el buffer no fue una ReadRune exitosa,UnreadRune devuelve un error.(En este sentido es más estricto que UnreadByte,que des-leerá el último byte de cualquier operación de lectura).</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune no lee la última runa.Si el método más reciente llamado en el lector no era una ReadRune,UnreadRune devuelve un error.(En este sentido es más estricto que UnreadByte,que desleerá el último byte de cualquier operación de lectura).</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr devuelve un puntero a los datos de V.Es para clientes avanzados que también importan el paquete &quot;inseguro&quot;.Entra en pánico si la v no es direccionable.</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Unsetenv desestabiliza una única variable de entorno.</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">UnsupportedTypeError se devuelve cuando Marshal encuentra un tipo que no puede ser convertido a XML.</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">Until devuelve la duración hasta t.Es la abreviatura de t.Sub(time.Now()).</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">Unwrap devuelve el resultado de llamar al método Unwrap en err,si el tipo de err contiene un error de retorno del método Unwrap.En caso contrario,Unwrap devuelve nil.</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">Desenvuelve los errores envueltos.Si el tipo de su argumento tiene un método de desenvolvimiento,llama al método una vez.De lo contrario,devuelve cero.</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">La actualización reemplaza un nodo antiguo en el mapa de comentarios con el nuevo nodo y devuelve el nuevo nodo.Los comentarios que estaban asociados al nodo antiguo se asocian al nuevo nodo.</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">La actualización devuelve el resultado de la adición de los bytes en p al crc.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage imprime un mensaje de uso documentando todas las banderas de línea de comandos definidas a la salida de CommandLine,que por defecto es os.Stderr.Se llama cuando se produce un error al analizar los indicadores.La función es una variable que se puede cambiar para que apunte a una función personalizada.Por defecto,imprime un encabezado simple y llama a PrintDefaults;para más detalles sobre el formato de la salida y cómo controlarla,consulte la documentación de PrintDefaults.Las funciones de uso personalizado pueden elegir salir del programa;por defecto,la salida se produce de todas formas ya que la estrategia de manejo de errores de la línea de comandos se establece en ExitOnError.</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">Use GoTokens para configurar el Escáner de tal manera que acepte todos los tokens literales de Go,incluyendo los identificadores de Go.Los comentarios serán omitidos.</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">Utilice un Escáner para implementar una simple utilidad de recuento de palabras,escaneando la entrada como una secuencia de fichas delimitadas por el espacio.</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">Usar un Escáner con una función de división personalizada (construida mediante la envoltura de ScanWords)para validar la entrada de decimales de 32 bits.</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">Utilice un escáner con una función de división personalizada para analizar una lista separada por comas con un valor final vacío.</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">Utilice los valores de contexto sólo para los datos de solicitud que transitan por procesos y API,no para pasar parámetros opcionales a las funciones.</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">El uso de este tipo presenta un riesgo de seguridad:el contenido encapsulado debe provenir de una fuente de confianza,ya que se incluirá textualmente en la salida de la plantilla.</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber hace que el Decodificador desmarque un número en una interfaz{}como un Número en lugar de como un float64.</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">Anotación del usuario</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">El usuario representa una cuenta de usuario.</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">El usuario devuelve un Userinfo que contiene el nombre de usuario proporcionado y ninguna contraseña establecida.</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">El UserAgent devuelve el User-Agent del cliente,si se ha enviado la solicitud.</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir devuelve el directorio raíz predeterminado para utilizar los datos en caché específicos del usuario.Los usuarios deben crear su propio subdirectorio específico de la aplicación dentro de éste y utilizarlo.</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir devuelve el directorio raíz predeterminado para usar los datos de configuración específicos del usuario.Los usuarios deben crear su propio subdirectorio específico de la aplicación dentro de éste y utilizarlo.</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir devuelve el directorio principal del usuario actual.</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword devuelve un Userinfo que contiene el nombre de usuario y la contraseña proporcionados.</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime devuelve el tiempo de la CPU del usuario del proceso saliente y sus hijos.</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">El nombre de usuario devuelve el nombre de usuario.</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">El uso de GOOS=androide coincide con la construcción de etiquetas y archivos como para GOOS=linux además de las etiquetas y archivos de androide.</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">El uso de GOOS=illumos coincide con la construcción de etiquetas y archivos como para GOOS=solaris además de las etiquetas y archivos de illumos.</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">Usar JS para incluir a JSON válido pero no confiable no es seguro.Una alternativa segura es analizar el JSON con json.Unmarshal y luego pasar el objeto resultante a la plantilla,donde se convertirá en JSON saneado cuando se presente en un contexto de JavaScript.</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">Usar un calificador nulo equivale a usar (*Paquete).Ruta:el objeto se califica por la ruta de importación,por ejemplo,&quot;codificando/json.Marshal&quot;.</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint decodifica un uint64 de buf y devuelve ese valor y el n&amp;uacute;mero de bytes le&amp;iacute;dos (&amp;gt; 0). Si ocurri&amp;oacute; un error, el valor es 0 y el n&amp;uacute;mero de bytes n es &amp;lt;= 0, lo que significa:</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Val devuelve el valor de la constante.</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val devuelve el valor subyacente para una constante dada.Dado que devuelve una interfaz,corresponde a la persona que llama afirmar el resultado al tipo esperado.Los posibles tipos de retorno dinámico son:</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val devuelve el valor asociado al atributo Attr in Entry,o nulo si no existe dicho atributo.</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">Informes válidos si los datos son una codificación JSON válida.</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">Valid informa si p consiste enteramente de runas válidas codificadas en UTF-8.</target>
        </trans-unit>
        <trans-unit id="9519df7a8cc1237bbc29245d3ead17c2ceaba31e" translate="yes" xml:space="preserve">
          <source>ValidPath reports whether the given path name is valid for use in a call to Open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune informa si la r puede ser codificada legalmente como UTF-8.Los puntos de código que están fuera de rango o una mitad sustituta son ilegales.</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString informa si la s consiste enteramente de runas válidas codificadas en UTF-8.</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">Validate realiza comprobaciones básicas de cordura en la llave.Devuelve cero si la llave es válida,o bien un error que describe un problema.</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">Valor (Config)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">Valor (LeerMayoritariamente)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value implementa la interfaz del conductor Valuer.</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">El valor es un valor que los conductores deben ser capaces de manejar.Puede ser nulo,un tipo manejado por la interfaz NamedValueChecker de un controlador de base de datos,o una instancia de uno de estos tipos:</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">El valor es la documentación para una declaración (posiblemente agrupada)var o const.</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">El valor es la interfaz con el valor dinámico almacenado en una bandera.(El valor por defecto se representa como una cadena).</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">El valor es la interfaz de reflexión de un valor Go.</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">El valor representa un valor de JavaScript.El valor cero es el valor JavaScript &quot;indefinido&quot;.</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678d207a532dcdea8e626b9a2f73dbb88876a486" translate="yes" xml:space="preserve">
          <source>Value represents a metric value returned by the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">El valor devuelve un valor arbitrario del tipo dado.Si el tipo implementa la interfaz del Generador,eso será utilizado.Nota:Para crear valores arbitrarios para las estructuras,todos los campos deben ser exportados.</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">El valor devuelve el valor de la entrada actual del mapa del iterador.</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter es la interfaz que proporciona el método ConvertValue.</target>
        </trans-unit>
        <trans-unit id="bfff933f54248b785748322ae516a5abd89e358e" translate="yes" xml:space="preserve">
          <source>ValueKind is a tag for a metric Value which indicates its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf devuelve un nuevo Valor inicializado al valor concreto almacenado en la interfaz i.ValueOf(nil)devuelve el Valor cero.</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf devuelve x como un valor de JavaScript:</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer es la interfaz que proporciona el método Value.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">Los valores que contienen los tipos definidos en este paquete no deben ser copiados.</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">Values asigna una clave de cadena a una lista de valores.Se utiliza típicamente para los parámetros de consulta y los valores de forma.A diferencia del mapa http.Header,las claves de un mapa de valores distinguen entre mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">Los valores de la interfaz de la imagen se crean llamando a funciones como NewRGBA y NewPaletted,o llamando a Decode en un io.Reader que contiene datos de imagen en un formato como GIF,JPEG o PNG.La decodificación de cualquier formato de imagen particular requiere el registro previo de una función decodificadora.El registro suele ser automático como efecto secundario de la inicialización del paquete de ese formato,de modo que,para decodificar una imagen PNG,basta con tener</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">Los valores que son compartidos tanto por R_PPC como por R_PPC64 llevan el prefijo R_POWERPC_en el estándar ELF.Para el tipo R_PPC,las reubicaciones compartidas relevantes han sido renombradas con el prefijo R_PPC_.El nombre original sigue al valor en un comentario.</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">Los valores que son compartidos tanto por R_PPC como por R_PPC64 llevan el prefijo R_POWERPC_en el estándar ELF.Para el tipo R_PPC64,las reubicaciones compartidas relevantes han sido renombradas con el prefijo R_PPC64_.El nombre original sigue al valor en un comentario.</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var define una bandera con el nombre y la cadena de uso especificados.El tipo y el valor del indicador están representados por el primer argumento,de tipo Valor,que normalmente contiene una implementación de Valor definida por el usuario.Por ejemplo,el llamador podría crear un indicador que convierta una cadena separada por comas en una rebanada de cadenas dando a la rebanada los métodos de Valor;en particular,Set descompondría la cadena separada por comas en la rebanada.</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var es un tipo abstracto para todas las variables exportadas.</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">Las variables previamente declaradas también pueden ser asignadas,usando la sintaxis</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Variadic informa si la firma s es variadic.</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint decodifica un int64 de buf y devuelve ese valor y el n&amp;uacute;mero de bytes le&amp;iacute;dos (&amp;gt; 0). Si ocurri&amp;oacute; un error, el valor es 0 y el n&amp;uacute;mero de bytes n es &amp;lt;= 0 con el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">Varios errores contenidos en OpError.</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">El paquete de controladores proporciona varias implementaciones de ValueConverter para ofrecer implementaciones coherentes de conversiones entre controladores.Los ValueConverters tienen varios usos:</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">Varios niveles de aislamiento que los conductores pueden soportar en BeginTx.Si un controlador no soporta un nivel de aislamiento determinado,se puede devolver un error.</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">Varios métodos apoyan las conversiones entre las cadenas y los valores numéricos correspondientes,y viceversa:Los valores *Int,*Rat y *Float implementan la interfaz de Stringer para una representación (por defecto)de cadena del valor,pero también proporcionan métodos SetString para inicializar un valor de una cadena en una variedad de formatos soportados (véase la documentación SetString respectiva).</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">Verbose informa si la bandera -test.v está puesta.</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">Verificar los intentos de verificar c construyendo una o más cadenas de c a un certificado en opts.Roots,utilizando certificados en opts.Intermediates si es necesario.Si tiene éxito,devuelve una o más cadenas donde el primer elemento de la cadena es c y el último elemento es de opts.Roots.</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">Verificar comprueba la validez de una dirección de correo electrónico en el servidor.Si Verificar devuelve cero,la dirección es válida.Un retorno no nulo no indica necesariamente una dirección inválida.Muchos servidores no verifican las direcciones por razones de seguridad.</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">Verifica los informes si la firma de sig es una firma válida de mensaje de PublicKey.Entrará en pánico si len(publicKey)no es PublicKeySize.</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">Verifica la firma en r,s de hash usando la clave pública,pub.Informa si la firma es válida.</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">Verifica la firma en r,s de hash usando la clave pública,pub.Su valor de retorno registra si la firma es válida.</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">VerifyHostname comprueba que la cadena de certificados de pares es válida para conectarse al host.Si es así,devuelve cero;si no,devuelve un error que describe el problema.</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">VerificarNombreDeHostes devuelve cero si c es un certificado válido para el anfitrión nombrado.De lo contrario,devuelve un error que describe la falta de coincidencia.</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions contiene los parámetros para Certificate.Verify.Es una estructura porque otras API de verificación de PKIX han terminado necesitando muchas opciones.</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15 verifica una firma RSA PKCS#1 v1.5.hashed es el resultado de hacer hash del mensaje de entrada usando la función hash dada y sig es la firma.Una firma válida se indica devolviendo un error nulo.Si el hash es cero,entonces el hash se utiliza directamente.Esto no es aconsejable excepto para la interoperabilidad.</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS verifica una firma PSS.hashed es el resultado de hacer hash del mensaje de entrada usando la función hash dada y sig es la firma.Una firma válida se indica devolviendo un error nulo.El argumento opts puede ser nil,en cuyo caso se utilizan valores por defecto sensibles.</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">La versión se encuentra en Header.Ident[EI_VERSION]y Header.Version.</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">La versión es la edición Unicode de la que se derivan las tablas.</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">La versión devuelve la cadena de versiones del árbol de Go.Es o bien el hash de confirmación y la fecha en el momento de la construcción o,cuando sea posible,una etiqueta de liberación como &quot;go1.3&quot;.</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">Los valores muy grandes se desbordan a -1 o +Inf.</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">Los valores muy grandes se desbordan a 0 o +Inf.Valores muy pequeños se desbordan a 1.</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">Visita las banderas de la línea de mando en orden lexicográfico,llamando a fn para cada una.Visita sólo las banderas que han sido colocadas.</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">Visita las banderas en orden lexicográfico,llamando fn a cada una.Visita sólo las banderas que han sido colocadas.</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitaTodos visitan las banderas de la línea de mando en orden lexicográfico,llamando a fn para cada uno.Visita todas las banderas,incluso las que no están fijadas.</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitaTodos visitan las banderas en orden lexicográfico,llamando a fn para cada una.Visita todas las banderas,incluso las que no están fijadas.</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName devuelve el nombre del volumen principal.Si se le da &quot;C:\foo\bar&quot; devuelve &quot;C:&quot; en Windows.Si se le da &quot;hostshare&quot; devuelve &quot;hostshare&quot;.En otras plataformas devuelve &quot;C:&quot;.</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">ADVERTENCIA:esta función no hace ninguna comprobación de revocación.</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">ADVERTENCIA:el uso de esta función para encriptar otros textos planos que no sean claves de sesión es peligroso.Use RSA OAEP en los nuevos protocolos.</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">Esperar atómicamente desbloquea a C.L.y suspende la ejecución de la llamada goroutine.Después de reanudar la ejecución,Wait bloquea a C.L.antes de regresar.A diferencia de otros sistemas,Wait no puede regresar a menos que sea despertado por una transmisión o una señal.</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">Espera los bloques hasta que el contador del Grupo de Espera sea cero.</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">Wait libera cualquier recurso asociado con el Cmd.</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Wait espera a que el Proceso salga,y luego devuelve un ProcessState describiendo su estado y un error,si lo hay.Wait libera cualquier recurso asociado con el Proceso.En la mayoría de los sistemas operativos,el Proceso debe ser un hijo del proceso actual o se devolverá un error.</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">Wait espera a que el comando salga y espera a que se complete cualquier copia a stdin o copia desde stdout o stderr.</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait cerrará el tubo después de ver la salida del comando,así que la mayoría de los que llaman no necesitan cerrar el tubo ellos mismos;sin embargo,una implicación es que es incorrecto llamar a Wait antes de que todas las lecturas del tubo se hayan completado.Por la misma razón,es incorrecto llamar a Run cuando se usa StdoutPipe.Vea el ejemplo de uso idiomático.</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait cerrará el tubo después de ver la salida del comando,así que la mayoría de los que llaman no necesitan cerrar el tubo ellos mismos;sin embargo,una implicación es que es incorrecto llamar a Wait antes de que todas las lecturas del tubo se hayan completado.Por la misma razón,es incorrecto usar Run cuando se usa StderrPipe.Vea el ejemplo de StdoutPipe para el uso idiomático.</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="52552b817eeffba362a3c98137f71c8293e62c3c" translate="yes" xml:space="preserve">
          <source>Walk calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9374260d790571a0abca3c2ad0ee8f4b2fee093" translate="yes" xml:space="preserve">
          <source>Walk does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ff2f8a0272ea96bdd57633837c4d9205c5c003" translate="yes" xml:space="preserve">
          <source>Walk is less efficient than WalkDir, introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">La caminata atraviesa una AST en primer orden de profundidad:Comienza llamando a v.Visit(nodo);el nodo no debe ser nulo.Si el visitante w devuelto por v.Visit(node)no es nulo,el Paseo se invoca recursivamente con el visitante w para cada uno de los hijos no nulos del nodo,seguido de una llamada de w.Visit(nil).</target>
        </trans-unit>
        <trans-unit id="448218872286b5074a9a3f4fa32510a7919bca39" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk recorre el árbol de archivos enraizado en la raíz,llamando a walkFn para cada archivo o directorio del árbol,incluyendo la raíz.Todos los errores que surgen al visitar archivos y directorios son filtrados por walkFn.Los archivos se recorren en orden léxico,lo que hace que la salida sea determinista pero significa que para directorios muy grandes Walk puede ser ineficiente.Walk no sigue los enlaces simbólicos.</target>
        </trans-unit>
        <trans-unit id="3474b62445a988d8dd7132a772a85658690ff2ba" translate="yes" xml:space="preserve">
          <source>WalkDir calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909c3003cad6334b97769f490356bda189f1f4c" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2944078867d26e9f67caf63090c30efa8665e473" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4671bbf058367649fe2ca3dc374a89674b38ba9a" translate="yes" xml:space="preserve">
          <source>WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a3cdec2023da7868097ad68f8742c9c0a18055" translate="yes" xml:space="preserve">
          <source>WalkDirFunc is the type of the function called by WalkDir to visit each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a839647907d9b3be60eae8967669c7e1dc729b5" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called by Walk to visit each each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc es el tipo de función llamada para cada archivo o directorio visitado por Walk.El argumento de ruta contiene el argumento de Walk como prefijo;es decir,si se llama a Walk con &quot;dir&quot;,que es un directorio que contiene el archivo &quot;a&quot;,se llamará a la función Walk con el argumento &quot;dir/a&quot;.El argumento info es el os.FileInfo para el camino nombrado.</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">Warning registra un mensaje con severidad LOG_WARNING,ignorando la severidad pasada a New.</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">Definimos códigos para cada error que se manifiesta al escapar de las plantillas,pero las plantillas escapadas también pueden fallar en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe es una paleta de 216 colores que fue popularizada por las primeras versiones de Netscape Navigator.También se conoce como el Cubo de Color de Netscape.</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">El día de la semana devuelve el día de la semana especificado por t.</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">Las conocidas direcciones IPv4</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">Direcciones IPv6 bien conocidas</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">Cuando el código Go se construye con opciones como -buildmode=c-compartido,se ejecutará como parte de un programa no-Go existente.El código no-Go puede tener ya instalados los manejadores de señal cuando se inicia el código Go (eso también puede suceder en casos inusuales cuando se usa cgo o SWIG;en ese caso,se aplica la discusión aquí).Para -buildmode=c-archive el tiempo de ejecución de Go inicializará las señales en tiempo de construcción global.Para -buildmode=c-shared el tiempo de ejecución de Go inicializará las señales cuando se cargue la biblioteca compartida.</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">Cuando Read encuentra un error o una condici&amp;oacute;n de fin de archivo despu&amp;eacute;s de leer con &amp;eacute;xito n&amp;gt; 0 bytes, devuelve el n&amp;uacute;mero de bytes le&amp;iacute;dos. Puede devolver el error (no nulo) de la misma llamada o devolver el error (y n == 0) de una llamada posterior. Un ejemplo de este caso general es que un lector que devuelve un n&amp;uacute;mero de bytes distinto de cero al final del flujo de entrada puede devolver err == EOF o err == nil. La siguiente lectura deber&amp;iacute;a devolver 0, EOF.</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">Cuando ReadAt devuelve n &amp;lt;len (p), devuelve un error no nulo que explica por qu&amp;eacute; no se devolvieron m&amp;aacute;s bytes. En este sentido, ReadAt es m&amp;aacute;s estricto que Read.</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">Cuando se llama a Shutdown,Serve,ListenAndServe y ListenAndServeTLS devuelven inmediatamente ErrServerClosed.Asegúrese de que el programa no salga y espere en su lugar a que vuelva Shutdown.</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">Cuando la ficha encuentra un error o una condición de fin de archivo después de haber leído con éxito una ficha,devuelve la ficha.Puede devolver el error (no nulo)de la misma llamada o devolver el error (y un token nulo)de una llamada posterior.Un ejemplo de este caso general es que un TokenReader que devuelve un token no nulo al final del flujo de tokens puede devolver un error io.EOF o un error nulo.El siguiente Read debería devolver nil,io.EOF.</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">Cuando un programa de Go escribe a una tubería rota,el núcleo levantará una señal de SIGPIPE.</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">Cuando un valor de datos no es texto plano,puedes asegurarte de que no se escape marcándolo con su tipo.</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">Cuando se abre un plugin por primera vez,se llaman las funciones de inicio de todos los paquetes que no forman parte del programa.La función principal no se ejecuta.Un plugin sólo se inicializa una vez,y no puede ser cerrado.</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">Cuando se llama a SetCgoTraceback,el argumento de versión es el número de versión de las estructuras que las funciones esperan recibir.Actualmente este debe ser cero.</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">Cuando cgo está disponible,se utiliza por defecto el código basado en cgo (respaldado por libc).Esto puede ser anulado usando la etiqueta de construcción osusergo,que refuerza la implementación de Go puro.</target>
        </trans-unit>
        <trans-unit id="3d68b88a257e3f62b9428ba8c7fdd32a8b354868" translate="yes" xml:space="preserve">
          <source>When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '&amp;amp;'. To force other encodings, use the following tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">Cuando err es nulo,resp siempre contiene un cuerpo no nulo.La persona que llama debe cerrar la resp.Body cuando termine de leerla.</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">Cuando comienza la ejecución,se establece $ al argumento de datos que se pasa a Ejecutar,es decir,al valor inicial de punto.</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">Al seguir las redirecciones,el Cliente reenviará todas las cabeceras establecidas en la solicitud inicial excepto:</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">Al comparar con el texto,el regexp devuelve una coincidencia que comienza lo antes posible en la entrada (la más a la izquierda),y entre ellas elige la que una búsqueda de retroceso habría encontrado primero.Esta llamada coincidencia más a la izquierda es la misma semántica que utilizan Perl,Python y otras implementaciones,aunque este paquete la implementa sin el gasto de retroceso.Para la coincidencia más larga a la izquierda de POSIX,ver CompilePOSIX.</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">Cuando se analiza una plantilla,se puede definir otra plantilla y asociarla a la plantilla que se analiza.Las definiciones de plantillas deben aparecer en el nivel superior de la plantilla,como las variables globales en un programa Go.</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">Cuando se analiza un tiempo con una abreviatura de zona como MST,si la abreviatura de la zona tiene un desplazamiento definido en la ubicación actual,entonces se utiliza ese desplazamiento.La abreviatura de la zona &quot;UTC&quot; se reconoce como UTC independientemente de la ubicación.Si se desconoce la abreviatura de la zona,Parse registra la hora como si estuviera en una ubicación fabricada con la abreviatura de la zona dada y un offset cero.Esta elección significa que tal hora puede ser analizada y reformateada con el mismo diseño sin pérdida,pero el instante exacto utilizado en la representación diferirá por el desplazamiento real de la zona.Para evitar tales problemas,prefiera las disposiciones de tiempo que utilizan un desplazamiento de zona numérico,o utilice ParseInLocation.</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">Al analizar una hora con un desfase de zona como -0700,si el desfase corresponde a una zona horaria utilizada por la ubicación actual (Local),entonces Parse utiliza esa ubicación y zona en el tiempo devuelto.De lo contrario,registra la hora como si estuviera en una ubicación fabricada con la hora fijada en el desplazamiento de la zona dada.</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">Cuando se analizan varios archivos con el mismo nombre en diferentes directorios,el último mencionado será el que resulte.</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">Cuando se analizan varios archivos con el mismo nombre en diferentes directorios,el último mencionado será el que resulte.Por ejemplo,ParseFiles(&quot;a/foo&quot;,&quot;b/foo&quot;)almacena &quot;b/foo&quot; como la plantilla llamada &quot;foo&quot;,mientras que &quot;a/foo&quot; no está disponible.</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">Al imprimir una estructura,fmt no puede y,por lo tanto,no invoca métodos de formato como Error o String en los campos no exportados.</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">Cuando se ejecuta un gran conjunto de casos de prueba secuenciales,la comprobación de la cobertura después de cada uno puede ser útil para identificar qué casos de prueba ejercen nuevas rutas de código.No es un sustituto de los informes generados por &quot;go test -cover&quot; y &quot;go tool cover&quot;.</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">Cuando la ejecución del modelo invoca una función con una lista de argumentos,esa lista debe ser asignable a los tipos de parámetros de la función.Las funciones destinadas a aplicarse a los argumentos de tipo arbitrario pueden utilizar parámetros de tipo interface{}o de tipo reflect.Value.Del mismo modo,las funciones destinadas a devolver un resultado de tipo arbitrario pueden devolver interface{}o reflect.Value.</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">Cuando se desmarcan las cadenas citadas,los UTF-8 inválidos o los pares sustitutos UTF-16 inválidos no se tratan como un error.En su lugar,son reemplazados por el carácter de reemplazo de Unicode U+FFFD.</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">Cuando se utiliza el TCP,y el host en el parámetro de dirección se resuelve a múltiples direcciones de red,cualquier tiempo de espera de marcación (desde d.Timeout o ctx)se reparte en cada marcación consecutiva,de manera que a cada uno se le da una fracción apropiada del tiempo para conectarse.Por ejemplo,si un host tiene 4 direcciones IP y el tiempo de espera es de 1 minuto,la conexión a cada una de las direcciones tendrá 15 segundos para completarse antes de intentar la siguiente.</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">Al usar el resolver de la biblioteca C del anfitrión,como mucho se devolverá un resultado.Para evitar la resolución del host,utilice una resolución personalizada.</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">El hecho de que un comentario se asocie a un nodo y la forma en que lo haga depende de la interpretación del árbol de sintaxis por parte del programa manipulador:Excepto los comentarios de Doc y Comment directamente asociados a los nodos,el resto de los comentarios son &quot;flotantes&quot; (ver también los números #18593,#20744).</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">Si bien sería correcto que la función de contexto registrara una traza completa de la pila siempre que se la llamara,y que simplemente la copiara en la función de rastreo,en un programa típico la función de contexto se llamará muchas veces sin registrar nunca una traza para ese contexto.Es probable que el registro de una traza de pila completa en una llamada a la función de contexto sea ineficiente.</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">Mientras que el método FileSystem.Open toma rutas separadas por '/',el valor de la cadena de un Dir es un nombre de archivo en el sistema de archivos nativo,no una URL,por lo que está separado por filepath.Separator,que no es necesariamente '/'.</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">El espacio blanco se considera parte de un campo.</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">El ancho y la precisión se miden en unidades de puntos de código Unicode,es decir,runas.(Esto difiere de la impresión de C,donde las unidades se miden siempre en bytes.)Una o ambas banderas pueden ser reemplazadas por el carácter &quot;*&quot;,haciendo que sus valores se obtengan del siguiente operando (precediendo al de formato),que debe ser de tipo int.</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">El ancho se interpreta en el texto de entrada pero no hay sintaxis para escanear con precisión (no %5.2f,sólo %5f).Si se proporciona width,se aplica después de que se recorten los espacios de las líneas y especifica el número máximo de runas a leer para satisfacer el verbo.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">La anchura se especifica mediante un número decimal opcional que precede inmediatamente al verbo.En caso de ausencia,la anchura es lo que sea necesario para representar el valor.La precisión se especifica después de la anchura (opcional)por un punto seguido de un número decimal.Si no hay punto,se utiliza una precisión por defecto.Un punto sin número siguiente especifica una precisión de cero.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">Con la autenticación básica de HTTP,el nombre de usuario y la contraseña proporcionados no están encriptados.</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">Con la excepción de los comentarios,que se omiten si se establece SkipComments,las fichas no reconocidas no se ignoran.En su lugar,el escáner simplemente devuelve los respectivos caracteres individuales (o posiblemente los subtocales).Por ejemplo,si el modo es ScanIdents (no ScanStrings),la cadena &quot;foo&quot; se escanea como la secuencia de símbolos '&quot;'.Ident '&quot;'.</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">Con Cancelar devuelve una copia de padre con un nuevo canal de Hecho.El canal Hecho del contexto devuelto se cierra cuando se llama a la función de cancelación devuelta o cuando se cierra el canal Hecho del contexto padre,lo que ocurra primero.</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">ConClientTrace se devuelve un nuevo contexto basado en el ctx padre proporcionado.Las solicitudes de clientes HTTP realizadas con el contexto devuelto utilizarán los ganchos de rastreo proporcionados,además de cualquier gancho anterior registrado con ctx.Cualquier gancho definido en el rastreo proporcionado será llamado primero.</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">ConContexto devuelve una copia superficial de r con su contexto cambiado a ctx.La ctx proporcionada debe ser no nula.</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline devuelve una copia del contexto del padre con el plazo ajustado para que no sea posterior a d.Si el plazo del padre ya es anterior a d,WithDeadline(padre,d)es semánticamente equivalente al padre.El canal Hecho del contexto devuelto se cierra cuando el plazo expira,cuando se llama a la función de cancelación devuelta o cuando se cierra el canal Hecho del contexto padre,lo que ocurra primero.</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">Con Etiquetas devuelve un nuevo contexto.Contexto con las etiquetas dadas añadidas.Una etiqueta sobrescribe una etiqueta anterior con la misma clave.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
