<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">Catorce macros C y quince funciones C que se pueden utilizar para escribir mapas tipográficos especializados,extensiones o funciones en línea que manejan casos no cubiertos por los mapas tipográficos proporcionados.Obsérvese que las macros y funciones están codificadas específicamente para funcionar con la NumPy C/API independientemente del número de versión de NumPy,tanto antes como después de la depreciación de algunos aspectos de la API después de la versión 1.6.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Parte fraccionaria de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Francis Hunt y Paul Johnson,Sobre la distribución en Pareto de los proyectos de Sourceforge.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">Los contenedores de frecuencia para determinados parámetros de FFT.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">La norma Frobenius</target>
        </trans-unit>
        <trans-unit id="b496ebf456418bea6f72b4dd532369d14b955f9b" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeadfde385f544a91cc8eaeeffa0c5ba93e6dc7d" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">De Dalgaard, p&amp;aacute;gina 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , suponga que la ingesta diaria de energ&amp;iacute;a de 11 mujeres en kilojulios (kJ) es:</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">De Dalgaard, p&amp;aacute;gina 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , suponga que la ingesta diaria de energ&amp;iacute;a de 11 mujeres en kilojulios (kJ) es:</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">De una matriz de 4x3, los elementos de las esquinas deben seleccionarse mediante indexaci&amp;oacute;n avanzada. Por lo tanto, todos los elementos para los que la columna es una de &lt;code&gt;[0, 2]&lt;/code&gt; y la fila es una de &lt;code&gt;[0, 3]&lt;/code&gt; deben seleccionarse. Para utilizar la indexaci&amp;oacute;n avanzada, es necesario seleccionar todos los elementos &lt;em&gt;expl&amp;iacute;citamente&lt;/em&gt; . Usando el m&amp;eacute;todo explicado anteriormente, se podr&amp;iacute;a escribir:</target>
        </trans-unit>
        <trans-unit id="a91be0fd97aa12da8097d28986c00ba2a4f3a53c" translate="yes" xml:space="preserve">
          <source>From a Fortran routine signature F2PY generates a Python/C extension function that has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">De una fecha y hora:</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">De una matriz,seleccione todas las filas que sumen menos o igual a dos:</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">De cada fila, se debe seleccionar un elemento espec&amp;iacute;fico. El &amp;iacute;ndice de fila es simplemente &lt;code&gt;[0, 1, 2]&lt;/code&gt; y el &amp;iacute;ndice de columna especifica el elemento a elegir para la fila correspondiente, aqu&amp;iacute; &lt;code&gt;[0, 1, 0]&lt;/code&gt; . Usando ambos juntos, la tarea se puede resolver usando indexaci&amp;oacute;n avanzada:</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">A partir de los datos existentes</target>
        </trans-unit>
        <trans-unit id="1978da17047230ecfb709900d093fe2bc00bb2a8" translate="yes" xml:space="preserve">
          <source>From now on &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; will know that &lt;code&gt;my-new-feature&lt;/code&gt; is related to the &lt;code&gt;my-new-feature&lt;/code&gt; branch in your own &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo. Subsequent push calls are then simplified to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">De otros objetos</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">Desde el principio</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8689c1f53f242e3e2ed351ba13d4443b972a335" translate="yes" xml:space="preserve">
          <source>From the output above, we can see that every value in &lt;code&gt;img[:,:,0]&lt;/code&gt; is an integer value between 0 and 255, representing the level of red in each corresponding image pixel (keep in mind that this might be different if you use your own image instead of &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt;&lt;code&gt;scipy.misc.face&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487083148a4854e5ec264b4e7603e6d383b8513e" translate="yes" xml:space="preserve">
          <source>From time to time you may want to pull down the latest code. Do this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541d68d9d4a26a74b3b1aec38602641c99c42b4f" translate="yes" xml:space="preserve">
          <source>Full broadcasting support for &lt;code&gt;np.cross&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">Clase indirecta completa</target>
        </trans-unit>
        <trans-unit id="b5dd204ac7b63984bfca215999235cdddc1cbe34" translate="yes" xml:space="preserve">
          <source>Full indirect sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">Una clase completa.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">Clasificación completa</target>
        </trans-unit>
        <trans-unit id="b375e36a5e2c847719599e1c9bc607f532495b26" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;median&lt;/code&gt; used with &lt;code&gt;overwrite_input&lt;/code&gt; only partially sorts array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35686e8529228454146ad9f9eb6c40fa0abbf7c" translate="yes" xml:space="preserve">
          <source>Function and macro call style: &lt;code&gt;foo(a, b, c)&lt;/code&gt;, no space before the open paren, no spaces inside the parens, no spaces before commas, one space after each comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Llamada de función</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">Decorador de funciones para aplicar ciertas supresiones a toda una función.</target>
        </trans-unit>
        <trans-unit id="1ace8a404ff1b1cae179e78198d969ee763553f5" translate="yes" xml:space="preserve">
          <source>Function definition style: function name in column 1, outermost curly braces in column 1, blank line after local variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf873f24ebe960e5f8ab96d1bf1dafec8236126" translate="yes" xml:space="preserve">
          <source>Function documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">Función que opera en los ndarrays.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Puntero de funci&amp;oacute;n de &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">Funci&amp;oacute;n que convierte una matriz flotante en flotante. El valor predeterminado es &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que esto no parece hacer nada &amp;uacute;til en la implementaci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Funci&amp;oacute;n que convierte una matriz flotante o flotante en una matriz de enteros o enteros. El valor predeterminado es &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">Funci&amp;oacute;n que convierte un solo flotante en una cadena. El valor predeterminado es &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Funci&amp;oacute;n que convierte una matriz de enteros o enteros en una matriz flotante o flotante. El valor predeterminado es &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81aebc7824dc558f5740b2294a8d328bfb265c12" translate="yes" xml:space="preserve">
          <source>Function to apply on the &amp;ldquo;field&amp;rdquo; dimension. This function must support an &lt;code&gt;axis&lt;/code&gt; argument, like np.mean, np.sum, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">Función para ser usada para imprimir bonitas matrices.La función debe esperar un único argumento de la matriz y devolver una cadena de la representación de la matriz.Si no hay ninguno,la función se restablece a la función NumPy por defecto para imprimir matrices.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Funci&amp;oacute;n para calcular solo los bordes de los contenedores utilizados por la funci&amp;oacute;n de &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Funci&amp;oacute;n para calcular solo los bordes de los contenedores utilizados por la funci&amp;oacute;n de &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">Funci&amp;oacute;n para llamar a errores de punto flotante (modo 'llamada') u objeto cuyo m&amp;eacute;todo 'escribir' se usa para registrar dicho mensaje (modo 'registro').</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">Función que devuelve un bucle interior enmascarado para la UFUN</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">Programación funcional</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">Funciones para la Iteración</target>
        </trans-unit>
        <trans-unit id="c9d64db1884b2fd4f353a105874e4c3957322b65" translate="yes" xml:space="preserve">
          <source>Functions and Methods Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6da2fb68f3db64f0a7a53228a8721f52f6134f" translate="yes" xml:space="preserve">
          <source>Functions available from numpy.ma.testutils have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">Funciones que implementan caracter&amp;iacute;sticas internas. No todos estos punteros de funci&amp;oacute;n deben definirse para un tipo determinado. Los miembros necesarios son &lt;code&gt;nonzero&lt;/code&gt; , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; y &lt;code&gt;cast&lt;/code&gt; . Se supone que estas entradas no son &lt;code&gt;NULL&lt;/code&gt; y que las entradas &lt;code&gt;NULL&lt;/code&gt; provocar&amp;aacute;n un bloqueo del programa. Las otras funciones pueden ser &lt;code&gt;NULL&lt;/code&gt; , lo que significar&amp;aacute; una funcionalidad reducida para ese tipo de datos. (Adem&amp;aacute;s, la funci&amp;oacute;n distinta de cero se completar&amp;aacute; con una funci&amp;oacute;n predeterminada si es &lt;code&gt;NULL&lt;/code&gt; cuando registre un tipo de datos definido por el usuario).</target>
        </trans-unit>
        <trans-unit id="f48c175b4673c0bc456bc9f1ba654da2d9542a5c" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;numpy.random&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516c584b732d36ebda7d25fae38b326dc6d202ae" translate="yes" xml:space="preserve">
          <source>Functions in numpy.random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724fd9678ed45fd313d6c7db38a089943643ca5" translate="yes" xml:space="preserve">
          <source>Functions may be listed without descriptions, and this is preferable if the functionality is clear from the function name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">Las funciones que devuelven un &amp;iacute;ndice a lo largo de un eje, como &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , producen &amp;iacute;ndices adecuados para esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">Funciones que también están en el espacio de nombres numérico y en las matrices de retorno</target>
        </trans-unit>
        <trans-unit id="95335a3a51e2f80868a95521fb5668b275263818" translate="yes" xml:space="preserve">
          <source>Functions that don&amp;rsquo;t accept keyword arguments should be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7888c5dcdff069b34a3486459892edd2f262c97" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fb8e5272b3356bebe72ae19a144383754b4e" translate="yes" xml:space="preserve">
          <source>Functions without keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dad1764839322eb03eab6b07936a589482f90c1" translate="yes" xml:space="preserve">
          <source>Fundraising</source>
          <target state="translated">Fundraising</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">Explicaci&amp;oacute;n adicional del par&amp;aacute;metro &lt;code&gt;fmt&lt;/code&gt; ( especificador &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3abcbfb793b7e40f09b0f5479b45936952f0ec59" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;np.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7e1185b0b79852815db7f42a86a47fec5e9990" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;numpy.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">Adem&amp;aacute;s, tenga en cuenta la forma en &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; se combinan:</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">Adem&amp;aacute;s, las matrices creadas con esta funci&amp;oacute;n a menudo contienen memoria que se superpone a s&amp;iacute; misma, de modo que dos elementos son id&amp;eacute;nticos. Las operaciones de escritura vectorizadas en tales matrices ser&amp;aacute;n normalmente impredecibles. Incluso pueden dar resultados diferentes para arreglos peque&amp;ntilde;os, grandes o transpuestos. Dado que la escritura en estas matrices debe probarse y realizarse con mucho cuidado, es posible que desee utilizar &lt;code&gt;writeable=False&lt;/code&gt; para evitar operaciones de escritura accidentales.</target>
        </trans-unit>
        <trans-unit id="12143faa25aabfe7fe468016abec86297c6fcf15" translate="yes" xml:space="preserve">
          <source>Furthermore, numpy now provides a new function &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt; which is a safer and more efficient alternative for users who wish to convert structured arrays to unstructured arrays, as the view above is often indeded to do. This function allows safe conversion to an unstructured type taking into account padding, often avoids a copy, and also casts the datatypes as needed, unlike the view. Code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">Adem&amp;aacute;s, la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada es del mismo tipo que antes, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; . Cuando se invoca, &lt;code&gt;args&lt;/code&gt; es una lista de &lt;code&gt;nargs&lt;/code&gt; de longitud que contiene los datos de todos los argumentos de entrada / salida. Para una funci&amp;oacute;n elemental escalar, los &lt;code&gt;steps&lt;/code&gt; tambi&amp;eacute;n tienen una longitud &lt;code&gt;nargs&lt;/code&gt; , que denota los pasos utilizados para los argumentos. &lt;code&gt;dimensions&lt;/code&gt; es un puntero a un &amp;uacute;nico entero que define el tama&amp;ntilde;o del eje sobre el que se va a realizar un bucle.</target>
        </trans-unit>
        <trans-unit id="c462e5cfdac7c4df78636f70346d506c3e424749" translate="yes" xml:space="preserve">
          <source>Furthermore, using the &lt;code&gt;ndim&lt;/code&gt; property of this array, we can see that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22552b8bf29fce0c52d5fcd39548010b9e76338c" translate="yes" xml:space="preserve">
          <source>Future Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb0dc3b9f8b3f5bdca8fc1d87183e1bba912790" translate="yes" xml:space="preserve">
          <source>Future changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">Valor futuro</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">Valor futuro (por defecto=0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Valores futuros.Si toda la entrada es escalar,devuelve un flotador escalar.Si alguna entrada es tipo_arreglo,devuelve valores futuros para cada elemento de entrada.Si varias entradas son tipo_arry,todas deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="722af3dc654f5b03462276f1ddc84a2ecf2baa12" translate="yes" xml:space="preserve">
          <source>Future very uncertain: it&amp;rsquo;s the only part of Scipy not ported to Python 3 and is effectively deprecated in favor of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d739c24bbd3b77640efa7aa653675284eae750ca" translate="yes" xml:space="preserve">
          <source>FutureWarning to changed behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cee77152a751b028de81f7755bdc87bacc5925" translate="yes" xml:space="preserve">
          <source>FutureWarnings</source>
          <target state="translated">FutureWarnings</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">GH Golub y CF Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt; , Baltimore, MD, Johns Hopkins University Press, 1985, p&amp;aacute;g. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">G. Strang, &amp;ldquo;&amp;Aacute;lgebra lineal y sus aplicaciones, 2&amp;ordf; edici&amp;oacute;n&amp;rdquo;, Academic Press, p&amp;aacute;g. 182, 1980.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2da Ed., Orlando, FL, Academic Press, Inc., 1980, Varias p&amp;aacute;gs.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">G. Strang, &lt;em&gt;&amp;Aacute;lgebra lineal y sus aplicaciones&lt;/em&gt; , 2&amp;ordf; ed., Orlando, FL, Academic Press, Inc., 1980, p&amp;aacute;g. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">G. Strang, &lt;em&gt;&amp;Aacute;lgebra lineal y sus aplicaciones&lt;/em&gt; , 2&amp;ordf; ed., Orlando, FL, Academic Press, Inc., 1980, p&amp;aacute;g. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">G. Strang, &lt;em&gt;&amp;Aacute;lgebra lineal y sus aplicaciones&lt;/em&gt; , 2&amp;ordf; ed., Orlando, FL, Academic Press, Inc., 1980, p&amp;aacute;gs. 139-142.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">G. Strang, &lt;em&gt;&amp;Aacute;lgebra lineal y sus aplicaciones&lt;/em&gt; , Orlando, FL, Academic Press, Inc., 1980, p&amp;aacute;g. 285.</target>
        </trans-unit>
        <trans-unit id="2fe46435d8800606efbbb4738ea49577e004f01c" translate="yes" xml:space="preserve">
          <source>GUfuncs on empty arrays and NpyIter axis removal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">Cuadrados de Gauss-Chebyshev.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">Cuadrados de Gauss-Hermita.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Cuadrados Gauss-HermiteE.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">La cuadratura Gauss-Laguerre.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">La cuadratura de Gauss-Legendre.</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="0cffb2d4275e42dba57746961ea67052aaeef334" translate="yes" xml:space="preserve">
          <source>General Broadcasting Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ff3c8e4686a4c021328dd784ede1cb72d7755f" translate="yes" xml:space="preserve">
          <source>General Purpose Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">Comprobación general del tipo de pitón</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">Clase de excepci&amp;oacute;n de prop&amp;oacute;sito general, derivada de la excepci&amp;oacute;n de Python. Clase de excepci&amp;oacute;n, generada mediante programaci&amp;oacute;n en funciones linalg cuando una condici&amp;oacute;n relacionada con el &amp;aacute;lgebra lineal impedir&amp;iacute;a una ejecuci&amp;oacute;n m&amp;aacute;s correcta de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Producto de matriz generalizado, utilizando la segunda &amp;uacute;ltima dimensi&amp;oacute;n de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172636dd07a5cf344fc718f14e5f8bac9163a8d1" translate="yes" xml:space="preserve">
          <source>Generalized &lt;code&gt;flip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d7eab60b5c5966c3521dbaae99dc8efbf97f6cb" translate="yes" xml:space="preserve">
          <source>Generalized Ufuncs will now unlock the GIL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">Función Universal Generalizada API</target>
        </trans-unit>
        <trans-unit id="e299d19ac7292c1bf7156bae2d6dd21bd9fba291" translate="yes" xml:space="preserve">
          <source>Generalized axis support for median and percentile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">Clase de función generalizada.</target>
        </trans-unit>
        <trans-unit id="1a1bc0e8d9d246a721e301167a79c68d6cdef5b2" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow fixed-size dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d28b03b171fb860aee83a82f532e58c4e9fba3" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow flexible dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0046ab62e86cdc207bdc51ed66f39ae439778565" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">Los ufuncs generalizados se utilizan internamente en muchas funciones de linalg y en el conjunto de pruebas; los ejemplos siguientes se toman de &amp;eacute;stos. Para ufuncs que operan en escalares, la firma es &lt;code&gt;None&lt;/code&gt; , que es equivalente a '()' para cada argumento.</target>
        </trans-unit>
        <trans-unit id="b0078c3e5a20e2fad81f2acb827abe758030ac9d" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is None, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c0fe98002f4322da923b10684f6d5d099ff33" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs now accept &lt;code&gt;axes&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">Firma de funci&amp;oacute;n universal generalizada, por ejemplo, &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; para la multiplicaci&amp;oacute;n vectorizada matriz-vector. Si se proporciona, se &lt;code&gt;pyfunc&lt;/code&gt; a pyfunc con (y se espera que devuelva) matrices con formas dadas por el tama&amp;ntilde;o de las dimensiones del n&amp;uacute;cleo correspondientes. De forma predeterminada, se supone que &lt;code&gt;pyfunc&lt;/code&gt; toma escalares como entrada y salida.</target>
        </trans-unit>
        <trans-unit id="4bdfd56723e2a4630d0aa40f0eab7e7e821379e3" translate="yes" xml:space="preserve">
          <source>Generally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2257faa28ea2af0838b36329ac81b4299b5a11a1" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">Generalmente, el archivo debe generarse durante la compilaci&amp;oacute;n, ya que necesita cierta informaci&amp;oacute;n conocida solo en el momento de la compilaci&amp;oacute;n (por ejemplo, prefijo). Esto es principalmente autom&amp;aacute;tico si se usa el m&amp;eacute;todo de &lt;code&gt;Configuration&lt;/code&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; . Suponiendo que tenemos un archivo de plantilla foo.ini.in de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">Generar una matriz de 1 por 3 con 3 límites inferiores diferentes</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">Generar una matriz de 1 x 3 con 3 límites superiores diferentes</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">Generar un conjunto de 2 por 4 utilizando la radiodifusión con el tipo de uint8</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">Generar una matriz de 2 x 4 ints entre 0 y 4,inclusive:</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">Generar una serie de Chebyshev con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">Generar una serie de Hermite con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">Generar una serie de HermiteE con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">Generar una serie de Laguerre con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">Generar una serie de Legendre con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Generar en la matriz de Vandermonde.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">Generar un polinomio único con raíces dadas.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Generar una muestra aleatoria no uniforme de np.arange(5)de tamaño 3 sin reemplazo:</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Generar una muestra aleatoria no uniforme a partir de np.arange(5)de tamaño 3:</target>
        </trans-unit>
        <trans-unit id="15beef8541c11b005861875826a071b16faf6c61" translate="yes" xml:space="preserve">
          <source>Generate a single integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Generar una muestra aleatoria uniforme de np.arange(5)de tamaño 3 sin reemplazo:</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Generar una muestra aleatoria uniforme a partir de np.arange(5)de tamaño 3:</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">Generar e instalar un archivo de configuración npy-pkg a partir de una plantilla.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">Generar el archivo config.py que contiene la información system_info utilizada durante la construcción del paquete.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">Generar el paquete __config__.py archivo que contiene la información system_info utilizada durante la construcción del paquete.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">Generar el paquete __svn_version__.py a partir del número de revisión del SVN,será eliminado después de que python salga pero estará disponible cuando se ejecuten los comandos sdist,etc.</target>
        </trans-unit>
        <trans-unit id="60ff5f05cec532a7f8f7d819baeeb92b41c5296d" translate="yes" xml:space="preserve">
          <source>Generate random uint64 numbers in closed interval [off, off + rng].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8045f4bbe378a7866506cc0ecb5d877bf5eaf96" translate="yes" xml:space="preserve">
          <source>Generate the README files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412730131bc368e3c0dcb289c20fbf2554245c4" translate="yes" xml:space="preserve">
          <source>Generate variates from a multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">Genera una muestra aleatoria a partir de un determinado conjunto de 1-D</target>
        </trans-unit>
        <trans-unit id="d332ac6845c5273c1195174ec786fa2289b9b752" translate="yes" xml:space="preserve">
          <source>Generating author/pr lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">Generando matrices de índices</target>
        </trans-unit>
        <trans-unit id="4bc72cf76a431fc1b67a969426c355ba5d2b3044" translate="yes" xml:space="preserve">
          <source>Generating random numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d1bad0186174ecfcdc9782f2116277b7b05e0" translate="yes" xml:space="preserve">
          <source>Generator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="b9790b2a609e0a0a9945eb7f9ff37cc7c5acb58d" translate="yes" xml:space="preserve">
          <source>Generators should be documented just as functions are documented. The only difference is that one should use the &lt;strong&gt;Yields&lt;/strong&gt; section instead of the &lt;strong&gt;Returns&lt;/strong&gt; section. Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">Generadores:Objetos que transforman secuencias de bits aleatorios de un Generador de Bits en secuencias de números que siguen una distribución de probabilidad específica (como uniforme,Normal o Binomial)dentro de un intervalo especificado.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">Objeto genérico derivado de la excepción de la pitón,planteado por las funciones linalg.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">Funciones genéricas</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">Tipos genéricos</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">Obtenga un objeto Python de un tipo incorporado de ndarray, &lt;em&gt;arr&lt;/em&gt; , en la ubicaci&amp;oacute;n apuntada por itemptr. Devuelve &lt;code&gt;NULL&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">Consigue una copia del iterador como una matriz 1-D.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">Consigue una copia del iterador en su estado actual.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">Obtener estado de punto flotante.Se pasa un puntero a una variable local para evitar que las optimizaciones agresivas del compilador reodifiquen esta llamada de función en relación con el código que establece el estado,lo que podría conducir a resultados incorrectos.</target>
        </trans-unit>
        <trans-unit id="c919c3aaf29bde2f7fadef95afc3436e547fc4bb" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">Obtener estado de punto flotante.Devuelve una máscara de bits con las siguientes posibles banderas:</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">Obtener información de ayuda para una función,clase o módulo.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">Obtener información sobre el tamaño del paso de un tipo de fecha u hora.</target>
        </trans-unit>
        <trans-unit id="d0d9c57e1b16aa99fa5d9ab014f87b4ec73ded17" translate="yes" xml:space="preserve">
          <source>Get number of parallel build jobs set by the &amp;ndash;parallel command line argument of setup.py If the command did not receive a setting the environment variable NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of processors on the system, with a maximum of 8 (to prevent overloading the system if there a lot of CPUs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">Obtener o establecer el estado PRNG</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">Obtener o establecer la máscara de la matriz si no tiene campos con nombre.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">Obtenga o establezca la m&amp;aacute;scara de la matriz si no tiene campos con nombre. Para matrices estructuradas, devuelve un ndarray de valores booleanos donde las entradas son &lt;code&gt;True&lt;/code&gt; si &lt;strong&gt;todos&lt;/strong&gt; los campos est&amp;aacute;n enmascarados, &lt;code&gt;False&lt;/code&gt; en caso contrario:</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">Obtener información de recursos.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">Obtenga los valores de Python utilizados para el procesamiento de ufunc del &amp;aacute;rea de almacenamiento local de subprocesos a menos que se hayan establecido los valores predeterminados, en cuyo caso se omite la b&amp;uacute;squeda de nombres. El nombre se coloca como una cadena en el primer elemento de &lt;em&gt;* errobj&lt;/em&gt; . El segundo elemento es la funci&amp;oacute;n de b&amp;uacute;squeda para llamar a la devoluci&amp;oacute;n de llamada de error. El valor del tama&amp;ntilde;o de b&amp;uacute;fer buscado para usar se pasa a &lt;em&gt;bufsize&lt;/em&gt; y el valor de la m&amp;aacute;scara de error se coloca en &lt;em&gt;errmask&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">Obtener la forma actual de manejar los errores de punto flotante.</target>
        </trans-unit>
        <trans-unit id="1ad2852f86c694e329d03e73d07b76a105a8cebc" translate="yes" xml:space="preserve">
          <source>Get the local copy of the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">Obtener el número de dimensiones de un conjunto</target>
        </trans-unit>
        <trans-unit id="38abfcd88f93b84356fd5ce9430a9a3bce6aa97e" translate="yes" xml:space="preserve">
          <source>Get the shape of the array and a pointer to its actual data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Funci&amp;oacute;n getitem / setitem / copyswap: similar a ufuncs, estas funciones generalmente tienen dos rutas de c&amp;oacute;digo. Si &lt;code&gt;ALIGNED&lt;/code&gt; es False, usar&amp;aacute;n una ruta de c&amp;oacute;digo que almacena los argumentos para que est&amp;eacute;n alineados con la verdad.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">Obtiene una serie de avances que son fijos,o no cambiarán durante toda la iteración.Para las zancadas que pueden cambiar,el valor NPY_MAX_INTP se coloca en la zancada.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">Obtiene el &lt;code&gt;iterindex&lt;/code&gt; del iterador, que es un &amp;iacute;ndice que coincide con el orden de iteraci&amp;oacute;n del iterador.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">Obtiene el &lt;code&gt;iterindex&lt;/code&gt; que se est&amp;aacute; iterando. Si no se especific&amp;oacute; &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; , esto siempre devuelve el rango &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">Lleva el conjunto de punteros de datos directamente a las matrices (nunca a los buffers),lo que corresponde al índice de iteración 0.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">Obtiene el conjunto de zancadas para el eje especificado.Requiere que el iterador siga un multiíndice,y que no se habilite el buffer.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">Obtiene la instancia del generador de bits utilizada por el generador</target>
        </trans-unit>
        <trans-unit id="d159fd31101fbca3940d95031521a0aa1cca2dba" translate="yes" xml:space="preserve">
          <source>Getting at ndarray memory and accessing elements of the ndarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">Obteniendo opciones adicionales del compilador Fortran 77 de la fuente</target>
        </trans-unit>
        <trans-unit id="40231bcdbc4a93a29a6d8b82096fcd17f9064444" translate="yes" xml:space="preserve">
          <source>Getting started with Git development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e47f4c54647389b910573011e6826ea1e0a912" translate="yes" xml:space="preserve">
          <source>Git Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfff37d55b9830b2f87d05fbf99d4f09fbfa666c" translate="yes" xml:space="preserve">
          <source>Git configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5717316487921ed9c21d808282281daa39b5a4" translate="yes" xml:space="preserve">
          <source>Git for development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cbb73206931d6c5b9ae31c184bc49486ee1eb6" translate="yes" xml:space="preserve">
          <source>Git will then immediately bring up an editor for editing the commit message. After revising it, we get the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">Dar una nueva forma a una matriz sin cambiar sus datos.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">Darle una nueva forma a la matriz sin cambiar sus datos.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">Dada una secuencia de ceros de un polinomio:</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">Dada una secuencia de matrices ( &lt;em&gt;sort_keys&lt;/em&gt; ) de la misma forma, devuelve una matriz de &amp;iacute;ndices (similar a &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)) que ordenar&amp;iacute;a las matrices lexicogr&amp;aacute;ficamente. Una clasificaci&amp;oacute;n lexicogr&amp;aacute;fica especifica que cuando dos claves son iguales, el orden se basa en la comparaci&amp;oacute;n de claves posteriores. Es necesario definir una clasificaci&amp;oacute;n de combinaci&amp;oacute;n (que deja indiferentes las entradas iguales) para los tipos. El ordenamiento se logra ordenando los &amp;iacute;ndices primero usando la primera &lt;em&gt;clave_ ordenaci&amp;oacute;n&lt;/em&gt; y luego usando la segunda &lt;em&gt;clave_ ordenaci&amp;oacute;n&lt;/em&gt; y as&amp;iacute; sucesivamente. Esto es equivalente al comando de Python lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Debido a la forma en que funciona la ordenaci&amp;oacute;n por combinaci&amp;oacute;n, aseg&amp;uacute;rese de comprender el orden de las &lt;em&gt;teclas de ordenaci&amp;oacute;n&lt;/em&gt; debe estar en (al rev&amp;eacute;s del orden que usar&amp;iacute;a al comparar dos elementos).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">Dada una serie de condiciones y funciones correspondientes,evalúe cada función en los datos de entrada siempre que su condición sea verdadera.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">Dada una forma de, por ejemplo, &lt;code&gt;(m,n,k)&lt;/code&gt; , se generan &lt;code&gt;m*n*k&lt;/code&gt; muestras y se empaquetan en una disposici&amp;oacute;n de &lt;code&gt;m&lt;/code&gt; - por- &lt;code&gt;n&lt;/code&gt; - por- &lt;code&gt;k&lt;/code&gt; . Dado que cada muestra es &lt;code&gt;N&lt;/code&gt; - dimensional, la forma de salida es &lt;code&gt;(m,n,k,N)&lt;/code&gt; . Si no se especifica ninguna forma, se devuelve una sola muestra ( &lt;code&gt;N&lt;/code&gt; -D).</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">Dado un objeto de disposición cuadrada:</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">Dada una matriz cuadrada &lt;code&gt;a&lt;/code&gt; , devuelve la matriz &lt;code&gt;ainv&lt;/code&gt; satisfaciendo &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la &lt;code&gt;q&lt;/code&gt; -&amp;eacute;sima percentil de &lt;code&gt;V&lt;/code&gt; es el valor &lt;code&gt;q/100&lt;/code&gt; del camino desde el m&amp;iacute;nimo hasta el m&amp;aacute;ximo en una copia ordenada de &lt;code&gt;V&lt;/code&gt; . Los valores y distancias de los dos vecinos m&amp;aacute;s cercanos, as&amp;iacute; como el par&amp;aacute;metro de &lt;code&gt;interpolation&lt;/code&gt; , determinar&amp;aacute;n el percentil si la clasificaci&amp;oacute;n normalizada no coincide exactamente con la ubicaci&amp;oacute;n de &lt;code&gt;q&lt;/code&gt; . Esta funci&amp;oacute;n es igual que la mediana si &lt;code&gt;q=50&lt;/code&gt; , igual que el m&amp;iacute;nimo si &lt;code&gt;q=0&lt;/code&gt; e igual que el m&amp;aacute;ximo si &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la mediana de &lt;code&gt;V&lt;/code&gt; es el valor medio de una copia ordenada de &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - es decir, &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , cuando &lt;code&gt;N&lt;/code&gt; es impar, y el promedio de dos valores medios de &lt;code&gt;V_sorted&lt;/code&gt; cuando &lt;code&gt;N&lt;/code&gt; es par.</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la mediana de &lt;code&gt;V&lt;/code&gt; es el valor medio de una copia ordenada de &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - es decir, &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , cuando &lt;code&gt;N&lt;/code&gt; es impar y el promedio de los dos valores intermedios de &lt;code&gt;V_sorted&lt;/code&gt; cuando &lt;code&gt;N&lt;/code&gt; es par.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la q-&amp;eacute;sima percentil de &lt;code&gt;V&lt;/code&gt; es el valor &lt;code&gt;q/100&lt;/code&gt; del camino desde el m&amp;iacute;nimo hasta el m&amp;aacute;ximo en una copia ordenada de &lt;code&gt;V&lt;/code&gt; . Los valores y distancias de los dos vecinos m&amp;aacute;s cercanos, as&amp;iacute; como el par&amp;aacute;metro de &lt;code&gt;interpolation&lt;/code&gt; , determinar&amp;aacute;n el percentil si la clasificaci&amp;oacute;n normalizada no coincide exactamente con la ubicaci&amp;oacute;n de &lt;code&gt;q&lt;/code&gt; . Esta funci&amp;oacute;n es igual que la mediana si &lt;code&gt;q=50&lt;/code&gt; , igual que el m&amp;iacute;nimo si &lt;code&gt;q=0&lt;/code&gt; e igual que el m&amp;aacute;ximo si &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la q-&amp;eacute;sima cuantil de &lt;code&gt;V&lt;/code&gt; es el valor &lt;code&gt;q&lt;/code&gt; de la forma desde el m&amp;iacute;nimo hasta el m&amp;aacute;ximo en una copia ordenada de &lt;code&gt;V&lt;/code&gt; . Los valores y distancias de los dos vecinos m&amp;aacute;s cercanos, as&amp;iacute; como el par&amp;aacute;metro de &lt;code&gt;interpolation&lt;/code&gt; , determinar&amp;aacute;n el cuantil si la clasificaci&amp;oacute;n normalizada no coincide exactamente con la ubicaci&amp;oacute;n de &lt;code&gt;q&lt;/code&gt; . Esta funci&amp;oacute;n es la misma que la mediana si &lt;code&gt;q=0.5&lt;/code&gt; , la misma que el m&amp;iacute;nimo si &lt;code&gt;q=0.0&lt;/code&gt; y la misma que el m&amp;aacute;ximo si &lt;code&gt;q=1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Dado un vector &lt;code&gt;V&lt;/code&gt; con &lt;code&gt;N&lt;/code&gt; valores no enmascarados, la mediana de &lt;code&gt;V&lt;/code&gt; es el valor medio de una copia ordenada de &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; ), es decir, &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , cuando &lt;code&gt;N&lt;/code&gt; es impar, o &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; cuando &lt;code&gt;N&lt;/code&gt; es par.</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">Dada una longitud de ventana &lt;code&gt;n&lt;/code&gt; y un espaciado de muestra &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">Dada una matriz de &quot;&amp;iacute;ndice&quot; ( &lt;code&gt;a&lt;/code&gt; ) de n&amp;uacute;meros enteros y una secuencia de &lt;code&gt;n&lt;/code&gt; matrices ( &lt;code&gt;choices&lt;/code&gt; ), &lt;code&gt;a&lt;/code&gt; y cada matriz de opciones se transmiten primero, seg&amp;uacute;n sea necesario, a matrices de una forma com&amp;uacute;n; llamando a estas &lt;em&gt;opciones &lt;/em&gt;&lt;em&gt;Ba&lt;/em&gt; y &lt;em&gt;B [i], i = 0,&amp;hellip;, n-1&lt;/em&gt; tenemos que, necesariamente, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; para cada &lt;code&gt;i&lt;/code&gt; . Luego, se crea una nueva matriz con forma &lt;code&gt;Ba.shape&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">Dada una matriz de n&amp;uacute;meros enteros y un conjunto de n matrices de opciones, este m&amp;eacute;todo crear&amp;aacute; una nueva matriz que fusiona cada una de las matrices de opciones. Donde un valor en &lt;code&gt;a&lt;/code&gt; es i, la nueva matriz tendr&amp;aacute; el valor que las opciones [i] contienen en el mismo lugar.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">Dado un intervalo, los valores fuera del intervalo se recortan a los bordes del intervalo. Por ejemplo, si se especifica un intervalo de &lt;code&gt;[0, 1]&lt;/code&gt; , los valores menores que 0 se convierten en 0 y los valores mayores que 1 se convierten en 1.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">Dadas varias claves de clasificaci&amp;oacute;n, que se pueden interpretar como columnas en una hoja de c&amp;aacute;lculo, lexsort devuelve una matriz de &amp;iacute;ndices enteros que describe el orden de clasificaci&amp;oacute;n por varias columnas. La &amp;uacute;ltima clave de la secuencia se utiliza para el orden de clasificaci&amp;oacute;n principal, la pen&amp;uacute;ltima clave para el orden de clasificaci&amp;oacute;n secundario, etc. El argumento de claves debe ser una secuencia de objetos que se puedan convertir en matrices de la misma forma. Si se proporciona una matriz 2D para el argumento de claves, sus filas se interpretan como las claves de clasificaci&amp;oacute;n y la clasificaci&amp;oacute;n se realiza de acuerdo con la &amp;uacute;ltima fila, la pen&amp;uacute;ltima fila, etc.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">Dados los &quot;catetos&quot; de un tri&amp;aacute;ngulo rect&amp;aacute;ngulo, devuelve su hipotenusa.</target>
        </trans-unit>
        <trans-unit id="65f0e0f7ab08e6e7d473538fe0c4ef0f86fa2404" translate="yes" xml:space="preserve">
          <source>Given the above, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">Dada la forma de una matriz, una instancia &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; itera sobre el &amp;iacute;ndice N-dimensional de la matriz. En cada iteraci&amp;oacute;n se devuelve una tupla de &amp;iacute;ndices, la &amp;uacute;ltima dimensi&amp;oacute;n se repite primero.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">Dadas dos matrices de enteros de &lt;em&gt;n&lt;/em&gt; longitudes, &lt;em&gt;l1&lt;/em&gt; y &lt;em&gt;l2&lt;/em&gt; , devuelve 1 si las listas son id&amp;eacute;nticas; de lo contrario, devuelve 0.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Dados dos objetos tipo &quot;array_like&quot;,compruebe que la forma es igual y que todos los elementos del primer objeto son estrictamente más pequeños que los del segundo.Se plantea una excepción en caso de desajuste de forma o de valores mal ordenados.El desajuste de forma no se eleva si un objeto tiene dimensión cero.En contraste con el uso estándar en numpy,se comparan los NaNs,no se eleva ninguna afirmación si ambos objetos tienen NaNs en las mismas posiciones.</target>
        </trans-unit>
        <trans-unit id="33ed5b3e4d203313d72bfb61344b0ef20252735e" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Dados dos objetos tipo &quot;array_like&quot;,comprueba que la forma es igual y que todos los elementos de estos objetos son iguales.Se plantea una excepción en caso de desajuste de forma o valores conflictivos.En contraste con el uso estándar en numpy,los NaNs se comparan como números,no se plantea ninguna afirmación si ambos objetos tienen NaNs en las mismas posiciones.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">Dados dos números,compruebe que son aproximadamente iguales.Aproximadamente igual se define como el número de dígitos significativos que coinciden.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">Dados dos objetos (escalares,listas,tuplas,diccionarios o matrices numéricas),compruebe que todos los elementos de estos objetos son iguales.Se plantea una excepción en los primeros valores conflictivos.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">Dados dos polinomios &lt;code&gt;a1&lt;/code&gt; y &lt;code&gt;a2&lt;/code&gt; , devuelve &lt;code&gt;a1 - a2&lt;/code&gt; . &lt;code&gt;a1&lt;/code&gt; y &lt;code&gt;a2&lt;/code&gt; pueden ser secuencias parecidas a una matriz de los coeficientes de los polinomios (incluidos los coeficientes iguales a cero) u objetos &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">Dados dos tensores, &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , y un objeto array_like que contiene dos array_like objetos, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; , sumar los productos de &lt;code&gt;a&lt;/code&gt; &amp;lsquo;s y &lt;code&gt;b&lt;/code&gt; &amp;lsquo;s elementos (componentes) en los ejes indicados por &lt;code&gt;a_axes&lt;/code&gt; y &lt;code&gt;b_axes&lt;/code&gt; . El tercer argumento puede ser un &amp;uacute;nico escalar no negativo tipo integer_like, &lt;code&gt;N&lt;/code&gt; ; si es as&amp;iacute;, se suman las &amp;uacute;ltimas &lt;code&gt;N&lt;/code&gt; dimensiones de &lt;code&gt;a&lt;/code&gt; y las primeras &lt;code&gt;N&lt;/code&gt; dimensiones de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Dados dos vectores, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; y &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; , el producto exterior &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; es:</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Dados dos vectores, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; y &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; , el producto exterior &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; es:</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Dados dos vectores, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; y &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; , el producto exterior &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; es:</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="882e099811dae6ac151e6bf8446fa672be3c6225" translate="yes" xml:space="preserve">
          <source>Gives a list of the names to exclude, such as &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;&amp;hellip; If one of the input name is part of this list, an underscore character (&lt;code&gt;'_'&lt;/code&gt;) will be appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">Da una nueva forma a un conjunto sin cambiar sus datos.</target>
        </trans-unit>
        <trans-unit id="1175f81a358d9e3f38210901aaa9e95baea2d5bc" translate="yes" xml:space="preserve">
          <source>Gives a string combining all the characters that must be deleted from the name. By default, invalid characters are &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';:
/?.&amp;gt;,&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Glantz, Stanton A. &quot;Primer of Biostatistics&quot;, McGraw-Hill, Quinta edici&amp;oacute;n, 2002.</target>
        </trans-unit>
        <trans-unit id="98ce8e321806dbb3b91df4ce336400b327d82b05" translate="yes" xml:space="preserve">
          <source>Global State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="b5455baaf8bb77490bac48f282fc705e080b078c" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy&lt;/a&gt; and click the &amp;ldquo;fork&amp;rdquo; button to create your own copy of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307ec71f941bf50bb0ca58211aaf38b07c21cec" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.14.5
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55f17953adb4e53b1ccccc7c663a01a1165b91" translate="yes" xml:space="preserve">
          <source>Go to GitHub. The new branch will show up with a green Pull Request button. Make sure the title and message are clear, concise, and self- explanatory. Then click the button to submit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69980c4426505922b99957185231ede61f777564" translate="yes" xml:space="preserve">
          <source>Go to github and make a PR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46869e8de50d59c9c1645cda5ce89ba58d2c65a" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; github home at &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f0c82f9a531318bc29fd46c7f891f5c55b9a1" translate="yes" xml:space="preserve">
          <source>Good for wrapping large (many functions) existing C libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb06bd200ddbdceda42084b415b9a92259f61a" translate="yes" xml:space="preserve">
          <source>Google offers two free &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;Technical Writing Courses&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">El gradiente se calcula sólo a lo largo del eje o ejes dados El valor por defecto (eje=Ninguno)es calcular el gradiente para todos los ejes de la matriz de entrada.El eje puede ser negativo,en cuyo caso cuenta desde el último hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">El gradiente se calcula usando diferencias precisas de N-ésimo orden en los límites.Por defecto:1.</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">Ilustraci&amp;oacute;n gr&amp;aacute;fica del par&amp;aacute;metro de &lt;code&gt;endpoint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">Ilustración gráfica:</target>
        </trans-unit>
        <trans-unit id="4a52fe6ab66ec52ee6bfd51d48518f7de2e194f9" translate="yes" xml:space="preserve">
          <source>Greater consistency in &lt;code&gt;assert_almost_equal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; codicioso (aproximaci&amp;oacute;n de ruta &amp;oacute;ptima m&amp;aacute;s r&amp;aacute;pida): ~ 160 ms</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">Arreglos en forma de cuadrícula de números uniformemente espaciados en dimensiones N.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">Grupo 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">Grupo 2</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">Garantizar un acceso seguro y alineado para los ufuncs/setitem/código de fundición</target>
        </trans-unit>
        <trans-unit id="f454c80c182290ac641c3ab02a9edcdbe149e617" translate="yes" xml:space="preserve">
          <source>Guide to writing Tutorials (TODO)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d49ac2fe6a93b218baff7cae5e0e60393e7661a" translate="yes" xml:space="preserve">
          <source>Guide to writing reference (API) documentation: the numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Gumbel, EJ, &quot;Statistics of Extremes&quot;, Nueva York: Columbia University Press, 1958.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="a23a715b33c5262fe3d1b937504a94f4b675a4b6" translate="yes" xml:space="preserve">
          <source>H() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b37f0341f572e1998e910b25532a92af5b558" translate="yes" xml:space="preserve">
          <source>Hack away! See &lt;a href=&quot;#editing-workflow&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd57d6fb3350fcd694b91496d526594622dbb6" translate="yes" xml:space="preserve">
          <source>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">Funciones de media precisión</target>
        </trans-unit>
        <trans-unit id="188b61888bd344a019188c5ddd9af8e491599b6a" translate="yes" xml:space="preserve">
          <source>Hand-generated wrappers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; por NpyIter_MultiNew</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">Manejar números complejos</target>
        </trans-unit>
        <trans-unit id="0294f5e8c997832af6154aa5a34d3bc487dacc89" translate="yes" xml:space="preserve">
          <source>Handling of higher-dimensional arrays (ndim &amp;gt; 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536b0ea00b813744dd07cc20d7e2d652df9775" translate="yes" xml:space="preserve">
          <source>Handling of vectors (one-dimensional arrays)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">Manejo de &lt;code&gt;fill_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">Manejar la máscara</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">Dimensiones codificadas,especificación de las dimensiones de la memoria intermedia de datos y especificación de las dimensiones de la memoria intermedia de datos.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">La dureza de la máscara</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">No tiene efecto,no lo use.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">Tiene la misma forma que el &lt;code&gt;element&lt;/code&gt; o . El &lt;code&gt;element[isin]&lt;/code&gt; valores [isin] est&amp;aacute; en &lt;code&gt;test_elements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d794659e95706af6481a92a9285f876ae1c7d63" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; install help pages available from &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4d88ad951423d45baeab75192e5801e748751" translate="yes" xml:space="preserve">
          <source>Have a shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944005e31393bd466d7655b38df2b420878ca75" translate="yes" xml:space="preserve">
          <source>Having a shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62bdff9b904bdda1a1ed9ed602657769f3345fd" translate="yes" xml:space="preserve">
          <source>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in &lt;a href=&quot;gitwash/index#using-git&quot;&gt;Git for development&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Heckert, NA y Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, Serie de manuales del Instituto Nacional de Est&amp;aacute;ndares y Tecnolog&amp;iacute;a, junio de 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https: //www.itl.nist. gov / div898 / software / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f25b2d1977ec1a7cc15a3fe3ee364cef6feeebb6" translate="yes" xml:space="preserve">
          <source>Help increase engagement in good discussion practice: try to identify where discussion may have broken down and provide actionable information, pointers and resources that can lead to positive change on these points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">Funciones del ayudante</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">Ayudante para el pepinillo.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">Rutinas del ayudante</target>
        </trans-unit>
        <trans-unit id="591b0ee67a75bdd05c2441f5d821e72ac5abd9ff" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; may also contain signature files. Among other options (see below), the following options can be used in this mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad119f3969c50ae36c69dfd7a8f2258a296a9e4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; is a one-dimensional array of length two whose datatype is a structure with three fields: 1. A string of length 10 or less named &amp;lsquo;name&amp;rsquo;, 2. a 32-bit integer named &amp;lsquo;age&amp;rsquo;, and 3. a 32-bit float named &amp;lsquo;weight&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d939cfc36f7e101c6969543d3aa4fc112af1c5" translate="yes" xml:space="preserve">
          <source>Here appropriately means at least two tabs. It isn&amp;rsquo;t necessary to line everything up with the opening parenthesis of the function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41762c3a1457e94bd62a7f7522c1df055434f548" translate="yes" xml:space="preserve">
          <source>Here are examples of shapes that do not broadcast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestran varios ejemplos de valores de m&amp;aacute;scara de semana personalizados. Estos ejemplos especifican que el &quot;d&amp;iacute;a de bus&quot; predeterminado de lunes a viernes son d&amp;iacute;as v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">Aquí hay algunos ejemplos de firmas:</target>
        </trans-unit>
        <trans-unit id="c7c80754b6ccbe7d6353c18ee79360b34170e3a5" translate="yes" xml:space="preserve">
          <source>Here are some more examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">Aquí están las unidades de fecha:</target>
        </trans-unit>
        <trans-unit id="fcedd65241f400ab6b9cead2ae708d4ee0595afe" translate="yes" xml:space="preserve">
          <source>Here brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional part, dots &lt;code&gt;...&lt;/code&gt; indicate one or more of a previous part. So, &lt;code&gt;[]...&lt;/code&gt; reads zero or more of a previous part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a598f6524593a5ce80868abd4ad9058d26e6370" translate="yes" xml:space="preserve">
          <source>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">Aquí hay una tabla de conversión de las funciones a utilizar con el nuevo iterador:</target>
        </trans-unit>
        <trans-unit id="ae703a87217d209b99ae68f8790ce06f1f882b70" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful NumPy functions and methods names ordered in categories. See &lt;a href=&quot;../reference/routines#routines&quot;&gt;Routines&lt;/a&gt; for the full list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbbb0f1468c183a40201806e4aca9dcb3c7060" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">Aqu&amp;iacute; hay una funci&amp;oacute;n de copia simple usando el iterador. El par&amp;aacute;metro de &lt;code&gt;order&lt;/code&gt; se utiliza para controlar el dise&amp;ntilde;o de la memoria del resultado asignado, normalmente se desea &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">He aquí un modismo útil para obtener copias contiguas en lugar de vistas no contiguas.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">Aqu&amp;iacute; hay una funci&amp;oacute;n de ejemplo que opera como una ufunc &quot;lambda&quot;:</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">He aquí un ejemplo de la función del producto exterior:</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">Así es como se utilizan las variables anteriores:</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">Así es como se pueden usar con un conjunto de muestras:</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">As&amp;iacute; es como podr&amp;iacute;amos escribir una funci&amp;oacute;n &lt;code&gt;iter_add&lt;/code&gt; , usando el protocolo de iterador de Python:</target>
        </trans-unit>
        <trans-unit id="82ebceae19f8e179d652196db8007bed9b016e84" translate="yes" xml:space="preserve">
          <source>Here is part of a Cython module named &lt;code&gt;add.pyx&lt;/code&gt; which implements the complex addition functions we previously implemented using f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27fb417254a59c4a73469e0d501f40b87bdc16a" translate="yes" xml:space="preserve">
          <source>Here is shown a modified version of the previous Fortran code, save it as &lt;code&gt;fib3.f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">Aquí está la misma función,pero siguiendo el patrón del estilo C:</target>
        </trans-unit>
        <trans-unit id="d4daff3ad7f47434c82a5051360f6f8f9147bcdd" translate="yes" xml:space="preserve">
          <source>Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879104127602f2f170c22fa52acd13e1c1a2bd91" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;newaxis&lt;/code&gt; index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional &lt;code&gt;4x1&lt;/code&gt; array. Combining the &lt;code&gt;4x1&lt;/code&gt; array with &lt;code&gt;b&lt;/code&gt;, which has shape &lt;code&gt;(3,)&lt;/code&gt;, yields a &lt;code&gt;4x3&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e95414daee162c67ba2f23612c05957e9c9fa" translate="yes" xml:space="preserve">
          <source>Here the newaxis index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional 4x1 array. &lt;a href=&quot;#figure-4&quot;&gt;Figure 4&lt;/a&gt; illustrates the stretching of both arrays to produce the desired 4x3 output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948564e37f936b7d719e03a725d3b08432712a65" translate="yes" xml:space="preserve">
          <source>Here we give a list of short and useful tips.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la lista de sum_squares.pyx:</target>
        </trans-unit>
        <trans-unit id="4f05498cc571c5e0811d261874316f4fcd69c560" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the short summary, complete TOC links are below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30babd25e27e87a901a32627496afe119a238cc9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; is a dictionary mapping keys to values, in this case the integer 1 to the string &amp;ldquo;one&amp;rdquo;, and the string &amp;ldquo;two&amp;rdquo; to the list &lt;code&gt;[1, 2]&lt;/code&gt;. The values may be accessed using their corresponding keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">Aqu&amp;iacute;, he usado el iterador enumerado incorporado para devolver el &amp;iacute;ndice del iterador y el valor.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">Aquí,la U se dibuja a partir de la distribución uniforme sobre (0,1).</target>
        </trans-unit>
        <trans-unit id="b81e3c833ac1c20cf33999c717a7683fc509fd53" translate="yes" xml:space="preserve">
          <source>Here, you grabbed a section of your array from index position 3 through index position 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="3e97b960fb6669c7ce3d868bc1ee39fbd840fc5f" translate="yes" xml:space="preserve">
          <source>Hermite (class in numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">La clase de la Hermafrodita</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">M&amp;oacute;dulo de Hermite, &quot;F&amp;iacute;sicos&quot; ( &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">M&amp;oacute;dulo de Hermite, &quot;F&amp;iacute;sicos&quot; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">Módulo de Hermite,&quot;Físicos&quot; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="7e732e7a329c7f9da3eef2d091dd68d62fa1ae1a" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d4eab91a42ee672e761807e2ccfac51f95da47" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">Los coeficientes de Hermite en orden de grado creciente, es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; dan &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Coeficientes de Hermite ordenados de menor a mayor. Si &lt;code&gt;y&lt;/code&gt; era 2-D, los coeficientes de los datos de la columna k de &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n en la columna &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">Serie Hermite</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">Coeficientes de la serie Hermite de la integral.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">La serie de energía de Hermite.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">La serie Hermite del derivado.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">La serie de Hermite cuyo gráfico es una línea recta.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">La función de peso de los hermafroditas</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="213b3add1699deb17fd0362b28ee9eaa1e08297e" translate="yes" xml:space="preserve">
          <source>HermiteE (class in numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">Clase HermiteE</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">M&amp;oacute;dulo HermiteE, &quot;Probabilistas&quot; ( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">M&amp;oacute;dulo HermiteE, &quot;Probabilistas&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">Módulo HermiteE,&quot;Probabilistas&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="a7da5893b105551d489e12a654065cc1aa5b0de0" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01652b3974c2bf789bf8511d4ddd036a45eab615" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">Los coeficientes de HermiteE en orden de grado creciente, es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; dan &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">Serie HermiteE</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">Funzione peso HermiteE.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">Coefficienti della serie Hermite_e dell'integrale.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Ermitiano (simmetrico se tutti gli elementi sono reali),matrice di ingresso positiva definita.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">FFT ermitiane</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">Matrici ermitiane o reali simmetriche i cui autovalori e autovettori devono essere calcolati.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">I polinomi di alto ordine possono oscillare selvaggiamente:</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">Dimensioni superiori</target>
        </trans-unit>
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L'Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, vol. 20, n&amp;uacute;m. 3, verano de 2008, p&amp;aacute;gs. 385-390.</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">El esquema de Horner &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; se utiliza para evaluar el polinomio. Aun as&amp;iacute;, para polinomios de alto grado, los valores pueden ser inexactos debido a errores de redondeo. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">Cu&amp;aacute;ntos bytes se necesitan para saltar desde el final de una dimensi&amp;oacute;n hasta su comienzo. Tenga en cuenta que &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; , pero se almacena aqu&amp;iacute; como una optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">Quante prove sono riuscite dopo una sola prova?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">C&amp;oacute;mo tratar las fechas que no caen en un d&amp;iacute;a v&amp;aacute;lido. El valor predeterminado es 'subir'.</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C&amp;oacute;mo utilizar un iterador de matriz en un nivel C se explica con m&amp;aacute;s detalle en secciones posteriores. Normalmente, no es necesario que se preocupe por la estructura interna del objeto iterador y simplemente interact&amp;uacute;e con &amp;eacute;l mediante el uso de las macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) o &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index). Todas estas macros requieren el argumento de &lt;em&gt;que&lt;/em&gt; sea un &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">Tuttavia,gli array scalari sono immutabili,quindi nessuno degli attributi scalari dell'array è impostabile.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">Sin embargo, para una matriz 2D, &lt;code&gt;tolist&lt;/code&gt; se aplica de forma recursiva:</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">Sin embargo, si la longitud del paso es un &lt;strong&gt;n&amp;uacute;mero complejo&lt;/strong&gt; (por ejemplo, 5j), entonces la parte entera de su magnitud se interpreta como la especificaci&amp;oacute;n del n&amp;uacute;mero de puntos a crear entre los valores de inicio y finalizaci&amp;oacute;n, donde el valor de parada &lt;strong&gt;es inclusivo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, tambi&amp;eacute;n proporciona un mecanismo de filtro para solucionar &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">Sin embargo, dado que las matrices de indexaci&amp;oacute;n anteriores simplemente se repiten, se puede usar la transmisi&amp;oacute;n (compare operaciones como &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; ) para simplificar esto:</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">Sin embargo, esta clase no se ejecuta directamente. M&amp;aacute;s bien, sirve como una clase base para varias otras clases de Python, cada una espec&amp;iacute;fica para un tipo de datos en particular. La clase &lt;code&gt;VectorTestCase&lt;/code&gt; almacena dos cadenas para escribir informaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">Coseno iperbolico,elementare.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">Funciones hiperbólicas</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">Seno iperbolico,elementare.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">IN Bronshtein, KA Semendyayev y KA Hirsch (Ed. Trans. Inglesa), &lt;em&gt;Handbook of Mathematics&lt;/em&gt; , Nueva York, Van Nostrand Reinhold Co., 1985, p&amp;aacute;g. 720.</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dell'infinito (positivo).</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">Rappresentazione in virgola mobile IEEE 754 di Not a Number (NaN).</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dell'infinito negativo.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">Rappresentazione in virgola mobile IEEE 754 dello zero negativo.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dello zero positivo.</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">Norma ISO / IEC 9899: 1999, &quot;Lenguaje de programaci&amp;oacute;n C.&quot;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">Función de identidad.</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Si est&amp;aacute; &quot;izquierda&quot;, se proporciona el &amp;iacute;ndice de la primera ubicaci&amp;oacute;n adecuada encontrada. Si es 'correcto', devuelve el &amp;uacute;ltimo &amp;iacute;ndice de este tipo. Si no hay un &amp;iacute;ndice adecuado, devuelve 0 o N (donde N es la longitud de &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">Si 'out' es None (el valor predeterminado), se crea una matriz de retorno no inicializada. Luego, la matriz de salida se llena con los resultados de ufunc en los lugares donde la transmisi&amp;oacute;n 'donde' es Verdadero. Si 'donde' es el escalar Verdadero (el valor predeterminado), esto corresponde a la salida completa que se est&amp;aacute; llenando. Tenga en cuenta que las salidas que no se llenan expl&amp;iacute;citamente se quedan con sus valores no inicializados.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se pasan valores -1 / NULL a &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; y &lt;code&gt;buffersize&lt;/code&gt; , es equivalente a &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">Si &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; est&amp;aacute; #definido, independientemente de si &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; lo&lt;/a&gt; es, la C-API se declara &lt;code&gt;extern void**&lt;/code&gt; , por lo que se espera que se defina en otra unidad de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">Si se llam&amp;oacute; a &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; , es posible que desee habilitar el indicador &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; . Este indicador no est&amp;aacute; permitido junto con &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; , por lo que esta funci&amp;oacute;n se proporciona para habilitar la funci&amp;oacute;n despu&amp;eacute;s de que se &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; . Esta funci&amp;oacute;n tambi&amp;eacute;n restablece el iterador a su estado inicial.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">Si &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; est&amp;aacute; #definido, pero &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; no, la C-API se declara &lt;code&gt;void**&lt;/code&gt; , de modo que tambi&amp;eacute;n ser&amp;aacute; visible para otras unidades de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">Si se establece &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , la matriz se copia solo si dtype no coincide:</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; no son unidimensionales, la salida tambi&amp;eacute;n tiene estas dimensiones.</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; son una cadena, se interpretan como una matriz con comas o espacios que separan las columnas y punto y coma que separan las filas.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; ya son un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , este indicador determina si los datos se copian (el valor predeterminado) o si se construye una vista.</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">Si &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , las &lt;code&gt;reps&lt;/code&gt; se promueven a &lt;code&gt;A&lt;/code&gt; .ndim con 1 pre-pendientes. Por lo tanto, para una &lt;code&gt;A&lt;/code&gt; de forma (2, 3, 4, 5), las &lt;code&gt;reps&lt;/code&gt; de (2, 2) se tratan como (1, 1, 2, 2).</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">Si &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; se promueve a d-dimensional anteponiendo nuevos ejes. Entonces, una matriz de forma (3,) se promueve a (1, 3) para la replicaci&amp;oacute;n 2-D, o forma (1, 1, 3) para la replicaci&amp;oacute;n 3-D. Si este no es el comportamiento deseado, promueva las dimensiones &lt;code&gt;A&lt;/code&gt; a d manualmente antes de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">Si es &lt;code&gt;False&lt;/code&gt; , el resultado contendr&amp;aacute; el n&amp;uacute;mero de muestras en cada contenedor. Si es &lt;code&gt;True&lt;/code&gt; , el resultado es el valor de la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el intervalo , normalizado de manera que la &lt;em&gt;integral&lt;/em&gt; sobre el rango sea 1. Tenga en cuenta que la suma de los valores del histograma no ser&amp;aacute; igual a 1 a menos que se elijan intervalos de ancho unitario; no es una funci&amp;oacute;n de &lt;em&gt;masa de&lt;/em&gt; probabilidad .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Si es &lt;code&gt;None&lt;/code&gt; (predeterminado), se supone que todas las constantes son cero. Si &lt;code&gt;m = 1&lt;/code&gt; , se puede dar un solo escalar en lugar de una lista.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , intercambia bytes en el lugar, el valor predeterminado es &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , el l&amp;iacute;mite de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n se refiere al n&amp;uacute;mero total de d&amp;iacute;gitos despu&amp;eacute;s del punto decimal, incluidos los ceros iniciales. Si es &lt;code&gt;False&lt;/code&gt; , la &lt;code&gt;precision&lt;/code&gt; refiere al n&amp;uacute;mero total de d&amp;iacute;gitos significativos, antes o despu&amp;eacute;s del punto decimal, ignorando los ceros iniciales.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , entonces almacena en cach&amp;eacute; la primera llamada de funci&amp;oacute;n que determina el n&amp;uacute;mero de salidas si no se proporcionan &lt;code&gt;otypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , utilice una estrategia de generaci&amp;oacute;n de d&amp;iacute;gitos que proporcione la representaci&amp;oacute;n m&amp;aacute;s corta que identifique de forma &amp;uacute;nica el n&amp;uacute;mero de punto flotante de otros valores del mismo tipo, mediante un redondeo juicioso. Si se omiti&amp;oacute; la &lt;code&gt;precision&lt;/code&gt; , imprima todos los d&amp;iacute;gitos necesarios; de lo contrario, la generaci&amp;oacute;n de d&amp;iacute;gitos se corta despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n y el valor restante se redondea. Si es &lt;code&gt;False&lt;/code&gt; , los d&amp;iacute;gitos se generan como si se imprimiera un valor de precisi&amp;oacute;n infinita y se detuvieran despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n , redondeando el valor restante.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , utilice una estrategia de generaci&amp;oacute;n de d&amp;iacute;gitos que proporcione la representaci&amp;oacute;n m&amp;aacute;s corta que identifique de forma &amp;uacute;nica el n&amp;uacute;mero de punto flotante de otros valores del mismo tipo, mediante un redondeo juicioso. Si se omiti&amp;oacute; la &lt;code&gt;precision&lt;/code&gt; , imprima todos los d&amp;iacute;gitos necesarios; de lo contrario, la generaci&amp;oacute;n de d&amp;iacute;gitos se corta despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n y el valor restante se redondea. Si es &lt;code&gt;False&lt;/code&gt; , los d&amp;iacute;gitos se generan como si se imprimiera un valor de precisi&amp;oacute;n infinita y se detuvieran despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n , redondeando el valor restante.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">Si &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; , devuelve el valor de relleno; de lo contrario, devuelve Ninguno.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">Si &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; , se eliminan las dimensiones especificadas por &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; , y se inserta un nuevo eje en el extremo correspondiente a la diagonal.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">Si &lt;code&gt;a.ndim&lt;/code&gt; es 0, dado que la profundidad de la lista anidada es 0, no ser&amp;aacute; una lista en absoluto, sino un simple escalar de Python.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">Si &lt;code&gt;a.shape&lt;/code&gt; es (5,1), &lt;code&gt;b.shape&lt;/code&gt; es (1,6), &lt;code&gt;c.shape&lt;/code&gt; es (6,) y &lt;code&gt;d.shape&lt;/code&gt; es () de modo que &lt;em&gt;d&lt;/em&gt; es un escalar, entonces &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; , &lt;em&gt;c&lt;/em&gt; , y &lt;em&gt;d&lt;/em&gt; son todos broadcastable a la dimensi&amp;oacute;n (5,6); y</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son escalar, sus &amp;uacute;ltimas dimensiones deben coincidir.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; y cada matriz de opciones no son todas asignables a la misma forma.</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no posee sus propios datos o referencias o vistas, existen, y la memoria de datos debe cambiarse. Solo PyPy: siempre se generar&amp;aacute; si se debe cambiar la memoria de datos, ya que no hay una forma confiable de determinar si existen referencias o vistas a ella.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, entonces se aplican las reglas de transmisi&amp;oacute;n, como se explica en &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;&amp;Aacute;lgebra lineal en varias matrices a la vez&lt;/a&gt; . Esto significa que SVD est&amp;aacute; trabajando en modo &quot;apilado&quot;: itera sobre todos los &amp;iacute;ndices de la primera &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensiones y para cada combinaci&amp;oacute;n SVD se aplica a los dos &amp;uacute;ltimos &amp;iacute;ndices. La matriz &lt;code&gt;a&lt;/code&gt; se puede reconstruir a partir de la descomposici&amp;oacute;n con &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; o &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; . (El operador &lt;code&gt;@&lt;/code&gt; puede ser reemplazado por la funci&amp;oacute;n &lt;code&gt;np.matmul&lt;/code&gt; para versiones de Python por debajo de 3.5).</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, los ejes especificados por axis1 y axis2 se utilizan para determinar las submatrices 2-D cuyas trazas se devuelven. La forma de la matriz resultante es la misma que la de &lt;code&gt;a&lt;/code&gt; con &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; eliminados.</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 1-D, la funci&amp;oacute;n &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; es la misma que &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; donde los &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; son &lt;code&gt;range(len(array) - 1)&lt;/code&gt; con un cero colocado en cada otro elemento: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, devuelve la diagonal de &lt;code&gt;a&lt;/code&gt; con el desplazamiento dado, es decir, la colecci&amp;oacute;n de elementos de la forma &lt;code&gt;a[i, i+offset]&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, entonces los ejes especificados por &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; se utilizan para determinar la submatriz 2-D cuya diagonal se devuelve. La forma de la matriz resultante se puede determinar quitando &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; y agregando un &amp;iacute;ndice a la derecha igual al tama&amp;ntilde;o de las diagonales resultantes.</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, se devuelve la suma a lo largo de su diagonal con el desplazamiento dado, es decir, la suma de los elementos &lt;code&gt;a[i,i+offset]&lt;/code&gt; para todo i.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, se devuelve la suma a lo largo de la diagonal. Si &lt;code&gt;a&lt;/code&gt; tiene dimensiones m&amp;aacute;s grandes, se devuelve una matriz de sumas a lo largo de las diagonales.</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz de 1-D que contiene la diagonal y 2-D, a continuaci&amp;oacute;n, del mismo tipo como &lt;code&gt;a&lt;/code&gt; se devuelve a menos que &lt;code&gt;a&lt;/code&gt; es una &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , en cuyo caso una matriz de 1-D en lugar de un (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; se devuelve para mantener la compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es un objeto de &lt;code&gt;matrix&lt;/code&gt; (a diferencia de un &lt;code&gt;ndarray&lt;/code&gt; ), entonces tambi&amp;eacute;n lo son todos los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una subclase de &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , su clase se conserva. No se realiza ninguna copia si la entrada ya es un &lt;code&gt;ndarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz ND y &lt;code&gt;b&lt;/code&gt; es una matriz de 1-D, que es un producto suma sobre el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz ND y &lt;code&gt;b&lt;/code&gt; es una matriz MD (donde &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ), que es un producto suma sobre el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; y la segunda a &amp;uacute;ltima eje de &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es complejo, el conjugado complejo se toma antes del c&amp;aacute;lculo del producto escalar.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no es un &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;a&lt;/code&gt; s&amp;iacute; es devuelto. Si &lt;code&gt;a&lt;/code&gt; es un &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;fill_value&lt;/code&gt; es None, &lt;code&gt;fill_value&lt;/code&gt; se establece en &lt;code&gt;a.fill_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no es cuadrado o falla la inversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es real, se usa el tipo de &lt;code&gt;a&lt;/code&gt; para la salida. Si &lt;code&gt;a&lt;/code&gt; tiene elementos complejos, el tipo devuelto es flotador.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es singular o no 'cuadrado' (en el sentido anterior).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es singular o no cuadrado.</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">Si &lt;code&gt;arr&lt;/code&gt; no tiene un atributo de forma (es decir, no es un ndarray)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;axes&lt;/code&gt; son m&amp;aacute;s grandes que el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es 0, solo se enmascaran las filas.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es 1 o -1, solo se enmascaran las columnas.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, las filas &lt;em&gt;y&lt;/em&gt; columnas est&amp;aacute;n enmascaradas.</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es un n&amp;uacute;mero entero, especifica el eje de &lt;code&gt;x&lt;/code&gt; a lo largo del cual calcular las normas vectoriales. Si &lt;code&gt;axis&lt;/code&gt; es una tupla bidimensional, especifica los ejes que contienen matrices bidimensionales y se calculan las normas matriciales de estas matrices. Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, se devuelve una norma vectorial (cuando &lt;code&gt;x&lt;/code&gt; es 1-D) o una norma matricial (cuando &lt;code&gt;x&lt;/code&gt; es 2-D).</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">Si se proporciona &lt;code&gt;axis&lt;/code&gt; , el n&amp;uacute;mero de varargs debe ser igual al n&amp;uacute;mero de ejes. Predeterminado: 1.</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es mayor que el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; y un eje que se comprime no tiene una longitud 1</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">Si &lt;code&gt;b&lt;/code&gt; es una matriz, todos los resultados de la matriz se devuelven como matrices.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es una cadena de la lista siguiente, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; utilizar&amp;aacute; el m&amp;eacute;todo elegido para calcular el ancho &amp;oacute;ptimo del bin y, en consecuencia, el n&amp;uacute;mero de bins (consulte &lt;code&gt;Notes&lt;/code&gt; para obtener m&amp;aacute;s detalles sobre los estimadores) a partir de los datos que se encuentran dentro del rango solicitado. Si bien el ancho del contenedor ser&amp;aacute; &amp;oacute;ptimo para los datos reales en el rango, el n&amp;uacute;mero de contenedores se calcular&amp;aacute; para llenar todo el rango, incluidas las porciones vac&amp;iacute;as. Para la visualizaci&amp;oacute;n, se sugiere usar la opci&amp;oacute;n 'auto'. Los datos ponderados no son compatibles con la selecci&amp;oacute;n autom&amp;aacute;tica del tama&amp;ntilde;o del contenedor.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es una cadena, define el m&amp;eacute;todo utilizado para calcular el ancho &amp;oacute;ptimo de bin, seg&amp;uacute;n lo definido por &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es un int, define el n&amp;uacute;mero de bins de igual ancho en el rango dado (10, por defecto). Si &lt;code&gt;bins&lt;/code&gt; es una secuencia, define una matriz de bordes de bin que aumenta mon&amp;oacute;tonamente, incluido el borde m&amp;aacute;s a la derecha, lo que permite anchos de bin no uniformes.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es un int, define el n&amp;uacute;mero de bins de igual ancho en el rango dado (10, por defecto). Si los &lt;code&gt;bins&lt;/code&gt; son una secuencia, define los bordes del contenedor, incluido el borde m&amp;aacute;s a la derecha, lo que permite anchos de contenedor no uniformes.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; no es mon&amp;oacute;tono.</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">Si el &lt;code&gt;buffer&lt;/code&gt; es Ninguno, solo se utilizan la &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , el &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; y el &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">Si &lt;code&gt;buffer&lt;/code&gt; es un objeto que expone la interfaz del b&amp;uacute;fer, se interpretan todas las palabras clave.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">Si el &lt;code&gt;buffersize&lt;/code&gt; es cero, se usa un tama&amp;ntilde;o de b&amp;uacute;fer predeterminado; de lo contrario, especifica qu&amp;eacute; tama&amp;ntilde;o de b&amp;uacute;fer se debe usar. Se recomiendan b&amp;uacute;feres con potencias de 2, como 4096 u 8192.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de 3 dimensiones, se a&amp;ntilde;aden unos impl&amp;iacute;citamente a su forma para convertirla en 3-D. La forma del resultado ser&amp;aacute; c.shape [3:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de tres dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 3-D. La forma del resultado ser&amp;aacute; c.shape [3:] + x.shape + y.shape + z.shape.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de dos dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape + y.shape.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de dos dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D, se agrega uno impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;hermeval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series HermiteE del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;hermval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Hermite del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;lagval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Laguerre del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = legvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;legval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Legendre del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;chebval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Chebyshev del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;polyval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de polinomios del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D, entonces &lt;code&gt;p(x)&lt;/code&gt; tendr&amp;aacute; la misma forma que &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; es multidimensional, entonces la forma del resultado depende del valor del &lt;code&gt;tensor&lt;/code&gt; . Si el &lt;code&gt;tensor&lt;/code&gt; es verdadero, la forma ser&amp;aacute; c.shape [1:] + x.shape. Si el &lt;code&gt;tensor&lt;/code&gt; es falso, la forma ser&amp;aacute; c.shape [1:]. Tenga en cuenta que los escalares tienen forma (,).</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es de longitud &lt;code&gt;n + 1&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es de longitud &lt;code&gt;n + 1&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor:</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">Si la &lt;code&gt;condition&lt;/code&gt; es booleana:</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Si se proporcionan &lt;code&gt;data&lt;/code&gt; , deben permanecer vivos durante la vida &amp;uacute;til de la matriz. Una forma de gestionar esto es a trav&amp;eacute;s de &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">Si &lt;code&gt;dtype&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , entonces requiere ese tipo de datos. Si se permite la copia, har&amp;aacute; una copia temporal si los datos se pueden convertir. Si &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado, tambi&amp;eacute;n copiar&amp;aacute; los datos con otra conversi&amp;oacute;n tras la destrucci&amp;oacute;n del iterador.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">Si &lt;code&gt;enddates&lt;/code&gt; especifica un valor de fecha que es anterior al valor de fecha de &lt;code&gt;begindates&lt;/code&gt; correspondiente , el recuento ser&amp;aacute; negativo.</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; es una matriz 1-D de enteros ordenados, las entradas indican en qu&amp;eacute; parte del &lt;code&gt;axis&lt;/code&gt; se divide la matriz. Por ejemplo, &lt;code&gt;[2, 3]&lt;/code&gt; , para el &lt;code&gt;axis=0&lt;/code&gt; , resultar&amp;iacute;a en</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; es un n&amp;uacute;mero entero, N, la matriz se dividir&amp;aacute; en N matrices iguales a lo largo del &lt;code&gt;axis&lt;/code&gt; . Si tal divisi&amp;oacute;n no es posible, se genera un error.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; se da como un n&amp;uacute;mero entero, pero una divisi&amp;oacute;n no da como resultado una divisi&amp;oacute;n igual.</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">Si &lt;code&gt;legacy&lt;/code&gt; es False, o BitGenerator no es NT19937, el estado se devuelve como un diccionario.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , o &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , o &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">Si &lt;code&gt;m1&lt;/code&gt; y &lt;code&gt;m2&lt;/code&gt; tienen diferentes tipos de d flexibles.</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">Si &lt;code&gt;m&lt;/code&gt; tiene una sola columna, esa columna se devuelve como la &amp;uacute;nica fila de una matriz. De lo contrario, se devuelve &lt;code&gt;m&lt;/code&gt; . La matriz devuelta es siempre &lt;code&gt;m&lt;/code&gt; en s&amp;iacute; misma o una vista de &lt;code&gt;m&lt;/code&gt; . Proporcionar un argumento de palabra clave de eje no afectar&amp;aacute; la matriz devuelta, pero puede provocar que se genere un error.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">Si se da &lt;code&gt;maxsplit&lt;/code&gt; , como m&amp;aacute;ximo se &lt;code&gt;maxsplit&lt;/code&gt; divisiones de maxsplit , las m&amp;aacute;s a la derecha.</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">Si se da &lt;code&gt;maxsplit&lt;/code&gt; , como m&amp;aacute;ximo se &lt;code&gt;maxsplit&lt;/code&gt; divisiones de maxsplit .</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es par, &lt;code&gt;A[-1]&lt;/code&gt; contiene el t&amp;eacute;rmino que representa la frecuencia de Nyquist tanto positiva como negativa (+ fs / 2 y -fs / 2), y tambi&amp;eacute;n debe ser puramente real. Si &lt;code&gt;n&lt;/code&gt; es impar, no hay t&amp;eacute;rmino en fs / 2; &lt;code&gt;A[-1]&lt;/code&gt; contiene la mayor frecuencia positiva (fs / 2 * (n-1) / n) y es complejo en el caso general.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">Si &lt;code&gt;names&lt;/code&gt; es Verdadero, los nombres de los campos se leen desde la primera l&amp;iacute;nea despu&amp;eacute;s de las primeras l&amp;iacute;neas &lt;code&gt;skip_header&lt;/code&gt; . Opcionalmente, esta l&amp;iacute;nea puede ir precedida de un delimitador de comentarios. Si &lt;code&gt;names&lt;/code&gt; es una secuencia o una sola cadena de nombres separados por comas, los nombres se usar&amp;aacute;n para definir los nombres de los campos en un tipo d estructurado. Si &lt;code&gt;names&lt;/code&gt; es Ninguno, se utilizar&amp;aacute;n los nombres de los campos dtype, si los hay.</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">Si &lt;code&gt;obj.flags&lt;/code&gt; tiene &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; o (en desuso) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n borra las banderas, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; y lo hace escribible, y establece &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; en NULL. A diferencia de &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; , no intenta copiar los datos de &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; . Esto deshace &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Por lo general, esto se llama despu&amp;eacute;s de un error cuando termina con &lt;code&gt;obj&lt;/code&gt; , justo antes de &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Se puede llamar varias veces o con una entrada &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;obj.flags&lt;/code&gt; tiene &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; o (en desuso) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n borra las banderas, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; y lo hace escribible, y establece &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; en NULL. Luego copia &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; a &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; y devuelve el estado de error de la operaci&amp;oacute;n de copia. Esto es lo opuesto a &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Por lo general, esto se llama una vez que haya terminado con &lt;code&gt;obj&lt;/code&gt; , justo antes de &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Se puede llamar varias veces o con una entrada &lt;code&gt;NULL&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; devuelve una matriz unidimensional llena con los elementos de &lt;em&gt;x&lt;/em&gt; correspondientes a los valores &lt;code&gt;True&lt;/code&gt; de &lt;em&gt;obj&lt;/em&gt; . El orden de b&amp;uacute;squeda ser&amp;aacute; &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;por filas&lt;/a&gt; , C-estilo. Si &lt;em&gt;obj&lt;/em&gt; tiene valores &lt;code&gt;True&lt;/code&gt; en las entradas que est&amp;aacute;n fuera de los l&amp;iacute;mites de &lt;em&gt;x&lt;/em&gt; , se generar&amp;aacute; un error de &amp;iacute;ndice. Si &lt;em&gt;obj&lt;/em&gt; es menor que &lt;em&gt;x&lt;/em&gt; , es id&amp;eacute;ntico a llenarlo con &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">Si &lt;code&gt;obj&lt;/code&gt; no es un tipo num&amp;eacute;rico adecuado.</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; implementa cualquier parte de la interfaz de la matriz, entonces &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; una nueva referencia al ndarray reci&amp;eacute;n creado usando la interfaz o &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;NULL&lt;/code&gt; si ocurre un error durante la conversi&amp;oacute;n. De lo contrario, out contendr&amp;aacute; una referencia prestada a &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; &lt;/a&gt; y no se establece ninguna condici&amp;oacute;n de error.</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; implementa cualquier parte de la interfaz de la matriz, entonces &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; una nueva referencia al ndarray reci&amp;eacute;n creado usando la interfaz o &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;NULL&lt;/code&gt; si ocurre un error durante la conversi&amp;oacute;n. De lo contrario, out contendr&amp;aacute; una referencia prestada a Py_NotImplemented y no se establece ninguna condici&amp;oacute;n de error. Esta versi&amp;oacute;n permite configurar el tipo y contexto en la parte de la interfaz de matriz que busca el atributo &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; ya es (estilo C) contiguo y se comporta bien, simplemente devuelva una referencia; de lo contrario, devuelva una copia (contigua y con buen comportamiento) de la matriz. El par&amp;aacute;metro op debe ser una (subclase de un) ndarray y no se realiza ninguna verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;op_dtypes&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , especifica un tipo de datos o &lt;code&gt;NULL&lt;/code&gt; para cada &lt;code&gt;op[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">Si no se especifica &lt;code&gt;otypes&lt;/code&gt; , se utilizar&amp;aacute; una llamada a la funci&amp;oacute;n con el primer argumento para determinar el n&amp;uacute;mero de salidas. Los resultados de esta llamada se almacenar&amp;aacute;n en cach&amp;eacute; si la &lt;code&gt;cache&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; para evitar llamar a la funci&amp;oacute;n dos veces. Sin embargo, para implementar la cach&amp;eacute;, la funci&amp;oacute;n original debe estar ajustada, lo que ralentizar&amp;aacute; las llamadas posteriores, por lo que solo haga esto si su funci&amp;oacute;n es costosa.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la desviaci&amp;oacute;n est&amp;aacute;ndar; de lo contrario, devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la desviaci&amp;oacute;n est&amp;aacute;ndar; de lo contrario, devuelve una referencia a la matriz de salida. Si ddof es&amp;gt; = el n&amp;uacute;mero de elementos que no son NaN en un segmento o el segmento contiene solo NaN, entonces el resultado para ese segmento es NaN.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la varianza; de lo contrario, devuelve una referencia a la matriz de salida. Si ddof es&amp;gt; = el n&amp;uacute;mero de elementos que no son NaN en un segmento o el segmento contiene solo NaN, entonces el resultado para ese segmento es NaN.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">Si se proporciona &lt;code&gt;out&lt;/code&gt; , la funci&amp;oacute;n escribe el resultado en &amp;eacute;l y devuelve una referencia a &lt;code&gt;out&lt;/code&gt; . (Ver ejemplos)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene los valores medios; de lo contrario, se devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene los valores medios; de lo contrario, se devuelve una referencia a la matriz de salida. Se devuelve Nan para los segmentos que contienen solo NaN.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene la varianza; de lo contrario, se devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">Si no se proporciona la &lt;code&gt;output&lt;/code&gt; , el c&amp;oacute;digo fuente se imprime en la pantalla (sys.stdout). El objeto de archivo debe crearse con los modos escribir 'w' o agregar 'a'.</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es de longitud N, esta funci&amp;oacute;n devuelve el valor:</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es la serie devuelta, entonces &lt;code&gt;p(x) == x&lt;/code&gt; para todos los valores de x.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es una URL, se descargar&amp;aacute;, se almacenar&amp;aacute; en el directorio &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; y se abrir&amp;aacute; desde all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es una URL, &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; la ubicaci&amp;oacute;n en la que existe el archivo localmente o la ubicaci&amp;oacute;n en la que existir&amp;iacute;a cuando se abriera con el m&amp;eacute;todo &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo percentil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios percentiles, el primer eje del resultado corresponde a los percentiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo percentil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios cuantiles, el primer eje del resultado corresponde a los cuantiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo cuantil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios cuantiles, el primer eje del resultado corresponde a los cuantiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es una matriz 1-D, entonces &lt;code&gt;p(x)&lt;/code&gt; tendr&amp;aacute; la misma forma que &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;r&lt;/code&gt; es multidimensional, entonces la forma del resultado depende del valor del &lt;code&gt;tensor&lt;/code&gt; . Si el &lt;code&gt;tensor is ``True`&lt;/code&gt; la forma ser&amp;aacute; r.shape [1:] + x.shape; es decir, cada polinomio se eval&amp;uacute;a en cada valor de &lt;code&gt;x&lt;/code&gt; . Si el &lt;code&gt;tensor&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; , la forma ser&amp;aacute; r.shape [1:]; es decir, cada polinomio se eval&amp;uacute;a solo para el valor de difusi&amp;oacute;n correspondiente de &lt;code&gt;x&lt;/code&gt; . Tenga en cuenta que los escalares tienen forma (,).</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es de longitud &lt;code&gt;N&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">Si &lt;code&gt;rep&lt;/code&gt; es una instancia de un dtype escalar, se devuelve True. Si no es as&amp;iacute;, se devuelve False.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">Si las &lt;code&gt;reps&lt;/code&gt; tienen una longitud &lt;code&gt;d&lt;/code&gt; , el resultado tendr&amp;aacute; una dimensi&amp;oacute;n de &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">Si &lt;code&gt;rowvar&lt;/code&gt; es True (predeterminado), entonces cada fila representa una variable, con observaciones en las columnas. De lo contrario, la relaci&amp;oacute;n se transpone: cada columna representa una variable, mientras que las filas contienen observaciones.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;axes&lt;/code&gt; tienen diferente longitud, o &lt;code&gt;axes&lt;/code&gt; no determinado y &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;axes&lt;/code&gt; tienen diferente longitud.</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">Si &lt;code&gt;sctype&lt;/code&gt; es un objeto para el que no se puede inferir el tipo.</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">Si &lt;code&gt;self.shape[k] == 1&lt;/code&gt; entonces para cualquier &amp;iacute;ndice de &lt;code&gt;index[k] == 0&lt;/code&gt; legal [k] == 0 . Esto significa que en la f&amp;oacute;rmula para el desplazamiento</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; no es singular, &lt;code&gt;ret&lt;/code&gt; es tal que &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; todos devuelven &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">Si el &lt;code&gt;self&lt;/code&gt; es singular.</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">Si no se especifica &lt;code&gt;sep&lt;/code&gt; o &lt;code&gt;None&lt;/code&gt; , cualquier cadena de espacios en blanco es un separador.</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;shape&lt;/code&gt; tiene una longitud uno, es decir, &lt;code&gt;(N,)&lt;/code&gt; , o es un escalar &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; se convierte en una matriz de fila &amp;uacute;nica de forma &lt;code&gt;(1,N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">Si &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">Si &lt;code&gt;v&lt;/code&gt; es una matriz 2-D, devuelve una copia de su &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal. Si &lt;code&gt;v&lt;/code&gt; es una matriz 1-D, devuelve una matriz 2-D con &lt;code&gt;v&lt;/code&gt; en la &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">Si &lt;code&gt;v&lt;/code&gt; es m&amp;aacute;s largo que &lt;code&gt;a&lt;/code&gt; , las matrices se intercambian antes del c&amp;aacute;lculo.</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;values&lt;/code&gt; no son del mismo tama&amp;ntilde;o que &lt;code&gt;a&lt;/code&gt; y la &lt;code&gt;mask&lt;/code&gt; , se repetir&amp;aacute;. Esto da un comportamiento diferente de los &lt;code&gt;a[mask] = values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">Si los &lt;code&gt;values&lt;/code&gt; son menores que &lt;code&gt;a&lt;/code&gt; , se repite:</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x2&lt;/code&gt; es un escalar, su signo se copiar&amp;aacute; a todos los elementos de &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una lista o tupla, se convierte en un ndarray; de lo contrario, no se modifica y se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la suma y la multiplicaci&amp;oacute;n consigo mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una lista o tupla, se convierte en un ndarray; de lo contrario, no se modifica y se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la suma y la multiplicaci&amp;oacute;n consigo mismos y con los elementos de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una matriz multidimensional, solo se baraja a lo largo de su primer &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una instancia poly1d, el resultado es la composici&amp;oacute;n de los dos polinomios, es decir, &lt;code&gt;x&lt;/code&gt; se &quot;sustituye&quot; en &lt;code&gt;p&lt;/code&gt; y se devuelve el resultado simplificado. Adem&amp;aacute;s, el tipo de &lt;code&gt;x&lt;/code&gt; - array_like o poly1d - gobierna el tipo de salida: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; un objeto poly1d =&amp;gt; &lt;code&gt;values&lt;/code&gt; tambi&amp;eacute;n lo es.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una secuencia, se devuelve &lt;code&gt;p(x)&lt;/code&gt; para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es otro polinomio, se devuelve el polinomio compuesto &lt;code&gt;p(x(t))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un subtipo de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,&lt;/a&gt; el valor devuelto ser&amp;aacute; del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un n&amp;uacute;mero entero, permuta aleatoriamente &lt;code&gt;np.arange(x)&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es una matriz, haga una copia y mezcle los elementos al azar.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es inexacta, NaN se sustituye por cero o por el valor definido por el usuario en &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; palabra clave, el infinito se sustituye por el m&amp;aacute;s grande finita valores de coma flotante representables por &lt;code&gt;x.dtype&lt;/code&gt; o por el valor definido por el usuario en &lt;code&gt;posinf&lt;/code&gt; palabra clave y se sustituye por -infinity los valores de coma flotante finitos m&amp;aacute;s negativos representables por &lt;code&gt;x.dtype&lt;/code&gt; o por el valor definido por el usuario en la palabra clave &lt;code&gt;neginf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es inexacto, entonces no se realizan reemplazos.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es de un tipo de entero con signo, entonces el tipo de salida es el entero de plataforma predeterminado:</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;xp&lt;/code&gt; y &lt;code&gt;fp&lt;/code&gt; tienen una longitud diferente Si &lt;code&gt;xp&lt;/code&gt; o &lt;code&gt;fp&lt;/code&gt; no son secuencias 1-D Si &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">Si &lt;em&gt;arr&lt;/em&gt; es una matriz, devuelve su descriptor de tipo de datos, pero si &lt;em&gt;arr&lt;/em&gt; es un escalar de matriz (tiene 0 dimensiones), busca el tipo de datos de menor tama&amp;ntilde;o al que se puede convertir el valor sin desbordamiento o truncamiento a un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">Si el &lt;em&gt;eje&lt;/em&gt; es &lt;em&gt;Ninguno&lt;/em&gt; (el valor predeterminado), la matriz se trata como una matriz 1-D y la operaci&amp;oacute;n se realiza en toda la matriz. Este comportamiento tambi&amp;eacute;n es el predeterminado si self es una matriz de dimensi&amp;oacute;n 0 o una matriz escalar. (Un arreglo escalar es una instancia de los tipos / clases float32, float64, etc., mientras que un arreglo de dimensi&amp;oacute;n 0 es una instancia ndarray que contiene precisamente un arreglo escalar).</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">Si el &lt;em&gt;eje&lt;/em&gt; es un n&amp;uacute;mero entero, entonces la operaci&amp;oacute;n se realiza sobre el eje dado (para cada subarreglo 1-D que se puede crear a lo largo del eje dado).</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">Si los &lt;em&gt;datos&lt;/em&gt; son &lt;code&gt;NULL&lt;/code&gt; , entonces se asignar&amp;aacute; una nueva memoria unitaria inicializada y los &lt;em&gt;indicadores&lt;/em&gt; pueden ser distintos de cero para indicar una matriz contigua al estilo Fortran. Utilice &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; para inicializar la memoria.</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">Si los &lt;em&gt;datos&lt;/em&gt; no son &lt;code&gt;NULL&lt;/code&gt; , se supone que apuntan a la memoria que se utilizar&amp;aacute; para la matriz y el argumento de &lt;em&gt;banderas&lt;/em&gt; se usa como las nuevas banderas para la matriz (excepto el estado de &lt;code&gt;NPY_OWNDATA&lt;/code&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; de la nueva matriz ser reiniciado).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">Si &lt;em&gt;descr&lt;/em&gt; es NULL, se utiliza el tipo de datos del &lt;em&gt;prototipo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">Si &lt;em&gt;dtype&lt;/em&gt; es &lt;code&gt;NULL&lt;/code&gt; , la matriz devuelta tendr&amp;aacute; el mismo tipo de datos que &lt;em&gt;self&lt;/em&gt; . El nuevo tipo de datos debe ser coherente con el tama&amp;ntilde;o de &lt;em&gt;uno mismo&lt;/em&gt; . Los tama&amp;ntilde;os de los elementos deben ser id&amp;eacute;nticos o el &lt;em&gt;self&lt;/em&gt; debe ser de un solo segmento y el n&amp;uacute;mero total de bytes debe ser el mismo. En el &amp;uacute;ltimo caso, las dimensiones de la matriz devuelta se modificar&amp;aacute;n en la &amp;uacute;ltima dimensi&amp;oacute;n (o la primera para las matrices contiguas estilo Fortran). El &amp;aacute;rea de datos de la matriz devuelta y self es exactamente la misma.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">Si &lt;em&gt;op&lt;/em&gt; ya es una matriz, pero no satisface los requisitos, se realiza una copia (que cumplir&amp;aacute; los requisitos). Si esta bandera est&amp;aacute; presente y se debe hacer una copia (de un objeto que ya es una matriz), entonces la bandera &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; correspondiente se establece en la copia devuelta y &lt;em&gt;op&lt;/em&gt; se hace para ser de solo lectura. Debe asegurarse de llamar a &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; para copiar el contenido de nuevo en &lt;em&gt;op&lt;/em&gt; y la matriz &lt;em&gt;op se&lt;/em&gt; volver&amp;aacute; a escribir. Si &lt;em&gt;op&lt;/em&gt; no se puede escribir para empezar, o si a&amp;uacute;n no es una matriz, se genera un error.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">Si &lt;em&gt;permute&lt;/em&gt; es &lt;code&gt;NULL&lt;/code&gt; , la forma del resultado es</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">Si &lt;em&gt;subok&lt;/em&gt; es 1, la matriz reci&amp;eacute;n creada usar&amp;aacute; el subtipo de &lt;em&gt;prototipo&lt;/em&gt; para crear la nueva matriz; de lo contrario, crear&amp;aacute; una matriz de clase base.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">Si el &lt;em&gt;subtipo&lt;/em&gt; es de una subclase de matriz en lugar de la base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; , entonces &lt;em&gt;obj&lt;/em&gt; es el objeto para pasar al m&amp;eacute;todo &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt; de la subclase.</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Si A = qr tal que q es ortonormal (lo cual siempre es posible a trav&amp;eacute;s de Gram-Schmidt), entonces &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; . (En la pr&amp;aacute;ctica, sin embargo, simplemente usamos &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">Si es False, se devuelve una vista de las matrices originales para conservar memoria. El valor predeterminado es verdadero. Tenga en cuenta que &lt;code&gt;sparse=False, copy=False&lt;/code&gt; probablemente devolver&amp;aacute; matrices no contiguas. Adem&amp;aacute;s, m&amp;aacute;s de un elemento de una matriz de difusi&amp;oacute;n puede referirse a una &amp;uacute;nica ubicaci&amp;oacute;n de memoria. Si necesita escribir en las matrices, primero haga copias.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">Si es falso,no se comprobará el recuento de referencia.Por defecto es Verdadero.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">Si es False, el valor predeterminado devuelve el n&amp;uacute;mero de muestras en cada contenedor. Si es True, devuelve la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el contenedor, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">Si es False, el valor predeterminado devuelve el n&amp;uacute;mero de muestras en cada contenedor. Si es True, devuelve la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el contenedor, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">Si K=min(M,N),entonces</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">Si no hay ninguno,el índice está en la matriz aplanada,de lo contrario a lo largo del eje especificado</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">Si no hay ninguno,entonces se asume que la ruta es la ruta local más el nombre del subpaquete.Si no se encuentra un archivo setup.py en la ruta_de_subpaquete,entonces se utiliza una configuración por defecto.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">Si es None, use una instancia de MaskType. De lo contrario, use un nuevo tipo de datos con los mismos campos que &lt;code&gt;dtype&lt;/code&gt; , convertido a tipos booleanos.</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">Si el cálculo del SVD no converge.</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">Si es Verdadero (predeterminado), haga una copia de &lt;code&gt;a&lt;/code&gt; en el resultado. Si es False, modifique &lt;code&gt;a&lt;/code&gt; en el lugar y devuelva una vista.</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">Si es True (predeterminado), &lt;code&gt;u&lt;/code&gt; y &lt;code&gt;vh&lt;/code&gt; tienen las formas &lt;code&gt;(..., M, M)&lt;/code&gt; y &lt;code&gt;(..., N, N)&lt;/code&gt; , respectivamente. De lo contrario, las formas son &lt;code&gt;(..., M, K)&lt;/code&gt; y &lt;code&gt;(..., K, N)&lt;/code&gt; , respectivamente, donde &lt;code&gt;K = min(M, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">Si es Verdadero (predeterminado), se establece la funci&amp;oacute;n para impresi&amp;oacute;n bonita ( &lt;code&gt;__repr__&lt;/code&gt; ), si es Falso, se establece la funci&amp;oacute;n que devuelve la representaci&amp;oacute;n de cadena predeterminada ( &lt;code&gt;__str__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">Si es cierto,se devuelve una red escasa para conservar la memoria.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Si es Verdadero, se supone que &lt;code&gt;M&lt;/code&gt; es hermitiano (sim&amp;eacute;trico si tiene un valor real), lo que permite un m&amp;eacute;todo m&amp;aacute;s eficiente para encontrar valores singulares. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Si es verdad, &lt;code&gt;a&lt;/code&gt; se supone que es hermitiana (sim&amp;eacute;trica si valor real-), lo que permite un m&amp;eacute;todo m&amp;aacute;s eficiente para encontrar valores singulares. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">Si es verdadero, &lt;code&gt;c_or_r&lt;/code&gt; especifica las ra&amp;iacute;ces del polinomio; El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Si es Verdadero, &lt;code&gt;stop&lt;/code&gt; es la &amp;uacute;ltima muestra. De lo contrario, no est&amp;aacute; incluido. El valor predeterminado es verdadero.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">Si es cierto,los NaNs se compararán de igual a igual.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">Si es cierto,alinee los campos por el relleno como lo haría el compilador C.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">Si es True, tambi&amp;eacute;n devuelve los &amp;iacute;ndices de &lt;code&gt;ar&lt;/code&gt; (a lo largo del eje especificado, si se proporciona, o en la matriz plana) que dan como resultado la matriz &amp;uacute;nica.</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Si es Verdadero, tambi&amp;eacute;n devuelve los &amp;iacute;ndices de la matriz &amp;uacute;nica (para el eje especificado, si se proporciona) que se pueden usar para reconstruir &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Si es Verdadero, tambi&amp;eacute;n devuelve el n&amp;uacute;mero de veces que aparece cada elemento &amp;uacute;nico en &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">Si es Verdadero, imprima siempre n&amp;uacute;meros de punto flotante utilizando notaci&amp;oacute;n de punto fijo, en cuyo caso los n&amp;uacute;meros iguales a cero en la precisi&amp;oacute;n actual se imprimir&amp;aacute;n como cero. Si es Falso, entonces se usa notaci&amp;oacute;n cient&amp;iacute;fica cuando el valor absoluto del n&amp;uacute;mero m&amp;aacute;s peque&amp;ntilde;o es &amp;lt;1e-4 o la relaci&amp;oacute;n entre el valor absoluto m&amp;aacute;ximo y el m&amp;iacute;nimo es&amp;gt; 1e3. El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">Si es cierto,siempre devuelve una tupla.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">Si es cierto,se plantea una excepción si se detecta una inconsistencia en el número de columnas.Si es Falso,se emite una advertencia y se saltan las líneas infractoras.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">Si es cierto,no plantee errores por valores inválidos.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">Si es verdadero, los nombres de los campos distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas. Si es False o 'superior', los nombres de los campos se convierten a may&amp;uacute;sculas. Si es 'inferior', los nombres de los campos se convierten a min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">Si es Verdadero, los valores enmascarados se propagan por pares: si un valor est&amp;aacute; enmascarado en &lt;code&gt;x&lt;/code&gt; , el valor correspondiente est&amp;aacute; enmascarado en &lt;code&gt;y&lt;/code&gt; . Si es False, genera una excepci&amp;oacute;n &lt;code&gt;ValueError&lt;/code&gt; cuando faltan algunos valores.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">Si es Verdadero, los valores enmascarados se propagan por pares: si un valor est&amp;aacute; enmascarado en &lt;code&gt;x&lt;/code&gt; , el valor correspondiente est&amp;aacute; enmascarado en &lt;code&gt;y&lt;/code&gt; . Si es falso, genera una excepci&amp;oacute;n. Debido a que el &lt;code&gt;bias&lt;/code&gt; est&amp;aacute; en desuso, este argumento debe tratarse como una palabra clave solo para evitar una advertencia.</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">Si es Verdadero, devuelve ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; ), donde &lt;code&gt;step&lt;/code&gt; es el espacio entre muestras.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">Si es cierto,devuelve un conjunto enmascarado.Si es falso,devuelve una matriz normal.</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">Si es cierto,especifica que el adorno de la llamada es una prueba.Si es falso,especifica que el plato decorado no es una prueba.Por defecto es True.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">Si es cierto,las subclases se conservan.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Si es verdadero, los ejes que se reducen se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra el &lt;code&gt;arr&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">Si es True,los valores en conflicto se añaden al mensaje de error.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">Si es cierto,se devuelven los índices que corresponden a la intersección de las dos matrices.La primera instancia de un valor se utiliza si hay múltiples.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">Si es cierto,se supone que las matrices de entrada son únicas,lo que puede acelerar el cálculo.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el &lt;code&gt;c_index&lt;/code&gt; o &lt;code&gt;f_index&lt;/code&gt; , y el &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; propiedad se puede usar para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el indicador &lt;code&gt;delay_bufalloc&lt;/code&gt; y a&amp;uacute;n no se llam&amp;oacute; a la funci&amp;oacute;n reset ().</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el indicador &lt;code&gt;multi_index&lt;/code&gt; y se puede usar la propiedad &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">Si es True, la matriz devuelta se transpone, por lo que los argumentos se pueden descomprimir usando &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Si es True, la matriz devuelta se transpone, por lo que los argumentos se pueden descomprimir usando &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; . Cuando se usa con un tipo de datos estructurado, se devuelven matrices para cada campo. El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Si es True, la forma de la matriz de coeficientes se extiende con unos a la derecha, uno para cada dimensi&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; . Los escalares tienen dimensi&amp;oacute;n 0 para esta acci&amp;oacute;n. El resultado es que cada columna de coeficientes en &lt;code&gt;c&lt;/code&gt; se eval&amp;uacute;a para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si es False, &lt;code&gt;x&lt;/code&gt; se difunde sobre las columnas de &lt;code&gt;c&lt;/code&gt; para la evaluaci&amp;oacute;n. Esta palabra clave es &amp;uacute;til cuando &lt;code&gt;c&lt;/code&gt; es multidimensional. El valor por defecto es verdadero.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Si es True, la forma de la matriz de ra&amp;iacute;ces se extiende con unas a la derecha, una para cada dimensi&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; . Los escalares tienen dimensi&amp;oacute;n 0 para esta acci&amp;oacute;n. El resultado es que cada columna de coeficientes en &lt;code&gt;r&lt;/code&gt; se eval&amp;uacute;a para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si es falso, &lt;code&gt;x&lt;/code&gt; se difunde sobre las columnas de &lt;code&gt;r&lt;/code&gt; para la evaluaci&amp;oacute;n. Esta palabra clave es &amp;uacute;til cuando &lt;code&gt;r&lt;/code&gt; es multidimensional. El valor por defecto es verdadero.</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">Si es True, los valores de la matriz devuelta se invierten (es decir, False donde un elemento de &lt;code&gt;ar1&lt;/code&gt; est&amp;aacute; en &lt;code&gt;ar2&lt;/code&gt; y True en caso contrario). El valor predeterminado es falso. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; es equivalente a (pero es m&amp;aacute;s r&amp;aacute;pido que) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">Si es True, los valores de la matriz devuelta se invierten, como si el &lt;code&gt;element not in test_elements&lt;/code&gt; calculado no estuviera en test_elements . El valor predeterminado es falso. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; es equivalente a (pero m&amp;aacute;s r&amp;aacute;pido que) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">Si es verdadero, a continuaci&amp;oacute;n, permitir que la matriz de entrada &lt;code&gt;a&lt;/code&gt; a ser modificado por c&amp;aacute;lculos intermedios, para ahorrar memoria. En este caso, el contenido de la entrada &lt;code&gt;a&lt;/code&gt; despu&amp;eacute;s de que se complete esta funci&amp;oacute;n no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada (a) para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a median. Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Tenga en cuenta que, si &lt;code&gt;overwrite_input&lt;/code&gt; es Verdadero, y la entrada a&amp;uacute;n no es un &lt;code&gt;ndarray&lt;/code&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada &lt;code&gt;a&lt;/code&gt; para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Si &lt;code&gt;overwrite_input&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; no es ya un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada &lt;code&gt;a&lt;/code&gt; para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Si &lt;code&gt;overwrite_input&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; no es ya un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">Si es True,entonces se pasarán las subclases (por defecto),de lo contrario el array devuelto será forzado a ser un array de clase base.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">Si es True,entonces se pasarán subclases,de lo contrario la matriz devuelta será forzada a ser una matriz de clase base (por defecto).</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">Si es True,entonces las subclases se pasarán,de lo contrario las matrices devueltas se verán forzadas a ser una matriz de clase base (por defecto).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Si es True, entonces la matriz reci&amp;eacute;n creada usar&amp;aacute; el tipo de subclase de 'a', de lo contrario ser&amp;aacute; una matriz de clase base. Por defecto es Verdadero.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">Si [matriz,matriz],los bordes de los contenedores en cada dimensión (x_borde,y_borde=contenedor).</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">Si [int,int],el número de contenedores en cada dimensión (nx,ny=contenedores).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">Si la versión __svn_.py existía antes,no se hace nada.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">Si a &amp;lt;1.</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">Si una clase (subclase ndarray o no) que tiene el m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; se usa como el objeto de salida de un &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , los resultados se escribir&amp;aacute;n en el objeto devuelto por &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . Se realiza una conversi&amp;oacute;n similar en matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">Si una clase define el m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , esto deshabilita el &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; descrito a continuaci&amp;oacute;n para ufuncs (que eventualmente puede quedar obsoleto).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">Si se est&amp;aacute; utilizando un b&amp;uacute;fer fijo en tiempo de compilaci&amp;oacute;n (ambos indicadores &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; ), el tama&amp;ntilde;o interno tambi&amp;eacute;n se puede usar como se&amp;ntilde;al. Se garantiza que el tama&amp;ntilde;o se convertir&amp;aacute; en cero cuando &lt;code&gt;iternext()&lt;/code&gt; devuelva falso, lo que habilita la siguiente construcci&amp;oacute;n de bucle. Tenga en cuenta que si usa esta construcci&amp;oacute;n, no debe pasar &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; como una marca , ya que provocar&amp;aacute; tama&amp;ntilde;os m&amp;aacute;s grandes en algunas circunstancias.</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">Si se recupera un campo cuyo objeto dtype tiene este atributo, las dimensiones adicionales impl&amp;iacute;citas en la &lt;em&gt;forma&lt;/em&gt; se agregan al final de la matriz recuperada.</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">Si se especifica un formateador para un tipo determinado, la palabra clave de &lt;code&gt;precision&lt;/code&gt; se ignora para ese tipo.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">Si un determinado conjunto no satisface las restricciones especificadas.</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">Si a es un objeto matricial,entonces el valor de retorno es también matricial:</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">Si a es un int y menos de cero,si a o p no son 1-dimensionales,si a es un array-como de tamaño 0,si p no es un vector de probabilidades,si a y p tienen diferentes longitudes,o si replace=False y el tamaño de la muestra es mayor que el tamaño de la población</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">Si a es un int y menos de cero,si p no es de una dimensión,si a es un array con un tamaño 0,si p no es un vector de probabilidades,si a y p tienen longitudes diferentes,o si replace=False y el tamaño de la muestra es mayor que el tamaño de la población.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">Si se trata de una lista de cuerdas,cada cuerda debe representar un tipo.Si es tipo_arreglo,se utiliza la representación de caracteres del tipo_arreglo.</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">Si es un dtype escalar, se devuelve el car&amp;aacute;cter de cadena correspondiente. Si es un objeto, &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; intenta inferir su tipo escalar y luego devuelve el car&amp;aacute;cter de cadena correspondiente.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">Si se pasa un valor escalar.</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">Si se proporciona un segundo argumento, el resultado se almacena all&amp;iacute;. Si el tipo de esa matriz es un tipo num&amp;eacute;rico, el resultado se representa como ceros y unos, si el tipo es booleano, entonces como Falso y Verdadero. El valor de retorno &lt;code&gt;out&lt;/code&gt; es entonces una referencia a esa matriz.</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">Si una matriz de dimensi&amp;oacute;n cero est&amp;aacute; presente en el &amp;iacute;ndice &lt;em&gt;y&lt;/em&gt; es un &amp;iacute;ndice entero completo, el resultado ser&amp;aacute; un &lt;em&gt;escalar&lt;/em&gt; y no una matriz de dimensi&amp;oacute;n cero. (La indexaci&amp;oacute;n avanzada no se activa).</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">Si lo real y lo deseado no son iguales a la precisión especificada.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">Si lo real y lo deseado no son iguales.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">Si los objetos reales y los deseados no son iguales.</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">Si todos los m&amp;eacute;todos &lt;code&gt;__array_function__&lt;/code&gt; devuelven &lt;code&gt;NotImplemented&lt;/code&gt; , NumPy generar&amp;aacute; &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">Si todas las matrices son 1-D, &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; es equivalente a:</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">Si todos los valores están enmascarados,devuelva Ninguno.En caso contrario,devuelva una lista de dos tuplas,correspondientes a los índices del primer y último valor desenmascarado respectivamente.</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">Si una matriz tiene un determinante muy peque&amp;ntilde;o o muy grande, entonces una llamada a &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; puede desbordarse o subdesbordarse. Esta rutina es m&amp;aacute;s robusta frente a estos problemas, porque calcula el logaritmo del determinante en lugar del determinante en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">Si una matriz no tiene elementos ( &lt;code&gt;self.size == 0&lt;/code&gt; ), no hay un &amp;iacute;ndice legal y las zancadas nunca se utilizan. Cualquier arreglo sin elementos puede considerarse contiguo al estilo C y al estilo Fortran.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">Si se crea una matriz usando un tipo de datos que describe una submatriz, las dimensiones de la submatriz se agregan a la forma de la matriz cuando se crea la matriz. Las submatrices en un campo de un tipo estructurado se comportan de manera diferente, consulte &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Acceso al campo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">Si se crea una matriz con este m&amp;eacute;todo, simplemente agregando 'tama&amp;ntilde;o de elemento' para cada iteraci&amp;oacute;n atravesar&amp;aacute; la nueva matriz que coincide con el iterador.</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si un elemento de &lt;code&gt;axes&lt;/code&gt; es mayor que el n&amp;uacute;mero de ejes de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">Si un &amp;iacute;ndice excede la dimensi&amp;oacute;n de la matriz a lo largo del &lt;code&gt;axis&lt;/code&gt; , se devuelve una submatriz vac&amp;iacute;a correspondientemente.</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">Si una entrada tiene un tama&amp;ntilde;o de dimensi&amp;oacute;n de 1 en su forma, la primera entrada de datos en esa dimensi&amp;oacute;n se utilizar&amp;aacute; para todos los c&amp;aacute;lculos a lo largo de esa dimensi&amp;oacute;n. En otras palabras, la maquinaria paso a paso de &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; simplemente no avanzar&amp;aacute; a lo largo de esa dimensi&amp;oacute;n (el &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;paso&lt;/a&gt; ser&amp;aacute; 0 para esa dimensi&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">Si un ndarray,una muestra aleatoria se genera a partir de sus elementos.Si un int,la muestra aleatoria se genera como si fuera un np.arange(a)</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">Si se proporciona un objeto,su método de escritura debe tomar un argumento,una cadena.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">Si alguna entrada es parecida a una matriz , &lt;code&gt;pv&lt;/code&gt; devuelve una matriz de la misma forma. Comparemos diferentes tipos de inter&amp;eacute;s en el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">Si alguna entrada es como una matriz, devuelve una matriz de la misma forma. Comparemos diferentes tipos de inter&amp;eacute;s del ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">Si existe alguna superposici&amp;oacute;n de lectura / escritura, este indicador garantiza que el resultado de la operaci&amp;oacute;n sea el mismo que si se copiaran todos los operandos. En los casos en que sea necesario realizar copias, &lt;strong&gt;el resultado del c&amp;aacute;lculo puede no estar definido sin esta bandera.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">Si algún valor en el alfa es menor o igual a cero</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">Si algún operando de escritura se ha solapado con algún operando de lectura,elimine todas las superposiciones haciendo copias temporales (habilitando UPDATEIFCOPY para operandos de escritura,si es necesario).Un par de operandos se superpone si hay una dirección de memoria que contiene datos comunes a ambas matrices.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">Si el argumento consiste exclusivamente en los tipos de int.</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">Si los argumentos se pasan sin palabras clave, los nombres de las variables correspondientes, en el archivo &lt;code&gt;.npz&lt;/code&gt; , son 'arr_0', 'arr_1', etc. Si se dan argumentos de palabras clave, los nombres de las variables correspondientes en el archivo &lt;code&gt;.npz&lt;/code&gt; coincidir&amp;aacute;n con los nombres de palabras clave.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">Si es similar a la matriz,los bordes de los contenedores para las dos dimensiones (x_bordes=y_bordes=bins).</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">Si el eje es 0,sólo se suprimen las filas.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">Si el eje es 1 o -1,sólo se suprimen las columnas.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">Si el eje es Ninguno,se suprimen tanto las filas como las columnas.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,se realiza un producto en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,se realiza una suma en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,el promedio se realiza en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">Si el eje es una tupla de ints,el volteo se realiza en todos los ejes especificados en la tupla.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son matrices 1-D, es un producto interno de vectores (sin conjugaci&amp;oacute;n compleja).</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son matrices 2-D, es una multiplicaci&amp;oacute;n de matrices, pero se &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; usar matmul o &lt;code&gt;a @ b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; son &lt;code&gt;NULL&lt;/code&gt; , devuelve &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; ). De lo contrario, se deben dar tanto &lt;em&gt;x&lt;/em&gt; como &lt;em&gt;y&lt;/em&gt; y el objeto devuelto tiene la forma de &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; y tiene elementos de &lt;em&gt;x&lt;/em&gt; e &lt;em&gt;y&lt;/em&gt; donde &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; es respectivamente Verdadero o Falso.</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">Si ambos argumentos son 2-D se multiplican como las matrices convencionales.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">Si tanto el infinito positivo como el negativo están presentes,la suma será un número no A (NaN).</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">Si se le llama con todos los argumentos que no sean la clase de advertencia omitida,puede utilizarse como gestor de contexto:</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">Si la entrada compleja devuelve una matriz real si las partes complejas están cerca de cero.</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">Si los cálculos no convergen.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si la condici&amp;oacute;n es &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , los valores faltantes se consideran &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">Si copy es False y una de las entradas es &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; , devuelve una vista de la otra m&amp;aacute;scara de entrada. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">Si los datos se pasan a &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; , esta memoria no se debe desasignar hasta que se elimine la nueva matriz. Si estos datos provienen de otro objeto Python, esto se puede lograr usando &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; en ese objeto y configurando el miembro base de la nueva matriz para que apunte a ese objeto. Si se pasan pasos, deben ser coherentes con las dimensiones, el tama&amp;ntilde;o del elemento y los datos de la matriz.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">Si se define, el eje de &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; que define el vector (s) y la cruz producto (s). Anulaciones &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; y &lt;code&gt;axisc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">Si cualquiera de &lt;code&gt;a&lt;/code&gt; o &lt;code&gt;b&lt;/code&gt; es 0-D (escalar), es equivalente a &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; y usando &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; o &lt;code&gt;a * b&lt;/code&gt; se prefiere.</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">Si cualquiera de los argumentos es ND, N&amp;gt; 2, se trata como una pila de matrices que residen en los dos &amp;uacute;ltimos &amp;iacute;ndices y se difunde en consecuencia.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">Si cualquiera de las matrices contiene una o más NaNs,se devuelve Falso.Los infs son tratados como iguales si están en el mismo lugar y del mismo signo en ambas matrices.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">Si el elemento tiene un tipo de complejo con cero parte de complejo,el valor de retorno de ese elemento es Verdadero.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">Si el factoraje falla.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">Si el archivo es una cadena o un objeto parecido a una ruta de acceso,entonces ese archivo se abre,de lo contrario se asume que es un objeto de archivo.El objeto archivo debe admitir el acceso aleatorio (es decir,debe tener métodos de &quot;tell and seek&quot;).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">Si se agregan filtros y se proporciona la palabra clave del &lt;code&gt;module&lt;/code&gt; , el registro de advertencia de este m&amp;oacute;dulo se borrar&amp;aacute; adicionalmente al aplicarlo, ingresar al contexto o salir de &amp;eacute;l. Esto podr&amp;iacute;a hacer que las advertencias aparezcan por segunda vez despu&amp;eacute;s de salir del contexto si se configuraron para imprimirse una vez (predeterminado) y ya se imprimieron antes de ingresar al contexto.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">Si el formato es Ninguno,entonces esto detectará automáticamente los formatos.Utilice la lista de tuplas en lugar de la lista de listas para un procesamiento más rápido.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">Si se da y no es &lt;code&gt;False&lt;/code&gt; , devuelva no solo la estimaci&amp;oacute;n sino tambi&amp;eacute;n su matriz de covarianza. De forma predeterminada, la covarianza se escala mediante chi2 / sqrt (N-dof), es decir, se presume que los pesos no son confiables excepto en un sentido relativo y todo se escala de manera que el chi2 reducido sea la unidad. Esta escala se omite si &lt;code&gt;cov='unscaled'&lt;/code&gt; , como es relevante para el caso de que los pesos sean 1 / sigma ** 2, y se sabe que sigma es una estimaci&amp;oacute;n confiable de la incertidumbre.</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">Si se proporciona, cualquier cadena de la forma &lt;code&gt;@key@&lt;/code&gt; ser&amp;aacute; reemplazada por &lt;code&gt;subst_dict[key]&lt;/code&gt; en el archivo de plantilla cuando se instale. El prefijo de instalaci&amp;oacute;n siempre est&amp;aacute; disponible a trav&amp;eacute;s de la variable &lt;code&gt;@prefix@&lt;/code&gt; , ya que el prefijo de instalaci&amp;oacute;n no es f&amp;aacute;cil de obtener de forma confiable desde setup.py.</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">Si se da, la matriz debe tener la forma &lt;code&gt;[beg, end]&lt;/code&gt; , donde &lt;code&gt;beg&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; son los puntos finales del dominio. Si se proporciona None, se utiliza el dominio de clase. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">Si se da, la matriz resultante debe tener la forma &lt;code&gt;[beg, end]&lt;/code&gt; , donde &lt;code&gt;beg&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; son los puntos finales de la ventana. Si se proporciona Ninguno, se utiliza la ventana de clase. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">Si se da,se devuelve para los objetos cuyos tipos no se pueden determinar.Si no se da,no se devuelve ninguno para esos objetos.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">Si la matriz de entrada &lt;code&gt;a&lt;/code&gt; no es 2D.</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">Si la entrada es de la forma equivocada (la entrada debe ser una matriz de 1-D o 2-D cuadrada).</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">Si es int,el número de contenedores para las dos dimensiones (nx=ny=contenedores).</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">Si se dan argumentos de palabras clave,entonces los nombres de archivo se toman de las palabras clave.Si se pasan argumentos sin palabras clave,entonces los nombres de archivo almacenados son arr_0,arr_1,etc.</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">Si las profundidades de la lista no coinciden, por ejemplo, &lt;code&gt;[[a, b], c]&lt;/code&gt; es ilegal y debe escribirse &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">Si las listas est&amp;aacute;n vac&amp;iacute;as, por ejemplo, &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">Si la entrada es multidimensional,devuelve un nuevo ndarray de índices a los valores mínimos a lo largo del eje dado.En caso contrario,devuelve un escalar de índices a los valores mínimos a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">Si es necesario,se aplanará antes de tomar las diferencias.</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">Si no se define ninguno, el C-API se declara &lt;code&gt;static void**&lt;/code&gt; , por lo que solo es visible dentro de la unidad de compilaci&amp;oacute;n que #include numpy / arrayobject.h.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">Si no &lt;code&gt;__array_function__&lt;/code&gt; m&amp;eacute;todos __array_function__ , NumPy llamar&amp;aacute; por defecto a su propia implementaci&amp;oacute;n, destinada a usarse en matrices NumPy. Este caso surge, por ejemplo, cuando todos los argumentos en forma de matriz son n&amp;uacute;meros o listas de Python. (Las matrices NumPy tienen un m&amp;eacute;todo &lt;code&gt;__array_function__&lt;/code&gt; , que se indica a continuaci&amp;oacute;n, pero siempre devuelve &lt;code&gt;NotImplemented&lt;/code&gt; si cualquier argumento que no sea una subclase de matriz NumPy implementa &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">Si ninguna de las entradas anula ufunc, todas las matrices de salida se pasar&amp;aacute;n a los m&amp;eacute;todos &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; de la entrada (adem&amp;aacute;s de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; y escalares) que la define &lt;strong&gt;y&lt;/strong&gt; tiene la mayor &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; de cualquier otra entrada a la funci&amp;oacute;n universal. El &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; predeterminado del ndarray es 0.0 y el &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; predeterminado de un subtipo es 0.0. Las matrices tienen &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; igual a 10.0.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si no es &lt;code&gt;None&lt;/code&gt; ,la normalizaci&amp;oacute;n es por &lt;code&gt;(N - ddof)&lt;/code&gt; , donde &lt;code&gt;N&lt;/code&gt; es el n&amp;uacute;mero de observaciones; esto anula el valor impl&amp;iacute;cito en el &lt;code&gt;bias&lt;/code&gt; . El valor predeterminado es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si no es &lt;code&gt;None&lt;/code&gt; se anula el valor predeterminado impl&amp;iacute;cito en el &lt;code&gt;bias&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;ddof=1&lt;/code&gt; devolver&amp;aacute; la estimaci&amp;oacute;n insesgada, incluso si se especifican tanto los &lt;code&gt;fweights&lt;/code&gt; como los &lt;code&gt;aweights&lt;/code&gt; , y &lt;code&gt;ddof=0&lt;/code&gt; devolver&amp;aacute; el promedio simple. Consulte las notas para obtener m&amp;aacute;s detalles. El valor predeterminado es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">Si no es ninguno,las teclas deben indicar el tipo o tipos a los que se aplica la respectiva función de formato.Las llamadas deben devolver una cadena.Los tipos que no se especifican (mediante sus correspondientes teclas)se manejan mediante los formateadores predeterminados.Los tipos individuales para los que se puede establecer un formateador son:</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">Si no es Ninguno, se usa el dominio especificado en lugar del de la instancia que llama. Debe tener la forma &lt;code&gt;[beg,end]&lt;/code&gt; . El valor predeterminado es Ninguno, en cuyo caso se utiliza el dominio de clase.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">Si no es None, entonces &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt; en memoria el archivo, usando el modo dado (vea numpy.memmap para una descripci&amp;oacute;n detallada de los modos). Una matriz mapeada en memoria se mantiene en disco. Sin embargo, se puede acceder y cortar como cualquier ndarray. La asignaci&amp;oacute;n de memoria es especialmente &amp;uacute;til para acceder a peque&amp;ntilde;os fragmentos de archivos grandes sin leer todo el archivo en la memoria.</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">Si un argumento: un escalar, solo se usa en el caso de que &lt;code&gt;a&lt;/code&gt; sea ​​de tama&amp;ntilde;o 1. Si dos argumentos: el &amp;uacute;ltimo argumento es el valor que se va a establecer y debe ser un escalar, el primer argumento especifica la ubicaci&amp;oacute;n de un solo elemento de matriz. Es un int o una tupla.</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Si uno de los argumentos de entrada o salida tiene un m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , se ejecuta en &lt;em&gt;lugar&lt;/em&gt; de ufunc. Si m&amp;aacute;s de uno de los argumentos implementa &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , se prueban en el orden: subclases antes que superclases, entradas antes que salidas, en caso contrario, de izquierda a derecha. La primera rutina que devuelve algo que no sea &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; determina el resultado. Si todas las operaciones &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; devuelven &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; , se genera un &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">Si uno o m&amp;aacute;s elementos difieren en m&amp;aacute;s de &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">Si uno lanza un dado repetidamente hasta la tercera vez que aparece un &quot;1&quot;, entonces la distribuci&amp;oacute;n de probabilidad del n&amp;uacute;mero de no &quot;1&quot; que aparecen antes del tercer &quot;1&quot; es una distribuci&amp;oacute;n binomial negativa.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">Si se utiliza el mismo nombre de dimensión en múltiples lugares,esto hace que se aplique el mismo tamaño de las dimensiones correspondientes.</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">Si se utilizan los indicadores de operandos &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; o &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; , los operandos pueden ser vistas de los datos originales con el indicador &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; . En este caso, nditer debe usarse como administrador de contexto o se debe llamar al m&amp;eacute;todo nditer.close antes de usar el resultado. Los datos temporales se volver&amp;aacute;n a escribir en los datos originales cuando se &lt;code&gt;__exit__&lt;/code&gt; funci&amp;oacute;n __exit__ pero no antes:</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">Si se da fuera y no tiene un atributo de máscara,¡la máscara de un se pierde!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">Si se pasa un solo ndarray o escalar (una lista anidada de profundidad 0),se devuelve sin modificar (y no se copia).</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">Si se proporcionan argumentos positivos de tipo int_like, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; genera una matriz de forma &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; , llena de flotantes aleatorios muestreados a partir de una distribuci&amp;oacute;n univariada &quot;normal&quot; (gaussiana) de media 0 y varianza 1. Un solo flotante Se devuelve una muestra aleatoria de la distribuci&amp;oacute;n si no se proporciona ning&amp;uacute;n argumento.</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">Si se proporciona, obliga al c&amp;aacute;lculo a utilizar el tipo de datos especificado. Tenga en cuenta que puede que tenga que dar tambi&amp;eacute;n una m&amp;aacute;s liberal &lt;code&gt;casting&lt;/code&gt; par&amp;aacute;metro para permitir las conversiones. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se proporciona, es una lista de ints o None para cada operando. La lista de ejes de un operando es un mapeo de las dimensiones del iterador a las dimensiones del operando. Se puede colocar un valor de -1 para las entradas, lo que hace que esa dimensi&amp;oacute;n se trate como un &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">Si se proporciona, uno por encima del entero m&amp;aacute;s grande (con signo) que se extraer&amp;aacute; de la distribuci&amp;oacute;n (consulte el comportamiento anterior si es &lt;code&gt;high=None&lt;/code&gt; ). Si es similar a una matriz, debe contener valores enteros</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">Si se proporciona,el cálculo se hace en esta matriz.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">Si se proporciona,el destino para colocar el resultado.La forma debe ser correcta,coincidiendo con la de lo que el concatenado habría devuelto si no se especificara un argumento de salida.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">Si se proporciona,el destino para colocar el resultado.La forma debe ser correcta,coincidiendo con la de la pila que habría regresado si no se especificara un argumento de salida.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">Si se proporciona, el entero m&amp;aacute;s grande (con signo) que se extraer&amp;aacute; de la distribuci&amp;oacute;n (consulte el comportamiento anterior si es &lt;code&gt;high=None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona, el resultado se insertar&amp;aacute; en esta matriz. Debe tener la forma y el tipo &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">Si se proporciona,el resultado se insertará en esta matriz.Debe tener la forma y el tipo apropiados.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Si se proporciona, el resultado se insertar&amp;aacute; en esta matriz. Debe tener la forma y el tipo adecuados. Tenga en cuenta que &lt;code&gt;out&lt;/code&gt; siempre est&amp;aacute; amortiguada si &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; utilice otros modos para un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Si se proporciona, el resultado se colocar&amp;aacute; en esta matriz. Debe tener la forma y el tipo adecuados. Tenga en cuenta que &lt;code&gt;out&lt;/code&gt; siempre est&amp;aacute; amortiguada si &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; utilice otros modos para un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">Si se proporciona,esta matriz se llena con el resultado.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">Si se establece en falso,la matriz devuelta siempre será sólo de lectura.De lo contrario,será escribible si la matriz original lo era.Es aconsejable ponerlo en Falso si es posible (ver Notas).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">Si se establece en la cadena &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; habilita el modo de impresi&amp;oacute;n heredado 1,13. Esto se aproxima a la salida de impresi&amp;oacute;n de 1,13 al incluir un espacio en la posici&amp;oacute;n del signo de los flotantes y un comportamiento diferente para las matrices 0d. Si se establece en &lt;code&gt;False&lt;/code&gt; , desactiva el modo heredado. Las cadenas no reconocidas se ignorar&amp;aacute;n con una advertencia de compatibilidad con versiones posteriores.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">Si se usa la notaci&amp;oacute;n de sector, la sintaxis &lt;code&gt;start:stop:step&lt;/code&gt; es equivalente a &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; dentro de los corchetes. Sin embargo, si el &lt;code&gt;step&lt;/code&gt; es un n&amp;uacute;mero imaginario (es decir, 100j), entonces su parte entera se interpreta como un n&amp;uacute;mero de puntos deseado y el inicio y la parada son inclusivos. En otras palabras, &lt;code&gt;start:stop:stepj&lt;/code&gt; se interpreta como &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; dentro de los corchetes. Despu&amp;eacute;s de la expansi&amp;oacute;n de la notaci&amp;oacute;n de corte, todas las secuencias separadas por comas se concatenan juntas.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Si algunos de los valores singulares de &lt;code&gt;V&lt;/code&gt; son tan peque&amp;ntilde;os que se descuidan (y &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ), se &lt;code&gt;RankWarning&lt;/code&gt; un RankWarning . Esto significa que los valores de los coeficientes pueden estar mal determinados. El ajuste a un polinomio de orden inferior generalmente eliminar&amp;aacute; la advertencia (pero puede que no sea lo que desea, por supuesto; si tiene razones independientes para elegir el t&amp;iacute;tulo que no funciona, es posible que deba: a) reconsiderar esos motivos, y / o b) reconsiderar la calidad de sus datos). El par&amp;aacute;metro &lt;code&gt;rcond&lt;/code&gt; tambi&amp;eacute;n se puede establecer en un valor menor que su predeterminado, pero el ajuste resultante puede ser falso y tener grandes contribuciones del error de redondeo.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Si algunos de los valores singulares de &lt;code&gt;V&lt;/code&gt; son tan peque&amp;ntilde;os que se descuidan, se &lt;code&gt;RankWarning&lt;/code&gt; un RankWarning . Esto significa que los valores de los coeficientes pueden estar mal determinados. El uso de un ajuste de orden inferior generalmente eliminar&amp;aacute; la advertencia. El par&amp;aacute;metro &lt;code&gt;rcond&lt;/code&gt; tambi&amp;eacute;n se puede establecer en un valor menor que su predeterminado, pero el ajuste resultante puede ser falso y tener grandes contribuciones del error de redondeo.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">Si lo disperso es falso:</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">Si lo disperso es cierto:</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">Si se establece que lo disperso es verdadero,la red será devuelta en una representación dispersa.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se especifica, todos los campos se cambiar&amp;aacute;n al orden de bytes proporcionado. De lo contrario, se utiliza el orden de bytes predeterminado. Para todos los especificadores de cadena disponibles, consulte &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">Si el estado es un diccionario, se establece directamente mediante la propiedad de &lt;code&gt;state&lt;/code&gt; BitGenerators .</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">Si se establecen las banderas (obsoletas) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , tiene un significado diferente, es decir, base es la matriz en la que se copiar&amp;aacute; la matriz actual tras la resoluci&amp;oacute;n de la copia. Es probable que esta sobrecarga de la propiedad base para dos funciones cambie en una versi&amp;oacute;n futura de NumPy.</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">Si el objeto &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; es una matriz estructurada, se puede acceder a los &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;campos&lt;/a&gt; de la matriz indexando la matriz con cadenas, como en un diccionario.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">Si se especifica el argumento de palabra clave de &lt;code&gt;order&lt;/code&gt; . Este comportamiento es un error en NumPy.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">Si el valor del &lt;code&gt;width&lt;/code&gt; es insuficiente, se ignorar&amp;aacute; y &lt;code&gt;num&lt;/code&gt; se devolver&amp;aacute; en forma binaria ( &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) o en complemento a dos ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) con su ancho igual al n&amp;uacute;mero m&amp;iacute;nimo de bits necesarios para representar el n&amp;uacute;mero en el forma designada. Este comportamiento est&amp;aacute; desaprobado y luego generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">Si el cálculo del SVD no converge.</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">Si el campo al que se accede es un subconjunto,las dimensiones del subconjunto se añaden a la forma del resultado.</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">Si el acumulador es demasiado pequeño,se produce un desbordamiento:</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">Si la matriz no tiene m&amp;aacute;scara, se devuelve la direcci&amp;oacute;n de &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Esta direcci&amp;oacute;n generalmente no est&amp;aacute; cerca de los datos en la memoria:</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">Si la matriz no es compatible con la nueva forma de acuerdo con las reglas de transmisi&amp;oacute;n de NumPy.</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">Si la memoria intermedia tiene datos que no están en el orden de bytes de la máquina,esto debe especificarse como parte del tipo de datos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">Si el tipo de datos com&amp;uacute;n se conoce de antemano, no use esta marca. En su lugar, establezca el dtype solicitado para todos los operandos.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">Si la condición es llamable,se utiliza en tiempo de ejecución para tomar la decisión de forma dinámica.Esto es útil para las pruebas que pueden requerir importaciones costosas,para retrasar el costo hasta que el conjunto de pruebas se ejecute realmente.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">Si la conversión no es posible</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">Si el m&amp;oacute;dulo ctypes no est&amp;aacute; disponible, entonces el atributo ctypes de los objetos de matriz todav&amp;iacute;a devuelve algo &amp;uacute;til, pero los objetos ctypes no se devuelven y pueden surgir errores en su lugar. En particular, el objeto seguir&amp;aacute; teniendo el atributo &lt;code&gt;as_parameter&lt;/code&gt; que devolver&amp;aacute; un n&amp;uacute;mero entero igual al atributo de datos.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">Si el dominio actual es el intervalo &lt;code&gt;[l1, r1]&lt;/code&gt; y la ventana es &lt;code&gt;[l2, r2]&lt;/code&gt; , entonces la funci&amp;oacute;n de mapeo lineal &lt;code&gt;L&lt;/code&gt; est&amp;aacute; definida por las ecuaciones:</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">Si el tipo de datos es &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;un tipo de datos estructurado&lt;/a&gt; , un agregado de otros tipos de datos ( &lt;em&gt;por ejemplo&lt;/em&gt; , que describe un elemento de matriz que consta de un n&amp;uacute;mero entero y un flotante),</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">Si el tipo de datos es un subconjunto,¿cuál es su forma y tipo de datos?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">Si la descomposici&amp;oacute;n falla, por ejemplo, si &lt;code&gt;a&lt;/code&gt; no es positivo-definido.</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo amax de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; a &lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo de subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;code&gt;ndarray&lt;/code&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo de &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; a&lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;code&gt;ndarray&lt;/code&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">Si la dimensi&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; es menor que 2.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">Si la discontinuidad en &lt;code&gt;p&lt;/code&gt; es menor que &lt;code&gt;pi&lt;/code&gt; , pero mayor que &lt;code&gt;discont&lt;/code&gt; , no se realiza ning&amp;uacute;n desenvolvimiento porque tomar el complemento 2 * pi solo aumentar&amp;iacute;a la discontinuidad.</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">Si el cálculo de los valores propios no converge.</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">Si el archivo contiene datos de pepinillos,entonces se devuelve cualquier objeto almacenado en el pepinillo.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npy&lt;/code&gt; , se devuelve una &amp;uacute;nica matriz.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npz&lt;/code&gt; , el valor devuelto admite el protocolo del administrador de contexto de forma similar a la funci&amp;oacute;n de apertura:</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npz&lt;/code&gt; , se devuelve un objeto similar a un diccionario, que contiene pares clave-valor &lt;code&gt;{filename: array}&lt;/code&gt; , uno para cada archivo en el archivo.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">Si el nombre del archivo termina en &lt;code&gt;.gz&lt;/code&gt; , el archivo se guarda autom&amp;aacute;ticamente en formato gzip comprimido. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; comprende los archivos comprimidos con gzip de forma transparente.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">Si el primer argumento es 1-D se trata como un vector fila.Si el último argumento es 1-D se trata como un vector de columna.Los otros argumentos deben ser 2-D.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">Si el primer argumento es 1-D se trata como un vector fila.Si el último argumento es 1-D se trata como un vector de columna.Los otros argumentos deben ser 2-D.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">Si el primer argumento es 1-D,se promueve a una matriz preparando un 1 a sus dimensiones.Después de la multiplicación de la matriz,el 1 preparado se elimina.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">Si el primer argumento es una tupla,los otros argumentos son ignorados:</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">Si la siguiente ecuaci&amp;oacute;n es Verdadera en cuanto a elementos, entonces &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; devuelve Verdadero:</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">Si la siguiente ecuación es de elemento Verdadero,entonces allclose devuelve Verdadero.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">Si las cadenas dadas son iguales, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; no hace nada. Si no son iguales, se genera un AssertionError y se muestra la diferencia entre las cadenas.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">Si el archivo de encabezado que contiene el prototipo de &lt;code&gt;double dot()&lt;/code&gt; tambi&amp;eacute;n contiene otros prototipos que desea ajustar, por lo que necesita &lt;code&gt;%include&lt;/code&gt; este archivo de encabezado, entonces tambi&amp;eacute;n necesitar&amp;aacute; un &lt;code&gt;%ignore dot;&lt;/code&gt; directiva, colocada despu&amp;eacute;s de &lt;code&gt;%rename&lt;/code&gt; y antes de &lt;code&gt;%include&lt;/code&gt; directivas. O, si la funci&amp;oacute;n en cuesti&amp;oacute;n es un m&amp;eacute;todo de clase, querr&amp;aacute; usar &lt;code&gt;%extend&lt;/code&gt; lugar de &lt;code&gt;%inline&lt;/code&gt; adem&amp;aacute;s de &lt;code&gt;%ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">Si la expresión del índice contiene matrices separadas por comas,entonces apílalas a lo largo de su primer eje.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">Si la expresión del índice contiene notación de corte o escalares,entonces cree una matriz 1-D con un rango indicado por la notación de corte.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">Si la entrada &lt;code&gt;a&lt;/code&gt; contiene una parte imaginaria, se descarta silenciosamente.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">Si el archivo de entrada no existe o no puede ser leído.</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">Si la entrada tiene un tipo entero la función es equivalente a np.max.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">Si la entrada tiene un tipo entero la función es equivalente a np.min.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">Si la entrada es 2d y se especifica el eje,el resultado es una lista de listas.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">Si la entrada no es unidimensional o contiene elementos con valores negativos, o si &lt;code&gt;minlength&lt;/code&gt; es negativo.</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el par&amp;aacute;metro de entrada &lt;code&gt;n&lt;/code&gt; es mayor que el tama&amp;ntilde;o de la entrada, la entrada se rellena a&amp;ntilde;adiendo ceros al final. Aunque este es el enfoque com&amp;uacute;n, puede dar lugar a resultados sorprendentes. Si se desea un relleno diferente, se debe realizar antes de llamar a &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">Si las entradas son ndarrays, entonces np.greater es equivalente a '&amp;gt;'.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">Si las entradas o el tipo d son complejas,la salida seguirá una espiral logarítmica en el plano complejo.(Hay un número infinito de espirales que pasan por dos puntos;la salida seguirá el camino más corto de estos.)</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">Si el iterador está almacenado en un búfer,devuelve el tamaño del búfer que se está utilizando,de lo contrario devuelve 0.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">Si el iterador está rastreando un multiíndice,éste les da soporte,y realiza otras optimizaciones del iterador que son posibles si los multiíndices no son necesarios.Esta función también restablece el iterador a su estado inicial.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">Si la &amp;uacute;ltima dimensi&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tiene un tama&amp;ntilde;o diferente.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
