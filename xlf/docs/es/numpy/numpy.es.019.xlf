<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El piso de cada elemento en &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">El piso del escalar &lt;code&gt;x&lt;/code&gt; es el entero m&amp;aacute;s grande &lt;code&gt;i&lt;/code&gt; , tal que &lt;code&gt;i &amp;lt;= x&lt;/code&gt; . A menudo se denota como</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">El fmax es equivalente a &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; cuando ni x1 ni x2 son NaN, pero es m&amp;aacute;s r&amp;aacute;pido y realiza una transmisi&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">El fmin es equivalente a &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; cuando ni x1 ni x2 son NaN, pero es m&amp;aacute;s r&amp;aacute;pido y realiza una transmisi&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="359ddc84e42e1145c1875abe172377b5b248a4ef" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;git config --global&lt;/code&gt; commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2933db06c5f57c543942f5ed02bb77ea787c4725" translate="yes" xml:space="preserve">
          <source>The following attributes are used by F2PY:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">Los siguientes atributos contienen información sobre la disposición de la memoria de la matriz:</target>
        </trans-unit>
        <trans-unit id="245831b050a7f252080c114fea4739c32457bc6e" translate="yes" xml:space="preserve">
          <source>The following code allows us to look at the call sequences and arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">La siguiente comparación no plantea una excepción.Hay NaNs en las entradas,pero están en las mismas posiciones.</target>
        </trans-unit>
        <trans-unit id="25c3aeb47ccb54f3895f28756398a03c01d886f7" translate="yes" xml:space="preserve">
          <source>The following corresponds to the usual functions except that nans are excluded from the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">Los siguientes tipos de datos son &lt;strong&gt;flexibles&lt;/strong&gt; : no tienen un tama&amp;ntilde;o predefinido y los datos que describen pueden tener diferente longitud en diferentes matrices. (En los c&amp;oacute;digos de caracteres, &lt;code&gt;#&lt;/code&gt; es un n&amp;uacute;mero entero que indica de cu&amp;aacute;ntos elementos consta el tipo de datos).</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">El siguiente ejemplo comprueba que &lt;code&gt;a * a+ * a == a&lt;/code&gt; y &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">El siguiente ejemplo demuestra que las operaciones en este tipo particular requieren Python C-API.</target>
        </trans-unit>
        <trans-unit id="bff8fe87ad1b3faab42fa78be47af40e14a3cdee" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to add user-defined variables to a F2PY generated extension module. Given the following signature file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601636ce271dc6c59652a4b9ca1697d0ffc34977" translate="yes" xml:space="preserve">
          <source>The following example shows how you might write a wrapper that accepts two input arguments (that will be converted to an array) and an output argument (that must be an array). The function returns None and updates the output array. Note the updated use of WRITEBACKIFCOPY semantics for NumPy v1.14 and above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9274fe878c5628b41be8c56553474b2bf993bdb4" translate="yes" xml:space="preserve">
          <source>The following import conventions are used throughout the NumPy source and documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a11277817c1922ff80f9328abde5fde7dba14c8" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[:, np.newaxis]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a4cf52932022adac50e43fe76bc932e82c5751" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">Lo siguiente es equivalente &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; o &lt;code&gt;x[np.newaxis]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">Lo siguiente es probablemente cierto,dado que 0,6 es aproximadamente el doble de la desviación estándar:</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">Las siguientes llaves están permitidas:</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">Las siguientes constantes matem&amp;aacute;ticas est&amp;aacute;n disponibles en &lt;code&gt;npy_math.h&lt;/code&gt; . La precisi&amp;oacute;n simple y extendida tambi&amp;eacute;n est&amp;aacute;n disponibles agregando los sufijos &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;l&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">Los siguientes métodos pueden utilizarse para acceder a la información sobre la máscara o para manipularla.</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">Los siguientes métodos implementan el protocolo de encurtido:</target>
        </trans-unit>
        <trans-unit id="ebfae704e1370f3e45632884fb2aa5f3e6615469" translate="yes" xml:space="preserve">
          <source>The following new &lt;code&gt;distutils&lt;/code&gt; commands are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">Se pueden calcular las siguientes normas:</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">Se dispone de las siguientes reglas predefinidas de repetición de nombres:</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0a5d55704a6c767182c6ac613e21ec8fe0f334" translate="yes" xml:space="preserve">
          <source>The following sections list commonly reported issues depending on your setup. If you have an issue/solution that you think should appear please open a NumPy issue so that it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ff8f470befc9ac72d0ecaaff54cadb612acf70" translate="yes" xml:space="preserve">
          <source>The following steps are repeated for the beta(s), release candidates(s) and the final release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">La forma de cada elemento de la secuencia de archivos es muy flexible,lo que permite muchas combinaciones de dónde obtener los archivos del paquete y dónde deben instalarse finalmente en el sistema.El uso más básico es que un elemento de la secuencia de argumentos de los archivos sea un simple nombre de archivo.Esto hará que ese archivo de la ruta local se instale en la ruta de instalación del paquete self.name (ruta del paquete).El argumento del archivo también puede ser una ruta relativa,en cuyo caso toda la ruta relativa se instalará en el directorio del paquete.Por último,el archivo puede ser un nombre de ruta absoluta,en cuyo caso el archivo se encontrará en el nombre de ruta absoluta pero se instalará en la ruta del paquete.</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">La sintaxis formal de las firmas es la siguiente:</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">La descripci&amp;oacute;n de formato, ya sea especificada como una cadena con descripciones de formato separadas por comas en el formato &lt;code&gt;'f8, i4, a5'&lt;/code&gt; , o una lista de cadenas de descripci&amp;oacute;n de formato en el formato &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">El formato es el requerido por la clave 'descr' en el atributo &lt;code&gt;__array_interface__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">El formato de estos tipos de archivos binarios est&amp;aacute; documentado en &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">La FFT bidimensional hacia adelante, de la cual &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; es la inversa.</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">La FFT directa &lt;em&gt;n-&lt;/em&gt; dimensional, de la cual &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; es la inversa.</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">La FFT directa n-dimensional de la entrada real, de la cual &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; es la inversa.</target>
        </trans-unit>
        <trans-unit id="86b261d0d21cfe3b6b89e72eae8348c6f9559d44" translate="yes" xml:space="preserve">
          <source>The foundations of Project governance are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">Las cuatro distribuciones centrales ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; ) permiten que las matrices existentes se llenen utilizando el argumento de palabra clave &lt;code&gt;out&lt;/code&gt; . Las matrices existentes deben ser contiguas y de buen comportamiento (escribibles y alineadas). En circunstancias normales, las matrices creadas con los constructores comunes como &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt; satisfar&amp;aacute;n estos requisitos.</target>
        </trans-unit>
        <trans-unit id="4e18095a7950042b568262a2f1c7ea1be5258e8f" translate="yes" xml:space="preserve">
          <source>The four values listed above correspond to the number of columns in your array. With a four-column array, you will get four values as your result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">El derivado de cuarto orden de un polinomio de tercer orden es cero:</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">Las partes fraccionarias e integrales son negativas si el número dado es negativo.</target>
        </trans-unit>
        <trans-unit id="8a03fbb591756592459d393e8bbc5d2c3b77111d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; can always be used to reproduce the old behavior, as it will return a packed copy of the structured array. The code above, for example, can be replaced with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a275d8e4e1eb223479714f496979856366e2451a" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt; instanciar&amp;aacute; un &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; con BitGenerator predeterminado de &lt;code&gt;BitGenerator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8219757277659dda8af10246595348c539cf3e" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt;&lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi-&amp;gt;iters[i]-&amp;gt;strides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aca3baefb770d49123ec449717dbfcad5a619a9" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt;&lt;code&gt;column_stack&lt;/code&gt;&lt;/a&gt; stacks 1D arrays as columns into a 2D array. It is equivalent to &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; only for 2D arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; le&lt;/a&gt; permite aplicar compensaciones especificadas en d&amp;iacute;as h&amp;aacute;biles a la fecha y hora con una unidad de 'D' (d&amp;iacute;a).</target>
        </trans-unit>
        <trans-unit id="b326cd579834eae17571b08e2103d37d7f1ef376" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;gun&lt;/code&gt; may return any number of objects as a tuple. Then following rules are applied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e4e84916821d7380bf310d4fe3bd37497cc290" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;zeros&lt;/code&gt; creates an array full of zeros, the function &lt;code&gt;ones&lt;/code&gt; creates an array full of ones, and the function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">La funci&amp;oacute;n asume que el n&amp;uacute;mero de dimensiones de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son los mismos, si es necesario anteponer el m&amp;aacute;s peque&amp;ntilde;o con unos. Si &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; y &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; , el producto de Kronecker tiene forma &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; . Los elementos son los productos de elementos de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , organizados de manera expl&amp;iacute;cita por:</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">La función tiene una media de</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">La función tiene su pico (el modo)en</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">La funci&amp;oacute;n tiene su pico en la media y su &quot;extensi&amp;oacute;n&quot; aumenta con la desviaci&amp;oacute;n est&amp;aacute;ndar (la funci&amp;oacute;n alcanza 0,607 veces su m&amp;aacute;ximo en</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">La función tiene ceros donde el ángulo es un múltiplo de</target>
        </trans-unit>
        <trans-unit id="8224b60c460c6d30ff461ee22df630041e59b82c" translate="yes" xml:space="preserve">
          <source>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if &lt;code&gt;./mylib.so&lt;/code&gt; has a function named &lt;code&gt;cool_function1&lt;/code&gt;, I could access this function either as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">La funci&amp;oacute;n tambi&amp;eacute;n es &amp;uacute;til para calcular algunos tipos de d&amp;iacute;as como vacaciones. En Canad&amp;aacute; y EE. UU., El d&amp;iacute;a de la madre es el segundo domingo de mayo, que se puede calcular con una m&amp;aacute;scara de semana personalizada.</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">La función se aplica tanto a los _datos como a la _máscara,si la hay.</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">La funci&amp;oacute;n se llama con N par&amp;aacute;metros, donde N es el rango de la &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . Cada par&amp;aacute;metro representa las coordenadas de la matriz que var&amp;iacute;an a lo largo de un eje espec&amp;iacute;fico. Por ejemplo, si la &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; fuera &lt;code&gt;(2, 2)&lt;/code&gt; , los par&amp;aacute;metros ser&amp;iacute;an &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; y &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3d30cf3098994de825e7f6bde3ab7173788815" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">La funci&amp;oacute;n se llama con N par&amp;aacute;metros, donde N es el rango de la &lt;code&gt;shape&lt;/code&gt; . Cada par&amp;aacute;metro representa las coordenadas de la matriz que var&amp;iacute;an a lo largo de un eje espec&amp;iacute;fico. Por ejemplo, si la &lt;code&gt;shape&lt;/code&gt; fuera &lt;code&gt;(2, 2)&lt;/code&gt; , los par&amp;aacute;metros ser&amp;iacute;an &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; y &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5020746e9a28c81bea9ebded1052af0dc8ae2dc6" translate="yes" xml:space="preserve">
          <source>The function is included as an argument to the python function call to the Fortran subroutine even though it was &lt;em&gt;not&lt;/em&gt; in the Fortran subroutine argument list. The &amp;ldquo;external&amp;rdquo; refers to the C function generated by f2py, not the python function itself. The python function must be supplied to the C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">El tipo de puntero de función para las funciones de clonación de NpyAuxData.Estas funciones nunca deben establecer la excepción de Python en error,porque pueden ser llamadas desde un contexto multi-hilo.</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">El tipo de puntero de la función para las funciones libres de NpyAuxData.</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">La función devuelve los coeficientes del polinomio</target>
        </trans-unit>
        <trans-unit id="56ed9dbe32b58078e6c4979647428ecdfd02c355" translate="yes" xml:space="preserve">
          <source>The function signature is normally found by introspection and displayed by the help function. For some functions (notably those written in C) the signature is not available, so we have to specify it as the first line of the docstring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">La función que se llama cuando se omiten x e y</target>
        </trans-unit>
        <trans-unit id="292f9d908dc66f70e34640d48dac32f92d8211ec" translate="yes" xml:space="preserve">
          <source>The function to be approximated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68506a39d4f1164408a473e0014c02732a65744" translate="yes" xml:space="preserve">
          <source>The function to be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">La funci&amp;oacute;n que se va a interpolar. Debe ser una funci&amp;oacute;n de una sola variable de la forma &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; , donde &lt;code&gt;a, b, c...&lt;/code&gt; son argumentos adicionales pasados ​​en el par&amp;aacute;metro &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La funcionalidad se basa en &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">La funcionalidad que esto proporciona es reemplazada en gran medida por el iterador &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; introducido en 1.6, con el indicador &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; o con el mismo par&amp;aacute;metro dtype para todos los operandos.</target>
        </trans-unit>
        <trans-unit id="a07514d8b8d140f4e03babf46c4ca643c0f5e565" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superseded by iterator &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2962953aa600a37ce10b761bfc967d43ddef0e3d" translate="yes" xml:space="preserve">
          <source>The functions are named with the following conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las funciones llamadas para implementar muchos m&amp;eacute;todos aritm&amp;eacute;ticos especiales para matrices se pueden modificar usando &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8d64b72fb018cdee0e3f01b29eae167f558f81" translate="yes" xml:space="preserve">
          <source>The functions in the shared library are available as attributes of the ctypes library object (returned from &lt;code&gt;ctypeslib.load_library&lt;/code&gt;) or as items using &lt;code&gt;lib['func_name']&lt;/code&gt; syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df46d6188871c9afe4dd8663a289bd38fe7112b3" translate="yes" xml:space="preserve">
          <source>The functions without &amp;ldquo;standard&amp;rdquo; in their name require additional parameters to describe the distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">El valor futuro se calcula resolviendo la ecuación:</target>
        </trans-unit>
        <trans-unit id="35263bdc6b8f9ed76c3ffddda6ddc106a35e30ef" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">Las ganancias son sustanciales y la escala es razonable incluso para los grandes que son sólo moderadamente grandes.Las ganancias son aún mayores cuando se comparan con una llamada que no utiliza un arreglo existente debido a la sobrecarga de la creación de arreglos.</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">El concepto general de transmisi&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; disponible en Python mediante el iterador de &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; . Este objeto toma</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">El archivo generado tendrá el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">Las muestras aleatorias generadas</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">Los objetos de tipo jerárquico genérico se convierten en objetos de tipo correspondiente según las asociaciones:</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">El decorador dado se aplica a todos los m&amp;eacute;todos p&amp;uacute;blicos de &lt;code&gt;cls&lt;/code&gt; que coinciden con la expresi&amp;oacute;n regular &lt;code&gt;testmatch&lt;/code&gt; ( &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ). Los m&amp;eacute;todos que son privados, es decir, que comienzan con un gui&amp;oacute;n bajo, se ignoran.</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">El gradiente se calcula utilizando diferencias centrales precisas de segundo orden en los puntos interiores y diferencias de un lado (hacia delante o hacia atrás)precisas de primer o segundo orden en los límites.El gradiente devuelto tiene por lo tanto la misma forma que la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">El mayor divisor común</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El m&amp;aacute;ximo com&amp;uacute;n divisor del valor absoluto de las entradas Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">El archivo de encabezado &amp;lt;numpy / halffloat.h&amp;gt; proporciona funciones para trabajar con valores de coma flotante de 16 bits IEEE 754-2008. Si bien este formato no se usa normalmente para c&amp;aacute;lculos num&amp;eacute;ricos, es &amp;uacute;til para almacenar valores que requieren un punto flotante pero que no necesitan mucha precisi&amp;oacute;n. Tambi&amp;eacute;n se puede utilizar como una herramienta educativa para comprender la naturaleza del error de redondeo de punto flotante.</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">El encabezado de un &lt;code&gt;__init__.py&lt;/code&gt; t&amp;iacute;pico de SciPy es:</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">El tipo de datos de mayor precisi&amp;oacute;n del mismo tipo ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ) que &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">El coseno hiperbólico describe la forma de un cable colgante:</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">La hipotenusa de los tri&amp;aacute;ngulos. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="b1216f6dc1a8f133c88cabe04669f3d387166a72" translate="yes" xml:space="preserve">
          <source>The idea is to consider all but the first &lt;code&gt;k&lt;/code&gt; singular values in &lt;code&gt;Sigma&lt;/code&gt; (which are the same as in &lt;code&gt;s&lt;/code&gt;) as zeros, keeping &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; intact, and computing the product of these matrices as the approximation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">La matriz de identidades es una matriz cuadrada con unas en la diagonal principal.</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">El valor de la identidad.</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">El componente imaginario del argumento complejo. Si &lt;code&gt;val&lt;/code&gt; es real, se usa el tipo de &lt;code&gt;val&lt;/code&gt; para la salida. Si &lt;code&gt;val&lt;/code&gt; tiene elementos complejos, el tipo devuelto es float.</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">La parte imaginaria de la matriz.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">La parte imaginaria del conjunto de máscaras.</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">La realización de las pruebas que producen esta información.</target>
        </trans-unit>
        <trans-unit id="aee088812e30b5da0a5df1b95d7c39c9c1258247" translate="yes" xml:space="preserve">
          <source>The implementations of multiplication, division, integration, and differentiation use the algebraic identities &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">La importancia que tiene cada elemento en el c&amp;aacute;lculo del promedio. La matriz de pesos puede ser 1-D (en cuyo caso su longitud debe ser del tama&amp;ntilde;o de &lt;code&gt;a&lt;/code&gt; lo largo del eje dado) o de la misma forma que &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;weights=None&lt;/code&gt; , a continuaci&amp;oacute;n, todos los datos en &lt;code&gt;a&lt;/code&gt; se supone que tienen un peso igual a uno. Si los &lt;code&gt;weights&lt;/code&gt; son complejos, se ignoran las partes imaginarias.</target>
        </trans-unit>
        <trans-unit id="8b1442547658f9bd4727b8dd9df733953ec22b3e" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3bacce4854001ee5a2b2337e74219eceafb03" translate="yes" xml:space="preserve">
          <source>The include statement is inserted just before the wrapper functions. This feature enables using arbitrary C functions (defined in &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt;) in F2PY generated wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">Los BitGenerators incluidos son:</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">Los generadores incluidos pueden utilizarse en aplicaciones paralelas y distribuidas de una de las tres maneras:</target>
        </trans-unit>
        <trans-unit id="0d9680eef1c6da704d4a94f1afb86f59c497487e" translate="yes" xml:space="preserve">
          <source>The index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31840bf8111dd67b394647308aa4678f4427cf3" translate="yes" xml:space="preserve">
          <source>The index is tracked by the iterator object itself, and accessible through the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; properties, depending on what was requested. The examples below show printouts demonstrating the progression of the index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00c25ebce056fd05b5bde5e2e04470c497a8460" translate="yes" xml:space="preserve">
          <source>The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">El resultado indexado.</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">La indexaci&amp;oacute;n funciona en la matriz de destino aplanada. &lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; es aproximadamente equivalente a:</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">Los índices pueden ser utilizados como un índice en una matriz.</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">Los índices del triángulo.La tupla devuelta contiene dos matrices,cada una con los índices a lo largo de una dimensión de la matriz.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">Los &amp;iacute;ndices del tri&amp;aacute;ngulo. La tupla devuelta contiene dos matrices, cada una con los &amp;iacute;ndices a lo largo de una dimensi&amp;oacute;n de la matriz. Puede usarse para cortar un ndarray de forma ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">Los índices del primer y último valor no enmascarado del conjunto.Devuelve ninguno si todos los valores están enmascarados.</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">Los índices de la iteración actual.</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">Los &amp;iacute;ndices de las primeras apariciones de los valores comunes en &lt;code&gt;ar1&lt;/code&gt; . Solo se proporciona si &lt;code&gt;return_indices&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">Los &amp;iacute;ndices de las primeras apariciones de los valores comunes en &lt;code&gt;ar2&lt;/code&gt; . Solo se proporciona si &lt;code&gt;return_indices&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">Los &amp;iacute;ndices de las primeras apariciones de los valores &amp;uacute;nicos en la matriz original. Solo se proporciona si &lt;code&gt;return_index&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Los &amp;iacute;ndices de los valores emparejados se pueden obtener con un valor &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">Los índices de los valores a extraer.</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">Los &amp;iacute;ndices para reconstruir la matriz original a partir de la matriz &amp;uacute;nica. Solo se proporciona si &lt;code&gt;return_inverse&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">Los índices serán válidos para matrices cuadradas cuyas dimensiones son las mismas que las de la matriz.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">Los índices serán válidos para las matrices cuadradas.</target>
        </trans-unit>
        <trans-unit id="2408a7bae27e18b5f16ce6bfc6c2e9edbdf96e75" translate="yes" xml:space="preserve">
          <source>The info dict contains the necessary options to use the C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a162a1581bd9df0f0c132b54dd0bc2b023b7fbc" translate="yes" xml:space="preserve">
          <source>The initialized generator object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">La entrada &lt;code&gt;a&lt;/code&gt; como un ndarray flotante.</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">La entrada &lt;code&gt;a&lt;/code&gt; en orden Fortran, o columna mayor.</target>
        </trans-unit>
        <trans-unit id="75fd22e41868bea41cd02857931f82382a569f45" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;seed&lt;/code&gt; is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the key. The counter is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">La matriz de entrada</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">La matriz de entrada debe ser de tipo entero d,de lo contrario se eleva un TypeError:</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">La matriz de entrada con entradas inválidas arregladas.</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">Esta funci&amp;oacute;n modifica la m&amp;aacute;scara de la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">La matriz de entrada, pero con todas o un subconjunto de las dimensiones de longitud 1 eliminadas. Esto siempre es &lt;code&gt;a&lt;/code&gt; s&amp;iacute; mismo o una vista de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c1757f1f00139c3d32d32875dc4cdee7e7573b" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;. Note that if all axes are squeezed, the result is a 0d array and not a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">La matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">Las matrices de entrada son los coeficientes (incluidos los coeficientes iguales a cero) de los polinomios &quot;numerador&quot; (dividendo) y &quot;denominador&quot; (divisor), respectivamente.</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">La entrada puede ser de cualquier tipo y forma.</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">El tipo de datos de entrada se conserva,lista/doble in significa lista/doble out.</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de datos de entrada. Puede ser un objeto &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; o un objeto convertible a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">El dominio de entrada.</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">Se espera que la entrada est&amp;eacute; en la forma devuelta por &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; , es decir, el t&amp;eacute;rmino de frecuencia cero real seguido por los t&amp;eacute;rminos de frecuencia positiva compleja en orden de frecuencia creciente. Dado que la transformada discreta de Fourier de la entrada real es sim&amp;eacute;trica de Hermitian, los t&amp;eacute;rminos de frecuencia negativa se toman como conjugados complejos de los t&amp;eacute;rminos de frecuencia positivos correspondientes.</target>
        </trans-unit>
        <trans-unit id="6f9750084d20ac908a43842756c2b861e3f42c50" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8974905180f39b4ffd2915ed945588ac5ab3b98" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate both values. The increment is not independently settable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7b1d5b6198e399c073a141f7cd1b6b8febb604" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; procesa la semilla de entrada para llenar todo el estado. El primer elemento se restablece de manera que solo se establece su bit m&amp;aacute;s significativo.</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; procesa la semilla de entrada para generar ambos valores. El incremento no se puede configurar de forma independiente.</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; procesa la semilla de entrada para generar los primeros 3 valores, luego el algoritmo &lt;code&gt;SFC64&lt;/code&gt; se itera una peque&amp;ntilde;a cantidad de veces para mezclar.</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; procesa la semilla de entrada para generar la clave. El contador se pone a 0.</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">La entrada debe ordenarse de la misma manera que la devuelve &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , es decir,</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">La entrada debe ordenarse de la misma manera que &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; , es decir, &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; para el eje de transformaci&amp;oacute;n final, y &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; a lo&lt;/a&gt; largo de todos los dem&amp;aacute;s ejes.</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">El valor o valores de entrada.</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">La entrada, de manera an&amp;aacute;loga a &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; , debe ordenarse de la misma manera que la devuelve &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt; , es decir, debe tener el t&amp;eacute;rmino para frecuencia cero en la esquina de orden inferior de los dos ejes, los t&amp;eacute;rminos de frecuencia positiva en la primera mitad de estos. ejes, el t&amp;eacute;rmino para la frecuencia de Nyquist en el medio de los ejes y los t&amp;eacute;rminos de frecuencia negativa en la segunda mitad de ambos ejes, en orden decreciente de frecuencia negativa.</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">La entrada, de manera an&amp;aacute;loga a &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; , debe ordenarse de la misma manera que la devuelve &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , es decir, debe tener el t&amp;eacute;rmino para frecuencia cero en todos los ejes en la esquina de orden inferior, los t&amp;eacute;rminos de frecuencia positiva en la primera mitad de todos los ejes , el t&amp;eacute;rmino para la frecuencia de Nyquist en el medio de todos los ejes y los t&amp;eacute;rminos de frecuencia negativa en la segunda mitad de todos los ejes, en orden decreciente de frecuencia negativa.</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">Las constantes de integración están predeterminadas a cero,pero se pueden especificar:</target>
        </trans-unit>
        <trans-unit id="b8cfb0f4ba349fe08f791a3f4e9c32e0be770fb0" translate="yes" xml:space="preserve">
          <source>The intent directive, intent(out) is used to tell f2py that &lt;code&gt;c&lt;/code&gt; is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, &lt;code&gt;n&lt;/code&gt;, but instead to get it from the size of &lt;code&gt;a&lt;/code&gt;. The depend( &lt;code&gt;a&lt;/code&gt; ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&amp;rsquo;t try to create the variable n until the variable a is created).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef0aef07474fa13f32cd7e44f96fd84d9e33ac9" translate="yes" xml:space="preserve">
          <source>The interface definition file (.pyf) is how you can fine-tune the interface between Python and Fortran. There is decent documentation for f2py found in the numpy/f2py/docs directory where-ever NumPy is installed on your system (usually under site-packages). There is also more information on using f2py (including how to use it to wrap C codes) at &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; under the &amp;ldquo;Interfacing With Other Languages&amp;rdquo; heading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Los valores interpolados, la misma forma que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">El &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; inverso tambi&amp;eacute;n se conoce como &lt;code&gt;acos&lt;/code&gt; o cos ^ -1.</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">El DFT inverso se define como</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">La distribución Gaussiana inversa se estudió primero en relación con el movimiento Browniano.En 1956 M.C.K.Tweedie utilizó el nombre de Gaussiano inverso porque hay una relación inversa entre el tiempo para cubrir una distancia unitaria y la distancia cubierta en tiempo unitario.</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">La función inversa.</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">El seno hiperb&amp;oacute;lico inverso tambi&amp;eacute;n se conoce como &lt;code&gt;asinh&lt;/code&gt; o &lt;code&gt;sinh^-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">La tangente hiperb&amp;oacute;lica inversa tambi&amp;eacute;n se conoce como &lt;code&gt;atanh&lt;/code&gt; o &lt;code&gt;tanh^-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , la FFT inversa &lt;em&gt;n-&lt;/em&gt; dimensional.</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">La inversa de &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; , es decir, la inversa de la FFT n-dimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; de&lt;/a&gt; modo que, si &lt;code&gt;y = cos(x)&lt;/code&gt; , entonces &lt;code&gt;x = arccos(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La inversa de &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; . Aunque id&amp;eacute;nticas para &lt;code&gt;x&lt;/code&gt; de longitud par , las funciones difieren en una muestra para &lt;code&gt;x&lt;/code&gt; de longitud impar .</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">La inversa de tan, de modo que si &lt;code&gt;y = tan(x)&lt;/code&gt; entonces &lt;code&gt;x = arctan(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">La inversa de la FFT &lt;em&gt;n-&lt;/em&gt; dimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">La inversa de la FFT &lt;em&gt;n-&lt;/em&gt; dimensional.</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">El inverso de la FFT unidimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">El inverso de la FFT bidimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">La operación inversa,agregando dimensiones de un solo tonelaje</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">La operación inversa,eliminando las dimensiones de un solo tonelaje</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">El seno inverso tambi&amp;eacute;n se conoce como &lt;code&gt;asin&lt;/code&gt; o sin ^ {- 1}.</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El seno inverso de cada elemento en &lt;code&gt;x&lt;/code&gt; , en radianes y en el intervalo cerrado &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">La tangente inversa tambi&amp;eacute;n se conoce como &lt;code&gt;atan&lt;/code&gt; o tan ^ {- 1}.</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">El FFT bidimensional inverso.</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">El n&amp;uacute;mero irracional &lt;code&gt;e&lt;/code&gt; tambi&amp;eacute;n se conoce como n&amp;uacute;mero de Euler. Es aproximadamente 2.718281, y es la base del logaritmo natural, &lt;code&gt;ln&lt;/code&gt; (esto significa que, si</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">El indicador de iterador &quot;delay_bufalloc&quot; est&amp;aacute; ah&amp;iacute; para permitir que los operandos de reducci&amp;oacute;n asignados al iterador existan junto con el almacenamiento en b&amp;uacute;fer. Cuando se establece esta bandera, el iterador dejar&amp;aacute; sus b&amp;uacute;feres sin inicializar hasta que reciba un reinicio, despu&amp;eacute;s de lo cual estar&amp;aacute; listo para la iteraci&amp;oacute;n regular. As&amp;iacute; es como se ve el ejemplo anterior si tambi&amp;eacute;n habilitamos el almacenamiento en b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">El iterador contiene una referencia al iter</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">El diseño del iterador es un detalle interno,y el código de usuario sólo ve una estructura incompleta.</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">El objeto iterador &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; , introducido en NumPy 1.6, proporciona muchas formas flexibles de visitar todos los elementos de una o m&amp;aacute;s matrices de forma sistem&amp;aacute;tica. Esta p&amp;aacute;gina presenta algunas formas b&amp;aacute;sicas de usar el objeto para c&amp;aacute;lculos en matrices en Python, luego concluye con c&amp;oacute;mo se puede acelerar el ciclo interno en Cython. Dado que la exposici&amp;oacute;n Python de &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; es un mapeo relativamente sencillo de la API del iterador de matriz C, estas ideas tambi&amp;eacute;n ayudar&amp;aacute;n a trabajar con la iteraci&amp;oacute;n de matriz desde C o C ++.</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">El iterador usa las reglas de conversi&amp;oacute;n de NumPy para determinar si se permite una conversi&amp;oacute;n espec&amp;iacute;fica. De forma predeterminada, impone la conversi&amp;oacute;n &quot;segura&quot;. Esto significa, por ejemplo, que generar&amp;aacute; una excepci&amp;oacute;n si intenta tratar una matriz flotante de 64 bits como una matriz flotante de 32 bits. En muchos casos, la regla 'same_kind' es la regla m&amp;aacute;s razonable de usar, ya que permitir&amp;aacute; la conversi&amp;oacute;n de float de 64 a 32 bits, pero no de float a int o de complex a float.</target>
        </trans-unit>
        <trans-unit id="cacf8c06cd15c0c88c5430d945ba0f2cf7ba5182" translate="yes" xml:space="preserve">
          <source>The ix_() function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">El tamaño del salto es</target>
        </trans-unit>
        <trans-unit id="ce335f317c6680914a491bd8a7fe70c41740c803" translate="yes" xml:space="preserve">
          <source>The jump step is computed using a modified version of Matsumoto&amp;rsquo;s implementation of Horner&amp;rsquo;s method. The step polynomial is precomputed to perform 2**128 steps. The jumped state has been verified to match the state produced using Matsumoto&amp;rsquo;s original code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342e9169764fb77c1b214a706155105da1218b49" translate="yes" xml:space="preserve">
          <source>The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the &lt;code&gt;key&lt;/code&gt; field cannot be found in the two input arrays. Neither &lt;code&gt;r1&lt;/code&gt; nor &lt;code&gt;r2&lt;/code&gt; should have any duplicates along &lt;code&gt;key&lt;/code&gt;: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">Las llaves son:</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">El tipo de datos enteros sobre los que obtener información.</target>
        </trans-unit>
        <trans-unit id="41c3ca93d5f02dccd969da26a833b72af9110c68" translate="yes" xml:space="preserve">
          <source>The kwds argument holds a Python dictionary whose keys are the names of the keyword arguments and whose values are the corresponding keyword-argument values. This dictionary can be processed however you see fit. The easiest way to handle it, however, is to replace the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses&amp;hellip;) function with a call to &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt;&lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt;&lt;/a&gt; (args, kwds, format_string, char *kwlist[], addresses&amp;hellip;). The kwlist parameter to this function is a &lt;code&gt;NULL&lt;/code&gt; -terminated array of strings providing the expected keyword arguments. There should be one string for each entry in the format_string. Using this function will raise a TypeError if invalid keyword arguments are passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">El objeto más grande para comparar.</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">El mayor número representativo.</target>
        </trans-unit>
        <trans-unit id="8c04ea0c745fb65e3a5c6b4d6a06693d11870a3e" translate="yes" xml:space="preserve">
          <source>The last dimension of the input array is converted into a structure, with number of field-elements equal to the size of the last dimension of the input array. By default all output fields have the input array&amp;rsquo;s dtype, but an output structured dtype with an equal number of fields-elements can be supplied instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">El último es un caso de congelación de una dimensión central y puede ser utilizado para mejorar el rendimiento de la UFU.</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">El &amp;uacute;ltimo dando solo los primeros elementos debido a la dimensi&amp;oacute;n extra. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; para comprender este ejemplo.</target>
        </trans-unit>
        <trans-unit id="d08df5e86170609b57051ef10f9fb3e1c3868c9f" translate="yes" xml:space="preserve">
          <source>The last thing that must be done to finish the extension module is to actually write the code that performs the desired functions. There are two kinds of functions: those that don&amp;rsquo;t accept keyword arguments, and those that do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e8d86c6819b2227ff0ab7cafe1755645c6727d" translate="yes" xml:space="preserve">
          <source>The last two are characteristics of ndarrays - in order to support things like array slicing. The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">El &amp;uacute;ltimo grupo de &lt;code&gt;{NAME}s&lt;/code&gt; corresponde a las letras utilizadas en la especificaci&amp;oacute;n de la cadena de tipos de la interfaz de matriz.</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">Los bordes m&amp;aacute;s a la izquierda y m&amp;aacute;s a la derecha de los bins a lo largo de cada dimensi&amp;oacute;n (si no se especifica expl&amp;iacute;citamente en los par&amp;aacute;metros de &lt;code&gt;bins&lt;/code&gt; ): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; . Todos los valores fuera de este rango se considerar&amp;aacute;n valores at&amp;iacute;picos y no se contabilizar&amp;aacute;n en el histograma.</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">La longitud de &lt;code&gt;condlist&lt;/code&gt; debe corresponder a la de &lt;code&gt;funclist&lt;/code&gt; . Si se proporciona una funci&amp;oacute;n adicional, es decir, si &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; , entonces esa funci&amp;oacute;n adicional es el valor predeterminado, utilizado siempre que todas las condiciones sean falsas.</target>
        </trans-unit>
        <trans-unit id="fda9f4dafa3b1f4f0bc8667197c7c2f74ba12e70" translate="yes" xml:space="preserve">
          <source>The length of docstring lines should be kept to 75 characters to facilitate reading the docstrings in text terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">La longitud de la lista de n&amp;uacute;meros enteros. Se supone que es seguro acceder a &lt;em&gt;ptr&lt;/em&gt; [0] a &lt;em&gt;ptr&lt;/em&gt; [len-1].</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">La longitud de las cadenas de prefijos y sufijos se utilizan para alinear y envolver la salida respectivamente.Una matriz se imprime típicamente como:</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">La longitud de las cuerdas resultantes</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">La longitud de la cadena devuelta si &lt;code&gt;num&lt;/code&gt; es positivo, o la longitud del complemento a dos si &lt;code&gt;num&lt;/code&gt; es negativo, siempre que el &lt;code&gt;width&lt;/code&gt; sea ​​al menos un n&amp;uacute;mero suficiente de bits para que &lt;code&gt;num&lt;/code&gt; se represente en la forma designada.</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">La longitud del segmento en bytes.</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">La longitud del intervalo es el intervalo de un entero de 64 bits multiplicado por la longitud de la fecha o unidad. Por ejemplo, el lapso de tiempo para 'W' (semana) es exactamente 7 veces m&amp;aacute;s largo que el lapso de tiempo para 'D' (d&amp;iacute;a), y el lapso de tiempo para 'D' (d&amp;iacute;a) es exactamente 24 veces m&amp;aacute;s largo que el lapso de tiempo para 'h' (hora).</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">La línea de arriba representa z**3+0*z**2+0*z+0.</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">La línea de arriba representa z**3-z/4</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;offset + scale*x&lt;/code&gt; mapa lineal + escala * x que asigna el dominio &lt;code&gt;old&lt;/code&gt; al dominio &lt;code&gt;new&lt;/code&gt; se aplica a los puntos &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2428c8d989723853883bd2c4d45c041f6e455adf" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;x&lt;/code&gt; contains 4 items, each which can be accessed individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">La lista de matrices de las que se toman los elementos de salida. Tiene que tener la misma longitud que &lt;code&gt;condlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">La lista de condiciones que determinan de qu&amp;eacute; matriz de la lista de selecci&amp;oacute;n se &lt;code&gt;choicelist&lt;/code&gt; los elementos de salida. Cuando se cumplen varias condiciones, se utiliza la primera que se encuentra en &lt;code&gt;condlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a85b3c79db62cd35117edd96a90c46599648e8f3" translate="yes" xml:space="preserve">
          <source>The list of field names of a structured datatype can be found in the &lt;code&gt;names&lt;/code&gt; attribute of the dtype object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">La lista de sectores, uno para cada regi&amp;oacute;n continua de elementos enmascarados en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">La lista de sectores, uno para cada regi&amp;oacute;n continua de elementos desenmascarados en &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">La lista de fuentes puede contener funciones ('generadores de fuentes') con un patr&amp;oacute;n &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; . Si &lt;code&gt;funcname&lt;/code&gt; devuelve &lt;code&gt;None&lt;/code&gt; , no se generan fuentes. Y si la instancia de &lt;code&gt;Extension&lt;/code&gt; no tiene fuentes despu&amp;eacute;s de procesar todos los generadores de fuentes, no se construir&amp;aacute; ning&amp;uacute;n m&amp;oacute;dulo de extensi&amp;oacute;n. &amp;Eacute;sta es la forma recomendada de definir condicionalmente m&amp;oacute;dulos de extensi&amp;oacute;n. Funciones del generador de c&amp;oacute;digo son llamados por el &lt;code&gt;build_src&lt;/code&gt; mando de &lt;code&gt;numpy.distutils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70ba9a25afcb1723906c4b12dfd6f0a126515e6c" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; sub-command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">La ubicación del modo de distribución.El valor por defecto es 0.</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">La distribución de las series de troncos se utiliza con frecuencia para representar la riqueza y la ocurrencia de las especies,propuesta por primera vez por Fisher,Corbet y Williams en 1943 [2].También se puede utilizar para modelar el número de ocupantes que se ven en los coches [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El logaritmo en base 10 de &lt;code&gt;x&lt;/code&gt; , por elementos. Se devuelven NaN donde x es negativo. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="4d6739be6bf6c7545bc1a71d692001820b9d7cac" translate="yes" xml:space="preserve">
          <source>The logic behind those functions in more than two dimensions can be strange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">El rango inferior y superior de los contenedores. Si no se proporciona, el rango es simplemente &lt;code&gt;(a.min(), a.max())&lt;/code&gt; . Los valores fuera del rango se ignoran. El primer elemento del rango debe ser menor o igual que el segundo. &lt;code&gt;range&lt;/code&gt; afecta el c&amp;aacute;lculo autom&amp;aacute;tico de la ubicaci&amp;oacute;n. Si bien el ancho del contenedor se calcula para que sea &amp;oacute;ptimo en funci&amp;oacute;n de los datos reales dentro del &lt;code&gt;range&lt;/code&gt; , el recuento de contenedores llenar&amp;aacute; todo el rango, incluidas las porciones que no contienen datos.</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">El límite inferior para el 1% superior de las muestras es..:</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">El límite inferior de la integral definida.</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">El límite inferior de la integral.(Por defecto:0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">El mínimo común múltiplo</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El m&amp;iacute;nimo com&amp;uacute;n m&amp;uacute;ltiplo del valor absoluto de las entradas Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">La caracter&amp;iacute;stica principal del m&amp;oacute;dulo &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; es la clase &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , que es una subclase de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; . La clase, sus atributos y m&amp;eacute;todos se describen con m&amp;aacute;s detalle en la secci&amp;oacute;n de la &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;clase MaskedArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52a36a5301780b2d55c316deba861004a7e6a2e2" translate="yes" xml:space="preserve">
          <source>The main page for the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy Documentation&lt;/a&gt; lists several categories. The documents mentioned there live in different places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a467f7e54add76d93e3f038ba1d5a3c08c31d6" translate="yes" xml:space="preserve">
          <source>The main routine for obtaining an array from any Python object that can be converted to an array is &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This function is very flexible with many input arguments. Several macros make it easier to use the basic function. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; is arguably the most useful of these macros for the most common uses. It allows you to convert an arbitrary Python object to an array of a specific builtin data-type ( &lt;em&gt;e.g.&lt;/em&gt; float), while specifying a particular set of requirements ( &lt;em&gt;e.g.&lt;/em&gt; contiguous, aligned, and writeable). The syntax is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6437cd8dced244085d75f5d4ec1f2af95ca5d9" translate="yes" xml:space="preserve">
          <source>The main way to control how the sequences of strings we have read from the file are converted to other types is to set the &lt;code&gt;dtype&lt;/code&gt; argument. Acceptable values for this argument are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">Las mantisas &lt;code&gt;x1&lt;/code&gt; y dos exponentes &lt;code&gt;x2&lt;/code&gt; se utilizan para construir n&amp;uacute;meros de coma flotante &lt;code&gt;x1 * 2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">El mapa &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; asigna el primer dominio al segundo.</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de mapeo est&amp;aacute; definida por &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&amp;iexcl;La m&amp;aacute;scara se pierde si &lt;code&gt;out&lt;/code&gt; es un &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; v&amp;aacute;lido !</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">&amp;iexcl;La m&amp;aacute;scara se pierde si &lt;code&gt;out&lt;/code&gt; es un MaskedArray v&amp;aacute;lido!</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">Se puede acceder a la m&amp;aacute;scara de una matriz enmascarada a trav&amp;eacute;s de su atributo de &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; . Debemos tener en cuenta que una entrada &lt;code&gt;True&lt;/code&gt; en la m&amp;aacute;scara indica un dato &lt;em&gt;no v&amp;aacute;lido&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5f7d748f7e23f2629a7257e1d7501357c2ce872d" translate="yes" xml:space="preserve">
          <source>The mask of a masked array view is also a view rather than a copy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">Las matrices enmascaradas con las que comparar los valores de relleno.</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">La funci&amp;oacute;n matmul implementa la sem&amp;aacute;ntica del operador &lt;code&gt;@&lt;/code&gt; introducido en Python 3.5 despu&amp;eacute;s de PEP465.</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">La clase de matriz es una subclase de Python de ndarray y se puede utilizar como referencia sobre c&amp;oacute;mo construir su propia subclase de ndarray. Las matrices se pueden crear a partir de otras matrices, cadenas y cualquier otra cosa que se pueda convertir en un &lt;code&gt;ndarray&lt;/code&gt; . El nombre &quot;mat&quot; es un alias de &quot;matriz&quot; en NumPy.</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">La matriz de valores aleatorios con forma dada por &lt;code&gt;*args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">El producto de la matriz de las entradas.Es un escalar sólo cuando ambos x1,x2 son vectores 1-d.</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">La matriz cuyo número de condición se busca.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">La matriz,pero como una matriz (1,N)si tuviera forma (N,1).</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">El m&amp;aacute;ximo es equivalente a &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; cuando ni x1 ni x2 son nans, pero es m&amp;aacute;s r&amp;aacute;pido y tiene una transmisi&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="b9ec29a01437d2db772a9e55518ff6e61467f369" translate="yes" xml:space="preserve">
          <source>The maximum number of array arguments that can be used in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">El máximo número de dimensiones permitidas en los conjuntos.</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">El número máximo de filas a leer.No debe ser usado con skip_footer al mismo tiempo.Si se da,el valor debe ser al menos 1.Por defecto es leer todo el archivo.</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">El número máximo de unidades en el último lugar de la tolerancia (véase Notas).El valor por defecto es 1.</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de unidades en el &amp;uacute;ltimo lugar que los elementos de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; puede ser diferente. El valor predeterminado es 1.</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El m&amp;aacute;ximo de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; , por elementos. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">El valor máximo a lo largo de un eje determinado.</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">El valor máximo de un arreglo a lo largo de un eje dado,ignora el NaNs.</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">El valor máximo de un arreglo a lo largo de un eje dado,ignorando cualquier NaNs.</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">El valor máximo de un conjunto a lo largo de un eje determinado,propaga el NaNs.</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">El valor máximo de un conjunto a lo largo de un eje dado,propagando cualquier NaNs.</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">El valor m&amp;aacute;ximo de un elemento de salida. Debe estar presente para permitir el c&amp;aacute;lculo en un segmento vac&amp;iacute;o. Consulte &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">La media es una coordenada en el espacio de dimensión N,que representa el lugar donde es más probable que se generen las muestras.Esto es análogo al pico de la curva de campana para la distribución normal unidimensional o univariante.</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">La media se calcula normalmente como &lt;code&gt;x.sum() / N&lt;/code&gt; , donde &lt;code&gt;N = len(x)&lt;/code&gt; . Sin embargo, &lt;code&gt;ddof&lt;/code&gt; se especifica ddof , en su lugar se utiliza el divisor &lt;code&gt;N - ddof&lt;/code&gt; . En la pr&amp;aacute;ctica estad&amp;iacute;stica est&amp;aacute;ndar, &lt;code&gt;ddof=1&lt;/code&gt; proporciona un estimador insesgado de la varianza de una poblaci&amp;oacute;n infinita hipot&amp;eacute;tica. &lt;code&gt;ddof=0&lt;/code&gt; proporciona una estimaci&amp;oacute;n de m&amp;aacute;xima verosimilitud de la varianza para variables distribuidas normalmente.</target>
        </trans-unit>
        <trans-unit id="6de47f27b421a49095ff1b82a99c964834e4c682" translate="yes" xml:space="preserve">
          <source>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;Chapter 4: Social and Political Infrastructure&lt;/a&gt; of Karl Fogel&amp;rsquo;s classic &lt;em&gt;Producing Open Source Software&lt;/em&gt;, and in particular the section on &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;Consensus-based Democracy&lt;/a&gt;, for a more detailed discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530a7cbb36983f7e2dde0f52c1c905d90e12e910" translate="yes" xml:space="preserve">
          <source>The mediator will engage with all the parties and seek a resolution that is satisfactory to all. Upon completion, the mediator will provide a report (vetted by all parties to the process) to the Committee, with recommendations on further steps. The Committee will then evaluate these results (whether satisfactory resolution was achieved or not) and decide on any additional action deemed necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">Los miembros son</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">Los miembros de esta estructura son</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">El objeto memmap se puede utilizar en cualquier lugar donde se acepte un ndarray. Dado un memmap &lt;code&gt;fp&lt;/code&gt; , &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; devuelve &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">La disposición de la memoria de un resultado de indexación avanzado se optimiza para cada operación de indexación y no se puede asumir ningún orden de memoria en particular.</target>
        </trans-unit>
        <trans-unit id="76384eb2a7d5d22bbc5978606ad7f8f1173b53b8" translate="yes" xml:space="preserve">
          <source>The memory layout of structured datatypes allows fields at arbitrary byte offsets. This means the fields can be separated by padding bytes, their offsets can be non-monotonically increasing, and they can overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5905e557d4f8798f2a63eb67ada3f5b47bd6cef3" translate="yes" xml:space="preserve">
          <source>The memory model for an ndarray admits arbitrary strides in each dimension to advance to the next element of the array. Often, however, you need to interface with code that expects a C-contiguous or a Fortran-contiguous memory layout. In addition, an ndarray can be misaligned (the address of an element is not at an integral multiple of the size of the element) which can cause your program to crash (or at least work more slowly) if you try and dereference a pointer into the array data. Both of these problems can be solved by converting the Python object into an array that is more &amp;ldquo;well-behaved&amp;rdquo; for your specific usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">El resultado fusionado.</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">El m&amp;eacute;todo debe devolver el resultado de la operaci&amp;oacute;n o &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; si la operaci&amp;oacute;n solicitada no est&amp;aacute; implementada.</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">El método utiliza la siguiente propiedad para el cálculo:dejar</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">Los métodos para estimar el número óptimo de contenedores están bien fundados en la literatura,y se inspiran en las opciones que R proporciona para la visualización del histograma.Nótese que teniendo el número de contenedores proporcional a</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">El tipo de datos mínimos.</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">El m&amp;iacute;nimo es equivalente a &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; cuando ni x1 ni x2 son NaN, pero es m&amp;aacute;s r&amp;aacute;pido y hace una transmisi&amp;oacute;n adecuada.</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El m&amp;iacute;nimo de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; , por elementos. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">El valor mínimo representable.</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">El valor mínimo a lo largo de un eje determinado.</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">El valor mínimo de un conjunto a lo largo de un eje dado,ignora el NaNs.</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">El valor mínimo de un arreglo a lo largo de un eje dado,ignorando cualquier NaNs.</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">El valor mínimo de un conjunto a lo largo de un eje determinado,propaga el NaNs.</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">El valor mínimo de un conjunto a lo largo de un eje dado,propagando cualquier NaNs.</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">El valor m&amp;iacute;nimo de un elemento de salida. Debe estar presente para permitir el c&amp;aacute;lculo en un segmento vac&amp;iacute;o. Consulte &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">El modo debe ser uno de:</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de Bessel modificada evaluada en cada uno de los elementos de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">El Weibull más común de 2 parámetros,incluyendo un parámetro de escala</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">La tarea m&amp;aacute;s b&amp;aacute;sica que se puede hacer con el &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; es visitar cada elemento de una matriz. Cada elemento se proporciona uno por uno utilizando la interfaz de iterador est&amp;aacute;ndar de Python.</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">La forma m&amp;aacute;s b&amp;aacute;sica de crear fechas y horas es a partir de cadenas en formato de fecha o fecha y hora ISO 8601. La unidad de almacenamiento interno se selecciona autom&amp;aacute;ticamente de la forma de la cadena y puede ser una &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;unidad de fecha&lt;/a&gt; o una &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;unidad de tiempo&lt;/a&gt; . Las unidades de fecha son a&amp;ntilde;os ('Y'), meses ('M'), semanas ('W') y d&amp;iacute;as ('D'), mientras que las unidades de tiempo son horas ('h'), minutos ('m' ), segundos ('s'), milisegundos ('ms') y algunas unidades adicionales basadas en segundos de prefijo SI.</target>
        </trans-unit>
        <trans-unit id="3f0f24060330e42125d74f607b6b6b61511b55b5" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units. The datetime64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo;, in any combination of lowercase/uppercase letters, for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">El uso más común de esta función es construir una matriz de bloques</target>
        </trans-unit>
        <trans-unit id="d15c9fb7581762b1e666994a9299d27d87d30396" translate="yes" xml:space="preserve">
          <source>The most natural way one can think of for boolean indexing is to use boolean arrays that have &lt;em&gt;the same shape&lt;/em&gt; as the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">La potencia m&amp;aacute;s negativa de la base (2) consistente con que no haya ceros iniciales en la mantisa.</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">El histograma multidimensional de la muestra x.Ver normalizado y pesos para las diferentes semánticas posibles.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">La distribuci&amp;oacute;n multinomial es una generalizaci&amp;oacute;n multivariante de la distribuci&amp;oacute;n binomial. Realice un experimento con uno de los &lt;code&gt;p&lt;/code&gt; posibles resultados. Un ejemplo de tal experimento es tirar un dado, donde el resultado puede ser de 1 a 6. Cada muestra extra&amp;iacute;da de la distribuci&amp;oacute;n representa &lt;code&gt;n&lt;/code&gt; de tales experimentos. Sus valores, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; , representan el n&amp;uacute;mero de veces que el resultado fue &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">La multiplicación utiliza la relación de recursividad para los polinomios de Hermite en la forma</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">La multiplicación utiliza la relación de recursividad para los polinomios de Laguerre en la forma</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">La multiplicación utiliza la relación de recursividad para los polinomios de Legendre en la forma</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">El generador de n&amp;uacute;meros aleatorios multiproceso se puede utilizar para completar una matriz. Los atributos de &lt;code&gt;values&lt;/code&gt; muestran el valor cero antes del relleno y el valor aleatorio despu&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="b9bbb85b9ae78b76721288cfcfe9a4008f15e026" translate="yes" xml:space="preserve">
          <source>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">La distribuci&amp;oacute;n normal multivariante, multinormal o gaussiana es una generalizaci&amp;oacute;n de la distribuci&amp;oacute;n normal unidimensional a dimensiones superiores. Tal distribuci&amp;oacute;n se especifica mediante su matriz de media y covarianza. Estos par&amp;aacute;metros son an&amp;aacute;logos a la media (promedio o &quot;centro&quot;) y la varianza (desviaci&amp;oacute;n est&amp;aacute;ndar o &quot;ancho&quot; al cuadrado) de la distribuci&amp;oacute;n normal unidimensional.</target>
        </trans-unit>
        <trans-unit id="a8b77cd2da64c5a2ad3fe22e334603fd46922d44" translate="yes" xml:space="preserve">
          <source>The mymethods must be an array (usually statically declared) of PyMethodDef structures which contain method names, actual C-functions, a variable indicating whether the method uses keyword arguments or not, and docstrings. These are explained in the next section. If you want to add constants to the module, then you store the returned value from Py_InitModule which is a module object. The most general way to add items to the module is to get the module dictionary using PyModule_GetDict(module). With the module dictionary, you can add whatever you like to the module manually. An easier way to add objects to the module is to use one of three additional Python C-API calls that do not require a separate extraction of the module dictionary. These are documented in the Python documentation, but repeated here for convenience:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">El FFT n-dimensional.</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">La matriz n-dimensional</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">La FFT inversa n-dimensional.</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">Las n-&amp;eacute;simas diferencias. La forma de la salida es la misma que &lt;code&gt;a&lt;/code&gt; excepto a lo largo del &lt;code&gt;axis&lt;/code&gt; donde la dimensi&amp;oacute;n es menor en &lt;code&gt;n&lt;/code&gt; . El tipo de salida es el mismo que el tipo de diferencia entre dos elementos cualesquiera de &lt;code&gt;a&lt;/code&gt; . Este es el mismo que el tipo de &lt;code&gt;a&lt;/code&gt; en la mayor&amp;iacute;a de los casos. Una excepci&amp;oacute;n notable es &lt;code&gt;datetime64&lt;/code&gt; , que da como resultado una &lt;code&gt;timedelta64&lt;/code&gt; salida timedelta64 .</target>
        </trans-unit>
        <trans-unit id="bbebdf33e8d96895ad0ed5b9400d54086fef2b67" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;colors&lt;/code&gt; comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; &lt;code&gt;colors[i]&lt;/code&gt; is the number of marbles in the urn with color &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">El nombre de una codificación</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">El nombre de cada columna, por ejemplo &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2c5edd467b851569da4a2dda38a270ee36e54ad" translate="yes" xml:space="preserve">
          <source>The name of the compiled python module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">El nombre de la funci&amp;oacute;n proviene del acr&amp;oacute;nimo de 'pico a pico'.</target>
        </trans-unit>
        <trans-unit id="d407bb92d1b152453450af784d89f7deb9d12336" translate="yes" xml:space="preserve">
          <source>The name of the function to be deprecated. Default is None, in which case the name of &lt;code&gt;func&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">El nombre de la variable polinómica</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">El nombre de la Ufunc.</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">El nombre sinc es la abreviatura de &quot;sine cardinal&quot; o &quot;sinus cardinalis&quot;.</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">Los nombres se ordenan según el aumento de la desviación de bytes.Esto puede ser usado,por ejemplo,para recorrer todos los campos nombrados en orden de desplazamiento.</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">Los nombres de los tipos en el c&amp;oacute;digo c siguen m&amp;aacute;s de cerca las convenciones de nomenclatura de c. Los nombres de Python para estos tipos siguen las convenciones de Python. Por lo tanto, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; recoge un flotante de 32 bits en C, pero &lt;code&gt;numpy.float_&lt;/code&gt; en Python corresponde a un doble de 64 bits. Los nombres de ancho de bits se pueden usar tanto en Python como en C para mayor claridad.</target>
        </trans-unit>
        <trans-unit id="7042a6f0e554df217f55061c01efbcd355c420f8" translate="yes" xml:space="preserve">
          <source>The names of the fields are given with the &lt;code&gt;names&lt;/code&gt; arguments, the corresponding values with the &lt;code&gt;data&lt;/code&gt; arguments. If a single field is appended, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;dtypes&lt;/code&gt; do not have to be lists but just values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">El tipo de indexaci&amp;oacute;n nativo de NumPy es &lt;code&gt;intp&lt;/code&gt; y puede diferir del tipo de matriz de enteros predeterminado. &lt;code&gt;intp&lt;/code&gt; es el tipo de datos m&amp;aacute;s peque&amp;ntilde;o suficiente para indexar de forma segura cualquier matriz; para indexaci&amp;oacute;n avanzada, puede ser m&amp;aacute;s r&amp;aacute;pido que otros tipos.</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">El registro natural del valor absoluto del determinante.</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El logaritmo natural &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; es el inverso de la funci&amp;oacute;n exponencial, de modo que &lt;code&gt;log(exp(x)) = x&lt;/code&gt; . El logaritmo natural es el logaritmo en base &lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El logaritmo natural de &lt;code&gt;x&lt;/code&gt; , por elementos. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">El nditer ya no se puede iterar una vez que se llama a &lt;code&gt;close&lt;/code&gt; o se sale de su contexto.</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">El nditer producirá entonces matrices de búferes escribibles que usted podrá modificar.Sin embargo,debido a que el nditer debe copiar estos datos del buffer de vuelta a la matriz original una vez que la iteración haya terminado,usted debe señalar cuando la iteración termine,por uno de dos métodos.Puedes hacer cualquiera de los dos:</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">El nuevo conjunto se forma a partir de los datos del antiguo conjunto,que se repiten si es necesario para completar el número de elementos requeridos.Los datos se repiten en el orden en que se almacenan en la memoria.</target>
        </trans-unit>
        <trans-unit id="a04e3c53d25194cf3b0ad0e57f30edc1bdcf03db" translate="yes" xml:space="preserve">
          <source>The new array will have a new last dimension equal in size to the number of field-elements of the input array. If not supplied, the output datatype is determined from the numpy type promotion rules applied to all the field datatypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97568b5d149f57d8764f77c287f9f2fe46a132b" translate="yes" xml:space="preserve">
          <source>The new behavior as of Numpy 1.16 leads to extra &amp;ldquo;padding&amp;rdquo; bytes at the location of unindexed fields compared to 1.15. You will need to update any code which depends on the data having a &amp;ldquo;packed&amp;rdquo; layout. For instance code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e027640aca67041dbf9c118ab74b0f73d41441e" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">La nueva infraestructura adopta un enfoque diferente para producir n&amp;uacute;meros aleatorios a partir del objeto &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . La generaci&amp;oacute;n de n&amp;uacute;meros aleatorios se divide en dos componentes, un generador de bits y un generador aleatorio.</target>
        </trans-unit>
        <trans-unit id="125105242ec81f06cd25f403baeb3cf1e8d9cd77" translate="yes" xml:space="preserve">
          <source>The new interface has docstring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">La nueva interfaz de argumento de palabra clave y el soporte de argumento &lt;code&gt;excluded&lt;/code&gt; degradan a&amp;uacute;n m&amp;aacute;s el rendimiento.</target>
        </trans-unit>
        <trans-unit id="d86ea97e67bbca694f01bcdba7b94c4f6336cda1" translate="yes" xml:space="preserve">
          <source>The new name for the function. Default is None, in which case the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated. If given, the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated and &lt;code&gt;new_name&lt;/code&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">La nueva forma debería ser compatible con la forma original.Si se suministra un número entero,el resultado será una matriz 1-D de esa longitud.</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">La nueva forma debería ser compatible con la forma original.Si es un número entero,entonces el resultado será una matriz 1-D de esa longitud.Una dimensión de la forma puede ser -1.En este caso,el valor se deduce de la longitud del conjunto y de las dimensiones restantes.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">El siguiente 1 byte es un byte sin firmar: el n&amp;uacute;mero de versi&amp;oacute;n principal del formato de archivo, por ejemplo, &lt;code&gt;\x01&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">El siguiente 1 byte es un byte sin firmar: el n&amp;uacute;mero de versi&amp;oacute;n menor del formato de archivo, por ejemplo, &lt;code&gt;\x00&lt;/code&gt; . Nota: la versi&amp;oacute;n del formato de archivo no est&amp;aacute; vinculada a la versi&amp;oacute;n del paquete numpy.</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">Los siguientes 2 bytes forman un int corto sin firmar:la longitud de los datos de la cabecera HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">Los siguientes bytes HEADER_LEN forman los datos del encabezado que describen el formato de la matriz. Es una cadena ASCII que contiene una expresi&amp;oacute;n literal de Python de un diccionario. Se termina con una nueva l&amp;iacute;nea ( &lt;code&gt;\n&lt;/code&gt; ) y se rellena con espacios ( &lt;code&gt;\x20&lt;/code&gt; ) para hacer que el total de &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; sea ​​divisible por 64 para fines de alineaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="af4ca037dcfe75d78dee9fbf52e144a1bd398782" translate="yes" xml:space="preserve">
          <source>The next floating point value after x1 towards x2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Los siguientes valores representables de &lt;code&gt;x1&lt;/code&gt; en la direcci&amp;oacute;n de &lt;code&gt;x2&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">El siguiente paso depende del tipo de &amp;iacute;ndice que se encontr&amp;oacute;. Si todas las dimensiones est&amp;aacute;n indexadas con un n&amp;uacute;mero entero, se devuelve o establece un escalar. Una &amp;uacute;nica matriz de indexaci&amp;oacute;n booleana llamar&amp;aacute; a funciones booleanas especializadas. Los &amp;iacute;ndices que contienen puntos suspensivos o rebanadas pero sin indexaci&amp;oacute;n avanzada siempre crear&amp;aacute;n una vista en la matriz anterior calculando los nuevos pasos y el desplazamiento de memoria. Esta vista puede devolverse o, para las asignaciones, completarse con &lt;code&gt;PyArray_CopyObject&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;PyArray_CopyObject&lt;/code&gt; tambi&amp;eacute;n se puede llamar en matrices temporales en otras ramas para admitir asignaciones complicadas cuando la matriz es de tipo d de objeto.</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">La siguiente tabla presenta el rendimiento en porcentaje relativo a los valores generados por el generador heredado, &lt;code&gt;RandomState(MT19937())&lt;/code&gt; . El rendimiento general se calcul&amp;oacute; utilizando una media geom&amp;eacute;trica.</target>
        </trans-unit>
        <trans-unit id="5462948418f50794d8b059e0adf72cefb6356af5" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original fortran code. Thus, if I modify the source code to contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">El sistema no central</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">Las distribuciones normales ocurren a menudo en la naturaleza. Por ejemplo, describe la distribuci&amp;oacute;n com&amp;uacute;n de muestras influenciadas por una gran cantidad de peque&amp;ntilde;as perturbaciones aleatorias, cada una con su propia distribuci&amp;oacute;n &amp;uacute;nica &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2acd5981a8ea796b96e83bb6555be4413ecc4212" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">Las distribuciones normales ocurren a menudo en la naturaleza. Por ejemplo, describe la distribuci&amp;oacute;n com&amp;uacute;n de muestras influenciadas por una gran cantidad de peque&amp;ntilde;as perturbaciones aleatorias, cada una con su propia distribuci&amp;oacute;n &amp;uacute;nica &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e795cd0114f2e83de16303b01c212b1bae08ff6" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los generadores normales, exponenciales y gamma utilizan m&amp;eacute;todos Ziggurat de 256 pasos que son de 2 a 10 veces m&amp;aacute;s r&amp;aacute;pidos que la implementaci&amp;oacute;n predeterminada de NumPy en &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">Los autovectores normalizados (unidad de &quot;longitud&quot;), de manera que la columna &lt;code&gt;v[:,i]&lt;/code&gt; es el autovector correspondiente al autovalor &lt;code&gt;w[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3299e827c6aa0d2d0f05fb49e420b7948a6917ca" translate="yes" xml:space="preserve">
          <source>The normed arguments of &lt;code&gt;histogramdd&lt;/code&gt; and &lt;code&gt;histogram2d&lt;/code&gt; have been renamed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">La norma nuclear es la suma de los valores singulares.</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">El n&amp;uacute;mero 13 tiene la representaci&amp;oacute;n &lt;code&gt;00001101&lt;/code&gt; . Asimismo, 16 est&amp;aacute; representado por &lt;code&gt;00010000&lt;/code&gt; . El OR bit a bit de 13 y 16 es &lt;code&gt;000111011&lt;/code&gt; , o 29:</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">El n&amp;uacute;mero 13 est&amp;aacute; representado por &lt;code&gt;00001101&lt;/code&gt; . Asimismo, 17 est&amp;aacute; representado por &lt;code&gt;00010001&lt;/code&gt; . El AND bit a bit de 13 y 17 es por lo tanto &lt;code&gt;000000001&lt;/code&gt; , o 1:</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">El n&amp;uacute;mero 13 est&amp;aacute; representado por &lt;code&gt;00001101&lt;/code&gt; . Asimismo, 17 est&amp;aacute; representado por &lt;code&gt;00010001&lt;/code&gt; . Por tanto, el XOR bit a bit de 13 y 17 es &lt;code&gt;00011100&lt;/code&gt; , o 28:</target>
        </trans-unit>
        <trans-unit id="d78115c4219b81e0960ff03256ee289bd93dfe48" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;a @ v = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">El n&amp;uacute;mero &lt;code&gt;w&lt;/code&gt; es un valor propio de &lt;code&gt;a&lt;/code&gt; si existe un vector &lt;code&gt;v&lt;/code&gt; tal que &lt;code&gt;dot(a,v) = w * v&lt;/code&gt; . Por lo tanto, las matrices &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; y &lt;code&gt;v&lt;/code&gt; satisfacen las ecuaciones &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; para</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">El número de argumentos.</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">El número de matrices que deben ser emitidas con la misma forma.</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">El número de unidades base en un paso.</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de contenedores (de tama&amp;ntilde;o 1) es uno m&amp;aacute;s grande que el valor m&amp;aacute;s grande en &lt;code&gt;x&lt;/code&gt; . Si se especifica &lt;code&gt;minlength&lt;/code&gt; , habr&amp;aacute; al menos este n&amp;uacute;mero de bins en la matriz de salida (aunque ser&amp;aacute; m&amp;aacute;s largo si es necesario, dependiendo del contenido de &lt;code&gt;x&lt;/code&gt; ). Cada contenedor da el n&amp;uacute;mero de apariciones de su valor de &amp;iacute;ndice en &lt;code&gt;x&lt;/code&gt; . Si se especifican &lt;code&gt;weights&lt;/code&gt; la matriz de entrada se pondera con ellos, es decir, si se encuentra un valor &lt;code&gt;n&lt;/code&gt; en la posici&amp;oacute;n &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;out[n] += weight[i]&lt;/code&gt; lugar de &lt;code&gt;out[n] += 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">El n&amp;uacute;mero de contenedores para todas las dimensiones (nx = ny =&amp;hellip; = contenedores).</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">El n&amp;uacute;mero de contenedores para cada dimensi&amp;oacute;n (nx, ny,&amp;hellip; = contenedores)</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">El n&amp;uacute;mero de contenedores es solo proporcional a la ra&amp;iacute;z c&amp;uacute;bica de un &lt;code&gt;a.size&lt;/code&gt; . Tiende a sobreestimar el n&amp;uacute;mero de bins y no tiene en cuenta la variabilidad de los datos.</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">El n&amp;uacute;mero de contenedores es el logaritmo en base 2 de un &lt;code&gt;a.size&lt;/code&gt; . Este estimador asume la normalidad de los datos y es demasiado conservador para conjuntos de datos m&amp;aacute;s grandes y no normales. Este es el m&amp;eacute;todo predeterminado en el m&amp;eacute;todo &lt;code&gt;hist&lt;/code&gt; de R.</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">El número de bits en el exponente,incluyendo su signo y sesgo.</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">El número de bits en la porción de exponente de la representación en punto flotante.</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">El número de bits en la mantisa.</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">El número de bits ocupados por el tipo.</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">El número de bits necesarios para generar un valor simulado difiere del número de bits generados por el RNG subyacente.Por ejemplo,se pueden simular dos valores enteros de 16 bits a partir de un solo dibujo de un RNG de 32 bits.</target>
        </trans-unit>
        <trans-unit id="5b028aff9079ccf79e60389c0ccd1c2bd52c5a13" translate="yes" xml:space="preserve">
          <source>The number of build jobs can also be specified via the environment variable &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">El número de bytes que requiere cada elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de bytes en el campo en el que colocar &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">El número de caracteres por línea con el fin de insertar saltos de línea (por defecto 75).</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">El n&amp;uacute;mero de ni&amp;ntilde;os ya engendrados. Solo pase esto si est&amp;aacute; reconstruyendo una &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; desde un formulario serializado.</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">El número de dimensiones y el tamaño de cada dimensión</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">El número de dimensiones de la matriz.</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">El número de dimensiones en el resultado emitido.</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">El número de dimensiones.</target>
        </trans-unit>
        <trans-unit id="cf23530c90606a0534a47544a2bf03555320f356" translate="yes" xml:space="preserve">
          <source>The number of each type of item in the collection from which a sample is drawn. The values in &lt;code&gt;colors&lt;/code&gt; must be nonnegative. To avoid loss of precision in the algorithm, &lt;code&gt;sum(colors)&lt;/code&gt; must be less than &lt;code&gt;10**9&lt;/code&gt; when &lt;code&gt;method&lt;/code&gt; is &amp;ldquo;marginals&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">El n&amp;uacute;mero de elementos a desempacar a lo largo del &lt;code&gt;axis&lt;/code&gt; , proporcionado como una forma de deshacer el efecto de empaquetar un tama&amp;ntilde;o que no es m&amp;uacute;ltiplo de ocho. Un n&amp;uacute;mero no negativo significa desempaquetar solo los bits de &lt;code&gt;count&lt;/code&gt; . Un n&amp;uacute;mero negativo significa recortar esa cantidad de bits del final. &lt;code&gt;None&lt;/code&gt; significa descomprimir toda la matriz (el valor predeterminado). Los recuentos mayores que la cantidad de bits disponibles agregar&amp;aacute;n relleno de ceros a la salida. Los recuentos negativos no deben exceder el n&amp;uacute;mero de bits disponible.</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">El número de tipos de puntos flotantes</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">El número de argumentos de entrada.</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">El número de entradas.</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">El número de integraciones a realizar.</target>
        </trans-unit>
        <trans-unit id="f51beaacf43aeefc0899893a53af8824382a26f0" translate="yes" xml:space="preserve">
          <source>The number of items selected. &lt;code&gt;nsample&lt;/code&gt; must not be greater than &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">La cantidad de elementos que se &lt;em&gt;van&lt;/em&gt; a leer &lt;em&gt;iterables&lt;/em&gt; . El valor predeterminado es -1, lo que significa que se leen todos los datos.</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">El número de operandos iteradores.</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">El número de líneas a saltar al principio del archivo.</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">El número de líneas a saltar al final del archivo.</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">El número de tipos numéricos NumPy-de los cuales hay 18 en total-en los que la ufunc puede operar.</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de objetos devueltos por &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">El número de argumentos de salida.</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">El número de salidas.</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">El n&amp;uacute;mero de per&amp;iacute;odos &lt;code&gt;nper&lt;/code&gt; se calcula resolviendo la ecuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">El n&amp;uacute;mero de lugares en los que se desplazan los elementos. Si es una tupla, el &lt;code&gt;axis&lt;/code&gt; debe ser una tupla del mismo tama&amp;ntilde;o y cada uno de los ejes dados se desplaza en el n&amp;uacute;mero correspondiente. Si un &lt;code&gt;axis&lt;/code&gt; int while es una tupla de enteros, entonces se usa el mismo valor para todos los ejes dados.</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">El n&amp;uacute;mero de repeticiones de cada elemento. &lt;code&gt;repeats&lt;/code&gt; se transmiten para adaptarse a la forma del eje dado.</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">El n&amp;uacute;mero de repeticiones de &lt;code&gt;A&lt;/code&gt; a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">El número de tipos de datos soportados para la UFUNC.Este número especifica cuántos bucles 1-d diferentes (de los tipos de datos incorporados)están disponibles.</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">El n&amp;uacute;mero de veces &lt;code&gt;a&lt;/code&gt; se repite a lo largo de los ejes primero y segundo.</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">El n&amp;uacute;mero de veces que aparece cada uno de los valores &amp;uacute;nicos en la matriz original. Solo se proporciona si &lt;code&gt;return_counts&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">El número de veces que los valores se diferencian.Si es cero,la entrada se devuelve tal cual.</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">El número de tipos.</target>
        </trans-unit>
        <trans-unit id="fddf10cce5774b681c3f0ad6691bdd384810c58d" translate="yes" xml:space="preserve">
          <source>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., &lt;code&gt;(k, m)&lt;/code&gt;, then &lt;code&gt;k * m&lt;/code&gt; variates are drawn, where one variate is a vector of length &lt;code&gt;len(colors)&lt;/code&gt;, and the return value has shape &lt;code&gt;(k, m, len(colors))&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is an integer, the output has shape &lt;code&gt;(size, len(colors))&lt;/code&gt;. Default is None, in which case a single variate is returned as an array with shape &lt;code&gt;(len(colors),)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">La matriz numérica comparte la memoria con el objeto tipo.</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">La biblioteca de matem&amp;aacute;ticas b&amp;aacute;sica numpy ('npymath') es un primer paso en esta direcci&amp;oacute;n. Esta biblioteca contiene la mayor&amp;iacute;a de las funciones de C99 relacionadas con las matem&amp;aacute;ticas, que se pueden utilizar en plataformas en las que C99 no es compatible. Las funciones matem&amp;aacute;ticas centrales tienen la misma API que las C99, excepto por el prefijo npy_ *.</target>
        </trans-unit>
        <trans-unit id="6064ebb13dec03f1de88e5067059d7a27df68911" translate="yes" xml:space="preserve">
          <source>The numpy documentation also depends on the &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx extension as well as an external sphinx theme. These extensions are included as git submodules and must be initialized before building the docs. From the &lt;code&gt;doc/&lt;/code&gt; directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">El módulo numpy.ma</target>
        </trans-unit>
        <trans-unit id="2cbe93e7df3a43f9ae71da4b89814ed8fa49c0d4" translate="yes" xml:space="preserve">
          <source>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fff5784e4a4fb8eb59dd23392ddf836510aaeb1" translate="yes" xml:space="preserve">
          <source>The numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd675a4d044f8874d7c67d632da0258490296eb" translate="yes" xml:space="preserve">
          <source>The object can be any Python object convertible to an ndarray. If the object is already (a subclass of) the ndarray that satisfies the requirements then a new reference is returned. Otherwise, a new array is constructed. The contents of &lt;em&gt;obj&lt;/em&gt; are copied to the new array unless the array interface is used so that data does not have to be copied. Objects that can be converted to an array include: 1) any nested sequence object, 2) any object exposing the array interface, 3) any object with an &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method (which should return an ndarray), and 4) any scalar object (becomes a zero-dimensional array). Sub-classes of the ndarray that otherwise fit the requirements will be passed through. If you want to ensure a base-class ndarray, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt; in the requirements flag. A copy is made only if necessary. If you want to guarantee a copy, then pass in &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; to the requirements flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">El objeto del que se devuelve el tipo.</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">El objeto que se convertirá en una matriz de tipo y requisito.</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">El objeto a comprobar.</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">El objeto a iterar sobre.</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">El tipo de objeto tambi&amp;eacute;n es especial porque una matriz que contiene &lt;code&gt;object_&lt;/code&gt; items no devuelve un &lt;code&gt;object_&lt;/code&gt; object al acceder al elemento, sino que devuelve el objeto real al que se refiere el elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">El objeto que calculó estos parámetros y tiene información más detallada.</target>
        </trans-unit>
        <trans-unit id="12dc58a76790d493cfd5ba208610a891b0f1c28f" translate="yes" xml:space="preserve">
          <source>The object will be converted to the desired type only if it can be done without losing precision. Otherwise &lt;code&gt;NULL&lt;/code&gt; will be returned and an error raised. Use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; in the requirements flag to override this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7678b3e9676e0762f7a3c623921af222c12ff2c" translate="yes" xml:space="preserve">
          <source>The obvious fix for this situation is to change the dtype so it gives the correct endianness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">El desplazamiento (en bytes) desde la posici&amp;oacute;n actual del archivo. El valor predeterminado es 0. Solo se permite para archivos binarios.</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">El viejo manejador de errores.</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">La antigua API del iterador incluye funciones como PyArrayIter_Check,PyArray_Iter*y PyArray_ITER_*.La matriz multi-iterador incluye PyArray_MultiIter*,PyArray_Broadcast,y PyArray_RemoveSmallest.El nuevo diseño del iterador reemplaza toda esta funcionalidad con un solo objeto y la API asociada.Uno de los objetivos de la nueva API es que todos los usos del iterador existente sean reemplazables por el nuevo iterador sin un esfuerzo significativo.En 1.6,la principal excepción a esto es el iterador de vecindario,que no tiene las características correspondientes en este iterador.</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">La FFT unidimensional (hacia adelante), de la cual &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; es la inversa</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">La FFT unidimensional de entrada general (compleja).</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">La FFT unidimensional de entrada real, de la cual &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; es inversa.</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">La FFT unidimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">El FFT unidimensional,con las definiciones y convenciones utilizadas.</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">El FFT unidimensional.</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">El FFT unidimensional inverso.</target>
        </trans-unit>
        <trans-unit id="ba7c728a6936b18871796d8f180aab8013101b39" translate="yes" xml:space="preserve">
          <source>The only constraint on &lt;code&gt;weights&lt;/code&gt; is that &lt;code&gt;sum(weights)&lt;/code&gt; must not be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0f1129172422a9679a73fc5e8d6a883951639f" translate="yes" xml:space="preserve">
          <source>The only mandatory argument of &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a &lt;code&gt;read&lt;/code&gt; method, for example, a file or &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">Los operandos de alguna operación cuyo tipo de resultado se necesita.</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">La operación en el bucle interior es una multiplicación sencilla.Todo lo que tiene que ver con el producto exterior se maneja por la configuración del iterador.</target>
        </trans-unit>
        <trans-unit id="471ee7828ebe7c0602cfc5e6e021f9c562ef10fd" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;dtype=None&lt;/code&gt; is provided for convenience. However, it is significantly slower than setting the dtype explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9c6a82b754562bff3c30cfb164e81b6c34b6c3" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;aligned&amp;rsquo; value can be set to &lt;code&gt;True&lt;/code&gt; to make the automatic offset computation use aligned offsets (see &lt;a href=&quot;#offsets-and-alignment&quot;&gt;Automatic Byte Offsets and Alignment&lt;/a&gt;), as if the &amp;lsquo;align&amp;rsquo; keyword argument of &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; had been set to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a3e8c483cee1d9d2b1425187728e8a245d58ca" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;titles&amp;rsquo; value should be a list of titles of the same length as &amp;lsquo;names&amp;rsquo;, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af8d6f274a699b745815e9b76bdbe8e97f9313c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;comments&lt;/code&gt; is used to define a character string that marks the beginning of a comment. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;comments='#'&lt;/code&gt;. The comment marker may occur anywhere on the line. Any character present after the comment marker(s) is simply ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">Los argumentos de salida opcionales se pueden usar para ayudarlo a ahorrar memoria para c&amp;aacute;lculos grandes. Si sus matrices son grandes, las expresiones complicadas pueden tardar m&amp;aacute;s de lo absolutamente necesario debido a la creaci&amp;oacute;n y (posterior) destrucci&amp;oacute;n de espacios de c&amp;aacute;lculo temporales. Por ejemplo, la expresi&amp;oacute;n &lt;code&gt;G = a * b + c&lt;/code&gt; es equivalente a &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; . Se ejecutar&amp;aacute; m&amp;aacute;s r&amp;aacute;pidamente como &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; que es lo mismo que &lt;code&gt;G = A * B; G += C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">El tercer elemento opcional &lt;em&gt;field_shape&lt;/em&gt; contiene la forma si este campo representa una matriz del tipo de datos en el segundo elemento. Tenga en cuenta que una tupla de 3 con un tercer argumento igual a 1 es equivalente a una tupla de 2.</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">Las opciones 'reducido', 'completo y' crudo 'son nuevas en numpy 1.8, consulte las notas para obtener m&amp;aacute;s informaci&amp;oacute;n. El valor predeterminado es 'reducido', y para mantener la compatibilidad con versiones anteriores de numpy, se pueden omitir tanto &amp;eacute;l como el antiguo predeterminado 'completo'. Tenga en cuenta que la matriz h devuelta en modo 'crudo' se transpone para llamar a Fortran. El modo 'econ&amp;oacute;mico' est&amp;aacute; en desuso. Los modos 'completo' y 'econ&amp;oacute;mico' pueden pasarse usando solo la primera letra para compatibilidad con versiones anteriores, pero todos los dem&amp;aacute;s deben estar detallados. Consulte las Notas para obtener m&amp;aacute;s explicaciones.</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">El orden en el que los datos de la matriz se almacenan en la memoria: 'C' -&amp;gt; orden de &amp;ldquo;fila principal&amp;rdquo; (el predeterminado), 'F' -&amp;gt; orden de &amp;ldquo;columna principal&amp;rdquo; (Fortran).</target>
        </trans-unit>
        <trans-unit id="68929adbb771e5f9d5347a88dc7ca873ea9321af" translate="yes" xml:space="preserve">
          <source>The order in which they are preferred is determined by &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; and &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; environment variables. The default value is &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">El orden de &lt;code&gt;v1&lt;/code&gt; y &lt;code&gt;v2&lt;/code&gt; no importa.</target>
        </trans-unit>
        <trans-unit id="64c7894d7cfcaaec3478ec1e4aaf0c4a01f8cc6f" translate="yes" xml:space="preserve">
          <source>The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4e69a308201075218d8a094df1f5f1f4d37aad" translate="yes" xml:space="preserve">
          <source>The order of the elements in the array resulting from ravel() is normally &amp;ldquo;C-style&amp;rdquo;, that is, the rightmost index &amp;ldquo;changes the fastest&amp;rdquo;, so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as &amp;ldquo;C-style&amp;rdquo;. NumPy normally creates arrays stored in this order, so ravel() will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel() and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">El orden de los bits de entrada. 'big' imitar&amp;aacute; bin (val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; . El valor predeterminado es &quot;grande&quot;.</target>
        </trans-unit>
        <trans-unit id="6a7badf2486ba3d65f6d452504aadca6f59aa17f" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order so &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">El orden de los bits devueltos. 'grande' imitar&amp;aacute; bin (val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; , 'peque&amp;ntilde;o' invertir&amp;aacute; el orden a &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; . El valor predeterminado es &quot;grande&quot;.</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">El orden o grado del polinomio</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">La orientaci&amp;oacute;n de &lt;code&gt;c&lt;/code&gt; se puede cambiar usando la palabra clave &lt;code&gt;axisc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6895b0ec7c91fa01ba724c0454c0ecbf9046ad1" translate="yes" xml:space="preserve">
          <source>The original contents of the &lt;code&gt;intent(in)&lt;/code&gt; argument may be altered by the Fortran/C function. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">La otra clase debe tener el atributo &lt;code&gt;coef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">La otra clase debe tener el atributo de &lt;code&gt;domain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">La otra clase debe tener el atributo de &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">El argumento out especifica d&amp;oacute;nde colocar el resultado. Si out es NULL, entonces se crea la matriz de salida; de lo contrario, la salida se coloca en out, que debe ser del tama&amp;ntilde;o y tipo correctos. Siempre se devuelve una nueva referencia a la matriz de salida incluso cuando out no es NULL. La persona que llama a la rutina tiene la responsabilidad de &lt;code&gt;DECREF&lt;/code&gt; si no es NULL o se producir&amp;aacute; una p&amp;eacute;rdida de memoria.</target>
        </trans-unit>
        <trans-unit id="b1eb4436c2a0a0542bae9d8ee0693add2fca6bb8" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;Py_DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">El producto exterior</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">Los argumentos de salida (si los hay) se procesan y se construyen las matrices de retorno que faltan. Si alguna matriz de salida proporcionada no tiene el tipo correcto (o est&amp;aacute; mal alineada) y es m&amp;aacute;s peque&amp;ntilde;a que el tama&amp;ntilde;o del b&amp;uacute;fer, entonces se construye una nueva matriz de salida con el conjunto de indicadores &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; especial . Al final de la funci&amp;oacute;n, se llama a &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; para que su contenido se vuelva a copiar en la matriz de salida. A continuaci&amp;oacute;n, se procesan los iteradores de los argumentos de salida.</target>
        </trans-unit>
        <trans-unit id="02fbb66d65f083fd2d9e7a738b5f72feedd2f131" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La matriz de salida est&amp;aacute; enmascarada donde se enmascaran todos los valores a lo largo del eje dado: si la salida hubiera sido un escalar y todos los valores est&amp;aacute;n enmascarados, entonces la salida est&amp;aacute; &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdd30a82881324958754cfed2ed5012e49b5922" translate="yes" xml:space="preserve">
          <source>The output array of type Boolean with the same shape as a and b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">La matriz de salida, que contiene la parte del contenido del &lt;code&gt;file&lt;/code&gt; que coincide con &lt;code&gt;regexp&lt;/code&gt; . &lt;code&gt;output&lt;/code&gt; es siempre una matriz estructurada.</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">La matriz de salida, funci&amp;oacute;n escalonada de Heaviside por elementos de &lt;code&gt;x1&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">La matriz de salida.</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">La matriz de salida. El n&amp;uacute;mero de dimensiones es el mismo que &lt;code&gt;a&lt;/code&gt; , pero la forma puede ser diferente. Esto depende de si &lt;code&gt;func&lt;/code&gt; cambia la forma de su salida con respecto a su entrada.</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">La matriz de salida. La forma de &lt;code&gt;out&lt;/code&gt; es id&amp;eacute;ntica a la forma de &lt;code&gt;arr&lt;/code&gt; , excepto a lo largo de la dimensi&amp;oacute;n del &lt;code&gt;axis&lt;/code&gt; . Este eje se elimina y se reemplaza con nuevas dimensiones iguales a la forma del valor de retorno de &lt;code&gt;func1d&lt;/code&gt; . Entonces, si &lt;code&gt;func1d&lt;/code&gt; devuelve, una &lt;code&gt;out&lt;/code&gt; escalar tendr&amp;aacute; una dimensi&amp;oacute;n menos que &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">La salida en la posici&amp;oacute;n m es el m-&amp;eacute;simo elemento de la matriz en la &lt;code&gt;choicelist&lt;/code&gt; de selecci&amp;oacute;n donde el m-&amp;eacute;simo elemento de la matriz correspondiente en la &lt;code&gt;condlist&lt;/code&gt; de condiciones es Verdadero.</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">El tipo de datos de salida.Debe ser especificado como una cadena de caracteres de código de tipo o una lista de especificadores de tipo de datos.Debe haber un especificador de tipo de datos para cada salida.</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">La salida tiene la misma forma que la entrada y cada bucle 1-D opera sobre</target>
        </trans-unit>
        <trans-unit id="63770907dcff4eb26363f61fd3098799f014e4b4" translate="yes" xml:space="preserve">
          <source>The output is a &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;tuple&lt;/a&gt; with three elements, which means that this is a three-dimensional array. In fact, since this is a color image, and we have used the &lt;code&gt;imread&lt;/code&gt; function to read it, the data is organized in three 2D arrays, representing color channels (in this case, red, green and blue - RGB). You can see this by looking at the shape above: it indicates that we have an array of 3 matrices, each having shape 768x1024.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">La salida se rellena a la izquierda con la longitud de la cadena de prefijo, y el &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; se fuerza en la columna max_line_width - len (sufijo) . Cabe se&amp;ntilde;alar que el contenido de las cadenas de prefijo y sufijo no se incluye en la salida.</target>
        </trans-unit>
        <trans-unit id="e11dba8a2e35e34ff280ff12d3cc6c9a772a17ab" translate="yes" xml:space="preserve">
          <source>The output is sorted along the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">La salida tiene la misma forma y tipo que x y se encuentra llamando a las funciones en &lt;code&gt;funclist&lt;/code&gt; en las porciones apropiadas de &lt;code&gt;x&lt;/code&gt; , seg&amp;uacute;n lo definido por las matrices booleanas en &lt;code&gt;condlist&lt;/code&gt; . Las porciones que no est&amp;aacute;n cubiertas por ninguna condici&amp;oacute;n tienen un valor predeterminado de 0.</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">La salida de &lt;code&gt;argwhere&lt;/code&gt; no es adecuada para indexar matrices. Para este prop&amp;oacute;sito, utilice un valor &lt;code&gt;nonzero(a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">La salida de ufunc (y sus m&amp;eacute;todos) no es necesariamente un &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , si todos los argumentos de entrada no son &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; . En efecto, si cualquier entrada define un &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo, el control se pasa completamente a esa funci&amp;oacute;n, es decir, la ufunc es &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;anulado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6599e81d2d214234687adf6fb69ac2c773f47b7b" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">La forma de salida en el caso denso se obtiene anteponiendo el n&amp;uacute;mero de dimensiones delante de la tupla de dimensiones, es decir, si &lt;code&gt;dimensions&lt;/code&gt; es una tupla &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; de longitud &lt;code&gt;N&lt;/code&gt; , la forma de salida es &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">El tipo de salida se determina evaluando el primer elemento de la entrada,a menos que se especifique:</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">La salida, an&amp;aacute;logamente a &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , contiene el t&amp;eacute;rmino para frecuencia cero en la esquina de orden inferior de todos los ejes, los t&amp;eacute;rminos de frecuencia positiva en la primera mitad de todos los ejes, el t&amp;eacute;rmino para la frecuencia de Nyquist en el medio de todos los ejes y el t&amp;eacute;rmino negativo t&amp;eacute;rminos de frecuencia en la segunda mitad de todos los ejes, en orden decreciente de frecuencia negativa.</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">La salida, an&amp;aacute;logamente a &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , contiene el t&amp;eacute;rmino para frecuencia cero en la esquina de orden inferior de los ejes transformados, los t&amp;eacute;rminos de frecuencia positiva en la primera mitad de estos ejes, el t&amp;eacute;rmino para la frecuencia de Nyquist en el medio de los ejes y el t&amp;eacute;rminos de frecuencia negativa en la segunda mitad de los ejes, en orden decreciente de frecuencia negativa.</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">El paquete asegura que las entradas enmascaradas no se utilicen en los cálculos.</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">El carácter de relleno a utilizar (por defecto es el espacio).</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">La función de acolchado,si se usa,debería modificar un arreglo de rango 1 en el lugar.Tiene la siguiente firma:</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;oa_ndim&lt;/code&gt; , cuando no es cero o -1, especifica el n&amp;uacute;mero de dimensiones que se iterar&amp;aacute;n con la difusi&amp;oacute;n personalizada. Si se proporciona, &lt;code&gt;op_axes&lt;/code&gt; debe y tambi&amp;eacute;n se puede proporcionar &lt;code&gt;itershape&lt;/code&gt; . El par&amp;aacute;metro &lt;code&gt;op_axes&lt;/code&gt; le permite controlar en detalle c&amp;oacute;mo los ejes de las matrices de operandos se emparejan e iteran. En &lt;code&gt;op_axes&lt;/code&gt; , debe proporcionar una matriz de punteros &lt;code&gt;nop&lt;/code&gt; a matrices de &lt;code&gt;oa_ndim&lt;/code&gt; oa_ndim de tipo &lt;code&gt;npy_intp&lt;/code&gt; . Si una entrada en &lt;code&gt;op_axes&lt;/code&gt; es NULL, se aplicar&amp;aacute;n las reglas de transmisi&amp;oacute;n normales. En &lt;code&gt;op_axes[j][i]&lt;/code&gt; se almacena un eje v&amp;aacute;lido de &lt;code&gt;op[j]&lt;/code&gt; , o -1 lo que significa &lt;code&gt;newaxis&lt;/code&gt; . Dentro de cada &lt;code&gt;op_axes[j]&lt;/code&gt; , los ejes no pueden repetirse. El siguiente ejemplo muestra c&amp;oacute;mo se aplica la transmisi&amp;oacute;n normal a una matriz 3-D, una matriz 2-D, una matriz 1-D y un escalar.</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;x&lt;/code&gt; se convierte en una matriz solo si es una tupla o una lista; de lo contrario, se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la multiplicaci&amp;oacute;n y la suma tanto con ellos mismos como con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;x&lt;/code&gt; se convierte en una matriz solo si es una tupla o una lista; de lo contrario, se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la multiplicaci&amp;oacute;n y la suma tanto con ellos mismos como con los elementos de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">El par&amp;aacute;metro &lt;em&gt;dtype&lt;/em&gt; especifica el tipo de datos sobre el que debe realizarse una operaci&amp;oacute;n de reducci&amp;oacute;n (como la suma). El tipo de datos de reducci&amp;oacute;n predeterminado es el mismo que el tipo de datos de &lt;em&gt;self&lt;/em&gt; . Para evitar el desbordamiento, puede resultar &amp;uacute;til realizar la reducci&amp;oacute;n utilizando un tipo de datos mayor.</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; se convierten en matrices s&amp;oacute;lo si son tuplas o unas listas, de lo contrario, se tratan como una escalares y deben tener la misma forma despu&amp;eacute;s de la conversi&amp;oacute;n. En cualquier caso, ya sea &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; o sus elementos deben apoyar multiplicaci&amp;oacute;n y adici&amp;oacute;n tanto con ellos mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; se convierten en matrices s&amp;oacute;lo si son tuplas o unas listas, de lo contrario, se tratan como una escalares. En cualquier caso, ya sea &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; o sus elementos deben apoyar multiplicaci&amp;oacute;n y adici&amp;oacute;n tanto con ellos mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; se convierten en matrices solo si son tuplas o listas; de lo contrario, se tratan como escalares y deben tener la misma forma despu&amp;eacute;s de la conversi&amp;oacute;n. En cualquier caso, ya sea &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , y &lt;code&gt;z&lt;/code&gt; o sus elementos deben apoyar multiplicaci&amp;oacute;n y adici&amp;oacute;n tanto con ellos mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; se convierten en matrices solo si son tuplas o listas; de lo contrario, se tratan como escalares. En cualquier caso, ya sea &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , y &lt;code&gt;z&lt;/code&gt; o sus elementos deben apoyar multiplicaci&amp;oacute;n y adici&amp;oacute;n tanto con ellos mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">El camino de la plantilla,relativamente al camino del paquete actual.</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">La ruta del archivo para el que se realizan las pruebas documentales.</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">El patrón de uso de los iteradores anidados es el siguiente.</target>
        </trans-unit>
        <trans-unit id="9db61e58e4763f03cd16195e5ed8a40825c96961" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El patr&amp;oacute;n es similar para otros generadores m&amp;aacute;s complejos. El rendimiento normal del generador &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; heredado es mucho m&amp;aacute;s bajo que el del otro, ya que usa la transformaci&amp;oacute;n Box-Muller en lugar del generador Ziggurat. La brecha de rendimiento para los exponenciales tambi&amp;eacute;n es grande debido al costo de calcular la funci&amp;oacute;n logar&amp;iacute;tmica para invertir el CDF. La columna etiquetada MT19973 se usa el mismo generador de 32 bits que &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; pero produce valores aleatorios usando &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">El pago se calcula resolviendo la ecuación:</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">El porcentaje de olas mayores de 3 metros es:</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">El rendimiento de los generadores de 64 bits en Windows de 32 bits es muy inferior al de los sistemas operativos de 64 bits debido al ancho de registro.MT19937,el generador que ha estado en NumPy desde 2005,funciona con números enteros de 32 bits.</target>
        </trans-unit>
        <trans-unit id="02f4c7c728252209e49cade8944d95bdb15fb9ef" translate="yes" xml:space="preserve">
          <source>The place in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a72aed7747ec5b4e706a7296ecd1eb9faae060" translate="yes" xml:space="preserve">
          <source>The places in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5ee23f497e38c29e0616fdcc0bb0ea7d4426f2" translate="yes" xml:space="preserve">
          <source>The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could iterate over each element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">Los coeficientes polinómicos</target>
        </trans-unit>
        <trans-unit id="daaa36d42f5e3da309c9eab093a92efe7a0076ca" translate="yes" xml:space="preserve">
          <source>The polynomial convenience classes cannot be passed to ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">El polinomio resultante de la multiplicación de las entradas.Si cualquiera de las entradas es un objeto poly1d,entonces la salida es también un objeto poly1d.De lo contrario,es un conjunto 1D de coeficientes polinómicos de mayor a menor grado.</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">La clase de tipo de serie polinómica a la que se debe convertir la instancia actual.Si el tipo es Ninguno,entonces se utiliza la clase de la instancia actual.</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">Los coeficientes del polinomio, en potencias decrecientes, o si el valor del segundo par&amp;aacute;metro es Verdadero, las ra&amp;iacute;ces del polinomio (valores donde el polinomio se eval&amp;uacute;a como 0). Por ejemplo, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; devuelve un objeto que representa</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">La posición,</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">La lista posiblemente anidada de elementos de la matriz.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">La distribución de la función de potencia es justo lo contrario de la distribución de Pareto.También puede verse como un caso especial de la distribución Beta.</target>
        </trans-unit>
        <trans-unit id="65b60415cb79d4266b3f17e50b1894cd53e37067" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on Github (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation Index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f79358f94b924f7a1e059d54f311b3bb21fdafb" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">La forma preferida de usar un BitGenerator en aplicaciones paralelas es usar el m&amp;eacute;todo &lt;code&gt;SeedSequence.spawn&lt;/code&gt; para obtener valores de entrop&amp;iacute;a, y usarlos para generar nuevos BitGenerators:</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">El preprocesamiento de archivos fuente C de tipo gen&amp;eacute;rico (ya sea en NumPy propiamente dicho o en cualquier paquete de terceros que use NumPy Distutils) se realiza mediante &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt; . Los archivos C espec&amp;iacute;ficos de tipo generados (extensi&amp;oacute;n: .c) por estos m&amp;oacute;dulos durante el proceso de compilaci&amp;oacute;n est&amp;aacute;n listos para compilarse. Esta forma de escritura gen&amp;eacute;rica tambi&amp;eacute;n es compatible con archivos de encabezado C (preprocesados ​​para producir archivos .h).</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">La presencia de &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n influye en c&amp;oacute;mo &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; maneja operaciones binarias como &lt;code&gt;arr + obj&lt;/code&gt; y &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; cuando &lt;code&gt;arr&lt;/code&gt; es un &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;obj&lt;/code&gt; es una instancia de una clase personalizada. Hay dos posibilidades. Si &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; est&amp;aacute; presente y no &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , entonces &lt;code&gt;ndarray.__add__&lt;/code&gt; y sus amigos delegar&amp;aacute;n en la maquinaria ufunc, lo que significa que &lt;code&gt;arr + obj&lt;/code&gt; convierte en &lt;code&gt;np.add(arr, obj)&lt;/code&gt; , y luego &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; invoca &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; . Esto es &amp;uacute;til si desea definir un objeto que act&amp;uacute;a como una matriz.</target>
        </trans-unit>
        <trans-unit id="40d6e2ba786e2b9884243f86e826abd1b1d0b0e2" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not None, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adb356cfd1303c61f397a436f3cf821b0707e98" translate="yes" xml:space="preserve">
          <source>The presence of a header in the file can hinder data processing. In that case, we need to use the &lt;code&gt;skip_header&lt;/code&gt; optional argument. The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed. Similarly, we can skip the last &lt;code&gt;n&lt;/code&gt; lines of the file by using the &lt;code&gt;skip_footer&lt;/code&gt; attribute and giving it a value of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">El valor actual se calcula resolviendo la ecuación:</target>
        </trans-unit>
        <trans-unit id="601986bff68f0c999502156a5c8a6f32ded002a4" translate="yes" xml:space="preserve">
          <source>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. &lt;code&gt;int16&lt;/code&gt;). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51c177d3ffae7eeb654a1cd5049b77b590c4db" translate="yes" xml:space="preserve">
          <source>The primitive types supported are tied closely to those in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">Las probabilidades asociadas con cada entrada en a.Si no se dan,la muestra asume una distribución uniforme sobre todas las entradas en a.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución Gamma es</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de Gauss es</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de Gumbel es</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución Hipergeométrica es</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de las Log Series es</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución logística es</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de Pareto es</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de Weibull es</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución Zipf es</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución binomial es</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">La densidad de probabilidad para la distribución de Von Mises es</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">La función de densidad de probabilidad</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución de Rayleigh es</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución de Wald es</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución completa de Cauchy es</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución chi-cuadrado no central es</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución t es</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">La función de densidad de probabilidad para la distribución triangular es</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">La función de densidad de probabilidad es</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">La función de densidad de probabilidad de la distribución chi-cuadrado es</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">La funci&amp;oacute;n de densidad de probabilidad de la distribuci&amp;oacute;n normal, derivada primero por De Moivre y 200 a&amp;ntilde;os m&amp;aacute;s tarde por Gauss y Laplace de forma independiente &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , a menudo se denomina curva de campana debido a su forma caracter&amp;iacute;stica (ver el ejemplo a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="2297eee1a9ef2ae469ffb4ffe7c7db8f4e4f83da" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">La funci&amp;oacute;n de densidad de probabilidad de la distribuci&amp;oacute;n normal, derivada primero por De Moivre y 200 a&amp;ntilde;os m&amp;aacute;s tarde por Gauss y Laplace de forma independiente &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , a menudo se denomina curva de campana debido a su forma caracter&amp;iacute;stica (ver el ejemplo a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="31415e3883f5ad2cde00e0bf903f48cc5ab3d293" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">La función de densidad de probabilidad de la distribución uniforme es</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">Las entradas de probabilidad deben normalizarse.Como detalle de implementación,se ignora el valor de la última entrada y se supone que absorbe cualquier masa de probabilidad sobrante,pero no se debe confiar en ello.Una moneda sesgada que tiene el doble de peso en una cara que en la otra debe ser muestreada de esta manera:</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">La función de masa de probabilidad para la distribución de la serie logarítmica es</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">La función de masa de probabilidad de la distribución geométrica es</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">La función de masa de probabilidad de la distribución binomial negativa es</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">La probabilidad de éxito de un ensayo individual.</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">El problema aqu&amp;iacute; es que hay un argumento de dimensi&amp;oacute;n y dos argumentos de matriz, y nuestros mapas de tipos est&amp;aacute;n configurados para dimensiones que se aplican a una sola matriz (de hecho, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; no proporciona un mecanismo para asociar &lt;code&gt;len&lt;/code&gt; con &lt;code&gt;vec2&lt;/code&gt; que toma dos argumentos de entrada de Python ). La soluci&amp;oacute;n recomendada es la siguiente:</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">El problema está resuelto exactamente.En este caso,la función devuelve True sólo si hay un elemento compartido entre las matrices.</target>
        </trans-unit>
        <trans-unit id="4ad89e6d069e4dfa2e5a4dc8cd5ea0ef4b308ab4" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El producto de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; , elemento-sabio. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">El producto de una matriz vacía es el elemento neutro 1:</target>
        </trans-unit>
        <trans-unit id="75994948d8c7e15ea47031e7a198364fb67ad040" translate="yes" xml:space="preserve">
          <source>The project management structure can be found at our &lt;a href=&quot;dev/governance/index&quot;&gt;governance page&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">El tipo de datos promovidos.</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La pseudo matriz de Vandermonde. La forma de la matriz devuelta es &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , donde El &amp;uacute;ltimo &amp;iacute;ndice es el grado del polinomio de Chebyshev correspondiente. El dtype ser&amp;aacute; el mismo que el &lt;code&gt;x&lt;/code&gt; convertido .</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La matriz pseudo-Vandermonde. La forma de la matriz devuelta es &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , donde El &amp;uacute;ltimo &amp;iacute;ndice es el grado del polinomio de Hermite correspondiente. El dtype ser&amp;aacute; el mismo que el &lt;code&gt;x&lt;/code&gt; convertido .</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La matriz pseudo-Vandermonde. La forma de la matriz devuelta es &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , donde El &amp;uacute;ltimo &amp;iacute;ndice es el grado del polinomio de HermiteE correspondiente. El dtype ser&amp;aacute; el mismo que el &lt;code&gt;x&lt;/code&gt; convertido .</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La matriz pseudo-Vandermonde. La forma de la matriz devuelta es &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , donde El &amp;uacute;ltimo &amp;iacute;ndice es el grado del polinomio de Laguerre correspondiente. El dtype ser&amp;aacute; el mismo que el &lt;code&gt;x&lt;/code&gt; convertido .</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La matriz pseudo-Vandermonde. La forma de la matriz devuelta es &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , donde El &amp;uacute;ltimo &amp;iacute;ndice es el grado del polinomio de Legendre correspondiente. El dtype ser&amp;aacute; el mismo que el &lt;code&gt;x&lt;/code&gt; convertido .</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">El pseudo-inverso de &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; es una &lt;code&gt;matrix&lt;/code&gt; ejemplo, entonces tambi&amp;eacute;n lo es &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">El pseudo-inverso de una matriz A,denotado</target>
        </trans-unit>
        <trans-unit id="43268b21480b8908d11ac78845b26e8a85b3d3ad" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;F2PY&lt;/code&gt; &amp;ndash;&lt;em&gt;Fortran to Python interface generator&lt;/em&gt;&amp;ndash; is to provide a connection between Python and Fortran languages. F2PY is a part of &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; (&lt;code&gt;numpy.f2py&lt;/code&gt;) and also available as a standalone command line tool &lt;code&gt;f2py&lt;/code&gt; when &lt;code&gt;numpy&lt;/code&gt; is installed that facilitates creating/building Python C/API extension modules that make it possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">El prop&amp;oacute;sito de la verificaci&amp;oacute;n del recuento de referencias es asegurarse de que no use esta matriz como b&amp;uacute;fer para otro objeto de Python y luego reasigne la memoria. Sin embargo, los recuentos de referencias pueden aumentar de otras formas, por lo que si est&amp;aacute; seguro de que no ha compartido la memoria de esta matriz con otro objeto de Python, puede configurar &lt;code&gt;refcheck&lt;/code&gt; en False de forma segura .</target>
        </trans-unit>
        <trans-unit id="cd4694d2cc663a00201267e4370ce5da08336131" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to formalize the governance process used by the NumPy project in both ordinary and extraordinary situations, and to clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">El cuadrante (es decir, la rama) se elige de modo que &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; sea ​​el &amp;aacute;ngulo con signo en radianes entre el rayo que termina en el origen y pasa por el punto (1,0), y el rayo que termina en el origen y pasa a trav&amp;eacute;s del punto ( &lt;code&gt;x2&lt;/code&gt; , &lt;code&gt;x1&lt;/code&gt; ). (Tenga en cuenta la inversi&amp;oacute;n de roles: la &quot; coordenada &lt;code&gt;y&lt;/code&gt; &quot; es el primer par&amp;aacute;metro de funci&amp;oacute;n, la &quot; coordenada &lt;code&gt;x&lt;/code&gt; &quot; es el segundo.) Por convenci&amp;oacute;n IEEE, esta funci&amp;oacute;n se define para &lt;code&gt;x2&lt;/code&gt; = +/- 0 y para uno o ambos de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; = +/- inf (ver Notas para valores espec&amp;iacute;ficos).</target>
        </trans-unit>
        <trans-unit id="a6498ac12126ab973a1934f179594a987afb7844" translate="yes" xml:space="preserve">
          <source>The quick and smart way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0770ff789fdc985036394e871929fde93eb9a9" translate="yes" xml:space="preserve">
          <source>The quick way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d041efcac5d4fa984fd9e585c0e674ab20c24a98" translate="yes" xml:space="preserve">
          <source>The quickest way to wrap the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; to Python is to run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef42c4d34d6fe180bfd554c782fbff1345844332" translate="yes" xml:space="preserve">
          <source>The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">Los valores aleatorios se simulan mediante un método basado en el rechazo,por lo que,en promedio,se requiere más de un valor del RNG subyacente para generar un solo sorteo.</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">Los valores aleatorios producidos por &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; se&lt;/a&gt; originan en un BitGenerator. Los BitGenerators no proporcionan directamente n&amp;uacute;meros aleatorios y solo contienen m&amp;eacute;todos utilizados para sembrar, obtener o establecer el estado, saltar o avanzar el estado, y para acceder a contenedores de bajo nivel para consumo por c&amp;oacute;digo que pueden acceder de manera eficiente a las funciones proporcionadas, por ejemplo, &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">La variante aleatoria de la distribución F (también conocida como distribución Fisher)es una distribución de probabilidad continua que surge en las pruebas de ANOVA,y es la relación de dos variantes chi-cuadrado.</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">El rango de la matriz de coeficientes en el ajuste por m&amp;iacute;nimos cuadrados es deficiente. La advertencia solo se genera si &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False.</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">El rango de la matriz de coeficientes en el ajuste por m&amp;iacute;nimos cuadrados es deficiente. La advertencia solo se genera si &lt;code&gt;full&lt;/code&gt; = False.</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">El rango de la matriz de coeficientes en el ajuste por m&amp;iacute;nimos cuadrados es deficiente. La advertencia solo se genera si &lt;code&gt;full&lt;/code&gt; = False. Las advertencias se pueden desactivar</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">El tipo de interés se calcula resolviendo iterativamente la ecuación (no lineal):</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">Las partes reales e imaginarias de los números complejos se redondean por separado.El resultado de redondear un flotador es un flotador.</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">El componente real del argumento complejo. Si &lt;code&gt;val&lt;/code&gt; es real, se usa el tipo de &lt;code&gt;val&lt;/code&gt; para la salida. Si &lt;code&gt;val&lt;/code&gt; tiene elementos complejos, el tipo devuelto es float.</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">La parte real de la matriz.</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">La parte real del conjunto de máscaras.</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">El enfoque recomendado para la iteraci&amp;oacute;n multiproceso es crear primero un iterador con los indicadores &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; y posiblemente &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; . Cree una copia de este iterador para cada hilo (menos uno para el primer iterador). Luego, tome el rango de &amp;iacute;ndice de iteraci&amp;oacute;n &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; y div&amp;iacute;dalo en tareas, por ejemplo, usando un ciclo TBB paralelo_for. Cuando un hilo obtiene una tarea para ejecutar, luego usa su copia del iterador llamando a &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; e iterando sobre el rango completo.</target>
        </trans-unit>
        <trans-unit id="8ebf9173277c6dd7ef8e96321015ddb67f853d5b" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">El generador recomendado para uso general es &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; . Es estad&amp;iacute;sticamente de alta calidad, con todas las funciones y r&amp;aacute;pido en la mayor&amp;iacute;a de las plataformas, pero algo lento cuando se compila para procesos de 32 bits.</target>
        </trans-unit>
        <trans-unit id="1ecded761aa3b896fb25df737596c852ad7e09c5" translate="yes" xml:space="preserve">
          <source>The recommended practice for initializing &lt;code&gt;mask&lt;/code&gt; with a scalar boolean value is to use &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; rather than &lt;code&gt;np.True_&lt;/code&gt;/&lt;code&gt;np.False_&lt;/code&gt;. The reason is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">La forma recomendada de marcar una o varias entradas espec&amp;iacute;ficas de una matriz enmascarada como inv&amp;aacute;lidas es asignarles el valor especial &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">La forma recomendada de almacenar y cargar datos:</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">La función de reducción es una generalización de las funciones de reducción y acumulación.Implementa una reducción sobre los rangos de la matriz de entrada especificados por los índices.El argumento de índices extra se comprueba para asegurarse de que cada entrada no es demasiado grande para la matriz de entrada a lo largo de la dimensión seleccionada antes de que se realicen los cálculos del bucle.La implementación del bucle se maneja usando código que es muy similar al código de reducción repetido tantas veces como elementos haya en la entrada de índices.En particular:el primer puntero de entrada pasado al bucle de cálculo 1-D subyacente apunta a la matriz de entrada en la ubicación correcta indicada por la matriz de índices.Además,el puntero de salida y el segundo puntero de entrada pasado al bucle 1-D subyacente apuntan a la misma posición en la memoria.El tamaño del bucle de cálculo 1-D se fija para que sea la diferencia entre el índice actual y el siguiente índice (cuando el índice actual es el último índice,entonces se supone que el siguiente índice es la longitud de la matriz a lo largo de la dimensión seleccionada).De esta manera,el bucle 1-D implementará una reducción sobre los índices especificados.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">La matriz reducida. Si se suministr&amp;oacute; &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; es una referencia a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Los valores reducidos. Si se suministr&amp;oacute; &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; es una referencia a &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">La expresi&amp;oacute;n regular. El valor predeterminado es Ninguno, en cuyo caso se &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; valor predeterminado de nose ( re.compile (r '(?: ^ | [\ B _ \.% S -]) [Tt] est'% os.sep) ). Si &lt;code&gt;testmatch&lt;/code&gt; es una cadena, primero se compila en una expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">El rendimiento relativo en Linux de 64 bits y en Windows de 64 bits es muy similar.</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">El parámetro de tolerancia relativa (véase Notas).</target>
        </trans-unit>
        <trans-unit id="3e03b7da726f71e414e37015d45ecfcbfb010c83" translate="yes" xml:space="preserve">
          <source>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96164d49d0f26476a5104ba2b3a4aa7deeeccb58" translate="yes" xml:space="preserve">
          <source>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f91fe84c2d74d72d982ce47fb9a64711667ccc" translate="yes" xml:space="preserve">
          <source>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El resto de la divisi&amp;oacute;n de &lt;code&gt;x1&lt;/code&gt; por &lt;code&gt;x2&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">La alineación requerida (bytes)de este tipo de datos según el compilador.</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">Los tipos de datos requeridos de los operandos.Si se habilita la copia o el almacenamiento en memoria intermedia,los datos se convertirán a/desde sus tipos originales.</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">El tipo de datos requerido.Si ninguno conserva el tipo de datos actual.Si su aplicación requiere que los datos estén en el orden de bytes nativos,incluya una especificación de bytes como parte de la especificación del dtype.</target>
        </trans-unit>
        <trans-unit id="65e5c657147f8f6206b51f162cff2b0b35eade26" translate="yes" xml:space="preserve">
          <source>The requirements flag allows specification of what kind of array is acceptable. If the object passed in does not satisfy this requirements then a copy is made so that thre returned object will satisfy the requirements. these ndarray can use a very generic pointer to memory. This flag allows specification of the desired properties of the returned array object. All of the flags are explained in the detailed API chapter. The flags most commonly needed are &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt;&lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">La lista de requisitos puede ser cualquiera de los siguientes</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">La operaci&amp;oacute;n de remodelaci&amp;oacute;n no puede garantizar que no se har&amp;aacute; una copia, para modificar la forma en su lugar, use &lt;code&gt;a.shape = s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c22a2794d4be1171f3bb3051bbeb72ad7588dd" translate="yes" xml:space="preserve">
          <source>The rest of the story</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b262525b3075625bc8ca490c385d67e383e0b64" translate="yes" xml:space="preserve">
          <source>The rest of this document discusses working on the NumPy code base and documentation. We&amp;rsquo;re in the process of updating our descriptions of other activities and roles. If you are interested in these other activities, please contact us! You can do this via the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;, or on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (open an issue or comment on a relevant issue). These are our preferred communication channels (open source is open by nature!), however if you prefer to discuss in private first, please reach out to our community coordinators at &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; or &lt;code&gt;numpy-team.slack.com&lt;/code&gt; (send an email to &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; for an invite the first time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">El resto de esta p&amp;aacute;gina le dar&amp;aacute; una idea b&amp;aacute;sica de c&amp;oacute;mo agregar pruebas unitarias a m&amp;oacute;dulos en SciPy. Es extremadamente importante para nosotros tener pruebas unitarias extensas ya que este c&amp;oacute;digo ser&amp;aacute; utilizado por cient&amp;iacute;ficos e investigadores y est&amp;aacute; siendo desarrollado por una gran cantidad de personas repartidas por todo el mundo. Por lo tanto, si est&amp;aacute; escribiendo un paquete que le gustar&amp;iacute;a formar parte de SciPy, escriba las pruebas a medida que desarrolla el paquete. Adem&amp;aacute;s, dado que gran parte de SciPy es c&amp;oacute;digo heredado que se escribi&amp;oacute; originalmente sin pruebas unitarias, todav&amp;iacute;a hay varios m&amp;oacute;dulos que a&amp;uacute;n no tienen pruebas. Si&amp;eacute;ntase libre de elegir uno de estos m&amp;oacute;dulos y desarrollar pruebas para &amp;eacute;l mientras lee esta introducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">El resultado puede utilizarse para construir una fecha-hora que utilice las mismas unidades que un timedelta</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">El resultado depende de la anchura del bit:</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">&amp;iexcl;El resultado &lt;strong&gt;no&lt;/strong&gt; es un MaskedArray!</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">El resultado es un inverso para &lt;code&gt;a&lt;/code&gt; relativo a la operaci&amp;oacute;n &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; , es decir, hasta una precisi&amp;oacute;n de punto flotante, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; es el tensor de &quot;identidad&quot; para el tensordot operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1513bc4b365343f54e37e3a0463aec42e49631e5" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being &lt;em&gt;stretched&lt;/em&gt; during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt; are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234fdc2574c2d15c385cc66cebde459f6f8d571" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being stretched during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt;, as shown in &lt;a href=&quot;#figure-1&quot;&gt;Figure 1&lt;/a&gt;, are simply copies of the original scalar. The stretching analogy is only conceptual. numpy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible. Because &lt;a href=&quot;#example-2&quot;&gt;Example 2&lt;/a&gt; moves less memory, (&lt;code&gt;b&lt;/code&gt; is a scalar, not an array) around during the multiplication, it is about 10% faster than &lt;a href=&quot;#example-1&quot;&gt;Example 1&lt;/a&gt; using the standard numpy on Windows 2000 with one million element arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">El resultado se rellena a bytes completos insertando cero bits al final.</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">El resultado se devuelve como una matriz booleana.</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">El resultado es:</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">El resultado enmascara los valores que est&amp;aacute;n enmascarados en &lt;code&gt;m1&lt;/code&gt; o &lt;code&gt;m2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">El resultado puede ser una vista en &lt;code&gt;m1&lt;/code&gt; o &lt;code&gt;m2&lt;/code&gt; si el otro es &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (es decir, falso).</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">Se &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; resultado de cPickle.loads (strg) .</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">El resultado de &lt;code&gt;x1 * 2**x2&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">El resultado de agrupar la matriz de entrada. La longitud de &lt;code&gt;out&lt;/code&gt; es igual a &lt;code&gt;np.amax(x)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6126cff082b1038f45f0cf4b879a12e8909f651" translate="yes" xml:space="preserve">
          <source>The result of indexing with a multi-field index is a view into the original array, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">El resultado de enmascarar &lt;code&gt;a&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; where es Verdadero.</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">El resultado de enmascarar &lt;code&gt;x&lt;/code&gt; fue aproximadamente igual al &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">El resultado de enmascarar &lt;code&gt;x&lt;/code&gt; es igual a &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">El resultado de repetir &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080be4f2b719d17ca857f6ff65fc2c9ddc4f8015" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">El resultado de la llamada a la &lt;code&gt;function&lt;/code&gt; se devuelve directamente. Por lo tanto, la forma de la &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; est&amp;aacute; completamente determinada por la &lt;code&gt;function&lt;/code&gt; . Si la &lt;code&gt;function&lt;/code&gt; devuelve un valor escalar, la forma de la funci&amp;oacute;n &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; no coincidir&amp;iacute;a con el par&amp;aacute;metro de &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">El resultado de la llamada a la &lt;code&gt;function&lt;/code&gt; se devuelve directamente. Por lo tanto, la forma de la &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; est&amp;aacute; completamente determinada por la &lt;code&gt;function&lt;/code&gt; . Si la &lt;code&gt;function&lt;/code&gt; devuelve un valor escalar, la forma de la funci&amp;oacute;n &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; no coincidir&amp;iacute;a con el par&amp;aacute;metro de &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">El resultado de la inversión real 2-D FFT.</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">El resultado de la operaci&amp;oacute;n de m&amp;oacute;dulo para dividendos y divisores negativos est&amp;aacute; sujeto a convenciones. Para &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; , el signo del resultado es el signo del dividendo, mientras que para el &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; el signo del resultado es el signo del divisor. La funci&amp;oacute;n &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; es equivalente a la funci&amp;oacute;n &lt;code&gt;rem&lt;/code&gt; de Matlab (TM) .</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">El resultado del verdadero 2-D FFT.</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">El resultado de esto es siempre una matriz de 2d,con una fila para cada elemento que no sea cero.</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">El resultado de recortar la entrada.El tipo de datos de entrada se conserva.</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">El tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="101ce3a3f58e25741f8924a6b8d0cfd25472eeff" translate="yes" xml:space="preserve">
          <source>The result will be multidimensional if y has more dimensions than b. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">El resultado.</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">La aproximación resultante de</target>
        </trans-unit>
        <trans-unit id="8f5a6724cd845387db9fbc4a8e08fe47ae3e4ec1" translate="yes" xml:space="preserve">
          <source>The resulting array is a view into the original array. It shares the same memory locations and writing to the view will modify the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">Por tanto, la matriz resultante tiene un valor &lt;code&gt;fn(x, y, z)&lt;/code&gt; en la coordenada &lt;code&gt;(x, y, z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">La trayectoria resultante indica qué términos de la contracción de entrada deben contraerse primero,el resultado de esta contracción se añade al final de la lista de contracción.Esta lista puede entonces iterarse hasta que se completen todas las contracciones intermedias.</target>
        </trans-unit>
        <trans-unit id="b0397bb7d27e88275099d7a9e2663ecd158fec65" translate="yes" xml:space="preserve">
          <source>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained &lt;code&gt;A(N)&lt;/code&gt; instead of &lt;code&gt;A(*)&lt;/code&gt; and so forth with &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then I could obtain (nearly) the same interface simply by placing the &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; comment line in the source code. The only difference is that &lt;code&gt;N&lt;/code&gt; would be an optional input that would default to the length of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">Los resultados sólo se han probado hasta el grado 100 grados superiores puede ser problemático.Los pesos se determinan utilizando el hecho de que</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">Los resultados solo se han probado hasta el grado 100, los grados m&amp;aacute;s altos pueden ser problem&amp;aacute;ticos. Para Gauss-Chebyshev hay soluciones de forma cerrada para los puntos y pesos muestrales. Si n = &lt;code&gt;deg&lt;/code&gt; , entonces</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">Los resultados sólo se han probado hasta el grado 100,los grados superiores pueden ser problemáticos.Los pesos se determinan utilizando el hecho de que</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">Los resultados se colocar&amp;aacute;n en esta matriz. Puede ser la matriz de entrada para el recorte en el lugar. &lt;code&gt;out&lt;/code&gt; debe tener la forma correcta para contener la salida. Se conserva su tipo.</target>
        </trans-unit>
        <trans-unit id="c6b62851dacdc54d8864ac2edf1604fc62b66dd6" translate="yes" xml:space="preserve">
          <source>The return statement should &lt;em&gt;not&lt;/em&gt; get redundant parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">El tipo de retorno siempre será un tipo escalar inexacto (es decir,de punto flotante),incluso si todos los arreglos son arreglos enteros.Si una de las entradas es un arreglo de números enteros,el tipo de precisión mínima que se devuelve es un tipo d de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">El valor de retorno es 0 en el éxito,-1 en el fracaso.</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">El valor de retorno tiene la misma forma y tipo que &lt;code&gt;M&lt;/code&gt; ; Si el exponente es positivo o cero, entonces el tipo de los elementos es el mismo que los de &lt;code&gt;M&lt;/code&gt; . Si el exponente es negativo, los elementos son de punto flotante.</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">El valor de retorno de las funciones de conversi&amp;oacute;n fallidas que se llaman usando la sintaxis &quot;O &amp;amp;&quot; en &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; similares a PyArg_ParseTuple .</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">El valor de retorno de las funciones de conversi&amp;oacute;n exitosas que se llaman usando la sintaxis &amp;ldquo;O &amp;amp;&amp;rdquo; en &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; similares a PyArg_ParseTuple .</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">El valor de retorno, False si &lt;code&gt;x&lt;/code&gt; es de un tipo complejo.</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">El valor devuelto, True si &lt;code&gt;x&lt;/code&gt; es de tipo complejo o tiene al menos un elemento complejo.</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">La matriz devuelta tiene el mismo tipo que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">La matriz devuelta es siempre 1D.</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">La matriz devuelta es siempre una matriz estructurada,y se construye a partir de todas las coincidencias de la expresión regular del archivo.Los grupos de la expresión regular se convierten en campos de la matriz estructurada.</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">Se garantizará que la matriz devuelta tenga los requisitos enumerados haciendo una copia si es necesario.</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">La matriz devuelta tendr&amp;aacute; al menos dimensiones &lt;code&gt;ndmin&lt;/code&gt; . De lo contrario, los ejes unidimensionales se comprimir&amp;aacute;n. Valores legales: 0 (predeterminado), 1 o 2.</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">La clase devuelta puede ser de un tipo diferente a la instancia actual y/o tener un dominio y/o una ventana diferente.</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">La matriz flotante devuelta &lt;code&gt;f&lt;/code&gt; contiene los centros de intervalos de frecuencia en ciclos por unidad del espaciado de muestra (con cero al comienzo). Por ejemplo, si el espaciado de la muestra est&amp;aacute; en segundos, entonces la unidad de frecuencia es ciclos / segundo.</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">Los índices devueltos serán válidos para acceder a las matrices de forma (n,n).</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">La lista devuelta contiene matrices de dtype double, complex double u object. Un argumento 1-d de forma &lt;code&gt;(N,)&lt;/code&gt; se analiza en &lt;code&gt;N&lt;/code&gt; matrices de tama&amp;ntilde;o uno; un argumento 2-d de forma &lt;code&gt;(M,N)&lt;/code&gt; se analiza en &lt;code&gt;M&lt;/code&gt; matrices de tama&amp;ntilde;o &lt;code&gt;N&lt;/code&gt; (es decir, se &quot;analiza por fila&quot;); y una matriz de dimensiones superiores genera un error de valor si no se reforma primero en una matriz 1-d o 2-d.</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">El objeto devuelto es un objeto de &lt;em&gt;subtipo de&lt;/em&gt; tipo Python , que debe ser un subtipo de &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; . La matriz tiene &lt;em&gt;nd&lt;/em&gt; dimensiones, descritas por &lt;em&gt;dims&lt;/em&gt; . El descriptor de tipo de datos de la nueva matriz es &lt;em&gt;descr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32e057c6946960f31384643bb71f5913a86433e2" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">El orden devuelto &lt;code&gt;m&lt;/code&gt; antiderivada &lt;code&gt;P&lt;/code&gt; del polinomio &lt;code&gt;p&lt;/code&gt; satisface</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">El puntero devuelto guardará una referencia a la matriz.</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">La tupla devuelta se puede pasar como segundo argumento de &lt;code&gt;numpy.datetime64&lt;/code&gt; y &lt;code&gt;numpy.timedelta64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">La tupla devuelta tiene los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">El car&amp;aacute;cter de tipo devuelto debe representar el dtype de tama&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o de modo que una matriz del tipo devuelto pueda manejar los datos de una matriz de todos los tipos en &lt;code&gt;typechars&lt;/code&gt; (o si &lt;code&gt;typechars&lt;/code&gt; es una matriz, entonces su dtype.char).</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">El Ufunc retornado siempre devuelve las matrices PyObject.</target>
        </trans-unit>
        <trans-unit id="a3367f678ba189a0a7553569bd4ae4f1aabaa222" translate="yes" xml:space="preserve">
          <source>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">Los valores devueltos definen un mapa lineal &lt;code&gt;off + scl*x&lt;/code&gt; que se aplica a los argumentos de entrada antes de evaluar la serie. El mapa depende del &lt;code&gt;domain&lt;/code&gt; y la &lt;code&gt;window&lt;/code&gt; ; si el &lt;code&gt;domain&lt;/code&gt; actual es igual a la &lt;code&gt;window&lt;/code&gt; el mapa resultante es la identidad. Si los coeficientes de la instancia de la serie se van a utilizar por s&amp;iacute; mismos fuera de esta clase, entonces la funci&amp;oacute;n lineal debe sustituirse por la &lt;code&gt;x&lt;/code&gt; en la representaci&amp;oacute;n est&amp;aacute;ndar de los polinomios base.</target>
        </trans-unit>
        <trans-unit id="0b9b48003d17ce5e05cd985e616cb02707b4abeb" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;__array_finalize__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">Las estimaciones de ra&amp;iacute;ces se obtienen como los valores propios de la matriz acompa&amp;ntilde;ante. Las ra&amp;iacute;ces alejadas del origen del plano complejo pueden tener grandes errores debido a la inestabilidad num&amp;eacute;rica de la serie de potencias para tales valores. Las ra&amp;iacute;ces con multiplicidad mayor que 1 tambi&amp;eacute;n mostrar&amp;aacute;n errores m&amp;aacute;s grandes ya que el valor de la serie cerca de dichos puntos es relativamente insensible a los errores en las ra&amp;iacute;ces. Las ra&amp;iacute;ces aisladas cerca del origen se pueden mejorar mediante algunas iteraciones del m&amp;eacute;todo de Newton.</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">Las estimaciones de ra&amp;iacute;ces se obtienen como los valores propios de la matriz acompa&amp;ntilde;ante. Las ra&amp;iacute;ces alejadas del origen del plano complejo pueden tener grandes errores debido a la inestabilidad num&amp;eacute;rica de la serie para tales valores. Las ra&amp;iacute;ces con multiplicidad mayor que 1 tambi&amp;eacute;n mostrar&amp;aacute;n errores m&amp;aacute;s grandes ya que el valor de la serie cerca de dichos puntos es relativamente insensible a los errores en las ra&amp;iacute;ces. Las ra&amp;iacute;ces aisladas cerca del origen se pueden mejorar mediante algunas iteraciones del m&amp;eacute;todo de Newton.</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">Las raíces del polinomio,donde auto(x)==0</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">La dimensión de las filas de los conjuntos para los cuales los índices devueltos serán válidos.</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">El argumento rtype especifica el tipo de datos sobre el que deber&amp;iacute;a tener lugar la reducci&amp;oacute;n. Esto es importante si el tipo de datos de la matriz no es lo suficientemente &quot;grande&quot; para manejar la salida. De forma predeterminada, todos los tipos de datos enteros se hacen al menos tan grandes como &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt; para las funciones de &quot;sumar&quot; y &quot;multiplicar&quot; (que forman la base de las funciones media, suma, acumulaci&amp;oacute;n, prod y cumprod).</target>
        </trans-unit>
        <trans-unit id="81acb42027d32e73c24e9573f794b96cf5d260da" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec28ce661286e5b1ead8f4ea14b439b8431742d" translate="yes" xml:space="preserve">
          <source>The rule governing whether two arrays have compatible shapes for broadcasting can be expressed in a single sentence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">Las reglas de compatibilidad de la ABI y la API pueden resumirse de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">El mismo análisis podría hacerse con varios tipos de interés y/o pagos y/o cantidades totales diferentes para producir un cuadro completo.</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">La misma función puede funcionar en una matriz de 4-D:</target>
        </trans-unit>
        <trans-unit id="54bfa0763e872f148814a7d73d89f2039603e607" translate="yes" xml:space="preserve">
          <source>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db94598647ae75e98a229d31f17501768537975a" translate="yes" xml:space="preserve">
          <source>The same results can be obtained by using the name of the second column (&lt;code&gt;&quot;p&quot;&lt;/code&gt;) as key instead of its index (1):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">Lo mismo funciona para el máximo y el mínimo,si se amplían las dimensiones:</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">Los puntos muestrales correspondientes a los valores de &lt;code&gt;y&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es Ninguno, se supone que los puntos muestrales est&amp;aacute;n separados &lt;code&gt;dx&lt;/code&gt; de manera uniforme . El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">La escala de la distribución gamma.Debe ser no negativa.El valor por defecto es igual a 1.</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">El parámetro de escala de la distribución.El valor por defecto es 1.Debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">El parámetro de la escala,</target>
        </trans-unit>
        <trans-unit id="162cbdbbbf1e2c84bee29866f841c84cd6b13d80" translate="yes" xml:space="preserve">
          <source>The scaling of the covariance matrix in &lt;code&gt;np.polyfit&lt;/code&gt; is different</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">Se recomienda la implementación de la scipy sobre esta función:es una ufunc apropiada escrita en C,y más de un orden de magnitud más rápido.</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">El segundo elemento, &lt;em&gt;field_dtype&lt;/em&gt; , puede ser cualquier cosa que pueda interpretarse como un tipo de datos.</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">El segundo es configurar el manejador de errores en 'log', usando &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; . Los errores de punto flotante desencadenan una llamada al m&amp;eacute;todo 'escribir' del objeto proporcionado.</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">La segunda cuestión que hay que entender es cómo los índices corresponden al orden en que la matriz se almacena en la memoria.En Fortran,el primer índice es el que varía más rápidamente cuando se mueve a través de los elementos de una matriz bidimensional,ya que se almacena en la memoria.Si se adopta la convención matricial para la indexación,esto significa que la matriz se almacena una columna a la vez (ya que el primer índice se mueve a la siguiente fila a medida que cambia).Por lo tanto,Fortran se considera un lenguaje de columnas.C tiene justo la convención opuesta.En C,el último índice cambia más rápidamente a medida que uno se mueve a través de la matriz como se almacena en la memoria.Por lo tanto,C es un lenguaje de Fila Mayor.La matriz se almacena por filas.Nótese que en ambos casos se presume que se está utilizando la convención de la matriz para la indexación,es decir,tanto para Fortran como para C,el primer índice es la fila.Nótese que esta convención implica que la convención de indexación es invariable y que el orden de los datos cambia para mantenerla así.</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">El m&amp;eacute;todo self.paths (&amp;hellip;) se aplica a todas las listas que pueden contener rutas.</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">La separaci&amp;oacute;n entre elementos para cada dimensi&amp;oacute;n (el 'paso'). No es necesario que sea un m&amp;uacute;ltiplo del tama&amp;ntilde;o del elemento.</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">Las series en este contexto son sumas finitas de las correspondientes funciones de base polinómica multiplicadas por coeficientes.Por ejemplo,una serie de potencia se ve como</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">La instancia de la serie a ser convertida.</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">La serie se reduce a grados &lt;code&gt;deg&lt;/code&gt; descartando los t&amp;eacute;rminos de orden superior. El valor de &lt;code&gt;deg&lt;/code&gt; debe ser un n&amp;uacute;mero entero no negativo.</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">La serie se reduce al &lt;code&gt;size&lt;/code&gt; longitud descartando los t&amp;eacute;rminos de alto grado. El valor de &lt;code&gt;size&lt;/code&gt; debe ser un n&amp;uacute;mero entero positivo.</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">El conjunto de c&amp;oacute;decs disponibles proviene de la biblioteca est&amp;aacute;ndar de Python y se puede ampliar en tiempo de ejecuci&amp;oacute;n. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte el m&amp;oacute;dulo de &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">El conjunto de códecs disponibles proviene de la biblioteca estándar de Python,y puede ser ampliado en tiempo de ejecución.Para obtener más información,consulte el módulo de códecs.</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">El conjunto de caracteres del que se elige el car&amp;aacute;cter devuelto. El conjunto predeterminado es 'GDFgdf'.</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">El conjunto de funciones que convierten los datos de una columna en un valor. Los convertidores tambi&amp;eacute;n se pueden utilizar para proporcionar un valor predeterminado para los datos faltantes: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">El conjunto de valores int no es un subconjunto de los valores uint para tipos con el mismo n&amp;uacute;mero de bits, algo que no se refleja en &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; , pero se maneja como un caso especial en PyArray_ResultType.</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El conjunto de valores int no es un subconjunto de los valores uint para tipos con el mismo n&amp;uacute;mero de bits, algo que no se refleja en &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; , pero se maneja como un caso especial en &lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">El conjunto de cadenas correspondientes a los datos que faltan.</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">El conjunto de valores que se usará como predeterminado cuando falten los datos.</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">La funci&amp;oacute;n de configuraci&amp;oacute;n para los tres m&amp;eacute;todos es &lt;code&gt;construct_reduce&lt;/code&gt; . Esta funci&amp;oacute;n crea un objeto de bucle reductor y lo llena con los par&amp;aacute;metros necesarios para completar el bucle. Todos los m&amp;eacute;todos solo funcionan en ufuncs que toman 2 entradas y devuelven 1 salida. Por lo tanto, el bucle 1-D subyacente se selecciona asumiendo una firma de [ &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; ] donde &lt;code&gt;otype&lt;/code&gt; es el tipo de datos de reducci&amp;oacute;n solicitado. El tama&amp;ntilde;o del b&amp;uacute;fer y el manejo de errores se recuperan del almacenamiento global (por subproceso). Para arreglos peque&amp;ntilde;os que est&amp;aacute;n mal alineados o tienen un tipo de datos incorrecto, se realiza una copia para que se use la secci&amp;oacute;n de c&amp;oacute;digo sin b&amp;uacute;fer. Luego, se selecciona la estrategia de bucle. Si hay 1 elemento o 0 elementos en la matriz, se selecciona un m&amp;eacute;todo de bucle simple. Si la matriz no est&amp;aacute; desalineada y tiene el tipo de datos correcto, se selecciona el bucle escalonado. De lo contrario, se debe realizar un bucle en b&amp;uacute;fer. A continuaci&amp;oacute;n, se establecen los par&amp;aacute;metros de bucle y se construye la matriz de retorno. La matriz de salida tiene una forma diferente dependiendo de si el m&amp;eacute;todo es reducir, acumular o reducir. Si ya se proporciona una matriz de salida, se verifica su forma. Si la matriz de salida no es C-contigua, alineada,y del tipo de datos correcto, entonces se realiza una copia temporal con el indicador WRITEBACKIFCOPY establecido. De esta manera, los m&amp;eacute;todos podr&amp;aacute;n funcionar con una matriz de salida con buen comportamiento, pero el resultado se copiar&amp;aacute; de nuevo en la matriz de salida verdadera cuando&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; se llama al finalizar la funci&amp;oacute;n. Por &amp;uacute;ltimo, los iteradores se configuran para recorrer el eje correcto (seg&amp;uacute;n el valor del eje proporcionado al m&amp;eacute;todo) y la rutina de configuraci&amp;oacute;n vuelve a la rutina de c&amp;aacute;lculo real.</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">La forma (siempre contigua en forma de C)del subconjunto como una tupla de Pitón.</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">La forma y el tipo de datos de &lt;code&gt;a&lt;/code&gt; definen estos mismos atributos de la matriz devuelta.</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">La forma y el tipo de datos del &lt;code&gt;prototype&lt;/code&gt; definen estos mismos atributos de la matriz devuelta.</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">La forma de la matriz en la que se aplican los &amp;iacute;ndices de &lt;code&gt;multi_index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">La forma de cada salida se determina a partir de las dimensiones del bucle m&amp;aacute;s las dimensiones del n&amp;uacute;cleo de la salida.</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">La forma del conjunto se conserva,pero los elementos se reordenan.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">La forma de la matriz a ser iterada.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">La forma de la matriz que se utilizar&amp;aacute; para desentra&amp;ntilde;ar &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">La forma de la matriz.</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">La forma del resultado emitido (solo se utilizan &lt;code&gt;nd&lt;/code&gt; ranuras).</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">La forma del conjunto deseado.</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">La forma de la distribución gamma.Debe ser no negativa.</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">La forma de la red.</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">La forma de la nueva matriz. Por defecto es &lt;code&gt;x.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">La forma de la salida depende del tama&amp;ntilde;o de los &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; y puede ser mayor que &lt;code&gt;a&lt;/code&gt; (esto sucede si &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">La forma del valor de retorno se describe arriba.</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">La forma de la matriz devuelta se describe arriba.</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">La forma de la matriz devuelta es &lt;code&gt;x.shape + (order,)&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">El parámetro de la forma debe ser dado si se convierte de un tipo POINTER.El parámetro de forma se ignora si se convierte de una matriz ctypes</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">La propiedad de forma se usa generalmente para obtener la forma actual de una matriz, pero tambi&amp;eacute;n se puede usar para remodelar la matriz en el lugar asign&amp;aacute;ndole una tupla de dimensiones de matriz. Al igual que con &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; , una de las nuevas dimensiones de forma puede ser -1, en cuyo caso su valor se infiere del tama&amp;ntilde;o de la matriz y las dimensiones restantes. La remodelaci&amp;oacute;n de una matriz en el lugar fallar&amp;aacute; si se requiere una copia.</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">Las formas de x,y,y la condición se transmiten juntas:</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">La matriz cambiada.</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">El signo de &lt;code&gt;x2&lt;/code&gt; se copia en &lt;code&gt;x1&lt;/code&gt; . Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El signo de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">La firma define la dimensionalidad &quot;central&quot; de las variables de entrada y salida y, por lo tanto, tambi&amp;eacute;n define la contracci&amp;oacute;n de las dimensiones. La firma est&amp;aacute; representada por una cadena con el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">La firma determina cómo las dimensiones de cada matriz de entrada/salida se dividen en dimensiones de núcleo y bucle:</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">El más simple y rápido estimador.Sólo tiene en cuenta el tamaño de los datos.</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">El caso m&amp;aacute;s simple de indexaci&amp;oacute;n con &lt;em&gt;N&lt;/em&gt; n&amp;uacute;meros enteros devuelve una &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;matriz escalar que&lt;/a&gt; representa el elemento correspondiente. Como en Python, todos los &amp;iacute;ndices est&amp;aacute;n basados ​​en cero: para el &lt;em&gt;i&lt;/em&gt; -&amp;eacute;simo &amp;iacute;ndice</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">La simulación de una matriz de estilo C no está completa para las matrices de 2 y 3 dimensiones.Por ejemplo,las matrices simuladas de punteros no pueden ser pasadas a subrutinas que esperan matrices específicas y definidas estáticamente de 2 y 3 dimensiones.Para pasar a las funciones que requieren ese tipo de entradas,se debe definir estáticamente la matriz requerida y copiar los datos.</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">La función sincera es</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">La función sinc se utiliza en diversas aplicaciones de procesamiento de señales,como el antialiasing,la construcción de un filtro de remuestreo Lanczos y la interpolación.</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">El seno es una de las funciones fundamentales de la trigonometría (el estudio matemático de los triángulos).Consideremos un círculo de radio 1 centrado en el origen.Un rayo entra desde el</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El seno de cada elemento de x. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">La llamada de un solo hilo utiliza directamente el BitGenerator.</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">La situación con el numpy hace que este asunto sea aún más complicado.La maquinaria interna de las matrices de numpy es lo suficientemente flexible para aceptar cualquier orden de índices.Uno puede simplemente reordenar los índices manipulando la información de zancadas internas de los arreglos sin reordenar los datos en absoluto.NumPy sabrá cómo asignar el nuevo orden de los índices a los datos sin moverlos.</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">El tamaño en cada dimensión de la forma de salida es el máximo de todos los tamaños de entrada en esa dimensión.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">El tamaño de cada dimensión del conjunto.</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">El tama&amp;ntilde;o de cada palabra. Esto solo deber&amp;iacute;a ser &lt;code&gt;uint32&lt;/code&gt; o &lt;code&gt;uint64&lt;/code&gt; . Las cadenas ( &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ) est&amp;aacute;n bien. Tenga en cuenta que solicitar &lt;code&gt;uint64&lt;/code&gt; extraer&amp;aacute; el doble de bits que &lt;code&gt;uint32&lt;/code&gt; para las mismas &lt;code&gt;n_words&lt;/code&gt; . Esto es una conveniencia para &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; matrices `uint64 .</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">El tamaño de la matriz menos 1 en cada dimensión.</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">El tamaño de las matrices para las que los índices devueltos serán válidos.</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">El tamaño,a lo largo de cada dimensión,de las matrices para las que se pueden utilizar los índices devueltos.</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">El objeto más pequeño para comprobar.</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">La potencia positiva más pequeña de la base (2)que causa el desbordamiento.</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">El n&amp;uacute;mero &amp;uacute;til positivo m&amp;aacute;s peque&amp;ntilde;o. El tipo de &lt;code&gt;tiny&lt;/code&gt; es un tipo de punto flotante apropiado.</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero representable m&amp;aacute;s peque&amp;ntilde;o, t&amp;iacute;picamente &lt;code&gt;-max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">El n&amp;uacute;mero positivo representable m&amp;aacute;s peque&amp;ntilde;o, tal que &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; . El tipo de &lt;code&gt;eps&lt;/code&gt; es un tipo de punto flotante apropiado.</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero positivo representable m&amp;aacute;s peque&amp;ntilde;o, tal que &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes de la serie &lt;code&gt;p&lt;/code&gt; de Chebyshev que minimiza la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes de la serie de Hermite &lt;code&gt;p&lt;/code&gt; que minimizan la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes de la serie &lt;code&gt;p&lt;/code&gt; de HermiteE que minimiza la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes de la serie de Laguerre &lt;code&gt;p&lt;/code&gt; que minimiza la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes de la serie de Legendre &lt;code&gt;p&lt;/code&gt; que minimiza la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">La soluci&amp;oacute;n son los coeficientes del polinomio &lt;code&gt;p&lt;/code&gt; que minimiza la suma de los errores cuadrados ponderados</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">La solución minimiza el error al cuadrado</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">Las soluciones se calculan utilizando la rutina LAPACK &lt;code&gt;_gesv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">El orden de clasificación de los números complejos es lexicográfico.Si tanto las partes reales como las imaginarias no son iguales,entonces el orden está determinado por las partes reales,excepto cuando son iguales,en cuyo caso el orden está determinado por las partes imaginarias.</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">Los valores únicos ordenados.</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">El algoritmo de clasificación utilizado.</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">La matriz de la fuente.</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">El código fuente sólo se devuelve para los objetos escritos en Python.</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">El código fuente sólo se devuelve para los objetos escritos en Python.Muchas funciones y clases están definidas en C y por lo tanto no devuelven información útil.</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">El espaciado entre puntos muestrales cuando &lt;code&gt;x&lt;/code&gt; es Ninguno. El valor predeterminado es 1.</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El espaciado de los valores de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">El algoritmo específico utilizado es el siguiente.</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">La l&amp;iacute;nea especificada viene dada por &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">El conjunto apilado tiene una dimensión más que los conjuntos de entrada.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">La matriz estándar puede tener 24 tipos de datos diferentes (y tiene cierto soporte para añadir sus propios tipos).Todos estos tipos de datos tienen un tipo enumerado,un tipo-carácter enumerado y un objeto correspondiente de tipo escalar Python de la matriz (colocado en una jerarquía).También hay tipedefs estándar C para facilitar la manipulación de los elementos del tipo de datos dado.En cuanto a los tipos numéricos,también hay tipedefs C equivalentes en anchura de bits y números de tipo nombrados que facilitan la selección de la precisión deseada.</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">Las reglas estándar de fundición aseguran que un escalar no puede ascender un conjunto a menos que el escalar sea de un tipo de datos fundamentalmente diferente (es decir,bajo una jerarquía diferente en la jerarquía de tipos de datos)que el conjunto:</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">La desviaci&amp;oacute;n est&amp;aacute;ndar es la ra&amp;iacute;z cuadrada del promedio de las desviaciones al cuadrado de la media, es decir, &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">La desviaci&amp;oacute;n est&amp;aacute;ndar es la ra&amp;iacute;z cuadrada del promedio de las desviaciones al cuadrado de la media: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">Las normas estándar de corte de secuencia se aplican al corte básico sobre una base por dimensión (incluyendo el uso de un índice de paso).Algunos conceptos útiles para recordar incluyen:</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">El inicio de los datos dentro del búfer de datos (un desplazamiento relativo al inicio del búfer de datos).</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">El inicio de los números de tipo utilizados para los tipos de datos personalizados.</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">El valor inicial de este producto. Consulte &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">El valor inicial de la secuencia.</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">El estado del gran generador devuelto se salta como si se hubieran generado 2**(128*saltos)números aleatorios.</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">El tamaño del paso es phi-1 cuando se multiplica por 2**128 donde phi es la proporción áurea.</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">Los pasos de la matriz.Cuántos bytes se necesitan para saltar al siguiente elemento en cada dimensión.</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">Los pasos de la nueva matriz. El valor predeterminado es &lt;code&gt;x.strides&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">El carácter de la cadena correspondiente al tipo escalar.</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">La representación en cadena de una matriz.</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">La representación en cadena del valor en coma flotante</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">La cadena que separa los números en los datos;también se ignoran los espacios en blanco adicionales entre los elementos.</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">La cuerda para cargar.</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">La cuerda para probar la igualdad contra la cuerda esperada.</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">La cadena utilizada para separar los valores.Por defecto,cualquier espacio en blanco consecutivo actúa como delimitador.También se puede proporcionar un entero o secuencia de enteros como ancho(s)de cada campo.</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">La cadena utilizada para separar valores. Para compatibilidad con versiones anteriores, las cadenas de bytes se decodificar&amp;aacute;n como 'latin1'. El valor predeterminado es el espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Las cuerdas producidas por el método Python float.hex pueden utilizarse como entrada para los flotadores.</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">Las submatrices cuyas diagonales principales acabamos de obtener; tenga en cuenta que cada uno corresponde a la fijaci&amp;oacute;n del eje m&amp;aacute;s a la derecha (columna), y que las diagonales est&amp;aacute;n &quot;empaquetadas&quot; en filas.</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">La sub-diagonal en y debajo de la cual se llena la matriz. &lt;code&gt;k&lt;/code&gt; = 0 es la diagonal principal, mientras que &lt;code&gt;k&lt;/code&gt; &amp;lt;0 est&amp;aacute; debajo de ella y &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 est&amp;aacute; arriba. El valor predeterminado es 0.</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">La &lt;code&gt;grid[k]&lt;/code&gt; subarreglos [k] contiene el arreglo ND de &amp;iacute;ndices a lo largo del eje &lt;code&gt;k-th&lt;/code&gt; . Expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La cadena de sub&amp;iacute;ndices es una lista separada por comas de etiquetas de sub&amp;iacute;ndices, donde cada etiqueta se refiere a una dimensi&amp;oacute;n del operando correspondiente. Siempre que se repite una etiqueta, se suma, por lo que &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; es equivalente a &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; . Si una etiqueta aparece s&amp;oacute;lo una vez, no se resume, por lo &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produce una vista de &lt;code&gt;a&lt;/code&gt; sin cambios. Otro ejemplo &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describe la multiplicaci&amp;oacute;n de matrices tradicional y es equivalente a &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt; . Las etiquetas de sub&amp;iacute;ndice repetidas en un operando toman la diagonal. Por ejemplo, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; es equivalente a &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">La subcadena a buscar.</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">La suma de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; , por elementos. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">La suma de una matriz vacía es el elemento neutro 0:</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">La suma de las entradas.Si cualquiera de las entradas es un objeto poly1d,entonces la salida es también un objeto poly1d.De lo contrario,es una matriz 1D de coeficientes polinómicos de mayor a menor grado.</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">El comportamiento de supresi&amp;oacute;n se selecciona con el par&amp;aacute;metro de &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">La prueba t se basa en la suposición de que los datos provienen de una distribución normal.La prueba t proporciona una forma de comprobar si la media de la muestra (es decir,la media calculada a partir de los datos)es una buena estimación de la verdadera media.</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">Los bloques de idioma de la plantilla est&amp;aacute;n delimitados por &lt;code&gt;/**begin repeat&lt;/code&gt; y &lt;code&gt;/**end repeat**/&lt;/code&gt; l&amp;iacute;neas, que tambi&amp;eacute;n se pueden anidar usando l&amp;iacute;neas delimitadas numeradas consecutivamente como &lt;code&gt;/**begin repeat1&lt;/code&gt; y &lt;code&gt;/**end repeat1**/&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">El punto tensor producto de la entrada.</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">La prueba también puede ser invertida:</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">La prueba es equivalente a &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (tenga en cuenta que &lt;code&gt;allclose&lt;/code&gt; tiene diferentes valores predeterminados). Compara la diferencia entre lo &lt;code&gt;actual&lt;/code&gt; y lo &lt;code&gt;desired&lt;/code&gt; con &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">La prueba se marca como omitida si &lt;code&gt;SkipMyTest&lt;/code&gt; se eval&amp;uacute;a como distinto de cero, y el mensaje en la salida de prueba detallada es el segundo argumento dado a &lt;code&gt;skipif&lt;/code&gt; . De manera similar, una prueba se puede marcar como falla conocida usando &lt;code&gt;xfail&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">El m&amp;eacute;todo de prueba puede tomar dos o m&amp;aacute;s argumentos; el primero, &lt;code&gt;label&lt;/code&gt; es una cadena que especifica lo que se debe probar y el segundo, &lt;code&gt;verbose&lt;/code&gt; es un n&amp;uacute;mero entero que da el nivel de verbosidad de salida. Consulte la cadena de documentos de numpy.test para obtener m&amp;aacute;s detalles. El valor predeterminado para la &lt;code&gt;label&lt;/code&gt; es &quot;r&amp;aacute;pido&quot;, que ejecutar&amp;aacute; las pruebas est&amp;aacute;ndar. La cadena 'full' ejecutar&amp;aacute; la bater&amp;iacute;a completa de pruebas, incluidas aquellas identificadas como lentas de ejecutar. Si &lt;code&gt;verbose&lt;/code&gt; es 1 o menos, las pruebas solo mostrar&amp;aacute;n mensajes de informaci&amp;oacute;n sobre las pruebas que se ejecutan; pero si es mayor que 1, las pruebas tambi&amp;eacute;n proporcionar&amp;aacute;n advertencias sobre las pruebas faltantes. Entonces, si desea ejecutar todas las pruebas y recibir mensajes sobre qu&amp;eacute; m&amp;oacute;dulos no tienen pruebas:</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">La prueba para etiquetar como lenta.</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">La prueba verifica formas id&amp;eacute;nticas y que los elementos &lt;code&gt;actual&lt;/code&gt; y &lt;code&gt;desired&lt;/code&gt; satisfacen.</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">La prueba verifica que los elementos de &lt;code&gt;actual&lt;/code&gt; y &lt;code&gt;desired&lt;/code&gt; satisfagan.</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">La serie tridimensional se eval&amp;uacute;a en los puntos &lt;code&gt;(x, y, z)&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; deben tener la misma forma. Si alguno de &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; es una lista o tupla, primero se convierte en un ndarray, de lo contrario, no se modifica y si no es un ndarray, se trata como un escalar.</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">La serie tridimensional se eval&amp;uacute;a en los puntos del producto cartesiano de &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; , `y`, o &lt;code&gt;z&lt;/code&gt; es una lista o tupla, se convierte primero a una ndarray, de lo contrario se deja sin cambios y, si no es un ndarray, se trata como un escalar.</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">Los tres operadores de divisi&amp;oacute;n est&amp;aacute;n todos definidos; &lt;code&gt;div&lt;/code&gt; est&amp;aacute; activo por defecto, &lt;code&gt;truediv&lt;/code&gt; est&amp;aacute; activo cuando la divisi&amp;oacute;n &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; est&amp;aacute; en vigor.</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">Los umbrales anteriores tratan con el error de redondeo de coma flotante en el c&amp;aacute;lculo de la SVD. Sin embargo, es posible que tenga m&amp;aacute;s informaci&amp;oacute;n sobre las fuentes de error en &lt;code&gt;M&lt;/code&gt; que le har&amp;iacute;a considerar otros valores de tolerancia para detectar &lt;em&gt;una&lt;/em&gt; deficiencia de rango &lt;em&gt;efectiva&lt;/em&gt; . La medida m&amp;aacute;s &amp;uacute;til de la tolerancia depende de las operaciones que pretenda utilizar en su matriz. Por ejemplo, si sus datos provienen de mediciones inciertas con incertidumbres mayores que la &amp;eacute;psilon de punto flotante, puede ser preferible elegir una tolerancia cercana a esa incertidumbre. La tolerancia puede ser absoluta si las incertidumbres son absolutas en lugar de relativas.</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">La matriz de salida de azulejos.</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">El tiempo necesario para producir utilizando múltiples hilos puede compararse con el tiempo necesario para generar utilizando un solo hilo.</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">Los siguientes tiempos son el tiempo en ns para producir 1 valor aleatorio de una distribuci&amp;oacute;n espec&amp;iacute;fica. El generador &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; original es mucho m&amp;aacute;s lento ya que requiere 2 valores de 32 bits para igualar la salida de los generadores m&amp;aacute;s r&amp;aacute;pidos.</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Los valores de tolerancia son positivos, normalmente n&amp;uacute;meros muy peque&amp;ntilde;os. La diferencia relativa ( &lt;code&gt;rtol&lt;/code&gt; * abs ( &lt;code&gt;b&lt;/code&gt; )) y la diferencia absoluta &lt;code&gt;atol&lt;/code&gt; se suman para comparar contra la diferencia absoluta entre &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">El tamaño total de la emisión.</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero total de argumentos ( &lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt; ). Debe ser inferior a &lt;code&gt;NPY_MAXARGS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">El número total de tipos de NumPy incorporados.La enumeración cubre el rango de 0 a NPY_NTYPES-1.</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">El número total de elementos enmascarados (eje=Ninguno)o el número de elementos enmascarados a lo largo de cada porción del eje dado.</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">El pago total está compuesto por el pago del principal más los intereses.</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">El tamaño total del conjunto subyacente.</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">La transformaci&amp;oacute;n para la entrada real se realiza sobre el &amp;uacute;ltimo eje de transformaci&amp;oacute;n, como por &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; , luego la transformaci&amp;oacute;n sobre los ejes restantes se realiza como por &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; . El orden de la salida es como para &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; para el eje de transformaci&amp;oacute;n final y como para &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; para los ejes de transformaci&amp;oacute;n restantes.</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">La transposición de una matriz ordenada por C es una matriz ordenada por FORTRAN.</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">La matriz transpuesta.</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">La distribución triangular es una distribución de probabilidad continua con un límite inferior a la izquierda,un pico en el modo y un límite superior a la derecha.A diferencia de las otras distribuciones,estos parámetros definen directamente la forma de la pdf.</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">La distribución triangular se utiliza a menudo en problemas mal definidos en los que se desconoce la distribución subyacente,pero existe cierto conocimiento de los límites y el modo.A menudo se utiliza en simulaciones.</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">La ventana triangular,con el valor máximo normalizado a uno (el valor uno aparece sólo si el número de muestras es impar),con la primera y la última muestra igual a cero.</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">El valor real de &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; es &lt;code&gt;1.00000000005e-10&lt;/code&gt; a aproximadamente 32 d&amp;iacute;gitos significativos. Este ejemplo muestra la superioridad de expm1 en este caso.</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">La entrada truncado o con relleno de ceros, transformado a lo largo de los ejes indicado por &lt;code&gt;axes&lt;/code&gt; , o por una combinaci&amp;oacute;n de &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; , como se explica en la secci&amp;oacute;n de par&amp;aacute;metros anteriormente.</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">La entrada truncado o con relleno de ceros, transformado a lo largo de los ejes indicado por &lt;code&gt;axes&lt;/code&gt; , o por una combinaci&amp;oacute;n de &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; , como se explica en la secci&amp;oacute;n de par&amp;aacute;metros anteriormente. La longitud del &amp;uacute;ltimo eje transformado ser&amp;aacute; &lt;code&gt;s[-1]//2+1&lt;/code&gt; , mientras que los ejes transformados restantes tendr&amp;aacute;n longitudes de acuerdo con &lt;code&gt;s&lt;/code&gt; , o sin cambios desde la entrada.</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">La entrada truncado o con relleno de ceros, transformado a lo largo de los ejes indicado por &lt;code&gt;axes&lt;/code&gt; , o por una combinaci&amp;oacute;n de &lt;code&gt;s&lt;/code&gt; o &lt;code&gt;a&lt;/code&gt; , como se explica en la secci&amp;oacute;n de par&amp;aacute;metros anteriormente.</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">La entrada truncado o con relleno de ceros, transformado a lo largo de los ejes indicado por &lt;code&gt;axes&lt;/code&gt; , o por una combinaci&amp;oacute;n de &lt;code&gt;s&lt;/code&gt; o &lt;code&gt;a&lt;/code&gt; , como se explica en la secci&amp;oacute;n de par&amp;aacute;metros anteriormente. La longitud de cada eje transformado es como se da por el elemento correspondiente de &lt;code&gt;s&lt;/code&gt; , o la longitud de la entrada en cada eje excepto el &amp;uacute;ltimo uno si &lt;code&gt;s&lt;/code&gt; no se da. En la final transformado eje de la longitud de la salida cuando &lt;code&gt;s&lt;/code&gt; no se da es &lt;code&gt;2*(m-1)&lt;/code&gt; donde &lt;code&gt;m&lt;/code&gt; es la longitud del eje transformado definitiva de la entrada. Para obtener un n&amp;uacute;mero impar de puntos de salida en el eje final, &lt;code&gt;s&lt;/code&gt; deben ser especificadas.</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo de los ejes indicados por &lt;code&gt;axes&lt;/code&gt; , o los dos &amp;uacute;ltimos ejes si no se dan &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo del eje indicado por el &lt;code&gt;axis&lt;/code&gt; , o la &amp;uacute;ltima si no se especifica el &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo del eje indicado por el &lt;code&gt;axis&lt;/code&gt; , o la &amp;uacute;ltima si no se especifica el &lt;code&gt;axis&lt;/code&gt; . Si &lt;code&gt;n&lt;/code&gt; es par, la longitud del eje transformado es &lt;code&gt;(n/2)+1&lt;/code&gt; . Si &lt;code&gt;n&lt;/code&gt; es impar, la longitud es &lt;code&gt;(n+1)/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo del eje indicado por el &lt;code&gt;axis&lt;/code&gt; , o la &amp;uacute;ltima si no se especifica el &lt;code&gt;axis&lt;/code&gt; . La longitud del eje transformado es &lt;code&gt;n//2 + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo del eje indicado por el &lt;code&gt;axis&lt;/code&gt; , o la &amp;uacute;ltima si no se especifica el &lt;code&gt;axis&lt;/code&gt; . La longitud del eje transformado es &lt;code&gt;n&lt;/code&gt; o, si no se da &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;2*(m-1)&lt;/code&gt; donde &lt;code&gt;m&lt;/code&gt; es la longitud del eje transformado de la entrada. Para obtener un n&amp;uacute;mero impar de puntos de salida, se debe especificar &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">La entrada truncada o con relleno de ceros, transformada a lo largo del eje indicado por el &lt;code&gt;axis&lt;/code&gt; , o la &amp;uacute;ltima si no se especifica el &lt;code&gt;axis&lt;/code&gt; . La longitud del eje transformado es &lt;code&gt;n&lt;/code&gt; o, si no se da &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;2*m - 2&lt;/code&gt; donde &lt;code&gt;m&lt;/code&gt; es la longitud del eje transformado de la entrada. Para obtener un n&amp;uacute;mero impar de puntos de salida, se debe especificar &lt;code&gt;n&lt;/code&gt; , por ejemplo, como &lt;code&gt;2*m - 1&lt;/code&gt; en el caso t&amp;iacute;pico,</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">El valor truncado de cada elemento en &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">El valor truncado del escalar &lt;code&gt;x&lt;/code&gt; es el entero m&amp;aacute;s cercano &lt;code&gt;i&lt;/code&gt; que est&amp;aacute; m&amp;aacute;s cerca de cero que &lt;code&gt;x&lt;/code&gt; . En resumen, se descarta la parte fraccionaria del n&amp;uacute;mero con signo &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">Las tuplas &lt;code&gt;args&lt;/code&gt; y dict &lt;code&gt;kwargs&lt;/code&gt; se pasan directamente desde la llamada original.</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">La tupla devuelta desde __array_interface __ ['datos'] sol&amp;iacute;a ser una cadena hexadecimal (ahora es un entero o un entero largo).</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">Los dos conjuntos tienen la misma longitud,por lo que sólo hay una posición en la que se superponen completamente:</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">Las dos series dimensional se eval&amp;uacute;a en los puntos &lt;code&gt;(x, y)&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; debe tener la misma forma. Si &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; es una lista o tupla, se convierte primero a una ndarray, de lo contrario se deja sin cambios y si no es un ndarray se trata como un escalar.</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">Las dos series dimensional se eval&amp;uacute;a en los puntos &lt;code&gt;(x, y)&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; debe tener la misma forma. Si &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; es una lista o tupla, se convierte primero a una ndarray, de lo contrario se deja sin cambios y, si no es un ndarray, se trata como un escalar.</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">La serie bidimensional se eval&amp;uacute;a en los puntos del producto cartesiano de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; es una lista o tupla, se convierte primero a una ndarray, de lo contrario se deja sin cambios y, si no es un ndarray, se trata como un escalar.</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">Los dos dominios que determinan el mapa.Cada uno debe (con éxito)convertirse en matrices 1-d que contengan precisamente dos valores.</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">El complemento a dos se devuelve cuando el n&amp;uacute;mero de entrada es negativo y se especifica el ancho:</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">La FFT bidimensional de la entrada real.</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">El FFT bidimensional.</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">El FFT inverso bidimensional.</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">El tipo de objeto utilizado para instanciar un escalar de este tipo de datos.</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Se puede acceder al tipo de datos a trav&amp;eacute;s del atributo &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">El tipo de datos se describe mediante los siguientes atributos &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">Se comprueba el tipo de entrada, no el valor. Incluso si la entrada tiene una parte imaginaria igual a cero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; se&lt;/a&gt; eval&amp;uacute;a como Verdadero.</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">Se comprueba el tipo de entrada, no el valor. Entonces, incluso si la entrada tiene una parte imaginaria igual a cero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; se&lt;/a&gt; eval&amp;uacute;a como Falso si el tipo de datos es complejo.</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">El tipo de matriz de salida. Si no se proporciona &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , infiera el tipo de datos de los otros argumentos de entrada.</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">El tipo de matriz de salida. Si no se proporciona &lt;code&gt;dtype&lt;/code&gt; , infiera el tipo de datos de los otros argumentos de entrada.</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">El tipo de resultado dependerá de la codificación especificada.</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">El tipo de la matriz devuelta y del acumulador en el que se suman los elementos. De forma predeterminada, se utiliza el tipo d de &lt;code&gt;a&lt;/code&gt; . Una excepci&amp;oacute;n es cuando &lt;code&gt;a&lt;/code&gt; tiene un tipo entero con menos precisi&amp;oacute;n que la plataforma (u) intp. En ese caso, el valor predeterminado ser&amp;aacute; (u) int32 o (u) int64 dependiendo de si la plataforma es de 32 o 64 bits. Para entradas inexactas, dtype debe ser inexacto.</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">El tipo de la matriz devuelta y del acumulador en el que se suman los elementos. El dtype de &lt;code&gt;a&lt;/code&gt; se usa por defecto a menos que &lt;code&gt;a&lt;/code&gt; tenga un dtype entero de menor precisi&amp;oacute;n que el entero de plataforma predeterminado. En ese caso, si &lt;code&gt;a&lt;/code&gt; est&amp;aacute; firmado, se usa el entero de plataforma, mientras que si &lt;code&gt;a&lt;/code&gt; no est&amp;aacute; firmado, se usa un entero sin signo de la misma precisi&amp;oacute;n que el entero de plataforma.</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">El tipo de la matriz devuelta, as&amp;iacute; como del acumulador en el que se multiplican los elementos. El dtype de &lt;code&gt;a&lt;/code&gt; se usa por defecto a menos que &lt;code&gt;a&lt;/code&gt; tenga un dtype entero de menor precisi&amp;oacute;n que el entero de plataforma predeterminado. En ese caso, si &lt;code&gt;a&lt;/code&gt; est&amp;aacute; firmado, se usa el entero de plataforma, mientras que si &lt;code&gt;a&lt;/code&gt; no est&amp;aacute; firmado, se usa un entero sin signo de la misma precisi&amp;oacute;n que el entero de plataforma.</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">El tipo utilizado para representar los resultados intermedios.El tipo de datos de la matriz de salida si se proporciona,o el tipo de datos de la matriz de entrada si no se proporciona ninguna matriz de salida.</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">El tipo utilizado para representar los resultados intermedios.Por defecto,el tipo de datos de la matriz de salida si se proporciona,o el tipo de datos de la matriz de entrada si no se proporciona ninguna matriz de salida.</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">Las directivas typemap proporcionadas por &lt;code&gt;numpy.i&lt;/code&gt; para matrices de diferentes tipos de datos, digamos &lt;code&gt;double&lt;/code&gt; e &lt;code&gt;int&lt;/code&gt; , y dimensiones de diferentes tipos, digamos &lt;code&gt;int&lt;/code&gt; o &lt;code&gt;long&lt;/code&gt; , son id&amp;eacute;nticas entre s&amp;iacute; excepto por las especificaciones de tipo C y NumPy. Por lo tanto, los mapas de tipos se implementan (generalmente entre bastidores) a trav&amp;eacute;s de una macro:</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">Las firmas del mapa de tipos se diferencian en gran medida por el nombre que se le da al puntero del b&amp;uacute;fer. Los nombres con &lt;code&gt;FARRAY&lt;/code&gt; son para matrices ordenadas en Fortran y los nombres con &lt;code&gt;ARRAY&lt;/code&gt; son para matrices ordenadas en C (o matrices 1D).</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">Los mapas de tipos de &lt;code&gt;numpy.i&lt;/code&gt; son responsables de las siguientes l&amp;iacute;neas de c&amp;oacute;digo: 12-20, 25 y 30. La l&amp;iacute;nea 10 analiza la entrada a la funci&amp;oacute;n &lt;code&gt;rms&lt;/code&gt; . A partir de la cadena de formato &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; , podemos ver que se espera que la lista de argumentos sea un solo objeto de Python (especificado por la &lt;code&gt;O&lt;/code&gt; antes de los dos puntos) y cuyo puntero se almacena en &lt;code&gt;obj0&lt;/code&gt; . Se &lt;code&gt;numpy.i&lt;/code&gt; una serie de funciones, proporcionadas por numpy.i , para realizar y verificar la (posible) conversi&amp;oacute;n de un objeto Python gen&amp;eacute;rico a una matriz NumPy. Estas funciones se explican en la secci&amp;oacute;n &lt;a href=&quot;#helper-functions&quot;&gt;Funciones auxiliares&lt;/a&gt; , pero es de esperar que sus nombres se expliquen por s&amp;iacute; mismos. En la l&amp;iacute;nea 12 usamos &lt;code&gt;obj0&lt;/code&gt; para construir una matriz NumPy. En la l&amp;iacute;nea 17, verificamos la validez del resultado: que no sea nulo y que tenga una &amp;uacute;nica dimensi&amp;oacute;n de longitud arbitraria. Una vez que se verifican estos estados, extraemos el b&amp;uacute;fer de datos y la longitud en las l&amp;iacute;neas 19 y 20 para poder llamar a la funci&amp;oacute;n C subyacente en la l&amp;iacute;nea 22. La l&amp;iacute;nea 25 realiza la administraci&amp;oacute;n de la memoria para el caso en el que hemos creado una nueva matriz que ya no es necesario.</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">La típica construcción de bucle es la siguiente.</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">El objeto ufunc se implementa mediante la creaci&amp;oacute;n de &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt; . Es un tipo muy simple que implementa solo el comportamiento b&amp;aacute;sico de getattribute, el comportamiento de impresi&amp;oacute;n y tiene un comportamiento de llamada que permite que estos objetos act&amp;uacute;en como funciones. La idea b&amp;aacute;sica detr&amp;aacute;s de ufunc es mantener una referencia a bucles unidimensionales r&amp;aacute;pidos (vectoriales) para cada tipo de datos que admita la operaci&amp;oacute;n. Todos estos bucles unidimensionales tienen la misma firma y son la clave para crear un nuevo ufunc. Son llamados por el c&amp;oacute;digo de bucle gen&amp;eacute;rico seg&amp;uacute;n corresponda para implementar la funci&amp;oacute;n N-dimensional. Tambi&amp;eacute;n hay algunos bucles 1-d gen&amp;eacute;ricos definidos para matrices flotantes y flotantes complejas que le permiten definir una ufunc utilizando una &amp;uacute;nica funci&amp;oacute;n escalar ( &lt;em&gt;por ejemplo,&lt;/em&gt; atanh).</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">El ufunc sigue devolviendo su(s)salida(s)aunque use el(los)argumento(s)de salida opcional(es).</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">Se puede acceder a los datos subyacentes de un conjunto enmascarado de varias maneras:</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">El descriptor de archivo subyacente se cierra al salir del bloque 'con'.</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">La matriz triangular superior.</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">Se aconseja la cautela habitual para verificar la igualdad con los números de punto flotante.</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">La matriz acompa&amp;ntilde;ante habitual de los polinomios de Laguerre ya es sim&amp;eacute;trica cuando &lt;code&gt;c&lt;/code&gt; es un polinomio de Laguerre base, por lo que no se aplica ninguna escala.</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">El valor de la funci&amp;oacute;n cuando x1 es 0. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">El valor de este atributo se utiliza para determinar qué tipo de objeto se debe devolver en situaciones en las que existe más de una posibilidad para el tipo de Python del objeto devuelto.Las subclases heredan un valor por defecto de 0.0 para este atributo.</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">El valor a convertir.Se manejan valores positivos y negativos.</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">El valor que se utilizar&amp;aacute; para las entradas no v&amp;aacute;lidas (Ninguno de forma predeterminada). Si es None, en su lugar se &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; atributo fill_value de la matriz.</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">El valor a utilizar para las entradas inválidas.El valor por defecto es Ninguno.</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">El valor en el que se produce el pico de la distribuci&amp;oacute;n. El valor debe cumplir la condici&amp;oacute;n &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">El valor cuyo tipo de datos mínimo se encuentra.</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">El valor con el que comenzar la reducci&amp;oacute;n. Si ufunc no tiene identidad o el dtype es un objeto, este valor predeterminado es Ninguno; de lo contrario, el valor predeterminado es ufunc.identity. Si se da &lt;code&gt;None&lt;/code&gt; , se usa el primer elemento de la reducci&amp;oacute;n y se arroja un error si la reducci&amp;oacute;n est&amp;aacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">Los valores &lt;code&gt;ar1[in1d]&lt;/code&gt; est&amp;aacute;n en &lt;code&gt;ar2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">Los valores contra los cuales probar cada valor de &lt;code&gt;ar1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">Los valores contra los cuales probar cada valor de &lt;code&gt;element&lt;/code&gt; o . Este argumento se aplana si es una matriz o array_like. Consulte las notas sobre el comportamiento con par&amp;aacute;metros no similares a matrices.</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">Los valores de la matriz de rango 1 &lt;code&gt;p&lt;/code&gt; son coeficientes de un polinomio. Si la longitud de &lt;code&gt;p&lt;/code&gt; es n + 1, entonces el polinomio se describe mediante:</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">Los valores en el resultado siguen el llamado orden &quot;est&amp;aacute;ndar&quot;: si &lt;code&gt;A = fft(a, n)&lt;/code&gt; , entonces &lt;code&gt;A[0]&lt;/code&gt; contiene el t&amp;eacute;rmino de frecuencia cero (la suma de la se&amp;ntilde;al), que siempre es puramente real para real entradas. Entonces &lt;code&gt;A[1:n/2]&lt;/code&gt; contiene los t&amp;eacute;rminos de frecuencia positiva, y &lt;code&gt;A[n/2+1:]&lt;/code&gt; contiene los t&amp;eacute;rminos de frecuencia negativa, en orden decreciente de frecuencia negativa. Para un n&amp;uacute;mero par de puntos de entrada, &lt;code&gt;A[n/2]&lt;/code&gt; representa la frecuencia de Nyquist tanto positiva como negativa, y tambi&amp;eacute;n es puramente real para la entrada real. Para un n&amp;uacute;mero impar de puntos de entrada, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contiene la mayor frecuencia positiva, mientras que &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contiene la mayor frecuencia negativa. La rutina &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; devuelve una matriz que proporciona las frecuencias de los elementos correspondientes en la salida. La rutina &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; cambia las transformaciones y sus frecuencias para poner los componentes de frecuencia cero en el medio, y &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; deshace ese cambio.</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">Los valores de &lt;code&gt;R&lt;/code&gt; se encuentran entre -1 y 1, inclusive.</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Los valores de &lt;code&gt;x1&lt;/code&gt; con el signo de &lt;code&gt;x2&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">Los valores del histograma. Consulte &lt;code&gt;density&lt;/code&gt; y &lt;code&gt;weights&lt;/code&gt; para obtener una descripci&amp;oacute;n de la posible sem&amp;aacute;ntica.</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Los valores del polinomio multidimensional en puntos formados con triples de valores correspondientes de &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Los valores del polinomio multidimensional en puntos formados con triples de valores correspondientes de &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">Los valores de la serie temporal de los flujos de efectivo. El intervalo de tiempo (fijo) entre los &amp;ldquo;eventos&amp;rdquo; de flujo de efectivo debe ser el mismo para el que se da la &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; (es decir, si la &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; es por a&amp;ntilde;o, se entiende que transcurre exactamente un a&amp;ntilde;o entre cada evento de flujo de efectivo). Por convenci&amp;oacute;n, las inversiones o &quot;dep&amp;oacute;sitos&quot; son negativos, los ingresos o los &quot;retiros&quot; son positivos; &lt;code&gt;values&lt;/code&gt; deben comenzar con la inversi&amp;oacute;n inicial, por lo que los &lt;code&gt;values[0]&lt;/code&gt; suelen ser negativos.</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los valores de la serie de Chebyshev bidimensional en puntos formados a partir de pares de valores correspondientes de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los valores de las dos series de Chebyshev dimensionales en los puntos en el producto cartesiano de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los valores de las dos series de Legendre dimensionales en los puntos formados a partir de pares de valores de correspondiente &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los valores del polinomio bidimensional en los puntos formados con pares de valores correspondientes de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los valores del polinomio bidimensional en los puntos del producto cartesiano de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">Los valores notificados están normalizados en relación con la velocidad de MT19937 en cada cuadro.Un valor de 100 indica que el rendimiento coincide con el de MT19937.Los valores más altos indican un mejor rendimiento.Estos valores no pueden ser comparados entre las tablas.</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">Los valores cuyas raíces cúbicas se requieren.</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">Los valores cuyas raíces cuadradas se requieren.</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">La variable obtenida sumando los cuadrados de las variables aleatorias est&amp;aacute;ndar independientes, distribuidas normalmente, &lt;code&gt;df&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">La variable utilizada en la representaci&amp;oacute;n de cadena de &lt;code&gt;p&lt;/code&gt; se puede modificar, utilizando el par&amp;aacute;metro &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">La varianza es el promedio de las desviaciones al cuadrado de la media, es decir, &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">Los diversos c&amp;oacute;digos de caracteres que indican ciertos tipos tambi&amp;eacute;n forman parte de una lista enumerada. Las referencias a los caracteres tipogr&amp;aacute;ficos (en caso de que sean necesarios) siempre deben utilizar estas enumeraciones. La forma de ellos es &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; donde &lt;code&gt;{NAME}&lt;/code&gt; puede ser</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">Todas las rutinas del paquete Polynomial tratan con series cuyos coeficientes van desde el grado cero hacia arriba, que es el &lt;em&gt;orden inverso&lt;/em&gt; de la convenci&amp;oacute;n Poly1d. La forma f&amp;aacute;cil de recordar esto es que los &amp;iacute;ndices corresponden al grado, es decir, coef [i] es el coeficiente del t&amp;eacute;rmino de grado i.</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">Los diversos algoritmos de selección se caracterizan por su velocidad media,el rendimiento en el peor de los casos,el tamaño del espacio de trabajo y si son estables.Una clasificación estable mantiene los elementos con la misma clave en el mismo orden relativo.Los algoritmos disponibles tienen las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">Los diversos algoritmos de clasificación se caracterizan por su velocidad media,el peor de los casos,el tamaño del espacio de trabajo y si son estables.Una clasificación estable mantiene los artículos con la misma clave en el mismo orden relativo.Los cuatro algoritmos implementados en NumPy tienen las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">La funci&amp;oacute;n vdot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) maneja n&amp;uacute;meros complejos de manera diferente a dot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ). Si el primer argumento es complejo, el conjugado complejo del primer argumento se utiliza para calcular el producto escalar.</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">El formato de la versi&amp;oacute;n 1.0 solo permit&amp;iacute;a que el encabezado de la matriz tuviera un tama&amp;ntilde;o total de 65535 bytes. Esto puede superarse mediante matrices estructuradas con una gran cantidad de columnas. El formato de la versi&amp;oacute;n 2.0 ampl&amp;iacute;a el tama&amp;ntilde;o del encabezado a 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; se guardar&amp;aacute; autom&amp;aacute;ticamente en formato 2.0 si los datos lo requieren; de lo contrario, siempre usar&amp;aacute; el formato 1.0 m&amp;aacute;s compatible.</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">La interfaz de la versión 2 era muy similar.Las diferencias eran en gran parte estéticas.En particular:</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">La numeraci&amp;oacute;n de versiones de estos formatos es independiente de la numeraci&amp;oacute;n de versiones de NumPy. Si se actualiza el formato, el c&amp;oacute;digo en &lt;code&gt;numpy.io&lt;/code&gt; a&amp;uacute;n podr&amp;aacute; leer y escribir archivos de la Versi&amp;oacute;n 1.0.</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">La distribución de von Mises (también conocida como la distribución circular normal)es una distribución de probabilidad continua en el círculo unitario.Puede pensarse que es el análogo circular de la distribución normal.</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">Los von Mises se llaman así por Richard Edler von Mises,que nació en Austria-Hungría,en lo que ahora es Ucrania.Huyó a los Estados Unidos en 1939 y se convirtió en profesor de Harvard.Trabajó en teoría de la probabilidad,aerodinámica,mecánica de fluidos y filosofía de la ciencia.</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">Las advertencias pueden ser desactivadas por</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de peso en &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">La función de peso es</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">La función de peso de los polinomios de Chebyshev.</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">La ventana de la serie convertida. Si el valor es Ninguno, se utiliza la ventana de &lt;code&gt;kind&lt;/code&gt; predeterminada .</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">La ventana, con el valor m&amp;aacute;ximo normalizado a uno (el valor uno aparece solo si &lt;code&gt;M&lt;/code&gt; es impar).</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">La ventana,con el valor máximo normalizado a uno (el valor uno aparece sólo si el número de muestras es impar).</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">La palabra &quot;distinto de cero&quot; se refiere al m&amp;eacute;todo &lt;code&gt;__nonzero__()&lt;/code&gt; Python 2.x __nonzero __ () (renombrado como &lt;code&gt;__bool__()&lt;/code&gt; en Python 3.x) de objetos de Python que prueba la &quot;veracidad&quot; de un objeto. Por ejemplo, cualquier n&amp;uacute;mero se considera verdadero si no es cero, mientras que cualquier cadena se considera verdadera si no es la cadena vac&amp;iacute;a. Por lo tanto, esta funci&amp;oacute;n (recursivamente) cuenta cu&amp;aacute;ntos elementos en &lt;code&gt;a&lt;/code&gt; (y en &lt;code&gt;__nonzero__()&lt;/code&gt; mismos) tienen su m&amp;eacute;todo __nonzero __ () o &lt;code&gt;__bool__()&lt;/code&gt; evaluado como &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">La opción de envolver sólo afecta a las matrices altas:</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">Las coordenadas x para evaluar los valores interpolados.</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">Las coordenadas x de los puntos de datos deben aumentar si no se especifica el &lt;code&gt;period&lt;/code&gt; argumento . De lo contrario, &lt;code&gt;xp&lt;/code&gt; se ordena internamente despu&amp;eacute;s de normalizar los l&amp;iacute;mites peri&amp;oacute;dicos con &lt;code&gt;xp = xp % period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">Las coordenadas y de los puntos de datos, de la misma longitud que &lt;code&gt;xp&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
