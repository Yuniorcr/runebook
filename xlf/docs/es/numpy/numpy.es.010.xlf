<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="40188341aa1ae4126e28065ab4ae4528efd4ab80" translate="yes" xml:space="preserve">
          <source>An array containing the size of the array in each dimension.</source>
          <target state="translated">Una matriz que contiene el tamaño de la matriz en cada dimensión.</target>
        </trans-unit>
        <trans-unit id="c5525cd97ca2fd0380b69e5fa824c4cb8926190c" translate="yes" xml:space="preserve">
          <source>An array containing the x coordinates of the points to be histogrammed.</source>
          <target state="translated">Una matriz que contiene las coordenadas x de los puntos a ser histogramados.</target>
        </trans-unit>
        <trans-unit id="5e0350b6b12b116d1bc018ccc6e377cd22ea853f" translate="yes" xml:space="preserve">
          <source>An array containing the y coordinates of the points to be histogrammed.</source>
          <target state="translated">Una matriz que contiene las coordenadas y de los puntos a ser histogramados.</target>
        </trans-unit>
        <trans-unit id="23292ed5ea6c87129ac7edf129a6b29a5c739151" translate="yes" xml:space="preserve">
          <source>An array created this way is a &lt;code&gt;view&lt;/code&gt;, and NumPy often exploits the performance gain of using a view versus making a new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd97d56d812219b3b28e1a0c52b1ff6cc695c36" translate="yes" xml:space="preserve">
          <source>An array describing the shape and dtype of the required MaskedArray.</source>
          <target state="translated">Un arreglo que describe la forma y el tipo del MaskedArray requerido.</target>
        </trans-unit>
        <trans-unit id="04cda3e50b71bd943d98a23dec5faaaa9a7dbcdc" translate="yes" xml:space="preserve">
          <source>An array has a shape given by the number of elements along each axis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d793f2dc9aa6a2d7752deea585ed5cd173d35117" translate="yes" xml:space="preserve">
          <source>An array is a central data structure of the NumPy library. An array is a grid of values and it contains information about the raw data, how to locate an element, and how to interpret an element. It has a grid of elements that can be indexed in &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;various ways&lt;/a&gt;. The elements are all of the same type, referred to as the array &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf313c17a2dcae5eace0c3bac8edc28ea3d4e63f" translate="yes" xml:space="preserve">
          <source>An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of &lt;code&gt;self.itemsize&lt;/code&gt;. Understanding &lt;code&gt;memory-alignment&lt;/code&gt; leads to better performance on most hardware.</source>
          <target state="translated">Una matriz se considera alineada si las compensaciones de memoria para todos los elementos y la compensaci&amp;oacute;n base en s&amp;iacute; es un m&amp;uacute;ltiplo de &lt;code&gt;self.itemsize&lt;/code&gt; . Comprender &lt;code&gt;memory-alignment&lt;/code&gt; conduce a un mejor rendimiento en la mayor&amp;iacute;a del hardware.</target>
        </trans-unit>
        <trans-unit id="39caa1c045b8f25aa32aa854e91ee572acbabbf4" translate="yes" xml:space="preserve">
          <source>An array is contiguous if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7bb147f3c8147036b25457f328e2835c359f8d" translate="yes" xml:space="preserve">
          <source>An array is usually a fixed-size container of items of the same type and size. The number of dimensions and items in an array is defined by its shape. The shape of an array is a tuple of non-negative integers that specify the sizes of each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d722ed07993e54ee58671613ec6bb989469ec46" translate="yes" xml:space="preserve">
          <source>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; provides more description and examples of this useful approach to looping over an array.</source>
          <target state="translated">Un iterador de matriz es una forma sencilla de acceder a los elementos de una matriz N-dimensional de forma r&amp;aacute;pida y eficiente. La secci&amp;oacute;n &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; proporciona m&amp;aacute;s descripci&amp;oacute;n y ejemplos de este m&amp;eacute;todo &amp;uacute;til para recorrer una matriz.</target>
        </trans-unit>
        <trans-unit id="4332fb61829c6f89ffe9272f70c9a5a0a04142f9" translate="yes" xml:space="preserve">
          <source>An array nested in a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, as &lt;code&gt;b&lt;/code&gt; is here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8ecafe80193daba2a801115dc110f22a3a74c2" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items.</source>
          <target state="translated">Un objeto de la matriz representa un conjunto multidimensional y homogéneo de elementos de tamaño fijo.</target>
        </trans-unit>
        <trans-unit id="4cce5f6c6a06c1eb7b057cb09fd7ff7ffd616b00" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.)</source>
          <target state="translated">Un objeto de la matriz representa un conjunto multidimensional y homogéneo de elementos de tamaño fijo.Un objeto de tipo de datos asociado describe el formato de cada elemento de la matriz (su orden de bytes,cuántos bytes ocupa en la memoria,si es un número entero,un número de punto flotante o algo más,etc.)</target>
        </trans-unit>
        <trans-unit id="8d1e82b5439e905b1ddafb253ce61f57276c43a9" translate="yes" xml:space="preserve">
          <source>An array object satisfying the specified requirements.</source>
          <target state="translated">Un objeto de la matriz que satisface los requisitos especificados.</target>
        </trans-unit>
        <trans-unit id="b7bb351e2eb8c7a3b66881caf4f6450b8b6137b9" translate="yes" xml:space="preserve">
          <source>An array of</source>
          <target state="translated">Un conjunto de</target>
        </trans-unit>
        <trans-unit id="5e4c885c1848f9a375fc02dab6bce7ae4010158c" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">Una serie de fechas a considerar como inválidas,sin importar en qué día de la semana caigan.Las fechas de las vacaciones pueden ser especificadas en cualquier orden,y las fechas de NaT (no a la vez)son ignoradas.Esta lista se guarda en una forma normalizada que es adecuada para cálculos rápidos de días válidos.</target>
        </trans-unit>
        <trans-unit id="43a99ea190c51364ce40fbff67e226039938f643" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">Una serie de fechas a considerar como fechas inválidas.Pueden ser especificadas en cualquier orden,y las fechas NaT (not-a-time)son ignoradas.Esta lista se guarda en una forma normalizada que es adecuada para cálculos rápidos de días válidos.</target>
        </trans-unit>
        <trans-unit id="e52ec49035d815a8b775d98b8000ec27cfc67177" translate="yes" xml:space="preserve">
          <source>An array of floats to be rounded</source>
          <target state="translated">Una serie de flotadores para ser redondeados</target>
        </trans-unit>
        <trans-unit id="f3de1a372b66bb0f894c2b02cc87913d27ccf3e7" translate="yes" xml:space="preserve">
          <source>An array of function pointers &amp;mdash; one for each data type supported by the ufunc. This is the vector loop that is called to implement the underlying function &lt;em&gt;dims&lt;/em&gt; [0] times. The first argument, &lt;em&gt;args&lt;/em&gt;, is an array of &lt;em&gt;nargs&lt;/em&gt; pointers to behaved memory. Pointers to the data for the input arguments are first, followed by the pointers to the data for the output arguments. How many bytes must be skipped to get to the next element in the sequence is specified by the corresponding entry in the &lt;em&gt;steps&lt;/em&gt; array. The last argument allows the loop to receive extra information. This is commonly used so that a single, generic vector loop can be used for multiple functions. In this case, the actual scalar function to call is passed in as &lt;em&gt;extradata&lt;/em&gt;. The size of this function pointer array is ntypes.</source>
          <target state="translated">Una matriz de punteros de funci&amp;oacute;n, uno para cada tipo de datos admitidos por ufunc. Este es el bucle vectorial que se llama para implementar la funci&amp;oacute;n subyacente &lt;em&gt;aten&amp;uacute;a&lt;/em&gt; [0] veces. El primer argumento, &lt;em&gt;args&lt;/em&gt; , es una serie de indicadores &lt;em&gt;nargs&lt;/em&gt; para la memoria comportada. Los punteros a los datos para los argumentos de entrada son los primeros, seguidos por los punteros a los datos para los argumentos de salida. La entrada correspondiente en la matriz de &lt;em&gt;pasos&lt;/em&gt; especifica cu&amp;aacute;ntos bytes deben omitirse para llegar al siguiente elemento de la secuencia . El &amp;uacute;ltimo argumento permite que el bucle reciba informaci&amp;oacute;n adicional. Esto se usa com&amp;uacute;nmente para que un solo bucle vectorial gen&amp;eacute;rico pueda usarse para m&amp;uacute;ltiples funciones. En este caso, la funci&amp;oacute;n escalar real a llamar se pasa como&lt;em&gt;extradata&lt;/em&gt; . El tama&amp;ntilde;o de esta matriz de punteros de funci&amp;oacute;n es ntypes.</target>
        </trans-unit>
        <trans-unit id="e1457d1fa372ec75b9a3106caffe135f20a4e98d" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;a href=&quot;array#c.NPY_QUICKSORT&quot;&gt;&lt;code&gt;NPY_QUICKSORT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_HEAPSORT&quot;&gt;&lt;code&gt;NPY_HEAPSORT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ccf0c919c71e47e2ddd7bf201588725f440dd1" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;code&gt;NPY_QUICKSORT&lt;/code&gt;, &lt;code&gt;NPY_HEAPSORT&lt;/code&gt;, and &lt;code&gt;NPY_MERGESORT&lt;/code&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="translated">Una matriz de punteros de funci&amp;oacute;n a un algoritmo de clasificaci&amp;oacute;n en particular. Se obtiene un algoritmo de clasificaci&amp;oacute;n particular mediante una clave (hasta ahora se &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; , &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; y &lt;code&gt;NPY_MERGESORT&lt;/code&gt; ). Estos tipos se realizan in situ asumiendo datos contiguos y alineados.</target>
        </trans-unit>
        <trans-unit id="e16de626c174b91da42175d30f3d8341b71b66d8" translate="yes" xml:space="preserve">
          <source>An array of function pointers to cast from the current type to all of the other builtin types. Each function casts a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;from&lt;/em&gt; to a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;to&lt;/em&gt; The number of items to cast is given by &lt;em&gt;n&lt;/em&gt;, and the arguments &lt;em&gt;fromarr&lt;/em&gt; and &lt;em&gt;toarr&lt;/em&gt; are interpreted as PyArrayObjects for flexible arrays to get itemsize information.</source>
          <target state="translated">Una matriz de punteros de funci&amp;oacute;n para convertir desde el tipo actual a todos los dem&amp;aacute;s tipos integrados. Cada funci&amp;oacute;n lanza un b&amp;uacute;fer contiguo, alineado y no intercambiado apuntado por &lt;em&gt;from&lt;/em&gt; a un b&amp;uacute;fer contiguo, alineado y no intercambiado apuntado por &lt;em&gt;to&lt;/em&gt; El n&amp;uacute;mero de elementos a emitir viene dado por &lt;em&gt;n&lt;/em&gt; , y los argumentos &lt;em&gt;fromarr&lt;/em&gt; y &lt;em&gt;toarr&lt;/em&gt; se interpretan como PyArrayObjects para matrices flexibles para obtener informaci&amp;oacute;n sobre el tama&amp;ntilde;o de los elementos.</target>
        </trans-unit>
        <trans-unit id="e200feb9e53ed4ebf2adb54be5ba987c1cf7059b" translate="yes" xml:space="preserve">
          <source>An array of function pointers to sorting algorithms for this data type. The same sorting algorithms as for sort are available. The indices producing the sort are returned in &lt;code&gt;result&lt;/code&gt; (which must be initialized with indices 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive).</source>
          <target state="translated">Matriz de punteros de funci&amp;oacute;n para ordenar algoritmos para este tipo de datos. Est&amp;aacute;n disponibles los mismos algoritmos de clasificaci&amp;oacute;n que para la clasificaci&amp;oacute;n. Los &amp;iacute;ndices que producen la ordenaci&amp;oacute;n se devuelven como &lt;code&gt;result&lt;/code&gt; ado (que debe inicializarse con &amp;iacute;ndices de 0 a &lt;code&gt;length-1&lt;/code&gt; inclusive).</target>
        </trans-unit>
        <trans-unit id="4bf461a6da3a9c78b86edef9e37f8d374d2671a0" translate="yes" xml:space="preserve">
          <source>An array of indices into the flattened version of an array of dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">Una serie de &amp;iacute;ndices en la versi&amp;oacute;n aplanada de una serie de dimensiones se &lt;code&gt;dims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a2b96955709f32822d46286842703f4390b599" translate="yes" xml:space="preserve">
          <source>An array of indices or a single index value.</source>
          <target state="translated">Una serie de índices o un único valor de índice.</target>
        </trans-unit>
        <trans-unit id="c327e0cbb835c3f65406d2930b711dc0438fe097" translate="yes" xml:space="preserve">
          <source>An array of integers or booleans whose elements should be packed to bits.</source>
          <target state="translated">Un conjunto de números enteros o booleanos cuyos elementos deben ser empaquetados en pedazos.</target>
        </trans-unit>
        <trans-unit id="760cd2caf69b9cf29b19f984123cfb0704600d65" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension.</source>
          <target state="translated">Un conjunto de números enteros que proporcionan para cada dimensión el número de bytes que deben saltarse para llegar al siguiente elemento de esa dimensión.</target>
        </trans-unit>
        <trans-unit id="71e7cb63a5da7e356218da95d576d7ce741d5a1c" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension. Associated with macro &lt;a href=&quot;array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44196e580ff225be1ef1476b121c70c9f63af8cb" translate="yes" xml:space="preserve">
          <source>An array of integers providing the shape in each dimension as long as nd</source>
          <target state="translated">Un conjunto de números enteros que proporcionan la forma en cada dimensión siempre y cuando</target>
        </trans-unit>
        <trans-unit id="62ed90156adc402e959f400c23d7929e6a74e615" translate="yes" xml:space="preserve">
          <source>An array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</source>
          <target state="translated">Un conjunto de objetos iteradores que mantiene los iteradores para que los conjuntos se transmitan juntos.A su vez,los iteradores se ajustan para la emisión.</target>
        </trans-unit>
        <trans-unit id="e3e82fd2fdc82899ac97dd9d7069f0c853f214d0" translate="yes" xml:space="preserve">
          <source>An array of numeric data can also be passed.</source>
          <target state="translated">También se puede pasar una serie de datos numéricos.</target>
        </trans-unit>
        <trans-unit id="ece80d1b5df43cd5fed015f36204934c9ec31960" translate="yes" xml:space="preserve">
          <source>An array of pointers to the actual data for the input and output arrays. The input arguments are given first followed by the output arguments.</source>
          <target state="translated">Una serie de punteros a los datos reales de las matrices de entrada y salida.Los argumentos de entrada se dan primero,seguidos por los argumentos de salida.</target>
        </trans-unit>
        <trans-unit id="d47c875bafe38f3ae53b22be1ca5e1e026b9c87a" translate="yes" xml:space="preserve">
          <source>An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, &lt;code&gt;edges&lt;/code&gt; is a list of the first and last index.</source>
          <target state="translated">Una matriz de &amp;iacute;ndices de inicio y finalizaci&amp;oacute;n si hay datos enmascarados en la matriz. Si no hay datos enmascarados en la matriz, los &lt;code&gt;edges&lt;/code&gt; son una lista del primer y &amp;uacute;ltimo &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="c7dec96e92acd76ab0b9a5089a0591ab494441f3" translate="yes" xml:space="preserve">
          <source>An array of strings the same shape as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Una matriz de cadenas de la misma forma que &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4864cc2ae1f8d0267df4cabfa6aa6a6b4bbde15b" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the cube cube-root of each element in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Una matriz de la misma forma que &lt;code&gt;x&lt;/code&gt; , que contiene la ra&amp;iacute;z c&amp;uacute;bica de cada elemento en &lt;code&gt;x&lt;/code&gt; . Si se proporcion&amp;oacute; &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; es una referencia a &amp;eacute;l. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="2dca043d37393a6e2fc85fdd287fdcbcb4dfecc0" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the positive square-root of each element in &lt;code&gt;x&lt;/code&gt;. If any element in &lt;code&gt;x&lt;/code&gt; is complex, a complex array is returned (and the square-roots of negative reals are calculated). If all of the elements in &lt;code&gt;x&lt;/code&gt; are real, so is &lt;code&gt;y&lt;/code&gt;, with negative elements returning &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Una matriz de la misma forma que &lt;code&gt;x&lt;/code&gt; , que contiene la ra&amp;iacute;z cuadrada positiva de cada elemento en &lt;code&gt;x&lt;/code&gt; . Si cualquier elemento de &lt;code&gt;x&lt;/code&gt; es complejo, se devuelve una matriz compleja (y se calculan las ra&amp;iacute;ces cuadradas de los reales negativos). Si todos los elementos en &lt;code&gt;x&lt;/code&gt; son reales, tambi&amp;eacute;n lo es &lt;code&gt;y&lt;/code&gt; , y los elementos negativos devuelven &lt;code&gt;nan&lt;/code&gt; . Si se proporcion&amp;oacute; &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; es una referencia a &amp;eacute;l. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="b73f11faf81ffda921b160f49100211ca44e9e3b" translate="yes" xml:space="preserve">
          <source>An array of the same type as &lt;code&gt;a&lt;/code&gt;, containing the rounded values. Unless &lt;code&gt;out&lt;/code&gt; was specified, a new array is created. A reference to the result is returned.</source>
          <target state="translated">Una matriz del mismo tipo que &lt;code&gt;a&lt;/code&gt; , que contiene los valores redondeados. A menos &lt;code&gt;out&lt;/code&gt; se especifique out , se crea una nueva matriz. Se devuelve una referencia al resultado.</target>
        </trans-unit>
        <trans-unit id="979601eabdfd48b8ade710f0f03e8b5a86f0bf28" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i)&lt;/code&gt;. Weights are normalized to 1 if &lt;code&gt;normed&lt;/code&gt; is True. If &lt;code&gt;normed&lt;/code&gt; is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">Una matriz de valores &lt;code&gt;w_i&lt;/code&gt; que pesa cada muestra &lt;code&gt;(x_i, y_i)&lt;/code&gt; . Los pesos se normalizan a 1 si la &lt;code&gt;normed&lt;/code&gt; es Verdadero. Si &lt;code&gt;normed&lt;/code&gt; es False, los valores del histograma devuelto son iguales a la suma de los pesos que pertenecen a las muestras que caen en cada bin.</target>
        </trans-unit>
        <trans-unit id="e086307191e3a610d256fdc031206d0be076bb2f" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt;. Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">Una matriz de valores &lt;code&gt;w_i&lt;/code&gt; que pesa cada muestra &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt; . Los pesos se normalizan a 1 si la norma es Verdadero. Si normed es False, los valores del histograma devuelto son iguales a la suma de los pesos que pertenecen a las muestras que caen en cada bin.</target>
        </trans-unit>
        <trans-unit id="c0ce1ac9c3e01f3e63767874318d5ec35c6c8162" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one.</source>
          <target state="translated">Una matriz de ponderaciones asociadas con los valores en &lt;code&gt;a&lt;/code&gt; . Cada valor de &lt;code&gt;a&lt;/code&gt; contribuye al promedio seg&amp;uacute;n su peso asociado. La matriz de pesos puede ser 1-D (en cuyo caso su longitud debe ser del tama&amp;ntilde;o de &lt;code&gt;a&lt;/code&gt; lo largo del eje dado) o de la misma forma que &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;weights=None&lt;/code&gt; , a continuaci&amp;oacute;n, todos los datos en &lt;code&gt;a&lt;/code&gt; se supone que tienen un peso igual a uno.</target>
        </trans-unit>
        <trans-unit id="cc2b51a306ef6edd1f96be1bb988f9b49d26d1ac" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d3b67fb93cc4bc7812921dd986159ce97b0f1e" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). If &lt;code&gt;density&lt;/code&gt; is True, the weights are normalized, so that the integral of the density over the range remains 1.</source>
          <target state="translated">Una matriz de pesos, de la misma forma que &lt;code&gt;a&lt;/code&gt; . Cada valor en &lt;code&gt;a&lt;/code&gt; solo contribuye con su peso asociado al recuento de contenedores (en lugar de 1). Si la &lt;code&gt;density&lt;/code&gt; es Verdadera, los pesos se normalizan, de modo que la integral de la densidad sobre el rango sigue siendo 1.</target>
        </trans-unit>
        <trans-unit id="e08534b68e928582028171965f68debd33645b68" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). This is currently not used by any of the bin estimators, but may be in the future.</source>
          <target state="translated">Una matriz de pesos, de la misma forma que &lt;code&gt;a&lt;/code&gt; . Cada valor en &lt;code&gt;a&lt;/code&gt; solo contribuye con su peso asociado al recuento de contenedores (en lugar de 1). Actualmente, ninguno de los estimadores de intervalos lo utiliza, pero es posible que lo utilice en el futuro.</target>
        </trans-unit>
        <trans-unit id="9f66c5b78a1ee6031ffac8fb1c853e09ee03b883" translate="yes" xml:space="preserve">
          <source>An array shaped as &lt;code&gt;a&lt;/code&gt; but with the specified axis removed. Returns a reference to &lt;code&gt;out&lt;/code&gt; if specified.</source>
          <target state="translated">Una matriz conformada como &lt;code&gt;a&lt;/code&gt; pero con el eje especificado eliminado. Devuelve una referencia a &lt;code&gt;out&lt;/code&gt; si se especifica.</target>
        </trans-unit>
        <trans-unit id="dd19a4a55dabbf2abd322a5d60254e3015e9603b" translate="yes" xml:space="preserve">
          <source>An array that does not own its data, but refers to another array&amp;rsquo;s data instead. For example, we may create a view that only shows every second element of another array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28da6e5d441ca894170555ee158c5c43a7ecacb4" translate="yes" xml:space="preserve">
          <source>An array where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="translated">Una matriz donde todos los elementos son iguales a cero, excepto la &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal, cuyos valores son iguales a uno.</target>
        </trans-unit>
        <trans-unit id="9b75a9f2449bf7b8b39aa7a14602f9d2a9c799dd" translate="yes" xml:space="preserve">
          <source>An array whose dtype is &lt;code&gt;object&lt;/code&gt;; that is, it contains references to Python objects. Indexing the array dereferences the Python objects, so unlike other ndarrays, an object array has the ability to hold heterogeneous objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1e5537016317a890a5d4a449f9cc2d733ed07" translate="yes" xml:space="preserve">
          <source>An array whose nonzero or True entries indicate the elements of &lt;code&gt;arr&lt;/code&gt; to extract.</source>
          <target state="translated">Una matriz cuyas entradas distintas de cero o True indican los elementos de &lt;code&gt;arr&lt;/code&gt; para extraer.</target>
        </trans-unit>
        <trans-unit id="c9db9bfd04f4def5fd1afc2affd0945adf42512d" translate="yes" xml:space="preserve">
          <source>An array with (possibly) masked elements.</source>
          <target state="translated">Un conjunto con (posiblemente)elementos enmascarados.</target>
        </trans-unit>
        <trans-unit id="f661a37bc1f34ccd31f28fc314368c36fc3fd521" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt; together, containing the number of valid days between the begin and end dates.</source>
          <target state="translated">Una matriz con una forma de transmitir las &lt;code&gt;begindates&lt;/code&gt; y &lt;code&gt;enddates&lt;/code&gt; juntas, que contiene el n&amp;uacute;mero de d&amp;iacute;as v&amp;aacute;lidos entre las fechas de inicio y finalizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da4b7ef06bb85fc991c331148db99f16620489ed" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;dates&lt;/code&gt; and &lt;code&gt;offsets&lt;/code&gt; together, containing the dates with offsets applied.</source>
          <target state="translated">Una matriz con una forma de las &lt;code&gt;dates&lt;/code&gt; transmisi&amp;oacute;n y las &lt;code&gt;offsets&lt;/code&gt; juntas, que contiene las fechas con las compensaciones aplicadas.</target>
        </trans-unit>
        <trans-unit id="cb96764e2b9c06bb0ff9fb7ca3e50e3f3bfa36d0" translate="yes" xml:space="preserve">
          <source>An array with elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">Una matriz con elementos de &lt;code&gt;x&lt;/code&gt; donde la &lt;code&gt;condition&lt;/code&gt; es Verdadera y elementos de &lt;code&gt;y&lt;/code&gt; en cualquier otro lugar.</target>
        </trans-unit>
        <trans-unit id="1229c9f2e1287182eb9a66528204171c6010bc1b" translate="yes" xml:space="preserve">
          <source>An array with ones at and below the given diagonal and zeros elsewhere.</source>
          <target state="translated">Un conjunto con unos en y debajo de la diagonal dada y ceros en otra parte.</target>
        </trans-unit>
        <trans-unit id="13f9e7222fb1b0027174f3c545f28e69a270792e" translate="yes" xml:space="preserve">
          <source>An array with the elements of &lt;code&gt;a&lt;/code&gt;, but where values &amp;lt; &lt;code&gt;a_min&lt;/code&gt; are replaced with &lt;code&gt;a_min&lt;/code&gt;, and those &amp;gt; &lt;code&gt;a_max&lt;/code&gt; with &lt;code&gt;a_max&lt;/code&gt;.</source>
          <target state="translated">Una matriz con los elementos de &lt;code&gt;a&lt;/code&gt; , pero donde los valores &amp;lt; &lt;code&gt;a_min&lt;/code&gt; se reemplazan por &lt;code&gt;a_min&lt;/code&gt; , y aquellos&amp;gt; &lt;code&gt;a_max&lt;/code&gt; con &lt;code&gt;a_max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d81681b563f7cbf7ca14e4beb55c0e61ff30a7" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned. If an output array is specified, a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">Una matriz con la misma forma que &lt;code&gt;a&lt;/code&gt; , con el eje especificado eliminado. Si &lt;code&gt;a&lt;/code&gt; es una matriz 0-d, o si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, se devuelve un escalar. Si se especifica una matriz de salida, se devuelve una referencia a &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9baa9b65de91284b3761237390d81577243ec095" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as &lt;code&gt;a&lt;/code&gt; is returned.</source>
          <target state="translated">Una matriz con la misma forma que &lt;code&gt;a&lt;/code&gt; , con el eje especificado eliminado. Si &lt;code&gt;a&lt;/code&gt; es una matriz 0-d, o si axis es None, se devuelve un escalar ndarray. Se devuelve el mismo dtype que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e70abaa821cac7240773cdf6e7844c07f6b75f59" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;dates&lt;/code&gt;, containing True for each valid day, and False for each invalid day.</source>
          <target state="translated">Una matriz con la misma forma que las &lt;code&gt;dates&lt;/code&gt; , que contiene Verdadero para cada d&amp;iacute;a v&amp;aacute;lido y Falso para cada d&amp;iacute;a no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="3dd1a7da3ce189a324136cbefbaa56e7594e5b61" translate="yes" xml:space="preserve">
          <source>An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned.</source>
          <target state="translated">Una matriz con la misma forma que la matriz de entrada, con el eje especificado eliminado. Si la matriz es una matriz 0-d, o si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, se devuelve un escalar.</target>
        </trans-unit>
        <trans-unit id="02c2325cc9f9529260815a39ebd69bc396f69b18" translate="yes" xml:space="preserve">
          <source>An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.</source>
          <target state="translated">Un array,cualquier objeto que exponga la interfaz del array,un objeto cuyo método __array__devuelva un array,o cualquier secuencia (anidada).</target>
        </trans-unit>
        <trans-unit id="567f786634fc5daa235d994c1657787eea4b779a" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt;. Copies are made only if necessary.</source>
          <target state="translated">Una matriz o lista de matrices, cada una con &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt; . Solo se hacen copias si es necesario.</target>
        </trans-unit>
        <trans-unit id="cba647ea9fdf896d7caaed5b946ba91dc1f4274e" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;. Copies are avoided where possible, and views with two or more dimensions are returned.</source>
          <target state="translated">Una matriz o lista de matrices, cada una con &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; . Se evitan las copias siempre que sea posible y se devuelven vistas con dos o m&amp;aacute;s dimensiones.</target>
        </trans-unit>
        <trans-unit id="20047f5be3a0546654cf45798129be0ced7cf529" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt;. Copies are avoided where possible, and views with three or more dimensions are returned. For example, a 1-D array of shape &lt;code&gt;(N,)&lt;/code&gt; becomes a view of shape &lt;code&gt;(1, N, 1)&lt;/code&gt;, and a 2-D array of shape &lt;code&gt;(M, N)&lt;/code&gt; becomes a view of shape &lt;code&gt;(M, N, 1)&lt;/code&gt;.</source>
          <target state="translated">Una matriz, o lista de matrices, cada una con &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt; . Se evitan las copias siempre que sea posible y se devuelven vistas con tres o m&amp;aacute;s dimensiones. Por ejemplo, una matriz 1-D de forma &lt;code&gt;(N,)&lt;/code&gt; se convierte en una vista de forma &lt;code&gt;(1, N, 1)&lt;/code&gt; , y una matriz 2-D de forma &lt;code&gt;(M, N)&lt;/code&gt; convierte en una vista de forma &lt;code&gt;(M, N, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d598faf58dcce518852d1c23ec2af6d3886d1a" translate="yes" xml:space="preserve">
          <source>An assertion is raised if the following condition is not met:</source>
          <target state="translated">Se plantea una afirmación si no se cumple la siguiente condición:</target>
        </trans-unit>
        <trans-unit id="c3adef5312938abeed5e9919b7facafa03477317" translate="yes" xml:space="preserve">
          <source>An assignment example:</source>
          <target state="translated">Un ejemplo de asignación:</target>
        </trans-unit>
        <trans-unit id="5b8cae1664bf34207082790eecd4cff8bc80d113" translate="yes" xml:space="preserve">
          <source>An authority is a person who can tell you more about something than you really care to know. &amp;mdash; &lt;em&gt;Unknown&lt;/em&gt;</source>
          <target state="translated">Una autoridad es una persona que puede decirle m&amp;aacute;s sobre algo de lo que realmente le gustar&amp;iacute;a saber. - &lt;em&gt;Desconocido&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8abc81a5a743ea9f021fdfc70f53e317bae852f" translate="yes" xml:space="preserve">
          <source>An easier way of casting the data to a specific dtype and byte ordering can be achieved with the ndarray astype method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06ba8b5680e861b82812d380d7c8f04108d181f" translate="yes" xml:space="preserve">
          <source>An element of a structured datatype that behaves like an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88aa14c58828551e162cc4a4661a6843968586b6" translate="yes" xml:space="preserve">
          <source>An empty (tuple) index is a full scalar index into a zero dimensional array. &lt;code&gt;x[()]&lt;/code&gt; returns a &lt;em&gt;scalar&lt;/em&gt; if &lt;code&gt;x&lt;/code&gt; is zero dimensional and a view otherwise. On the other hand &lt;code&gt;x[...]&lt;/code&gt; always returns a view.</source>
          <target state="translated">Un &amp;iacute;ndice vac&amp;iacute;o (tupla) es un &amp;iacute;ndice escalar completo en una matriz de dimensi&amp;oacute;n cero. &lt;code&gt;x[()]&lt;/code&gt; devuelve un &lt;em&gt;escalar&lt;/em&gt; si &lt;code&gt;x&lt;/code&gt; es de dimensi&amp;oacute;n cero y una vista en caso contrario. Por otro lado, &lt;code&gt;x[...]&lt;/code&gt; siempre devuelve una vista.</target>
        </trans-unit>
        <trans-unit id="9f8fe74c5bf94bc803b1bb945a029de2c98e9baa" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating how permissive data conversions should be. This is used by the iterator added in NumPy 1.6, and is intended to be used more broadly in a future version.</source>
          <target state="translated">Un tipo de enumeración que indica cuán permisivas deben ser las conversiones de datos.Este es utilizado por el iterador añadido en NumPy 1.6,y está previsto que se utilice más ampliamente en una versión futura.</target>
        </trans-unit>
        <trans-unit id="f076fadc0ee0a286669da0779a627fc24ddf6053" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating the element order that an array should be interpreted in. When a brand new array is created, generally only &lt;strong&gt;NPY_CORDER&lt;/strong&gt; and &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; are used, whereas when one or more inputs are provided, the order can be based on them.</source>
          <target state="translated">Un tipo de enumeraci&amp;oacute;n que indica el orden de los elementos en el que se debe interpretar una matriz. Cuando se crea una matriz nueva, generalmente solo se utilizan &lt;strong&gt;NPY_CORDER&lt;/strong&gt; y &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; , mientras que cuando se proporcionan una o m&amp;aacute;s entradas, el orden puede basarse en ellas.</target>
        </trans-unit>
        <trans-unit id="9ea26de5566952ec524cedbb60ee90bf6c1be0e2" translate="yes" xml:space="preserve">
          <source>An example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2daf8ca86e15a2e24ed018141a980cd426e388" translate="yes" xml:space="preserve">
          <source>An example Python session would be identical to the previous example except that argument names would differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf41c0b27774c1df8aed12edb2351eadd7f38b3" translate="yes" xml:space="preserve">
          <source>An example castfunc is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e8f4d7015b6070bf3f50c3e64f0fbef756b878" translate="yes" xml:space="preserve">
          <source>An example from Glantz[1], pp 47-40:</source>
          <target state="translated">Un ejemplo de Glantz[1],pp 47-40:</target>
        </trans-unit>
        <trans-unit id="1ad321a0ede9c3a9da071e8e5fe72a77cf61d678" translate="yes" xml:space="preserve">
          <source>An example of a non-associative case:</source>
          <target state="translated">Un ejemplo de un caso no asociativo:</target>
        </trans-unit>
        <trans-unit id="21524e2813ff9dc11cf1667f630888b770b6f890" translate="yes" xml:space="preserve">
          <source>An example of broadcasting in practice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9441160929c1f5a53f0eec18887501ddb4a68eb" translate="yes" xml:space="preserve">
          <source>An example of using the config header in light of the above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2a4a70d420aa2d3935775486296bc45b66a315" translate="yes" xml:space="preserve">
          <source>An example of where this may be useful is for a color lookup table where we want to map the values of an image into RGB triples for display. The lookup table could have a shape (nlookup, 3). Indexing such an array with an image with shape (ny, nx) with dtype=np.uint8 (or any integer type so long as values are with the bounds of the lookup table) will result in an array of shape (ny, nx, 3) where a triple of RGB values is associated with each pixel location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bcbe60f6b1cdb52a7d953fc81ff3369b0f2592" translate="yes" xml:space="preserve">
          <source>An example to show comments</source>
          <target state="translated">Un ejemplo para mostrar los comentarios</target>
        </trans-unit>
        <trans-unit id="ab59fb864b641fc21102fa6867c9f294d4d4a6b9" translate="yes" xml:space="preserve">
          <source>An example using a &amp;ldquo;vector&amp;rdquo; of letters:</source>
          <target state="translated">Un ejemplo usando un &quot;vector&quot; de letras:</target>
        </trans-unit>
        <trans-unit id="ae67380a5d930011edb475d7e700cc0a79c17af2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;b&lt;/code&gt; is a scalar:</source>
          <target state="translated">Un ejemplo donde &lt;code&gt;b&lt;/code&gt; es un escalar:</target>
        </trans-unit>
        <trans-unit id="94faf0f11390e7c87a6db1e320054aa5b39eed5b" translate="yes" xml:space="preserve">
          <source>An example with fixed-width columns</source>
          <target state="translated">Un ejemplo con columnas de ancho fijo</target>
        </trans-unit>
        <trans-unit id="ee3a8754bce53d43d3e15790bf69e69f40787cb1" translate="yes" xml:space="preserve">
          <source>An extended example taking advantage of the overloading of + and *:</source>
          <target state="translated">Un ejemplo extendido aprovechando la sobrecarga de+y *:</target>
        </trans-unit>
        <trans-unit id="153bca2420915680d942ae459053fce685c8d220" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with Python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1f5040c3fab0c8014dea349166afc8130d9681" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41352b04320eefbd12c3e75a33715bda727551fe" translate="yes" xml:space="preserve">
          <source>An important distinction for these methods is how they handle the &lt;code&gt;axis&lt;/code&gt; parameter. Both &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; treat the input as a one-dimensional sequence, and the &lt;code&gt;axis&lt;/code&gt; parameter determines which dimension of the input array to use as the sequence. In the case of a two-dimensional array, &lt;code&gt;axis=0&lt;/code&gt; will, in effect, rearrange the rows of the array, and &lt;code&gt;axis=1&lt;/code&gt; will rearrange the columns. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234994ab6fdb07f0421cdf6417fa8d08aaed3974" translate="yes" xml:space="preserve">
          <source>An important thing to be aware of for this iteration is that the order is chosen to match the memory layout of the array instead of using a standard C or Fortran ordering. This is done for access efficiency, reflecting the idea that by default one simply wants to visit each element without concern for a particular ordering. We can see this by iterating over the transpose of our previous array, compared to taking a copy of that transpose in C order.</source>
          <target state="translated">Una cosa importante que hay que tener en cuenta para esta iteración es que el orden se elige para que coincida con la disposición de la memoria de la matriz en lugar de utilizar un orden C o Fortran estándar.Esto se hace para la eficiencia del acceso,reflejando la idea de que por defecto uno simplemente quiere visitar cada elemento sin preocuparse por un orden particular.Podemos ver esto al iterar sobre la transposición de nuestra matriz anterior,en comparación con tomar una copia de esa transposición en orden C.</target>
        </trans-unit>
        <trans-unit id="ce8e2f3f33d5cad8aca5e828b4984abc49c8c85d" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; estimator that works better with non-normal datasets.</source>
          <target state="translated">Una versi&amp;oacute;n mejorada del estimador de Sturges que funciona mejor con conjuntos de datos no normales.</target>
        </trans-unit>
        <trans-unit id="f04b75dbec8a648ba0471c30efe8cb82bf3011bd" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; formula that produces better estimates for non-normal datasets. This estimator attempts to account for the skew of the data.</source>
          <target state="translated">Una versi&amp;oacute;n mejorada de la f&amp;oacute;rmula de Sturges que produce mejores estimaciones para conjuntos de datos no normales. Este estimador intenta dar cuenta del sesgo de los datos.</target>
        </trans-unit>
        <trans-unit id="6c0daf8923a8ff879a417d16aa3697c8609e06f7" translate="yes" xml:space="preserve">
          <source>An index which matches the order of iteration.</source>
          <target state="translated">Un índice que coincide con el orden de la iteración.</target>
        </trans-unit>
        <trans-unit id="fd3ef13b14659602803a66f38a194c91b0d16c51" translate="yes" xml:space="preserve">
          <source>An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.</source>
          <target state="translated">Una entrada puede utilizarse en el cálculo si su tamaño en una dimensión particular coincide con el tamaño de salida en esa dimensión,o tiene un valor exactamente 1.</target>
        </trans-unit>
        <trans-unit id="24428e2d87c0033a748d11a9f2ce4caa1e91c810" translate="yes" xml:space="preserve">
          <source>An input object.</source>
          <target state="translated">Un objeto de entrada.</target>
        </trans-unit>
        <trans-unit id="ccd98d417809c28451b9172282e9fd64d1c41e89" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; can be thought as the combination of several elements:</source>
          <target state="translated">Una instancia de &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; se puede pensar como la combinaci&amp;oacute;n de varios elementos:</target>
        </trans-unit>
        <trans-unit id="cc6e3d42720c490f4a7b292acd6a9d04e387f93f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">Una instancia de &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; que devuelve una cuadr&amp;iacute;cula de malla densa (o desarrollada) cuando se indexa, de modo que cada argumento devuelto tiene la misma forma. Las dimensiones y el n&amp;uacute;mero de matrices de salida son iguales al n&amp;uacute;mero de dimensiones de indexaci&amp;oacute;n. Si la longitud del paso no es un n&amp;uacute;mero complejo, entonces la parada no es inclusiva.</target>
        </trans-unit>
        <trans-unit id="634a502415ebc5263dc90361e50dd67e1f0e70b8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">Una instancia de &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; que devuelve una cuadr&amp;iacute;cula de malla abierta (es decir, no desarrollada) cuando se indexa, de modo que solo una dimensi&amp;oacute;n de cada matriz devuelta es mayor que 1. La dimensi&amp;oacute;n y el n&amp;uacute;mero de las matrices de salida son iguales al n&amp;uacute;mero de dimensiones de indexaci&amp;oacute;n. Si la longitud del paso no es un n&amp;uacute;mero complejo, entonces la parada no es inclusiva.</target>
        </trans-unit>
        <trans-unit id="3ea316e4ad89d0b127e75fd6f9a3da36dffed3ba" translate="yes" xml:space="preserve">
          <source>An instance of class &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps &lt;em&gt;N&lt;/em&gt; integers into the location of an item in the block. The ranges in which the indices can vary is specified by the &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; of the array. How many bytes each item takes and how the bytes are interpreted is defined by the &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt; associated with the array.</source>
          <target state="translated">Una instancia de la clase &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; consiste en un segmento unidimensional contiguo de la memoria de la computadora (propiedad de la matriz o de alg&amp;uacute;n otro objeto), combinado con un esquema de indexaci&amp;oacute;n que asigna &lt;em&gt;N&lt;/em&gt; n&amp;uacute;meros enteros a la ubicaci&amp;oacute;n de un elemento en el bloque. Los rangos en los que pueden variar los &amp;iacute;ndices se especifican por la &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; de la matriz. El &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;objeto de tipo de datos&lt;/a&gt; asociado con la matriz define la cantidad de bytes que toma cada elemento y c&amp;oacute;mo se interpretan los bytes .</target>
        </trans-unit>
        <trans-unit id="6e1c5ac8d50b25041dc87f2c7519eb1a86058078" translate="yes" xml:space="preserve">
          <source>An integer array whose elements are indices into the flattened version of an array of dimensions &lt;code&gt;shape&lt;/code&gt;. Before version 1.6.0, this function accepted just one index value.</source>
          <target state="translated">Una matriz de enteros cuyos elementos son los &amp;iacute;ndices en el aplanado versi&amp;oacute;n de una matriz de dimensiones &lt;code&gt;shape&lt;/code&gt; . Antes de la versi&amp;oacute;n 1.6.0, esta funci&amp;oacute;n aceptaba solo un valor de &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="4276a3e1422ad086a54d759953deada7066bbc35" translate="yes" xml:space="preserve">
          <source>An integer as a dimension name freezes that dimension to the value.</source>
          <target state="translated">Un número entero como nombre de dimensión congela esa dimensión hasta el valor.</target>
        </trans-unit>
        <trans-unit id="1fa126ddddd0a6a8da1f0e66c4d42624e8184e08" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is &lt;code&gt;None&lt;/code&gt; or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="translated">Un desplazamiento entero en la regi&amp;oacute;n de datos de la matriz. Esto solo se puede usar cuando los datos son &lt;code&gt;None&lt;/code&gt; o devuelven un objeto de &lt;code&gt;buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208ac298af4fe8503099d4537d939f78fa068387" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is None or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7827031c1e4779ee518d6bbc19386c165a21aa2f" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="translated">Un n&amp;uacute;mero entero que proporciona el n&amp;uacute;mero de dimensiones de esta matriz. Cuando nd es 0, la matriz a veces se denomina matriz de rango 0. Tales matrices tienen dimensiones y zancadas indefinidas y no se puede acceder a ellas. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; es el mayor n&amp;uacute;mero de dimensiones para cualquier matriz.</target>
        </trans-unit>
        <trans-unit id="98a7f29877575db550ac35bbad96c05eb4cb8962" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. Macro &lt;a href=&quot;array#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt; points to this data member. &lt;a href=&quot;array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740a8c0291954a1fc0b575bf55fa7f345ee70e49" translate="yes" xml:space="preserve">
          <source>An integer showing the version of the interface (i.e. 3 for this version). Be careful not to use this to invalidate objects exposing future versions of the interface.</source>
          <target state="translated">Un número entero que muestra la versión de la interfaz (es decir,3 para esta versión).Tenga cuidado de no utilizarlo para invalidar objetos que expongan futuras versiones de la interfaz.</target>
        </trans-unit>
        <trans-unit id="d87fed7bbbc954e477fb70394a40418f3fdbf745" translate="yes" xml:space="preserve">
          <source>An integer, &lt;em&gt;i&lt;/em&gt;, returns the same values as &lt;code&gt;i:i+1&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt; the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the &lt;em&gt;p&lt;/em&gt;-th element an integer (and all other entries &lt;code&gt;:&lt;/code&gt;) returns the corresponding sub-array with dimension &lt;em&gt;N - 1&lt;/em&gt;. If &lt;em&gt;N = 1&lt;/em&gt; then the returned object is an array scalar. These objects are explained in &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Scalars&lt;/a&gt;.</source>
          <target state="translated">Un entero, &lt;em&gt;i&lt;/em&gt; , devuelve los mismos valores que &lt;code&gt;i:i+1&lt;/code&gt; &lt;strong&gt;, excepto&lt;/strong&gt; la dimensionalidad del objeto devuelto se reduce en 1. En particular, una tupla selecci&amp;oacute;n con el &lt;em&gt;p&lt;/em&gt; elemento -&amp;eacute;simo un n&amp;uacute;mero entero (y todas las dem&amp;aacute;s entradas &lt;code&gt;:&lt;/code&gt; ) devuelve el submatriz correspondiente con dimensi&amp;oacute;n &lt;em&gt;N - 1&lt;/em&gt; . Si &lt;em&gt;N = 1&lt;/em&gt; , el objeto devuelto es un escalar de matriz. Estos objetos se explican en &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Escalares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73fd3d8e22c91d0b01a5e0d96a1a194d3f402dd7" translate="yes" xml:space="preserve">
          <source>An introduction to the concepts discussed here</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9337d47802d85cb5aefc4c6ec7749f6fe4d0f859" translate="yes" xml:space="preserve">
          <source>An introduction, with definitions and general explanations.</source>
          <target state="translated">Una introducción,con definiciones y explicaciones generales.</target>
        </trans-unit>
        <trans-unit id="0e55a620091e71a89cb39a3c09fd5cc874040b26" translate="yes" xml:space="preserve">
          <source>An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, is represented by a Python object whose type is one of the &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar types&lt;/a&gt; built in NumPy. The array scalars allow easy manipulation of also more complicated arrangements of data.</source>
          <target state="translated">Un elemento extra&amp;iacute;do de una matriz, &lt;em&gt;por ejemplo&lt;/em&gt; , por indexaci&amp;oacute;n, est&amp;aacute; representado por un objeto Python cuyo tipo es uno de los &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;tipos escalares de matriz&lt;/a&gt; construidos en NumPy. Los escalares de matriz permiten una f&amp;aacute;cil manipulaci&amp;oacute;n de arreglos de datos tambi&amp;eacute;n m&amp;aacute;s complicados.</target>
        </trans-unit>
        <trans-unit id="de99db091c92a4334b9f2bbfb02c196f89f1e72f" translate="yes" xml:space="preserve">
          <source>An iterable object providing data for the array.</source>
          <target state="translated">Un objeto iterable que proporciona datos para el conjunto.</target>
        </trans-unit>
        <trans-unit id="c2c683940adaf3e17b5b2d4dbfdc8fb1f9285bc0" translate="yes" xml:space="preserve">
          <source>An masked array with &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; elements where the condition is masked, elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">Una matriz enmascarada con elementos &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; donde la condici&amp;oacute;n est&amp;aacute; enmascarada, elementos de &lt;code&gt;x&lt;/code&gt; donde la &lt;code&gt;condition&lt;/code&gt; es Verdadera y elementos de &lt;code&gt;y&lt;/code&gt; en otros lugares.</target>
        </trans-unit>
        <trans-unit id="8ce742f07c8b93ebe9e87ec17c3c1ca6bc05421b" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortan-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="translated">Un ndarray puede tener un segmento de datos que no es un simple trozo contiguo de memoria bien conservada que se puede manipular.Puede que no esté alineado con los límites de las palabras (muy importante en algunas plataformas).Puede tener sus datos en un orden de bytes diferente al que la máquina reconoce.Puede que no sea escribible.Puede estar en un orden contiguo al de Fortan.Las banderas de la matriz se utilizan para indicar lo que se puede decir sobre los datos asociados a una matriz.</target>
        </trans-unit>
        <trans-unit id="bb779643bca7bbe52a88ddd4236e7e3d90ebda9e" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84038cf3f95c6f7f876de572eb50dcdd65ebb4e5" translate="yes" xml:space="preserve">
          <source>An ndarray containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For complex input, &lt;code&gt;a + ib&lt;/code&gt;, the absolute value is</source>
          <target state="translated">Un ndarray que contiene el valor absoluto de cada elemento en &lt;code&gt;x&lt;/code&gt; . Para una entrada compleja, &lt;code&gt;a + ib&lt;/code&gt; , el valor absoluto es</target>
        </trans-unit>
        <trans-unit id="937ff1e9853b1d8bb7896ced9c9a3c640f4a20fd" translate="yes" xml:space="preserve">
          <source>An ndarray of appropriate shape and dtype, filled with False.</source>
          <target state="translated">Un ndarray de forma y tipo apropiado,lleno de False.</target>
        </trans-unit>
        <trans-unit id="a5ee74273207da7ae537266764fb0a696c970cac" translate="yes" xml:space="preserve">
          <source>An nditer for each item in &lt;code&gt;axes&lt;/code&gt;, outermost first</source>
          <target state="translated">Un nditer para cada elemento en los &lt;code&gt;axes&lt;/code&gt; , el m&amp;aacute;s externo primero</target>
        </trans-unit>
        <trans-unit id="d7605eba941666733600a4275983300b4a00400c" translate="yes" xml:space="preserve">
          <source>An ndpointer instance is used to describe an ndarray in restypes and argtypes specifications. This approach is more flexible than using, for example, &lt;code&gt;POINTER(c_double)&lt;/code&gt;, since several restrictions can be specified, which are verified upon calling the ctypes function. These include data type, number of dimensions, shape and flags. If a given array does not satisfy the specified restrictions, a &lt;code&gt;TypeError&lt;/code&gt; is raised.</source>
          <target state="translated">Una instancia de ndpointer se usa para describir un ndarray en restypes y especificaciones de argtypes. Este enfoque es m&amp;aacute;s flexible que usar, por ejemplo, &lt;code&gt;POINTER(c_double)&lt;/code&gt; , ya que se pueden especificar varias restricciones, que se verifican al llamar a la funci&amp;oacute;n ctypes. Estos incluyen el tipo de datos, el n&amp;uacute;mero de dimensiones, la forma y las banderas. Si una matriz dada no satisface las restricciones especificadas, se &lt;code&gt;TypeError&lt;/code&gt; un TypeError .</target>
        </trans-unit>
        <trans-unit id="7417872fe9adc5a45fba54aa51c9ae05347385d3" translate="yes" xml:space="preserve">
          <source>An object representing &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;numpy.number&lt;/code&gt;&lt;/a&gt; precision during static type checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8249a78054c0cb82583f75cad623801b99c6e816" translate="yes" xml:space="preserve">
          <source>An object that can be passed as an argument to the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; constructor to create the array&amp;rsquo;s dtype.</source>
          <target state="translated">Un objeto que se puede pasar como argumento al constructor &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt; para crear el dtype de la matriz.</target>
        </trans-unit>
        <trans-unit id="51b070f54d715dc3c886991b214975d29e065cb3" translate="yes" xml:space="preserve">
          <source>An object that can be queried for it&amp;rsquo;s numeric type.</source>
          <target state="translated">Objeto que se puede consultar por su tipo num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="cb7089d647c1b86db71967874a04b75f15c4139e" translate="yes" xml:space="preserve">
          <source>An object that cannot be modified after execution is called immutable. Two common examples are strings and tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757fdfd1c89cb8f173de4247aa51861595590920" translate="yes" xml:space="preserve">
          <source>An object that exposes the buffer interface.</source>
          <target state="translated">Un objeto que expone la interfaz del buffer.</target>
        </trans-unit>
        <trans-unit id="9aa10d88b8c5173358367cce862fb4a6d6fc0051" translate="yes" xml:space="preserve">
          <source>An object that specifies a custom set of valid days.</source>
          <target state="translated">Un objeto que especifica un conjunto personalizado de días válidos.</target>
        </trans-unit>
        <trans-unit id="9697eabfa36a0c57b03730a9e63e9c0dd7cc2d09" translate="yes" xml:space="preserve">
          <source>An object to simplify the interaction of the array with the ctypes module.</source>
          <target state="translated">Un objeto para simplificar la interacción de la matriz con el módulo ctypes.</target>
        </trans-unit>
        <trans-unit id="77d04ad5d02d58a854d2c57fda919f98926805a2" translate="yes" xml:space="preserve">
          <source>An offset can be passed also to the masking function. This gets us the indices starting on the first diagonal right of the main one:</source>
          <target state="translated">También se puede pasar una compensación a la función de enmascaramiento.Esto nos da los índices comenzando en la primera diagonal a la derecha de la principal:</target>
        </trans-unit>
        <trans-unit id="e7bb40a65a5fed271af7ea895f0c3a327894df3e" translate="yes" xml:space="preserve">
          <source>An open file object, or a string containing a filename.</source>
          <target state="translated">Un objeto de archivo abierto,o una cadena que contiene un nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="d961e30e446f529b34e65541eef1f1abf1c657fc" translate="yes" xml:space="preserve">
          <source>An operation &lt;code&gt;along axis n&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt; behaves as if its argument were an array of slices of &lt;code&gt;a&lt;/code&gt; where each slice has a successive index of axis &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe21301c43ae5617db256d71e7099b9d072912c3" translate="yes" xml:space="preserve">
          <source>An operator that transforms a function. For example, a &lt;code&gt;log&lt;/code&gt; decorator may be defined to print debugging information upon function execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61177b92fd6e93436d3f1589cdd0e84373a28c0" translate="yes" xml:space="preserve">
          <source>An optional argument which is passed through to &lt;code&gt;mask_func&lt;/code&gt;. Functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; take a second argument that is interpreted as an offset.</source>
          <target state="translated">Un argumento opcional que se pasa a &lt;code&gt;mask_func&lt;/code&gt; . Funciones como &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; toman un segundo argumento que se interpreta como un desplazamiento.</target>
        </trans-unit>
        <trans-unit id="6ed67195e81edd8b8281aeaf900064fe84cfec71" translate="yes" xml:space="preserve">
          <source>An optional section detailing which errors get raised and under what conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae26e0d878e399f66a265f5cebede9ebffc3136" translate="yes" xml:space="preserve">
          <source>An optional section detailing which warnings get raised and under what conditions, formatted similarly to Raises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391f6511a38216160a18b8a442ab41f825e0e811" translate="yes" xml:space="preserve">
          <source>An optional section for examples, using the &lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt; format. This section is meant to illustrate usage, not to provide a testing framework &amp;ndash; for that, use the &lt;code&gt;tests/&lt;/code&gt; directory. While optional, this section is very strongly encouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366365808b8b78b0df47b3f2fa0f2ced248b85eb" translate="yes" xml:space="preserve">
          <source>An optional section that provides additional information about the code, possibly including a discussion of the algorithm. This section may include mathematical equations, written in &lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt; format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2c98cd19c30e91e6748b44b5303643381a459b" translate="yes" xml:space="preserve">
          <source>An optional section used to describe infrequently used parameters. It should only be used if a function has a large number of keyword parameters, to prevent cluttering the &lt;strong&gt;Parameters&lt;/strong&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abef9ce470f7fb03808979a319d66414811663e" translate="yes" xml:space="preserve">
          <source>An optional section used to refer to related code. This section can be very useful, but should be used judiciously. The goal is to direct users to other functions they may not be aware of, or have easy means of discovering (by looking at the module docstring, for example). Routines whose docstrings further explain parameters used by this function are good candidates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163026d9f814b206fafab6b479ab36888cccfde6" translate="yes" xml:space="preserve">
          <source>An optional section with cautions to the user in free text/reST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1965c219b7008fe9d099c530f609263a14ec3ab8" translate="yes" xml:space="preserve">
          <source>An optional shape tuple providing how many times this part of the structure should be repeated. No repeats are assumed if this is not given. Very complicated structures can be described using this generic interface. Notice, however, that each element of the array is still of the same data-type. Some examples of using this interface are given below.</source>
          <target state="translated">Una tupla de forma opcional que proporciona cuántas veces esta parte de la estructura debe ser repetida.No se supone que se repita si no se da esta información.Se pueden describir estructuras muy complicadas usando esta interfaz genérica.Nótese,sin embargo,que cada elemento del conjunto sigue siendo del mismo tipo de datos.A continuación se dan algunos ejemplos del uso de esta interfaz.</target>
        </trans-unit>
        <trans-unit id="53899654d34ff89eb71076f6e6bc7701229a1b68" translate="yes" xml:space="preserve">
          <source>An order as close to the order of the inputs as possible, even if the input is in neither C nor Fortran order.</source>
          <target state="translated">Un orden tan cercano al orden de las entradas como sea posible,incluso si la entrada no está en orden ni C ni Fortran.</target>
        </trans-unit>
        <trans-unit id="62dbe9a66cb25d1e5f12073cb6b65d7c95221376" translate="yes" xml:space="preserve">
          <source>An ordered tuple of field names. It is NULL if no field is defined.</source>
          <target state="translated">Una tupla ordenada de nombres de campo.Es NULL si no se define ningún campo.</target>
        </trans-unit>
        <trans-unit id="b28a1d46b1f9296ef3b935989580ffec6bc90e2b" translate="yes" xml:space="preserve">
          <source>And even an array that contains a range of evenly spaced intervals. To do this, you will specify the &lt;strong&gt;first number&lt;/strong&gt;, &lt;strong&gt;last number&lt;/strong&gt;, and the &lt;strong&gt;step size&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fba956825020587f9a5a64e281c04047de223ea" translate="yes" xml:space="preserve">
          <source>And even use a Greek symbol like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d209b0782b74a22172d98886be624cfb54a8889a" translate="yes" xml:space="preserve">
          <source>And finally, we build the extension module by running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43728498911f9a35c7cfcd97027ee53c73e05582" translate="yes" xml:space="preserve">
          <source>And for assigning values:</source>
          <target state="translated">Y para asignar valores:</target>
        </trans-unit>
        <trans-unit id="4fb83d7408641f0a8ebf4e9525e3b469b9150326" translate="yes" xml:space="preserve">
          <source>And here are the time units:</source>
          <target state="translated">Y aquí están las unidades de tiempo:</target>
        </trans-unit>
        <trans-unit id="1b699ec82ab8d002ac2193762454ef347af6a2da" translate="yes" xml:space="preserve">
          <source>And in more detail:</source>
          <target state="translated">Y con más detalle:</target>
        </trans-unit>
        <trans-unit id="de07ee02fee2070e061118495013c58fef8e83bb" translate="yes" xml:space="preserve">
          <source>And make sure the &lt;code&gt;VERSION&lt;/code&gt; variable is set properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee8deafdefbce6d1b2807fd39f58eb30f617552" translate="yes" xml:space="preserve">
          <source>And read your CSV with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750b2a038f3915c181ab3d5361e664ccd43727d0" translate="yes" xml:space="preserve">
          <source>And then in the debugger:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021c9202efccb926bf8e315a46e72fcbd7af5307" translate="yes" xml:space="preserve">
          <source>And to find the shape of your array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96cb503f931b03fd273a49b170890809399fc62" translate="yes" xml:space="preserve">
          <source>And use it to set the diagonal of an array of zeros to 1:</source>
          <target state="translated">Y lo usamos para establecer la diagonal de un conjunto de ceros en 1:</target>
        </trans-unit>
        <trans-unit id="240ae7e192fffb9c12f05d721f8aebdc4754f4de" translate="yes" xml:space="preserve">
          <source>Angle in radians.</source>
          <target state="translated">Ángulo en los radianes.</target>
        </trans-unit>
        <trans-unit id="0184757264cf635f3a2e2e908775a586af284275" translate="yes" xml:space="preserve">
          <source>Angle, in radians (</source>
          <target state="translated">Ángulo,en radianes (</target>
        </trans-unit>
        <trans-unit id="531138e549dac342fe270e2699b3c5521bbf5ec8" translate="yes" xml:space="preserve">
          <source>Angles in degrees.</source>
          <target state="translated">Ángulos en grados.</target>
        </trans-unit>
        <trans-unit id="dfa37c7c185a546b145b8e12c452f16dbc48d7fc" translate="yes" xml:space="preserve">
          <source>Anirudh Subramanian</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1108804921f7fa74ee3f663d12f9acdb0f17609b" translate="yes" xml:space="preserve">
          <source>Announce the release on scipy.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0f71af0703a17a0fe77843a34b501f25db1f87" translate="yes" xml:space="preserve">
          <source>Announce to Linux Weekly News</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542e50fbd0847e1465192e2a2bd9c3cc0e292cfc" translate="yes" xml:space="preserve">
          <source>Announce to mailing lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc7a7a2cec9dbb01f44b9fb7e6acf4fd9b1506f" translate="yes" xml:space="preserve">
          <source>Announce to the lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4dde3e14d997b719c29d0bbd6c5103efadda68" translate="yes" xml:space="preserve">
          <source>Another common separator is &lt;code&gt;&quot;\t&quot;&lt;/code&gt;, the tabulation character. However, we are not limited to a single character, any string will do. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;delimiter=None&lt;/code&gt;, meaning that the line is split along white spaces (including tabs) and that consecutive white spaces are considered as a single white space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdf42a70a6f5e3b9eb4a7a9d5fd5b3a5e3c028d" translate="yes" xml:space="preserve">
          <source>Another common use of indexing with arrays is the search of the maximum value of time-dependent series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4043a7e9def49f8cd15e6e1c3c67b85fcd702c3b" translate="yes" xml:space="preserve">
          <source>Another difference with the standard ndarray of str data-type is that the chararray inherits the feature introduced by Numarray that white-space at the end of any element in the array will be ignored on item retrieval and comparison operations.</source>
          <target state="translated">Otra diferencia con el ndarray estándar de tipo str data es que el chararray hereda la característica introducida por Numarray de que los espacios en blanco al final de cualquier elemento del array serán ignorados en las operaciones de recuperación y comparación de elementos.</target>
        </trans-unit>
        <trans-unit id="5dcd2747e1a6d1d5aac68e7e1ee2b04c96abcc9c" translate="yes" xml:space="preserve">
          <source>Another example is the function &lt;code&gt;inner1d(a, b)&lt;/code&gt; with a signature of &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;. This applies the inner product along the last axis of each input, but keeps the remaining indices intact. For example, where &lt;code&gt;a&lt;/code&gt; is of shape &lt;code&gt;(3, 5, N)&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is of shape &lt;code&gt;(5, N)&lt;/code&gt;, this will return an output of shape &lt;code&gt;(3,5)&lt;/code&gt;. The underlying elementary function is called &lt;code&gt;3 * 5&lt;/code&gt; times. In the signature, we specify one core dimension &lt;code&gt;(i)&lt;/code&gt; for each input and zero core dimensions &lt;code&gt;()&lt;/code&gt; for the output, since it takes two 1-d arrays and returns a scalar. By using the same name &lt;code&gt;i&lt;/code&gt;, we specify that the two corresponding dimensions should be of the same size.</source>
          <target state="translated">Otro ejemplo es la funci&amp;oacute;n &lt;code&gt;inner1d(a, b)&lt;/code&gt; con una firma de &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; . Esto aplica el producto interno a lo largo del &amp;uacute;ltimo eje de cada entrada, pero mantiene intactos los &amp;iacute;ndices restantes. Por ejemplo, cuando &lt;code&gt;a&lt;/code&gt; es de forma &lt;code&gt;(3, 5, N)&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; es de forma &lt;code&gt;(5, N)&lt;/code&gt; , esto devolver&amp;aacute; una salida de forma &lt;code&gt;(3,5)&lt;/code&gt; . La funci&amp;oacute;n elemental subyacente se llama &lt;code&gt;3 * 5&lt;/code&gt; veces. En la firma, especificamos una dimensi&amp;oacute;n de n&amp;uacute;cleo &lt;code&gt;(i)&lt;/code&gt; para cada entrada y cero dimensiones de n&amp;uacute;cleo &lt;code&gt;()&lt;/code&gt; para la salida, ya que toma dos matrices 1-d y devuelve un escalar. Usando el mismo nombre &lt;code&gt;i&lt;/code&gt; , especificamos que las dos dimensiones correspondientes deben ser del mismo tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="90bf0b9c455b04ca91edfdb12178ac251d5b7ad5" translate="yes" xml:space="preserve">
          <source>Another frequently asked question is &amp;ldquo;How do I debug C code inside NumPy?&amp;rdquo;. First, ensure that you have gdb installed on your system with the Python extensions (often the default on Linux). You can see which version of Python is running inside gdb to verify your setup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c72feff7651c1b9feda841c49b58c2d454b80e" translate="yes" xml:space="preserve">
          <source>Another important role played by deprecation markings in the C API is to move towards hiding internal details of the NumPy implementation. For those needing direct, easy, access to the data of ndarrays, this will not remove this ability. Rather, there are many potential performance optimizations which require changing the implementation details, and NumPy developers have been unable to try them because of the high value of preserving ABI compatibility. By deprecating this direct access, we will in the future be able to improve NumPy&amp;rsquo;s performance in ways we cannot presently.</source>
          <target state="translated">Otro papel importante que juegan las marcas de desaprobaci&amp;oacute;n en la API de C es avanzar hacia la ocultaci&amp;oacute;n de detalles internos de la implementaci&amp;oacute;n de NumPy. Para aquellos que necesiten acceso directo y f&amp;aacute;cil a los datos de ndarrays, esto no eliminar&amp;aacute; esta capacidad. M&amp;aacute;s bien, hay muchas optimizaciones de rendimiento potenciales que requieren cambiar los detalles de implementaci&amp;oacute;n, y los desarrolladores de NumPy no han podido probarlas debido al alto valor de preservar la compatibilidad ABI. Al desaprobar este acceso directo, en el futuro podremos mejorar el rendimiento de NumPy de formas que no podemos actualmente.</target>
        </trans-unit>
        <trans-unit id="a86afb1ef0a04254ac219408ffb94437b02ea319" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91143b613b806bdad96301f98bc353e17238828f" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="translated">Otro m&amp;eacute;todo es usar &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt; que avanza el estado como si</target>
        </trans-unit>
        <trans-unit id="0fd6c16778a959995e7dc3e9960a7fccd4bf7af0" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt;&lt;code&gt;getmask&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt;&lt;code&gt;getmaskarray&lt;/code&gt;&lt;/a&gt; functions. &lt;code&gt;getmask(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array, and the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; otherwise. &lt;code&gt;getmaskarray(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array. If &lt;code&gt;x&lt;/code&gt; has no invalid entry or is not a masked array, the function outputs a boolean array of &lt;code&gt;False&lt;/code&gt; with as many elements as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Otra posibilidad es utilizar las funciones &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt; &lt;code&gt;getmask&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt; &lt;code&gt;getmaskarray&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;getmask(x)&lt;/code&gt; genera la m&amp;aacute;scara de &lt;code&gt;x&lt;/code&gt; si &lt;code&gt;x&lt;/code&gt; es una matriz enmascarada, y el valor especial &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; en&lt;/a&gt; caso contrario. &lt;code&gt;getmaskarray(x)&lt;/code&gt; genera la m&amp;aacute;scara de &lt;code&gt;x&lt;/code&gt; si &lt;code&gt;x&lt;/code&gt; es una matriz enmascarada. Si &lt;code&gt;x&lt;/code&gt; no tiene una entrada no v&amp;aacute;lida o no es una matriz enmascarada, la funci&amp;oacute;n genera una matriz booleana de &lt;code&gt;False&lt;/code&gt; con tantos elementos como &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8f5707c41037b98d07b3655f44a00e7754af32b" translate="yes" xml:space="preserve">
          <source>Another simpler possibility is to use the &lt;code&gt;names&lt;/code&gt; keyword with a sequence of strings or a comma-separated string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb96c2d76983849aa396fb78c96e7b20143386c1" translate="yes" xml:space="preserve">
          <source>Another somewhat outdated MATLAB/NumPy cross-reference can be found at &lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;http://mathesaurus.sf.net/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b047c7f58df9c5865a2b74a6710b7b1e5f19d15" translate="yes" xml:space="preserve">
          <source>Another term for &lt;a href=&quot;#term-advanced-indexing&quot;&gt;advanced indexing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a695f570d8eedee37a6873f1169fc8ffe3e272" translate="yes" xml:space="preserve">
          <source>Another term for an array dimension. Axes are numbered left to right; axis 0 is the first element in the shape tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af7d96a4421569602af070d1f51ae85302570e" translate="yes" xml:space="preserve">
          <source>Another use of this flag is for setting up reduction operations. After the iterator is created, and a reduction output is allocated automatically by the iterator (be sure to use READWRITE access), its value may be initialized to the reduction unit. Use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get the object. Then, call &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; to allocate and fill the buffers with their initial values.</source>
          <target state="translated">Otro uso de esta bandera es para configurar operaciones de reducci&amp;oacute;n. Una vez creado el iterador, y el iterador asigna autom&amp;aacute;ticamente una salida de reducci&amp;oacute;n (aseg&amp;uacute;rese de utilizar el acceso READWRITE), su valor puede inicializarse en la unidad de reducci&amp;oacute;n. Utilice &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; para obtener el objeto. Luego, llame a &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt; para asignar y llenar los b&amp;uacute;feres con sus valores iniciales.</target>
        </trans-unit>
        <trans-unit id="1273c53271563cf36a39aab59fe3df9f43442e63" translate="yes" xml:space="preserve">
          <source>Another way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.</source>
          <target state="translated">Otra forma de representar el determinante,más adecuada para las grandes matrices en las que puede haber subdesbordamiento/desbordamiento.</target>
        </trans-unit>
        <trans-unit id="4a9a549b7d1a971f20baf0bc7c2890ecc79e2921" translate="yes" xml:space="preserve">
          <source>Another way to retrieve the valid data is to use the &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; method, which returns a one-dimensional &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (or one of its subclasses, depending on the value of the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute):</source>
          <target state="translated">Otra forma de recuperar los datos v&amp;aacute;lidos es utilizar el m&amp;eacute;todo &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt; , que devuelve un &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; unidimensional (o una de sus subclases, seg&amp;uacute;n el valor del atributo &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="4c793b7f96dc3a05a24bc874af2795d6270941c5" translate="yes" xml:space="preserve">
          <source>Anti-derivative of a polynomial.</source>
          <target state="translated">Anti-derivado de un polinomio.</target>
        </trans-unit>
        <trans-unit id="253f5b3f24b2fd1c0fc450339280f5eb6eb4f07c" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;reference/arrays.scalars&quot;&gt;scalar&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt; that can be interpreted as an ndarray. In addition to ndarrays and scalars this category includes lists (possibly nested and with different element types) and tuples. Any argument accepted by &lt;a href=&quot;reference/generated/numpy.array&quot;&gt;numpy.array&lt;/a&gt; is array_like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6711bfd3b820f62c39c4d88fd0c62299f5e94371" translate="yes" xml:space="preserve">
          <source>Any Python object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a193823ba578f9f1e7b81264ee2c1d9779647da7" translate="yes" xml:space="preserve">
          <source>Any Python object:</source>
          <target state="translated">Cualquier objeto de Python:</target>
        </trans-unit>
        <trans-unit id="58e444efe77e462bb342fdd66c1b5f6f6487f4f4" translate="yes" xml:space="preserve">
          <source>Any binary operation can be extended to an array operation in an outer product fashion like in &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;outer&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a way to accomplish this by explicitly mapping the axes of the operands. It is also possible to do this with &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; indexing, but we will show you how to directly use the nditer &lt;code&gt;op_axes&lt;/code&gt; parameter to accomplish this with no intermediate views.</source>
          <target state="translated">Cualquier operaci&amp;oacute;n binaria puede extenderse a una operaci&amp;oacute;n de matriz en una forma de producto externo como en &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;outer&lt;/code&gt; &lt;/a&gt; , y el objeto &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; proporciona una manera de lograr esto al mapear expl&amp;iacute;citamente los ejes de los operandos. Tambi&amp;eacute;n es posible hacer esto con la indexaci&amp;oacute;n de &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; , pero le mostraremos c&amp;oacute;mo usar directamente el par&amp;aacute;metro nditer &lt;code&gt;op_axes&lt;/code&gt; para lograr esto sin vistas intermedias.</target>
        </trans-unit>
        <trans-unit id="df3387b9c652aaab79f08e9bac190d701d99f2f6" translate="yes" xml:space="preserve">
          <source>Any class or type can define this method which should take an ndarray argument and return an instance of the type. It can be seen as the opposite of the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method. This method is used by the ufuncs (and other NumPy functions) to allow other objects to pass through. For Python &amp;gt;2.4, it can also be used to write a decorator that converts a function that works only with ndarrays to one that works with any type with &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10078c28a66a73c575c275e6dbad2ad1c3448ead" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="translated">Cualquier clase, subclase ndarray o no, puede definir este m&amp;eacute;todo o establecerlo en &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; para anular el comportamiento de los ufuncs de NumPy. Esto funciona de manera bastante similar a &lt;code&gt;__mul__&lt;/code&gt; de Python y otras rutinas de operaciones binarias.</target>
        </trans-unit>
        <trans-unit id="615fb1d9086b422643eac8df92cc3c45b3d4452a" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to None in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c392144526317c8f8ed6b5a13470ac5e7a3986" translate="yes" xml:space="preserve">
          <source>Any combination of N scalars/arrays with the meaning of 2. and 3.</source>
          <target state="translated">Cualquier combinación de N escalares/arreglos con el significado de 2.y 3.</target>
        </trans-unit>
        <trans-unit id="7e81367c0096f8373d0b6f4554ea3cc6aafb3c68" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b31e220e37372f3e91f15af6702628188b111" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="translated">Cualquier indicador de datos ( &lt;em&gt;por ejemplo, &lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; ) que deber&amp;iacute;a usarse para interpretar la memoria.</target>
        </trans-unit>
        <trans-unit id="d26a90b0973e9f5339ce6764ce63dbf7b59a3e02" translate="yes" xml:space="preserve">
          <source>Any data saved to the file is appended to the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0107d5bdb46b9143c29ff9e836efde601fe340" translate="yes" xml:space="preserve">
          <source>Any dynamically allocated memory. Currently, this is used for dynamic ufuncs created from a python function to store room for the types, data, and name members.</source>
          <target state="translated">Cualquier memoria asignada dinámicamente.Actualmente,se utiliza para ufuncs dinámicos creados a partir de una función pitón para almacenar los tipos,datos y miembros del nombre.</target>
        </trans-unit>
        <trans-unit id="f1796623bc2027a8a0877fb0e869c4d3c3990d76" translate="yes" xml:space="preserve">
          <source>Any further arguments given to &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, 1, 'a')&lt;/code&gt;.</source>
          <target state="translated">Cualquier otro argumento dado a por &lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; se pasa a las funciones durante la ejecuci&amp;oacute;n, es decir, si se llama por &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt; , entonces cada funci&amp;oacute;n se llama como &lt;code&gt;f(x, 1, 'a')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd7c425a186534062ca5afb654fb680173c25d5" translate="yes" xml:space="preserve">
          <source>Any keyword arguments the function requires.</source>
          <target state="translated">Cualquier argumento con palabras clave que la función requiera.</target>
        </trans-unit>
        <trans-unit id="487737106c5cb105d4cc96a9c1768d045f864529" translate="yes" xml:space="preserve">
          <source>Any masked values in x is propagated in y, and vice-versa.</source>
          <target state="translated">Cualquier valor enmascarado en x se propaga en y,y viceversa.</target>
        </trans-unit>
        <trans-unit id="5b3e589175f1027a44f22dd657bf35194fb4efe1" translate="yes" xml:space="preserve">
          <source>Any object that can be interpreted as a numpy data type.</source>
          <target state="translated">Cualquier objeto que pueda ser interpretado como un tipo de datos numéricos.</target>
        </trans-unit>
        <trans-unit id="5c7fd0d6a17d8a832706885c37ef7915bca46e30" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5faa1a4aa7fab555a1cad670ecbaad358f811e8" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c0049b3dfe5e641bc6afd3eb13a7ff82f212c5" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6945ac0af9b8b9ad29a3d13b28b137c3c2801d79" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="translated">Cualquiera de los valores de enumeraci&amp;oacute;n &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt; se puede pasar a la &lt;code&gt;casting&lt;/code&gt; . Los valores incluyen &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt; . Para permitir que se produzcan las conversiones, tambi&amp;eacute;n se debe habilitar la copia o el almacenamiento en b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="99411ff6757ed2755306b2b1a16852e86b5af656" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="translated">Cualquiera de los valores de enumeraci&amp;oacute;n &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt; se puede pasar a la &lt;code&gt;order&lt;/code&gt; . Para una iteraci&amp;oacute;n eficiente, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; es la mejor opci&amp;oacute;n, y las otras &amp;oacute;rdenes imponen el patr&amp;oacute;n de iteraci&amp;oacute;n particular.</target>
        </trans-unit>
        <trans-unit id="edb631f6c3d9ec9fd114b3a0b6be2d92e321c394" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cualquiera de los valores de enumeraci&amp;oacute;n &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt; se puede pasar a la &lt;code&gt;order&lt;/code&gt; . Para una iteraci&amp;oacute;n eficiente, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; es la mejor opci&amp;oacute;n, y las otras &amp;oacute;rdenes imponen el patr&amp;oacute;n de iteraci&amp;oacute;n particular. Al usar &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; , si tambi&amp;eacute;n desea asegurarse de que la iteraci&amp;oacute;n no se invierta a lo largo de un eje, debe pasar la &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3abc478c3f222918197160be100f748fcb675c9" translate="yes" xml:space="preserve">
          <source>Any of the above can be repeated with an arbitrary array-like instead of just integers. For instance:</source>
          <target state="translated">Cualquiera de los anteriores puede ser repetido con un arreglo arbitrario,como en lugar de sólo números enteros.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="baa143a57607b2a750593f79fe56d85a053bca99" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f8138ac25a7b846ede67771ef46a3519a7468a" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be291c901c4e86c13d0921234777782594d69ca9" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">Cualquiera de los bits &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (1), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (2), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; (0x100), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; (0x200) o &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; (0x400). Los &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; se pueden determinar realmente a partir de los otros par&amp;aacute;metros. El indicador &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; ( 0x800 ) tambi&amp;eacute;n se puede configurar para indicar a los objetos que consumen la interfaz de matriz de la versi&amp;oacute;n 3 que el miembro descrito de la estructura est&amp;aacute; presente (ser&amp;aacute; ignorado por los objetos que consumen la versi&amp;oacute;n 2 de la interfaz de matriz).</target>
        </trans-unit>
        <trans-unit id="451522a82b98d1ecbb1f701acd57fae92d96248e" translate="yes" xml:space="preserve">
          <source>Any scalar or sequence that can be interpreted as an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade55446d2b73db16731c562424aceaad0914376" translate="yes" xml:space="preserve">
          <source>Any sequence that can be interpreted as an ndarray. This includes nested lists, tuples, scalars and existing arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40cd9ea72e6075ff56d97f5c96e1adeaca3800f" translate="yes" xml:space="preserve">
          <source>Any specified CPU feature to &lt;code&gt;--cpu-dispatch&lt;/code&gt; will be skipped if it&amp;rsquo;s part of CPU baseline features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fc04558da8dd3c7bccbbace9c70f03ebdb6a80" translate="yes" xml:space="preserve">
          <source>Any string in &lt;code&gt;numpy.sctypeDict&lt;/code&gt;.keys():</source>
          <target state="translated">Cualquier cadena en &lt;code&gt;numpy.sctypeDict&lt;/code&gt; .keys ():</target>
        </trans-unit>
        <trans-unit id="d713c0e047edfbd49f0b3846ac98a9a40d4a3161" translate="yes" xml:space="preserve">
          <source>Any third argument to &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt;&lt;code&gt;pow&lt;/code&gt;&lt;/a&gt; is silently ignored, as the underlying &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; takes only two arguments.</source>
          <target state="translated">Cualquier tercer argumento de &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt; &lt;code&gt;pow&lt;/code&gt; &lt;/a&gt; se ignora silenciosamente, ya que el &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt; subyacente solo toma dos argumentos.</target>
        </trans-unit>
        <trans-unit id="946a38c0dae9772a5b694f0cc7db9666bf07194e" translate="yes" xml:space="preserve">
          <source>Any time you want to use a package or library in your code, you first need to make it accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be63b1330ee25c1f855c85df25ca52d3b0d9ac" translate="yes" xml:space="preserve">
          <source>Any type object with a &lt;code&gt;dtype&lt;/code&gt; attribute: The attribute will be accessed and used directly. The attribute must return something that is convertible into a dtype object.</source>
          <target state="translated">Cualquier objeto de tipo con un atributo &lt;code&gt;dtype&lt;/code&gt; : se acceder&amp;aacute; al atributo y se utilizar&amp;aacute; directamente. El atributo debe devolver algo que se pueda convertir en un objeto dtype.</target>
        </trans-unit>
        <trans-unit id="a26626a547f9526333d65f7f7ac98e634e8d404b" translate="yes" xml:space="preserve">
          <source>Append a new recording filter or apply it if the state is entered.</source>
          <target state="translated">Añada un nuevo filtro de grabación o aplíquelo si se introduce el estado.</target>
        </trans-unit>
        <trans-unit id="2911a13c39db194e9958de7d85a60b6ad7244721" translate="yes" xml:space="preserve">
          <source>Append directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; to the list of directories searched for include files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01347379ae01a5a40d3d1ed49513be6a422e707d" translate="yes" xml:space="preserve">
          <source>Append elements at the end of an array.</source>
          <target state="translated">Agregar elementos al final de un arreglo.</target>
        </trans-unit>
        <trans-unit id="6e89159e1cc33f0d869902b46493c6f6e94db543" translate="yes" xml:space="preserve">
          <source>Append values to the end of an array.</source>
          <target state="translated">Agregar valores al final de un arreglo.</target>
        </trans-unit>
        <trans-unit id="481aab454c2962551cc9f57d11f57a67e0fca9e4" translate="yes" xml:space="preserve">
          <source>Appending to build flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9cf77e8ba225a7ce0a29de1d2139c5781725d4" translate="yes" xml:space="preserve">
          <source>Appends a data function to the data_files list that will generate __svn_version__.py file to the current package directory.</source>
          <target state="translated">Añade una función de datos a la lista de data_files que generará el archivo __svn_version__.py al directorio actual del paquete.</target>
        </trans-unit>
        <trans-unit id="33f5ee9b7c00e9ead408311c459141d052778da5" translate="yes" xml:space="preserve">
          <source>Applies an offset counted in valid days.</source>
          <target state="translated">Aplica una compensación contada en días válidos.</target>
        </trans-unit>
        <trans-unit id="2bf57444d43c734213e1d3c851fdf1b3fb150bdf" translate="yes" xml:space="preserve">
          <source>Applies glob.glob(&amp;hellip;) to each path in the sequence (if needed) and pre-pends the local_path if needed. Because this is called on all source lists, this allows wildcard characters to be specified in lists of sources for extension modules and libraries and scripts and allows path-names be relative to the source directory.</source>
          <target state="translated">Aplica glob.glob (&amp;hellip;) a cada ruta en la secuencia (si es necesario) y antepone local_path si es necesario. Debido a que esto se llama en todas las listas de fuentes, esto permite que se especifiquen caracteres comod&amp;iacute;n en listas de fuentes para m&amp;oacute;dulos de extensi&amp;oacute;n y bibliotecas y scripts y permite que los nombres de ruta sean relativos al directorio de fuentes.</target>
        </trans-unit>
        <trans-unit id="78652f7b097973c5af68766b38955ba3ae45a013" translate="yes" xml:space="preserve">
          <source>Applies the Einstein summation convention to the array operands provided, returning a new array or placing the result in &lt;em&gt;out&lt;/em&gt;. The string in &lt;em&gt;subscripts&lt;/em&gt; is a comma separated list of index letters. The number of operands is in &lt;em&gt;nop&lt;/em&gt;, and &lt;em&gt;op_in&lt;/em&gt; is an array containing those operands. The data type of the output can be forced with &lt;em&gt;dtype&lt;/em&gt;, the output order can be forced with &lt;em&gt;order&lt;/em&gt; (&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is recommended), and when &lt;em&gt;dtype&lt;/em&gt; is specified, &lt;em&gt;casting&lt;/em&gt; indicates how permissive the data conversion should be.</source>
          <target state="translated">Aplica la convenci&amp;oacute;n de suma de Einstein a los operandos de matriz proporcionados, devolviendo una nueva matriz o colocando el resultado dentro de &lt;em&gt;fuera&lt;/em&gt; . La cadena en &lt;em&gt;sub&amp;iacute;ndices&lt;/em&gt; es una lista separada por comas de letras &amp;iacute;ndice. El n&amp;uacute;mero de operandos est&amp;aacute; en &lt;em&gt;nop&lt;/em&gt; y &lt;em&gt;op_in&lt;/em&gt; es una matriz que contiene esos operandos. El tipo de datos de la salida se puede forzar con &lt;em&gt;dtype&lt;/em&gt; , el orden de salida se puede forzar con &lt;em&gt;order&lt;/em&gt; ( se recomienda &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; ), y cuando se especifica &lt;em&gt;dtype&lt;/em&gt; , la &lt;em&gt;conversi&amp;oacute;n&lt;/em&gt; indica qu&amp;eacute; tan permisiva debe ser la conversi&amp;oacute;n de datos.</target>
        </trans-unit>
        <trans-unit id="21feca4b141579d51c961cd00a897cb1717e4a03" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argpartition to an array as if by calling partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca4fe7fefd7c25f71a50eeea097cc697cb368a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argsort to an array as if by calling sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c436985ffd81a143fc825046932ac1ad32bff874" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmax to an array as if by calling max.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc1b6ea691ac922af6be7bae41f63f959261f5d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmin to an array as if by calling min.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c58f86e54424ee8c27debf26633ec82caf815e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;op&lt;/code&gt; to the arguments &lt;code&gt;*x&lt;/code&gt; elementwise, broadcasting the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15deb464b32712e5faad1a95646f2d13bba4428" translate="yes" xml:space="preserve">
          <source>Apply a decorator to all methods in a class matching a regular expression.</source>
          <target state="translated">Aplicar un decorador a todos los métodos de una clase que coincidan con una expresión regular.</target>
        </trans-unit>
        <trans-unit id="9aba00bb90c6eaaa703b9d293078221144653ecd" translate="yes" xml:space="preserve">
          <source>Apply a function repeatedly over multiple axes.</source>
          <target state="translated">Aplicar una función repetidamente sobre varios ejes.</target>
        </trans-unit>
        <trans-unit id="930471cd723d35b6c2b966e96ceecc291d0fdf6a" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices along the given axis.</source>
          <target state="translated">Aplicar una función a los cortes 1-D a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="60e579e665f3197d6488027d302750921e380286" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices of an array along the given axis.</source>
          <target state="translated">Aplicar una función a los cortes 1-D de un arreglo a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="8a69d5c1511c3d8cf1aef04b61ce82902f9e77f8" translate="yes" xml:space="preserve">
          <source>Apply function &amp;lsquo;func&amp;rsquo; as a reduction across fields of a structured array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f37352400ea0595778e975d3829366956d6422" translate="yes" xml:space="preserve">
          <source>Apply glob to paths and prepend local_path if needed.</source>
          <target state="translated">Aplicar glob a las rutas y preparar local_path si es necesario.</target>
        </trans-unit>
        <trans-unit id="6d57e8ee432c77c347bd91e42e1ec296a790a962" translate="yes" xml:space="preserve">
          <source>Apply linear map to input points.</source>
          <target state="translated">Aplicar el mapa lineal a los puntos de entrada.</target>
        </trans-unit>
        <trans-unit id="b451c47d03d2342612630d90e5961330763668d9" translate="yes" xml:space="preserve">
          <source>Apply the same function to a scalar value.</source>
          <target state="translated">Aplicar la misma función a un valor escalar.</target>
        </trans-unit>
        <trans-unit id="c19a38c87eebd888f6ee1a1c74150ed1ef57dd31" translate="yes" xml:space="preserve">
          <source>Apply the ufunc &lt;code&gt;op&lt;/code&gt; to all pairs (a, b) with a in &lt;code&gt;A&lt;/code&gt; and b in &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Aplicar la ufunc &lt;code&gt;op&lt;/code&gt; para todos los pares (A, B) con un en &lt;code&gt;A&lt;/code&gt; y B en &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b480bceb3391de1a231371b22b8f98d14965a74b" translate="yes" xml:space="preserve">
          <source>Applying to all colors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11fedb225efa784388e87f9d68e4b132e27f024" translate="yes" xml:space="preserve">
          <source>Approximation</source>
          <target state="translated">Approximation</target>
        </trans-unit>
        <trans-unit id="0a7e07004db73b8ccd197df301f0c0c88108495f" translate="yes" xml:space="preserve">
          <source>Arbitrary data (extra arguments, function names, &lt;em&gt;etc.&lt;/em&gt; ) that can be stored with the ufunc and will be passed in when it is called.</source>
          <target state="translated">Datos arbitrarios (argumentos adicionales, nombres de funciones, &lt;em&gt;etc.&lt;/em&gt; ) que se pueden almacenar con ufunc y se pasar&amp;aacute;n cuando se llame.</target>
        </trans-unit>
        <trans-unit id="d6c0ec3c601093336049eacec64ee0a29b472718" translate="yes" xml:space="preserve">
          <source>Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses will be accepted for writing, but only the array data will be written out. A regular numpy.ndarray object will be created upon reading the file.</source>
          <target state="translated">Las subclases arbitrarias de numpy.ndarray no se conservan completamente.Se aceptarán subclases para escribir,pero sólo se escribirán los datos del array.Se creará un objeto numpy.ndarray normal al leer el archivo.</target>
        </trans-unit>
        <trans-unit id="55d5f33d484d4926bb72a9fc085161f70575b63d" translate="yes" xml:space="preserve">
          <source>Arch option for windows binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91c75193c3842b9d909ec7b8dd4d035b07a9f55" translate="yes" xml:space="preserve">
          <source>Are all arguments of a type that we know how to handle?</source>
          <target state="translated">¿Todos los argumentos son del tipo que sabemos manejar?</target>
        </trans-unit>
        <trans-unit id="9bdf5e0978150bd50fab817fc37629d830ac57f1" translate="yes" xml:space="preserve">
          <source>Are axis or shape arguments tested to be &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;tuples&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bf0c3e3104c86791f4ce367eca2a5cc6cd438f" translate="yes" xml:space="preserve">
          <source>Are the array elements of type unicode (True) or string (False). Default is False.</source>
          <target state="translated">Son los elementos de la matriz de tipo unicode (Verdadero)o cadena (Falso).Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="b5b7142c8499ab6cb5dbe41cc158e30ea956ddca" translate="yes" xml:space="preserve">
          <source>Are unusual &lt;code&gt;dtypes&lt;/code&gt; tested if a function supports those?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fec1cc4e99f8522843b011fb68aafe3fb92c1c" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t how-tos and tutorials the same thing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c651546e6d3a9b3b4ba1458219c7c80e713538c6" translate="yes" xml:space="preserve">
          <source>Argmin and argmax out argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b5fdf11f1c668ee1bccda74e473d486cb80034" translate="yes" xml:space="preserve">
          <source>Argout Arrays</source>
          <target state="translated">Argout Arrays</target>
        </trans-unit>
        <trans-unit id="1f693ea5d95326ee12ba9edafca87f6f5ac163dc" translate="yes" xml:space="preserve">
          <source>Argout View Arrays</source>
          <target state="translated">Argout View Arrays</target>
        </trans-unit>
        <trans-unit id="9362235cd642830a37eb4b0e960e60e4a8a7f208" translate="yes" xml:space="preserve">
          <source>Argout arrays are arrays that appear in the input arguments in C, but are in fact output arrays. This pattern occurs often when there is more than one output variable and the single return argument is therefore not sufficient. In Python, the conventional way to return multiple arguments is to pack them into a sequence (tuple, list, etc.) and return the sequence. This is what the argout typemaps do. If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list, depending on the version of Python. The Python user does not pass these arrays in, they simply get returned. For the case where a dimension is specified, the python user must provide that dimension as an argument. The argout signatures are</source>
          <target state="translated">Las matrices de Argout son matrices que aparecen en los argumentos de entrada en C,pero que en realidad son matrices de salida.Este patrón se produce a menudo cuando hay más de una variable de salida y,por lo tanto,el único argumento de retorno no es suficiente.En Python,la forma convencional de devolver múltiples argumentos es empaquetarlos en una secuencia (tupla,lista,etc.)y devolver la secuencia.Esto es lo que hacen los mapas de tipos de argot.Si una función envuelta que utiliza estos mapas tipo argout tiene más de un argumento de retorno,se empaquetan en una tupla o lista,dependiendo de la versión de Python.El usuario de Python no pasa estas matrices,simplemente las devuelve.En el caso de que se especifique una dimensión,el usuario de python debe proporcionar esa dimensión como argumento.Las firmas del argumento son</target>
        </trans-unit>
        <trans-unit id="f0d811a8c8b43b06e028e619f05e9d14eafcdca7" translate="yes" xml:space="preserve">
          <source>Argoutview arrays are for when your C code provides you with a view of its internal data and does not require any memory to be allocated by the user. This can be dangerous. There is almost no way to guarantee that the internal data from the C code will remain in existence for the entire lifetime of the NumPy array that encapsulates it. If the user destroys the object that provides the view of the data before destroying the NumPy array, then using that array may result in bad memory references or segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply have no other choice.</source>
          <target state="translated">Las matrices Argoutview son para cuando su código C le proporciona una vista de sus datos internos y no requiere que el usuario le asigne ninguna memoria.Esto puede ser peligroso.Casi no hay forma de garantizar que los datos internos del código C permanezcan en existencia durante toda la vida útil de la matriz NumPy que lo encapsula.Si el usuario destruye el objeto que proporciona la vista de los datos antes de destruir la matriz NumPy,entonces el uso de esa matriz puede dar lugar a malas referencias de memoria o fallos de segmentación.Sin embargo,hay situaciones,trabajando con grandes conjuntos de datos,en las que simplemente no tienes otra opción.</target>
        </trans-unit>
        <trans-unit id="69013bc8794a33ce0d96e2362b8fd29875b1d20a" translate="yes" xml:space="preserve">
          <source>Argument can be either</source>
          <target state="translated">El argumento puede ser</target>
        </trans-unit>
        <trans-unit id="80e8304a176934810abc17d2d26c3888e65cbaa7" translate="yes" xml:space="preserve">
          <source>Argument of complex values.</source>
          <target state="translated">Argumento de valores complejos.</target>
        </trans-unit>
        <trans-unit id="103cd4d5d40741b2189f1a4cd45b1145dc7d5cc2" translate="yes" xml:space="preserve">
          <source>Argument of the Bessel function.</source>
          <target state="translated">Argumento de la función de Bessel.</target>
        </trans-unit>
        <trans-unit id="da03da7501b0f4c3d0e71a81aacac0740f6ea6ce" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either</source>
          <target state="translated">Los argumentos pueden ser</target>
        </trans-unit>
        <trans-unit id="3a267e3ae3a20fe67defefd5d3c99d6c87f6bed7" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either:</source>
          <target state="translated">Los argumentos pueden ser cualquiera de los dos:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="5649abe78903b9f6461061e275735b25a7054ccd" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fece9ebb467e36ae935eb7f9713ac9a4f47e841" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Los argumentos pasaron a &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed091b4d91808383da4576963f0c43e1c919be23" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the nose test runner. &lt;code&gt;argv[0]&lt;/code&gt; is ignored. All command line arguments accepted by &lt;code&gt;nosetests&lt;/code&gt; will work. If it is the default value None, sys.argv is used.</source>
          <target state="translated">Argumentos para pasar al corredor de pruebas de nariz. &lt;code&gt;argv[0]&lt;/code&gt; se ignora. Todos los argumentos de la l&amp;iacute;nea de comando aceptados por &lt;code&gt;nosetests&lt;/code&gt; funcionar&amp;aacute;n. Si es el valor predeterminado Ninguno, se utiliza sys.argv.</target>
        </trans-unit>
        <trans-unit id="a47a631225ff0c3415173266008602c859777e94" translate="yes" xml:space="preserve">
          <source>Arguments to pass on to the ufunc. Typically &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Argumentos para transmitir a la ufunc. Normalmente &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="424915704fdafa9f1991a2f818f149305624ecb5" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations</source>
          <target state="translated">Operaciones aritméticas y de comparación</target>
        </trans-unit>
        <trans-unit id="27c9afdfd25af93dd20b5c590862915ebec2aa5c" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e6f1226f47528d48f2f359b548a2a985744686" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;code&gt;data&lt;/code&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="translated">Las operaciones aritm&amp;eacute;ticas y de comparaci&amp;oacute;n son compatibles con matrices enmascaradas. En la medida de lo posible, las entradas no v&amp;aacute;lidas de una matriz enmascarada no se procesan, lo que significa que las entradas de &lt;code&gt;data&lt;/code&gt; correspondientes &lt;em&gt;deben&lt;/em&gt; ser las mismas antes y despu&amp;eacute;s de la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="574e424bf0f02d1b18e3ad5386f39a38953e230d" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; are defined as element-wise operations, and generally yield &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects as results.</source>
          <target state="translated">Las operaciones aritm&amp;eacute;ticas y de comparaci&amp;oacute;n en &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; se definen como operaciones por elementos y, por lo general, producen objetos &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; como resultados.</target>
        </trans-unit>
        <trans-unit id="6179dfdf1f721c4f139e7add385d54ea9025725c" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow.</source>
          <target state="translated">La aritmética es modular cuando se usan tipos enteros,y no se produce ningún error al desbordarse.</target>
        </trans-unit>
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="translated">La aritmética es modular cuando se usan tipos enteros,y no se produce ningún error al desbordarse.Eso significa que,en una plataforma de 32 bits:</target>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="translated">Media aritmética tomada sin ignorar el NaNs</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">Operaciones aritméticas</target>
        </trans-unit>
        <trans-unit id="7ee1fda772751523c2669ec2f48ddc06e8ec6d54" translate="yes" xml:space="preserve">
          <source>Arithmetic operators on arrays apply &lt;em&gt;elementwise&lt;/em&gt;. A new array is created and filled with the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="translated">Aritmética,en el lugar:</target>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="translated">Aritmética,multiplicación de matrices y operaciones de comparación</target>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">Matriz (posiblemente multidimensional) de valores para los que calcular &lt;code&gt;sinc(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0523df413b1fea0ba7975ab7c9175833f364830f" translate="yes" xml:space="preserve">
          <source>Array &lt;strong&gt;attributes&lt;/strong&gt; reflect information intrinsic to the array itself. If you need to get, or even set, properties of an array without creating a new array, you can often access an array through its attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="translated">Matriz API</target>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="translated">Atributos de la matriz</target>
        </trans-unit>
        <trans-unit id="3458034e7e106c04c09c4ec57632af02a473c676" translate="yes" xml:space="preserve">
          <source>Array Broadcasting in Numpy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a37c234fe9514069c7363784bf98af15b8355" translate="yes" xml:space="preserve">
          <source>Array Creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="translated">Funciones de la matriz</target>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="translated">Matriz Iterator</target>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="translated">API del Iterator Array</target>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="translated">Iteradores de la matriz</target>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="translated">Array Scalars</target>
        </trans-unit>
        <trans-unit id="d8dbcc76e586f64f22d24c3030096b5747dde0a4" translate="yes" xml:space="preserve">
          <source>Array arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="translated">Atributos de la matriz</target>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="translated">Los atributos de la matriz reflejan información que es intrínseca a la propia matriz.Generalmente,el acceso a un array a través de sus atributos permite obtener y a veces establecer propiedades intrínsecas del array sin crear un nuevo array.Los atributos expuestos son las partes centrales de un array y sólo algunos de ellos pueden ser restablecidos de forma significativa sin crear un nuevo array.A continuación se ofrece información sobre cada atributo.</target>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; &lt;/a&gt; ejes de matriz, numpy.sum .</target>
        </trans-unit>
        <trans-unit id="c2c33d8dc2ce945222653dfcc314e267ebd95901" translate="yes" xml:space="preserve">
          <source>Array coercion changes when Strings and other types are mixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3499b80a79c532bb5bd65ecb4071851e51014ae" translate="yes" xml:space="preserve">
          <source>Array coercion restructure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c60efa53930ae07f9d8ba23de0e194c69cf7fe" translate="yes" xml:space="preserve">
          <source>Array comparison assertions include maximum differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347b135c7cac14f05d7b1660f5d4b4c54f55d66d" translate="yes" xml:space="preserve">
          <source>Array comparisons involving strings or structured dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene los datos que se van a promediar. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="translated">Matriz que contiene elementos para recortar.</target>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Array que contiene n&amp;uacute;mero de n&amp;uacute;meros de punto flotante representables entre los elementos en &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuyo m&amp;aacute;ximo se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuya media se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuyo m&amp;iacute;nimo se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuyo producto se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuya suma se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Matriz que contiene n&amp;uacute;meros cuya varianza se desea. Si &lt;code&gt;a&lt;/code&gt; no es una matriz, una conversi&amp;oacute;n que se intente.</target>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="translated">Conjunto que contiene las raíces de la serie.</target>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="translated">El contenido de la matriz</target>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="translated">Conversión de matrices</target>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="translated">Convolución de la matriz.La misma salida que el polímero,pero tiene un parámetro para el modo de superposición.</target>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="translated">Creación de la matriz</target>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="translated">Rutinas de creación de matrices</target>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="translated">Datos de la matriz para ser guardados.</target>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="translated">Tipo de datos de la matriz.</target>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="translated">Arreglo deseado.</target>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="translated">Banderas de la matriz</target>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="translated">Los indicadores de la matriz proporcionan información sobre cómo debe interpretarse el área de memoria utilizada para la matriz.Hay 7 banderas booleanas en uso,de las cuales sólo cuatro pueden ser cambiadas por el usuario:WRITEBACKIFCOPY,UPDATEIFCOPY,WRITEABLE y ALIGNED.</target>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="translated">Banderas de la matriz;puede ser una o más de ellas:</target>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="translated">Matriz de la que se toman las diagonales.</target>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="translated">Arreglo del cual se extrae una parte.</target>
        </trans-unit>
        <trans-unit id="e35c942121269158d9bce83e940f79fd38671bbd" translate="yes" xml:space="preserve">
          <source>Array indexing refers to any use of the square brackets ([]) to index array values. There are many options to indexing, which give numpy indexing great power, but with power comes some complexity and the potential for confusion. This section is just an overview of the various options and issues related to indexing. Aside from single element indexing, the details on most of these options are to be found in related sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="translated">Interfaz de la matriz</target>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Interpretaci&amp;oacute;n de matriz de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="translated">Interpretaci&amp;oacute;n de matriz de &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; es un ndarray o una subclase de ndarray, se devuelve como est&amp;aacute; y no se realiza ninguna copia.</target>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">Interpretaci&amp;oacute;n de matriz de &lt;code&gt;a&lt;/code&gt; . No se realiza ninguna copia si la entrada ya es un ndarray con dtype y order coincidentes. Si &lt;code&gt;a&lt;/code&gt; es una subclase de ndarray, se devuelve una clase base ndarray.</target>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">Interpretaci&amp;oacute;n de matriz de &lt;code&gt;a&lt;/code&gt; . No se realiza ninguna copia si la entrada ya es un ndarray. Si &lt;code&gt;a&lt;/code&gt; es una subclase de ndarray, se devuelve una clase base ndarray.</target>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Matriz en la que se coloca la salida.Se conserva su tipo y debe tener la forma adecuada para mantener la salida.</target>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Matriz en la que se puede colocar el resultado.Se conserva su tipo y debe tener la forma adecuada para mantener la salida.</target>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="translated">Matriz como el objeto índice o el objeto cortado para indexar en el primer operando.Si el primer operando tiene múltiples dimensiones,los índices pueden ser una tupla de matriz como los objetos índice o los objetos rebanada.</target>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="translated">Rutinas de manipulación de arreglos</target>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="translated">Método de matriz alternativa API</target>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="translated">Métodos de arreglo...</target>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="translated">Mezclas de arreglos</target>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="translated">Los objetos de la matriz...</target>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="translated">Arreglo obtenido.</target>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="translated">Matriz de &lt;code&gt;fill_value&lt;/code&gt; con la forma, el tipo y el orden dados.</target>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de &lt;code&gt;fill_value&lt;/code&gt; con la misma forma y tipo que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Conjunto de coeficientes de la serie Chebyshev.Si c es multidimensional,los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el índice correspondiente.</target>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Matriz de coeficientes de la serie de Hermite. Si &lt;code&gt;c&lt;/code&gt; es multidimensional los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el &amp;iacute;ndice correspondiente.</target>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Conjunto de coeficientes de la serie de Hermite.Si c es multidimensional,los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el índice correspondiente.</target>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Matriz de coeficientes de la serie Hermite_e. Si &lt;code&gt;c&lt;/code&gt; es multidimensional los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el &amp;iacute;ndice correspondiente.</target>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Conjunto de coeficientes de la serie Hermite_e.Si c es multidimensional,los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el índice correspondiente.</target>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Matriz de coeficientes de la serie de Laguerre. Si &lt;code&gt;c&lt;/code&gt; es multidimensional los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el &amp;iacute;ndice correspondiente.</target>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Coeficientes de la serie de Legendre.Si c es multidimensional,los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el índice correspondiente.</target>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Matriz de &amp;aacute;ngulos en radianes, en el rango &lt;code&gt;[-pi, pi]&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="translated">Una serie de cubos de basura.Tiene que ser unidimensional y monótono.</target>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="translated">Una serie de booleanos...</target>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores booleanos de forma id&amp;eacute;ntica a &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores booleanos de la misma forma que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Matriz de coeficientes ordenados de modo que el coeficiente del t&amp;eacute;rmino de varios grados i, j est&amp;eacute; contenido en &lt;code&gt;c[i,j]&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; tiene una dimensi&amp;oacute;n mayor que 2, los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples conjuntos de coeficientes.</target>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Matriz de coeficientes ordenados de modo que el coeficiente del t&amp;eacute;rmino de varios grados i, j est&amp;eacute; contenido en &lt;code&gt;c[i,j]&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; tiene una dimensi&amp;oacute;n mayor que dos, los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples conjuntos de coeficientes.</target>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Matriz de coeficientes ordenados de modo que el coeficiente del t&amp;eacute;rmino de varios grados i, j, k est&amp;eacute; contenido en &lt;code&gt;c[i,j,k]&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; tiene una dimensi&amp;oacute;n mayor que 3, los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples conjuntos de coeficientes.</target>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Matriz de coeficientes ordenados de modo que los coeficientes para t&amp;eacute;rminos de grado i, j est&amp;eacute;n contenidos en &lt;code&gt;c[i,j]&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; tiene una dimensi&amp;oacute;n mayor que dos, los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples conjuntos de coeficientes.</target>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Matriz de coeficientes ordenados de manera que los coeficientes para t&amp;eacute;rminos de grado n est&amp;eacute;n contenidos en c [n]. Si &lt;code&gt;c&lt;/code&gt; es multidimensional, los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples polinomios. En el caso bidimensional, se puede pensar que los coeficientes est&amp;aacute;n almacenados en las columnas de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="translated">Una serie de valores uniformemente espaciados.</target>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="translated">Matriz de &amp;iacute;ndices en la matriz. Tiene la misma forma que &lt;code&gt;a.shape&lt;/code&gt; con la dimensi&amp;oacute;n a lo largo del &lt;code&gt;axis&lt;/code&gt; eliminado.</target>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">Matriz de &amp;iacute;ndices que se dividen &lt;code&gt;a&lt;/code&gt; lo largo del eje especificado. Si &lt;code&gt;a&lt;/code&gt; es unidimensional, &lt;code&gt;a[index_array]&lt;/code&gt; rinde un reparti&amp;oacute; &lt;code&gt;a&lt;/code&gt; . De manera m&amp;aacute;s general, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; siempre produce la partici&amp;oacute;n &lt;code&gt;a&lt;/code&gt; , independientemente de la dimensionalidad.</target>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">Matriz de &amp;iacute;ndices que ordenan &lt;code&gt;a&lt;/code&gt; lo largo del &lt;code&gt;axis&lt;/code&gt; especificado . Si &lt;code&gt;a&lt;/code&gt; es unidimensional, &lt;code&gt;a[index_array]&lt;/code&gt; produce un ordenado &lt;code&gt;a&lt;/code&gt; . De manera m&amp;aacute;s general, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; siempre produce el ordenado &lt;code&gt;a&lt;/code&gt; , independientemente de la dimensionalidad.</target>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de &amp;iacute;ndices que ordenan &lt;code&gt;a&lt;/code&gt; lo largo del eje especificado. En otras palabras, &lt;code&gt;a[index_array]&lt;/code&gt; produce un ordenado &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="translated">Conjunto de índices que ordenan las teclas a lo largo del eje especificado.</target>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Matriz de puntos de inserci&amp;oacute;n con la misma forma que &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">Matriz de longitud &lt;code&gt;n//2 + 1&lt;/code&gt; contiene las frecuencias de muestra.</target>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">Matriz de longitud &lt;code&gt;n&lt;/code&gt; que contiene las frecuencias de muestra.</target>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="translated">Matriz de objetos de la lista</target>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="translated">Conjunto de multiplicadores.</target>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="translated">Una serie de números que se descompondrán.</target>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="translated">Una serie de los que tienen la forma,el tipo y el orden dados.</target>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de otros con la misma forma y tipo que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="translated">Una serie de ellas.</target>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="translated">Matriz de puntos de la misma forma que &lt;code&gt;x&lt;/code&gt; , despu&amp;eacute;s de la aplicaci&amp;oacute;n del mapa lineal entre los dos dominios.</target>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="translated">Matriz de puntos. El dtype se convierte en float64 o complex128 dependiendo de si alguno de los elementos es complejo. Si &lt;code&gt;x&lt;/code&gt; es escalar, se convierte en una matriz 1-D.</target>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Conjunto de coeficientes polinómicos.Si c es multidimensional,los diferentes ejes corresponden a diferentes variables con el grado en cada eje dado por el índice correspondiente.</target>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="translated">Matriz de flotantes aleatorios de &lt;code&gt;size&lt;/code&gt; de forma (a menos que &lt;code&gt;size=None&lt;/code&gt; , en cuyo caso se devuelve un solo flotante).</target>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Matriz de ra&amp;iacute;ces. Si &lt;code&gt;r&lt;/code&gt; es multidimensional, el primer &amp;iacute;ndice es el &amp;iacute;ndice ra&amp;iacute;z, mientras que los &amp;iacute;ndices restantes enumeran m&amp;uacute;ltiples polinomios. Por ejemplo, en el caso bidimensional, las ra&amp;iacute;ces de cada polinomio se pueden considerar almacenadas en las columnas de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">Matriz de las ra&amp;iacute;ces del polinomio. Si todas las ra&amp;iacute;ces son reales, entonces &lt;code&gt;out&lt;/code&gt; tambi&amp;eacute;n es real, de lo contrario, es complejo.</target>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">Matriz de las ra&amp;iacute;ces de la serie. Si todas las ra&amp;iacute;ces son reales, entonces &lt;code&gt;out&lt;/code&gt; tambi&amp;eacute;n es real, de lo contrario, es complejo.</target>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Matriz de la misma forma que &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz del mismo tipo y forma que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="translated">Conjunto de dos o más dimensiones.</target>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Matriz de dos exponentes. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="translated">Matriz de tipo uint8 cuyos elementos representan bits correspondientes al valor l&amp;oacute;gico (0 o distinto de cero) de los elementos de entrada. La forma de &lt;code&gt;packed&lt;/code&gt; tiene el mismo n&amp;uacute;mero de dimensiones que la entrada (a menos que el &lt;code&gt;axis&lt;/code&gt; sea ​​Ninguno, en cuyo caso la salida es 1-D).</target>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="translated">Conjunto de datos no inicializados (arbitrarios)de la forma,tipo y orden dados.Las matrices de objetos se inicializarán en Ninguno.</target>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="translated">Matriz de datos no inicializados (arbitrarios) con la misma forma y tipo que el &lt;code&gt;prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b00e6648235fca7be6befd806901affb44faa6e" translate="yes" xml:space="preserve">
          <source>Array of variates drawn from the multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="translated">Una serie de ceros con la forma,tipo y orden dados.</target>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de ceros con la misma forma y tipo que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">Array u objeto &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; de los coeficientes del polinomio de diferencia.</target>
        </trans-unit>
        <trans-unit id="dbb2927a7be8102e0b46249ee761be13ecebeed6" translate="yes" xml:space="preserve">
          <source>Array or sequence of arrays storing the fields to add to the base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f2bfa93bf415207add71f7123707aa76abefda" translate="yes" xml:space="preserve">
          <source>Array output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7dfcc33834d14fc2a907169048d0358bdabe51" translate="yes" xml:space="preserve">
          <source>Array output, specified fill-in value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="translated">Prioridad de la matriz.</target>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="translated">Propiedad de la matriz que devuelve la matriz transpuesta.</target>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="translated">Protocolo de la matriz:Lado de la pitón</target>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="translated">Protocolo de la matriz:estructura</target>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="translated">La matriz que representa la serie de Chebyshev de su suma.</target>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="translated">La matriz que representa la serie de Hermite de su suma.</target>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="translated">La matriz que representa la serie de Laguerre de su suma.</target>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="translated">La matriz que representa la serie de Legendre de su suma.</target>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="translated">Matriz que representa el resultado de la multiplicación.</target>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="translated">El escalar de la matriz comprueba el valor,la matriz no</target>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="translated">Array tipo escalar</target>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="translated">Los escalares de matriz se pueden indexar como matrices de dimensi&amp;oacute;n 0: si &lt;em&gt;x&lt;/em&gt; es un escalar de matriz,</target>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="translated">Los escalares de matriz tienen exactamente los mismos m&amp;eacute;todos que las matrices. El comportamiento predeterminado de estos m&amp;eacute;todos es convertir internamente el escalar en una matriz de dimensi&amp;oacute;n 0 equivalente y llamar al m&amp;eacute;todo de matriz correspondiente. Adem&amp;aacute;s, las operaciones matem&amp;aacute;ticas en escalares de matriz se definen para que se establezcan y utilicen los mismos indicadores de hardware para interpretar los resultados que para &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt; , de modo que el estado de error utilizado para ufuncs tambi&amp;eacute;n se transfiera a las matem&amp;aacute;ticas en escalares de matriz.</target>
        </trans-unit>
        <trans-unit id="037bfe1a4a99bed13c2116a48ffe9e15e096321a" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">Los escalares de matriz tienen los mismos atributos y m&amp;eacute;todos que los &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; Esto permite tratar los elementos de una matriz en parte en la misma base que las matrices, suavizando los bordes &amp;aacute;speros que resultan al mezclar operaciones escalares y de matriz.</target>
        </trans-unit>
        <trans-unit id="646d54d2caceda76929950b800cb978c81f4566e" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;a href=&quot;#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Los escalares de matriz viven en una jerarqu&amp;iacute;a (consulte la Figura siguiente) de tipos de datos. Se pueden detectar utilizando la jerarqu&amp;iacute;a: por ejemplo, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;True&lt;/code&gt; si &lt;em&gt;val&lt;/em&gt; es un objeto escalar de matriz. Alternativamente, el tipo de matriz escalar que est&amp;aacute; presente puede determinarse utilizando otros miembros de la jerarqu&amp;iacute;a de tipos de datos. Por lo tanto, por ejemplo, &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;True&lt;/code&gt; si &lt;em&gt;val&lt;/em&gt; es un tipo de valor complejo, mientras que &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; devolver&amp;aacute; verdadero si &lt;em&gt;val&lt;/em&gt; es uno de los tipos de matriz de tama&amp;ntilde;o de elemento flexible ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;unicode&lt;/code&gt; , &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="translated">Forma de la matriz.</target>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="translated">Estructura de la matriz y acceso a los datos</target>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="translated">Matriz que selecciona qu&amp;eacute; entradas devolver. Si len (condici&amp;oacute;n) es menor que el tama&amp;ntilde;o de a &lt;code&gt;a&lt;/code&gt; lo largo del eje dado, la salida se trunca a la longitud de la matriz de condiciones.</target>
        </trans-unit>
        <trans-unit id="592206156ca99ae21d8e7426eb607780c1bba521" translate="yes" xml:space="preserve">
          <source>Array that suppressed values indicated by a mask:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="translated">La matriz se dividirá en submatrices.</target>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="translated">El conjunto será remodelado.</target>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="translated">La matriz debe ser redimensionada.</target>
        </trans-unit>
        <trans-unit id="a56492e54afe7d74e97671bd4eee3157258038ae" translate="yes" xml:space="preserve">
          <source>Array to be shuffled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="translated">La matriz debe ser ordenada.</target>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="translated">Matriz para comprobar los valores enmascarados.</target>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="translated">Array para crear un nuevo...</target>
        </trans-unit>
        <trans-unit id="38e408cec29face92846919cb92911927e113755" translate="yes" xml:space="preserve">
          <source>Array to create the sliding window view from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="translated">Arreglo para enmascarar</target>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="translated">Arreglos para la máscara.</target>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="translated">Matriz para poner los datos en.</target>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="translated">Arreglar para clasificar.</target>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="translated">Arreglo para la prueba.</target>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="translated">Prueba de tipo de matriz</target>
        </trans-unit>
        <trans-unit id="585f95a404e839b1977230612e779c3487e0200e" translate="yes" xml:space="preserve">
          <source>Array types and conversions between types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023792f2b2e17a7b6e86f7c45b577b4c007acb28" translate="yes" xml:space="preserve">
          <source>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric. Some documentation may still refer to these, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d6303545819c17e2ef1222e68fb70dc26c55f8" translate="yes" xml:space="preserve">
          <source>Array whose &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; is a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="translated">El conjunto cuya diagonal debe ser rellenada,se modifica en el lugar.</target>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">Array con su tri&amp;aacute;ngulo inferior lleno de unos y cero en el resto; en otras palabras &lt;code&gt;T[i,j] == 1&lt;/code&gt; para &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt; , 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="b85c2934c5f2a59bc2e12dac7625860a488c925e" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="translated">Arreglo con ejes movidos.Esta matriz es una vista de la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="translated">Arreglo con requisitos específicos y tipo si se da.</target>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="translated">Revisando los restipos/argumentos.</target>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="translated">Cadenas de tipo de protocolo de matriz (consulte &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;La interfaz de matriz&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="translated">Tipos de escalas de matriz</target>
        </trans-unit>
        <trans-unit id="8160528d25c4bf32940e604af5858cd6853079e6" translate="yes" xml:space="preserve">
          <source>ArrayLike</source>
          <target state="translated">ArrayLike</target>
        </trans-unit>
        <trans-unit id="91f0d52225d31ae76fcb11c767a8c5c08a4c298a" translate="yes" xml:space="preserve">
          <source>ArrayLike objects which do not define &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50913b40e0e8d9dc26876d10bb49f2fa38c66fb" translate="yes" xml:space="preserve">
          <source>Array_like means all those objects &amp;ndash; lists, nested lists, etc. &amp;ndash; that can be converted to an array. We can also refer to variables like &lt;code&gt;var1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="translated">Las matrices &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="f2499f813f17514e2097a1073a6cd307b768602d" translate="yes" xml:space="preserve">
          <source>Arrays based off readonly buffers cannot be set &lt;code&gt;writeable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="translated">Los arreglos pueden ser contiguos al estilo C y al estilo Fortran simultáneamente.Esto está claro para los conjuntos de una dimensión,pero también puede ser cierto para los conjuntos de dimensiones superiores.</target>
        </trans-unit>
        <trans-unit id="9cba266ac8d90f704b5607af4e06eea419c285f7" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">Las matrices se pueden indexar utilizando una sintaxis de divisi&amp;oacute;n de Python extendida, &lt;code&gt;array[selection]&lt;/code&gt; . Tambi&amp;eacute;n se utiliza una sintaxis similar para acceder a los campos en un &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;tipo de datos estructurados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7125fa97866bba33cfadfef25acde94b75f55b74" translate="yes" xml:space="preserve">
          <source>Arrays cannot be using subarray dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d674e5d59a78e41b46aaf270748b55f0fb8f59d0" translate="yes" xml:space="preserve">
          <source>Arrays do not need to have the same &lt;em&gt;number&lt;/em&gt; of dimensions. For example, if you have a &lt;code&gt;256x256x3&lt;/code&gt; array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf5c66690e5daa90427ed3c7163aa6397d5aeea" translate="yes" xml:space="preserve">
          <source>Arrays may be repeated along dimensions of length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="translated">Las matrices pueden tener tipos de datos que contienen campos, an&amp;aacute;logos a las columnas de una hoja de c&amp;aacute;lculo. Un ejemplo es &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt; , donde cada entrada en la matriz es un par de &lt;code&gt;(int, float)&lt;/code&gt; . Normalmente, se accede a estos atributos mediante b&amp;uacute;squedas en diccionarios como &lt;code&gt;arr['x']&lt;/code&gt; y &lt;code&gt;arr['y']&lt;/code&gt; . Arrays de registro permiten a los campos para utilizarse como miembros de la matriz, utilizando &lt;code&gt;arr.x&lt;/code&gt; y &lt;code&gt;arr.y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b36ecf0a7f7bd039ed5c1c0704a51fefda73d80e" translate="yes" xml:space="preserve">
          <source>Arrays may have more than one dimension, each which can be sliced individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c0cea98d6d20ecb3d174c3213bef74e8bc018" translate="yes" xml:space="preserve">
          <source>Arrays of byte-strings are not swapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">Matrices de números uniformemente espaciados en dimensiones N.</target>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="translated">Matrices de coordenadas de puntos,todas de la misma forma.Los tipos se convertirán en flotantes64 o complejos128 dependiendo de si alguno de los elementos es complejo.Los escalares se convierten en arreglos de 1-D.</target>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="translated">Los conjuntos de cuerdas no se intercambian</target>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Matrices de valores. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="translated">Las matrices deben construirse utilizando &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; (consulte la secci&amp;oacute;n Vea tambi&amp;eacute;n a continuaci&amp;oacute;n). Los par&amp;aacute;metros dados aqu&amp;iacute; se refieren a un m&amp;eacute;todo de bajo nivel ( &lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt; ) para instanciar una matriz.</target>
        </trans-unit>
        <trans-unit id="28d3efbe465ae0abcb5a0dfba10ae7944a7f48a2" translate="yes" xml:space="preserve">
          <source>Arrays support the iterator protocol and can be iterated over like Python lists. See the &lt;a href=&quot;../user/quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;Indexing, Slicing and Iterating&lt;/a&gt; section in the Quickstart guide for basic usage and examples. The remainder of this document presents the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object and covers more advanced usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfb0f71df3562232665c06d9cf63f39acceecc4" translate="yes" xml:space="preserve">
          <source>Arrays to be compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="translated">Matrices para guardar en el archivo.Los arreglos se guardarán en el archivo con los nombres de las palabras clave.</target>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">Matrices para guardar en el archivo. Dado que Python no puede conocer los nombres de las matrices fuera de &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; , las matrices se guardar&amp;aacute;n con los nombres &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, etc. Estos argumentos pueden ser cualquier expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">Matrices para guardar en el archivo. Dado que Python no puede conocer los nombres de las matrices fuera de &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; , las matrices se guardar&amp;aacute;n con los nombres &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, etc. Estos argumentos pueden ser cualquier expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="translated">Arreglos para apilar.Todos ellos deben tener la misma primera dimensión.</target>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="translated">Las matrices con dtypes complejos no devuelven True.</target>
        </trans-unit>
        <trans-unit id="a2bd40fc5b54aa90919de15beac751e23ad15489" translate="yes" xml:space="preserve">
          <source>Arrayterator (class in numpy.lib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">Como &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; es una subclase de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , una matriz enmascarada tambi&amp;eacute;n hereda todos los atributos y propiedades de una instancia de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc5d12d9a06d1a300c059aee30b6e3298b8cd56" translate="yes" xml:space="preserve">
          <source>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="translated">Como &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; es una subclase de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , hereda sus mecanismos para indexar y segmentar.</target>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="translated">Para comodidad de los implementadores de &lt;code&gt;__array_function__&lt;/code&gt; , los &lt;code&gt;types&lt;/code&gt; proporcionan a todos los tipos de argumentos un atributo &lt;code&gt;'__array_function__'&lt;/code&gt; . Esto permite a los implementadores identificar r&amp;aacute;pidamente los casos en los que deber&amp;iacute;an diferir de &lt;code&gt;__array_function__&lt;/code&gt; implementaciones de __array_function__ en otros argumentos. Las implementaciones no deben depender del orden de iteraci&amp;oacute;n de los &lt;code&gt;types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="translated">Como corolario de este cambio,ya no prohibimos el casting entre fechas con unidades de fecha y fechas con unidades de tiempo.Con las fechas y horas ingenuas de las zonas horarias,la regla para el casting de fechas a horas ya no es ambigua.</target>
        </trans-unit>
        <trans-unit id="013d98a5ec5b7f58afd0279b5cb85ae341df8643" translate="yes" xml:space="preserve">
          <source>As a final note: if the &lt;code&gt;super&lt;/code&gt; route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class &lt;code&gt;B&lt;/code&gt; also used the &lt;code&gt;super&lt;/code&gt; in its &lt;code&gt;__array_ufunc__&lt;/code&gt; implementation, and we created a class &lt;code&gt;C&lt;/code&gt; that depended on both, i.e., &lt;code&gt;class C(A, B)&lt;/code&gt; (with, for simplicity, not another &lt;code&gt;__array_ufunc__&lt;/code&gt; override). Then any ufunc on an instance of &lt;code&gt;C&lt;/code&gt; would pass on to &lt;code&gt;A.__array_ufunc__&lt;/code&gt;, the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;A&lt;/code&gt; would go to &lt;code&gt;B.__array_ufunc__&lt;/code&gt;, and the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;B&lt;/code&gt; would go to &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt;, thus allowing &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; to collaborate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839c21dc6f9c35797b35f17417f1d765334d2a61" translate="yes" xml:space="preserve">
          <source>As a rough estimate, a sliding window approach with an input size of &lt;code&gt;N&lt;/code&gt; and a window size of &lt;code&gt;W&lt;/code&gt; will scale as &lt;code&gt;O(N*W)&lt;/code&gt; where frequently a special algorithm can achieve &lt;code&gt;O(N)&lt;/code&gt;. That means that the sliding window variant for a window size of 100 can be a 100 times slower than a more specialized version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="translated">Como alternativa a &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt; , hay una serie de etiquetas que puede utilizar.</target>
        </trans-unit>
        <trans-unit id="3dab1c17c36782c312875481e08692d9b809435e" translate="yes" xml:space="preserve">
          <source>As an example, for &lt;code&gt;numpy.mean&lt;/code&gt; we would have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecff8f943e371686abc1110d1711ebbbb86c5fa" translate="yes" xml:space="preserve">
          <source>As an example, see the 1.14.3 REL commit: &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="translated">Como ejemplo,imprimimos el resultado de la emisión de un conjunto de una y dos dimensiones juntas.</target>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="translated">Como ilustraci&amp;oacute;n, consideremos el siguiente conjunto de datos:</target>
        </trans-unit>
        <trans-unit id="3c1410845edf2c868fb5a0fe8e6419a05b6e17f2" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt; that allows access to fields of structured arrays by attribute instead of only by index. Record arrays use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array. The &lt;code&gt;numpy.rec&lt;/code&gt; module provides functions for creating recarrays from various objects. Additional helper functions for creating and manipulating structured arrays can be found in &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06bd4fa6779fdd07b3d52175c70a52bf6deacdac" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt;, and associated helper functions in the &lt;code&gt;numpy.rec&lt;/code&gt; submodule, that allows access to fields of structured arrays by attribute instead of only by index. Record arrays also use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="translated">Como ejemplo trivial, considere esta implementaci&amp;oacute;n de una clase &lt;code&gt;ArrayLike&lt;/code&gt; que simplemente envuelve una matriz NumPy y asegura que el resultado de cualquier operaci&amp;oacute;n aritm&amp;eacute;tica tambi&amp;eacute;n sea un objeto &lt;code&gt;ArrayLike&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="translated">Como puede verse, las partes &quot;buenas&quot; se han reducido a la insignificancia. Al usar polinomios de Chebyshev para ajustar, queremos usar la regi&amp;oacute;n donde &lt;code&gt;x&lt;/code&gt; est&amp;aacute; entre -1 y 1 y eso es lo &lt;code&gt;window&lt;/code&gt; especifica la ventana . Sin embargo, es poco probable que los datos que se van a ajustar tengan todos sus puntos de datos en ese intervalo, por lo que usamos &lt;code&gt;domain&lt;/code&gt; para especificar el intervalo donde se encuentran los puntos de datos. Cuando se realiza el ajuste, el dominio se asigna primero a la ventana mediante una transformaci&amp;oacute;n lineal y el ajuste por m&amp;iacute;nimos cuadrados habitual se realiza utilizando los puntos de datos asignados. La ventana y el dominio del ajuste son parte de la serie devuelta y se utilizan autom&amp;aacute;ticamente al calcular valores, derivadas, etc. Si no se especifican en la llamada, la rutina de ajuste utilizar&amp;aacute; la ventana predeterminada y el dominio m&amp;aacute;s peque&amp;ntilde;o que contiene todos los puntos de datos. Esto se ilustra a continuaci&amp;oacute;n para un ajuste a una curva sinusoidal ruidosa.</target>
        </trans-unit>
        <trans-unit id="e0bc58a150fd519b1ef1b28d23e1c4528291bcac" translate="yes" xml:space="preserve">
          <source>As expected, this is a 768x1024 matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53fc1e45dbe406be17b6e30a5cfb9d43c0f2859" translate="yes" xml:space="preserve">
          <source>As explained previously, C-style contiguous arrays and Fortran-style contiguous arrays have particular striding patterns. Two array flags (&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;) indicate whether or not the striding pattern of a particular array matches the C-style contiguous or Fortran-style contiguous or neither. Whether or not the striding pattern matches a standard C or Fortran one can be tested Using &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (obj) and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (obj) respectively. Most third-party libraries expect contiguous arrays. But, often it is not difficult to support general-purpose striding. I encourage you to use the striding information in your own code whenever possible, and reserve single-segment requirements for wrapping third-party code. Using the striding information provided with the ndarray rather than requiring a contiguous striding reduces copying that otherwise must be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdede3e80508e2816102dcd54a9d5c797c31ec48" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">En cuanto a &lt;code&gt;ndarray.tobytes&lt;/code&gt; , se perder&amp;aacute; informaci&amp;oacute;n sobre la forma, dtype, etc., pero tambi&amp;eacute;n sobre &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="442dd71dc758bc00985af7b82e3b46e788353af0" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="translated">Resulta que el numpy es lo suficientemente inteligente cuando se trata de ufuncs para determinar qué índice es el que varía más rápidamente en la memoria y lo utiliza para el bucle más interno.Por lo tanto,para los ufuncs no hay una gran ventaja intrínseca en ninguno de los dos enfoques en la mayoría de los casos.Por otra parte,el uso de .flat con una matriz ordenada por FORTRAN conducirá a un acceso no óptimo a la memoria,ya que los elementos adyacentes en la matriz aplanada (iterador,en realidad)no son contiguos en la memoria.</target>
        </trans-unit>
        <trans-unit id="bae171d630e66c8dccf252742ea919c5676002d9" translate="yes" xml:space="preserve">
          <source>As mentioned in the Notes section, &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt;&lt;code&gt;assert_array_equal&lt;/code&gt;&lt;/a&gt; has special handling for scalars. Here the test checks that each value in &lt;code&gt;x&lt;/code&gt; is 3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="translated">Como se mencionó anteriormente,el atributo plano de los objetos ndarray devuelve un iterador que circulará por todo el array en orden contiguo de tipo C.</target>
        </trans-unit>
        <trans-unit id="1eeb436878ddf7f47ab4d8c1fb337ec14f285994" translate="yes" xml:space="preserve">
          <source>As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="translated">Como se ha señalado anteriormente,la distribución gaussiana inversa surge primero de los intentos de modelar el movimiento browniano.También es un competidor de la Weibull para su uso en el modelado de la fiabilidad y el modelado de los rendimientos de las existencias y los procesos de los tipos de interés.</target>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="translated">A partir de 1.6, esta funci&amp;oacute;n simplemente llama a &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt; &lt;code&gt;PyArray_CopyInto&lt;/code&gt; &lt;/a&gt; , que maneja la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="translated">A partir de NumPy 1.10,la matriz devuelta tendrá el mismo tipo que la matriz de entrada.(por ejemplo,una matriz enmascarada será devuelta para una entrada de matriz enmascarada)</target>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A partir de NumPy 1.4.0, &lt;a href=&quot;#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; funciona con matrices reales / complejas que contienen valores nan. El orden de clasificaci&amp;oacute;n mejorado se documenta en &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A partir de NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; funciona con matrices reales / complejas que contienen valores &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; . El orden de clasificaci&amp;oacute;n mejorado se documenta en &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A partir de NumPy 1.6.0, estos iteradores de matriz son reemplazados por el nuevo iterador de matriz, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8364d1abaebc5d8b1444ea31949f7accfaa13ead" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f60464691ec1296f5eb92b23ac7c66b95bdc223" translate="yes" xml:space="preserve">
          <source>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; function has the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6c9caa222f474d8200d79ae5b20b408a1c8172" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure-2&quot;&gt;Figure 2&lt;/a&gt;, &lt;code&gt;b&lt;/code&gt; is added to each row of &lt;code&gt;a&lt;/code&gt;. When &lt;code&gt;b&lt;/code&gt; is longer than the rows of &lt;code&gt;a&lt;/code&gt;, as in &lt;a href=&quot;#figure-3&quot;&gt;Figure 3&lt;/a&gt;, an exception is raised because of the incompatible shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="translated">A medida que la escala se acerca al infinito,la distribución se parece más a la de un gaussiano.Algunas referencias afirman que el Wald es un Gausiano inverso con una media igual a 1,pero esto no es de ninguna manera universal.</target>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="translated">Así como el caso especial de la matriz escalar que indica que una matriz entera fue interpretada como un índice entero,lo cual es importante porque un índice de matriz entera fuerza una copia pero se ignora si se devuelve un escalar (índice entero completo).Se garantiza la validez del índice preparado,con la excepción de los valores fuera del límite y los errores de difusión para la indexación avanzada.Esto incluye que se añade una elipsis para los índices incompletos,por ejemplo,cuando se indexa una matriz bidimensional con un solo número entero.</target>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Al igual que con otros objetos contenedores en Python, se puede acceder al contenido de un &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; y modificarlo &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexando o dividiendo&lt;/a&gt; el arreglo (usando, por ejemplo, &lt;em&gt;N&lt;/em&gt; enteros) y mediante los m&amp;eacute;todos y atributos del &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52fd93066bad29b67273e079568eccef85b00fa0" translate="yes" xml:space="preserve">
          <source>As you can imagine from the introduction, there are two ways you can affect the relationship between the byte ordering of the array and the underlying memory it is looking at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2891acf8ae5fe1d5007874779732cde26b391a3" translate="yes" xml:space="preserve">
          <source>As you can see, the object can be initialized in the &lt;code&gt;__new__&lt;/code&gt; method or the &lt;code&gt;__init__&lt;/code&gt; method, or both, and in fact ndarray does not have an &lt;code&gt;__init__&lt;/code&gt; method, because all the initialization is done in the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4f7dc7b3c4a70ce9ff533c44a9b7a4a1713152" translate="yes" xml:space="preserve">
          <source>Asking for your changes to be merged with the main repo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="translated">Ensamblar un nd-array a partir de listas anidadas de bloques.</target>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="translated">Ensamblar matrices a partir de bloques.</target>
        </trans-unit>
        <trans-unit id="de78d0a7b76ee6bba1ecaedfc383918b06ba62a9" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical imprecision with floats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="translated">La afirmación fracasa por la falta de precisión numérica de los flotadores:</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="289e36002d46d5808069779b9fe9f985a8b15407" translate="yes" xml:space="preserve">
          <source>Assigning data to a Structured Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a799af040a420920800093adb9e84b1752618c3" translate="yes" xml:space="preserve">
          <source>Assigning to slices/views of &lt;code&gt;MaskedArray&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63aa663ce3fd806853c6e1d56f0f1c1896855bd" translate="yes" xml:space="preserve">
          <source>Assigning values to indexed arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5174a57fec035b53144526667e457e11d00dd3" translate="yes" xml:space="preserve">
          <source>Assignment between two structured arrays occurs as if the source elements had been converted to tuples and then assigned to the destination elements. That is, the first field of the source array is assigned to the first field of the destination array, and the second field likewise, and so on, regardless of field names. Structured arrays with a different number of fields cannot be assigned to each other. Bytes of the destination structure which are not included in any of the fields are unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acccf5c6ee3457ada97687fe5c7f1318e0893486" translate="yes" xml:space="preserve">
          <source>Assignment from Python Native Types (Tuples)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc21533901f2115eb4a3c32d19650f93349565e" translate="yes" xml:space="preserve">
          <source>Assignment from Scalars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c57993301d1b6548c0e4939d7c7c8d9a2d56b2c" translate="yes" xml:space="preserve">
          <source>Assignment from other Structured Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5e2a82565507aaae14030e1c010088c6562688" translate="yes" xml:space="preserve">
          <source>Assignment involving subarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3ede0861439daaed8c3de08958646d9211be1a" translate="yes" xml:space="preserve">
          <source>Assignment of ndarray object&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edeef440cbb6c2ba230df4bbf3e9bef68f36e23" translate="yes" xml:space="preserve">
          <source>Assignment to an array with a multi-field index modifies the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af53b1c5013c72eb7aa598ce977b69cfb859c315" translate="yes" xml:space="preserve">
          <source>Assignment to the view modifies the original array. The view&amp;rsquo;s fields will be in the order they were indexed. Note that unlike for single-field indexing, the dtype of the view has the same itemsize as the original array, and has fields at the same offsets as in the original array, and unindexed fields are merely missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed91fb02ba267588e9268d85784e62da51f799fd" translate="yes" xml:space="preserve">
          <source>Assignment vs referencing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a1879dbe4b9ce9021e415e931186b4b4a19157" translate="yes" xml:space="preserve">
          <source>Assigns values from one structured array to another by field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="translated">Suponga que &lt;code&gt;mask_func&lt;/code&gt; es una funci&amp;oacute;n que, para una matriz cuadrada a de tama&amp;ntilde;o &lt;code&gt;(n, n)&lt;/code&gt; con un posible argumento de compensaci&amp;oacute;n &lt;code&gt;k&lt;/code&gt; , cuando se llama como &lt;code&gt;mask_func(a, k)&lt;/code&gt; devuelve una nueva matriz con ceros en ciertas ubicaciones (funciones como &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; haz precisamente esto). Luego, esta funci&amp;oacute;n devuelve los &amp;iacute;ndices donde se ubicar&amp;iacute;an los valores distintos de cero.</target>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="translated">Suponga que &lt;em&gt;n&lt;/em&gt; es el n&amp;uacute;mero de elementos de la dimensi&amp;oacute;n que se est&amp;aacute; cortando. Entonces, si no se da &lt;em&gt;i&lt;/em&gt; , el valor predeterminado es 0 para &lt;em&gt;k&amp;gt; 0&lt;/em&gt; y &lt;em&gt;n - 1&lt;/em&gt; para &lt;em&gt;k &amp;lt;0&lt;/em&gt; . Si no se da &lt;em&gt;j&lt;/em&gt; , el valor predeterminado es &lt;em&gt;n&lt;/em&gt; para &lt;em&gt;k&amp;gt; 0&lt;/em&gt; y &lt;em&gt;-n-1&lt;/em&gt; para &lt;em&gt;k &amp;lt;0&lt;/em&gt; . Si no se da &lt;em&gt;k&lt;/em&gt; , el valor predeterminado es 1. Tenga en cuenta que &lt;code&gt;::&lt;/code&gt; es lo mismo que &lt;code&gt;:&lt;/code&gt; y significa seleccionar todos los &amp;iacute;ndices a lo largo de este eje.</target>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="translated">Suponga que las observaciones est&amp;aacute;n en las columnas de la matriz de observaci&amp;oacute;n &lt;code&gt;m&lt;/code&gt; y sea &lt;code&gt;f = fweights&lt;/code&gt; y &lt;code&gt;a = aweights&lt;/code&gt; para abreviar. Los pasos para calcular la covarianza ponderada son los siguientes:</target>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="translated">Supongamos que tenemos tres matrices</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="translated">Asumiendo que</target>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="translated">Suponiendo que &lt;code&gt;a&lt;/code&gt; est&amp;aacute; ordenado:</target>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="translated">Asumiendo que el archivo foo.ini.in tiene el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="3d748459a93c925f679363da9105b14fbf94ff7f" translate="yes" xml:space="preserve">
          <source>Assuming you have followed the instructions in these pages, git will create a default link to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo called &lt;code&gt;origin&lt;/code&gt;. In git &amp;gt;= 1.7 you can ensure that the link to origin is permanently set by using the &lt;code&gt;--set-upstream&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb0f65a2eba6ba7c9892f097c02bd25a54d7da6" translate="yes" xml:space="preserve">
          <source>Assuming you have your &lt;a href=&quot;development_environment#development-environment&quot;&gt;development environment&lt;/a&gt; set up, you can now build the code and test it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c95f65947e1bc255843aa11283635e0c0b35d4e" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;compile&lt;/em&gt; time, a distutils command is used to define the minimum and maximum features to support, based on user choice and compiler support. The appropriate macros are overlayed with the platform / architecture intrinsics, and the three loops are compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe13899297822b3fa2661ba300f5fe4b4634e5" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;runtime import&lt;/em&gt;, the CPU is probed for the set of supported intrinsic features. A mechanism is used to grab the pointer to the most appropriate function, and this will be the one called for the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="translated">En cada iteraci&amp;oacute;n del ciclo, los &lt;em&gt;nin&lt;/em&gt; objetos de entrada se extraen de sus matrices de objetos y se colocan en una tupla de argumentos, se llama al Python &lt;em&gt;invocable&lt;/em&gt; con los argumentos de entrada y las nout salidas se colocan en sus matrices de objetos.</target>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="translated">Al comienzo de cada &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , este m&amp;eacute;todo se llama en el objeto de entrada con la prioridad de matriz m&amp;aacute;s alta, o en el objeto de salida si se especific&amp;oacute; uno. La matriz de salida se pasa y lo que se devuelve se pasa a ufunc. Las subclases heredan una implementaci&amp;oacute;n predeterminada de este m&amp;eacute;todo que simplemente devuelve la matriz de salida sin modificar. Las subclases pueden optar por utilizar este m&amp;eacute;todo para transformar la matriz de salida en una instancia de la subclase y actualizar los metadatos antes de devolver la matriz a ufunc para su c&amp;aacute;lculo.</target>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="translated">En el centro de cada UFU se encuentra una colección de funciones específicas de cada tipo que define la funcionalidad básica de cada uno de los tipos soportados.Estas funciones deben evaluar la función subyacente</target>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="translated">En el n&amp;uacute;cleo de cada ufunc hay un bucle de strided unidimensional que implementa la funci&amp;oacute;n real para una combinaci&amp;oacute;n de tipos espec&amp;iacute;fica. Cuando se crea un ufunc, se le proporciona una lista est&amp;aacute;tica de bucles internos y una lista correspondiente de firmas de tipo sobre las que opera el ufunc. La maquinaria ufunc usa esta lista para determinar qu&amp;eacute; bucle interno usar para un caso particular. Puede inspeccionar el atributo &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt; &lt;code&gt;.types&lt;/code&gt; &lt;/a&gt; de un ufunc en particular para ver qu&amp;eacute; combinaciones de tipos tienen un bucle interno definido y qu&amp;eacute; tipo de salida producen (los &lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;c&amp;oacute;digos de caracteres&lt;/a&gt; se utilizan en dicha salida para mayor brevedad).</target>
        </trans-unit>
        <trans-unit id="a696ebe70ac5ecb64adf92ab51868a20788e2014" translate="yes" xml:space="preserve">
          <source>At the core of the NumPy package, is the &lt;code&gt;ndarray&lt;/code&gt; object. This encapsulates &lt;em&gt;n&lt;/em&gt;-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="translated">Al final de cada &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , este m&amp;eacute;todo se llama en el objeto de entrada con la prioridad de matriz m&amp;aacute;s alta, o en el objeto de salida, si se especific&amp;oacute; uno. La matriz calculada por ufunc se pasa y lo que se devuelve se pasa al usuario. Las subclases heredan una implementaci&amp;oacute;n predeterminada de este m&amp;eacute;todo, que transforma la matriz en una nueva instancia de la clase del objeto. Las subclases pueden optar por utilizar este m&amp;eacute;todo para transformar la matriz de salida en una instancia de la subclase y actualizar los metadatos antes de devolver la matriz al usuario.</target>
        </trans-unit>
        <trans-unit id="b5c2669a04a5d46f02634839c3dfc6c41bdd3f88" translate="yes" xml:space="preserve">
          <source>At the upper right of the page, click &lt;code&gt;Fork&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f27a6635e66c8275db039314e451b39ca65192" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;arr + 3&lt;/code&gt; does not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7cf21779cc632f37ca6f9f1b905fd816410c5c5" translate="yes" xml:space="preserve">
          <source>Attribute statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="translated">Atributos y propiedades de los conjuntos enmascarados</target>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="translated">Atributos que proporcionan información adicional:</target>
        </trans-unit>
        <trans-unit id="1003414a3eb685608efbc345c0f83084c22559bd" translate="yes" xml:space="preserve">
          <source>Attributes that are properties and have their own docstrings can be simply listed by name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="translated">Autor: Pearu Peterson &amp;lt; &lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt; &amp;gt; Creado: 11 de enero de 2003</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="translated">Ejemplo de Métodos de Selección de Contenedores Automatizados,usando 2 datos aleatorios de pico con 2000 puntos:</target>
        </trans-unit>
        <trans-unit id="bfb122c45c152fbdf176456bb1bd4e6bc24c337e" translate="yes" xml:space="preserve">
          <source>Automatic Byte Offsets and Alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522d7710743316a9bb70282225a360f203660682" translate="yes" xml:space="preserve">
          <source>Automatic detection of forward incompatibilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687034389bdc7cc4294c91418210f69e71c2ea75" translate="yes" xml:space="preserve">
          <source>Automatic extension module generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ebac8c965ff2e52dca0ea08eceaccc8803b780" translate="yes" xml:space="preserve">
          <source>Automatically generated reference documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="translated">Datos auxiliares con la semántica de los objetos</target>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="translated">Typemaps disponibles</target>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="translated">Las etiquetas disponibles son:</target>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="translated">Ufunciones disponibles</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="translated">Promedios y variaciones</target>
        </trans-unit>
        <trans-unit id="c283b762c8c40e64645901b30f41d8175d39891d" translate="yes" xml:space="preserve">
          <source>Avoid when possible; &lt;a href=&quot;https://docs.python.org/dev/library/pickle.html&quot;&gt;pickles&lt;/a&gt; are not secure against erroneous or maliciously constructed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a6dacf63a1600c6901329b8727cfba6197e8fd" translate="yes" xml:space="preserve">
          <source>Axes are defined for arrays with more than one dimension. A 2-dimensional array has two corresponding axes: the first running vertically downwards across rows (axis 0), and the second running horizontally across columns (axis 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="translated">Ejes en &lt;code&gt;a&lt;/code&gt; para reordenar a la derecha, antes de la inversi&amp;oacute;n. Si es Ninguno (predeterminado), no se realiza ning&amp;uacute;n reordenamiento.</target>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="translated">Ejes sobre los que se aplica la &lt;code&gt;func&lt;/code&gt; i&amp;oacute;n ; los elementos deben ser n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="translated">Hachas sobre las que calcular.Por defecto,ninguno,lo que desplaza todos los ejes.</target>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="translated">Ejes sobre los que calcular la FFT.</target>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="translated">Ejes sobre los que calcular la FFT. Si no se proporciona, se utilizan los &amp;uacute;ltimos ejes &lt;code&gt;len(s)&lt;/code&gt; , o todos los ejes si &lt;code&gt;s&lt;/code&gt; tampoco se especifica.</target>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="translated">Ejes sobre los que calcular la FFT. Si no se proporciona, se utilizan los &amp;uacute;ltimos ejes de &lt;code&gt;len(s)&lt;/code&gt; , o todos los ejes si &lt;code&gt;s&lt;/code&gt; tampoco se especifica. Los &amp;iacute;ndices repetidos en &lt;code&gt;axes&lt;/code&gt; significan que la transformaci&amp;oacute;n sobre ese eje se realiza varias veces.</target>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="translated">Ejes sobre los que calcular la FFT. Si no se da, se utilizan los dos &amp;uacute;ltimos ejes. Un &amp;iacute;ndice repetido en &lt;code&gt;axes&lt;/code&gt; significa que la transformaci&amp;oacute;n sobre ese eje se realiza varias veces. Una secuencia de un elemento significa que se realiza una FFT unidimensional.</target>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">Ejes sobre los que calcular la IFFT. Si no se proporciona, se utilizan los &amp;uacute;ltimos ejes de &lt;code&gt;len(s)&lt;/code&gt; , o todos los ejes si &lt;code&gt;s&lt;/code&gt; tampoco se especifica. Los &amp;iacute;ndices repetidos en los &lt;code&gt;axes&lt;/code&gt; significan que la transformaci&amp;oacute;n inversa sobre ese eje se realiza varias veces.</target>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">Ejes sobre los que calcular la FFT inversa. Si no se proporciona, se utilizan los &amp;uacute;ltimos ejes de &lt;code&gt;len(s)&lt;/code&gt; , o todos los ejes si &lt;code&gt;s&lt;/code&gt; tampoco se especifica. Los &amp;iacute;ndices repetidos en los &lt;code&gt;axes&lt;/code&gt; significan que la transformaci&amp;oacute;n inversa sobre ese eje se realiza varias veces.</target>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="translated">Hachas sobre las que cambiar.Por defecto es Ninguno,lo que desplaza todos los ejes.</target>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Ejes que se utilizar&amp;aacute;n como primer y segundo eje de las submatrices 2-D de las que se deben tomar las diagonales. Los valores predeterminados son los dos primeros ejes de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="translated">Eje a lo largo del cual se corta &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="translated">Eje a lo largo del cual se realiza el quirófano lógico</target>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="translated">Eje a lo largo del cual se calcula el producto acumulado.Por defecto,la entrada se aplana.</target>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="translated">Eje a lo largo del cual se calcula la suma acumulada.El valor por defecto (Ninguno)es calcular la suma acumulada sobre la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="translated">Eje a lo largo del cual se cuentan los elementos.Por defecto,da el número total de elementos.</target>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="translated">Eje a lo largo del cual se calculan las medianas.El valor por defecto (Ninguno)es calcular la mediana a lo largo de una versión aplanada de la matriz.</target>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="translated">Eje a lo largo del cual debe realizarse la operación.</target>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="translated">Eje a lo largo del cual promediar &lt;code&gt;a&lt;/code&gt; . Si es &lt;code&gt;None&lt;/code&gt; , el promedio se realiza sobre la matriz plana.</target>
        </trans-unit>
        <trans-unit id="17667e8c77ab258d88774c70f62a92c1b9869875" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If None, averaging is done over the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="translated">Eje a lo largo del cual contar.Si no hay ninguno (por defecto),se utiliza una versión aplanada de la matriz.</target>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Eje por el que encontrar los picos. De forma predeterminada, aplana la matriz. &lt;code&gt;axis&lt;/code&gt; puede ser negativo, en cuyo caso cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="translated">Eje a lo largo del cual se encuentran los picos.Si no hay ninguno (por defecto)se utiliza la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="translated">Eje a lo largo del cual insertar &lt;code&gt;values&lt;/code&gt; . Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, primero se aplana &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="translated">Eje a lo largo del cual operar.Por defecto se utiliza la entrada aplanada.</target>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="translated">Eje sobre el que operar. De forma predeterminada, el &lt;code&gt;axis&lt;/code&gt; es Ninguno y se utiliza la entrada plana.</target>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="translated">Eje a lo largo del cual realizar la operación.Por defecto es Ninguno.</target>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Eje a lo largo del cual realizar la operaci&amp;oacute;n. Si es Ninguno (predeterminado), se aplica a una versi&amp;oacute;n plana de la matriz, y es lo mismo que &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt; &lt;code&gt;flatnotmasked_contiguous&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="translated">Eje a lo largo del cual realizar la operación.Si no hay ninguno (por defecto),se aplica a una versión aplanada del array.</target>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="translated">Eje a lo largo del cual realizar la operación.Si no hay ninguno,se aplica a una versión aplanada de la matriz.</target>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="translated">Eje a lo largo del cual clasificar.El valor por defecto es -1,lo que significa ordenar a lo largo del último eje.</target>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="translated">Eje a lo largo del cual clasificar.Si no hay ninguno,la matriz se aplana antes de clasificar.El valor por defecto es -1,que ordena a lo largo del último eje.</target>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="translated">Eje a lo largo del cual clasificar.Si no hay ninguno,por defecto,se utiliza la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="translated">Eje a lo largo del cual clasificar.El valor por defecto es -1 (el último eje).Si no hay ninguno,se utiliza la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="translated">Eje a lo largo del cual tomar rebanadas.Si no hay ninguno (por defecto),trabaje en la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="translated">Eje a lo largo del cual operará el desenvolvimiento,por defecto es el último eje.</target>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">Eje de &lt;code&gt;a&lt;/code&gt; que define el (los) vector (s). Por defecto, el &amp;uacute;ltimo eje.</target>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">Eje de &lt;code&gt;b&lt;/code&gt; que define el (los) vector (s). Por defecto, el &amp;uacute;ltimo eje.</target>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="translated">Eje de &lt;code&gt;c&lt;/code&gt; que contiene el vector o los vectores de productos cruzados. Se ignora si ambos vectores de entrada tienen dimensi&amp;oacute;n 2, ya que el retorno es escalar. Por defecto, el &amp;uacute;ltimo eje.</target>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes a lo largo del cual se realiza una reducci&amp;oacute;n AND l&amp;oacute;gica. El valor predeterminado ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) es realizar un Y l&amp;oacute;gico sobre todas las dimensiones de la matriz de entrada. &lt;code&gt;axis&lt;/code&gt; puede ser negativo, en cuyo caso cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="10ee68577b50399a741722b3f075be540558e59c" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes sobre los que se realiza una reducci&amp;oacute;n l&amp;oacute;gica OR. El valor predeterminado ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) es realizar un O l&amp;oacute;gico en todas las dimensiones de la matriz de entrada. &lt;code&gt;axis&lt;/code&gt; puede ser negativo, en cuyo caso cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="4b3cd50c25bcf6114d5dbf62c339109576c970bf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se realiza un producto.El valor por defecto,axis=None,calculará el producto de todos los elementos de la matriz de entrada.Si el eje es negativo,cuenta desde el último hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes sobre los que se realiza una reducci&amp;oacute;n. El valor predeterminado ( &lt;code&gt;axis&lt;/code&gt; = 0) es realizar una reducci&amp;oacute;n sobre la primera dimensi&amp;oacute;n de la matriz de entrada. &lt;code&gt;axis&lt;/code&gt; puede ser negativo, en cuyo caso cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se realiza una suma.El valor por defecto,axis=None,sumará todos los elementos de la matriz de entrada.Si el eje es negativo,cuenta desde el último hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se desplazan los elementos.Por defecto,la matriz se aplana antes del desplazamiento,después de lo cual se restaura la forma original.</target>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes a lo largo del cual se realiza el conteo. El valor predeterminado ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) realiza el recuento de todas las dimensiones de la matriz de entrada. &lt;code&gt;axis&lt;/code&gt; puede ser negativo, en cuyo caso cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="dbd8b445b81cd5436ce710f441b84e722e566a56" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula el máximo.El valor por defecto es calcular el máximo de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calculan los medios.El valor por defecto es calcular la media de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calculan las medianas.El valor por defecto es calcular la mediana a lo largo de una versión aplanada de la matriz.Se admite una secuencia de ejes desde la versión 1.9.0.</target>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula el mínimo.El valor por defecto es calcular el mínimo de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calculan los percentiles.El valor por defecto es calcular el(los)percentil(es)a lo largo de una versión aplanada de la matriz.</target>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula el producto.El valor por defecto es calcular el producto de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calculan los cuantiles.El valor por defecto es calcular el (los)cuantiles a lo largo de una versión aplanada de la matriz.</target>
        </trans-unit>
        <trans-unit id="c32c668e0dd59a8b292f11f9182ecb083fc9a19d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sliding window is applied. By default, the sliding window is applied to all axes and &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to axis &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is given as a &lt;code&gt;tuple of int&lt;/code&gt;, &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to the axis &lt;code&gt;axis[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. Single integers &lt;code&gt;i&lt;/code&gt; are treated as if they were the tuple &lt;code&gt;(i,)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula la desviación estándar.El valor por defecto es calcular la desviación estándar del conjunto aplanado.</target>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula la suma.El valor por defecto es calcular la suma de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales se calcula la variación.El valor por defecto es calcular la varianza de la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Eje o ejes sobre los que promediar &lt;code&gt;a&lt;/code&gt; . El valor predeterminado, eje = Ninguno, promediar&amp;aacute; todos los elementos de la matriz de entrada. Si el eje es negativo, cuenta desde el &amp;uacute;ltimo hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Eje o hachas a lo largo de las cuales dar la vuelta.El valor por defecto,axis=None,volteará todos los ejes de la matriz de entrada.Si el eje es negativo,cuenta desde el último hasta el primer eje.</target>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="translated">Eje o ejes a lo largo de los cuales operar.Por defecto,se utiliza la entrada aplanada.</target>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Eje o tupla de ejes a lo largo de los cuales contar los no ceros. El valor predeterminado es Ninguno, lo que significa que los no ceros se contar&amp;aacute;n a lo largo de una versi&amp;oacute;n aplanada de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="translated">Eje sobre el que se toman las anomalías.El valor por defecto es usar la media de la matriz aplanada como referencia.</target>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="translated">Eje sobre el que se toma el derivado.(Por defecto:0).</target>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="translated">Eje sobre el que se toma la integral.(Por defecto:0).</target>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="translated">Eje sobre el que se calcula la FFT.Si no se da,se utiliza el último eje.</target>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="translated">Eje sobre el que calcular el DFT inverso.Si no se da,se utiliza el último eje.</target>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="translated">Eje sobre el que calcular la FFT inversa.Si no se da,se utiliza el último eje.</target>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="translated">El eje se clasificará indirectamente.Por defecto,ordenar sobre el último eje.</target>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="translated">Eje que se utilizará como el primer eje de los subconjuntos 2D de los que se deben tomar las diagonales.Por defecto el primer eje (0).</target>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="translated">Eje que se utilizará como el segundo eje de los subconjuntos 2D de los que se tomarán las diagonales.Por defecto,el segundo eje (1).</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="translated">COMPORTADO y C_CONTIGUO.</target>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">PORTADA y F_CONTIGUOUS y no C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="c7243d04c977df0309eee7b50ccaddc2665154ee" translate="yes" xml:space="preserve">
          <source>BLAS</source>
          <target state="translated">BLAS</target>
        </trans-unit>
        <trans-unit id="bcd158bb5feaae9038808e3b55d2a031b8ba7709" translate="yes" xml:space="preserve">
          <source>BLAS (NetLIB)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf8c920edb3ad9eb9b92f8b67ba19eaaa1b8c86" translate="yes" xml:space="preserve">
          <source>BLIS</source>
          <target state="translated">BLIS</target>
        </trans-unit>
        <trans-unit id="cf867b1a06ac32f25a3a53b5cac69625adf84e3c" translate="yes" xml:space="preserve">
          <source>BLIS support in &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214e501b88ef4fd6dfd2e0ceb3d07f872f3aa657" translate="yes" xml:space="preserve">
          <source>BSD / Solaris</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">Información de fondo</target>
        </trans-unit>
        <trans-unit id="090a12d667902964e48f38714b38e1c7c7410ac2" translate="yes" xml:space="preserve">
          <source>Backport Pull Requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304c9bb8acb18cf698a66eac9714c36a88110784" translate="yes" xml:space="preserve">
          <source>Backporting</source>
          <target state="translated">Backporting</target>
        </trans-unit>
        <trans-unit id="850de91aa7213a4adf4d94aeab2caaf4d100f909" translate="yes" xml:space="preserve">
          <source>Backporting is the process of copying new feature/fixes committed in &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy/master&lt;/a&gt; back to stable release branches. To do this you make a branch off the branch you are backporting to, cherry pick the commits you want from &lt;code&gt;numpy/master&lt;/code&gt;, and then submit a pull request for the branch containing the backport.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9bfe183c1510e40aa465bc59796172c1a8f60e" translate="yes" xml:space="preserve">
          <source>Bad or missing data can be cleanly ignored by putting it in a masked array, which has an internal boolean array indicating invalid entries. Operations with masked arrays ignore these entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172132c5b69b62eb861ca29a9ea486edc3f7219f" translate="yes" xml:space="preserve">
          <source>Bare metal, wrap your own C-code manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="translated">Clase base para generadores de bits genéricos,que proporcionan un flujo de bits aleatorios basados en diferentes algoritmos.</target>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="translated">Clase base para generadores de bits genéricos,que proporcionan un flujo de bits aleatorios basados en diferentes algoritmos.Debe ser anulado.</target>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="translated">Clase base</target>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="translated">Clase base para todos los tipos de polinomios.</target>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="translated">Clase base para los errores en este módulo.</target>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="translated">Clase base para tipos de escalares numéricos.</target>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="translated">Objeto base si la memoria es de algún otro objeto.</target>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="translated">Base del logaritmo natural (</target>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Logaritmo en base 2 de &lt;code&gt;2**x1 + 2**x2&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Logaritmo en base 2 de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Logaritmo en base 2 de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="translated">Representaciones de la base N</target>
        </trans-unit>
        <trans-unit id="0bff1548231bd093df6d8bc4bf7a28a9733d2f0e" translate="yes" xml:space="preserve">
          <source>Based on the above characterization, &amp;ldquo;high-priority&amp;rdquo; changes (i.e. fixing technical inaccuracies, broken links, etc.) can be proposed via pull requests directly as they are straightforward to review. Other changes should be raised as issues first so that the discussion can happen before you make major modifications, which in principle saves you from wasting your time on undesired changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="translated">&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; b&amp;aacute;sico : ~ 1520ms (comparado con Intel i5 de 3,1 GHz).</target>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="translated">Banderas de la matriz básica</target>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="translated">Fechas básicas</target>
        </trans-unit>
        <trans-unit id="6081b68b227981c90bce83d2c2beb9f59d79503d" translate="yes" xml:space="preserve">
          <source>Basic Git setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a031fb4b54459f27072c9ee40c4b13ebd94a781" translate="yes" xml:space="preserve">
          <source>Basic Installation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5074656d77a5a1b87923975067a88a41f1ac1c1" translate="yes" xml:space="preserve">
          <source>Basic Iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a6dc8bc52fe0e5017a1d4e4df961ab713b5b3a" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7231dfbf12224ef4a3543250815ccb954fcb938" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra Subprograms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a85f6e8c6ded273cdb7e38718d85979a45dd77e" translate="yes" xml:space="preserve">
          <source>Basic Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="translated">Rebanado básico e indexación</target>
        </trans-unit>
        <trans-unit id="60094894bbbb579bd2f4b96162f9928ec2ce169d" translate="yes" xml:space="preserve">
          <source>Basic Statistics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b6d01ce3d08fc15e9971b8d7ad62d621a90733" translate="yes" xml:space="preserve">
          <source>Basic array operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="translated">Personalización básica:</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">Ejemplos básicos</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">Operaciones básicas</target>
        </trans-unit>
        <trans-unit id="d6e8bb93c76a2ef8f7afd4a4fc3b007cbfd7ef2c" translate="yes" xml:space="preserve">
          <source>Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you&amp;rsquo;d use &lt;code&gt;sum()&lt;/code&gt;. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8920f677fe61e2e2076f058e28c7701ee809c1" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">La divisi&amp;oacute;n b&amp;aacute;sica extiende el concepto b&amp;aacute;sico de Python de divisi&amp;oacute;n a N dimensiones. El corte b&amp;aacute;sico ocurre cuando &lt;em&gt;obj&lt;/em&gt; es un objeto de &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; (construido por notaci&amp;oacute;n &lt;code&gt;start:stop:step&lt;/code&gt; dentro de par&amp;eacute;ntesis), un n&amp;uacute;mero entero o una tupla de objetos de corte y enteros. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; objetos de &lt;code&gt;Ellipsis&lt;/code&gt; y newaxis tambi&amp;eacute;n se pueden intercalar con estos.</target>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="translated">Rebanar b&amp;aacute;sica con m&amp;aacute;s de una no- &lt;code&gt;:&lt;/code&gt; entrada en el tupla corte en lonchas, act&amp;uacute;a como la aplicaci&amp;oacute;n repetida de corte en rodajas usando un solo no &lt;code&gt;:&lt;/code&gt; entrada, donde los no &lt;code&gt;:&lt;/code&gt; se toman sucesivamente entradas (con todos los otros no &lt;code&gt;:&lt;/code&gt; entradas sustituidos por &lt;code&gt;:&lt;/code&gt; ) . Por lo tanto, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; act&amp;uacute;a como &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; en el corte b&amp;aacute;sico.</target>
        </trans-unit>
        <trans-unit id="de17dd65e3190938ee92ddb98549d2245920a8ee" translate="yes" xml:space="preserve">
          <source>Basic usage is to call &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt;&lt;code&gt;PyArray_IterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; which contains the total size of the array, &lt;code&gt;iter-&amp;gt;index&lt;/code&gt;, which contains the current 1-d index into the array, and &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; which is a pointer to the data for the current element of the array. Sometimes it is also useful to access &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; which is a pointer to the underlying ndarray object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="translated">Uso b&amp;aacute;sico. Observe c&amp;oacute;mo y es la versi&amp;oacute;n &quot;aplanada&quot; de [a [:, 0,:], a [:, 1, 0], a [:, 2,:]] ya que especificamos los ejes del primer iter como [1]</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4ce3c1a6b26e31f8d07ec92f4cb05d49b3eec33d" translate="yes" xml:space="preserve">
          <source>Be aware that when NumPy prints N-dimensional arrays, the last axis is looped over the fastest while the first axis is the slowest. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="translated">¡Ten cuidado con el error de redondeo!</target>
        </trans-unit>
        <trans-unit id="3008b1888d55827508c13f2c0985bc725a03a91e" translate="yes" xml:space="preserve">
          <source>Be careful in the words that we choose. We are careful and respectful in our communication and we take responsibility for our own speech. Be kind to others. Do not insult or put down other participants. We will not accept harassment or other exclusionary behaviour, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95dfdc69ac7b8c496606d6afad271cdcc3a6cdb" translate="yes" xml:space="preserve">
          <source>Be collaborative. Our work will be used by other people, and in turn we will depend on the work of others. When we make something for the benefit of the project, we are willing to explain to others how it works, so that they can build on the work to make it even better. Any decision we make will affect users and colleagues, and we take those consequences seriously when making decisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff801bed133a99446534aede438fa2583bcd9e5a" translate="yes" xml:space="preserve">
          <source>Be empathetic, welcoming, friendly, and patient. We work together to resolve conflict, and assume good intentions. We may all experience some frustration from time to time, but we do not allow frustration to turn into a personal attack. A community where people feel uncomfortable or threatened is not a productive one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eaab4694464d982dfc3e0a1afc07f0c4449c8cc" translate="yes" xml:space="preserve">
          <source>Be inquisitive. Nobody knows everything! Asking questions early avoids many problems later, so we encourage questions, although we may direct them to the appropriate forum. We will try hard to be responsive and helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a20b0ffbe846eba275eb3ea56da6251c7cd9752" translate="yes" xml:space="preserve">
          <source>Be mindful of the needs of new members: provide them with explicit support and consideration, with the aim of increasing participation from underrepresented groups in particular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f37a97353eabf9fd15a91dbc5d9f5eb04cea0bf" translate="yes" xml:space="preserve">
          <source>Be mindful that large arrays created with &lt;code&gt;np.empty&lt;/code&gt; or &lt;code&gt;np.zeros&lt;/code&gt; might not be allocated in physical memory until the memory is accessed. If this is desired behaviour, make sure to comment it in your setup function. If you are benchmarking an algorithm, it is unlikely that a user will be executing said algorithm on a newly created empty/zero array. One can force pagefaults to occur in the setup phase either by calling &lt;code&gt;np.ones&lt;/code&gt; or &lt;code&gt;arr.fill(value)&lt;/code&gt; after creating the array,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3730bbeeef610bbf04c76abf5ec330327e101406" translate="yes" xml:space="preserve">
          <source>Be open. We invite anyone to participate in our community. We prefer to use public methods of communication for project-related messages, unless discussing something sensitive. This applies to messages for help or project-related support, too; not only is a public support request much more likely to result in an answer to a question, it also ensures that any inadvertent mistakes in answering are more easily detected and corrected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="translated">Asegúrese de comprender los pasos que debe seguir para gestionar la memoria cuando utilice estas funciones de conversión.Estas funciones pueden requerir la liberación de la memoria,y/o la alteración de los recuentos de referencia de objetos específicos basados en su uso.</target>
        </trans-unit>
        <trans-unit id="6e72bb7e156cb39574b057b9674c2412ed422481" translate="yes" xml:space="preserve">
          <source>Be warned that even if &lt;code&gt;np.longdouble&lt;/code&gt; offers more precision than python &lt;code&gt;float&lt;/code&gt;, it is easy to lose that extra precision, since python often forces values to pass through &lt;code&gt;float&lt;/code&gt;. For example, the &lt;code&gt;%&lt;/code&gt; formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="translated">Debido a que &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; es un tipo incorporado (escrito en C), los m&amp;eacute;todos especiales &lt;code&gt;__r{op}__&lt;/code&gt; no se definen directamente.</target>
        </trans-unit>
        <trans-unit id="d79cf7f45add11b370a63146a7703acf9ea33ca1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__array_finalize__&lt;/code&gt; is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc46c55e2dfa187c2ac071bbb4bae1702d622519" translate="yes" xml:space="preserve">
          <source>Because Python strings are immutable, an &lt;code&gt;intent(inout)&lt;/code&gt; argument expects an array version of a string in order to have &lt;em&gt;in situ&lt;/em&gt; changes be effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ea4687fdb37cf012f30310b86e8fc32c6c91ad" translate="yes" xml:space="preserve">
          <source>Because access to additional information is so useful, IPython uses the &lt;code&gt;?&lt;/code&gt; character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. &lt;a href=&quot;https://ipython.org/&quot;&gt;You can find more information about IPython here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="translated">Dado que la detección de superposición exacta tiene un tiempo de ejecución exponencial en el número de dimensiones,la decisión se toma sobre la base de la heurística,que tiene falsos positivos (copias innecesarias en casos inusuales)pero no tiene falsos negativos.</target>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="translated">Debido a c&amp;oacute;mo la &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; maneja los conjuntos, lo siguiente no funciona como se esperaba:</target>
        </trans-unit>
        <trans-unit id="4a390a00169642b8c370c2fa0fa4fb8d3ba973c7" translate="yes" xml:space="preserve">
          <source>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a5855103a7e35a06feda100f69f0d3c37a35c5" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions &lt;a href=&quot;#c.PyArray_GetNDArrayCVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCVersion&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_GetNDArrayCFeatureVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCFeatureVersion&lt;/code&gt;&lt;/a&gt; corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">Debido a que las extensiones de Python no se usan de la misma manera que las bibliotecas habituales en la mayor&amp;iacute;a de las plataformas, algunos errores no se pueden detectar autom&amp;aacute;ticamente en el momento de la compilaci&amp;oacute;n o incluso en el tiempo de ejecuci&amp;oacute;n. Por ejemplo, si crea una extensi&amp;oacute;n usando una funci&amp;oacute;n disponible solo para numpy&amp;gt; = 1.3.0, e importa la extensi&amp;oacute;n m&amp;aacute;s tarde con numpy 1.2, no obtendr&amp;aacute; un error de importaci&amp;oacute;n (pero es casi seguro que un error de segmentaci&amp;oacute;n al llamar a la funci&amp;oacute;n) . Es por eso que se proporcionan varias funciones para verificar versiones numerosas. Las macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponden a la versi&amp;oacute;n numpy utilizada para construir la extensi&amp;oacute;n, mientras que las versiones devueltas por las funciones PyArray_GetNDArrayCVersion y PyArray_GetNDArrayCFeatureVersion corresponden a la versi&amp;oacute;n numpy en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="00d51d08a981e99f75ad16b5ac99f6d7fcbcfe04" translate="yes" xml:space="preserve">
          <source>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="translated">Debido a que la transformada discreta de Fourier separa su entrada en componentes que contribuyen a frecuencias discretas, tiene una gran cantidad de aplicaciones en el procesamiento de se&amp;ntilde;ales digitales, por ejemplo, para el filtrado, y en este contexto, la entrada discretizada a la transformada se conoce habitualmente como &lt;em&gt;se&amp;ntilde;al.&lt;/em&gt; , que existe en el &lt;em&gt;dominio del tiempo&lt;/em&gt; . La salida se llama &lt;em&gt;espectro&lt;/em&gt; o &lt;em&gt;transformada&lt;/em&gt; y existe en el &lt;em&gt;dominio de&lt;/em&gt; la &lt;em&gt;frecuencia&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="translated">Debido a que la salida est&amp;aacute; limitada al rango del tipo C int64, se genera un ValueError cuando &lt;code&gt;lam&lt;/code&gt; est&amp;aacute; dentro de 10 sigma del valor m&amp;aacute;ximo representable.</target>
        </trans-unit>
        <trans-unit id="fac8d49cb6d5e3c4d76e0475c48ac86177c281c5" translate="yes" xml:space="preserve">
          <source>Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9411fa9bcced44864e82d01d766c1a2786cafda" translate="yes" xml:space="preserve">
          <source>Because you shouldn&amp;rsquo;t have done that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66686e9fe82b8c4d1e36e68b32d366de35a5f9f" translate="yes" xml:space="preserve">
          <source>Before beginning, ensure that &lt;em&gt;airspeed velocity&lt;/em&gt; is installed. By default, &lt;code&gt;asv&lt;/code&gt; ships with support for anaconda and virtualenv:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4352ccd0a83ad23754cd59af6872e1e5131c575" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8362b68d70c7caa9ac18442122ac15a5a21eab" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial, you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701eda483d7c3d519624fb81a0315cb15ec0008" translate="yes" xml:space="preserve">
          <source>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Extending and Embedding the Python Interpreter&lt;/a&gt; and in &lt;a href=&quot;c-info.how-to-extend&quot;&gt;How to extend NumPy&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32836ad1d5d4d4bb58df8da3afbc677909c61049" translate="yes" xml:space="preserve">
          <source>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6843f140ae464de1cf1062218ac15fdc241e46ba" translate="yes" xml:space="preserve">
          <source>Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the information needed for the loop. The return value of this function is &lt;code&gt;0&lt;/code&gt; if the process was successful and &lt;code&gt;-1&lt;/code&gt; with an error condition set if it was not successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be89e8229b2d83a60fa787b8ef67a25d3d7f1699" translate="yes" xml:space="preserve">
          <source>Begin if possible with the large issues, so the author knows they&amp;rsquo;ve been understood. Resist the temptation to immediately go line by line, or to open with small pervasive issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="translated">Comportamiento cuando la matriz de covarianza no es semidefinida positiva.</target>
        </trans-unit>
        <trans-unit id="16b46349029a1f8fc5f5c2e429e2632fc7c9ed5c" translate="yes" xml:space="preserve">
          <source>Behaviors and Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b4ea80568cb9ce63d7c954c6894e4b50f0041f" translate="yes" xml:space="preserve">
          <source>Below I&amp;rsquo;ll describe three typical approaches of using F2PY. The following example Fortran 77 code will be used for illustration, save it as fib1.f:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="translated">A continuaci&amp;oacute;n se muestran los atributos p&amp;uacute;blicos de este objeto que se documentaron en la &quot;Gu&amp;iacute;a de NumPy&quot; (hemos omitido los atributos p&amp;uacute;blicos indocumentados, as&amp;iacute; como los atributos privados documentados):</target>
        </trans-unit>
        <trans-unit id="4b6fe750132d00281d0a5b32dae239702c2e48c2" translate="yes" xml:space="preserve">
          <source>Below is a typical usage example: &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt; is herein used for annotating a function that takes a float and integer of arbitrary precision as arguments and returns a new float of whichever precision is largest (&lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;np.float16 + np.int64 -&amp;gt; np.float64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un ejemplo de un archivo &lt;code&gt;setup.py&lt;/code&gt; m&amp;iacute;nimo para un paquete SciPy puro:</target>
        </trans-unit>
        <trans-unit id="525759fddd68e1f874367bb6bfc9a8ba5f573531" translate="yes" xml:space="preserve">
          <source>Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt; adds a one-dimensional array to a two-dimensional array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="817dcc8fca981b9f81e80ededa53ee4f0c2fe004" translate="yes" xml:space="preserve">
          <source>Benchmarking NumPy with Airspeed Velocity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a532923696aa5c8f039ac98c01ebbdc352eb0162" translate="yes" xml:space="preserve">
          <source>Benchmarks are like tests, but have names starting with &amp;ldquo;bench&amp;rdquo; instead of &amp;ldquo;test&amp;rdquo;, and can be found under the &amp;ldquo;benchmarks&amp;rdquo; sub-directory of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">Los ensayos de Bernoulli son experimentos con uno de dos resultados: &amp;eacute;xito o fracaso (un ejemplo de tal experimento es lanzar una moneda). La distribuci&amp;oacute;n geom&amp;eacute;trica modela el n&amp;uacute;mero de pruebas que se deben ejecutar para lograr el &amp;eacute;xito. Por ello, se apoya en los enteros positivos, &lt;code&gt;k = 1, 2, ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fb2a7b505b1b75b34095ee2ffe16a241dd5bdfa" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;sys.stdout&lt;/code&gt;, a file-like object can also be used as it has both required methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5ba1e315701c442ad54ed60833fcd6227c3ccc" translate="yes" xml:space="preserve">
          <source>Besides creating an array from a sequence of elements, you can easily create an array filled with &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb46c86681950d0f6eb887f4a6fb11b462f9f2e" translate="yes" xml:space="preserve">
          <source>Besides its obvious scientific uses, &lt;em&gt;NumPy&lt;/em&gt; can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined. This allows &lt;em&gt;NumPy&lt;/em&gt; to seamlessly and speedily integrate with a wide variety of databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">Adem&amp;aacute;s de la informaci&amp;oacute;n estructural contenida en los miembros de pasos y dimensiones de &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; , las banderas contienen informaci&amp;oacute;n importante sobre c&amp;oacute;mo se puede acceder a los datos. En particular, la bandera &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; se activa cuando la memoria est&amp;aacute; en un l&amp;iacute;mite adecuado seg&amp;uacute;n la matriz de tipo de datos. Incluso si tiene una porci&amp;oacute;n contigua de memoria, no puede simplemente asumir que es seguro desreferenciar un puntero espec&amp;iacute;fico del tipo de datos a un elemento. Solo si se establece el indicador &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , esta operaci&amp;oacute;n es segura (en algunas plataformas funcionar&amp;aacute;, pero en otras, como Solaris, causar&amp;aacute; un error de bus). El &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;Tambi&amp;eacute;n debe asegurarse si planea escribir en el &amp;aacute;rea de memoria de la matriz. Tambi&amp;eacute;n es posible obtener un puntero a un &amp;aacute;rea de memoria que no se puede escribir. A veces, escribir en el &amp;aacute;rea de memoria cuando el indicador &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; no est&amp;aacute; configurado ser&amp;aacute; simplemente de mala educaci&amp;oacute;n. Otras veces puede provocar fallos en el programa ( &lt;em&gt;por ejemplo,&lt;/em&gt; un &amp;aacute;rea de datos que es un archivo mapeado en memoria de s&amp;oacute;lo lectura).</target>
        </trans-unit>
        <trans-unit id="7552a827553f203cc1e2b5ca99b7201f49328d40" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ba37be85f86a4053d7f866745343aa6628b3b0" translate="yes" xml:space="preserve">
          <source>Besides using &lt;code&gt;runtests.py&lt;/code&gt;, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf0953ee914f2edfe24d253c99b5774c0b042b9" translate="yes" xml:space="preserve">
          <source>Best choice for unitary and other non-Hermitian normal matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">La mejor pr&amp;aacute;ctica para lograr flujos de bits reproducibles es usar el valor predeterminado &lt;code&gt;None&lt;/code&gt; para la entrop&amp;iacute;a inicial, y luego usar &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt; para registrar / seleccionar la &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt; para la reproducibilidad:</target>
        </trans-unit>
        <trans-unit id="7670ec2417d2f252a955be33c6c1b4f20bd90718" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="translated">Beta, positivo (&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="translated">Beta: '1.8.0b1', '1.8.0b2', etc.</target>
        </trans-unit>
        <trans-unit id="e5c69acc70fda034169d23116e19f5548d61c870" translate="yes" xml:space="preserve">
          <source>Better &lt;code&gt;repr&lt;/code&gt; of object arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ff91962e9990f86b3c3c6f7d7e56caab72ace4" translate="yes" xml:space="preserve">
          <source>Better behaviour of ufunc identities during reductions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b6f98e6b21c5c6afa9104a0769b9205288f70" translate="yes" xml:space="preserve">
          <source>Better default repr for &lt;code&gt;ndarray&lt;/code&gt; subclasses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c34cb1b69a33b2d347cbab7a352fe546099b5b5" translate="yes" xml:space="preserve">
          <source>Better numerical stability for sum in some cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c0df1717608a8779754648098f8f6a8b834b75" translate="yes" xml:space="preserve">
          <source>Better support for &lt;code&gt;const&lt;/code&gt; dimensions in API functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf8b70bc38b460cf450f48cba644f58d2901785" translate="yes" xml:space="preserve">
          <source>Better support for empty structured and string types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741240e1ef7d29df48749ede4195530d21b5583c" translate="yes" xml:space="preserve">
          <source>Beyond changes to a functions docstring and possible description in the general documentation, if your change introduces any user-facing modifications they may need to be mentioned in the release notes. To add your change to the release notes, you need to create a short file with a summary and place it in &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt;. The file &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; details the format and filename conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7c1c795d86187e8f7208b51b9e4bbd86fa144c" translate="yes" xml:space="preserve">
          <source>Beyond the Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="translated">Más allá de los mapas tipo proporcionados</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="translated">Descripción del formato binario</target>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="translated">Operaciones binarias</target>
        </trans-unit>
        <trans-unit id="e2606828726dd092395e99ae84af2fb16d4bba99" translate="yes" xml:space="preserve">
          <source>Binary operations with non-arrays as second argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">Representaci&amp;oacute;n binaria de &lt;code&gt;num&lt;/code&gt; o complemento a dos de &lt;code&gt;num&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">La búsqueda binaria se utiliza para encontrar los puntos de inserción necesarios.</target>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="translated">Serialización binaria</target>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="translated">Generadores de bits</target>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="translated">Campo de bits (el siguiente número entero da el número de bits en el campo de bits).</target>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="translated">Un poco de empaquetamiento</target>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="translated">Banderas de bits que describen cómo debe interpretarse este tipo de datos.</target>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="translated">Las m&amp;aacute;scaras de bits est&amp;aacute;n en &lt;code&gt;numpy.core.multiarray&lt;/code&gt; como las constantes &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt; , &lt;code&gt;LIST_PICKLE&lt;/code&gt; , &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt; , &lt;code&gt;NEEDS_INIT&lt;/code&gt; , &lt;code&gt;NEEDS_PYAPI&lt;/code&gt; , &lt;code&gt;USE_GETITEM&lt;/code&gt; , &lt;code&gt;USE_SETITEM&lt;/code&gt; . Una explicaci&amp;oacute;n completa de estos indicadores se encuentra en la documentaci&amp;oacute;n de C-API; son muy &amp;uacute;tiles para los tipos de datos definidos por el usuario.</target>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="translated">Funciones de giro de bits</target>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="translated">Nombres de ancho de bits</target>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="translated">Referencias de ancho de bits a los tipos enumerados</target>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="e1d49785c1daa86c89ab6e63f74767502d9e2cd5" translate="yes" xml:space="preserve">
          <source>BitGenerator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="translated">BitGenerator para Small Fast Chaotic PRNG de Chris Doty-Humphrey.</target>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="translated">BitGenerator para el generador de números pseudo-aleatorios PCG-64.</target>
        </trans-unit>
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">BitGenerator para usar como el generador de núcleo.</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">BitGenerators:Objetos que generan números aleatorios.Son típicamente palabras enteras sin signo,llenas de secuencias de 32 o 64 bits aleatorios.</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">Los bits se desplazan hacia la izquierda a&amp;ntilde;adiendo &lt;code&gt;x2&lt;/code&gt; 0 a la derecha de &lt;code&gt;x1&lt;/code&gt; . Dado que la representaci&amp;oacute;n interna de los n&amp;uacute;meros est&amp;aacute; en formato binario, esta operaci&amp;oacute;n equivale a multiplicar &lt;code&gt;x1&lt;/code&gt; por &lt;code&gt;2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">Los bits se desplazan a la derecha &lt;code&gt;x2&lt;/code&gt; . Debido a que la representaci&amp;oacute;n interna de los n&amp;uacute;meros est&amp;aacute; en formato binario, esta operaci&amp;oacute;n equivale a dividir &lt;code&gt;x1&lt;/code&gt; por &lt;code&gt;2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb86c6c99db380b9a785bd4e060a6f5dc41e87fd" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Bits establecidos para el tipo de datos del objeto: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Blackman,R.B.y Tukey,J.W.,(1958)The measurement of power spectra,Dover Publications,Nueva York.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">Los bloques pueden ser de cualquier dimensi&amp;oacute;n, pero no se emitir&amp;aacute;n con las reglas normales. En su lugar, se insertan ejes principales de tama&amp;ntilde;o 1, para hacer que &lt;code&gt;block.ndim&lt;/code&gt; sea el mismo para todos los bloques. Esto es principalmente &amp;uacute;til para trabajar con escalares y significa que un c&amp;oacute;digo como &lt;code&gt;np.block([v, 1])&lt;/code&gt; es v&amp;aacute;lido, donde &lt;code&gt;v.ndim == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">Los bloques en las listas m&amp;aacute;s internas se concatenan (ver &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; ) a lo largo de la &amp;uacute;ltima dimensi&amp;oacute;n (-1), luego se concatenan a lo largo de la pen&amp;uacute;ltima dimensi&amp;oacute;n (-2), y as&amp;iacute; sucesivamente hasta que se alcanza la lista m&amp;aacute;s externa.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="317be1616a174c84304de299b4ead5ef76ce4a76" translate="yes" xml:space="preserve">
          <source>Boolean (True or False) stored as a byte</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">Booleano (tipo entero donde todos los valores son sólo Verdaderos o Falsos)</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">Matriz booleana 1-d seleccionando qué entradas devolver.Si len(condición)es menor que el tamaño de a a lo largo del eje,entonces la salida se trunca a la longitud de la matriz de condiciones.</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">La indexación de la matriz booleana</target>
        </trans-unit>
        <trans-unit id="60d82fac26a05eb411b70101c41bd3047454cb5f" translate="yes" xml:space="preserve">
          <source>Boolean array indices with mismatching shapes now properly give &lt;code&gt;IndexError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Matriz booleana de la misma forma que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="233d1fbe1852dc657d35dfe3cd279e3947a9a911" translate="yes" xml:space="preserve">
          <source>Boolean arrays used as indices are treated in a different manner entirely than index arrays. Boolean arrays must be of the same shape as the initial dimensions of the array being indexed. In the most straightforward case, the boolean array has the same shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98073379b648edd4cbe725ce47f959a6d23058d4" translate="yes" xml:space="preserve">
          <source>Boolean indexing changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">Booleana que indica si el orden de los bytes de este tipo es nativo de la plataforma.</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">Booleana que indica si el dtype es una estructura que mantiene la alineación del campo.</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">Booleana que indica si el dtype es una estructura que mantiene la alineación del campo.Esta bandera es pegajosa,por lo que al combinar varias estructuras juntas,se conserva y produce nuevos tipos que también están alineados.</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">Booleana que indica si este tipo contiene algún objeto de referencia en algún campo o subtipo.</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de m&amp;aacute;scara booleana. Tiene que tener la misma forma que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de m&amp;aacute;scara booleana. Debe tener el mismo tama&amp;ntilde;o que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">Operaciones booleanas</target>
        </trans-unit>
        <trans-unit id="0d747f327c87280779ba3eb08a42ad6dc25e090e" translate="yes" xml:space="preserve">
          <source>Boolean or &amp;ldquo;mask&amp;rdquo; index arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">Resultado booleano de comprobar si &lt;code&gt;rep&lt;/code&gt; es un tipo d escalar.</target>
        </trans-unit>
        <trans-unit id="e4ae3e1eb416ce7ddaa17364adbe02e871496027" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical AND operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Resultado booleano de la operaci&amp;oacute;n l&amp;oacute;gica OR aplicada a los elementos de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; ; la forma se determina por radiodifusi&amp;oacute;n. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Resultado booleano de la operaci&amp;oacute;n l&amp;oacute;gica XOR aplicada a los elementos de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; ; la forma se determina por radiodifusi&amp;oacute;n. Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Resultado booleano con la misma forma que &lt;code&gt;x&lt;/code&gt; de la operaci&amp;oacute;n NOT en elementos de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="b93268f3c2db16861f90ecc22ed53005b764061c" translate="yes" xml:space="preserve">
          <source>Boolean type (True or False), stored as a byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">Las booleanas también son aceptadas:</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="37cb1b945ecb9b619ea4147615565076f43e7b81" translate="yes" xml:space="preserve">
          <source>Boost Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb86696c9c70e3e908a024dfe4075dae3951c7" translate="yes" xml:space="preserve">
          <source>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. I have not used Boost.Python because I am not a big user of C++ and using Boost to wrap simple C-subroutines is usually over-kill. It&amp;rsquo;s primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9f5c6c1605197a54538b1a42018d968a659108" translate="yes" xml:space="preserve">
          <source>Boost.Python</source>
          <target state="translated">Boost.Python</target>
        </trans-unit>
        <trans-unit id="35f319efb34e1e345510a06307dd059dbed15ac2" translate="yes" xml:space="preserve">
          <source>Boost.python</source>
          <target state="translated">Boost.python</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">Tanto &lt;code&gt;u&lt;/code&gt; como &lt;code&gt;v&lt;/code&gt; deben ser 0-d o 1-d (ndim = 0 o 1), pero &lt;code&gt;u.ndim&lt;/code&gt; no necesita ser igual a &lt;code&gt;v.ndim&lt;/code&gt; . En otras palabras, las cuatro combinaciones posibles: &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; , &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; , &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; y &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - trabajo.</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">Tanto el pedido C (&quot;&amp;uacute;ltima dimensi&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida&quot;) como el pedido Fortran (&quot;primera dimensi&amp;oacute;n m&amp;aacute;s r&amp;aacute;pido&quot;) admiten matrices 2D, 3D y 4D.</target>
        </trans-unit>
        <trans-unit id="3720a76c9cc3b6258ee484172d090cd5b19b7e16" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a &lt;code&gt;DLL&lt;/code&gt; or &lt;code&gt;so&lt;/code&gt;. An example showing the use of a more complicated distribution is in the &lt;code&gt;examples&lt;/code&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">Tanto los CTypes como los CFFI permiten que las distribuciones más complicadas se utilicen directamente en Numba después de compilar el archivo distributions.c en una DLL más o menos.Un ejemplo que muestra el uso de una distribución más complicada se encuentra en la carpeta de ejemplos.</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">Ambos argumentos deben ser convertibles en objetos de tipo datos con el mismo tamaño total.</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">Ambos para la indexación:</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">Ambas rutinas multiplican una matriz de &lt;em&gt;n&lt;/em&gt; longitudes, &lt;em&gt;seq&lt;/em&gt; , de enteros y devuelven el resultado. No se realiza ninguna comprobaci&amp;oacute;n de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="e7d4dd33376799dad2f66b13833f7382c04f91d5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; attributes will equal &lt;code&gt;None&lt;/code&gt; for unstructured arrays. The recommended way to test if a dtype is structured is with &lt;code&gt;if dt.names is not None&lt;/code&gt; rather than &lt;code&gt;if dt.names&lt;/code&gt;, to account for dtypes with 0 fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5df7074d510c649a42e62d1e6b7c4d94875f1b9" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;../glossary#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">Tanto los &amp;oacute;rdenes C como los de Fortran son &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguos&lt;/a&gt; , &lt;em&gt;es decir,&lt;/em&gt; dise&amp;ntilde;os de memoria de un solo segmento, en los que se puede acceder a cada parte del bloque de memoria mediante alguna combinaci&amp;oacute;n de &amp;iacute;ndices.</target>
        </trans-unit>
        <trans-unit id="d093ba37f9ce9c9f30f8fca73c109507dfcb0225" translate="yes" xml:space="preserve">
          <source>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when &lt;code&gt;x.ndim != 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">Ambos vectores con dimensión 2.</target>
        </trans-unit>
        <trans-unit id="ee63b82109d9ff030ecbe37ab04ceac7db2412e8" translate="yes" xml:space="preserve">
          <source>Breaking long lines: if you can, break after commas in the outermost argument list. Always indent continuation lines appropriately, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution&amp;rdquo;, &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">Transmitir una matriz a una nueva forma</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">Transmitir una matriz a una nueva forma.</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">Emitir cualquier número de matrices contra cada una de ellas.</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">Transmita los par&amp;aacute;metros de entrada entre s&amp;iacute; y devuelva un objeto que encapsule el resultado. Entre otras, tiene propiedades de &lt;code&gt;shape&lt;/code&gt; y &lt;code&gt;nd&lt;/code&gt; , y se puede utilizar como iterador.</target>
        </trans-unit>
        <trans-unit id="a82937f02ff3220ad370539cf8e7b1333cdbe7e9" translate="yes" xml:space="preserve">
          <source>Broadcast the input shapes into a single shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb1c7bbc547d77034be314540af70ac8dab269b" translate="yes" xml:space="preserve">
          <source>Broadcasted shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">Radiodifusión (multi-iteradores)</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">Iteración de la matriz de radiodifusión</target>
        </trans-unit>
        <trans-unit id="ffca602e6975476928a035e0bd899a364b765bab" translate="yes" xml:space="preserve">
          <source>Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">La radiodifusión y la multiplicación escalar:</target>
        </trans-unit>
        <trans-unit id="9c4c6b372f00f9bbc9735f2491e20986adab213c" translate="yes" xml:space="preserve">
          <source>Broadcasting comes up quite often in real world problems. A typical example occurs in the vector quantization (VQ) algorithm used in information theory, classification, and other related areas. The basic operation in VQ [#f0] finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown in &lt;a href=&quot;#figure-5&quot;&gt;Figure 5&lt;/a&gt;, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, &lt;code&gt;codes[0]&lt;/code&gt; is the closest class indicating that the athlete is likely a basketball player.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">La radiodifusión es convencional para las pilas de conjuntos</target>
        </trans-unit>
        <trans-unit id="60a524b775e11155b5c4df4747f272a28d6e6176" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt;&lt;code&gt;numpy.doc.broadcasting&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8bfce10b38e0298dd7b485ac126daa93a79456" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;code&gt;basics.broadcasting&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">La difusi&amp;oacute;n se utiliza en todo NumPy para decidir c&amp;oacute;mo manejar matrices de formas dispares; por ejemplo, todas las operaciones aritm&amp;eacute;ticas ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; ,&amp;hellip;) entre &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; difunden las matrices antes de la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c2ccb1ef65055f853bfad815cb4304fa00148706" translate="yes" xml:space="preserve">
          <source>Broadcasting over multiple arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8643e22fd07e0fa1b2c6f3538e1689c01bced1a3" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays that produces the same result as &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f086db6f9cde283cd15667e2a34db081fa8323d1" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a860416eab96b40dda7fe2424a559b1d3ae5f" translate="yes" xml:space="preserve">
          <source>Broadcasting rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Se aplican las reglas de transmisi&amp;oacute;n; consulte la documentaci&amp;oacute;n de &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">La radiodifusi&amp;oacute;n siempre se implement&amp;oacute; en num&amp;eacute;rico utilizando pasos de valor 0 para las dimensiones extendidas. Se hace exactamente de la misma manera en NumPy. La gran diferencia es que ahora se realiza un seguimiento de la matriz de pasos en un &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; , los iteradores involucrados en un resultado de transmisi&amp;oacute;n se mantienen en un &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; , y la llamada &lt;code&gt;PyArray_BroadCast&lt;/code&gt; implementa las reglas de transmisi&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="34f655aae3670aa20a7e4bb7846e02a31bb3ce80" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; call implements the broad-casting rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0a6879b6872d1f7b106e1d3c8e15aa2bd9c9f9" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Difusi&amp;oacute;n, multiplicaci&amp;oacute;n por elementos y escalar, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">El b&amp;uacute;fer ( &lt;code&gt;buf&lt;/code&gt; ) se interpreta de acuerdo con estos pasos (los pasos definen cu&amp;aacute;ntos bytes ocupa cada elemento de matriz, fila, columna, etc. en la memoria).</target>
        </trans-unit>
        <trans-unit id="3a3c6f456f2df72c3dcf8bdef2f2f225bc537cc1" translate="yes" xml:space="preserve">
          <source>Buffer of binary data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">Lazo de amortiguación</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">Un iterador amortiguado para grandes conjuntos.</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">El modo de búfer mitiga el problema de uso de la memoria y es más fácil de guardar en la memoria caché que hacer copias temporales.Excepto en casos especiales,en los que se necesita todo el conjunto a la vez fuera del iterador,se recomienda el buffering sobre la copia temporal.Dentro de NumPy,el buffering es utilizado por los ufuncs y otras funciones para soportar entradas flexibles con una mínima sobrecarga de memoria.</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">Amortiguar los elementos de la matriz</target>
        </trans-unit>
        <trans-unit id="e0ea19fac7306381f9369bebfc56bf181ad2f644" translate="yes" xml:space="preserve">
          <source>Bugs Fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95995878b77d2a8ce4a1c4b232969f85fc5862" translate="yes" xml:space="preserve">
          <source>Build System Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">Construye un objeto matriz a partir de una cadena,secuencia anidada o matriz.</target>
        </trans-unit>
        <trans-unit id="62d0591005ae8571425b97ff29068016515cd29b" translate="yes" xml:space="preserve">
          <source>Build and archive documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcd3a3a0bc7c1a4ce328d262f632a0650b70528" translate="yes" xml:space="preserve">
          <source>Build extension module from a Fortran 77 source string with f2py.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d349060ba731253879161224c46e4521b75c084" translate="yes" xml:space="preserve">
          <source>Build options can be discovered by running any of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368f9cf215b81c7db781f6218da65973b2216ee7" translate="yes" xml:space="preserve">
          <source>Build options for compilation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1b626e82829b0dfeb4bfac3a16b7d5bcd6a8fc" translate="yes" xml:space="preserve">
          <source>Build source releases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4c8827fa3eb397f1363449f23094e9e120bb77" translate="yes" xml:space="preserve">
          <source>Build the changelog and notes for upload with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133bc31192cbeea22da4122bb90ba0a93a894d67" translate="yes" xml:space="preserve">
          <source>Build wheels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">Construir bibliotecas instalables C</target>
        </trans-unit>
        <trans-unit id="fc68ddc861d1de39d367519f523580fe22e0de8b" translate="yes" xml:space="preserve">
          <source>Building NumPy requires the following software installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7247d0ef96399c8a6f6f94bdfcbbd262feaf108" translate="yes" xml:space="preserve">
          <source>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as &lt;code&gt;python-dbg&lt;/code&gt;) is highly recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ab4efd8b4a10d38ed8959a1cb29fc9881db378" translate="yes" xml:space="preserve">
          <source>Building against OpenBLAS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cd4f14fd9faeca78fccf35fd005e67e4d55852" translate="yes" xml:space="preserve">
          <source>Building and Extending the Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e724a6fd06203378a19b755ba05b8cd55da0f623" translate="yes" xml:space="preserve">
          <source>Building and extending the documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6e2e9b251f8b11fe3d952437e66c0d7503db76" translate="yes" xml:space="preserve">
          <source>Building docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797c000e127fd646fe95625f81ea1c57543896ff" translate="yes" xml:space="preserve">
          <source>Building in-place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">Construir matrices</target>
        </trans-unit>
        <trans-unit id="d1d8b51984115777766e2f069b697c4bb754479c" translate="yes" xml:space="preserve">
          <source>Building source archives and wheels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc054390cfe90161261914ab7d65d3cfee4150a" translate="yes" xml:space="preserve">
          <source>Building the NumPy API and reference docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0584a2ddbe43766e4479e6f854126bbc0cb8a1" translate="yes" xml:space="preserve">
          <source>Building the documents requires a number of latex &lt;code&gt;.sty&lt;/code&gt; files. Install them all to avoid aggravation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afe730004d87377bea3908e9c6c7255bf4ce79e" translate="yes" xml:space="preserve">
          <source>Building the extension module can be now carried out in one command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">Crea un conjunto de pasos que son los mismos que los pasos de una matriz de salida creada usando la bandera &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; , donde se pas&amp;oacute; NULL para op_axes. Esto es para datos empaquetados de forma contigua, pero no necesariamente en el orden C o Fortran. Esto debe usarse junto con &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt; con la bandera &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; pasada al constructor.</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">Tipos de pitón incorporados</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">Tipos de escalares incorporados</target>
        </trans-unit>
        <trans-unit id="4a2892e18069d1f5869c7225c38ebadc7aa96d21" translate="yes" xml:space="preserve">
          <source>Bundled version of LAPACK is now 3.2.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">Funcionalidad del Día de Negocios</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">Funciones del día laboral</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">Pero se pueden utilizar diferentes tipos para la sustitución.De hecho,así es como la conversión de las clases de polinomios entre sí se hace para el tipo,el dominio y el moldeo de la ventana:</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">Pero si la &lt;code&gt;rowsum&lt;/code&gt; tendr&amp;iacute;a dos dimensiones:</target>
        </trans-unit>
        <trans-unit id="a50860d81b9d10875263242c5534750b4457432a" translate="yes" xml:space="preserve">
          <source>But if the arrays have different dtype metadata, the metadata may be dropped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cce3613bf130a21ef8719b403ca292f0f091a49" translate="yes" xml:space="preserve">
          <source>But in certain useful cases, NumPy can duplicate data along &amp;ldquo;missing&amp;rdquo; axes or &amp;ldquo;too-short&amp;rdquo; dimensions so shapes will match. The duplication costs no memory or time. For details, see &lt;a href=&quot;user/basics.broadcasting&quot;&gt;Broadcasting.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">Pero tambi&amp;eacute;n se permite producir, para algunos &lt;code&gt;a, b, c, d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="95f2ff26f5da95b9bea4d70486f2a022cde496b8" translate="yes" xml:space="preserve">
          <source>But it automatically handles negative inputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">Pero esa no es la &amp;uacute;nica forma de verlo. Suponga que uno tiene grandes matrices bidimensionales (im&amp;aacute;genes o matrices) almacenadas en archivos de datos. Suponga que los datos se almacenan por filas en lugar de columnas. Si queremos preservar nuestra convenci&amp;oacute;n de &amp;iacute;ndice (ya sea de matriz o imagen), eso significa que, dependiendo del lenguaje que usemos, podemos vernos obligados a reordenar los datos si se leen en la memoria para preservar nuestra convenci&amp;oacute;n de indexaci&amp;oacute;n. Por ejemplo, si leemos datos ordenados por filas en la memoria sin reordenarlos, coincidir&amp;aacute; con la convenci&amp;oacute;n de indexaci&amp;oacute;n matricial para C, pero no para Fortran. A la inversa, coincidir&amp;aacute; con la convenci&amp;oacute;n de indexaci&amp;oacute;n de im&amp;aacute;genes para Fortran, pero no para C. Para C, si uno est&amp;aacute; usando datos almacenados en orden de fila y desea preservar la convenci&amp;oacute;n de &amp;iacute;ndice de imagen, los datos deben reordenarse cuando se leen en la memoria.</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">Pero hay consideraciones multiplataforma,como las extensiones de los archivos de las bibliotecas,además del hecho de que Windows sólo cargará la primera biblioteca que encuentre con ese nombre.NumPy provee la función load_library como una conveniencia.</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">Pero esto omite algunas sutilezas.Aquí hay un resumen completamente general:</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">Pero también podemos especificar el eje sobre el cual multiplicar:</target>
        </trans-unit>
        <trans-unit id="9f79d5f66a9deb8e0798847bf7ab428de8db1e5a" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;ravel&lt;/code&gt;, the changes you make to the new array will affect the parent array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7460c60c1fec76b65a3c31a575c95674fb86e283" translate="yes" xml:space="preserve">
          <source>But, we could do anything we wanted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">Buzas, Mart&amp;iacute;n A .; Culver, Stephen J., Comprensi&amp;oacute;n de la diversidad de especies regionales a trav&amp;eacute;s de la distribuci&amp;oacute;n de ocurrencias en series logar&amp;iacute;tmicas: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volumen 5, N&amp;uacute;mero 5, septiembre de 1999, p&amp;aacute;gs. 187-195 (9).</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">Al elegir un desplazamiento de 8 bytes podemos seleccionar la parte compleja de la matriz para nuestra vista:</target>
        </trans-unit>
        <trans-unit id="c96bbfd74d3086f0a931f577a61fdefbdd812bbe" translate="yes" xml:space="preserve">
          <source>By constructing a new ndarray of your desired shape and type using &lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or a simpler macro or function based on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">Por convención,el signo negativo representa el flujo de salida de dinero (es decir,el dinero que no está disponible hoy en día).Así,ahorrar 100 dólares al mes al 5% de interés anual lleva a 15.692,93 dólares disponibles para gastar en 10 años.</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">Por convenci&amp;oacute;n, el signo negativo representa el flujo de efectivo que sale (es decir, dinero no disponible hoy). Por lo tanto, para terminar con $ 15,692.93 en 10 a&amp;ntilde;os ahorrando $ 100 al mes con un inter&amp;eacute;s anual del 5%, el dep&amp;oacute;sito inicial tambi&amp;eacute;n debe ser de $ 100.</target>
        </trans-unit>
        <trans-unit id="e8f9209679e0d480aec7fb981fefcc0f2b86d6ab" translate="yes" xml:space="preserve">
          <source>By converting it from some Python object using &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; or a macro built on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2387467eae05dde35d2654a3dbfc0d30bc85b00f" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;align=False&lt;/code&gt;), numpy will pack the fields together such that each field starts at the byte offset the previous field ended, and the fields are contiguous in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">Por defecto, &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt; genera un AssertionError en caso de falla.</target>
        </trans-unit>
        <trans-unit id="57786a266025c7ab2defbf0e660b34ff7cd9c745" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../arrays.scalars#numpy.float16&quot;&gt;&lt;code&gt;float16&lt;/code&gt;&lt;/a&gt; results are computed using &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; intermediates for extra precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3d90ca79bba610cc2cceb26a3b68c32b444a0a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; returns a copy. To operate in-place with &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt;, pass the same array as the first argument &lt;em&gt;and&lt;/em&gt; as the value of the &lt;code&gt;out&lt;/code&gt; parameter. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; usa bits proporcionados por &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; que tiene mejores propiedades estad&amp;iacute;sticas que el generador de n&amp;uacute;meros aleatorios mt19937 heredado en &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">De forma predeterminada, los resultados de &lt;code&gt;float16&lt;/code&gt; se calculan utilizando intermedios &lt;code&gt;float32&lt;/code&gt; para una precisi&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="f255d5e8f1a7ce5480c00642bd965d8cbd147605" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;skip_header=0&lt;/code&gt; and &lt;code&gt;skip_footer=0&lt;/code&gt;, meaning that no lines are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">De forma predeterminada, se crea una nueva matriz con la forma y el tipo de datos dados. Si se especifica &lt;code&gt;buf&lt;/code&gt; y es un objeto que expone la interfaz del b&amp;uacute;fer, la matriz utilizar&amp;aacute; la memoria del b&amp;uacute;fer existente. En este caso, las palabras clave &lt;code&gt;offset&lt;/code&gt; y &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="823f8fa3f73a578c65a2065fa5f02e69dcee70ef" translate="yes" xml:space="preserve">
          <source>By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt;&lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt;&lt;/a&gt; (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt; for the scalarkind argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c9f5af6f6f20b9748f044265ea41cc53afdaad" translate="yes" xml:space="preserve">
          <source>By default, any empty string is marked as missing. We can also consider more complex strings, such as &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; or &lt;code&gt;&quot;???&quot;&lt;/code&gt; to represent missing or invalid data. The &lt;code&gt;missing_values&lt;/code&gt; argument accepts three kind of values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">De forma predeterminada, astype siempre devuelve una matriz reci&amp;eacute;n asignada. Si se establece en falso y se &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; los requisitos dtype , &lt;code&gt;order&lt;/code&gt; y &lt;code&gt;subok&lt;/code&gt; , se devuelve la matriz de entrada en lugar de una copia.</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">De forma predeterminada, astype siempre devuelve una matriz reci&amp;eacute;n asignada. Si se establece en falso y se &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; los requisitos dtype , &lt;code&gt;order&lt;/code&gt; y &lt;code&gt;subok&lt;/code&gt; , se devuelve la matriz de entrada en lugar de una copia.</target>
        </trans-unit>
        <trans-unit id="67bd53a8510577a68e06f12cd6753f65341b7ba7" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">De forma predeterminada, astype siempre devuelve una matriz reci&amp;eacute;n asignada. Si se establece en falso y se &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; los requisitos dtype , &lt;code&gt;order&lt;/code&gt; y &lt;code&gt;subok&lt;/code&gt; , se devuelve la matriz de entrada en lugar de una copia.</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">Por defecto,calcula el producto de todos los elementos:</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">De forma predeterminada, los valores enmascarados se reconocen como tales. Si &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; tienen la misma forma, una m&amp;aacute;scara com&amp;uacute;n est&amp;aacute; asignado: si &lt;code&gt;x[i,j]&lt;/code&gt; es enmascarado, a continuaci&amp;oacute;n, &lt;code&gt;y[i,j]&lt;/code&gt; tambi&amp;eacute;n ser&amp;aacute;n enmascarados. Establecer &lt;code&gt;allow_masked&lt;/code&gt; en False generar&amp;aacute; una excepci&amp;oacute;n si faltan valores en cualquiera de las matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">De forma predeterminada, el modo es &quot;completo&quot;. Esto devuelve la convoluci&amp;oacute;n en cada punto de superposici&amp;oacute;n, con una forma de salida de (N + M-1,). En los puntos finales de la convoluci&amp;oacute;n, las se&amp;ntilde;ales no se superponen completamente y se pueden ver efectos de contorno.</target>
        </trans-unit>
        <trans-unit id="781e5458e78b28bbdf619e8539b2f911598af3c5" translate="yes" xml:space="preserve">
          <source>By default, returned multidimensional arrays are Fortran-contiguous. If &lt;code&gt;intent(c)&lt;/code&gt; is used, then returned multidimensional arrays are C-contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">Por defecto,invierta las dimensiones,de lo contrario permute los ejes según los valores dados.</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">Por defecto, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; trata el operando de entrada como un objeto de solo lectura. Para poder modificar los elementos de la matriz, debe especificar el modo de lectura-escritura o de solo escritura utilizando los &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; por operando &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; o 'writeonly' .</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">De forma predeterminada, el &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; usa los indicadores 'asignar' y 'escribir solo' para los operandos que se pasan como Ninguno. Esto significa que pudimos proporcionar solo los dos operandos al iterador y &amp;eacute;l manej&amp;oacute; el resto.</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">Por defecto,el tipo de datos se infiere a partir de los datos de entrada.</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">Por defecto,el índice está en la matriz aplanada,de lo contrario a lo largo del eje especificado.</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">De forma predeterminada, el iterador produce punteros en las matrices proporcionadas, que pueden estar alineadas o no alineadas, y con cualquier orden de bytes. Si la copia o el almacenamiento en b&amp;uacute;fer no est&amp;aacute;n habilitados y los datos del operando no satisfacen las restricciones, se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="ab25c157edc4354c1f57c1df2646a0b82ab1dad1" translate="yes" xml:space="preserve">
          <source>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the &lt;code&gt;axis&lt;/code&gt; parameter you can apply an operation along the specified axis of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8619d136820b4ea98c355d5e9bb29020512d7ef1" translate="yes" xml:space="preserve">
          <source>By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument &lt;code&gt;autostrip&lt;/code&gt; to a value of &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">Al eliminar el bucle interno en la descripci&amp;oacute;n anterior y usar &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; para construir objetos de corte simples, &lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; se puede expresar en t&amp;eacute;rminos de aplicar una indexaci&amp;oacute;n elegante a cada corte 1-d:</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">Al activar el modo de amortiguación,los trozos proporcionados por el iterador al bucle interior pueden hacerse más grandes,reduciendo significativamente la sobrecarga del intérprete de la pitón.En el ejemplo de forzar el orden de iteración de Fortran,el bucle interior consigue ver todos los elementos de una sola vez cuando se habilita el buffering.</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">Examinando los coeficientes,vemos que la línea debería tener un gradiente de aproximadamente 1 y cortar el eje y en,más o menos,-1.</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">El caso más complejo es,con mucho,el de la indexación avanzada,que puede o no combinarse con la indexación típica basada en la vista.Aquí los índices enteros se interpretan como basados en la vista.Antes de intentar comprender esto,puede que quieras familiarizarte con sus sutilezas.El código de indexación avanzada tiene tres ramas diferentes y un caso especial:</target>
        </trans-unit>
        <trans-unit id="e675b296a66e810552905002296a09520d23ea5d" translate="yes" xml:space="preserve">
          <source>By organizing how-tos this way, you not only display the options for people who need to narrow their question, you also have provided answers for users who start with narrower questions (&amp;ldquo;I want to see historic buildings,&amp;rdquo; &amp;ldquo;Which way to city hall?&amp;rdquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46784614463c18819405731702cb3c998ad15a83" translate="yes" xml:space="preserve">
          <source>By placing intent directives and checking code, the interface can be cleaned up quite a bit until the Python module method is both easier to use and more robust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">Al sustituir</target>
        </trans-unit>
        <trans-unit id="a10b2dfc802325db14226bfb0f644772b0ee8dc9" translate="yes" xml:space="preserve">
          <source>By testing them against the compiler, and seeing what the compiler can support according to the requested optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">Seg&amp;uacute;n la descripci&amp;oacute;n anterior, las reglas de conversi&amp;oacute;n se implementan esencialmente por la cuesti&amp;oacute;n de cu&amp;aacute;ndo un tipo de datos se puede convertir &quot;de forma segura&quot; a otro tipo de datos. La respuesta a esta pregunta se puede determinar en Python con una llamada a la funci&amp;oacute;n: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt; . La siguiente figura muestra los resultados de esta llamada para los 24 tipos admitidos internamente en el sistema de 64 bits del autor. Puede generar esta tabla para su sistema con el c&amp;oacute;digo que se muestra en la Figura.</target>
        </trans-unit>
        <trans-unit id="0cffcf4de4e9b85ff13913ac390d2131986b166e" translate="yes" xml:space="preserve">
          <source>Byte (-128 to 127)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b1bb21176956a777afbce91b2dc46b27bfdbd1" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">Orden de bytes de los datos ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; o &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="33aea8e37e75e01b5515b25f2b9a264a2526b968" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">Orden de bytes para forzar; un valor de las especificaciones de orden de bytes anteriores. El valor predeterminado ('S') da como resultado el intercambio del orden de bytes actual. El c&amp;oacute;digo hace una verificaci&amp;oacute;n que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas en la primera letra de &lt;code&gt;new_order&lt;/code&gt; para las alternativas anteriores. Por ejemplo, cualquiera de 'B' o 'b' o 'biggish' son v&amp;aacute;lidos para especificar big-endian.</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">Orden de bytes para forzar; un valor de las especificaciones de orden de bytes a continuaci&amp;oacute;n. &lt;code&gt;new_order&lt;/code&gt; c&amp;oacute;digos new_order pueden ser cualquiera de los siguientes:</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">Orden de bytes para forzar; un valor de las especificaciones de orden de bytes a continuaci&amp;oacute;n. El valor predeterminado ('S') da como resultado el intercambio del orden de bytes actual. &lt;code&gt;new_order&lt;/code&gt; c&amp;oacute;digos new_order pueden ser cualquiera de los siguientes:</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">Orden de bytes para todos los campos.</target>
        </trans-unit>
        <trans-unit id="3d30b75f6bbab6dd2f33ea184465104adfe034dc" translate="yes" xml:space="preserve">
          <source>Byte-swapping</source>
          <target state="translated">Byte-swapping</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C Depreciación del API</target>
        </trans-unit>
        <trans-unit id="5eefd673571a664f98901cbfc9269cc56d66bdd2" translate="yes" xml:space="preserve">
          <source>C API changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991eaf0718be5436cf82b4e88422dbaeb580655b" translate="yes" xml:space="preserve">
          <source>C API for random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09f5c39498227c23bac03c4d85a857f0c660b68" translate="yes" xml:space="preserve">
          <source>C dialect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf0b9cf537d3452f0bedecd7885e6a6f5c95212" translate="yes" xml:space="preserve">
          <source>C expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5053549bf41c7c644de43b7357e8b95981f3b14c" translate="yes" xml:space="preserve">
          <source>C expressions are used in the following parts of signature files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">Orden C</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">Orden C.</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef859ea3c4b4e94c8561ce88af6e45cd8c349e4" translate="yes" xml:space="preserve">
          <source>C++ support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04e63e5d64190b9021eeae0aa43f4dd8f802b80" translate="yes" xml:space="preserve">
          <source>C-API</source>
          <target state="translated">C-API</target>
        </trans-unit>
        <trans-unit id="b42fb0a4e21a6c7c2ad779467660c5d634cd1f27" translate="yes" xml:space="preserve">
          <source>C-API Array Additions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e7136fe60c57d32b3ba713a50d60dd983c3865" translate="yes" xml:space="preserve">
          <source>C-API Developer Improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847c15716f4f18fd587862ab143e5d2f9581c235" translate="yes" xml:space="preserve">
          <source>C-API Ufunc Additions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">C-API para la aplicación de las funciones elementales</target>
        </trans-unit>
        <trans-unit id="6bc42241dfe0e66ad03fd900ab60e09366468123" translate="yes" xml:space="preserve">
          <source>C-Level string to datetime casts changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">Interfaz de funci&amp;oacute;n &lt;code&gt;numpy.ctypeslib&lt;/code&gt; tipos C ( numpy.ctypeslib )</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">Interfaz de la función externa del tipo C (numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="72c1b618d901fa2527c184612af8e5f097445876" translate="yes" xml:space="preserve">
          <source>C-contiguous or simply contiguous arrays when data is stored row-wise, i.e. indexing of data as stored in memory starts from the highest dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb65d7a9aa6da6471ba4a02f9d435dd19d2ae5a" translate="yes" xml:space="preserve">
          <source>C-order</source>
          <target state="translated">C-order</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">Las matrices ordenadas por C se evalúan como falsas incluso si también están ordenadas por FORTRAN.</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">Coeficientes de la integral de la serie C.</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">Lado C de la interfaz de la matriz</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">Acceso a la estructura C</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">Nombres de tipo C</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw, &quot;Serie de Chebyshev para funciones matem&amp;aacute;ticas&quot;, en &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt; , vol. 5, Londres: Her Majesty's Stationery Office, 1962.</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">Se han añadido funciones complejas similares a las del C99.Estas pueden ser utilizadas si se desea implementar extensiones C portátiles.Ya que seguimos soportando plataformas sin el tipo de complejo C99,es necesario restringir a la sintaxis compatible con C90,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="cf46ba2402ead2c46d226454dffcd7ce5ff43524" translate="yes" xml:space="preserve">
          <source>CFFI</source>
          <target state="translated">CFFI</target>
        </trans-unit>
        <trans-unit id="51aa24adb10c8f416d462fb3a5357dabf3e3fd38" translate="yes" xml:space="preserve">
          <source>CFFI + Numba</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f44f432adf98c7d09c95f8b09f92c94663702d" translate="yes" xml:space="preserve">
          <source>CFFI can be used to directly access the functions in &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt;. Some &amp;ldquo;massaging&amp;rdquo; of the header file is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">Interfaz CFFI</target>
        </trans-unit>
        <trans-unit id="a36da1e151b2b0823e662d5b8eaaa38259edebce" translate="yes" xml:space="preserve">
          <source>CI extended with additional services</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6821c968895aca188636e67b589fcc004a8bbd12" translate="yes" xml:space="preserve">
          <source>CPU arch detection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">Arquitectura de la CPU de la plataforma;sólo se define una de las anteriores.</target>
        </trans-unit>
        <trans-unit id="70b1c54ffd0a791d6e36e2ee0d98c9acf4b031e8" translate="yes" xml:space="preserve">
          <source>CPU features and other options are case-insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b3426c923b3e7b1cdee4b651f488f72bf3c78b" translate="yes" xml:space="preserve">
          <source>CXX</source>
          <target state="translated">CXX</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUO/C/CONTIGUO</target>
        </trans-unit>
        <trans-unit id="0ce3a73aca867f2538f5c735d732291c3a6e377f" translate="yes" xml:space="preserve">
          <source>Caches in &lt;code&gt;np.fft&lt;/code&gt; are now bounded in total size and item count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">Calcule &lt;code&gt;2**p&lt;/code&gt; para todo &lt;code&gt;p&lt;/code&gt; en la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">Calcule &lt;code&gt;2**x&lt;/code&gt; para todos los elementos de la matriz.</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">Calcule &lt;code&gt;exp(x) - 1&lt;/code&gt; para todos los elementos de la matriz.</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">Calcule el valor absoluto de los elementos.</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">Calcula la exponencial de todos los elementos de la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">Calcule el inverso generalizado de una matriz utilizando su descomposici&amp;oacute;n de valor singular (SVD) e incluyendo todos &lt;em&gt;los&lt;/em&gt; valores singulares &lt;em&gt;grandes&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">Calcula la n-ésima diferencia discreta a lo largo de un eje determinado.</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">Calcula la n-ésima diferencia discreta a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">Calcule la desviación estándar de los valores no-NaN.</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">Calcule la desviación estándar de estos valores.</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">Calcula la estadística t,ajustando el parámetro ddof al valor no sesgado para que el divisor en la desviación estándar sean los grados de libertad,N-1.</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">Calcula &lt;code&gt;1/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">Calcula el &lt;code&gt;element in test_elements&lt;/code&gt; , transmitiendo solo sobre el &lt;code&gt;element&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">Calcula el &lt;code&gt;element in test_elements&lt;/code&gt; , transmitiendo solo sobre el &lt;code&gt;element&lt;/code&gt; o . Devuelve una matriz booleana de la misma forma que el &lt;code&gt;element&lt;/code&gt; o que es True donde un elemento de &lt;code&gt;element&lt;/code&gt; est&amp;aacute; en &lt;code&gt;test_elements&lt;/code&gt; y False en caso contrario.</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">Calcula el &lt;code&gt;log(1 + x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">Calcula &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; . Esta funci&amp;oacute;n es &amp;uacute;til en estad&amp;iacute;sticas donde las probabilidades calculadas de eventos pueden ser tan peque&amp;ntilde;as como para exceder el rango de n&amp;uacute;meros de coma flotante normales. En tales casos, se almacena el logaritmo de la probabilidad calculada. Esta funci&amp;oacute;n permite sumar probabilidades almacenadas de esta forma.</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">Calcula &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; . Esta funci&amp;oacute;n es &amp;uacute;til en el aprendizaje autom&amp;aacute;tico cuando las probabilidades calculadas de eventos pueden ser tan peque&amp;ntilde;as como para exceder el rango de n&amp;uacute;meros de coma flotante normales. En tales casos, se puede utilizar en su lugar el logaritmo en base 2 de la probabilidad calculada. Esta funci&amp;oacute;n permite sumar probabilidades almacenadas de esta forma.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
