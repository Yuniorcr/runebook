<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="653a93daba5d03116d06838a5a76a1330934f611" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;str&lt;/code&gt; refers to either null terminated bytes or unicode strings depending on the Python version. In code targeting both Python 2 and 3 &lt;code&gt;np.unicode_&lt;/code&gt; should be used as a dtype for strings. See &lt;a href=&quot;#string-dtype-note&quot;&gt;Note on string types&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;str&lt;/code&gt; se refiere a bytes terminados en nulo o cadenas Unicode, seg&amp;uacute;n la versi&amp;oacute;n de Python. En el c&amp;oacute;digo dirigido a Python 2 y 3, &lt;code&gt;np.unicode_&lt;/code&gt; debe usarse como dtype para cadenas. Consulte la &lt;a href=&quot;#string-dtype-note&quot;&gt;Nota sobre los tipos de cadenas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="577f40a867da04018fffaab4749ee48c7ab85bee" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;test_&lt;/code&gt; functions or methods should not have a docstring, because that makes it hard to identify the test from the output of running the test suite with &lt;code&gt;verbose=2&lt;/code&gt; (or similar verbosity setting). Use plain comments (&lt;code&gt;#&lt;/code&gt;) if necessary.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;test_&lt;/code&gt; funciones o m&amp;eacute;todos test_ no deben tener una cadena de documentaci&amp;oacute;n, porque eso dificulta identificar la prueba a partir del resultado de ejecutar el conjunto de pruebas con &lt;code&gt;verbose=2&lt;/code&gt; (o una configuraci&amp;oacute;n de verbosidad similar). Utilice comentarios sencillos ( &lt;code&gt;#&lt;/code&gt; ) si es necesario.</target>
        </trans-unit>
        <trans-unit id="84da082e7c60f89cf395b2c2caf3ee075a4fd999" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tiny&lt;/code&gt; is not actually the smallest positive representable value in a NumPy floating point type. As in the IEEE-754 standard &lt;a href=&quot;#r2ee89c7f792a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, NumPy floating point types make use of subnormal numbers to fill the gap between 0 and &lt;code&gt;tiny&lt;/code&gt;. However, subnormal numbers may have significantly reduced precision &lt;a href=&quot;#r2ee89c7f792a-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e2af0a66e4601c973f5ec5d0ddca41b2da6bef" translate="yes" xml:space="preserve">
          <source>Note that C++ type &lt;code&gt;bool&lt;/code&gt; is not supported in the list in the &lt;a href=&quot;#available-typemaps&quot;&gt;Available Typemaps&lt;/a&gt; section. NumPy bools are a single byte, while the C++ &lt;code&gt;bool&lt;/code&gt; is four bytes (at least on my system). Therefore:</source>
          <target state="translated">Tenga en cuenta que el tipo &lt;code&gt;bool&lt;/code&gt; de C ++ no se admite en la lista de la secci&amp;oacute;n &lt;a href=&quot;#available-typemaps&quot;&gt;Mapas de tipos disponibles&lt;/a&gt; . Los bools de NumPy son de un solo byte, mientras que el &lt;code&gt;bool&lt;/code&gt; de C ++ tiene cuatro bytes (al menos en mi sistema). Por lo tanto:</target>
        </trans-unit>
        <trans-unit id="b7fb7bda276a077f32e3518dd51fb7c92f1227b3" translate="yes" xml:space="preserve">
          <source>Note that F2PY found that the second argument &lt;code&gt;n&lt;/code&gt; is the dimension of the first array argument &lt;code&gt;a&lt;/code&gt;. Since by default all arguments are input-only arguments, F2PY concludes that &lt;code&gt;n&lt;/code&gt; can be optional with the default value &lt;code&gt;len(a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa71944aea37a075fc5603b1c286b6996796fc2" translate="yes" xml:space="preserve">
          <source>Note that LaTeX is not particularly easy to read, so use equations sparingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc512ad322760dff623f859eafd23590a132e18" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4dc94a38ed3b66216a78c32ac7673436712897" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended. On ARM64 (aarch64) GCC 8.x (and later) are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fea2f832bdac55a57e8bcf7203f52e450af3e1" translate="yes" xml:space="preserve">
          <source>Note that NumPy submodules still use a file named &lt;code&gt;info.py&lt;/code&gt; in which the module docstring and &lt;code&gt;__all__&lt;/code&gt; dict are defined. These files will be removed at some point.</source>
          <target state="translated">Tenga en cuenta que los subm&amp;oacute;dulos de NumPy todav&amp;iacute;a usan un archivo llamado &lt;code&gt;info.py&lt;/code&gt; en el que se definen la &lt;code&gt;__all__&lt;/code&gt; documentos del m&amp;oacute;dulo y __all__ dict. Estos archivos se eliminar&amp;aacute;n en alg&amp;uacute;n momento.</target>
        </trans-unit>
        <trans-unit id="cd1c6148abd4d8a68d9037726f201b07b6224a50" translate="yes" xml:space="preserve">
          <source>Note that a Fortran source file can contain many routines, and not necessarily all routines are needed to be used from Python. So, you can either specify which routines should be wrapped (in &lt;code&gt;only: .. :&lt;/code&gt; part) or which routines F2PY should ignored (in &lt;code&gt;skip: .. :&lt;/code&gt; part).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ecaa164d1fdc3d2b5cb9ca7ff5cce49bcc5610" translate="yes" xml:space="preserve">
          <source>Note that a sliding window approach is often &lt;strong&gt;not&lt;/strong&gt; optimal (see Notes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243df166efa690ac8a711211a7fdea37ebc1d718" translate="yes" xml:space="preserve">
          <source>Note that although almost all modern C compilers pad in this way by default, padding in C structs is C-implementation-dependent so this memory layout is not guaranteed to exactly match that of a corresponding struct in a C program. Some work may be needed, either on the numpy side or the C side, to obtain exact correspondence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0319be442be6ef174d641d2057417bdd72b054" translate="yes" xml:space="preserve">
          <source>Note that another approach would be to to use &lt;code&gt;getattr(ufunc,
methods)(*inputs, **kwargs)&lt;/code&gt; instead of the &lt;code&gt;super&lt;/code&gt; call. For this example, the result would be identical, but there is a difference if another operand also defines &lt;code&gt;__array_ufunc__&lt;/code&gt;. E.g., lets assume that we evalulate &lt;code&gt;np.add(a, b)&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is an instance of another class &lt;code&gt;B&lt;/code&gt; that has an override. If you use &lt;code&gt;super&lt;/code&gt; as in the example, &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; will notice that &lt;code&gt;b&lt;/code&gt; has an override, which means it cannot evaluate the result itself. Thus, it will return &lt;code&gt;NotImplemented&lt;/code&gt; and so will our class &lt;code&gt;A&lt;/code&gt;. Then, control will be passed over to &lt;code&gt;b&lt;/code&gt;, which either knows how to deal with us and produces a result, or does not and returns &lt;code&gt;NotImplemented&lt;/code&gt;, raising a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3a7170281d96c749df00a8822f6364f1c668d7" translate="yes" xml:space="preserve">
          <source>Note that another way to do an inplace build visible outside the repo base dir is with &lt;code&gt;python setup.py develop&lt;/code&gt;. Instead of adjusting &lt;code&gt;PYTHONPATH&lt;/code&gt;, this installs a &lt;code&gt;.egg-link&lt;/code&gt; file into your site-packages as well as adjusts the &lt;code&gt;easy-install.pth&lt;/code&gt; there, so its a more permanent (and magical) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0bc3c9921682280a85d9ad74708f6af3774f00" translate="yes" xml:space="preserve">
          <source>Note that arrays with hard-coded dimensions are not supported. These cannot follow the double pointer signatures of these typemaps.</source>
          <target state="translated">Tenga en cuenta que no se admiten matrices con dimensiones de código duro.No pueden seguir las firmas de doble puntero de estos mapas tipográficos.</target>
        </trans-unit>
        <trans-unit id="48706be1cfd595ac0f989289e2a8fb9947cff916" translate="yes" xml:space="preserve">
          <source>Note that as the order of the arguments are reversed, the side must be too. The &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.</source>
          <target state="translated">Tenga en cuenta que como se invierte el orden de los argumentos, el lado tambi&amp;eacute;n debe serlo. La llamada de &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; es ligeramente m&amp;aacute;s r&amp;aacute;pida, ya que no realiza ning&amp;uacute;n control de monotonicidad. Quiz&amp;aacute;s lo m&amp;aacute;s importante es que admite todos los tipos.</target>
        </trans-unit>
        <trans-unit id="b5450d42b830584acc5db98da979017850552b6b" translate="yes" xml:space="preserve">
          <source>Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1107611495a4cef20786212c1426d524434253be" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a4ad0db92a475933d552d809189c9d735b06a9" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ba7f496bb7ba121307112b93618161ad3c991" translate="yes" xml:space="preserve">
          <source>Note that by default using single &lt;code&gt;intent(out)&lt;/code&gt; also implies &lt;code&gt;intent(hide)&lt;/code&gt;. Arguments that have the &lt;code&gt;intent(hide)&lt;/code&gt; attribute specified will not be listed in the argument list of a wrapper function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dd030963aaaf3be4bd9f6afb2a54167cbe9671" translate="yes" xml:space="preserve">
          <source>Note that computing a monthly mortgage payment is only one use for this function. For example, pmt returns the periodic deposit one must make to achieve a specified future balance given an initial deposit, a fixed, periodically compounded interest rate, and the total number of periods.</source>
          <target state="translated">Tenga en cuenta que el cálculo de un pago mensual de la hipoteca es sólo un uso para esta función.Por ejemplo,el pmt devuelve el depósito periódico que uno debe hacer para lograr un saldo futuro especificado dado un depósito inicial,un tipo de interés fijo y periódicamente compuesto,y el número total de períodos.</target>
        </trans-unit>
        <trans-unit id="d45705fbd740d84091e3bf2b229712fdd0365205" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3299a2dbf1b83250c6148ada8e7d466fe67fe1d" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;code&gt;str&lt;/code&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d023cb473537055d9b3a4020206aea9635b5fe" translate="yes" xml:space="preserve">
          <source>Note that dictionaries are not stored in any specific order. Also, most mutable (see &lt;em&gt;immutable&lt;/em&gt; below) objects, such as lists, may not be used as keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b262586803e1839adc1dd7ba61528562de1c4dc" translate="yes" xml:space="preserve">
          <source>Note that element</source>
          <target state="translated">Note que el elemento</target>
        </trans-unit>
        <trans-unit id="3361278c66a9a950ab868f2606daa6d980ba0742" translate="yes" xml:space="preserve">
          <source>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</source>
          <target state="translated">Obsérvese que el ajuste de los coeficientes de polinomios está intrínsecamente mal condicionado cuando el grado del polinomio es grande o el intervalo de puntos de muestra está mal centrado.La calidad del ajuste debe ser siempre comprobada en estos casos.Cuando los ajustes de los polinomios no son satisfactorios,las estrías pueden ser una buena alternativa.</target>
        </trans-unit>
        <trans-unit id="0754d929f5032a758a77b70b619d10e1a6b0a14a" translate="yes" xml:space="preserve">
          <source>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Nótese que para los números complejos,el valor absoluto se toma antes de la cuadratura,de modo que el resultado es siempre real y no negativo.</target>
        </trans-unit>
        <trans-unit id="17ba305768334a737a4dfbed178a872a09842e7e" translate="yes" xml:space="preserve">
          <source>Note that for documentation within numpy, it is not necessary to do &lt;code&gt;import numpy as np&lt;/code&gt; at the beginning of an example. However, some sub-modules, such as &lt;code&gt;fft&lt;/code&gt;, are not imported by default, and you have to include them explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc16e5fa0b99ff8394b543959e3c5038077d609b" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ef16afabd45555cde2cd7088469cd77b4f8e66" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532f8402b234b1805dc32ad508ed06d2d992bc4" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Tenga en cuenta que para la entrada de punto flotante, la media se calcula con la misma precisi&amp;oacute;n que tiene la entrada. Dependiendo de los datos de entrada, esto puede causar que los resultados sean inexactos, especialmente para &lt;code&gt;float32&lt;/code&gt; (vea el ejemplo a continuaci&amp;oacute;n). Especificar un acumulador de mayor precisi&amp;oacute;n mediante la palabra clave &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; puede aliviar este problema.</target>
        </trans-unit>
        <trans-unit id="28ec6b24f09abee0bf153ce2a68e94e6fc60a244" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Tenga en cuenta que para la entrada de punto flotante, la media se calcula con la misma precisi&amp;oacute;n que tiene la entrada. Dependiendo de los datos de entrada, esto puede hacer que los resultados sean inexactos, especialmente para &lt;code&gt;float32&lt;/code&gt; . Especificar un acumulador de mayor precisi&amp;oacute;n mediante la palabra clave &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; puede aliviar este problema.</target>
        </trans-unit>
        <trans-unit id="9429c3e4d702a779857d710d5ba3d4bb8d91e3db" translate="yes" xml:space="preserve">
          <source>Note that for higher dimensional inserts &lt;code&gt;obj=0&lt;/code&gt; behaves very different from &lt;code&gt;obj=[0]&lt;/code&gt; just like &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; is different from &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que para inserciones de dimensiones superiores &lt;code&gt;obj=0&lt;/code&gt; se comporta de manera muy diferente de &lt;code&gt;obj=[0]&lt;/code&gt; al igual que &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; es diferente de &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64098939d0cc3bd11f1e190ea4842decacbcc08d" translate="yes" xml:space="preserve">
          <source>Note that higher-dimensional arrays are flattened!</source>
          <target state="translated">¡Noten que las matrices de dimensiones superiores están aplanadas!</target>
        </trans-unit>
        <trans-unit id="08dbdae6232197f6e8ea8b77dc3750bf740014ac" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;threads&lt;/code&gt; is not set by the user, it will be determined by &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e03a6fba50452828f3483eb33a462b6c52de935" translate="yes" xml:space="preserve">
          <source>Note that if a field has the same name as an ndarray attribute, the ndarray attribute takes precedence. Such fields will be inaccessible by attribute but will still be accessible by index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c7921c177ba1f557c86613521ffad6b35f74d0" translate="yes" xml:space="preserve">
          <source>Note that if an operand is given the flag &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, a copy will be made in preference to buffering. Buffering will still occur when the array was broadcast so elements need to be duplicated to get a constant stride.</source>
          <target state="translated">Tenga en cuenta que si a un operando se le asigna el indicador &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , se realizar&amp;aacute; una copia con preferencia al almacenamiento en b&amp;uacute;fer. El almacenamiento en b&amp;uacute;fer seguir&amp;aacute; ocurriendo cuando se transmiti&amp;oacute; la matriz, por lo que los elementos deben duplicarse para obtener un paso constante.</target>
        </trans-unit>
        <trans-unit id="b29d0e1167132199e264175b7a1e173cb2ad60e1" translate="yes" xml:space="preserve">
          <source>Note that if an uninitialized return array is created, values of False will leave those values &lt;strong&gt;uninitialized&lt;/strong&gt;.</source>
          <target state="translated">Tenga en cuenta que si se crea una matriz de retorno no inicializada, los valores de False dejar&amp;aacute;n esos valores sin &lt;strong&gt;inicializar&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa598501b8ebf0323315a582a961e1c62a8f937" translate="yes" xml:space="preserve">
          <source>Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d909696047578f38bea71bdf411f55070df9d2" translate="yes" xml:space="preserve">
          <source>Note that if the C function signature was in a different order:</source>
          <target state="translated">Observe que si la firma de la función C estaba en un orden diferente:</target>
        </trans-unit>
        <trans-unit id="01a168adfe5fe1f5dd6875481bec15e4f9aa1985" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a reduction on an automatically allocated output, you must use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get its reference, then set every value to the reduction unit before doing the iteration loop. In the case of a buffered reduction, this means you must also specify the flag &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, then reset the iterator after initializing the allocated operand to prepare the buffers.</source>
          <target state="translated">Tenga en cuenta que si desea hacer una reducci&amp;oacute;n en una salida asignada autom&amp;aacute;ticamente, debe usar &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; para obtener su referencia y luego establecer cada valor en la unidad de reducci&amp;oacute;n antes de realizar el ciclo de iteraci&amp;oacute;n. En el caso de una reducci&amp;oacute;n en b&amp;uacute;fer, esto significa que tambi&amp;eacute;n debe especificar el indicador &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; , luego restablecer el iterador despu&amp;eacute;s de inicializar el operando asignado para preparar los b&amp;uacute;feres.</target>
        </trans-unit>
        <trans-unit id="2b010bbfdb300bcd389c385bed7ea27b3386f09b" translate="yes" xml:space="preserve">
          <source>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, and 32 = 0010 0000.</source>
          <target state="translated">Note que en binario 160=1010 0000,64=0100 0000,192=1100 0000,y 32=0010 0000.</target>
        </trans-unit>
        <trans-unit id="a6ebb270150b81af72246532a75002f3434d09b6" translate="yes" xml:space="preserve">
          <source>Note that in the code snippets below, &lt;code&gt;upstream&lt;/code&gt; refers to the root repository on github and &lt;code&gt;origin&lt;/code&gt; to a fork in your personal account. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit &lt;code&gt;.git/config&lt;/code&gt; and add &lt;code&gt;upstream&lt;/code&gt; if it isn&amp;rsquo;t already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0deb1edca6a6f101961c6c8ff2fdf5eb19dff4d3" translate="yes" xml:space="preserve">
          <source>Note that integer divide-by-zero is handled by the same machinery. These behaviors are set on a per-thread basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6720060be8821678605a9cb8b96c71daf2200a5d" translate="yes" xml:space="preserve">
          <source>Note that it is not required for &lt;code&gt;__array_function__&lt;/code&gt; implementations to include &lt;em&gt;all&lt;/em&gt; of the corresponding NumPy function&amp;rsquo;s optional arguments (e.g., &lt;code&gt;broadcast_to&lt;/code&gt; above omits the irrelevant &lt;code&gt;subok&lt;/code&gt; argument). Optional arguments are only passed in to &lt;code&gt;__array_function__&lt;/code&gt; if they were explicitly used in the NumPy function call.</source>
          <target state="translated">Tenga en cuenta que no es necesario que &lt;code&gt;__array_function__&lt;/code&gt; implementaciones de __array_function__ incluyan &lt;em&gt;todos&lt;/em&gt; los argumentos opcionales de la funci&amp;oacute;n NumPy correspondiente (por ejemplo, &lt;code&gt;broadcast_to&lt;/code&gt; anterior omite el argumento &lt;code&gt;subok&lt;/code&gt; irrelevante ). Los argumentos opcionales solo se pasan a &lt;code&gt;__array_function__&lt;/code&gt; si se usaron expl&amp;iacute;citamente en la llamada a la funci&amp;oacute;n NumPy.</target>
        </trans-unit>
        <trans-unit id="401f22bf499be24336e06ca8c727f49552e9ba96" translate="yes" xml:space="preserve">
          <source>Note that it would be more straightforward in the above example to extract the required elements directly with &lt;code&gt;x[:2, :3]&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que ser&amp;iacute;a m&amp;aacute;s sencillo en el ejemplo anterior extraer los elementos necesarios directamente con &lt;code&gt;x[:2, :3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640acbca975ba8209807d8f3d4cb4b40d4247c4c" translate="yes" xml:space="preserve">
          <source>Note that license and author info, while often included in source files, do not belong in docstrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03915cb39403716ec5a60a8297475cd1fe487299" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;a href=&quot;arrays.scalars#numpy.flexible&quot;&gt;&lt;code&gt;flexible&lt;/code&gt;&lt;/a&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaef84f5e6e416f2f83a03c812a03e6bee63048" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;code&gt;flexible&lt;/code&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="translated">Tenga en cuenta que no toda la informaci&amp;oacute;n de tipo de datos se puede suministrar con un tipo de objeto: por ejemplo, los &lt;code&gt;flexible&lt;/code&gt; datos flexibles tienen un &lt;em&gt;tama&amp;ntilde;o&lt;/em&gt; de &lt;em&gt;elemento&lt;/em&gt; predeterminado de 0 y requieren un tama&amp;ntilde;o dado expl&amp;iacute;citamente para ser &amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="780756f1773042c233a75d985a3181931209c4b9" translate="yes" xml:space="preserve">
          <source>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e81c263eba620a31c6f05237f30bb45194a05fe" translate="yes" xml:space="preserve">
          <source>Note that once the iterator is closed we can not access &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; and must use a reference created inside the context manager.</source>
          <target state="translated">Tenga en cuenta que una vez que se cierra el iterador, no podemos acceder a los &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; y debemos usar una referencia creada dentro del administrador de contexto.</target>
        </trans-unit>
        <trans-unit id="60c2866e24780637913bab15a3c10ed5a1e5ba08" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;a href=&quot;../arrays.scalars#numpy.int16&quot;&gt;&lt;code&gt;int16&lt;/code&gt;&lt;/a&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0072c6c9282c50699dd3bb094606976a4136251" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;code&gt;int16&lt;/code&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="translated">Tenga en cuenta que las operaciones en tipos escalares enteros (como &lt;code&gt;int16&lt;/code&gt; ) se manejan como punto flotante y se ven afectadas por esta configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b5c0500d98fa9cc106c3d86fe8d639514bc7b011" translate="yes" xml:space="preserve">
          <source>Note that slices of arrays do not copy the internal array data but only produce new views of the original data. This is different from list or tuple slicing and an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended if the original data is not required anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50c6ff377ac0a2ca64d0c66fbaa9d2065ec9a" translate="yes" xml:space="preserve">
          <source>Note that some examples may use &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;np.newaxis&lt;/code&gt;. These are the same objects:</source>
          <target state="translated">Tenga en cuenta que algunos ejemplos pueden usar &lt;code&gt;None&lt;/code&gt; en lugar de &lt;code&gt;np.newaxis&lt;/code&gt; . Estos son los mismos objetos:</target>
        </trans-unit>
        <trans-unit id="1c4abf3101df64ae31f9f09aef9564b202ca3573" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to rerun them. You will need to be logged in under &amp;lsquo;numpy&amp;rsquo; to do this on azure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f987286ad6faa40518b3a8186b7c20cb6434a93" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to restart them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa9fecdeba09a0f43a75d04eeb01c1da54d7720" translate="yes" xml:space="preserve">
          <source>Note that sorting is first according to the elements of &lt;code&gt;a&lt;/code&gt;. Secondary sorting is according to the elements of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que la clasificaci&amp;oacute;n es primero seg&amp;uacute;n los elementos de &lt;code&gt;a&lt;/code&gt; . La clasificaci&amp;oacute;n secundaria se realiza seg&amp;uacute;n los elementos de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab2cbf3d7d05721e26131cbe4f74f5e6c689750" translate="yes" xml:space="preserve">
          <source>Note that the above may not produce exact integers:</source>
          <target state="translated">Obsérvese que lo anterior puede no producir números enteros exactos:</target>
        </trans-unit>
        <trans-unit id="eca364d78cae8f55568bb70af05b48416bbfc64c" translate="yes" xml:space="preserve">
          <source>Note that the columns have been rearranged &amp;ldquo;in bulk&amp;rdquo;: the values within each column have not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816b54542ce937e025129bb5a02d396360440696" translate="yes" xml:space="preserve">
          <source>Note that the covariance matrix must be positive semidefinite (a.k.a. nonnegative-definite). Otherwise, the behavior of this method is undefined and backwards compatibility is not guaranteed.</source>
          <target state="translated">Obsérvese que la matriz de covarianza debe ser semidefinida positiva (es decir,no negativa-definida).De lo contrario,el comportamiento de este método es indefinido y no se garantiza la compatibilidad hacia atrás.</target>
        </trans-unit>
        <trans-unit id="ce6b6a669d0954769df5e326b05520fbeb05f879" translate="yes" xml:space="preserve">
          <source>Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see &lt;a href=&quot;../ufuncs#ufuncs-casting&quot;&gt;Casting Rules&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891f0fa3122015805e6600a7a4bd2235d2515ff8" translate="yes" xml:space="preserve">
          <source>Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, &lt;code&gt;b1&lt;/code&gt; has length 3 (the number of &lt;em&gt;rows&lt;/em&gt; in &lt;code&gt;a&lt;/code&gt;), and &lt;code&gt;b2&lt;/code&gt; (of length 4) is suitable to index the 2nd axis (columns) of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fdfec7c0c161ff5cf20da12ebf59920f92cef4" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is filled varies depending on the flip function.</source>
          <target state="translated">Observe que el orden en que se rellena la diagonal varía dependiendo de la función de giro.</target>
        </trans-unit>
        <trans-unit id="724f6e013fa8829f11659c1f81abf24921dbd546" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is retrieved varies depending on the flip function.</source>
          <target state="translated">Observe que el orden en que se recupera la diagonal varía dependiendo de la función de giro.</target>
        </trans-unit>
        <trans-unit id="a99c18cf39a32483fd943f4224186f409906587f" translate="yes" xml:space="preserve">
          <source>Note that the output of &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; is always 1D.</source>
          <target state="translated">Tenga en cuenta que la salida de &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt; es siempre 1D.</target>
        </trans-unit>
        <trans-unit id="fe6f42e3829661cf63ecd7296a8f95be4fb61504" translate="yes" xml:space="preserve">
          <source>Note that the result of each integration is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt;. Why is this important to note? Say one is making a linear change of variable</source>
          <target state="translated">Tenga en cuenta que el resultado de cada integraci&amp;oacute;n se &lt;em&gt;multiplica&lt;/em&gt; por &lt;code&gt;scl&lt;/code&gt; . &amp;iquest;Por qu&amp;eacute; es importante tener esto en cuenta? Digamos que uno est&amp;aacute; haciendo un cambio lineal de variable</target>
        </trans-unit>
        <trans-unit id="87d64ab0ec81404f96e3a3fd6a0cf4af1b48cd4a" translate="yes" xml:space="preserve">
          <source>Note that the result shape is identical to the (broadcast) indexing array shapes &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que la forma del resultado es id&amp;eacute;ntica a las formas de matriz de indexaci&amp;oacute;n (difusi&amp;oacute;n) &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="970776667a9fe553514eecc1dd1a72278348d24e" translate="yes" xml:space="preserve">
          <source>Note that the scalar types are not &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</source>
          <target state="translated">Tenga en cuenta que los tipos escalares no son objetos &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , aunque se pueden usar en lugar de uno siempre que se necesite una especificaci&amp;oacute;n de tipo de datos en NumPy.</target>
        </trans-unit>
        <trans-unit id="c59a59639135c22037a5377f994f5afdc88bff2a" translate="yes" xml:space="preserve">
          <source>Note that the strided-copy and strided-cast code are deeply intertwined and so any arrays being processed by them must be both uint and true aligned, even though the copy-code only needs uint alignment and the cast code only true alignment. If there is ever a big rewrite of this code it would be good to allow them to use different alignments.</source>
          <target state="translated">Note que el código de copia y el de emisión están profundamente entrelazados y por lo tanto cualquier arreglo que sea procesado por ellos debe estar alineado tanto en uint como en true,aunque el código de copia sólo necesita una alineación en uint y el código de emisión sólo una alineación en true.Si alguna vez hay una gran reescritura de este código sería bueno permitirles usar diferentes alineaciones.</target>
        </trans-unit>
        <trans-unit id="773d567bd01efce78b3ce4a4307782bcff7af947" translate="yes" xml:space="preserve">
          <source>Note that the string representation of polynomials uses Unicode characters by default (except on Windows) to express powers and subscripts. An ASCII-based representation is also available (default on Windows). The polynomial string format can be toggled at the package-level with the &lt;a href=&quot;generated/numpy.polynomial.set_default_printstyle#numpy.polynomial.set_default_printstyle&quot;&gt;&lt;code&gt;set_default_printstyle&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c05a00c87427b26e39bf9edf93e478c145e10d" translate="yes" xml:space="preserve">
          <source>Note that the terms in the multi-line Boolean expression are indented so as to make the beginning of the code block clearly visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecfca7c041f47ec9751b796cf84238ada1da72a" translate="yes" xml:space="preserve">
          <source>Note that the ufunc (&lt;code&gt;np.add&lt;/code&gt;) has called the &lt;code&gt;__array_wrap__&lt;/code&gt; method with arguments &lt;code&gt;self&lt;/code&gt; as &lt;code&gt;obj&lt;/code&gt;, and &lt;code&gt;out_arr&lt;/code&gt; as the (ndarray) result of the addition. In turn, the default &lt;code&gt;__array_wrap__&lt;/code&gt; (&lt;code&gt;ndarray.__array_wrap__&lt;/code&gt;) has cast the result to class &lt;code&gt;MySubClass&lt;/code&gt;, and called &lt;code&gt;__array_finalize__&lt;/code&gt; - hence the copying of the &lt;code&gt;info&lt;/code&gt; attribute. This has all happened at the C level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d91192b6712228963707a6381dc069bd269f72d" translate="yes" xml:space="preserve">
          <source>Note that there are no new elements in the array, just that the dimensionality is increased. This can be handy to combine two arrays in a way that otherwise would require explicitly reshaping operations. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c86d4295cc278f91db8c615a2b6f47dcfb069bb" translate="yes" xml:space="preserve">
          <source>Note that there are some subtleties regarding the last usage that the user should be aware of that are described in the arange docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272a5f558b3fab42d4539ad3dc738bcb4ce852" translate="yes" xml:space="preserve">
          <source>Note that there are three parts to the long version of the printout. The first is the coefficients, the second is the domain, and the third is the window:</source>
          <target state="translated">Observe que hay tres partes en la versión larga de la impresión.La primera son los coeficientes,la segunda es el dominio y la tercera es la ventana:</target>
        </trans-unit>
        <trans-unit id="3a9c78ac3abf35e5e3337780f5e62c12c7df494d" translate="yes" xml:space="preserve">
          <source>Note that this distribution is very similar to the binomial distribution, except that in this case, samples are drawn without replacement, whereas in the Binomial case samples are drawn with replacement (or the sample space is infinite). As the sample space becomes large, this distribution approaches the binomial.</source>
          <target state="translated">Obsérvese que esta distribución es muy similar a la del binomio,salvo que en este caso las muestras se extraen sin reemplazo,mientras que en el caso del binomio las muestras se extraen con reemplazo (o el espacio de muestra es infinito).A medida que el espacio de muestra se hace grande,esta distribución se aproxima al binomio.</target>
        </trans-unit>
        <trans-unit id="71bb480ec02fbb938cca2004bc6943842a328aaa" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;complex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c75e7f017341538d8b3f779cf45143d903afb1a" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207f864735403916ab64725fc35836347eea06c9" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;data_as&lt;/code&gt;, a reference will not be kept to the array: code like &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; will result in a pointer to a deallocated array, and should be spelt &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;data_as&lt;/code&gt; , no se guardar&amp;aacute; una referencia a la matriz: el c&amp;oacute;digo como &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; dar&amp;aacute; como resultado un puntero a una matriz desasignada y debe escribirse &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa5eae61b870cb56e093988870d6dd9877647aa6" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;numpy.ndarray&lt;/code&gt;, &lt;code&gt;ArrayLike&lt;/code&gt; does not allow operations with arbitrary, unrecognized types. This ensures that interactions with ArrayLike preserve a well-defined casting hierarchy.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;numpy.ndarray&lt;/code&gt; , &lt;code&gt;ArrayLike&lt;/code&gt; no permite operaciones con tipos arbitrarios no reconocidos. Esto asegura que las interacciones con ArrayLike conserven una jerarqu&amp;iacute;a de conversi&amp;oacute;n bien definida.</target>
        </trans-unit>
        <trans-unit id="43c59c07e98c965f271cd8992d38ce79563e80fe" translate="yes" xml:space="preserve">
          <source>Note that we can assign each color channel to a separate matrix using the slice syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448e8d337bf988d0c2429a16c43ede94f241e3d0" translate="yes" xml:space="preserve">
          <source>Note that we had to use only the first &lt;code&gt;k&lt;/code&gt; rows of &lt;code&gt;Vt&lt;/code&gt;, since all other rows would be multiplied by the zeros corresponding to the singular values we eliminated from this approximation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6653eb59198778eef2da729298a76ec147105c9f" translate="yes" xml:space="preserve">
          <source>Note that we picked datetimes that cross a DST boundary. Passing in a &lt;code&gt;pytz&lt;/code&gt; timezone object will print the appropriate offset</source>
          <target state="translated">Tenga en cuenta que elegimos fechas y horas que cruzan un l&amp;iacute;mite de horario de verano. Pasar un objeto de zona horaria de &lt;code&gt;pytz&lt;/code&gt; imprimir&amp;aacute; el desplazamiento apropiado</target>
        </trans-unit>
        <trans-unit id="ff6a8871cdaa44abafcf71b9b33d5e54dbc5be42" translate="yes" xml:space="preserve">
          <source>Note that we support &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout typemaps in 1D, but not 2D or 3D. This is because of a quirk with the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemap syntax and cannot be avoided. Note that for these types of 1D typemaps, the Python function will take a single argument representing &lt;code&gt;DIM1&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout typemaps en 1D, pero no en 2D o 3D. Esto se debe a una peculiaridad de la sintaxis del mapa de &lt;a href=&quot;http://www.swig.org&quot;&gt;tipos&lt;/a&gt; SWIG y no se puede evitar. Tenga en cuenta que para estos tipos de mapas de tipos 1D, la funci&amp;oacute;n Python tomar&amp;aacute; un solo argumento que represente &lt;code&gt;DIM1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11034ab53fb8599a1310cf4207146288e154fc02" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;a == 1&lt;/code&gt;, the normalization factor &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; goes over to &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; as it should.</source>
          <target state="translated">Tenga en cuenta que cuando &lt;code&gt;a == 1&lt;/code&gt; , el factor de normalizaci&amp;oacute;n &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; pasa a &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; como deber&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="9bc6e51338747705400e85f794a015c6a2357856" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;out&lt;/code&gt; is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3037f71e1ac80b9e7b6e511f234ab46281a3503" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;out&lt;/code&gt; parameter is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98530ea6c0be02d22c92fb9a99dc0d9aff053c64" translate="yes" xml:space="preserve">
          <source>Note that when type-casting is required and there is possible loss of information (e.g. when type-casting float to integer or complex to float), F2PY does not raise any exception. In complex to real type-casting only the real part of a complex number is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23123ffca4ff0e0a4a42f0653d7d9ea09cd17620" translate="yes" xml:space="preserve">
          <source>Note that whenever &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used, &lt;code&gt;optional&lt;/code&gt; attribute is set automatically by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0fb9212f997bf3174d26345ac37f18f11183de" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;code&gt;np.ix_&lt;/code&gt; call, only the diagonal elements would be selected, as was used in the previous example. This difference is the most important thing to remember about indexing with multiple advanced indexes.</source>
          <target state="translated">Tenga en cuenta que sin la llamada &lt;code&gt;np.ix_&lt;/code&gt; , solo se seleccionar&amp;iacute;an los elementos diagonales, como se us&amp;oacute; en el ejemplo anterior. Esta diferencia es lo m&amp;aacute;s importante que debe recordar acerca de la indexaci&amp;oacute;n con m&amp;uacute;ltiples &amp;iacute;ndices avanzados.</target>
        </trans-unit>
        <trans-unit id="b5412b8a5c5e8aa3576931f3f122d134b272fe13" translate="yes" xml:space="preserve">
          <source>Note that you can eg. install NumPy to a temporary location and set the PYTHONPATH environment variable appropriately. Alternatively, if using Python virtual environments (via e.g. &lt;code&gt;conda&lt;/code&gt;, &lt;code&gt;virtualenv&lt;/code&gt; or the &lt;code&gt;venv&lt;/code&gt; module), installing numpy into a new virtual environment is recommended. All of the necessary dependencies for building the NumPy docs can be installed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3edd40f42578284bf324094d774023e21eda09" translate="yes" xml:space="preserve">
          <source>Note that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que obtiene el resultado conjugado complejo invertido en el tiempo cuando las dos secuencias de entrada cambian de lugar, es decir, &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dc4f36c08ee65f253c387ba6c97a8e2ba7041327" translate="yes" xml:space="preserve">
          <source>Note that, above, we use the &lt;em&gt;Python&lt;/em&gt; float object as a dtype. NumPy knows that &lt;code&gt;int&lt;/code&gt; refers to &lt;code&gt;np.int_&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; means &lt;code&gt;np.bool_&lt;/code&gt;, that &lt;code&gt;float&lt;/code&gt; is &lt;code&gt;np.float_&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt; is &lt;code&gt;np.complex_&lt;/code&gt;. The other data-types do not have Python equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5c8fb85c6ca6f109e49af951ef9e99c064bb30" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Tenga en cuenta que, para n&amp;uacute;meros complejos, &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; toma el valor absoluto antes de elevar al cuadrado, por lo que el resultado siempre es real y no negativo.</target>
        </trans-unit>
        <trans-unit id="67ff0ed45eb77e75fcc2a8d19c65a90ea73589bb" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Tenga en cuenta que, para n&amp;uacute;meros complejos, &lt;a href=&quot;numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; toma el valor absoluto antes de elevar al cuadrado, por lo que el resultado siempre es real y no negativo.</target>
        </trans-unit>
        <trans-unit id="70d9a8c143ac6b7cff84e338754a98ad2f6ecebc" translate="yes" xml:space="preserve">
          <source>Note that, in linear algebra, the dimension of a vector refers to the number of entries in an array. In NumPy, it instead defines the number of axes. For example, a 1D array is a vector such as &lt;code&gt;[1, 2, 3]&lt;/code&gt;, a 2D array is a matrix, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e93cf7b4b44a5b77a394d19e4276d3eaadfbbd" translate="yes" xml:space="preserve">
          <source>Note that, in the old API that was deprecated in version 1.7, this function had the return type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que, en la antigua API que qued&amp;oacute; obsoleta en la versi&amp;oacute;n 1.7, esta funci&amp;oacute;n ten&amp;iacute;a el tipo de retorno &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7589de457b1bf436d7dda2480bd2ade65f60a09f" translate="yes" xml:space="preserve">
          <source>Note that, since NaN is unsortable, &lt;code&gt;xp&lt;/code&gt; also cannot contain NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60913e9a1e7e3a8383e344378c5f7011cb280cd" translate="yes" xml:space="preserve">
          <source>Note that, when we modify x, y changes, but not z:</source>
          <target state="translated">Note que,cuando modificamos x,y cambia,pero no z:</target>
        </trans-unit>
        <trans-unit id="a663ed58f0a095b16634564fa9a49f9e01516158" translate="yes" xml:space="preserve">
          <source>Note the array &lt;code&gt;dtype&lt;/code&gt; above of &lt;code&gt;&amp;gt;i2&lt;/code&gt;. The &lt;code&gt;&amp;gt;&lt;/code&gt; means &amp;lsquo;big-endian&amp;rsquo; (&lt;code&gt;&amp;lt;&lt;/code&gt; is little-endian) and &lt;code&gt;i2&lt;/code&gt; means &amp;lsquo;signed 2-byte integer&amp;rsquo;. For example, if our data represented a single unsigned 4-byte little-endian integer, the dtype string would be &lt;code&gt;&amp;lt;u4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf42915649d8c90d2411a01638407672b7fa26fe" translate="yes" xml:space="preserve">
          <source>Note the array has not changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45db9188e4e378f18f56f3c51bcc9db7db73d40" translate="yes" xml:space="preserve">
          <source>Note the normalization factor of &lt;code&gt;pi&lt;/code&gt; used in the definition. This is the most commonly used definition in signal processing. Use &lt;code&gt;sinc(x / np.pi)&lt;/code&gt; to obtain the unnormalized sinc function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7868473a32c7a3c40bb3a312d03eac57c7a37527" translate="yes" xml:space="preserve">
          <source>Note the order of the parameters. &lt;a href=&quot;#numpy.arctan2&quot;&gt;&lt;code&gt;arctan2&lt;/code&gt;&lt;/a&gt; is defined also when &lt;code&gt;x2&lt;/code&gt; = 0 and at several other special points, obtaining values in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta el orden de los par&amp;aacute;metros. &lt;a href=&quot;#numpy.arctan2&quot;&gt; &lt;code&gt;arctan2&lt;/code&gt; &lt;/a&gt; se define tambi&amp;eacute;n cuando &lt;code&gt;x2&lt;/code&gt; = 0 y en varios otros puntos especiales, obteniendo valores en el rango &lt;code&gt;[-pi, pi]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3999859e7edf0b6850997e2b685c81e41f6bf30b" translate="yes" xml:space="preserve">
          <source>Note the unusual interpretation of sample when an array_like:</source>
          <target state="translated">Obsérvese la inusual interpretación de la muestra cuando se trata de un array_like:</target>
        </trans-unit>
        <trans-unit id="4959b44a65b76595dc01fa81f812b74fb283e1a6" translate="yes" xml:space="preserve">
          <source>Note to those used to IDL or Fortran memory order as it relates to indexing. NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111feaa1cd8151a1eb25cfbf746ea648c6673cdc" translate="yes" xml:space="preserve">
          <source>Note: Prior to NumPy 1.10.0, less strict checks were in place: missing core dimensions were created by prepending 1&amp;rsquo;s to the shape as necessary, core dimensions with the same label were broadcast together, and undetermined dimensions were created with size 1.</source>
          <target state="translated">Nota: Antes de NumPy 1.10.0, exist&amp;iacute;an controles menos estrictos: las dimensiones de n&amp;uacute;cleo faltantes se creaban anteponiendo 1 a la forma seg&amp;uacute;n fuera necesario, las dimensiones de n&amp;uacute;cleo con la misma etiqueta se difund&amp;iacute;an juntas y las dimensiones indeterminadas se creaban con el tama&amp;ntilde;o 1.</target>
        </trans-unit>
        <trans-unit id="d21079fa664fe20f0bcb604959e5d77d12a5f0cb" translate="yes" xml:space="preserve">
          <source>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays.</source>
          <target state="translated">Nota:Esta función devuelve un arreglo con al menos una dimensión (1-d)por lo que no conservará los arreglos 0-d.</target>
        </trans-unit>
        <trans-unit id="4a1a649c093516be216b047d4a6e07a8bfed16fc" translate="yes" xml:space="preserve">
          <source>Note: cannot use equality to test NaNs. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="046d816b2cced12f2b8341cea27cc367cd961583" translate="yes" xml:space="preserve">
          <source>Notes about the implementation algorithm (if needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a08e04c0814f8e83ad56517e19ff3c0721fcd94" translate="yes" xml:space="preserve">
          <source>Notes and Warnings : If there are points in the docstring that deserve special emphasis, the reST directives for a note or warning can be used in the vicinity of the context of the warning (inside a section). Syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f57a8f12c91535f8b3bf8808e86d3137e06887d9" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;a&lt;/code&gt; is not a masked array.</source>
          <target state="translated">No sucede nada si &lt;code&gt;a&lt;/code&gt; no es una matriz enmascarada.</target>
        </trans-unit>
        <trans-unit id="a10912bd64eec5f116a9c3fe1369faded07c9f4b" translate="yes" xml:space="preserve">
          <source>Nothing returned by this function.</source>
          <target state="translated">Nada devuelto por esta función.</target>
        </trans-unit>
        <trans-unit id="15640e8dfd2dd046a0fb763219826f0e011ee43c" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184b0a59161cac7480934a6869880704e9ffc1c5" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="translated">Observe c&amp;oacute;mo el elemento final de la salida &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; es el complejo conjugado del segundo elemento, para la entrada real. Para &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; , esta simetr&amp;iacute;a se aprovecha para calcular solo los t&amp;eacute;rminos de frecuencia no negativos.</target>
        </trans-unit>
        <trans-unit id="9d24afb4770f955e79718f663c68d81c2708b5a7" translate="yes" xml:space="preserve">
          <source>Notice how the last term in the input to the ordinary &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the complex conjugate of the second term, and the output has zero imaginary part everywhere. When calling &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, the negative frequencies are not specified, and the output array is purely real.</source>
          <target state="translated">Observe c&amp;oacute;mo el &amp;uacute;ltimo t&amp;eacute;rmino en la entrada del &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; ordinario es el conjugado complejo del segundo t&amp;eacute;rmino, y la salida tiene una parte imaginaria cero en todas partes. Al llamar a &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; , las frecuencias negativas no se especifican y la matriz de salida es puramente real.</target>
        </trans-unit>
        <trans-unit id="ed100c4959db20fe84fd87eecf37518e6739a62d" translate="yes" xml:space="preserve">
          <source>Notice that Cython is an extension-module generator only. Unlike f2py, it includes no automatic facility for compiling and linking the extension module (which must be done in the usual fashion). It does provide a modified distutils class called &lt;code&gt;build_ext&lt;/code&gt; which lets you build an extension module from a &lt;code&gt;.pyx&lt;/code&gt; source. Thus, you could write in a &lt;code&gt;setup.py&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb564d7e3f343c55b0fae22523656706209711d" translate="yes" xml:space="preserve">
          <source>Notice that the above 3 flags are defined so that a new, well- behaved array has these flags defined as true.</source>
          <target state="translated">Fíjense que las 3 banderas anteriores están definidas de manera que un nuevo conjunto bien comportado tiene estas banderas definidas como verdaderas.</target>
        </trans-unit>
        <trans-unit id="933e026efdbeaa2316ba75443c7fec80dcb22b12" translate="yes" xml:space="preserve">
          <source>Notice that the full PyArrayObject is used as the first entry in order to ensure that the binary layout of instances of the new type is identical to the PyArrayObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847535dd495885c3e2ed82b62e1abcb626ece607" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">Observe que el valor inicial se usa como uno de los elementos para los que se determina el m&amp;aacute;ximo, a diferencia del argumento predeterminado de la funci&amp;oacute;n max de Python, que solo se usa para iterables vac&amp;iacute;os.</target>
        </trans-unit>
        <trans-unit id="98ab17cc2cf9317019aeddb2bbabfef19cd3a629" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">Observe que el valor inicial se usa como uno de los elementos para los que se determina el m&amp;iacute;nimo, a diferencia del argumento predeterminado de la funci&amp;oacute;n max de Python, que solo se usa para iterables vac&amp;iacute;os.</target>
        </trans-unit>
        <trans-unit id="7a3bf5045be1e646ff0b1cf93fe99f156e23026b" translate="yes" xml:space="preserve">
          <source>Notice that the resulting wrapper to &lt;code&gt;FIB&lt;/code&gt; is as &amp;ldquo;smart&amp;rdquo; as in previous case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492b4a295e5558fecc78ff637653ffa8b09ca97f" translate="yes" xml:space="preserve">
          <source>Notice that the return type is a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fad7b0d0de8433821f8ae84856c18eccd090df" translate="yes" xml:space="preserve">
          <source>Notice that the second &lt;code&gt;usercode&lt;/code&gt; statement must be defined inside an &lt;code&gt;interface&lt;/code&gt; block and where the module dictionary is available through the variable &lt;code&gt;d&lt;/code&gt; (see &lt;code&gt;f2py var.pyf&lt;/code&gt;-generated &lt;code&gt;varmodule.c&lt;/code&gt; for additional details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99552cfe5ebf21e89509d47400467670883a7d" translate="yes" xml:space="preserve">
          <source>Notice that this isn&amp;rsquo;t the same as Python&amp;rsquo;s &lt;code&gt;default&lt;/code&gt; argument.</source>
          <target state="translated">Tenga en cuenta que este no es el mismo que el argumento &lt;code&gt;default&lt;/code&gt; de Python .</target>
        </trans-unit>
        <trans-unit id="86ca463fe236705953b4cb323c8e44dbe110c67f" translate="yes" xml:space="preserve">
          <source>Notice the automatic conversion to the correct format that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75917695664ab58d7b5d23aff9664353427c773e" translate="yes" xml:space="preserve">
          <source>Now all those people can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c558c7187dbb9215bbd627b6f1b25246d5a8c6fd" translate="yes" xml:space="preserve">
          <source>Now assume you attached &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; to the source tree, then the infrastructure should generate a temporary config header called &lt;strong&gt;hello.dispatch.h&lt;/strong&gt; that can be reached by any source in the source tree, and it should contain the following code :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bfcb10a3d92ea0cb076fb11e889a3f7696c2f5" translate="yes" xml:space="preserve">
          <source>Now editing a Python source file in NumPy allows you to immediately test and use your changes (in &lt;code&gt;.py&lt;/code&gt; files), by simply restarting the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1d525547aac9ec4fc5c41b72c69bb1f2c8bfa" translate="yes" xml:space="preserve">
          <source>Now go to your fork and make a pull request for the branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59497d295295e7471278d2cef4e18af42ce6655b" translate="yes" xml:space="preserve">
          <source>Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1562b378f268443ad7a3ad7b80f355a383c82822" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s tackle &lt;code&gt;__array_function__&lt;/code&gt;. We&amp;rsquo;ll create dict that maps numpy functions to our custom variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4854dca388c79f7bb12e14a8a161b7a492c001a" translate="yes" xml:space="preserve">
          <source>Now multiply a diagonal matrix by &lt;code&gt;Q&lt;/code&gt; on one side and by &lt;code&gt;Q.T&lt;/code&gt; on the other:</source>
          <target state="translated">Ahora multiplique una matriz diagonal por &lt;code&gt;Q&lt;/code&gt; en un lado y por &lt;code&gt;Q.T&lt;/code&gt; en el otro:</target>
        </trans-unit>
        <trans-unit id="d9aee1cf03a85f2c9234d34f54fa504a0ad159f3" translate="yes" xml:space="preserve">
          <source>Now our custom array type passes through numpy functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653b19d1d4883b62177051122cc7aeebf0172920" translate="yes" xml:space="preserve">
          <source>Now returns an empty list instead of None for a fully masked array</source>
          <target state="translated">Ahora devuelve una lista vacía en lugar de ninguna para un conjunto totalmente enmascarado</target>
        </trans-unit>
        <trans-unit id="ba8aa04151c2a1b06d4ae8fedf1218b84591b899" translate="yes" xml:space="preserve">
          <source>Now that our data has been masked, let&amp;rsquo;s try summing up all the cases in China:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec58b2146d74f6a1fb2a7b312c2b04a59b639bdc" translate="yes" xml:space="preserve">
          <source>Now the array &lt;em&gt;has&lt;/em&gt; changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5721d6e90bb96b54d081e10fa69a0fa60aa41ba" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded before proceeding. There should currently be 21 of them at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy/files&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy/files&lt;/a&gt;, 3 for Mac, 6 for Windows, and 12 for Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699a899259937ad1e936681606eb842fe76f5cf4" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded to the staging repository before proceeding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a3bd4e9414b13e38275e5df8769440d431b61f" translate="yes" xml:space="preserve">
          <source>Now we are ready to apply the SVD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747aa74212ee1540da17718b2993f3a2e84b8796" translate="yes" xml:space="preserve">
          <source>Now we can correctly sum entries for mainland China:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f39ae5d13c5ad14506d67df0c86ac586848a064" translate="yes" xml:space="preserve">
          <source>Now we can iterate over &lt;code&gt;a_itor&lt;/code&gt;, and it will return arrays of size two. Since &lt;code&gt;buf_size&lt;/code&gt; was smaller than any dimension, the first dimension will be iterated over first:</source>
          <target state="translated">Ahora podemos iterar sobre &lt;code&gt;a_itor&lt;/code&gt; , y devolver&amp;aacute; matrices de tama&amp;ntilde;o dos. Dado que &lt;code&gt;buf_size&lt;/code&gt; era m&amp;aacute;s peque&amp;ntilde;o que cualquier dimensi&amp;oacute;n, la primera dimensi&amp;oacute;n se iterar&amp;aacute; primero:</target>
        </trans-unit>
        <trans-unit id="bf7432fe9f7d1de2712d47dd480396ec30fe9d54" translate="yes" xml:space="preserve">
          <source>Now we create an array &lt;code&gt;b1&lt;/code&gt; by slicing &lt;code&gt;a&lt;/code&gt; and modify the first element of &lt;code&gt;b1&lt;/code&gt;. This will modify the corresponding element in &lt;code&gt;a&lt;/code&gt; as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76ea020d2e734b4cfb0d824a7cb637d663128ae" translate="yes" xml:space="preserve">
          <source>Now we want to do the same kind of operation, but to all three colors. Our first instinct might be to repeat the same operation we did above to each color matrix individually. However, NumPy&amp;rsquo;s &lt;code&gt;broadcasting&lt;/code&gt; takes care of this for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6dd4a7bf7c5c8f068a6e558d5c8ec36b5c692a" translate="yes" xml:space="preserve">
          <source>Now we write implementations of numpy functions for &lt;code&gt;DiagonalArray&lt;/code&gt;. For completeness, to support the usage &lt;code&gt;arr.sum()&lt;/code&gt; add a method &lt;code&gt;sum&lt;/code&gt; that calls &lt;code&gt;numpy.sum(self)&lt;/code&gt;, and the same for &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc172f812b48628145c33844eeb0c5e41365a9a" translate="yes" xml:space="preserve">
          <source>Now you are ready to generate the docs, so write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae5aab236f57788a41324d9fac04d9f996796fb" translate="yes" xml:space="preserve">
          <source>Now you can do the following to test your module:</source>
          <target state="translated">Ahora puede hacer lo siguiente para probar su módulo:</target>
        </trans-unit>
        <trans-unit id="93e01758207ef7eac9898579c0a0ad53ac2cbd99" translate="yes" xml:space="preserve">
          <source>Now you can make the release commit and tag. We recommend you don&amp;rsquo;t push the commit or tag immediately, just in case you need to do more cleanup. We prefer to defer the push of the tag until we&amp;rsquo;re confident this is the exact form of the released code (see: &lt;a href=&quot;#push-tag-and-commit&quot;&gt;Push the release tag and commit&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14145f90c1ed14c03e17b7327ce3f007834c2f" translate="yes" xml:space="preserve">
          <source>Now you need to apply the changes from master to this branch using &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html&quot;&gt;git cherry-pick&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da29f0210a502c721dd0dd5c83f6b4fa9f50c915" translate="yes" xml:space="preserve">
          <source>Now you want to connect to the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repository, so you can merge in changes from trunk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99261818f6547b5ed54374d3a2426ea44c25412d" translate="yes" xml:space="preserve">
          <source>Now,</source>
          <target state="translated">Now,</target>
        </trans-unit>
        <trans-unit id="54e3f4943855839d7ff1038b70ea21091b66f2f7" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;china_mask&lt;/code&gt; is an array of boolean values (&lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;); we can check that the indices are what we wanted with the &lt;a href=&quot;../reference/generated/numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;ma.nonzero&lt;/code&gt;&lt;/a&gt; method for masked arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a849066ed1f230f65474fee40b0e94a7d98faa2" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;git remote -v&lt;/code&gt; will show two remote repositories named:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e590b12ac969204974436ab86b73a66b484b9" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;h&lt;/code&gt; is called a &lt;code&gt;House&lt;/code&gt; instance. An instance is therefore a specific realisation of a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9c91fe6808bc153fedc3a3be54f274b18ccbd" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img&lt;/code&gt; is a NumPy array, as we can see when using the &lt;code&gt;type&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ef6adb474c75b77cfec6493b6e37127e46dd0c" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img_gray&lt;/code&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5e3ab134c32e63476e019b6cc1db7108c6756a" translate="yes" xml:space="preserve">
          <source>Now, applying the &lt;a href=&quot;../reference/generated/numpy.linalg.svd#numpy.linalg.svd&quot;&gt;&lt;code&gt;linalg.svd&lt;/code&gt;&lt;/a&gt; function to this matrix, we obtain the following decomposition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4103944902505e88c56a448e8658e10eed8eb1b4" translate="yes" xml:space="preserve">
          <source>Now, do one experiment throwing the dice 10 time, and 10 times again, and another throwing the dice 20 times, and 20 times again:</source>
          <target state="translated">Ahora,haz un experimento lanzando los dados 10 veces,y 10 veces de nuevo,y otro lanzando los dados 20 veces,y 20 veces de nuevo:</target>
        </trans-unit>
        <trans-unit id="c02651c46a41ca9f07ac3b1090a827bd1aa0997e" translate="yes" xml:space="preserve">
          <source>Now, if we want to create a very simple approximation for this data, we should take into account the valid entries around the invalid ones. So first let&amp;rsquo;s select the dates for which the data is valid. Note that we can use the mask from the &lt;code&gt;china_total&lt;/code&gt; masked array to index the dates array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ea454c7baf7564ea6fcb77c917ce2269209f53" translate="yes" xml:space="preserve">
          <source>Now, if we wish to rebuild the full SVD (with no approximation), we can do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79503e4a7bcf0bb6045b13fb5038f72cea2083ab" translate="yes" xml:space="preserve">
          <source>Now, the function can be called in a much more robust way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0435f8dfb75dd633a8592e953b3a61869c66ed" translate="yes" xml:space="preserve">
          <source>Now, throw the dice 20 times, and 20 times again:</source>
          <target state="translated">Ahora,tira los dados 20 veces,y 20 veces de nuevo:</target>
        </trans-unit>
        <trans-unit id="e886cde483c798665f26429d663d928161ab6acf" translate="yes" xml:space="preserve">
          <source>Now, to build our approximation, we first need to make sure that our singular values are ready for multiplication, so we build our &lt;code&gt;Sigma&lt;/code&gt; matrix similarly to what we did before. The &lt;code&gt;Sigma&lt;/code&gt; array must have dimensions &lt;code&gt;(3, 768, 1024)&lt;/code&gt;. In order to add the singular values to the diagonal of &lt;code&gt;Sigma&lt;/code&gt;, we will use the &lt;code&gt;fill_diagonal&lt;/code&gt; function from NumPy, using each of the 3 rows in &lt;code&gt;s&lt;/code&gt; as the diagonal for each of the 3 matrices in &lt;code&gt;Sigma&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565f463048564fa2ff4bfcbc1dc8859dde3aeacc" translate="yes" xml:space="preserve">
          <source>Now, to do the approximation, we must choose only the first &lt;code&gt;k&lt;/code&gt; singular values for each color channel. This can be done using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0393525e01988d9f9cb1a6b35b57bda883e2e" translate="yes" xml:space="preserve">
          <source>Now, we create indices to manipulate a 3-D array:</source>
          <target state="translated">Ahora,creamos índices para manipular una matriz 3-D:</target>
        </trans-unit>
        <trans-unit id="c7902891716f837cf46001e7e450e13862b8420f" translate="yes" xml:space="preserve">
          <source>Now, we want to check if the reconstructed &lt;code&gt;U @ Sigma @ Vt&lt;/code&gt; is close to the original &lt;code&gt;img_gray&lt;/code&gt; matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f06f8937e93eb4f141bfb2a705595fcdf67626f" translate="yes" xml:space="preserve">
          <source>Now, when we define a function, we can &amp;ldquo;decorate&amp;rdquo; it using &lt;code&gt;log&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7b2e6b23e5632ad7c5158bf566b73a38ffebf" translate="yes" xml:space="preserve">
          <source>Now, whenever you want to switch to the virtual environment, you can use the command &lt;code&gt;source numpy-dev/bin/activate&lt;/code&gt;, and &lt;code&gt;deactivate&lt;/code&gt; to exit from the virtual environment and back to your previous shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198b66dda9dfc0b0d1d736fde28782e16d5483f5" translate="yes" xml:space="preserve">
          <source>Now, you can go ahead and repeat this experiment with other values of &lt;code&gt;k&lt;/code&gt;, and each of your experiments should give you a slightly better (or worse) image depending on the value you choose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd61014c9008087889fd725668b3c8d4970463d" translate="yes" xml:space="preserve">
          <source>Now, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61d4e29999f717e20a2ffa02fda03db9cc09177" translate="yes" xml:space="preserve">
          <source>Now:</source>
          <target state="translated">Now:</target>
        </trans-unit>
        <trans-unit id="8b7fcaae0aa22776c49d066644c2b1975dfe6da1" translate="yes" xml:space="preserve">
          <source>NpyAuxData (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a30eac154cabdf7a90e0db5f0c2478a5065e89" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc</source>
          <target state="translated">NpyAuxData_CloneFunc</target>
        </trans-unit>
        <trans-unit id="34e8b7730172c8e3d3adc73c058819a6f92f117f" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4fef0ec03464a7b11bd65b370680102da32d76" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc</source>
          <target state="translated">NpyAuxData_FreeFunc</target>
        </trans-unit>
        <trans-unit id="97e892e902cfe2bd9ee7b43a2c987c5ba8273d80" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3a83bac5637b7f866d954fa04d5054091c36cc" translate="yes" xml:space="preserve">
          <source>NpyIter</source>
          <target state="translated">NpyIter</target>
        </trans-unit>
        <trans-unit id="82a0508669bbb7771cac0c8d3e2c866a68070845" translate="yes" xml:space="preserve">
          <source>NpyIter (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c5db212050a32c003c23a2e475d5c5ce78e2df" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af20c5dee7afb2fdfe083ea49a8e985dcebda12" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew()</source>
          <target state="translated">NpyIter_AdvancedNew()</target>
        </trans-unit>
        <trans-unit id="4b68aef05b915f8c4d85c85d6e5e698604e22d5b" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b997b8b2b511720cd1069c024299823f83302c9e" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy()</source>
          <target state="translated">NpyIter_Copy()</target>
        </trans-unit>
        <trans-unit id="dead001979a949af7bc216d40e317c11b1627b50" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb78c3f62b576c1af874d751640db8eff8c9979" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides()</source>
          <target state="translated">NpyIter_CreateCompatibleStrides()</target>
        </trans-unit>
        <trans-unit id="bd5f39811c4a438e4611fe7324c733dae8e18e94" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad45ab8ae95fe7da10aaac502dcfd57dbf572fa" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate()</source>
          <target state="translated">NpyIter_Deallocate()</target>
        </trans-unit>
        <trans-unit id="9e58f50382b305a7c644ed30e9dbf73ab673b658" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39e8d7265758ca02d07e1e363c5debc0123f813" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop()</source>
          <target state="translated">NpyIter_EnableExternalLoop()</target>
        </trans-unit>
        <trans-unit id="329ae7e5f8f4f861595a2f3783d09679b3a68e75" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2c139e38956ebdf5ce855ccf3149ea641f8b05" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray()</source>
          <target state="translated">NpyIter_GetAxisStrideArray()</target>
        </trans-unit>
        <trans-unit id="11e9224b826aa03f20a5575963d1a61c21bde7ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c71d1d0e6fd6d70024c7dd931246be434c73502" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize()</source>
          <target state="translated">NpyIter_GetBufferSize()</target>
        </trans-unit>
        <trans-unit id="efd6b812e98d492f8edfd24e4ba12b4a6b2f06ff" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a85869fc34454e6204a9b83263efd25b3b19a8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray()</source>
          <target state="translated">NpyIter_GetDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="4818f80260586e06d259cc413bb89e872d11d852" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cedbb3cbc591b2ae980b3bc6c8c39f71d0c16b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray()</source>
          <target state="translated">NpyIter_GetDescrArray()</target>
        </trans-unit>
        <trans-unit id="b2e4a49c346fdbeb713aed872c544759f393dc2a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d029059dda4dad1438f1bd80a75d454f99834d6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex()</source>
          <target state="translated">NpyIter_GetGetMultiIndex()</target>
        </trans-unit>
        <trans-unit id="0b61a40f2f042effaff1a816288916e29182e78d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66611101d6de9d68cce0bd7a8cf2f113e7678aaf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr()</source>
          <target state="translated">NpyIter_GetIndexPtr()</target>
        </trans-unit>
        <trans-unit id="709bac1bb4a069b2df14e08fa3d634e04e1b48d8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca4420e7f21331a3412d9afdd62effd1a37e0d5" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray()</source>
          <target state="translated">NpyIter_GetInitialDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="ce42d7c0034eff3c7307f8b08adc8d1d3d5232be" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2852a223ce3a2b4862d0d75cd1f8c82ebb096d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray()</source>
          <target state="translated">NpyIter_GetInnerFixedStrideArray()</target>
        </trans-unit>
        <trans-unit id="320bab14d48a2be5366699d949e501506d8b52ef" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28fb690d09a18949fd479bfd69414cd7025ffd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr()</source>
          <target state="translated">NpyIter_GetInnerLoopSizePtr()</target>
        </trans-unit>
        <trans-unit id="2741ed5c537a092cf9f55caeb0d6909844811cae" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459e9e1f94992501dfb6860694a283afdd8b7cd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray()</source>
          <target state="translated">NpyIter_GetInnerStrideArray()</target>
        </trans-unit>
        <trans-unit id="916bfb4b9ccc85a495812e9b0ef709804cf83e7b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b51d4d2bf86336410a4e52bb5d565c6529f946c" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex()</source>
          <target state="translated">NpyIter_GetIterIndex()</target>
        </trans-unit>
        <trans-unit id="4f98f4187c0881fc46fb9149b68116d68e20d9ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f9917bbb45a59125169b7d51e52942d1ae839d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange()</source>
          <target state="translated">NpyIter_GetIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="6ac9c145de13db3cda86b9108539ac806761dc14" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterNext (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb93380537687af5addf300e0da2d51122534b79" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b47088c34a7caf54317e4c555ce5eeee306bf9" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize()</source>
          <target state="translated">NpyIter_GetIterSize()</target>
        </trans-unit>
        <trans-unit id="971f351012eac4ac6bf123d19280ff6e83e62e85" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37332e2ac83c27d275077f93c1a5465ad79ccdf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView()</source>
          <target state="translated">NpyIter_GetIterView()</target>
        </trans-unit>
        <trans-unit id="260ac3818c138694453f685279c2631308cb9db4" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc</source>
          <target state="translated">NpyIter_GetMultiIndexFunc</target>
        </trans-unit>
        <trans-unit id="268c5739b883afa9c178c9d12b961525ac033a81" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fef6dc6e8adca628a81ab1f9f58214b8989570" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9bba8a229eb928a91402e6ca604c155e3edd64" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim()</source>
          <target state="translated">NpyIter_GetNDim()</target>
        </trans-unit>
        <trans-unit id="68db817bd7a88e9a2db3bf2cfbe83efefe3a7b98" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50db8bb821c577506b545754506219ead592b053" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp()</source>
          <target state="translated">NpyIter_GetNOp()</target>
        </trans-unit>
        <trans-unit id="4be079e1aeeda5c22d683667022b51cf015a2c21" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af90f6f35483cf45c99c7df56d9615992da54dd" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray()</source>
          <target state="translated">NpyIter_GetOperandArray()</target>
        </trans-unit>
        <trans-unit id="4b047889d28074e88029d8a1e07fab68c9e1b2a6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30bb289b8e86739e36ea60928a2ed64312d2fec" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags()</source>
          <target state="translated">NpyIter_GetReadFlags()</target>
        </trans-unit>
        <trans-unit id="72287467289d08139728b9bd588cb1fba0d298e1" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3fe550cadce766e0ebaa92151a7d483873ef4a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape()</source>
          <target state="translated">NpyIter_GetShape()</target>
        </trans-unit>
        <trans-unit id="16f7d0a2122c563a659425f4ce571bbbba298beb" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd9a2ff8ce509672e11ffa76fdbabff9b0c7181" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags()</source>
          <target state="translated">NpyIter_GetWriteFlags()</target>
        </trans-unit>
        <trans-unit id="6668661c9c3f5c1e327bd4f2c42ad82f1605c898" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3120c654191cddf0b70bae47a341b3c86669393" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex()</source>
          <target state="translated">NpyIter_GotoIndex()</target>
        </trans-unit>
        <trans-unit id="32885a42e6fb8b031f26299bec0d11656e3b1eaa" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1654c5ff8fe66cc2194f6b61e83a8e796fe628" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex()</source>
          <target state="translated">NpyIter_GotoIterIndex()</target>
        </trans-unit>
        <trans-unit id="e135f8536fc5fd83a52cd6bbd2bce201e704280c" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d041142525a40cf564e2e7e029c65f6509b0a323" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex()</source>
          <target state="translated">NpyIter_GotoMultiIndex()</target>
        </trans-unit>
        <trans-unit id="1d5b6a575bb6f461dea653952d455489a8ea3d4a" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0864809f09d890d29d15054f92994f033a3f43" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc()</source>
          <target state="translated">NpyIter_HasDelayedBufAlloc()</target>
        </trans-unit>
        <trans-unit id="8d6631cc570fdeba0443b204635f61ead9da9cc0" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c750ba9fcfc1c225387cebcaf21e29ccbc7ab1" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop()</source>
          <target state="translated">NpyIter_HasExternalLoop()</target>
        </trans-unit>
        <trans-unit id="01ff965a16adc18e1fe09a249c239ef993e1e4cd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1495f8b014a812b7d5168151357e69d6e80056fa" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex()</source>
          <target state="translated">NpyIter_HasIndex()</target>
        </trans-unit>
        <trans-unit id="524724e0000bf6ba5bb9fefb1e4de88d3ce724e6" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca93af25bd286e2ffe55a87884c419afcd79bfcd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex()</source>
          <target state="translated">NpyIter_HasMultiIndex()</target>
        </trans-unit>
        <trans-unit id="b4e6deeafbbcf71e1a3f6bc2ac6366e5bd6c1b90" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476b949116e329f3c582aec5e76ce2e141633429" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered()</source>
          <target state="translated">NpyIter_IsBuffered()</target>
        </trans-unit>
        <trans-unit id="7304a6b23051f3e1aaa8d76004af420f8c287e9d" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9bbd57db7393e50498619291fc91b81f37f813" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit()</source>
          <target state="translated">NpyIter_IsFirstVisit()</target>
        </trans-unit>
        <trans-unit id="c71ca1fe83aa6474b8db38df750b5605a0ad4041" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0a2dba542604a7f3103127f1353c17a14acca2" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner()</source>
          <target state="translated">NpyIter_IsGrowInner()</target>
        </trans-unit>
        <trans-unit id="89d075475c669dbbf16b180a78f6a538e870d992" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc</source>
          <target state="translated">NpyIter_IterNextFunc</target>
        </trans-unit>
        <trans-unit id="ed5e1d448ea8ab46ae13594b26e85229c0f707c9" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7035ada01b636882b1ed7a431b18b92987e61d41" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959108f7b8a46be14788dcc6f2c656a40adf98c1" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew()</source>
          <target state="translated">NpyIter_MultiNew()</target>
        </trans-unit>
        <trans-unit id="ed094cc005976d6753311589b5d73c8f2c8e5e4f" translate="yes" xml:space="preserve">
          <source>NpyIter_New (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75df925e997f8a9b01f4fc38c2a52f970f929a3f" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fc99dccddcd13dec9ec17ac48fd49dd80c577" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex()</source>
          <target state="translated">NpyIter_RemoveMultiIndex()</target>
        </trans-unit>
        <trans-unit id="71dc9b48fe46c56aa709225d6c3eb5faead7860b" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a202ae5802958f468dad8c3e99a4bb5293a4dde8" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering()</source>
          <target state="translated">NpyIter_RequiresBuffering()</target>
        </trans-unit>
        <trans-unit id="082f6c0216a14a9d8e91d9d0eb80091b4c8e7c17" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c109fda112a4bfc0725b7a5833fd46c5602a3173" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset()</source>
          <target state="translated">NpyIter_Reset()</target>
        </trans-unit>
        <trans-unit id="70f5ee8ee0cc17ab92992d6cf6ee393f1e4520e7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1294ce3152cab7ceda644b504d717770b89e5c7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers()</source>
          <target state="translated">NpyIter_ResetBasePointers()</target>
        </trans-unit>
        <trans-unit id="14a37f97f8b6e5b56b6e83ff5eb67b7c25067c0c" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0acf29df8ba8a7bb014f05220b41b68cf91300" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange()</source>
          <target state="translated">NpyIter_ResetToIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="73626c9be0436b0d908d20d700956f6f6ce365b0" translate="yes" xml:space="preserve">
          <source>NpyIter_Type</source>
          <target state="translated">NpyIter_Type</target>
        </trans-unit>
        <trans-unit id="61c3b0ba34d7f397bd9f7eff4691cefedb4d278d" translate="yes" xml:space="preserve">
          <source>NpyIter_Type (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114cc06627557f63febd03e44f39195669b3db75" translate="yes" xml:space="preserve">
          <source>NumFOCUS Subcommittee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148fb3e1f0f3a0a5a25d7af63d9dc5d6da0841ea" translate="yes" xml:space="preserve">
          <source>NumPy</source>
          <target state="translated">NumPy</target>
        </trans-unit>
        <trans-unit id="a9d2a1b57f4f20938978d4d1c165136857a81954" translate="yes" xml:space="preserve">
          <source>NumPy &amp;mdash; it provides packages like:</source>
          <target state="translated">NumPy: proporciona paquetes como:</target>
        </trans-unit>
        <trans-unit id="766bc7e1c62d6bf447df2796935c0002e01046b4" translate="yes" xml:space="preserve">
          <source>NumPy (&lt;strong&gt;Numerical Python&lt;/strong&gt;) is an open source Python library that&amp;rsquo;s used in almost every field of science and engineering. It&amp;rsquo;s the universal standard for working with numerical data in Python, and it&amp;rsquo;s at the core of the scientific Python and PyData ecosystems. NumPy users include everyone from beginning coders to experienced researchers doing state-of-the-art scientific and industrial research and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib, scikit-learn, scikit-image and most other data science and scientific Python packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c505ea92418c9a5d535f7526fb8ff95e78ef0962" translate="yes" xml:space="preserve">
          <source>NumPy &lt;a href=&quot;#term-object-array&quot;&gt;object arrays&lt;/a&gt;, which contain references to Python objects, fill the role of heterogeneous arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7856c2dbbcca63221ed726f4aced6db4c3c7ff" translate="yes" xml:space="preserve">
          <source>NumPy API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de84e2593a0db73fdbbba3a6d668459795665a8b" translate="yes" xml:space="preserve">
          <source>NumPy API reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41afbb931d30bf51df3c5d024df1c8569665b6f" translate="yes" xml:space="preserve">
          <source>NumPy Array Scalars and SWIG</source>
          <target state="translated">NumPy Array Scalars y SWIG</target>
        </trans-unit>
        <trans-unit id="51ad55a9768d51db51dfc0fe1a4177bdd94eb2e8" translate="yes" xml:space="preserve">
          <source>NumPy C API</source>
          <target state="translated">NumPy C API</target>
        </trans-unit>
        <trans-unit id="3ee0e4047919b43a08c3c67ba0e3fc5e60d9cdaa" translate="yes" xml:space="preserve">
          <source>NumPy C Code Explanations</source>
          <target state="translated">Explicaciones del código NumPy C</target>
        </trans-unit>
        <trans-unit id="e338b3196336652494be7c1852eae3cde59bd702" translate="yes" xml:space="preserve">
          <source>NumPy C Style Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f9bc55e71edfa349e88dbc3b76c5d2e90cc3f" translate="yes" xml:space="preserve">
          <source>NumPy C style guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6796af8c026b629052c1b19daa9ac3e40093d9f" translate="yes" xml:space="preserve">
          <source>NumPy C-API</source>
          <target state="translated">NumPy C-API</target>
        </trans-unit>
        <trans-unit id="a1586bc86c3a6e96b55470571a3b7966155b62c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1435e02825452fed2fb68e6c73bfa4d34ac784c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct - How to follow up on a report</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68b43adfe65e0ada7943e8e901732e697fd8106" translate="yes" xml:space="preserve">
          <source>NumPy Contributor Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9b8569488631e17e9c539e945f4151de6b16a5" translate="yes" xml:space="preserve">
          <source>NumPy Distutils - Users Guide</source>
          <target state="translated">NumPy Distutils-Guía del usuario</target>
        </trans-unit>
        <trans-unit id="c956147a86ea5dbf2bd113161d5a9a92844fee2c" translate="yes" xml:space="preserve">
          <source>NumPy Distutils preprocesses C source files (extension: &lt;code&gt;.c.src&lt;/code&gt;) written in a custom templating language to generate C code. The &lt;code&gt;@&lt;/code&gt; symbol is used to wrap macro-style variables to empower a string substitution mechanism that might describe (for instance) a set of data types.</source>
          <target state="translated">NumPy Distutils preprocesa archivos fuente C (extensi&amp;oacute;n: &lt;code&gt;.c.src&lt;/code&gt; ) escritos en un lenguaje de plantillas personalizado para generar c&amp;oacute;digo C. El s&amp;iacute;mbolo &lt;code&gt;@&lt;/code&gt; se usa para envolver variables de estilo macro para habilitar un mecanismo de sustituci&amp;oacute;n de cadenas que podr&amp;iacute;a describir (por ejemplo) un conjunto de tipos de datos.</target>
        </trans-unit>
        <trans-unit id="6d3daec11f336cbe9aa58a4987acc6154b7a71ca" translate="yes" xml:space="preserve">
          <source>NumPy Docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87b70e72189be1c91039076031182a00ca8a4a2" translate="yes" xml:space="preserve">
          <source>NumPy Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11f236a358860bc1630b35d02b897f965a3abe6" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposal (NEP) 32, &lt;a href=&quot;https://numpy.org/neps/nep-0032-remove-financial-functions.html&quot;&gt;https://numpy.org/neps/nep-0032-remove-financial-functions.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f4b91200bead38a769f70a1e46a5128f09c922" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b610e33661eed30d2fd4d5c8298056db2d15c3b" translate="yes" xml:space="preserve">
          <source>NumPy How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b77a99ad474e5c770e0ddd949ded46acfaf38e" translate="yes" xml:space="preserve">
          <source>NumPy Issues: &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;https://github.com/numpy/numpy/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07568fa1b23354307b498eba5947dd449b1ae50" translate="yes" xml:space="preserve">
          <source>NumPy License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1797f9e232d63f819933885e2ac94ec0352d11" translate="yes" xml:space="preserve">
          <source>NumPy Reference</source>
          <target state="translated">Referencia NumPy</target>
        </trans-unit>
        <trans-unit id="23bd4c05c1a40776eacbfc3e62d23e6f2151bb0f" translate="yes" xml:space="preserve">
          <source>NumPy Reference, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Generalized Universal Function API&lt;/a&gt;.</source>
          <target state="translated">Referencia de NumPy, secci&amp;oacute;n &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;API de funci&amp;oacute;n universal generalizada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba14bf798691d10d0084ffd0e5302c3bb4aff789" translate="yes" xml:space="preserve">
          <source>NumPy Scalars are cast when assigned to arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf67cf31bc3a7972c91a07dd966f1740a8d146e" translate="yes" xml:space="preserve">
          <source>NumPy Tutorials</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31cee45cf66b17220997ed18c1c784b896e561" translate="yes" xml:space="preserve">
          <source>NumPy User Guide, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;I/O with NumPy&lt;/a&gt;.</source>
          <target state="translated">Gu&amp;iacute;a del usuario de NumPy, secci&amp;oacute;n &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;E / S con NumPy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfb797f6ad28f48ccb741b2ddb48976e23e00a3f" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64.</source>
          <target state="translated">NumPy permite la resta de dos valores de fecha y hora, una operaci&amp;oacute;n que produce un n&amp;uacute;mero con una unidad de tiempo. Debido a que NumPy no tiene un sistema de cantidades f&amp;iacute;sicas en su n&amp;uacute;cleo, el tipo de datos timedelta64 se cre&amp;oacute; para complementar datetime64.</target>
        </trans-unit>
        <trans-unit id="f9dacbde768b51aaba6413e3c788f0b194b5b375" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64. The arguments for timedelta64 are a number, to represent the number of units, and a date/time unit, such as (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds. The timedelta64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo; in place of the number for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ef31835ba51a139fefe6ca7653831fa1d642d" translate="yes" xml:space="preserve">
          <source>NumPy also performs aggregation functions. In addition to &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, and &lt;code&gt;sum&lt;/code&gt;, you can easily run &lt;code&gt;mean&lt;/code&gt; to get the average, &lt;code&gt;prod&lt;/code&gt; to get the result of multiplying the elements together, &lt;code&gt;std&lt;/code&gt; to get the standard deviation, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3681d5d48b000e09eb74bcf9d80a233df272bb0f" translate="yes" xml:space="preserve">
          <source>NumPy and SWIG</source>
          <target state="translated">NumPy y SWIG</target>
        </trans-unit>
        <trans-unit id="c826d8c52c25e4bbad4a786ac8dfdcf96c8f11ac" translate="yes" xml:space="preserve">
          <source>NumPy and Swig</source>
          <target state="translated">NumPy y Swig</target>
        </trans-unit>
        <trans-unit id="378b259740f670c18f15c2234a2938b6e65c8a3f" translate="yes" xml:space="preserve">
          <source>NumPy array slicing uses pass-by-reference, that does not copy the arguments. Slicing operations are views into an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f3f40987eacf79da1da15ffc970ce1ce8e5996" translate="yes" xml:space="preserve">
          <source>NumPy arrays are &lt;strong&gt;not&lt;/strong&gt; directly &lt;a href=&quot;https://github.com/numpy/numpy/issues/12481&quot;&gt;JSON serializable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9f76864b0123b6e81c3abbfaba07bd1a398902" translate="yes" xml:space="preserve">
          <source>NumPy arrays are faster and more compact than Python lists. An array consumes less memory and is convenient to use. NumPy uses much less memory to store data and it provides a mechanism of specifying the data types. This allows the code to be optimized even further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e9cb3043e5f97824505a55cbdfc5294d3ba613" translate="yes" xml:space="preserve">
          <source>NumPy arrays consist of two major components, the raw array data (from now on, referred to as the data buffer), and the information about the raw array data. The data buffer is typically what people think of as arrays in C or Fortran, a contiguous (and fixed) block of memory containing fixed sized data items. NumPy also contains a significant set of data that describes how to interpret the data in the data buffer. This extra information contains (among other things):</source>
          <target state="translated">Las matrices NumPy constan de dos componentes principales,los datos en bruto de las matrices (de ahora en adelante,denominados &quot;búfer de datos&quot;)y la información sobre los datos en bruto de las matrices.El búfer de datos es típicamente lo que la gente piensa que son las matrices en C o Fortran,un bloque de memoria contiguo (y fijo)que contiene elementos de datos de tamaño fijo.NumPy también contiene un conjunto significativo de datos que describe cómo interpretar los datos en el búfer de datos.Esta información extra contiene (entre otras cosas):</target>
        </trans-unit>
        <trans-unit id="064ff558785222ad92d746322b42cf271317a323" translate="yes" xml:space="preserve">
          <source>NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python&amp;rsquo;s built-in sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df6ed13e1a0bf8dd7a4da9cdb0f04829d71462" translate="yes" xml:space="preserve">
          <source>NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an &lt;code&gt;ndarray&lt;/code&gt; will create a new array and delete the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a2b1964b63758771b415bd46c81a550e3302e2" translate="yes" xml:space="preserve">
          <source>NumPy arrays may be indexed with other arrays (or any other sequence- like object that can be converted to an array, such as lists, with the exception of tuples; see the end of this document for why this is). The use of index arrays ranges from simple, straightforward cases to complex, hard-to-understand cases. For all cases of index arrays, what is returned is a copy of the original data, not a view as one gets for slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594d6227d1e21e95a87fa36149ce8ba56ba3bd8" translate="yes" xml:space="preserve">
          <source>NumPy arrays with a structured dtype can also be viewed as &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, where a field can be accessed as if it were an attribute. For that reason, we may need to make sure that the field name doesn&amp;rsquo;t contain any space or invalid character, or that it does not correspond to the name of a standard attribute (like &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;shape&lt;/code&gt;), which would confuse the interpreter. &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; accepts three optional arguments that provide a finer control on the names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddb7bcd5abd45f2c144892bcef25d7ca724d758" translate="yes" xml:space="preserve">
          <source>NumPy assigns by reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46c4db4be1d2bf47d471c892c8666f70fae9c0" translate="yes" xml:space="preserve">
          <source>NumPy basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5ee6decc812823bbb32d4c52868169ed0e2dc6" translate="yes" xml:space="preserve">
          <source>NumPy benchmarks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acba6e54dd52e6409526789be99f698cf4b66810" translate="yes" xml:space="preserve">
          <source>NumPy binary files (NPY, NPZ)</source>
          <target state="translated">Archivos binarios NumPy (NPY,NPZ)</target>
        </trans-unit>
        <trans-unit id="24422cd746cd54c121886f257099a4c4b493866b" translate="yes" xml:space="preserve">
          <source>NumPy can be tested in a number of ways, choose any way you feel comfortable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2731ffa90b7c735aae8e17474bd85f4ca800f4d" translate="yes" xml:space="preserve">
          <source>NumPy can do operations on arrays whose shapes are mismatched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16a651e79e36287ab38bac721290bfd05bc2a01" translate="yes" xml:space="preserve">
          <source>NumPy comes with 24 builtin data-types. While this covers a large majority of possible use cases, it is conceivable that a user may have a need for an additional data-type. There is some support for adding an additional data-type into the NumPy system. This additional data- type will behave much like a regular data-type except ufuncs must have 1-d loops registered to handle it separately. Also checking for whether or not other data-types can be cast &amp;ldquo;safely&amp;rdquo; to and from this new type or not will always return &amp;ldquo;can cast&amp;rdquo; unless you also register which types your new data-type can be cast to and from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f2beec853b334d966939a6cfbd8740cabbc29f" translate="yes" xml:space="preserve">
          <source>NumPy community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587dfdb00740f1bca4ab2388a780e1daaf9e9438" translate="yes" xml:space="preserve">
          <source>NumPy contains both an &lt;code&gt;array&lt;/code&gt; class and a &lt;code&gt;matrix&lt;/code&gt; class. The &lt;code&gt;array&lt;/code&gt; class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while &lt;code&gt;matrix&lt;/code&gt; is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648b2c826e9dca058d52cb253a3629a695c1c05a" translate="yes" xml:space="preserve">
          <source>NumPy contributor guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e0392d352bfceb00b69b8aae489d3cfcd35b94" translate="yes" xml:space="preserve">
          <source>NumPy core libraries</source>
          <target state="translated">Bibliotecas centrales de NumPy</target>
        </trans-unit>
        <trans-unit id="ccf16bd0788fff6636ddfa05a6cb0f611b1a5988" translate="yes" xml:space="preserve">
          <source>NumPy core math library</source>
          <target state="translated">Biblioteca de matemáticas del núcleo NumPy</target>
        </trans-unit>
        <trans-unit id="973c555328d9b9a87fd43d16a1a900328d00f946" translate="yes" xml:space="preserve">
          <source>NumPy data type descriptions are instances of the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">Las descripciones de tipos de datos NumPy son instancias de la clase &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="978f537fd61d02bcc51970587f176772f017251f" translate="yes" xml:space="preserve">
          <source>NumPy dispatcher is based on multi-source compiling, which means taking a certain source and compiling it multiple times with different compiler flags and also with different &lt;strong&gt;C&lt;/strong&gt; definitions that affect the code paths to enable certain instruction-sets for each compiled object depending on the required optimizations, then combining the returned objects together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9b40e5263a5085939745fd3402fa19fc002ecb" translate="yes" xml:space="preserve">
          <source>NumPy distutils - users guide</source>
          <target state="translated">NumPy distutils-guía del usuario</target>
        </trans-unit>
        <trans-unit id="7682241df5064b6dcd3fa7f5b4aadf68c8c520d1" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases.</source>
          <target state="translated">NumPy distutils admite la conversi&amp;oacute;n autom&amp;aacute;tica de archivos de origen denominados &amp;lt;somefile&amp;gt; .src. Esta funci&amp;oacute;n se puede utilizar para mantener bloques de c&amp;oacute;digo muy similares que requieren solo cambios simples entre bloques. Durante la fase de construcci&amp;oacute;n de la instalaci&amp;oacute;n, si se encuentra un archivo de plantilla llamado &amp;lt;somefile&amp;gt; .src, se construye un nuevo archivo llamado &amp;lt;somefile&amp;gt; a partir de la plantilla y se coloca en el directorio de construcci&amp;oacute;n para ser utilizado en su lugar. Se admiten dos formas de conversi&amp;oacute;n de plantillas. La primera forma ocurre para archivos llamados &amp;lt;archivo&amp;gt; .ext.src donde ext es una extensi&amp;oacute;n Fortran reconocida (f, f90, f95, f77, for, ftn, pyf). La segunda forma se utiliza para todos los dem&amp;aacute;s casos.</target>
        </trans-unit>
        <trans-unit id="52e91b4c51a9db40b4247ecf6771ad0f610935f6" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases. See &lt;a href=&quot;distutils_guide#templating&quot;&gt;Conversion of .src files using Templates&lt;/a&gt;.</source>
          <target state="translated">NumPy distutils admite la conversi&amp;oacute;n autom&amp;aacute;tica de archivos de origen denominados &amp;lt;somefile&amp;gt; .src. Esta funci&amp;oacute;n se puede utilizar para mantener bloques de c&amp;oacute;digo muy similares que solo requieren cambios simples entre bloques. Durante la fase de construcci&amp;oacute;n de la instalaci&amp;oacute;n, si se encuentra un archivo de plantilla llamado &amp;lt;somefile&amp;gt; .src, se construye un nuevo archivo llamado &amp;lt;somefile&amp;gt; a partir de la plantilla y se coloca en el directorio de construcci&amp;oacute;n para ser utilizado en su lugar. Se admiten dos formas de conversi&amp;oacute;n de plantillas. La primera forma ocurre para archivos llamados &amp;lt;archivo&amp;gt; .ext.src donde ext es una extensi&amp;oacute;n Fortran reconocida (f, f90, f95, f77, for, ftn, pyf). La segunda forma se utiliza para todos los dem&amp;aacute;s casos. Consulte &lt;a href=&quot;distutils_guide#templating&quot;&gt;Conversi&amp;oacute;n de archivos .src mediante plantillas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62cb8c054f8f025824b221606b89da66fb01bcbf" translate="yes" xml:space="preserve">
          <source>NumPy docs have the details covered. API reference documentation is generated directly from &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;docstrings&lt;/a&gt; in the code when the documentation is &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;built&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1726df240b387443461a0936d41d6367c1cbf" translate="yes" xml:space="preserve">
          <source>NumPy documentation is kept in the source code tree. To get your document into the docbase you must download the tree, &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;build it&lt;/a&gt;, and submit a pull request. If GitHub and pull requests are new to you, check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec067cc97926d6f20fb73fa3184c126e233e754" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;) is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b5f2ddae9a416483671c90287f2072fd0042bc" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;\; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;\) is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5d51a5b62b750c1604f2d01dcf736580720f16" translate="yes" xml:space="preserve">
          <source>NumPy does not require any external linear algebra libraries to be installed. However, if these are available, NumPy&amp;rsquo;s setup script can detect them and use them for building. A number of different LAPACK library setups can be used, including optimized LAPACK libraries such as OpenBLAS or MKL. The choice and location of these libraries as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation, and below for specifying search priority from environmental variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a95170c1892d84e44be0593492dbf2a5886a93" translate="yes" xml:space="preserve">
          <source>NumPy doesn&amp;rsquo;t have a C function documentation standard at this time, but needs one. Most numpy functions are not documented in the code and that should change. One possibility is Doxygen with a plugin so that the same NumPy style used for Python functions can also be used for documenting C functions, see the files in doc/cdoc/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f68fa749d0083be9916fd2a5a507830517a2a85" translate="yes" xml:space="preserve">
          <source>NumPy for MATLAB users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d7988a962e51ca82f6767321b92e79ba1d8ec3" translate="yes" xml:space="preserve">
          <source>NumPy for Matlab users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cda8cf1f381ff8936b6e543e5a88f49fb98417" translate="yes" xml:space="preserve">
          <source>NumPy fully supports an object-oriented approach, starting, once again, with &lt;code&gt;ndarray&lt;/code&gt;. For example, &lt;code&gt;ndarray&lt;/code&gt; is a class, possessing numerous methods and attributes. Many of its methods are mirrored by functions in the outer-most NumPy namespace, allowing the programmer to code in whichever paradigm they prefer. This flexibility has allowed the NumPy array dialect and NumPy &lt;code&gt;ndarray&lt;/code&gt; class to become the &lt;em&gt;de-facto&lt;/em&gt; language of multi-dimensional data interchange used in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4900e8d811971de762aa8ebe80dcd63c7e850d2e" translate="yes" xml:space="preserve">
          <source>NumPy functions now always support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f30850bdb0a0d23d96244e831d9063c220901" translate="yes" xml:space="preserve">
          <source>NumPy functions now support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832b7ee6576dfafa6af4c3707e511d8557196774" translate="yes" xml:space="preserve">
          <source>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype). Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples). There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890be7939c4a57f24699a49e8b1d3523457ca863" translate="yes" xml:space="preserve">
          <source>NumPy gives us the best of both worlds: element-by-element operations are the &amp;ldquo;default mode&amp;rdquo; when an &lt;code&gt;ndarray&lt;/code&gt; is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c84a4092d43fdae4261d3327c4c544413793832" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogeneous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogeneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e59636db0bed7b9eb085bfb86e99aa0957bc34" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogenous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogenous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce24f4bb69b1ac53e640f756f04696d112954c58" translate="yes" xml:space="preserve">
          <source>NumPy governance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadfd147c1bce43e0bd90025c0c918f23b1fb090" translate="yes" xml:space="preserve">
          <source>NumPy hands off array processing to C, where looping and computation are much faster than in Python. To exploit this, programmers using NumPy eliminate Python loops in favor of array-to-array operations. &lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt; can refer both to the C offloading and to structuring NumPy code to leverage it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fab98fb581f98170a2f8d5e454b21a4a9ae970" translate="yes" xml:space="preserve">
          <source>NumPy has a Documentation Team. We have open meetings on Zoom every three weeks and invite everyone to join. Don&amp;rsquo;t hesitate to reach out if you have questions or just need someone to guide you through your first steps - we&amp;rsquo;re always happy to help. Meetings are usually announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;. Meeting minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1252a4902fb7242313c7e4fd534a4effe97cd036" translate="yes" xml:space="preserve">
          <source>NumPy has a few import-time, compile-time, or runtime options which change the global behaviour. Most of these are related to performance or for debugging purposes and will not be interesting to the vast majority of users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99117692035516c5cb720484aff4e4e585660600" translate="yes" xml:space="preserve">
          <source>NumPy has a set of rules for dealing with arrays that have differing shapes which are applied whenever functions take multiple operands which combine element-wise. This is called &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcasting&lt;/a&gt;. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object can apply these rules for you when you need to write such a function.</source>
          <target state="translated">NumPy tiene un conjunto de reglas para lidiar con matrices que tienen formas diferentes que se aplican siempre que las funciones toman m&amp;uacute;ltiples operandos que combinan elementos. A esto se le llama &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;transmisi&amp;oacute;n&lt;/a&gt; . El objeto &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; puede aplicar estas reglas cuando necesite escribir dicha funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="333e27cc5487f69edc109f8bd0d8086fc2dbda03" translate="yes" xml:space="preserve">
          <source>NumPy has built-in functions for creating arrays from scratch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60168f40b56e28aca9cf44fb018703394a1b278b" translate="yes" xml:space="preserve">
          <source>NumPy has the following versioning scheme (numbers given are examples; they can be &amp;gt; 9) in principle):</source>
          <target state="translated">NumPy tiene el siguiente esquema de versiones (los n&amp;uacute;meros dados son ejemplos; pueden ser&amp;gt; 9) en principio):</target>
        </trans-unit>
        <trans-unit id="79eee1716a93d0c26d644ba6dc16d49583d1dea3" translate="yes" xml:space="preserve">
          <source>NumPy includes several constants:</source>
          <target state="translated">NumPy incluye varias constantes:</target>
        </trans-unit>
        <trans-unit id="7f95e3acee5a2de64945dfe9e2cae9083154d9ea" translate="yes" xml:space="preserve">
          <source>NumPy internals</source>
          <target state="translated">NumPy internos</target>
        </trans-unit>
        <trans-unit id="6dae93447071b4ec5703dcc87628e48329941095" translate="yes" xml:space="preserve">
          <source>NumPy is a community-owned and community-run project. To the maximum extent possible, decisions about project direction are made by community consensus (but note that &amp;ldquo;consensus&amp;rdquo; here has a somewhat technical meaning that might not match everyone&amp;rsquo;s expectations &amp;ndash; see below). Some members of the community additionally contribute by serving on the NumPy steering council, where they are responsible for facilitating the establishment of community consensus, for stewarding project resources, and &amp;ndash; in extreme cases &amp;ndash; for making project decisions if the normal community-based process breaks down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f4695ea1e6796c3681301e16dfcf7c8b735296" translate="yes" xml:space="preserve">
          <source>NumPy is a distributed, volunteer, open-source project. &lt;em&gt;You&lt;/em&gt; can help us make it better; if you believe something should be improved either in functionality or in documentation, don&amp;rsquo;t hesitate to contact us &amp;mdash; or even better, contact us and participate in fixing the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991ba5f7e8a9558d2bf270584d8056914d9ad664" translate="yes" xml:space="preserve">
          <source>NumPy is a successor for two earlier scientific Python libraries: Numeric and Numarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2a33b46873f26a8ea57c12754716a4bc2bae10" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, a general-purpose language. The advantage to NumPy is access to Python libraries including: &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;, &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;, &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;, &lt;a href=&quot;https://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;, and more. In addition, Python is often &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language&quot;&gt;embedded as a scripting language&lt;/a&gt; in other software, allowing NumPy to be used there too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0402fb92221bd3cd2c68208cc2865ddc5a180086" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab&amp;rsquo;s syntax for some array manipulations is more compact than NumPy&amp;rsquo;s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance dealing properly with stacks of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1930f65134cee5b200e1969765b9f9a7fa7a24" translate="yes" xml:space="preserve">
          <source>NumPy is now typed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eab1c6f817d74852716edac9ada3c155fd78dc5" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da01ca615e98a9d3de5876bf011bc4feb765cc1" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package needed for scientific computing with Python. This package contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2707988141b2528631eeb146c6abc6ae889534d6" translate="yes" xml:space="preserve">
          <source>NumPy is very flexible. Trying to describe the full range of possibilities statically would result in types that are not very helpful. For that reason, the typed NumPy API is often stricter than the runtime NumPy API. This section describes some notable differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0842da7a3c9a631b811fb55a0710af0d36229b7" translate="yes" xml:space="preserve">
          <source>NumPy itself is normally intentionally limited to a single thread during function calls, however it does support multiple Python threads running at the same time. Note that for performant linear algebra NumPy uses a BLAS backend such as OpenBLAS or MKL, which may use multiple threads that may be controlled by environment variables such as &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; depending on what is used. One way to control the number of threads is the package &lt;a href=&quot;https://pypi.org/project/threadpoolctl/&quot;&gt;threadpoolctl&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3d14564899f1e1d8b53467e884e70e752511fc" translate="yes" xml:space="preserve">
          <source>NumPy license</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c5b9ca35b73a4c5ad8cc11ecf764298cf0bacc" translate="yes" xml:space="preserve">
          <source>NumPy may be built with relaxed stride checking debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53e90e7b656a00b8ffca88bb6b89ffe64b4a95" translate="yes" xml:space="preserve">
          <source>NumPy numerical types are instances of &lt;code&gt;dtype&lt;/code&gt; (data-type) objects, each having unique characteristics. Once you have imported NumPy using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385beaafbdefdbe97d289ec18bd9e262a0ed8458" translate="yes" xml:space="preserve">
          <source>NumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ac2c9d8a2fd7d4b8f16afdbb4951561e207021" translate="yes" xml:space="preserve">
          <source>NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aab5ecc0999cd974eb3c7668641606fa9f4eb6b" translate="yes" xml:space="preserve">
          <source>NumPy project governance and decision-making</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344b2ccffdbc846784cb6ec3e6e0955c7148fb58" translate="yes" xml:space="preserve">
          <source>NumPy provides &lt;a href=&quot;../reference/generated/numpy.iinfo#numpy.iinfo&quot;&gt;&lt;code&gt;numpy.iinfo&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.finfo#numpy.finfo&quot;&gt;&lt;code&gt;numpy.finfo&lt;/code&gt;&lt;/a&gt; to verify the minimum or maximum values of NumPy integer and floating point values respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b798355ee6b0ba0edb9030dee01599200313df" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code than create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8046368fea8bda3d4541728b814c2be74d1348d" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code then create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="translated">NumPy proporciona una C-API para permitir a los usuarios extender el sistema y obtener acceso al objeto de matriz para usarlo en otras rutinas. La mejor manera de comprender verdaderamente la C-API es leer el c&amp;oacute;digo fuente. Sin embargo, si no est&amp;aacute; familiarizado con el c&amp;oacute;digo fuente (C), esta puede ser una experiencia desalentadora al principio. Tenga la seguridad de que la tarea se vuelve m&amp;aacute;s f&amp;aacute;cil con la pr&amp;aacute;ctica, y se sorprender&amp;aacute; de lo simple que puede ser comprender el c&amp;oacute;digo C. Incluso si cree que no puede escribir c&amp;oacute;digo C desde cero, es mucho m&amp;aacute;s f&amp;aacute;cil de entender y modificar el c&amp;oacute;digo fuente ya escrito y luego crearlo &lt;em&gt;de novo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93fc0aec43944a02522a3921ad457b6e9255c9c4" translate="yes" xml:space="preserve">
          <source>NumPy provides a convenience function called &lt;code&gt;ctypeslib.load_library&lt;/code&gt; (name, path). This function takes the name of the shared library (including any prefix like &amp;lsquo;lib&amp;rsquo; but excluding the extension) and a path where the shared library can be located. It returns a ctypes library object or raises an &lt;code&gt;OSError&lt;/code&gt; if the library cannot be found or raises an &lt;code&gt;ImportError&lt;/code&gt; if the ctypes module is not available. (Windows users: the ctypes library object loaded using &lt;code&gt;load_library&lt;/code&gt; is always loaded assuming cdecl calling convention. See the ctypes documentation under &lt;code&gt;ctypes.windll&lt;/code&gt; and/or &lt;code&gt;ctypes.oledll&lt;/code&gt; for ways to load libraries under other calling conventions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfa01d82f003cb630031c6b813526f750ab53b1" translate="yes" xml:space="preserve">
          <source>NumPy provides a set of macros that define &lt;a href=&quot;https://numpy.org/neps/nep-0038-SIMD-optimizations.html&quot;&gt;Universal Intrinsics&lt;/a&gt; to abstract out typical platform-specific intrinsics so SIMD code needs to be written only once. There are three layers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a7d5fdc3538cf929aee4c511ed8f06972767b8" translate="yes" xml:space="preserve">
          <source>NumPy provides an N-dimensional array type, the &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt;, which describes a collection of &amp;ldquo;items&amp;rdquo; of the same type. The items can be &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexed&lt;/a&gt; using for example N integers.</source>
          <target state="translated">NumPy proporciona un tipo de matriz N-dimensional, el &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt; , que describe una colecci&amp;oacute;n de &quot;elementos&quot; del mismo tipo. Los elementos se pueden &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexar&lt;/a&gt; utilizando, por ejemplo, N n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="1a75765bb40779d587b945d346fd4f25656a32a8" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy proporciona una funcionalidad distutils mejorada para facilitar la creaci&amp;oacute;n e instalaci&amp;oacute;n de subpaquetes, la generaci&amp;oacute;n autom&amp;aacute;tica de c&amp;oacute;digo y los m&amp;oacute;dulos de extensi&amp;oacute;n que utilizan bibliotecas compiladas por Fortran. Para usar las funciones de NumPy distutils, use el comando de &lt;code&gt;setup&lt;/code&gt; de &lt;code&gt;numpy.distutils.core&lt;/code&gt; . Tambi&amp;eacute;n se proporciona una clase de &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; &amp;uacute;til en &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; que puede facilitar la construcci&amp;oacute;n de argumentos de palabras clave para pasar a la funci&amp;oacute;n de configuraci&amp;oacute;n (pasando el diccionario obtenido del m&amp;eacute;todo todict () de la clase). Hay m&amp;aacute;s informaci&amp;oacute;n disponible en &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - User Guide&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc45b2b061a3c987c044eb3531af83d969814354" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a083cfd3cae0f2b0c71ffa2d89ecb4205930693" translate="yes" xml:space="preserve">
          <source>NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called &amp;ldquo;universal functions&amp;rdquo;(&lt;code&gt;ufunc&lt;/code&gt;). Within NumPy, these functions operate elementwise on an array, producing an array as output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a62542984876095dd49786ce30743b4af981559" translate="yes" xml:space="preserve">
          <source>NumPy provides several functions to create arrays from tabular data. We focus here on the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd70d7e4f84112d992fc760c41c139b7d9150b" translate="yes" xml:space="preserve">
          <source>NumPy provides several hooks that classes can customize:</source>
          <target state="translated">NumPy proporciona varios ganchos que las clases pueden personalizar:</target>
        </trans-unit>
        <trans-unit id="db997f8d5529d90e4e824067ebfe5d83669d3578" translate="yes" xml:space="preserve">
          <source>NumPy provides the &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; class which allows accessing the fields of a structured array as attributes, and a corresponding scalar data type object &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;record&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy proporciona la clase &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt; que permite acceder a los campos de una matriz estructurada como atributos, y un &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;record&lt;/code&gt; &lt;/a&gt; objeto de tipo de datos escalares correspondiente .</target>
        </trans-unit>
        <trans-unit id="46067414ac2be3ec3b21adf1f81bfbaed905b370" translate="yes" xml:space="preserve">
          <source>NumPy quickstart</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334ad60fc95510fca18811e881286378efc5596" translate="yes" xml:space="preserve">
          <source>NumPy refers to each dimension as an &lt;code&gt;axis&lt;/code&gt;. Because of how &lt;code&gt;imread&lt;/code&gt; works, the &lt;em&gt;first index in the 3rd axis&lt;/em&gt; is the red pixel data for our image. We can access this by using the syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeae0e0ef5087fb1cba7dbba1eef7ee4ab1c725" translate="yes" xml:space="preserve">
          <source>NumPy searches for optimized linear algebra libraries such as BLAS and LAPACK. There are specific orders for searching these libraries, as described below and in the &lt;code&gt;site.cfg.example&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6871239fcd860bb968e0e454a350e13641da17d" translate="yes" xml:space="preserve">
          <source>NumPy slices are by reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ea34766b2df6ce15b555bccc153c9453e468d7" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50bd9e44504ee882f7d36e3a1a29183cd10ae09" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="translated">El corte de NumPy crea una &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;vista en&lt;/a&gt; lugar de una copia como en el caso de secuencias integradas de Python como cadena, tupla y lista. Se debe tener cuidado al extraer una peque&amp;ntilde;a parte de una matriz grande que se vuelve in&amp;uacute;til despu&amp;eacute;s de la extracci&amp;oacute;n, porque la peque&amp;ntilde;a parte extra&amp;iacute;da contiene una referencia a la matriz original grande cuya memoria no se liberar&amp;aacute; hasta que todas las matrices derivadas de ella sean recolectadas como basura. En tales casos, se recomienda una &lt;code&gt;copy()&lt;/code&gt; expl&amp;iacute;cita () .</target>
        </trans-unit>
        <trans-unit id="9315eaa766c603c7ff5592ed435945f3c4e579c8" translate="yes" xml:space="preserve">
          <source>NumPy stores an internal table of Python callable objects that are used to implement arithmetic operations for arrays as well as certain array calculation methods. This function allows the user to replace any or all of these Python objects with their own versions. The keys of the dictionary, &lt;em&gt;dict&lt;/em&gt;, are the named functions to replace and the paired value is the Python callable object to use. Care should be taken that the function used to replace an internal array operation does not itself call back to that internal array operation (unless you have designed the function to handle that), or an unchecked infinite recursion can result (possibly causing program crash). The key names that represent operations that can be replaced are:</source>
          <target state="translated">NumPy almacena una tabla interna de objetos de Python que se pueden llamar que se utilizan para implementar operaciones aritm&amp;eacute;ticas para matrices, as&amp;iacute; como ciertos m&amp;eacute;todos de c&amp;aacute;lculo de matrices. Esta funci&amp;oacute;n permite al usuario reemplazar cualquiera o todos estos objetos Python con sus propias versiones. Las claves del diccionario, &lt;em&gt;dict&lt;/em&gt; , son las funciones nombradas para reemplazar y el valor emparejado es el objeto invocable de Python que se debe usar. Se debe tener cuidado de que la funci&amp;oacute;n utilizada para reemplazar una operaci&amp;oacute;n de matriz interna no vuelva a llamar a esa operaci&amp;oacute;n de matriz interna (a menos que haya dise&amp;ntilde;ado la funci&amp;oacute;n para manejar eso), o puede resultar una recursi&amp;oacute;n infinita sin marcar (posiblemente causando un bloqueo del programa). Los nombres de clave que representan operaciones que se pueden reemplazar son:</target>
        </trans-unit>
        <trans-unit id="387d18f40b5cc90de6d4cee0fbe4a352c5b8dee6" translate="yes" xml:space="preserve">
          <source>NumPy style governs cases where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ffae4d5e74817321bd554d6e22d7ad10db9e4c" translate="yes" xml:space="preserve">
          <source>NumPy supports PEP 3141 numbers:</source>
          <target state="translated">NumPy soporta los números PEP 3141:</target>
        </trans-unit>
        <trans-unit id="a30e09b28bd3a22ee136145ff9e9655f237427ce" translate="yes" xml:space="preserve">
          <source>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array&amp;rsquo;s data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233a312424d8a0ad1356c1a0f6d65ae323b75b8a" translate="yes" xml:space="preserve">
          <source>NumPy understands that the multiplication should happen with each cell. That concept is called &lt;strong&gt;broadcasting&lt;/strong&gt;. Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. The dimensions of your array must be compatible, for example, when the dimensions of both arrays are equal or when one of them is 1. If the dimensions are not compatible, you will get a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9b240ab41f1a17ca7549bbe67eafcc942f1048" translate="yes" xml:space="preserve">
          <source>NumPy user guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9253086c7c4965c63bda0ce6993cc9b981baa4c" translate="yes" xml:space="preserve">
          <source>NumPy uses a series of tests to probe the compiler and libc libraries for funtions. The results are stored in &lt;code&gt;_numpyconfig.h&lt;/code&gt; and &lt;code&gt;config.h&lt;/code&gt; files using &lt;code&gt;HAVE_XXX&lt;/code&gt; definitions. These tests are run during the &lt;code&gt;build_src&lt;/code&gt; phase of the &lt;code&gt;_multiarray_umath&lt;/code&gt; module in the &lt;code&gt;generate_config_h&lt;/code&gt; and &lt;code&gt;generate_numpyconfig_h&lt;/code&gt; functions. Since the output of these calls includes many compiler warnings and errors, by default it is run quietly. If you wish to see this output, you can run the &lt;code&gt;build_src&lt;/code&gt; stage verbosely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fbc5d580827f690776ae9fde2ddf99b3716968" translate="yes" xml:space="preserve">
          <source>NumPy uses both methods with a preference for the second method because it can be safer. The ctypes attribute of the ndarray returns an object that has an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute which returns an integer representing the address of the ndarray to which it is associated. As a result, one can pass this ctypes attribute object directly to a function expecting a pointer to the data in your ndarray. The caller must be sure that the ndarray object is of the correct type, shape, and has the correct flags set or risk nasty crashes if the data-pointer to inappropriate arrays are passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddaf9c91d8d4012f023752f68ed0149bce87d6e" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</source>
          <target state="translated">NumPy utiliza el estándar IEEE para el punto flotante binario para la aritmética (IEEE 754).</target>
        </trans-unit>
        <trans-unit id="8667558f0f51c03b2587a599efedda1f9f4468ac" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Negative zero is considered to be a finite number.</source>
          <target state="translated">NumPy utiliza el Estándar IEEE de Punto Flotante Binario para Aritmética (IEEE 754).El cero negativo se considera un número finito.</target>
        </trans-unit>
        <trans-unit id="d23202e89199272fb59380a61ef4cc7654a36b65" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Positive zero is considered to be a finite number.</source>
          <target state="translated">NumPy utiliza el Estándar IEEE de Punto Flotante Binario para Aritmética (IEEE 754).El cero positivo se considera un número finito.</target>
        </trans-unit>
        <trans-unit id="f42533d92c39de593371e6aa3dde32696064d2b8" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</source>
          <target state="translated">NumPy utiliza el Estándar IEEE de Punto Flotante Binario para Aritmética (IEEE 754).Esto significa que No es un número no es equivalente al infinito.</target>
        </trans-unit>
        <trans-unit id="af1c83a08aa63e00fff2b45b2f860192ca21bcf1" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity.</source>
          <target state="translated">NumPy utiliza el Estándar IEEE de Punto Flotante Binario para Aritmética (IEEE 754).Esto significa que No es un número no es equivalente al infinito.También que el infinito positivo no es equivalente al infinito negativo.Pero el infinito es equivalente al infinito positivo.</target>
        </trans-unit>
        <trans-unit id="389fed054ec853b5b8bb20d440426bf9262e8e46" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when &lt;code&gt;x&lt;/code&gt; is a scalar input, or if first and second arguments have different shapes.</source>
          <target state="translated">NumPy utiliza el est&amp;aacute;ndar IEEE de coma flotante binaria para aritm&amp;eacute;tica (IEEE 754). Esto significa que Not a Number no es equivalente a infinito. Adem&amp;aacute;s, ese infinito positivo no es equivalente al infinito negativo. Pero el infinito es equivalente al infinito positivo. Se producen errores si el segundo argumento tambi&amp;eacute;n se proporciona cuando &lt;code&gt;x&lt;/code&gt; es una entrada escalar, o si el primer y segundo argumento tienen formas diferentes.</target>
        </trans-unit>
        <trans-unit id="35a6249b4224925e0bdcfa0f8624c08fcc4790ef" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</source>
          <target state="translated">NumPy utiliza el Estándar IEEE de Punto Flotante Binario para Aritmética (IEEE 754).Esto significa que No es un número no es equivalente al infinito.El infinito positivo se trata como un número muy grande y el infinito negativo se trata como un número muy pequeño (es decir,negativo).</target>
        </trans-unit>
        <trans-unit id="4026f26ee4d1cd9de2a496e4e3dd03a3e5a7f962" translate="yes" xml:space="preserve">
          <source>NumPy v1.19 Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a799f9f2b696a8693dd829a76caa31a7afbdcb94" translate="yes" xml:space="preserve">
          <source>NumPy v1.20 Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0a36ef00ca34de0c91ee7b58a561c1bb0550a" translate="yes" xml:space="preserve">
          <source>NumPy version comparison</source>
          <target state="translated">Comparación de la versión de NumPy</target>
        </trans-unit>
        <trans-unit id="8ba9f463515e23b0f299b2ffc9d54837e3d43200" translate="yes" xml:space="preserve">
          <source>NumPy version string (&lt;code&gt;np.__version__&lt;/code&gt;).</source>
          <target state="translated">Cadena de versi&amp;oacute;n de NumPy ( &lt;code&gt;np.__version__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9b3a90b67fc6e7751631f73fbd200fedcaf6517b" translate="yes" xml:space="preserve">
          <source>NumPy will gather implementations of &lt;code&gt;__array_function__&lt;/code&gt; from all specified inputs and call them in order: subclasses before superclasses, and otherwise left to right. Note that in some edge cases involving subclasses, this differs slightly from the &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;current behavior&lt;/a&gt; of Python.</source>
          <target state="translated">NumPy recopilar&amp;aacute; implementaciones de &lt;code&gt;__array_function__&lt;/code&gt; de todas las entradas especificadas y las llamar&amp;aacute; en orden: subclases antes que superclases y, de lo contrario, de izquierda a derecha. Tenga en cuenta que en algunos casos extremos que involucran subclases, esto difiere ligeramente del &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;comportamiento actual&lt;/a&gt; de Python.</target>
        </trans-unit>
        <trans-unit id="eaf96b4a25ad851a2b4abd4e522b636c4d667ac3" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip()&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb311f19fa41c253fcda50763e8cfca7eec45cb" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b39796df6889956cc3b3ff1db77e20497876b0e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c194038698da06d4deba03ca0f701303ee7a9e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s array class is called &lt;code&gt;ndarray&lt;/code&gt;. It is also known by the alias &lt;code&gt;array&lt;/code&gt;. Note that &lt;code&gt;numpy.array&lt;/code&gt; is not the same as the Standard Python Library class &lt;code&gt;array.array&lt;/code&gt;, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an &lt;code&gt;ndarray&lt;/code&gt; object are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132beeeb0b4ce70a8210a70bdb9c78c481e563b" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s broadcasting rule relaxes this constraint when the arrays&amp;rsquo; shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6e87a1254c0e2518a18db62672d9b8b4222aec" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s documentation uses several custom extensions to Sphinx. These are shipped in the &lt;code&gt;sphinxext/&lt;/code&gt; directory (as git submodules, as discussed above), and are automatically enabled when building NumPy&amp;rsquo;s documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b4ca4dd070cbb18cd729b7d82f19fbc8f9eb17" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s fast element-by-element computation (&lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt;) gives a choice which function gets applied. The general term for the function is &lt;code&gt;ufunc&lt;/code&gt;, short for &lt;code&gt;universal function&lt;/code&gt;. NumPy routines have built-in ufuncs, but users can also &lt;a href=&quot;reference/ufuncs&quot;&gt;write their own.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a23df3dc68bb04fcd72ce4a7accb7a59c107ed5" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called &lt;em&gt;axes&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bdc0eebf8a97bb8d97d7e158fade619726770f" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s two-dimensional &lt;a href=&quot;reference/generated/numpy.matrix&quot;&gt;matrix class&lt;/a&gt; should no longer be used; use regular ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e72e3b2d20e9ce05fa10cf5b67fd4a5d867f2b5" translate="yes" xml:space="preserve">
          <source>NumPy, &lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt;, and the scikits follow a common convention for docstrings that provides for consistency, while also allowing our toolchain to produce well-formatted reference guides. This document describes the current community consensus for such a standard. If you have suggestions for improvements, post them on the &lt;a href=&quot;http://scipy.org/scipylib/mailing-lists.html&quot;&gt;numpy-discussion list&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e598a2efe067bb7689f0ffff5764af8bbe8461" translate="yes" xml:space="preserve">
          <source>NumPy, like Python, numbers indices from 0; &lt;code&gt;a[0]&lt;/code&gt; is the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65980c8f8cdaffbdb9dc6b41c004c578cf994ed4" translate="yes" xml:space="preserve">
          <source>NumPy, or rather Python, has similar facilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99044d84c351a4ed63efec49bbe1ae3bf320ae" translate="yes" xml:space="preserve">
          <source>NumPy-specific help functions</source>
          <target state="translated">Funciones de ayuda específicas de NumPy</target>
        </trans-unit>
        <trans-unit id="8e5883940f8591fc18bd2d38714b4441d0bc3808" translate="yes" xml:space="preserve">
          <source>NumPy-specific workflow is in &lt;a href=&quot;development_workflow#development-workflow&quot;&gt;numpy-development-workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61e66899eea7ee7ff7294019b3070d639ae0728" translate="yes" xml:space="preserve">
          <source>NumPy: the absolute basics for beginners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f40cf39f0e25d8cf6f052959da2085155ae248" translate="yes" xml:space="preserve">
          <source>Numba</source>
          <target state="translated">Numba</target>
        </trans-unit>
        <trans-unit id="2ad094bf2eb6f204e2abae88bcc155073c5a7b5d" translate="yes" xml:space="preserve">
          <source>Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators all export a small set of functions through both interfaces.</source>
          <target state="translated">El Numba puede ser usado con CTypes o CFFI.La iteración actual de los Generadores de Bits exporta un pequeño conjunto de funciones a través de ambas interfaces.</target>
        </trans-unit>
        <trans-unit id="25996b6bfaea719dfb36b6f8bc64656e147e8c2f" translate="yes" xml:space="preserve">
          <source>Number Precision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858e21b5a976ec86aff538495ea9c4f65e263a29" translate="yes" xml:space="preserve">
          <source>Number of &amp;lsquo;guard digits&amp;rsquo; used when truncating the product of two mantissas to fit the representation.</source>
          <target state="translated">N&amp;uacute;mero de &quot;d&amp;iacute;gitos de guarda&quot; que se utilizan al truncar el producto de dos mantisas para que se ajuste a la representaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bbf91dba201dcc9eece0dc41a5e6c527d91e56cf" translate="yes" xml:space="preserve">
          <source>Number of Threads used for Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be768826cc42fcf995f3aef93d52ff0cd53e9ae" translate="yes" xml:space="preserve">
          <source>Number of array dimensions.</source>
          <target state="translated">Número de dimensiones de la matriz.</target>
        </trans-unit>
        <trans-unit id="a97fad0d0844aff9a71f23c56eb56e01fb752db2" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension (default 3).</source>
          <target state="translated">Número de elementos de la matriz en resumen al principio y al final de cada dimensión (por defecto 3).</target>
        </trans-unit>
        <trans-unit id="9201c088075dba2ae62f215d4d2fdd9a8a777253" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension. Defaults to &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de elementos de la matriz en resumen al principio y al final de cada dimensi&amp;oacute;n. El valor predeterminado es &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4574e45463a4337cd6208d1b13e93be562f45874" translate="yes" xml:space="preserve">
          <source>Number of base-&lt;code&gt;ibeta&lt;/code&gt; digits in the floating point mantissa M.</source>
          <target state="translated">N&amp;uacute;mero de d&amp;iacute;gitos base- &lt;code&gt;ibeta&lt;/code&gt; en la mantisa M.</target>
        </trans-unit>
        <trans-unit id="3ada3f66dbd1b40b353be9a0f81e475922b90cd9" translate="yes" xml:space="preserve">
          <source>Number of bits in data types</source>
          <target state="translated">Número de bits en los tipos de datos</target>
        </trans-unit>
        <trans-unit id="f0e91946bba240191d8f8b60627edef4c8d6081d" translate="yes" xml:space="preserve">
          <source>Number of bits in the exponent (including its sign and bias).</source>
          <target state="translated">Número de bits en el exponente (incluyendo su signo y sesgo).</target>
        </trans-unit>
        <trans-unit id="3a305056bc0be0ed46faf9a5c4020bd05011c494" translate="yes" xml:space="preserve">
          <source>Number of bits to remove at the right of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">N&amp;uacute;mero de bits para eliminar a la derecha de &lt;code&gt;x1&lt;/code&gt; . Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="bcd1696318c5332018bcf91295a29c11afe64192" translate="yes" xml:space="preserve">
          <source>Number of bytes to skip before beginning the element view.</source>
          <target state="translated">Número de bytes a saltar antes de comenzar la vista de elementos.</target>
        </trans-unit>
        <trans-unit id="2bd38d497915bde99690ede2a81fd5739730552b" translate="yes" xml:space="preserve">
          <source>Number of columns in the array. By default, &lt;code&gt;M&lt;/code&gt; is taken equal to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de columnas de la matriz. Por defecto, &lt;code&gt;M&lt;/code&gt; se toma igual a &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e78e98de656ac1f174b228b3b3cfaba70b125d" translate="yes" xml:space="preserve">
          <source>Number of columns in the output, defaults to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de columnas en la salida, predeterminado en &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00044a0ba0541a7997dd2599a4f9b91182edde55" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If &lt;code&gt;N&lt;/code&gt; is not specified, a square array is returned (&lt;code&gt;N = len(x)&lt;/code&gt;).</source>
          <target state="translated">N&amp;uacute;mero de columnas en la salida. Si no se especifica &lt;code&gt;N&lt;/code&gt; , se devuelve una matriz cuadrada ( &lt;code&gt;N = len(x)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a06d5e776ba9dffd0e77cd97b2c7b86bb26acb1a" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If None, defaults to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de columnas en la salida. Si ninguno, por defecto a &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0217140ca3d5b8f088751040a1594d26b45a1b44" translate="yes" xml:space="preserve">
          <source>Number of compounding periods</source>
          <target state="translated">Número de períodos compuestos</target>
        </trans-unit>
        <trans-unit id="97af9143d62e7223493889f6bc88440f1ed78209" translate="yes" xml:space="preserve">
          <source>Number of core dimensions of each argument</source>
          <target state="translated">Número de dimensiones centrales de cada argumento</target>
        </trans-unit>
        <trans-unit id="33246fa87d0b3d8cf0cd33d590270d0d5b8977dd" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round to (default: 0). If decimals is negative, it specifies the number of positions to the left of the decimal point.</source>
          <target state="translated">Número de decimales a redondear (por defecto:0).Si los decimales son negativos,especifica el número de posiciones a la izquierda del punto decimal.</target>
        </trans-unit>
        <trans-unit id="6d7f7a5c3f27de2bb3c70596c0f42aef8c17be9e" translate="yes" xml:space="preserve">
          <source>Number of decimals to round to. May be negative.</source>
          <target state="translated">Número de decimales a redondear.Puede ser negativo.</target>
        </trans-unit>
        <trans-unit id="d0f39eca925aa79a0a6c1e41a38d8c60caef28f9" translate="yes" xml:space="preserve">
          <source>Number of degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">N&amp;uacute;mero de grados de libertad, debe ser&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="947cb948510d628b02b33a2e4f5d937c49f48f16" translate="yes" xml:space="preserve">
          <source>Number of derivatives taken, must be non-negative. (Default: 1)</source>
          <target state="translated">El número de derivados tomados,debe ser no negativo.(Por defecto:1)</target>
        </trans-unit>
        <trans-unit id="97245ef113e26038c737c690b9b01b48fa8ebd7e" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="translated">N&amp;uacute;mero de d&amp;iacute;gitos de precisi&amp;oacute;n para salida de coma flotante (por defecto 8). Puede ser &lt;code&gt;None&lt;/code&gt; si &lt;code&gt;floatmode&lt;/code&gt; no es &lt;code&gt;fixed&lt;/code&gt; , para imprimir tantos d&amp;iacute;gitos como sea necesario para especificar de forma &amp;uacute;nica el valor.</target>
        </trans-unit>
        <trans-unit id="f527b9aa37b022d773444c86018ada827757d9b4" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be None if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d97ec2f2e677c40d4431d2275107bedf5755ab8" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result.</source>
          <target state="translated">Número de dimensiones del resultado emitido.</target>
        </trans-unit>
        <trans-unit id="e3508cd09f84a8328fcc45ebfc715b277ccf9575" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. Alias for &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt;&lt;code&gt;nd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">N&amp;uacute;mero de dimensiones del resultado emitido. Alias ​​para &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt; &lt;code&gt;nd&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d295ce1b14b658fe281bd20aab41d9aab0b616" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. For code intended for NumPy 1.12.0 and later the more consistent &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; is preferred.</source>
          <target state="translated">N&amp;uacute;mero de dimensiones del resultado emitido. Para el c&amp;oacute;digo destinado a NumPy 1.12.0 y posteriores, se prefiere el &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt; m&amp;aacute;s consistente .</target>
        </trans-unit>
        <trans-unit id="b135521e22bf0efd0692b304dc2944b4be1550dd" translate="yes" xml:space="preserve">
          <source>Number of dimensions of the sub-array if this data type describes a sub-array, and &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">N&amp;uacute;mero de dimensiones de la submatriz si este tipo de datos describe una submatriz y &lt;code&gt;0&lt;/code&gt; en caso contrario.</target>
        </trans-unit>
        <trans-unit id="19ea598f5fd4c1ee639980fee9928d5377e30cf8" translate="yes" xml:space="preserve">
          <source>Number of distinct core dimension names in the signature</source>
          <target state="translated">Número de nombres de dimensiones centrales distintas en la firma</target>
        </trans-unit>
        <trans-unit id="30b78d11ec827a9cb1ca1519eabc00a62b47ac43" translate="yes" xml:space="preserve">
          <source>Number of draws to advance the RNG. Must be less than the size state variable in the underlying RNG.</source>
          <target state="translated">Número de sorteos para avanzar en el RNG.Debe ser menor que la variable de estado de tamaño en el RNG subyacente.</target>
        </trans-unit>
        <trans-unit id="70e37b72989cb2f41b3fc9d963c59f76fe6543ba" translate="yes" xml:space="preserve">
          <source>Number of elements along the specified axis.</source>
          <target state="translated">Número de elementos a lo largo del eje especificado.</target>
        </trans-unit>
        <trans-unit id="807011d441713287a8ad8dac9e44680a221be633" translate="yes" xml:space="preserve">
          <source>Number of elements in the array.</source>
          <target state="translated">Número de elementos en la matriz.</target>
        </trans-unit>
        <trans-unit id="9dd78b22d2ed99e0d773b0892f1882002390793b" translate="yes" xml:space="preserve">
          <source>Number of experiments.</source>
          <target state="translated">Número de experimentos.</target>
        </trans-unit>
        <trans-unit id="f483027559825fca9bfa4da6e5eb78910571331a" translate="yes" xml:space="preserve">
          <source>Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</source>
          <target state="translated">Número de primeros índices que están involucrados en la suma inversa.Debe ser un entero positivo,el valor por defecto es 2.</target>
        </trans-unit>
        <trans-unit id="b1779d0462b8633175ab393ef9880942bb660fa7" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be at least 1 and at most &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de art&amp;iacute;culos muestreados. Debe ser al menos 1 y como m&amp;aacute;ximo &lt;code&gt;ngood + nbad&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafdf0d454dc2aa43f8a71aaefeb0feceae0766e" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be nonnegative and less than &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero de art&amp;iacute;culos muestreados. Debe ser no negativo y menor que &lt;code&gt;ngood + nbad&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="897014b016e872c41c97ea0a9d1726a5e3c782d9" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all data in the buffer.</source>
          <target state="translated">N&amp;uacute;mero de elementos para leer. &lt;code&gt;-1&lt;/code&gt; significa todos los datos en el b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="b39ddea78956da2963bde4fd3e57272e8d0acb35" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all items (i.e., the complete file).</source>
          <target state="translated">N&amp;uacute;mero de elementos para leer. &lt;code&gt;-1&lt;/code&gt; significa todos los elementos (es decir, el archivo completo).</target>
        </trans-unit>
        <trans-unit id="166e4814f7850463b72419995efff990410c931d" translate="yes" xml:space="preserve">
          <source>Number of iterators possessed by the broadcasted result.</source>
          <target state="translated">Número de iteradores que posee el resultado emitido.</target>
        </trans-unit>
        <trans-unit id="4211a9fc555cfccd24b355f573ae3f8ff77483ef" translate="yes" xml:space="preserve">
          <source>Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</source>
          <target state="translated">Número de valores no nulos en la matriz a lo largo de un eje determinado.De lo contrario,se devuelve el número total de valores distintos de cero en la matriz.</target>
        </trans-unit>
        <trans-unit id="10474dca8982c65317e69ff33c6161fee40334b7" translate="yes" xml:space="preserve">
          <source>Number of point pairs to return. The default value is 100.</source>
          <target state="translated">Número de pares de puntos a devolver.El valor por defecto es 100.</target>
        </trans-unit>
        <trans-unit id="551051df538e93f92abd0e4d70bab9ebd0a9979c" translate="yes" xml:space="preserve">
          <source>Number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">N&amp;uacute;mero de puntos a lo largo del eje de transformaci&amp;oacute;n en la entrada que se utilizar&amp;aacute;. Si &lt;code&gt;n&lt;/code&gt; es menor que la longitud de la entrada, la entrada se recorta. Si es mayor, la entrada se rellena con ceros. Si no se da &lt;code&gt;n&lt;/code&gt; , se usa la longitud de la entrada a lo largo del eje especificado por &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1a0e92249dd7ea05411a06963194533d7918c7" translate="yes" xml:space="preserve">
          <source>Number of points in the output window. If zero or less, an empty array is returned.</source>
          <target state="translated">Número de puntos en la ventana de salida.Si es cero o menos,se devuelve una matriz vacía.</target>
        </trans-unit>
        <trans-unit id="79e81bd3a9cf8f13e4e087ed6b9ef489d7061b0e" translate="yes" xml:space="preserve">
          <source>Number of random bytes.</source>
          <target state="translated">Número de bytes aleatorios.</target>
        </trans-unit>
        <trans-unit id="53975b0c071abdcd5131d1862834f5b08e87e264" translate="yes" xml:space="preserve">
          <source>Number of rows (and columns) in &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; output.</source>
          <target state="translated">N&amp;uacute;mero de filas (y columnas) en la salida &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba04adb79f4c3bf3f6caa8c01f8f929a74cbf8dc" translate="yes" xml:space="preserve">
          <source>Number of rows in the array.</source>
          <target state="translated">Número de filas en la matriz.</target>
        </trans-unit>
        <trans-unit id="9371726ac94e49726635264017eacaef06541bb1" translate="yes" xml:space="preserve">
          <source>Number of rows in the output.</source>
          <target state="translated">Número de filas en la salida.</target>
        </trans-unit>
        <trans-unit id="89c00ebdcc34147d25718afd7dbd46f5e2d21937" translate="yes" xml:space="preserve">
          <source>Number of sample points and weights. It must be &amp;gt;= 1.</source>
          <target state="translated">N&amp;uacute;mero de puntos de muestra y pesos. Debe ser&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="394bbce360690b00428b0808fa6c2c7bc474b75c" translate="yes" xml:space="preserve">
          <source>Number of sample points desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f13e51c56d80088f553a736484516fc0a17451a" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50.</source>
          <target state="translated">Número de muestras a generar.Por defecto es 50.</target>
        </trans-unit>
        <trans-unit id="b944ba1a6a786da2de285aee44ef64df7a0334c1" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50. Must be non-negative.</source>
          <target state="translated">Número de muestras a generar.Por defecto es 50.Debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="b8477012cd08123303aba533415512dffd6caae6" translate="yes" xml:space="preserve">
          <source>Number of times the array is rotated by 90 degrees.</source>
          <target state="translated">El número de veces que la matriz se gira 90 grados.</target>
        </trans-unit>
        <trans-unit id="43c5f5739f871a7eba2351b02c5057ed709b7574" translate="yes" xml:space="preserve">
          <source>Number of times to jump the state of the bit generator returned</source>
          <target state="translated">El número de veces que se salta el estado del generador de bits devuelto</target>
        </trans-unit>
        <trans-unit id="612ea9a9fedd365d5dfed6db5fa33a0bb992e5bc" translate="yes" xml:space="preserve">
          <source>Number of values padded to the edges of each axis. ((before_1, after_1), &amp;hellip; (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes.</source>
          <target state="translated">N&amp;uacute;mero de valores rellenados en los bordes de cada eje. ((before_1, after_1),&amp;hellip; (before_N, after_N)) anchos de almohadilla &amp;uacute;nicos para cada eje. ((antes, despu&amp;eacute;s),) produce la misma almohadilla antes y despu&amp;eacute;s para cada eje. (pad,) o int es un atajo para before = after = pad width para todos los ejes.</target>
        </trans-unit>
        <trans-unit id="21f1fbd39c40968c76006276fee34189d50015b9" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">Número de formas de hacer una mala selección.Debe ser no negativo y menos de 10**9.</target>
        </trans-unit>
        <trans-unit id="4fbe2e90660c2e70b194a26e014711298205f94b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative.</source>
          <target state="translated">Número de formas de hacer una mala selección.Debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="3f0216b57e4ddf8587c6f571d9e2b9562f1ca140" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">Hay muchas maneras de hacer una buena selección.Debe ser no negativo y menos de 10**9.</target>
        </trans-unit>
        <trans-unit id="e7a90f9a528b46c6111a9dd205b3c9485855546b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative.</source>
          <target state="translated">Hay muchas maneras de hacer una buena selección.Debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="f8ef4addb29288d67ee3b4225212bd0c25d2c82e" translate="yes" xml:space="preserve">
          <source>Number of zeros padded on the left. Default is 0 (no padding).</source>
          <target state="translated">Número de ceros acolchados a la izquierda.Por defecto es 0 (sin relleno).</target>
        </trans-unit>
        <trans-unit id="c42ce792573d252e0e5bfedf479c34b63dd69907" translate="yes" xml:space="preserve">
          <source>Number of zeros to append to &lt;code&gt;x1&lt;/code&gt;. Has to be non-negative. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">N&amp;uacute;mero de ceros para agregar a &lt;code&gt;x1&lt;/code&gt; . Tiene que ser no negativo. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="48744031d20b47daf05a16a7cf85445cecfa69bb" translate="yes" xml:space="preserve">
          <source>Number(s) to append at the end of the returned differences.</source>
          <target state="translated">Número(s)a añadir al final de las diferencias devueltas.</target>
        </trans-unit>
        <trans-unit id="b058e82a0ebd1af4fdfdc76f108d0c56ee2817ee" translate="yes" xml:space="preserve">
          <source>Number(s) to prepend at the beginning of the returned differences.</source>
          <target state="translated">Número(s)a preparar al principio de las diferencias devueltas.</target>
        </trans-unit>
        <trans-unit id="415e3bf4df03605336c3914770641333dc739919" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom in &lt;code&gt;random.noncentral_f&lt;/code&gt; need only be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef085dad0112ed12e20c9ac768d68c02abb5c39" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">Los grados de libertad del numerador deben ser&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="915427ef41bad72baf07ece61495d7f8349cc6ce" translate="yes" xml:space="preserve">
          <source>Numerator.</source>
          <target state="translated">Numerator.</target>
        </trans-unit>
        <trans-unit id="725a001aa87d95c548766f8d2dce89bbb2b6023f" translate="yes" xml:space="preserve">
          <source>Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are &lt;code&gt;c -&amp;gt; S1&lt;/code&gt;, &lt;code&gt;b -&amp;gt; B&lt;/code&gt;, &lt;code&gt;1 -&amp;gt; b&lt;/code&gt;, &lt;code&gt;s -&amp;gt; h&lt;/code&gt;, &lt;code&gt;w -&amp;gt;
H&lt;/code&gt;, and &lt;code&gt;u -&amp;gt; I&lt;/code&gt;. These changes make the type character convention more consistent with other Python modules such as the &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Compatibilidad num&amp;eacute;rica: si us&amp;oacute; caracteres de c&amp;oacute;digo de tipo antiguo en su c&amp;oacute;digo num&amp;eacute;rico (que nunca se recomend&amp;oacute;), deber&amp;aacute; cambiar algunos de ellos por los nuevos caracteres. En particular, los cambios necesarios son &lt;code&gt;c -&amp;gt; S1&lt;/code&gt; , &lt;code&gt;b -&amp;gt; B&lt;/code&gt; , &lt;code&gt;1 -&amp;gt; b&lt;/code&gt; , &lt;code&gt;s -&amp;gt; h&lt;/code&gt; , &lt;code&gt;w -&amp;gt; H&lt;/code&gt; , y &lt;code&gt;u -&amp;gt; I&lt;/code&gt; . Estos cambios hacen que la convenci&amp;oacute;n de caracteres de tipo sea m&amp;aacute;s coherente con otros m&amp;oacute;dulos de Python, como el m&amp;oacute;dulo &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb439f202c0c83a4476c0493068474885a0d04ea" translate="yes" xml:space="preserve">
          <source>Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. &lt;code&gt;U+2155,
VULGAR FRACTION ONE FIFTH&lt;/code&gt;.</source>
          <target state="translated">Los caracteres num&amp;eacute;ricos incluyen caracteres de d&amp;iacute;gitos y todos los caracteres que tienen la propiedad de valor num&amp;eacute;rico Unicode, por ejemplo, &lt;code&gt;U+2155, VULGAR FRACTION ONE FIFTH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d110fd1044993992c435dc5c01496d108d91112c" translate="yes" xml:space="preserve">
          <source>Numeric-style type names have been removed from type dictionaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5636617d28e515f0b65e76f0f4004b94b623c0" translate="yes" xml:space="preserve">
          <source>Numerical negative, element-wise.</source>
          <target state="translated">Negativo numérico,en cuanto a los elementos.</target>
        </trans-unit>
        <trans-unit id="4370eb3bfbe7ac1a30c0f9e9ca59a934adb66660" translate="yes" xml:space="preserve">
          <source>Numerical operations</source>
          <target state="translated">Operaciones numéricas</target>
        </trans-unit>
        <trans-unit id="42eddc11b63fd08bdfea69adf3f079710df9af97" translate="yes" xml:space="preserve">
          <source>Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.:</source>
          <target state="translated">Las operaciones numéricas pueden realizarse fácilmente sin preocuparse por los valores perdidos,dividiendo por cero,las raíces cuadradas de los números negativos,etc:</target>
        </trans-unit>
        <trans-unit id="4259f28206bfbca56d0e23c019e2fc661e9b9dc6" translate="yes" xml:space="preserve">
          <source>Numerical positive, element-wise.</source>
          <target state="translated">Positivo numérico,en cuanto a los elementos.</target>
        </trans-unit>
        <trans-unit id="52d7754f5a98c840b507e69ac61f5c2741e65c9f" translate="yes" xml:space="preserve">
          <source>Numerical ranges</source>
          <target state="translated">Rangos numéricos</target>
        </trans-unit>
        <trans-unit id="6466751f790e1e415eaeb56dd6736b61b1be5ff5" translate="yes" xml:space="preserve">
          <source>Numpy Alignment Goals</source>
          <target state="translated">Objetivos de la alineación Numpy</target>
        </trans-unit>
        <trans-unit id="5e9d87ae4602a83bd12085c965654deb5c3d6e16" translate="yes" xml:space="preserve">
          <source>Numpy has switched to using pytest instead of nose for testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecbc9f20872e5d771f0c6a8fd21f4eb8338d6ff" translate="yes" xml:space="preserve">
          <source>Numpy no longer monkey-patches &lt;code&gt;ctypes&lt;/code&gt; with &lt;code&gt;__array_interface__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924ed3491b77ccfa9befdd61777a79adde9bfe4c" translate="yes" xml:space="preserve">
          <source>Numpy type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa7af780a848cf7ff977252465dc8e7c6177248" translate="yes" xml:space="preserve">
          <source>Numpy uses one of two methods to automatically determine the field byte offsets and the overall itemsize of a structured datatype, depending on whether &lt;code&gt;align=True&lt;/code&gt; was specified as a keyword argument to &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfbe596058b381b5d62de809d86afe7e25ae53f" translate="yes" xml:space="preserve">
          <source>Numpy uses two different forms of alignment to achieve these goals: &amp;ldquo;True alignment&amp;rdquo; and &amp;ldquo;Uint alignment&amp;rdquo;.</source>
          <target state="translated">Numpy utiliza dos formas diferentes de alineaci&amp;oacute;n para lograr estos objetivos: &quot;alineaci&amp;oacute;n verdadera&quot; y &quot;alineaci&amp;oacute;n Uint&quot;.</target>
        </trans-unit>
        <trans-unit id="0bb9027c1066c8ed830e4c8560442711a99e34e6" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;http://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93c9bf237607868ba74040bad035c52633b9e7e" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;https://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893f750b4312b0bd2ff35bac0b6f12ab34ffa8d1" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964f31d6716dc00a266686a77065b8428590080d" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;code&gt;BitGenerator&lt;/code&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="translated">Las rutinas de n&amp;uacute;meros aleatorios de &lt;code&gt;BitGenerator&lt;/code&gt; producen n&amp;uacute;meros pseudoaleatorios usando combinaciones de un BitGenerator para crear secuencias y un &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; para usar esas secuencias para muestrear de diferentes distribuciones estad&amp;iacute;sticas:</target>
        </trans-unit>
        <trans-unit id="dbcd930c38d963d5846a86153db381c82c24485e" translate="yes" xml:space="preserve">
          <source>NumpyVersion (class in numpy.lib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1987fcddaae88d3445636d103d2f655d68cf7145" translate="yes" xml:space="preserve">
          <source>NumpyVersion class added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="76403535a8ec16748017a87f4c76e50c07884d6f" translate="yes" xml:space="preserve">
          <source>O&amp;rsquo;Neill, Melissa E. &lt;a href=&quot;https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf&quot;&gt;&amp;ldquo;PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation&amp;rdquo;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="cd32e6ddbd41be3c5a4eb16b6f1ed3f8efca53a5" translate="yes" xml:space="preserve">
          <source>O(n*log(n))</source>
          <target state="translated">O(n*log(n))</target>
        </trans-unit>
        <trans-unit id="65ac5f452cfa676b59863240cc6b58ed94146182" translate="yes" xml:space="preserve">
          <source>O(n^2)</source>
          <target state="translated">O(n^2)</target>
        </trans-unit>
        <trans-unit id="16e21f4d3aaf4aa65a40bf94fc12335c25429454" translate="yes" xml:space="preserve">
          <source>O. McNoleg, &amp;ldquo;The integration of GIS, remote sensing, expert systems and adaptive co-kriging for environmental habitat modelling of the Highland Haggis using object-oriented, fuzzy-logic and neural-network techniques,&amp;rdquo; Computers &amp;amp; Geosciences, vol. 22, pp. 585-588, 1996.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4363d346523c5b2cd1bf247b95c174fae0de6fec" translate="yes" xml:space="preserve">
          <source>OS X builds on travis currently use &lt;code&gt;clang&lt;/code&gt;. It appears that binary wheels for OSX &amp;gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edf589ebc096e6f9b1588e4ff5155e67b354878" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4888b19146be35293d0e37e7d29c9c307248078" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495dc72791fecbe14725db696ffa42ad8b5edf3d" translate="yes" xml:space="preserve">
          <source>OSError</source>
          <target state="translated">OSError</target>
        </trans-unit>
        <trans-unit id="8803bb33e936d33e0faf20b780197077a08628ad" translate="yes" xml:space="preserve">
          <source>OSX: x64_86 OSX wheels built using travis-ci;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fce725b9aa55e80045f38a3d07a2d5daf8ad25e" translate="yes" xml:space="preserve">
          <source>OWNDATA / O</source>
          <target state="translated">OWNDATA/O</target>
        </trans-unit>
        <trans-unit id="77cbefcb956b9d9d63f0f7b3f93654f940febe59" translate="yes" xml:space="preserve">
          <source>Object (i.e. the memory contains a pointer to &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Objeto (es decir, la memoria contiene un puntero a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="afdc54032033cacfee557f2ce2a005fa3b70eafb" translate="yes" xml:space="preserve">
          <source>Object array equality comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cc0c5c1acda14fa673f72ba7a000a4aeb4b75a" translate="yes" xml:space="preserve">
          <source>Object arrays containing multi-line objects have a more readable &lt;code&gt;repr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3760fc40824fa6cae9e794ba9f7b99a3316407ab" translate="yes" xml:space="preserve">
          <source>Object that defines the index or indices before which &lt;code&gt;values&lt;/code&gt; is inserted.</source>
          <target state="translated">Objeto que define el &amp;iacute;ndice o &amp;iacute;ndices antes del cual se insertan los &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d05ef3a802418a7aebbd13573f51be0ead5f4193" translate="yes" xml:space="preserve">
          <source>Object to be converted to a data type object.</source>
          <target state="translated">Objeto que se convertirá en un objeto de tipo de datos.</target>
        </trans-unit>
        <trans-unit id="1fd19fd89522d105167e839769054978a325524d" translate="yes" xml:space="preserve">
          <source>Object to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4aa609fdcdcac826105f68748fd29ccfe3e04a" translate="yes" xml:space="preserve">
          <source>Objects implementing the &lt;code&gt;__array__&lt;/code&gt; protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce13dfb5c9252ebd908c62fdf9e3deef898f9e3" translate="yes" xml:space="preserve">
          <source>Objects with the &lt;code&gt;.dtype&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8900e78cbf680bcf40ca195f2953f79bcfe04f2" translate="yes" xml:space="preserve">
          <source>Observe that we are using the dataptr array inside the iterator, not copying the values to a local temporary. This is possible because when &lt;code&gt;iternext()&lt;/code&gt; is called, these pointers will be overwritten with fresh values, not incrementally updated.</source>
          <target state="translated">Observe que estamos usando la matriz dataptr dentro del iterador, no copiando los valores a un temporal local. Esto es posible porque cuando se llama a &lt;code&gt;iternext()&lt;/code&gt; , estos punteros se sobrescribir&amp;aacute;n con valores nuevos, no se actualizar&amp;aacute;n de forma incremental.</target>
        </trans-unit>
        <trans-unit id="f7b6a1c7c2ab92717708ab52dfb304953f89b662" translate="yes" xml:space="preserve">
          <source>Observe that with the default of keeping native memory order, the iterator is able to provide a single one-dimensional chunk, whereas when forcing Fortran order, it has to provide three chunks of two elements each.</source>
          <target state="translated">Obsérvese que con el defecto de mantener el orden de la memoria nativa,el iterador es capaz de proporcionar un solo trozo unidimensional,mientras que al forzar el orden Fortran,tiene que proporcionar tres trozos de dos elementos cada uno.</target>
        </trans-unit>
        <trans-unit id="d9a0a259d7da286202ed894d68d15acb64fcfe1b" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reported person(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b79a5cda4ce7e7ddd9f792b9921027f93e2741" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reporter(s). The reporter(s) have complete freedom to decline the mediation idea, or to propose an alternate mediator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4aa4abf7a6245dfaef0c8852a595c8fb657a3c" translate="yes" xml:space="preserve">
          <source>Obvious &lt;strong&gt;wording&lt;/strong&gt; mistakes (like leaving out a &amp;ldquo;not&amp;rdquo;) fall into the typo category, but other rewordings &amp;ndash; even for grammar &amp;ndash; require a judgment call, which raises the bar. Test the waters by first presenting the fix as an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8499c2c896d61295bd16e3c134140b4e72b522" translate="yes" xml:space="preserve">
          <source>Occasionally there may be simple issues with old or bad installations of NumPy. In this case you may just try to uninstall and reinstall NumPy. Make sure that NumPy is not found after uninstalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8a40208cbec6893957fea3d09da8c32d4bb67b" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing the quotient and remainder.</source>
          <target state="translated">de los coeficientes de la serie Chebyshev que representan el cociente y el resto.</target>
        </trans-unit>
        <trans-unit id="95a193973a1a38f794d62d2292b358ed61a158d4" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their difference.</source>
          <target state="translated">de los coeficientes de la serie Chebyshev que representan su diferencia.</target>
        </trans-unit>
        <trans-unit id="f6f11800879153b66dc0982f5c4e19a52fd99bfd" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their product.</source>
          <target state="translated">de los coeficientes de la serie Chebyshev que representan su producto.</target>
        </trans-unit>
        <trans-unit id="1e744292f68f81ff06c4af2891c2284d51276990" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing the quotient and remainder.</source>
          <target state="translated">de los coeficientes de la serie de Hermite que representan el cociente y el resto.</target>
        </trans-unit>
        <trans-unit id="68e73a174e70afa8021e3a5b69b172f5340b60a0" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their difference.</source>
          <target state="translated">de los coeficientes de la serie de Hermite que representan su diferencia.</target>
        </trans-unit>
        <trans-unit id="584dca0bbf2ee8dea79e52251025d455fc466309" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their product.</source>
          <target state="translated">de los coeficientes de la serie de Hermite que representan su producto.</target>
        </trans-unit>
        <trans-unit id="f835afbe8ca3fee3a7aaf7264b53bfe89607c7f1" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing the quotient and remainder.</source>
          <target state="translated">de los coeficientes de la serie de Laguerre que representan el cociente y el resto.</target>
        </trans-unit>
        <trans-unit id="90b47b338ded7c0b1d451aae2b6b202ac054bd26" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their difference.</source>
          <target state="translated">de los coeficientes de la serie de Laguerre que representan su diferencia.</target>
        </trans-unit>
        <trans-unit id="9b96161c3659cfd1e35cc2549dc17860026b7cdc" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their product.</source>
          <target state="translated">de los coeficientes de la serie de Laguerre que representan su producto.</target>
        </trans-unit>
        <trans-unit id="bd7f06a962c25e759bd9ef64c710ec6053768d88" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing the quotient and remainder.</source>
          <target state="translated">de los coeficientes de la serie Legendre que representan el cociente y el resto.</target>
        </trans-unit>
        <trans-unit id="3059e37623b23a53a523c2b1352662c0102ac1da" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their difference.</source>
          <target state="translated">de los coeficientes de la serie Legendre que representan su diferencia.</target>
        </trans-unit>
        <trans-unit id="50248795d9f87718e76bae1fc0c734509f84b250" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their product.</source>
          <target state="translated">de los coeficientes de la serie Legendre que representan su producto.</target>
        </trans-unit>
        <trans-unit id="d8427b6e14c2b373d5a6dab581028bfc5f363679" translate="yes" xml:space="preserve">
          <source>Of coefficient series representing the quotient and remainder.</source>
          <target state="translated">de series de coeficientes que representan el cociente y el resto.</target>
        </trans-unit>
        <trans-unit id="d290318bfec96b6b8a0b5657cb6aa25c8656f248" translate="yes" xml:space="preserve">
          <source>Of coefficients representing their difference.</source>
          <target state="translated">de coeficientes que representan su diferencia.</target>
        </trans-unit>
        <trans-unit id="6a85fe85cc5899aa41f4c1b4360a890de25aa1af" translate="yes" xml:space="preserve">
          <source>Of course you&amp;rsquo;ll need to replace &lt;code&gt;Your Name&lt;/code&gt; and &lt;code&gt;you@yourdomain.example.com&lt;/code&gt; with your actual name and email address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3f315ee6b4ab53b8b92ba8326227f97899e80b" translate="yes" xml:space="preserve">
          <source>Of course, a test can be unconditionally skipped or marked as a known failure by using &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;xfail&lt;/code&gt; without argument, respectively.</source>
          <target state="translated">Por supuesto, una prueba se puede omitir incondicionalmente o marcar como una falla conocida usando &lt;code&gt;skip&lt;/code&gt; o &lt;code&gt;xfail&lt;/code&gt; sin argumento, respectivamente.</target>
        </trans-unit>
        <trans-unit id="fbcd4dc2b30c5efc09e8b8e0ac34e1195e3be111" translate="yes" xml:space="preserve">
          <source>Of course, this is not the best method to &lt;em&gt;approximate&lt;/em&gt; an image. However, there is, in fact, a result in linear algebra that says that the approximation we built above is the best we can get to the original matrix in terms of the norm of the difference. For more information, see &lt;em&gt;G. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a45899d21a287f8cee5fcbf7d53b28d2a2524" translate="yes" xml:space="preserve">
          <source>Of the coefficients of their product.</source>
          <target state="translated">de los coeficientes de su producto.</target>
        </trans-unit>
        <trans-unit id="609c29eaa3c81a7bde19a799569654e9420a8d39" translate="yes" xml:space="preserve">
          <source>Offset into a memmap:</source>
          <target state="translated">Compensar en un mapa de notas:</target>
        </trans-unit>
        <trans-unit id="0bc2c6922816779fd173b29551f1ab7c3175a4b8" translate="yes" xml:space="preserve">
          <source>Offset is limited to C int, which is signed and usually 32 bits. If present, the optional title can be any object (if it is a string or unicode then it will also be a key in the fields dictionary, otherwise it&amp;rsquo;s meta-data). Notice also that the first two elements of the tuple can be passed directly as arguments to the &lt;code&gt;ndarray.getfield&lt;/code&gt; and &lt;code&gt;ndarray.setfield&lt;/code&gt; methods.</source>
          <target state="translated">El desplazamiento est&amp;aacute; limitado a C int, que tiene signo y suele ser de 32 bits. Si est&amp;aacute; presente, el t&amp;iacute;tulo opcional puede ser cualquier objeto (si es una cadena o unicode, tambi&amp;eacute;n ser&amp;aacute; una clave en el diccionario de campos; de lo contrario, son metadatos). Observe tambi&amp;eacute;n que los dos primeros elementos de la tupla se pueden pasar directamente como argumentos a los m&amp;eacute;todos &lt;code&gt;ndarray.getfield&lt;/code&gt; y &lt;code&gt;ndarray.setfield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ce02382c3cd06f8561677ae11ec555fdb1fe4e" translate="yes" xml:space="preserve">
          <source>Offset of array data in buffer.</source>
          <target state="translated">Desplazamiento de los datos de la matriz en el buffer.</target>
        </trans-unit>
        <trans-unit id="680177996996fd2c23e4d0d5181bef8478a843b3" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</source>
          <target state="translated">Desplazamiento de la diagonal de la diagonal principal.Puede ser tanto positivo como negativo.Por defecto es 0.</target>
        </trans-unit>
        <trans-unit id="6b6b5a41310e8f5b4f7075c43a048e4d2e50484a" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be positive or negative. Defaults to main diagonal (0).</source>
          <target state="translated">Desplazamiento de la diagonal de la diagonal principal.Puede ser positivo o negativo.Por defecto a la diagonal principal (0).</target>
        </trans-unit>
        <trans-unit id="efcd2ae12c66734a66a7aa79ae569a447152e17b" translate="yes" xml:space="preserve">
          <source>Offset position in the file.</source>
          <target state="translated">Posición de desplazamiento en el archivo.</target>
        </trans-unit>
        <trans-unit id="e5143224a659eeda117fd7431883f438f099ac14" translate="yes" xml:space="preserve">
          <source>Offsets in bytes, here 0 and 25:</source>
          <target state="translated">Compensaciones en bytes,aquí 0 y 25:</target>
        </trans-unit>
        <trans-unit id="c9a4dc99b78136ab2e2bc1eee5d9d7344239f777" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;a href=&quot;../reference/arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;numpy.object_&lt;/code&gt;&lt;/a&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7329966e05964c08e33b7a47b16c9992cb5a4adf" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;code&gt;numpy.object&lt;/code&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967a38eb8129ad7778f2c9f5678f5fdf3c82cadb" translate="yes" xml:space="preserve">
          <source>Often it is preferable to use a boolean mask. For example:</source>
          <target state="translated">A menudo es preferible usar una máscara booleana.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6904502646c7743d277053efc8b47079c56c46bb" translate="yes" xml:space="preserve">
          <source>Often seen in method signatures, &lt;code&gt;self&lt;/code&gt; refers to the instance of the associated class. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b563fa4cc80accab04bf13505ac3eb5aa2b458" translate="yes" xml:space="preserve">
          <source>Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f9c3f125b2ae3755f9cc2e88d97945e0b2e6b1" translate="yes" xml:space="preserve">
          <source>Old, no conjugate, version of correlate.</source>
          <target state="translated">Antiguo,no conjugado,versión de correlación.</target>
        </trans-unit>
        <trans-unit id="22b35a56584d02836f725dd51b4643aaa3081190" translate="yes" xml:space="preserve">
          <source>Older Equivalent</source>
          <target state="translated">Equivalente más antiguo</target>
        </trans-unit>
        <trans-unit id="a2240253307fec1cb9e7de6b2b992423b8538bf0" translate="yes" xml:space="preserve">
          <source>On AArch64 &lt;code&gt;NEON&lt;/code&gt;&lt;code&gt;FP16&lt;/code&gt;&lt;code&gt;VFPV4&lt;/code&gt;&lt;code&gt;ASIMD&lt;/code&gt; implies each other since they are part of the hardware baseline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950780760d17e16ea15a84017774640eae55ce02" translate="yes" xml:space="preserve">
          <source>On Unix-like machines, reads from &lt;code&gt;/dev/urandom&lt;/code&gt;. On Windows machines reads from the RSA algorithm provided by the cryptographic service provider.</source>
          <target state="translated">En m&amp;aacute;quinas similares a Unix, lee desde &lt;code&gt;/dev/urandom&lt;/code&gt; . En m&amp;aacute;quinas con Windows, lee el algoritmo RSA proporcionado por el proveedor de servicios criptogr&amp;aacute;ficos.</target>
        </trans-unit>
        <trans-unit id="2d3188b9edd47b7b8e155f7d62759b49e4bbd63c" translate="yes" xml:space="preserve">
          <source>On array access use the &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; function pointer instead of the standard conversion to an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">En el acceso a la matriz, use el puntero de funci&amp;oacute;n &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; en lugar de la conversi&amp;oacute;n est&amp;aacute;ndar a un escalar de matriz. Debe usarse si no define un escalar de matriz para que coincida con el tipo de datos.</target>
        </trans-unit>
        <trans-unit id="4dcefd1cec20f7966d92a38bf6e10deb907560ec" translate="yes" xml:space="preserve">
          <source>On compilers which support a #warning mechanism, NumPy issues a compiler warning if you do not define the symbol NPY_NO_DEPRECATED_API. This way, the fact that there are deprecations will be flagged for third-party developers who may not have read the release notes closely.</source>
          <target state="translated">En los compiladores que soportan un mecanismo de alerta #,NumPy emite una advertencia de compilador si no se define el símbolo NPY_NO_DEPRECATED_API.De esta manera,el hecho de que hay deprecaciones será marcado para los desarrolladores de terceros que no hayan leído las notas de lanzamiento con atención.</target>
        </trans-unit>
        <trans-unit id="3a15f70253da2dd06321b41b01d9ced818944641" translate="yes" xml:space="preserve">
          <source>On ppc64le &lt;code&gt;VSX(ISA 2.06)&lt;/code&gt; and &lt;code&gt;VSX2(ISA 2.07)&lt;/code&gt; both imply one another since the first generation that supports little-endian mode is Power-8`(ISA 2.07)`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c713072ca3a05590ed7b22ab2b7c84fab6d46af9" translate="yes" xml:space="preserve">
          <source>On some platforms (&lt;em&gt;e.g.&lt;/em&gt; Windows), a shared library requires a .def file that specifies the functions to be exported. For example a mylib.def file might contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b6987bb053c195d4d4a88861df5cc0bec8c735" translate="yes" xml:space="preserve">
          <source>On the other hand, coolhelper.c would contain at the top:</source>
          <target state="translated">Por otro lado,coolhelper.c contendría en la parte superior:</target>
        </trans-unit>
        <trans-unit id="8e10b67ab476fcac9d1e17bd9eaadbb9eeb769ca" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97323f6987cba1f587e924c7a9998279536c754" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;code&gt;row_stack&lt;/code&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;code&gt;row_stack&lt;/code&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8085f065b43ca0612f8f5a0dd702c78428f8a7" translate="yes" xml:space="preserve">
          <source>On this machine, building the .pyx file into a module looked like the following, but you may have to find some Cython tutorials to tell you the specifics for your system configuration.:</source>
          <target state="translated">En esta máquina,la construcción del archivo .pyx en un módulo se parecía a lo siguiente,pero es posible que tengas que encontrar algunos tutoriales de Cython que te digan los detalles de la configuración de tu sistema..:</target>
        </trans-unit>
        <trans-unit id="9a506ebe097fd976b21e552ba29fd40b62947df8" translate="yes" xml:space="preserve">
          <source>Once a busdaycalendar object is created, the weekmask and holidays cannot be modified.</source>
          <target state="translated">Una vez que se crea un objeto del calendario del autobús,la máscara de la semana y los días festivos no pueden ser modificados.</target>
        </trans-unit>
        <trans-unit id="eba82deb0932802c527a81a17b1d4d366fc0af03" translate="yes" xml:space="preserve">
          <source>Once a new &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure is created and filled with the needed information and useful functions you call &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterDataType&quot;&gt;&lt;code&gt;PyArray_RegisterDataType&lt;/code&gt;&lt;/a&gt; (new_descr). The return value from this call is an integer providing you with a unique type_number that specifies your data-type. This type number should be stored and made available by your module so that other modules can use it to recognize your data-type (the other mechanism for finding a user-defined data-type number is to search based on the name of the type-object associated with the data-type using &lt;code&gt;PyArray_TypeNumFromName&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5183e36c12674d881f64d8eaa0dea9c0fa03d80d" translate="yes" xml:space="preserve">
          <source>Once a resolution is agreed upon, but before it is enacted, the committee will contact the original reporter and any other affected parties and explain the proposed resolution. The committee will ask if this resolution is acceptable, and must note feedback for the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d441f19f98ee4b31cf802d2cbf0a4fb74d4c8d91" translate="yes" xml:space="preserve">
          <source>Once everything seems satisfactory, commit and upload the changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc2ddc32e9564a57768ba3eb61dec0741c722ab" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;numpy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8ca7f94183ec448b711283a3a7fa64f6c8872" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="translated">Una vez que se &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; es posible ejecutar las pruebas yendo al directorio &lt;code&gt;tests/&lt;/code&gt; y escribiendo:</target>
        </trans-unit>
        <trans-unit id="ac70209362afce77775660280fe98f52f86f930f" translate="yes" xml:space="preserve">
          <source>Once the SeedSequence is instantiated, you can call the &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt;&lt;code&gt;generate_state&lt;/code&gt;&lt;/a&gt; method to get an appropriately sized seed. Calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn(n)&lt;/code&gt;&lt;/a&gt; will create &lt;code&gt;n&lt;/code&gt; SeedSequences that can be used to seed independent BitGenerators, i.e. for different threads.</source>
          <target state="translated">Una vez que se crea una instancia de SeedSequence, puede llamar al m&amp;eacute;todo &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt; &lt;code&gt;generate_state&lt;/code&gt; &lt;/a&gt; para obtener una semilla de tama&amp;ntilde;o adecuado. Llamar a &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn(n)&lt;/code&gt; &lt;/a&gt; crear&amp;aacute; &lt;code&gt;n&lt;/code&gt; SeedSequences que se pueden usar para generar BitGenerators independientes, es decir, para diferentes subprocesos.</target>
        </trans-unit>
        <trans-unit id="9b8c845df2375661d6c8904939512353e20ecd41" translate="yes" xml:space="preserve">
          <source>Once the conversions to the appropriate C-structures and C data-types have been performed, the next step in the wrapper is to call the underlying function. This is straightforward if the underlying function is in C or C++. However, in order to call Fortran code you must be familiar with how Fortran subroutines are called from C/C++ using your compiler and platform. This can vary somewhat platforms and compilers (which is another reason f2py makes life much simpler for interfacing Fortran code) but generally involves underscore mangling of the name and the fact that all variables are passed by reference (i.e. all arguments are pointers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd5de6f03a0c2c385081a0d6f534ba7e379838a" translate="yes" xml:space="preserve">
          <source>Once the file is defined and open for reading, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; splits each non-empty line into a sequence of strings. Empty or commented lines are just skipped. The &lt;code&gt;delimiter&lt;/code&gt; keyword is used to define how the splitting should take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7cac8dde7cbe137262c702e77fb0ca9ad5356" translate="yes" xml:space="preserve">
          <source>Once the header is parsed by &lt;code&gt;ffi.cdef&lt;/code&gt;, the functions can be accessed directly from the &lt;code&gt;_generator&lt;/code&gt; shared object, using the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator.cffi#numpy.random.BitGenerator.cffi&quot;&gt;&lt;code&gt;BitGenerator.cffi&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e905cb6480a6fdb98cbdeb00114c7de3f9ecca" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231d4308334f05ae25082dce13bc3cf1e18cdbf8" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="translated">Una vez que el iterador est&amp;aacute; preparado para la iteraci&amp;oacute;n (despu&amp;eacute;s de un reinicio si se us&amp;oacute; &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; ), llame a esto para obtener los pasos que pueden usarse para seleccionar una funci&amp;oacute;n de bucle interno r&amp;aacute;pido. Por ejemplo, si el paso es 0, eso significa que el bucle interno siempre puede cargar su valor en una variable una vez, luego usar la variable en todo el bucle, o si el paso es igual al tama&amp;ntilde;o del elemento, se puede usar una versi&amp;oacute;n contigua para ese operando.</target>
        </trans-unit>
        <trans-unit id="c04dbd1660afe1562d16b591f18b1bb40507aaa1" translate="yes" xml:space="preserve">
          <source>Once the spam module is imported into python, you can call logit via spam.logit. Note that the function used above cannot be applied as-is to numpy arrays. To do so we must call numpy.vectorize on it. For example, if a python interpreter is opened in the file containing the spam library or spam has been installed, one can perform the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78ec319a64fd7535ba4d9ce2b45a93a3eddd1ea" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993e871933c3573c232eaa172843213039b4efd1" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors, go back to your numpy repository in the maintenance branch and tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44934f86865426c152af6fe43faca7909cb74599" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your arrays, you can start to work with them. Let&amp;rsquo;s say, for example, that you&amp;rsquo;ve created two arrays, one called &amp;ldquo;data&amp;rdquo; and one called &amp;ldquo;ones&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c392b0b03965e8b7e58ba06da44426e1525511" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your matrices, you can add and multiply them using arithmetic operators if you have two matrices that are the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77517b16ad949bec662df3d2780dff01b3a28d3c" translate="yes" xml:space="preserve">
          <source>One Loop</source>
          <target state="translated">Un bucle</target>
        </trans-unit>
        <trans-unit id="fb74c341b98c307818ac342dee77af9f705b8e7e" translate="yes" xml:space="preserve">
          <source>One big advantage of Cython-generated extension modules is that they are easy to distribute. In summary, Cython is a very capable tool for either gluing C code or generating an extension module quickly and should not be over-looked. It is especially useful for people that can&amp;rsquo;t or won&amp;rsquo;t write C or Fortran code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91705b60cf41602239345b05e981d551e6358c23" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444c9c354929cf1b3a58f15b3f0b2168f58f68f7" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8524b74ddf89508f43aa1069be40f8c206f86f89" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;code&gt;BitGenerator&lt;/code&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n se puede crear una instancia de &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; directamente con una instancia de &lt;code&gt;BitGenerator&lt;/code&gt; . Para utilizar el algoritmo &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; anterior , se puede crear una instancia directamente y pasarlo a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="070709f2e07ce3e32b6abdd9998a1049f1bd5e84" translate="yes" xml:space="preserve">
          <source>One can index and assign to a structured array with a multi-field index, where the index is a list of field names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3340151bf466504ea342e74247a72d1486385a" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; to declare a more general ufunc. The argument list is the same as &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;, with an additional argument specifying the signature as C string.</source>
          <target state="translated">Se puede usar &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; para declarar un ufunc m&amp;aacute;s general. La lista de argumentos es la misma que &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; , con un argumento adicional que especifica la firma como una cadena C.</target>
        </trans-unit>
        <trans-unit id="e6a96a24425a79d2472bdd027a95e9628f8491bc" translate="yes" xml:space="preserve">
          <source>One can use different values for optional &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c665d4f58d5aed156c11bf302a241bec2c3bfe" translate="yes" xml:space="preserve">
          <source>One cannot mix negation and positives, nor have multiple negations, such cases will raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56899b43e5156c96d1005f04cd69878206c68abd" translate="yes" xml:space="preserve">
          <source>One common algorithmic requirement is to be able to walk over all elements in a multidimensional array. The array iterator object makes this easy to do in a generic way that works for arrays of any dimension. Naturally, if you know the number of dimensions you will be using, then you can always write nested for loops to accomplish the iteration. If, however, you want to write code that works with any number of dimensions, then you can make use of the array iterator. An array iterator object is returned when accessing the .flat attribute of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81089507935f358c69911644b087b72a2a0a612b" translate="yes" xml:space="preserve">
          <source>One common source of reference-count errors is the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt; function. Pay careful attention to the difference between the &amp;lsquo;N&amp;rsquo; format character and the &amp;lsquo;O&amp;rsquo; format character. If you create a new object in your subroutine (such as an output array), and you are passing it back in a tuple of return values, then you should most- likely use the &amp;lsquo;N&amp;rsquo; format character in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt;. The &amp;lsquo;O&amp;rsquo; character will increase the reference count by one. This will leave the caller with two reference counts for a brand-new array. When the variable is deleted and the reference count decremented by one, there will still be that extra reference count, and the array will never be deallocated. You will have a reference-counting induced memory leak. Using the &amp;lsquo;N&amp;rsquo; character will avoid this situation as it will return to the caller an object (inside the tuple) with a single reference count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d4e9404ec123b91b7f0181eb9f23e04fe59bd2" translate="yes" xml:space="preserve">
          <source>One deviation from the current behavior of &lt;code&gt;__array_ufunc__&lt;/code&gt; is that NumPy will only call &lt;code&gt;__array_function__&lt;/code&gt; on the &lt;em&gt;first&lt;/em&gt; argument of each unique type. This matches Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;rule for calling reflected methods&lt;/a&gt;, and this ensures that checking overloads has acceptable performance even when there are a large number of overloaded arguments.</source>
          <target state="translated">Una desviaci&amp;oacute;n del comportamiento actual de &lt;code&gt;__array_ufunc__&lt;/code&gt; es que NumPy solo llamar&amp;aacute; a &lt;code&gt;__array_function__&lt;/code&gt; en el &lt;em&gt;primer&lt;/em&gt; argumento de cada tipo &amp;uacute;nico. Esto coincide con la &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;regla&lt;/a&gt; de Python para llamar a m&amp;eacute;todos reflejados , y esto asegura que la verificaci&amp;oacute;n de sobrecargas tenga un rendimiento aceptable incluso cuando hay una gran cantidad de argumentos sobrecargados.</target>
        </trans-unit>
        <trans-unit id="b47e08224aaf497fafd8b89783b8a17e95a05214" translate="yes" xml:space="preserve">
          <source>One dimensional array:</source>
          <target state="translated">Una matriz unidimensional:</target>
        </trans-unit>
        <trans-unit id="bbfcf4855e8547b3c2c018358506a526943e1c9a" translate="yes" xml:space="preserve">
          <source>One fundamental aspect of the ndarray is that an array is seen as a &amp;ldquo;chunk&amp;rdquo; of memory starting at some location. The interpretation of this memory depends on the stride information. For each dimension in an</source>
          <target state="translated">Un aspecto fundamental del ndarray es que una matriz se ve como un &quot;trozo&quot; de memoria que comienza en alguna ubicaci&amp;oacute;n. La interpretaci&amp;oacute;n de este recuerdo depende de la informaci&amp;oacute;n del paso. Para cada dimensi&amp;oacute;n en un</target>
        </trans-unit>
        <trans-unit id="16275c9ae04e235f8070983e66409df72503b036" translate="yes" xml:space="preserve">
          <source>One is returned for slices that are all-NaN or empty.</source>
          <target state="translated">Uno se devuelve por las rebanadas que están todas-NaN o vacías.</target>
        </trans-unit>
        <trans-unit id="e2800fbab71db8fc98d5d383e0fd87d0d933e41f" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;always&amp;rdquo;, &amp;ldquo;once&amp;rdquo;, &amp;ldquo;module&amp;rdquo;, or &amp;ldquo;location&amp;rdquo;. Analogous to the usual warnings module filter mode, it is useful to reduce noise mostly on the outmost level. Unsuppressed and unrecorded warnings will be forwarded based on this rule. Defaults to &amp;ldquo;always&amp;rdquo;. &amp;ldquo;location&amp;rdquo; is equivalent to the warnings &amp;ldquo;default&amp;rdquo;, match by exact location the warning warning originated from.</source>
          <target state="translated">Uno de &quot;siempre&quot;, &quot;una vez&quot;, &quot;m&amp;oacute;dulo&quot; o &quot;ubicaci&amp;oacute;n&quot;. De manera an&amp;aacute;loga al modo de filtro del m&amp;oacute;dulo de advertencias habitual, es &amp;uacute;til reducir el ruido principalmente en el nivel m&amp;aacute;s externo. Las advertencias no suprimidas y no grabadas se reenviar&amp;aacute;n seg&amp;uacute;n esta regla. Por defecto es &quot;siempre&quot;. &quot;Ubicaci&amp;oacute;n&quot; es equivalente a las advertencias &quot;predeterminadas&quot;, coincide con la ubicaci&amp;oacute;n exacta desde la que se origin&amp;oacute; la advertencia.</target>
        </trans-unit>
        <trans-unit id="a089b8e63dd4e8eb30432f942f75f4b932e1fd5a" translate="yes" xml:space="preserve">
          <source>One of None, &amp;lsquo;auto&amp;rsquo;, or a &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt;.</source>
          <target state="translated">Uno de Ninguno, 'autom&amp;aacute;tico' o una &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;unidad de fecha&lt;/a&gt; y hora .</target>
        </trans-unit>
        <trans-unit id="f39ed1de2c370ff6c78c1184ddb58d4c6a6a7345" translate="yes" xml:space="preserve">
          <source>One of the built-in data-types, the void data-type allows for arbitrary structured types containing 1 or more fields as elements of the array. A field is simply another data-type object along with an offset into the current structured type. In order to support arbitrarily nested fields, several recursive implementations of data-type access are implemented for the void type. A common idiom is to cycle through the elements of the dictionary and perform a specific operation based on the data-type object stored at the given offset. These offsets can be arbitrary numbers. Therefore, the possibility of encountering mis- aligned data must be recognized and taken into account if necessary.</source>
          <target state="translated">Uno de los tipos de datos incorporados,el tipo de datos vacío,permite tipos estructurados arbitrarios que contienen 1 o más campos como elementos del conjunto.Un campo es simplemente otro objeto de tipo de datos junto con un desplazamiento en el tipo estructurado actual.Para poder soportar campos anidados arbitrariamente,se implementan varias implementaciones recursivas de acceso al tipo de datos para el tipo de vacío.Una expresión común es recorrer los elementos del diccionario y realizar una operación específica basada en el objeto de tipo de datos almacenado en el desplazamiento dado.Estos desplazamientos pueden ser números arbitrarios.Por lo tanto,la posibilidad de encontrar datos mal alineados debe ser reconocida y tenida en cuenta si es necesario.</target>
        </trans-unit>
        <trans-unit id="7fb71e305de0bd82275b57dccd8d18215eb5533d" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f15581ffc61dc8d280c89c7bfaccc5af8a60a18" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800f0527f171cc2cc2f96013ed1d0d73822e318b" translate="yes" xml:space="preserve">
          <source>One of the enumerated types or &lt;a href=&quot;../reference/c-api/dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; if the data-type should be determined from the object itself. The C-based names can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bb917d30f8e918beefbd1feb7c9a171676de0" translate="yes" xml:space="preserve">
          <source>One of the following string values or a user supplied function.</source>
          <target state="translated">Uno de los siguientes valores de cadena o una función suministrada por el usuario.</target>
        </trans-unit>
        <trans-unit id="c247d033f683cfebb6311017bf9488ea1b3de438" translate="yes" xml:space="preserve">
          <source>One of the lesser-used features that has been lurking in Python since 2.2 is the ability to sub-class types in C. This facility is one of the important reasons for basing NumPy off of the Numeric code-base which was already in C. A sub-type in C allows much more flexibility with regards to memory management. Sub-typing in C is not difficult even if you have only a rudimentary understanding of how to create new types for Python. While it is easiest to sub-type from a single parent type, sub-typing from multiple parent types is also possible. Multiple inheritance in C is generally less useful than it is in Python because a restriction on Python sub-types is that they have a binary compatible memory layout. Perhaps for this reason, it is somewhat easier to sub-type from a single parent type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27403d9ce40c15186aafb846c5de4d2a9de532c0" translate="yes" xml:space="preserve">
          <source>One of the problems that ndarray solves is keeping track of memory ownership of ndarrays and their views. Consider the case where we have created an ndarray, &lt;code&gt;arr&lt;/code&gt; and have taken a slice with &lt;code&gt;v = arr[1:]&lt;/code&gt;. The two objects are looking at the same memory. NumPy keeps track of where the data came from for a particular array or view, with the &lt;code&gt;base&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3967d3ba22f4ac7f4c1ab09bac9634bd847ca9c" translate="yes" xml:space="preserve">
          <source>One of:</source>
          <target state="translated">Uno de:</target>
        </trans-unit>
        <trans-unit id="eb28eadbd381d78c0578e9d33fcdb60f914be747" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have three or more dimensions are preserved.</source>
          <target state="translated">Una o más secuencias similares a una matriz.Las entradas que no son de matriz se convierten en matrices.Las matrices que ya tienen tres o más dimensiones se conservan.</target>
        </trans-unit>
        <trans-unit id="30e8ba24447e6b42366fd8b8bb4f9518361510cc" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have two or more dimensions are preserved.</source>
          <target state="translated">Una o más secuencias similares a una matriz.Las entradas que no son de matriz se convierten en matrices.Las matrices que ya tienen dos o más dimensiones se conservan.</target>
        </trans-unit>
        <trans-unit id="b5ac146eea9a6c289d467e482f8a257b9519c8d8" translate="yes" xml:space="preserve">
          <source>One or more input arrays.</source>
          <target state="translated">Una o más matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="c995dd2d01832787cd57c037ae2c18a3ecd49592" translate="yes" xml:space="preserve">
          <source>One padding, Outside bounds values will be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d567aa2c7888a9ebb9443758e2ad3f65f13a88e0" translate="yes" xml:space="preserve">
          <source>One possibility we can think of is to interpolate the missing data to estimate the number of cases in late January. Observe that we can select the masked elements using the &lt;code&gt;.mask&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4e66d66f3f25393b9b9092b14d986216b8ea91" translate="yes" xml:space="preserve">
          <source>One relatively simple and reliable way to check for the compiler used to build a library is to use ldd on the library. If libg2c.so is a dependency, this means that g77 has been used (note: g77 is no longer supported for building NumPy). If libgfortran.so is a dependency, gfortran has been used. If both are dependencies, this means both have been used, which is almost always a very bad idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6362eba61fec5cf9abb4f9817d64b7cd0aed92b" translate="yes" xml:space="preserve">
          <source>One sees that the &lt;code&gt;super&lt;/code&gt; call, which goes to &lt;code&gt;ndarray.__new__&lt;/code&gt;, passes &lt;code&gt;__array_finalize__&lt;/code&gt; the new object, of our own class (&lt;code&gt;self&lt;/code&gt;) as well as the object from which the view has been taken (&lt;code&gt;obj&lt;/code&gt;). As you can see from the output above, the &lt;code&gt;self&lt;/code&gt; is always a newly created instance of our subclass, and the type of &lt;code&gt;obj&lt;/code&gt; differs for the three instance creation methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ec8922f9be1aeeb6fe45b52431c5e822f5d065" translate="yes" xml:space="preserve">
          <source>One simple way to achieve this is to install the released version in site-packages, by using a binary installer or pip for example, and set up the development version in a virtualenv. First install &lt;a href=&quot;http://www.virtualenv.org/&quot;&gt;virtualenv&lt;/a&gt; (optionally use &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;virtualenvwrapper&lt;/a&gt;), then create your virtualenv (named numpy-dev here) with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bd59e7480ae8ee0b30eea6aab25ec69688345a" translate="yes" xml:space="preserve">
          <source>One thing to watch out for is conversions back to the original data type when using a read-write or write-only operand. A common case is to implement the inner loop in terms of 64-bit floats, and use &amp;lsquo;same_kind&amp;rsquo; casting to allow the other floating-point types to be processed as well. While in read-only mode, an integer array could be provided, read-write mode will raise an exception because conversion back to the array would violate the casting rule.</source>
          <target state="translated">Una cosa a tener en cuenta son las conversiones al tipo de datos original cuando se usa un operando de lectura-escritura o de solo escritura. Un caso com&amp;uacute;n es implementar el bucle interno en t&amp;eacute;rminos de flotantes de 64 bits y usar la conversi&amp;oacute;n 'same_kind' para permitir que los otros tipos de punto flotante tambi&amp;eacute;n se procesen. Mientras que en el modo de solo lectura, se podr&amp;iacute;a proporcionar una matriz de enteros, el modo de lectura y escritura generar&amp;aacute; una excepci&amp;oacute;n porque la conversi&amp;oacute;n de nuevo a la matriz violar&amp;iacute;a la regla de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2cc36f9c20276e56c093db5e52fdeb366528fc58" translate="yes" xml:space="preserve">
          <source>One vector with dimension 2.</source>
          <target state="translated">Un vector con dimensión 2.</target>
        </trans-unit>
        <trans-unit id="99918e2f05caf6cd6ec60dc844a473737b719247" translate="yes" xml:space="preserve">
          <source>One very nice feature of testing is allowing easy testing across a range of parameters - a nasty problem for standard unit tests. Use the &lt;code&gt;dec.paramaterize&lt;/code&gt; decorator.</source>
          <target state="translated">Una caracter&amp;iacute;stica muy interesante de las pruebas es que permite realizar pruebas sencillas en una variedad de par&amp;aacute;metros, un problema desagradable para las pruebas unitarias est&amp;aacute;ndar. Utilice el decorador &lt;code&gt;dec.paramaterize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9c1c4f351a78f93a1ea46f7fb6388f8d6e8ce8" translate="yes" xml:space="preserve">
          <source>One way we can initialize NumPy arrays is from Python lists, using nested lists for two- or higher-dimensional data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd980620fd6bb0d38c87e52f67df303553acf634" translate="yes" xml:space="preserve">
          <source>One-character strings</source>
          <target state="translated">Cuerdas de un solo carácter</target>
        </trans-unit>
        <trans-unit id="7dd48564d3a850a05467a68a151727d64b2ad461" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5131dc464a794c785bc59aee87c51ca82227aaed" translate="yes" xml:space="preserve">
          <source>One-dimensional linear interpolation.</source>
          <target state="translated">Interpolación lineal unidimensional.</target>
        </trans-unit>
        <trans-unit id="cd572fc9dc51ce4fd31312f0bb79afc0c6e4432a" translate="yes" xml:space="preserve">
          <source>One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.</source>
          <target state="translated">Matrices unidimensionales,bidimensionales,tridimensionales y cuatridimensionales.</target>
        </trans-unit>
        <trans-unit id="3b7777f0a5babbc2cd6ca70c30ebaa80abc0442d" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Funciones 1-d de n&amp;uacute;cleo de una entrada, una salida y dos entradas y una salida para el tipo de datos &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; . Estas funciones manejan problemas de recuento de referencias y regresan temprano en caso de error. La funci&amp;oacute;n real para llamar es &lt;em&gt;func&lt;/em&gt; y debe aceptar llamadas con la firma &lt;code&gt;(PyObject*) (PyObject*)&lt;/code&gt; para &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt; &lt;code&gt;PyUFunc_O_O&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;(PyObject*)(PyObject *, PyObject *)&lt;/code&gt; para &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt; &lt;code&gt;PyUFunc_OO_O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1f106f50e29c9c2b8a1ac2b65d27f3773387b3" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd47ce11e1fa9754d28954cfcd5881bbc1273cc" translate="yes" xml:space="preserve">
          <source>Ones and zeros</source>
          <target state="translated">Unos y ceros</target>
        </trans-unit>
        <trans-unit id="cb940bbbd02e7c31b4ae50aac2139276e3822e9f" translate="yes" xml:space="preserve">
          <source>Ones are returned for slices that are all-NaN or empty.</source>
          <target state="translated">Se devuelven las rebanadas que están todas-NaN o vacías.</target>
        </trans-unit>
        <trans-unit id="09f22eb6b2adcce43b85d8b07506fb5c95ab640d" translate="yes" xml:space="preserve">
          <source>Only a few, unrelated commits then prefer rebasing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b697531330130760eafc916bd6f1be5353ebde" translate="yes" xml:space="preserve">
          <source>Only a survey of the choices. Little detail on how each works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addd7b3649a3c34fc344240c254d5a275033117" translate="yes" xml:space="preserve">
          <source>Only accepts 1-D arrays.</source>
          <target state="translated">Sólo acepta matrices 1-D.</target>
        </trans-unit>
        <trans-unit id="bde044c10adb7133cf0f3ad6c4862788f16172f1" translate="yes" xml:space="preserve">
          <source>Only accepts 2-D arrays at most.</source>
          <target state="translated">Sólo acepta matrices 2-D como mucho.</target>
        </trans-unit>
        <trans-unit id="7afe5b0a4d7cbceb0c653cfc81e1d454858d38ee" translate="yes" xml:space="preserve">
          <source>Only allow casts which will not cause values to be rounded, truncated, or otherwise changed.</source>
          <target state="translated">Sólo se permiten los calcos que no causen que los valores se redondeen,trunquen o cambien de otra manera.</target>
        </trans-unit>
        <trans-unit id="c3582e0ecb066430ad3be065ab374165ffa609f3" translate="yes" xml:space="preserve">
          <source>Only allow identical types.</source>
          <target state="translated">Sólo se permiten tipos idénticos.</target>
        </trans-unit>
        <trans-unit id="603519900a2e75cc37ace5a2f71e7c45cdb8b832" translate="yes" xml:space="preserve">
          <source>Only an integer decimal number can be used.</source>
          <target state="translated">Sólo se puede utilizar un número entero decimal.</target>
        </trans-unit>
        <trans-unit id="cae35f53e6308f43d551d7ad3a2026ad04e15e23" translate="yes" xml:space="preserve">
          <source>Only contiguous arrays (data elements consecutive in memory) can be resized.</source>
          <target state="translated">Sólo los conjuntos contiguos (elementos de datos consecutivos en la memoria)pueden ser redimensionados.</target>
        </trans-unit>
        <trans-unit id="e992238c6b6cf34041def067b036cda1362cc0ed" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled.</source>
          <target state="translated">Sólo se manejan los tipos enteros y booleanos.</target>
        </trans-unit>
        <trans-unit id="ce974e565e6e54262541b566a10f88e312bc9462" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Solo se manejan los tipos enteros y booleanos. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="7329167d275db4d33debe4e1e78cc7c194228992" translate="yes" xml:space="preserve">
          <source>Only on intel (windows?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e46a9dd5cfa9d4541737997e2a69c528376429" translate="yes" xml:space="preserve">
          <source>Only return the middle values of the convolution. Contains boundary effects, where zeros are taken into account:</source>
          <target state="translated">Sólo devuelve los valores medios de la convolución.Contiene efectos de límite,donde se tienen en cuenta los ceros:</target>
        </trans-unit>
        <trans-unit id="c646c2238b413bc43301092aedff89ef1f867724" translate="yes" xml:space="preserve">
          <source>Only returned if &lt;code&gt;retstep&lt;/code&gt; is True</source>
          <target state="translated">Solo se devuelve si &lt;code&gt;retstep&lt;/code&gt; es True</target>
        </trans-unit>
        <trans-unit id="e429b326ee86d54ede5217418c8826c4e767d391" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt;&lt;code&gt;ndarray.setflags&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El usuario solo puede cambiar los indicadores WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE y ALIGNED, mediante la asignaci&amp;oacute;n directa al atributo o entrada de diccionario, o llamando a &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt; &lt;code&gt;ndarray.setflags&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8823766a1477c99c5d6107c4aad19cb79aa3fe" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;code&gt;ndarray.setflags&lt;/code&gt;.</source>
          <target state="translated">El usuario solo puede cambiar los indicadores WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE y ALIGNED, mediante la asignaci&amp;oacute;n directa al atributo o entrada de diccionario, o llamando a &lt;code&gt;ndarray.setflags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14128c80bfe87033c27d2c8a406f61e4d63d6d90" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked by default.</source>
          <target state="translated">Sólo los límites de memoria de a y b están marcados por defecto.</target>
        </trans-unit>
        <trans-unit id="a133ec60f230a1d745372bd29522c9608116df62" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked.</source>
          <target state="translated">Sólo se comprueban los límites de memoria de a y b.</target>
        </trans-unit>
        <trans-unit id="2828ce3af0ec6cf22589ee67ae2d61139d97726f" translate="yes" xml:space="preserve">
          <source>Only used in &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt; to over-ride the byteorder of the data-type object passed in.</source>
          <target state="translated">Solo se usa en &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt; para anular el orden de bytes del objeto de tipo de datos pasado.</target>
        </trans-unit>
        <trans-unit id="c499db64f45476fb60b7a934c6b0e9eae67b09aa" translate="yes" xml:space="preserve">
          <source>Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">Solo es &amp;uacute;til para obligar a que los objetos de las matrices de objetos en Python 3 sean decapados de una manera compatible con Python 2. Si &lt;code&gt;fix_imports&lt;/code&gt; es True, pickle intentar&amp;aacute; asignar los nuevos nombres de Python 3 a los nombres de m&amp;oacute;dulos antiguos utilizados en Python 2, de modo que el flujo de datos de pickle sea legible con Python 2.</target>
        </trans-unit>
        <trans-unit id="9be2bb2a7cf937c49df50863791a7e2b8e618032" translate="yes" xml:space="preserve">
          <source>Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the old Python 2 names to the new names used in Python 3.</source>
          <target state="translated">Solo es &amp;uacute;til cuando se cargan archivos encurtidos generados por Python 2 en Python 3, que incluye archivos npy / npz que contienen matrices de objetos. Si &lt;code&gt;fix_imports&lt;/code&gt; es True, pickle intentar&amp;aacute; asignar los nombres antiguos de Python 2 a los nuevos nombres utilizados en Python 3.</target>
        </trans-unit>
        <trans-unit id="284f33151b0cb79968c40e4b088e6fb638c9882a" translate="yes" xml:space="preserve">
          <source>Open a .npy file as a memory-mapped array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ffc3b0833d539654e5ad58b641d1cef1d2a7bc" translate="yes" xml:space="preserve">
          <source>Open and return file-like object.</source>
          <target state="translated">Abrir y devolver un objeto en forma de archivo.</target>
        </trans-unit>
        <trans-unit id="bb7abb02e2506f465eda9d56007ed5a7e2b0bd98" translate="yes" xml:space="preserve">
          <source>Open existing file for reading and writing.</source>
          <target state="translated">Abrir el archivo existente para leer y escribir.</target>
        </trans-unit>
        <trans-unit id="bd185b75f1b59e945b739489c944a7512ff51fd8" translate="yes" xml:space="preserve">
          <source>Open existing file for reading only.</source>
          <target state="translated">Abra el archivo existente sólo para leerlo.</target>
        </trans-unit>
        <trans-unit id="96179d121ec9cf7124c6c2755cce0f345158530b" translate="yes" xml:space="preserve">
          <source>Open file object or filename.</source>
          <target state="translated">Abrir el objeto o el nombre del archivo.</target>
        </trans-unit>
        <trans-unit id="a6f0b5cd06c0857fa1094ec1c01c44ffc62a3722" translate="yes" xml:space="preserve">
          <source>Open text file with given encoding. The default encoding will be what &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="translated">Abrir archivo de texto con la codificaci&amp;oacute;n dada. La codificaci&amp;oacute;n predeterminada ser&amp;aacute; la que use &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="988a0621a69f95c126d429edd6ad72b8b9753d30" translate="yes" xml:space="preserve">
          <source>OpenBLAS</source>
          <target state="translated">OpenBLAS</target>
        </trans-unit>
        <trans-unit id="9e6729afd8b62e6a17fee3a65c668dbe74656c3a" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 with &lt;code&gt;64_&lt;/code&gt; symbol suffix (&lt;code&gt;openblas64_&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db258279bc027edbc14a901c4f72c25179352f5" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 without symbol suffix (&lt;code&gt;openblas_ilp64&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9413e771602d364356d827e1ba5484c54b2980c" translate="yes" xml:space="preserve">
          <source>OpenGL Half Float Pixel Support</source>
          <target state="translated">Soporte de medio píxel de flotación OpenGL</target>
        </trans-unit>
        <trans-unit id="92b199ce7b8a6cd2b986683aff11b8b6f7fca3cd" translate="yes" xml:space="preserve">
          <source>Openness &amp;amp; Transparency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="802737eaf4ae404056a43d4b36a403eb607a4663" translate="yes" xml:space="preserve">
          <source>Operations on an axis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba63388b76fb2354877e0a00827567f3e7dd9beb" translate="yes" xml:space="preserve">
          <source>Operations on masked arrays</source>
          <target state="translated">Operaciones en conjuntos enmascarados</target>
        </trans-unit>
        <trans-unit id="52f32163af2ed7163e716ed54ad45e1abac6d362" translate="yes" xml:space="preserve">
          <source>Operations on masks</source>
          <target state="translated">Operaciones con máscaras</target>
        </trans-unit>
        <trans-unit id="ee87ced5cf49f6083697398814cf1d512f44d6ad" translate="yes" xml:space="preserve">
          <source>Operations on np.memmap objects return numpy arrays in most cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36cb408f625975bc7da03d4112be652fbd5e3b3" translate="yes" xml:space="preserve">
          <source>Operations where ufunc input and output operands have memory overlap are defined to be the same as for equivalent operations where there is no memory overlap. Operations affected make temporary copies as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result in needless temporary copies. For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary. As an example, &lt;code&gt;np.add(a, b, out=a)&lt;/code&gt; will not involve copies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca78838064bd04174cc1a2b7101984f13a328d5" translate="yes" xml:space="preserve">
          <source>Operators &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;, functions &lt;code&gt;dot()&lt;/code&gt;, and &lt;code&gt;multiply()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0563fccbe64a1dfd8037f51262c4fd0530cd94" translate="yes" xml:space="preserve">
          <source>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="translated">Oppenheim,A.V.y R.W.Schafer.Procesamiento de señales en tiempo discreto.Upper Saddle River,NJ:Prentice-Hall,1999,págs.468-471.</target>
        </trans-unit>
        <trans-unit id="dc6761ca91dcee4424a2851cbb50045197345e3f" translate="yes" xml:space="preserve">
          <source>Optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (best usage pattern in some use cases): ~110ms</source>
          <target state="translated">&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; &amp;oacute;ptimo (mejor patr&amp;oacute;n de uso en algunos casos de uso): ~ 110 ms</target>
        </trans-unit>
        <trans-unit id="14a620b1a39a0c10e2201e1aff4cc0715f2dfce6" translate="yes" xml:space="preserve">
          <source>Optimization names can be CPU features or groups of features that gather several features or &lt;a href=&quot;#special-options&quot;&gt;special options&lt;/a&gt; to perform a series of procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6005faa183a89f9948e43f5a980447b421fb158" translate="yes" xml:space="preserve">
          <source>Optimizations for operations of the form &lt;code&gt;A.T @ A&lt;/code&gt; and &lt;code&gt;A @ A.T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a9abbcaa67a245b7df3c4aa99c089ac4fab21b" translate="yes" xml:space="preserve">
          <source>Optimizing a looping block by specialized code. In a traditional sense, vectorization performs the same operation on multiple elements with fixed strides between them via specialized hardware. Compilers know how to take advantage of well-constructed loops to implement such optimizations. NumPy uses &lt;a href=&quot;user/whatisnumpy#whatis-vectorization&quot;&gt;vectorization&lt;/a&gt; to mean any optimization via specialized code performing the same operations on multiple elements, typically achieving speedups by avoiding some of the overhead in looking up and converting the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92272bcec6c59382899a85edc8fe1911432803d7" translate="yes" xml:space="preserve">
          <source>Option whether to print a line feed or not. Defaults to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1be0f36b97d1f66b6be8a1b7591fde1a83a0d94" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;axis&lt;/code&gt; argument for methods like &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;permutation&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; that controls which axis an operation is performed over for multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8be51f4f30d13faa44a6de0502a01108e24089" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;dtype&lt;/code&gt; argument that accepts &lt;code&gt;np.float32&lt;/code&gt; or &lt;code&gt;np.float64&lt;/code&gt; to produce either single or double prevision uniform random variables for select distributions</source>
          <target state="translated">Argumento &lt;code&gt;dtype&lt;/code&gt; opcional que acepta &lt;code&gt;np.float32&lt;/code&gt; o &lt;code&gt;np.float64&lt;/code&gt; para producir variables aleatorias uniformes de previsi&amp;oacute;n simple o doble para distribuciones seleccionadas</target>
        </trans-unit>
        <trans-unit id="12126826f76c7f0467a4ffb91534c1d1ec680e4d" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;out&lt;/code&gt; argument that allows existing arrays to be filled for select distributions</source>
          <target state="translated">Argumento de &lt;code&gt;out&lt;/code&gt; opcional que permite completar matrices existentes para distribuciones seleccionadas</target>
        </trans-unit>
        <trans-unit id="01273e336bfe0a367b1748fe162d52aafeac5e31" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as in slice notation.</source>
          <target state="translated">Los argumentos opcionales &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; se interpretan en notaci&amp;oacute;n de sector.</target>
        </trans-unit>
        <trans-unit id="ad0126e97a8970efb03fe063de9451fa05d68f3f" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as slice notation to specify the range in which to count.</source>
          <target state="translated">Los argumentos opcionales &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; se interpretan como notaci&amp;oacute;n de sector para especificar el rango en el que contar.</target>
        </trans-unit>
        <trans-unit id="4dd32917dfd5f66fb159ebdd50889a1b4bed7749" translate="yes" xml:space="preserve">
          <source>Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.</source>
          <target state="translated">Matriz opcional de índices enteros que ordenan la matriz a en orden ascendente.Son típicamente el resultado de argsort.</target>
        </trans-unit>
        <trans-unit id="6024e1a91279063fb7e7889daf1b6251045d44cb" translate="yes" xml:space="preserve">
          <source>Optional character strings placed as the first element of the index expression can be used to change the output. The strings &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; result in matrix output. If the result is 1-D and &amp;lsquo;r&amp;rsquo; is specified a 1 x N (row) matrix is produced. If the result is 1-D and &amp;lsquo;c&amp;rsquo; is specified, then a N x 1 (column) matrix is produced. If the result is 2-D then both provide the same matrix result.</source>
          <target state="translated">Las cadenas de caracteres opcionales colocadas como el primer elemento de la expresi&amp;oacute;n de &amp;iacute;ndice se pueden utilizar para cambiar la salida. Las cadenas 'r' o 'c' dan como resultado una salida de matriz. Si el resultado es 1-D y se especifica 'r', se produce una matriz de 1 x N (filas). Si el resultado es 1-D y se especifica 'c', entonces se produce una matriz N x 1 (columna). Si el resultado es 2-D, ambos proporcionan el mismo resultado de matriz.</target>
        </trans-unit>
        <trans-unit id="fa7999c926f6055eca464cd4cd0189771a96574e" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments</source>
          <target state="translated">Argumentos de palabras clave opcionales</target>
        </trans-unit>
        <trans-unit id="957ed642dc25daf64f22e9ce4f2d86f58626bccf" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters have default values, which are displayed as part of the function signature. They can also be detailed in the description:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5739d18910534a4fc38a98f7f49af50c8efbd3" translate="yes" xml:space="preserve">
          <source>Optional reduced verbosity for np.distutils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7d5ecd852396fa81676288ee6a2c196a7a5edc" translate="yes" xml:space="preserve">
          <source>Optional: Check which files have changed with &lt;code&gt;git status&lt;/code&gt; (see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-status.html&quot;&gt;git status&lt;/a&gt;). You&amp;rsquo;ll see a listing like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f5f42f191b45dd21642dce26f8c271e45fd28" translate="yes" xml:space="preserve">
          <source>Optional: Compare the changes with the previous version using with &lt;code&gt;git
diff&lt;/code&gt; (&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-diff.html&quot;&gt;git diff&lt;/a&gt;). This brings up a simple text browser interface that highlights the difference between your files and the previous version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b391073386a52a6e7c7d2a204ec775ecfe3f5d3a" translate="yes" xml:space="preserve">
          <source>Optional: set up SSH keys to avoid passwords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1956660192de93e6ae71981428d48e53a65ccc" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c0f096a4d20dec7aa72b3d7d08a3d6f13db350" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (numpy.dual)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb0ace95d7206d55e77238265b3a66f3d4c761a" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="translated">Opcionalmente, rutinas aceleradas por &lt;code&gt;numpy.dual&lt;/code&gt; ( numpy.dual )</target>
        </trans-unit>
        <trans-unit id="a841da812f87c91971335f8748cac5433932b134" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (numpy.dual)</source>
          <target state="translated">Opcionalmente,rutinas aceleradas por la ciencia (numpy.dual)</target>
        </trans-unit>
        <trans-unit id="8836fa518e3fcc554024b475844ea5ac0ecd26c6" translate="yes" xml:space="preserve">
          <source>Optionally, F2PY created signature files can be edited to optimize wrappers functions, make them &amp;ldquo;smarter&amp;rdquo; and more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19671beddc2d78364aeb52dc43b5315cb3a7f11" translate="yes" xml:space="preserve">
          <source>Or a non uniform one:</source>
          <target state="translated">O uno no uniforme:</target>
        </trans-unit>
        <trans-unit id="8fe65c617425af9e2c3d6f2775ea339d5f9f089e" translate="yes" xml:space="preserve">
          <source>Or a similar way from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953f087657473d16d4beb73a89ced5320c3f6acc" translate="yes" xml:space="preserve">
          <source>Or an array filled with &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7ef857cc1fde38181b075860bab6fb0bd52da8" translate="yes" xml:space="preserve">
          <source>Or as a decorator:</source>
          <target state="translated">O como decorador:</target>
        </trans-unit>
        <trans-unit id="c7e6a42ed35b95f820330f765f1edafa77be23aa" translate="yes" xml:space="preserve">
          <source>Or even an empty array! The function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. The reason to use &lt;code&gt;empty&lt;/code&gt; over &lt;code&gt;zeros&lt;/code&gt; (or something similar) is speed - just make sure to fill every element afterwards!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9b2d57a173de94af257f54a0e80ee07c9cf0f4" translate="yes" xml:space="preserve">
          <source>Or for a vectorized convolution:</source>
          <target state="translated">O para una convolución vectorizada:</target>
        </trans-unit>
        <trans-unit id="b0d8b33e98de773e2f38b3003cb0a7e130e442fc" translate="yes" xml:space="preserve">
          <source>Or from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d726b49f504d34574328c172ded1bdd16da0e2" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;numpy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d67dbe290ba345acdc7d9f67357d1c9ca90c84" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="translated">O si agrega &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; a la ruta de Python, puede ejecutar las pruebas de forma interactiva en el int&amp;eacute;rprete de esta manera:</target>
        </trans-unit>
        <trans-unit id="86168e460ad3421414419c2552c4c8f1c87145ff" translate="yes" xml:space="preserve">
          <source>Or more generally, the f2cmap file must contain a dictionary with items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a034f1d60dd7621f858f2d8cd0dbc13046363fae" translate="yes" xml:space="preserve">
          <source>Or reverse only the &lt;em&gt;columns&lt;/em&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002d2f07f89a6dd55f4dbdba5b6f9608201e1d77" translate="yes" xml:space="preserve">
          <source>Or select specific elements to include:</source>
          <target state="translated">O seleccionar elementos específicos para incluir:</target>
        </trans-unit>
        <trans-unit id="91f70ad6cdb41e4acfd7bf765e82bbdee8fa8d5e" translate="yes" xml:space="preserve">
          <source>Or stack them horizontally with &lt;code&gt;hstack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c3ddf3aab6700d937d53be3d5b45771f361386" translate="yes" xml:space="preserve">
          <source>Or wish to add a constant to all negative elements:</source>
          <target state="translated">O desea añadir una constante a todos los elementos negativos:</target>
        </trans-unit>
        <trans-unit id="9ed306dae12d1d39fff858942862ae59bbc4399d" translate="yes" xml:space="preserve">
          <source>Or without &lt;code&gt;np.ix_&lt;/code&gt; (compare the integer array examples):</source>
          <target state="translated">O sin &lt;code&gt;np.ix_&lt;/code&gt; (compare los ejemplos de matrices de enteros):</target>
        </trans-unit>
        <trans-unit id="05b188193e465d376dab17b5c2f6bf78bee37c0c" translate="yes" xml:space="preserve">
          <source>Or you can open the file any time with a text editor!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c15fab9ba4d55adcaf397914137e45e790605" translate="yes" xml:space="preserve">
          <source>Or you can select elements that satisfy two conditions using the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e527e2f2a0e03657e01d30970c004e213dc85" translate="yes" xml:space="preserve">
          <source>Or, for a column vector, you can insert an axis along the second dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c3124f81c1d85f2179239c9449534ba1cd1e5" translate="yes" xml:space="preserve">
          <source>Or, if you start with these arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="57f93044bc0a408687e6b01e33395f89ff4d70a4" translate="yes" xml:space="preserve">
          <source>Order of differentiation (default: 1)</source>
          <target state="translated">Orden de diferenciación (por defecto:1)</target>
        </trans-unit>
        <trans-unit id="788c2fe754b6f79f4fc9b0b665993b8ce7234c19" translate="yes" xml:space="preserve">
          <source>Order of integration, must be positive. (Default: 1)</source>
          <target state="translated">El orden de la integración,debe ser positivo.(Por defecto:1)</target>
        </trans-unit>
        <trans-unit id="a5353df5e917b478408b634f2bf535553074c600" translate="yes" xml:space="preserve">
          <source>Order of operations optimization in &lt;code&gt;np.einsum&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad4bbf3f62befe7c196979bd8380406f97a913" translate="yes" xml:space="preserve">
          <source>Order of the antiderivative. (Default: 1)</source>
          <target state="translated">Orden del antiderivado.(Por defecto:1)</target>
        </trans-unit>
        <trans-unit id="c2ecce42b9cac400a1b6d5085507c247c9b755ae" translate="yes" xml:space="preserve">
          <source>Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</source>
          <target state="translated">Orden de los datos para los conjuntos multidimensionales:C,Fortran,o el mismo que para la matriz original.</target>
        </trans-unit>
        <trans-unit id="1c001b919a2f52d0fbb20d49a83e3f37a24b3cfa" translate="yes" xml:space="preserve">
          <source>Order of the data item in the copy. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">Orden del elemento de datos en la copia. El valor predeterminado es 'C'.</target>
        </trans-unit>
        <trans-unit id="f847d5dac01910a77c77edf954ad824a1e14efe8" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;a href=&quot;../constants#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; object. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f142fafd57c235130d4ec687878d429370c853" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object.</source>
          <target state="translated">Orden de la norma (ver tabla bajo &lt;code&gt;Notes&lt;/code&gt; ). inf significa objeto &lt;code&gt;inf&lt;/code&gt; de numpy .</target>
        </trans-unit>
        <trans-unit id="b66f9f860fc227b1d5431e30c1b51053269954ff" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc210a4b093569ae3685cc2f2612720dea8f1e" translate="yes" xml:space="preserve">
          <source>Order of the norm:</source>
          <target state="translated">Orden de la norma:</target>
        </trans-unit>
        <trans-unit id="b8a7abb1120bc925fdb57310f93f2fa464fdc7ae" translate="yes" xml:space="preserve">
          <source>Order of the powers of the columns. If True, the powers increase from left to right, if False (the default) they are reversed.</source>
          <target state="translated">Orden de los poderes de las columnas.Si es Verdadero,los poderes aumentan de izquierda a derecha,si es Falso (por defecto)se invierten.</target>
        </trans-unit>
        <trans-unit id="9ad696b93bae4cfca8937f28f2148899d7322e0a" translate="yes" xml:space="preserve">
          <source>Order statistics</source>
          <target state="translated">Ordenar las estadísticas</target>
        </trans-unit>
        <trans-unit id="422e3f686c9f8818631b86e59adef2a48327ba9b" translate="yes" xml:space="preserve">
          <source>Ordered list of field names, or &lt;code&gt;None&lt;/code&gt; if there are no fields.</source>
          <target state="translated">Lista ordenada de nombres de campo, o &lt;code&gt;None&lt;/code&gt; si no hay campos.</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="d1225815854e81b81f3a0215f90f105cc1022337" translate="yes" xml:space="preserve">
          <source>Ordinarly, vector operands must all be the same size, because NumPy works element by element &amp;ndash; for instance, &lt;code&gt;c = a * b&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d44d98096c18e71b1176f355d8b6f0c7c16e1d1" translate="yes" xml:space="preserve">
          <source>Ordinary inner product for vectors:</source>
          <target state="translated">Producto interno ordinario para los vectores:</target>
        </trans-unit>
        <trans-unit id="191b600520d98586a88c24fcdd4e2889be08fced" translate="yes" xml:space="preserve">
          <source>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</source>
          <target state="translated">Producto interno ordinario de vectores para matrices 1-D (sin conjugación compleja),en dimensiones superiores un producto de suma sobre los últimos ejes.</target>
        </trans-unit>
        <trans-unit id="eb7dc7265e25691a9373e1ca80276306cb88c7ca" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values.</source>
          <target state="translated">Valores de ordenadas o &amp;ldquo;variables dependientes&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="8c7ff7749bfea5af2d2c09b7c86b2dbdfee56f2a" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the least-squares solution is calculated for each of the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Valores de ordenadas o &amp;ldquo;variables dependientes&amp;rdquo;. Si &lt;code&gt;b&lt;/code&gt; es bidimensional, la soluci&amp;oacute;n de m&amp;iacute;nimos cuadrados se calcula para cada una de las &lt;code&gt;K&lt;/code&gt; columnas de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bedfebf0ecf8e3c63711ee41881ab8ce7f77971c" translate="yes" xml:space="preserve">
          <source>Original Source</source>
          <target state="translated">Fuente original</target>
        </trans-unit>
        <trans-unit id="92bff9048309d096b7578598a0790ad0978b76db" translate="yes" xml:space="preserve">
          <source>Original Source of the Generator and BitGenerators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f05a12c3fefa36c0646baab0998b9e0baf27dee" translate="yes" xml:space="preserve">
          <source>Original author: Robert Cimrman</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d77937700b7f6304cd9cc6f6f114b310986845" translate="yes" xml:space="preserve">
          <source>Original positions of the axes to move. These must be unique.</source>
          <target state="translated">Las posiciones originales de los ejes a mover.Estas deben ser únicas.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="34d7150cfcec917eee04da671286a02a27c1a6b8" translate="yes" xml:space="preserve">
          <source>Other (void * &amp;ndash; each item is a fixed-size chunk of memory)</source>
          <target state="translated">Otro (nulo *: cada elemento es un trozo de memoria de tama&amp;ntilde;o fijo)</target>
        </trans-unit>
        <trans-unit id="16863278e548d66fae935c08b81b275cea6f9914" translate="yes" xml:space="preserve">
          <source>Other C-Structures</source>
          <target state="translated">Otras estructuras C</target>
        </trans-unit>
        <trans-unit id="c5164a0d79a937ac6a201b20d3ffe5ea4af04bc1" translate="yes" xml:space="preserve">
          <source>Other Common Types: bool</source>
          <target state="translated">Otros tipos comunes:bool</target>
        </trans-unit>
        <trans-unit id="9a529214aef07d296fc3d4d086152694a3e98921" translate="yes" xml:space="preserve">
          <source>Other Common Types: complex</source>
          <target state="translated">Otros tipos comunes:complejos</target>
        </trans-unit>
        <trans-unit id="708bf6f62e354ff314651598e7eebc62fd8d2bb2" translate="yes" xml:space="preserve">
          <source>Other Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa321ae463cf423d057b0fb19c09b0142f3c2a" translate="yes" xml:space="preserve">
          <source>Other Parameters:</source>
          <target state="translated">Otros parámetros:</target>
        </trans-unit>
        <trans-unit id="3a704886f69c3b776903fa1eae3b74661fb05227" translate="yes" xml:space="preserve">
          <source>Other Polynomial Constructors</source>
          <target state="translated">Otros constructores de polinomios</target>
        </trans-unit>
        <trans-unit id="407cab4f45e3f1e45a4d3d8364006412c6cfc5cd" translate="yes" xml:space="preserve">
          <source>Other Situations</source>
          <target state="translated">Otras situaciones</target>
        </trans-unit>
        <trans-unit id="ae276ac9fe79a4b2444ced92d93c1c04bd2cde2e" translate="yes" xml:space="preserve">
          <source>Other aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d042bb243a9d93f7d217c6e5a0c1a49c971c43e7" translate="yes" xml:space="preserve">
          <source>Other attributes</source>
          <target state="translated">Otros atributos</target>
        </trans-unit>
        <trans-unit id="e84477e1de2ec14b541d8664b31b8881de493393" translate="yes" xml:space="preserve">
          <source>Other axes remain in their original order.</source>
          <target state="translated">Otras hachas permanecen en su orden original.</target>
        </trans-unit>
        <trans-unit id="94a56f444dca5dd30ab9a1fe9100b3b01d86f467" translate="yes" xml:space="preserve">
          <source>Other build options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a6c3afafd0ae34a74385fb566d6175cb96b17" translate="yes" xml:space="preserve">
          <source>Other constants</source>
          <target state="translated">Otras constantes</target>
        </trans-unit>
        <trans-unit id="ed4b1121b10e2ed9c2b0a79e79f85e8ad19d33ae" translate="yes" xml:space="preserve">
          <source>Other conversions</source>
          <target state="translated">Otras conversiones</target>
        </trans-unit>
        <trans-unit id="b0c0a3787c5b36b4fe5b178d91a655c6a5cbdf6b" translate="yes" xml:space="preserve">
          <source>Other files</source>
          <target state="translated">Otros archivos</target>
        </trans-unit>
        <trans-unit id="e12e322f5b694198963cd183428de579cc666876" translate="yes" xml:space="preserve">
          <source>Other functions</source>
          <target state="translated">Otras funciones</target>
        </trans-unit>
        <trans-unit id="1cddb5c0e17d84098d16d9325f9cc36b4d8d05b6" translate="yes" xml:space="preserve">
          <source>Other indexing options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b002f2786124a662470fe9d1d4b2061560ed34" translate="yes" xml:space="preserve">
          <source>Other keys that can be used to set a group of types at once are:</source>
          <target state="translated">Otras claves que pueden utilizarse para establecer un grupo de tipos a la vez son:</target>
        </trans-unit>
        <trans-unit id="04009c322c38e522287cb7657248010dcf883c3a" translate="yes" xml:space="preserve">
          <source>Other methods of running tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">Otros módulos</target>
        </trans-unit>
        <trans-unit id="486d94e1070b48b0053b9b70f1f9be9f4d9d5bf1" translate="yes" xml:space="preserve">
          <source>Other new functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99a2c4e58511e531864aed996a281648e9837a1" translate="yes" xml:space="preserve">
          <source>Other points to keep in mind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a81da2e8af18ed2deb2ba9e65ed60e75f7dbe" translate="yes" xml:space="preserve">
          <source>Other related special value functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56243f47f05b7964d5f4fc1a7a1d5dc330f1664" translate="yes" xml:space="preserve">
          <source>Other special functions</source>
          <target state="translated">Otras funciones especiales</target>
        </trans-unit>
        <trans-unit id="9cc692beb493cdd7b095a31706521fdb297cd3ab" translate="yes" xml:space="preserve">
          <source>Other statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28f6f004c86b1b4979a17c950470ea4d696d78" translate="yes" xml:space="preserve">
          <source>Other than the view syntax, the function is immediately readable to a Python programmer. Static typing of the variable &lt;code&gt;i&lt;/code&gt; is implicit. Instead of the view syntax, we could also have used Cython&amp;rsquo;s special NumPy array syntax, but the view syntax is preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db156a16585b32767d434efac29632f353ee893f" translate="yes" xml:space="preserve">
          <source>Other useful flags that can be OR&amp;rsquo;d as additional requirements are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80ae13d27005970d36a64205ad27c701906310c" translate="yes" xml:space="preserve">
          <source>Other useful related constants are</source>
          <target state="translated">Otras constantes útiles relacionadas son</target>
        </trans-unit>
        <trans-unit id="da626da9b3eb80a71166ddec09244cef236be1ee" translate="yes" xml:space="preserve">
          <source>Other ways to contribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60a0a7b60b2c507b8c7be2f403c23dd728c5542" translate="yes" xml:space="preserve">
          <source>Otherwise F2PY makes a contiguous copy (with a proper dtype) of the input array and passes C pointer of the copy to Fortran subroutine. As a result, any possible changes to the (copy of) input array have no effect to the original argument, as demonstrated below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc3acd71c35a47919d5dc18e67e38bbe2ca711" translate="yes" xml:space="preserve">
          <source>Otherwise we recommend simply learning to reverse the usual order of indices when accessing elements of an array. Granted, it goes against the grain, but it is more in line with Python semantics and the natural order of the data.</source>
          <target state="translated">De lo contrario,recomendamos simplemente aprender a invertir el orden habitual de los índices cuando se accede a los elementos de una matriz.Por supuesto,va a contracorriente,pero está más en línea con la semántica de Python y el orden natural de los datos.</target>
        </trans-unit>
        <trans-unit id="29b9f8169fedb0ad1c9be824eca55314fa16d94e" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; is called on each array, and the resulting data types are all combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">De lo contrario, se llama a &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; en cada matriz, y los tipos de datos resultantes se combinan con &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; para producir el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="fae9e7a3585b77fe783d86ad593d20c5ecc3f354" translate="yes" xml:space="preserve">
          <source>Otherwise, PyArray_MinScalarType is called on each array, and the resulting data types are all combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">De lo contrario, se llama a PyArray_MinScalarType en cada matriz y los tipos de datos resultantes se combinan con &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; para producir el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="a5347d369bb3cc80acdc3e9eec52dbe20542bf3e" translate="yes" xml:space="preserve">
          <source>Otherwise, only the &lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;pdf&lt;/code&gt; links should be updated with the new tag name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd38ba9fb1f1dbc35dcac58860b6157e6882b67" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MySubClass.__new__&lt;/code&gt; method only gets called in the case of the explicit constructor call, so we can&amp;rsquo;t rely on &lt;code&gt;MySubClass.__new__&lt;/code&gt; or &lt;code&gt;MySubClass.__init__&lt;/code&gt; to deal with the view casting and new-from-template. It turns out that &lt;code&gt;MySubClass.__array_finalize__&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; get called for all three methods of object creation, so this is where our object creation housekeeping usually goes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c471225c8348ecdf3cb9056eeb4166b9df8525" translate="yes" xml:space="preserve">
          <source>Our current rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5388893497a63e10962c70e1e04399dd9d5a42e3" translate="yes" xml:space="preserve">
          <source>Our custom array can be instantiated like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf78b3f6f52a00f298a7bfb0726e5baf2bd452dd" translate="yes" xml:space="preserve">
          <source>Our docstring standard uses &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;re-structured text (reST)&lt;/a&gt; syntax and is rendered using &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; (a pre-processor that understands the particular documentation style we are using). While a rich set of markup is available, we limit ourselves to a very basic subset, in order to provide docstrings that are easy to read on text-only terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699b767a44afe4a72b5254c097705dfd2fc0c0eb" translate="yes" xml:space="preserve">
          <source>Our final example is a ufunc with multiple arguments. It is a modification of the code for a logit ufunc for data with a single dtype. We compute (A*B, logit(A*B)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd99f75ef9c59f37909a92800122629525cfc030" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eb13334b28d2a094a12f8ab9ba2e910911e99a" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in SciPy and NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="translated">Nuestro objetivo es que cada m&amp;oacute;dulo y paquete de SciPy y NumPy tenga un conjunto completo de pruebas unitarias. Estas pruebas deben ejercitar la funcionalidad completa de una rutina determinada, as&amp;iacute; como su solidez ante argumentos de entrada err&amp;oacute;neos o inesperados. Una larga experiencia ha demostrado que, con mucho, el mejor momento para escribir las pruebas es antes de escribir o cambiar el c&amp;oacute;digo; esto es &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;desarrollo impulsado por pruebas.&lt;/a&gt;. Los argumentos a favor de esto pueden sonar bastante abstractos, pero podemos asegurarle que encontrar&amp;aacute; que escribir las pruebas primero conduce a un c&amp;oacute;digo m&amp;aacute;s robusto y mejor dise&amp;ntilde;ado. Las pruebas bien dise&amp;ntilde;adas con buena cobertura marcan una enorme diferencia en la facilidad de refactorizaci&amp;oacute;n. Siempre que se encuentre un nuevo error en una rutina, debe escribir una nueva prueba para ese caso espec&amp;iacute;fico y agregarlo al conjunto de pruebas para evitar que ese error vuelva a aparecer sin ser detectado.</target>
        </trans-unit>
        <trans-unit id="d68e5db67be9b03d20fd91c37de52993f3c9d547" translate="yes" xml:space="preserve">
          <source>Our main means of communication are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469d2ebc8c77151c167772e7a4f4b5ae56c779b" translate="yes" xml:space="preserve">
          <source>Our markup language is reStructuredText (rST), which is more elaborate than Markdown. Sphinx, the tool many Python projects use to build and link project documentation, converts the rST into HTML and other formats. For more on rST, see the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;https://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092ac50b2f1d2b5a2fd5de4d521d3e71263ef97d" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09929ef69018d98fc6ab68200819ee812816f740" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;https://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154d74419b6aca893341269b8ba48a9e26a16006" translate="yes" xml:space="preserve">
          <source>Out has the same shape as &lt;code&gt;x&lt;/code&gt;. Its real part is in &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; (&lt;code&gt;arctan(+/-inf)&lt;/code&gt; returns &lt;code&gt;+/-pi/2&lt;/code&gt;). This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Out tiene la misma forma que &lt;code&gt;x&lt;/code&gt; . Su parte real est&amp;aacute; en &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; ( &lt;code&gt;arctan(+/-inf)&lt;/code&gt; devuelve &lt;code&gt;+/-pi/2&lt;/code&gt; ). Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="851f8da769fc08fe920a7a332149d07bd3e21638" translate="yes" xml:space="preserve">
          <source>Out of the box, &lt;code&gt;numpy.i&lt;/code&gt; provides typemaps that support conversion between NumPy arrays and C arrays:</source>
          <target state="translated">De &lt;code&gt;numpy.i&lt;/code&gt; , numpy.i proporciona mapas de tipos que admiten la conversi&amp;oacute;n entre matrices NumPy y matrices C:</target>
        </trans-unit>
        <trans-unit id="b99f04d1fc495fb457ec6ab4bb045f1b70e94783" translate="yes" xml:space="preserve">
          <source>Outer Product Iteration</source>
          <target state="translated">Iteración del producto exterior</target>
        </trans-unit>
        <trans-unit id="c6ee0caa49ecd5d48b8b76e247cdb1d691fc307b" translate="yes" xml:space="preserve">
          <source>Outer product, same as &lt;code&gt;outer(x, y)&lt;/code&gt;:</source>
          <target state="translated">Producto externo, igual que &lt;code&gt;outer(x, y)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f31dd41cdb77529134dabee0a5149b6913233527" translate="yes" xml:space="preserve">
          <source>Outer product.</source>
          <target state="translated">Producto exterior.</target>
        </trans-unit>
        <trans-unit id="a8eb7f250550fb11f31a150896a2c233c22e5afb" translate="yes" xml:space="preserve">
          <source>Output Arrays</source>
          <target state="translated">Matrices de salida</target>
        </trans-unit>
        <trans-unit id="69721e85622681a00d5e83b618b8602f51f2805c" translate="yes" xml:space="preserve">
          <source>Output a 3x8000 array:</source>
          <target state="translated">Da salida a una matriz de 3x8000:</target>
        </trans-unit>
        <trans-unit id="7156471f771c478a3049744cdf9adc5be3b74b53" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a, b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e70b270c18c83f26e6230a7a984b1fb40cee94" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">Argumento de salida. Debe ser del tipo exacto que se devolver&amp;iacute;a si no se utilizara. En particular, debe tener el tipo correcto, debe ser C-contiguo y su dtype debe ser el dtype que se devolver&amp;iacute;a para el &lt;code&gt;dot(a,b)&lt;/code&gt; . Esta es una caracter&amp;iacute;stica de rendimiento. Por lo tanto, si no se cumplen estas condiciones, se genera una excepci&amp;oacute;n, en lugar de intentar ser flexible.</target>
        </trans-unit>
        <trans-unit id="6e978531d306139571810dad3cc0f8a44d943b22" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;ma.dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83f71ed49812b1c51736e820cd87f0f9865fcb1" translate="yes" xml:space="preserve">
          <source>Output arguments to ufuncs can be tuples also for ufunc methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f12acadc64d21e2feac22d1a1b4692fb105ee3" translate="yes" xml:space="preserve">
          <source>Output array</source>
          <target state="translated">Matriz de salida</target>
        </trans-unit>
        <trans-unit id="f89327ce1837e2c79277b79c5f26d1462b21d4b0" translate="yes" xml:space="preserve">
          <source>Output array for the exponent. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Matriz de salida para el exponente. Debe tener la misma forma que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce4222d68677642db5d8cd581c2069a152c5cd0e" translate="yes" xml:space="preserve">
          <source>Output array for the mantissa. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Matriz de salida para la mantisa. Debe tener la misma forma que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1138d70b1d22742de8a7eec1ca180e5192ab003" translate="yes" xml:space="preserve">
          <source>Output array is same shape and type as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">La matriz de salida tiene la misma forma y tipo que &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="2e976c3ac1b3c4a193e0ef93cc1e51ab4229d440" translate="yes" xml:space="preserve">
          <source>Output array of &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef051a2e330bee8268ab4c049205eb02d245cc1" translate="yes" xml:space="preserve">
          <source>Output array of &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">Matriz de salida de &lt;code&gt;string_&lt;/code&gt; o &lt;code&gt;unicode_&lt;/code&gt; , seg&amp;uacute;n los tipos de entrada de la misma forma que &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd088a12712ab8d4c2c426261156c01f4ed1606" translate="yes" xml:space="preserve">
          <source>Output array of bools</source>
          <target state="translated">Matriz de salida de bools</target>
        </trans-unit>
        <trans-unit id="32b7b13439f3e6221fd4780b32449d5d4d7f2b86" translate="yes" xml:space="preserve">
          <source>Output array of bools, or a single bool if x1 and x2 are scalars.</source>
          <target state="translated">Una serie de bools de salida,o un solo bool si x1 y x2 son escalares.</target>
        </trans-unit>
        <trans-unit id="242b7670831be50eb14727f2ee1d42762f40625b" translate="yes" xml:space="preserve">
          <source>Output array of bools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59628506899dd565c36cb8637802ca8d03d5a7e8" translate="yes" xml:space="preserve">
          <source>Output array of indices, of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Matriz de &amp;iacute;ndices de salida, de la misma forma que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee5c2cea50e4665a7ae56f4b3614a03fe2437d2" translate="yes" xml:space="preserve">
          <source>Output array of integers</source>
          <target state="translated">Matriz de salida de números enteros</target>
        </trans-unit>
        <trans-unit id="7e2593695a5d88e14bbbac4809c3409ae05309b7" translate="yes" xml:space="preserve">
          <source>Output array of ints.</source>
          <target state="translated">Matriz de salida de ints.</target>
        </trans-unit>
        <trans-unit id="52a772b58c524d2ad00244b1064922aec6a445c6" translate="yes" xml:space="preserve">
          <source>Output array of ints. Return -1 on failure.</source>
          <target state="translated">Matriz de salida de ints.Retorno -1 en caso de fallo.</target>
        </trans-unit>
        <trans-unit id="a30063ccd5b6202d238ce61d0b6db2952ded8310" translate="yes" xml:space="preserve">
          <source>Output array of ints. Returns -1 if &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">Matriz de salida de ints. Devuelve -1 si no se encuentra &lt;code&gt;sub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9735bcc93d569bce2b6e7befd7418f0ba4b716c9" translate="yes" xml:space="preserve">
          <source>Output array of same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Matriz de salida de la misma forma que &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="a38bebcd0d7b96b1c608bbee88ef6bc304e314b0" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type</source>
          <target state="translated">Matriz de salida de str o unicode,según el tipo de entrada</target>
        </trans-unit>
        <trans-unit id="58c2378e8c8946ae97f1ea7dac73a13c10abcd50" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">Matriz de salida de str o unicode,según el tipo de entrada.La matriz de salida tendrá una dimensión extra con 3 elementos por cada elemento de entrada.</target>
        </trans-unit>
        <trans-unit id="64d5dcb1c0c304c381fa58f443d7ded824e0bc47" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input types</source>
          <target state="translated">Matriz de salida de str o unicode,dependiendo de los tipos de entrada</target>
        </trans-unit>
        <trans-unit id="fd13d84379a70df2e078233919d2189882423201" translate="yes" xml:space="preserve">
          <source>Output array of string or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">Una matriz de salida de cadena o unicode,dependiendo del tipo de entrada.La matriz de salida tendrá una dimensión extra con 3 elementos por cada elemento de entrada.</target>
        </trans-unit>
        <trans-unit id="f7c9fa3972ed6e6a39e0733beb489d1ce3ad7791" translate="yes" xml:space="preserve">
          <source>Output array which has the same shape as &lt;code&gt;a&lt;/code&gt;, except along the given axis.</source>
          <target state="translated">Matriz de salida que tiene la misma forma que &lt;code&gt;a&lt;/code&gt; , excepto a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="b3c1a1cbd46397d96a8e1319b9f70d2c4e83a943" translate="yes" xml:space="preserve">
          <source>Output array, containing the indices of the elements of &lt;code&gt;a.ravel()&lt;/code&gt; that are non-zero.</source>
          <target state="translated">Matriz de salida, que contiene los &amp;iacute;ndices de los elementos de &lt;code&gt;a.ravel()&lt;/code&gt; que no son cero.</target>
        </trans-unit>
        <trans-unit id="307c943561bf0b8b5ee1a6f51fb083d57904faed" translate="yes" xml:space="preserve">
          <source>Output array, element-wise comparison of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. Typically of type bool, unless &lt;code&gt;dtype=object&lt;/code&gt; is passed. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Matriz de salida, comparaci&amp;oacute;n de elementos de &lt;code&gt;x1&lt;/code&gt; y &lt;code&gt;x2&lt;/code&gt; . Normalmente de tipo bool, a menos que se &lt;code&gt;dtype=object&lt;/code&gt; . Este es un escalar si tanto &lt;code&gt;x1&lt;/code&gt; como &lt;code&gt;x2&lt;/code&gt; son escalares.</target>
        </trans-unit>
        <trans-unit id="2e21fc9917d319d6359f007add3068ca89130f62" translate="yes" xml:space="preserve">
          <source>Output array, element-wise exponential of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Matriz de salida, exponencial por elementos de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="16e86016f9dd58438b33f8fa3832e0a84ce8bad6" translate="yes" xml:space="preserve">
          <source>Output array, or reference to &lt;code&gt;out&lt;/code&gt; if that was supplied. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Matriz de salida, o referencia a &lt;code&gt;out&lt;/code&gt; si se proporcion&amp;oacute;. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="1c4ffa82eda162fa8929d170e0a0f647fbc47d46" translate="yes" xml:space="preserve">
          <source>Output array, with the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Matriz de salida, con la misma forma que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c7fe807ab5dc7a002fea6ec306d2d20dd6cd310" translate="yes" xml:space="preserve">
          <source>Output array.</source>
          <target state="translated">Matriz de salida.</target>
        </trans-unit>
        <trans-unit id="bfcf0a026c1c1c3df16d07e5c463c5d22ef8d769" translate="yes" xml:space="preserve">
          <source>Output array. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Matriz de salida.Se conserva su tipo y debe tener la forma adecuada para mantener la salida.</target>
        </trans-unit>
        <trans-unit id="21470ea6838153d93bb789847f1e781e9233d56c" translate="yes" xml:space="preserve">
          <source>Output formatting</source>
          <target state="translated">Formato de salida</target>
        </trans-unit>
        <trans-unit id="ebe7bf947438344dfee2f421c7f0822ca9d92fa3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a vector of length &lt;code&gt;k&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a267ec8ecd4cabb56c1672c1c1515df13c271b4b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn from the 1-d &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than one dimension, the &lt;code&gt;size&lt;/code&gt; shape will be inserted into the &lt;code&gt;axis&lt;/code&gt; dimension, so the output &lt;code&gt;ndim&lt;/code&gt; will be &lt;code&gt;a.ndim - 1 +
len(size)&lt;/code&gt;. Default is None, in which case a single value is returned.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras del 1-d &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de una dimensi&amp;oacute;n, la forma de &lt;code&gt;size&lt;/code&gt; se insertar&amp;aacute; en la dimensi&amp;oacute;n del &lt;code&gt;axis&lt;/code&gt; , por lo que el &lt;code&gt;ndim&lt;/code&gt; de salida ser&amp;aacute; &lt;code&gt;a.ndim - 1 + len(size)&lt;/code&gt; . El valor predeterminado es Ninguno, en cuyo caso se devuelve un solo valor.</target>
        </trans-unit>
        <trans-unit id="d2424a491af135ae36f950b7ab0516bd18ace8df" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a single value is returned.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. El valor predeterminado es Ninguno, en cuyo caso se devuelve un solo valor.</target>
        </trans-unit>
        <trans-unit id="89e56aa13faf2ac19ffb0b3e5e716f7bfddc1ab9" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), un valor &amp;uacute;nico se devuelve si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son ambos escalares. De lo contrario, se &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; muestras de np.broadcast (a, b) .size .</target>
        </trans-unit>
        <trans-unit id="55b478ddcb62162e8ce07219dee1d9d6ca7a8be6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(a).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;a&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(a).size&lt;/code&gt; muestras np.array (a) .size .</target>
        </trans-unit>
        <trans-unit id="bad13c9c05fba2155bd76b001de567b59798e200" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;nonc&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;df&lt;/code&gt; y &lt;code&gt;nonc&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; muestras de np.broadcast (df, nonc) .size .</target>
        </trans-unit>
        <trans-unit id="738b6886d61591bdc17ae069de249790d6b71087" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(df).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;df&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(df).size&lt;/code&gt; muestras de np.array (df) .size .</target>
        </trans-unit>
        <trans-unit id="ae475a1d95fefab6fd2f2bedb6223f991fcc41b6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt; and &lt;code&gt;dfden&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;dfnum&lt;/code&gt; y &lt;code&gt;dfden&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46a9903f305b04fd0f7d5079b4658c01625926e1" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt;, &lt;code&gt;dfden&lt;/code&gt;, and &lt;code&gt;nonc&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un &amp;uacute;nico valor si &lt;code&gt;dfnum&lt;/code&gt; , &lt;code&gt;dfden&lt;/code&gt; y &lt;code&gt;nonc&lt;/code&gt; son todos escalares. De lo contrario, se &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9a357ee338f25bf2bcb1c6a39d7e36ff751b6d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;lam&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(lam).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;lam&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(lam).size&lt;/code&gt; muestras de np.array (lam) .size .</target>
        </trans-unit>
        <trans-unit id="6bfc36fdff77cbd952a127d76db752bf9585b331" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un &amp;uacute;nico valor si &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; y &lt;code&gt;right&lt;/code&gt; son todos escalares. De lo contrario, se &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="221f43b3f6b78ea4ffc570a2b4686a11e53b9689" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;loc&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; son ambos escalares. De lo contrario, se &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; muestras np.broadcast (loc, scale) .size .</target>
        </trans-unit>
        <trans-unit id="4282c4067b87ca3f0f86b5fc7e0e58c780e280c3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si tanto &lt;code&gt;low&lt;/code&gt; como &lt;code&gt;high&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; muestras de tama&amp;ntilde;o np.broadcast (bajo, alto) .</target>
        </trans-unit>
        <trans-unit id="d0683da40c0442ae9f7198c7d720ea85a5de1b4d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un &amp;uacute;nico valor si la &lt;code&gt;mean&lt;/code&gt; y la &lt;code&gt;scale&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; muestras np.broadcast (media, escala) .size .</target>
        </trans-unit>
        <trans-unit id="0de49618d9158d1b17813c0b098c763f862b1d88" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;sigma&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si la &lt;code&gt;mean&lt;/code&gt; y el &lt;code&gt;sigma&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; muestras de tama&amp;ntilde;o np.broadcast (mean, sigma) .</target>
        </trans-unit>
        <trans-unit id="4e92a7af3b2b74719c734b754039059712af838b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mu&lt;/code&gt; and &lt;code&gt;kappa&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;mu&lt;/code&gt; y &lt;code&gt;kappa&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; muestras de np.broadcast (mu, kappa) .size .</target>
        </trans-unit>
        <trans-unit id="508329c1fbd22ad6be84a6836708268204490867" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;p&lt;/code&gt; son ambos escalares. De lo contrario, se &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; muestras de np.broadcast (n, p) .size .</target>
        </trans-unit>
        <trans-unit id="b122820c89df713b07cfbc58626294123f0af0a3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;ngood&lt;/code&gt;, &lt;code&gt;nbad&lt;/code&gt;, and &lt;code&gt;nsample&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;ngood&lt;/code&gt; , &lt;code&gt;nbad&lt;/code&gt; y &lt;code&gt;nsample&lt;/code&gt; son todos escalares. De lo contrario, se &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d2ec43f10ca379398aac021ba6a41147bbbdc4" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;p&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si &lt;code&gt;p&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(p).size&lt;/code&gt; muestras np.array (p) .size .</target>
        </trans-unit>
        <trans-unit id="df56295e78bed4d72315ff68acac7d0f9dadfb30" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;scale&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si la &lt;code&gt;scale&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(scale).size&lt;/code&gt; muestras np.array (scale) .size .</target>
        </trans-unit>
        <trans-unit id="948b72efe91fbed7c1a9b81472148fc726a10ddb" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si la &lt;code&gt;shape&lt;/code&gt; y la &lt;code&gt;scale&lt;/code&gt; son escalares. De lo contrario, se &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; muestras np.broadcast (forma, escala) .size .</target>
        </trans-unit>
        <trans-unit id="eb5df5a3ebce059571acee730f004ee96866a67f" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(shape).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Forma de salida. Si la forma dada es, por ejemplo, &lt;code&gt;(m, n, k)&lt;/code&gt; , entonces se extraen &lt;code&gt;m * n * k&lt;/code&gt; muestras. Si el tama&amp;ntilde;o es &lt;code&gt;None&lt;/code&gt; (predeterminado), se devuelve un solo valor si la &lt;code&gt;shape&lt;/code&gt; es un escalar. De lo contrario, se &lt;code&gt;np.array(shape).size&lt;/code&gt; muestras de np.array (shape) .size .</target>
        </trans-unit>
        <trans-unit id="93434be0fa874141cd4c8b5151bed934649c82c6" translate="yes" xml:space="preserve">
          <source>Output to existing array instead of creating new one, must have same shape as expected output</source>
          <target state="translated">La salida a la matriz existente en lugar de crear una nueva,debe tener la misma forma que la salida esperada</target>
        </trans-unit>
        <trans-unit id="84eedc132f8f3afc97e2735311f70af181b638d1" translate="yes" xml:space="preserve">
          <source>Output type determination</source>
          <target state="translated">Determinación de la clase de salida</target>
        </trans-unit>
        <trans-unit id="25c6817215cc63aae8850c0698a2094523318f20" translate="yes" xml:space="preserve">
          <source>Output values. Used for performance testing since the generated values are not returned.</source>
          <target state="translated">Valores de salida.Se utiliza para las pruebas de rendimiento ya que los valores generados no se devuelven.</target>
        </trans-unit>
        <trans-unit id="645e7318aeb0e81470723bb7fa3e333eeb197cd2" translate="yes" xml:space="preserve">
          <source>Output view is of shape &lt;code&gt;(self.size,)&lt;/code&gt; (or &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt;).</source>
          <target state="translated">La vista de salida es de forma &lt;code&gt;(self.size,)&lt;/code&gt; (o &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75eaf4cf3feb6b5ab1173e2bce737a946dc189fe" translate="yes" xml:space="preserve">
          <source>Outputs an array of bools.</source>
          <target state="translated">Produce una serie de bools.</target>
        </trans-unit>
        <trans-unit id="0ba159acbd720278d8203620bd6051e07665bfbd" translate="yes" xml:space="preserve">
          <source>Outside the context the error handling behavior has not changed:</source>
          <target state="translated">Fuera de contexto,el comportamiento de manejo de errores no ha cambiado:</target>
        </trans-unit>
        <trans-unit id="8a528519bdaba69c0bdc57fdcdf7b370f2e098f2" translate="yes" xml:space="preserve">
          <source>Overall</source>
          <target state="translated">Overall</target>
        </trans-unit>
        <trans-unit id="3b4b69a29c016e758ecb737d47f6f3d84f5ea925" translate="yes" xml:space="preserve">
          <source>Overall view of discrete Fourier transforms, with definitions and conventions used.</source>
          <target state="translated">Visión general de las transformaciones discretas de Fourier,con las definiciones y convenciones utilizadas.</target>
        </trans-unit>
        <trans-unit id="bd6510575c0d6b439267f2e4a3758c5ec63354f0" translate="yes" xml:space="preserve">
          <source>Overflow Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e247da042a068cd8a71502e0fd76c6b94f4ca5d" translate="yes" xml:space="preserve">
          <source>Overflow: result too large to be expressed.</source>
          <target state="translated">Desbordamiento:resultado demasiado grande para ser expresado.</target>
        </trans-unit>
        <trans-unit id="2efc34a90711b7a3d99847c32b113347fb82c866" translate="yes" xml:space="preserve">
          <source>Override the default nditer flags for the ufunc.</source>
          <target state="translated">Anular las banderas de nditer por defecto de la UFUN.</target>
        </trans-unit>
        <trans-unit id="75e6a3ee5dadc59620ad485d88ddab650173edc7" translate="yes" xml:space="preserve">
          <source>Override the default operand flags for each ufunc operand.</source>
          <target state="translated">Anular las banderas de operandos por defecto para cada operando ufunc.</target>
        </trans-unit>
        <trans-unit id="c7112a2f014dc699135617be0b1abde474ac316b" translate="yes" xml:space="preserve">
          <source>Overrideable operand flags in ufunc C-API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e2dc0135e076adb3e9a12f5a92b84ec65a0542" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;normed&lt;/code&gt; keyword if given.</source>
          <target state="translated">Anula la palabra clave &lt;code&gt;normed&lt;/code&gt; si se proporciona.</target>
        </trans-unit>
        <trans-unit id="3a7540b1b3a0dda7242487679ca9b11862d3a4ba" translate="yes" xml:space="preserve">
          <source>Overrides the data type of the result.</source>
          <target state="translated">Anula el tipo de datos del resultado.</target>
        </trans-unit>
        <trans-unit id="cb013ea80decaa67cad8a4fef77945440ec27842" translate="yes" xml:space="preserve">
          <source>Overrides the dtype of the calculation and output arrays. Similar to &lt;em&gt;signature&lt;/em&gt;.</source>
          <target state="translated">Anula el tipo d de las matrices de c&amp;aacute;lculo y salida. Similar a la &lt;em&gt;firma&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7006d2b6fc1325bb6529d58eb36199d98e2b6962" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible.</source>
          <target state="translated">Anula el dise&amp;ntilde;o de memoria del resultado. 'C' significa orden C, 'F' significa orden F, 'A' significa 'F' si &lt;code&gt;a&lt;/code&gt; es contiguo a Fortran, 'C' en caso contrario. 'K' significa igualar el dise&amp;ntilde;o de &lt;code&gt;a&lt;/code&gt; lo m&amp;aacute;s cerca posible.</target>
        </trans-unit>
        <trans-unit id="ddaf5efe8542a3a691f6af72e37e55e4e33af102" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;prototype&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;prototype&lt;/code&gt; as closely as possible.</source>
          <target state="translated">Anula el dise&amp;ntilde;o de memoria del resultado. 'C' significa orden C, 'F' significa orden F, 'A' significa 'F' si el &lt;code&gt;prototype&lt;/code&gt; es contiguo a Fortran, 'C' en caso contrario. 'K' significa coincidir con el dise&amp;ntilde;o del &lt;code&gt;prototype&lt;/code&gt; m&amp;aacute;s fielmente posible.</target>
        </trans-unit>
        <trans-unit id="4bd31b5015136a3790d4ea1e4b56f5e23f60c98d" translate="yes" xml:space="preserve">
          <source>Overrides the shape of the result. If order=&amp;rsquo;K&amp;rsquo; and the number of dimensions is unchanged, will try to keep order, otherwise, order=&amp;rsquo;C&amp;rsquo; is implied.</source>
          <target state="translated">Anula la forma del resultado. Si order = 'K' y el n&amp;uacute;mero de dimensiones no cambia, intentaremos mantener el orden, de lo contrario, order = 'C' est&amp;aacute; impl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="3ab7f8eaa264cb0094ba3f9ca231b49fca803e1c" translate="yes" xml:space="preserve">
          <source>Overriding Ufunc behavior</source>
          <target state="translated">Anulando el comportamiento Ufunc</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4b0a4170e8329f03d8b135ba293e3ad03fce2389" translate="yes" xml:space="preserve">
          <source>Overview of numpy type hierarchy.</source>
          <target state="translated">Visión general de la jerarquía de tipos de numeración.</target>
        </trans-unit>
        <trans-unit id="043d190b03e4fa8608d62de06341dd2afb4fd385" translate="yes" xml:space="preserve">
          <source>Overview of the numpy type hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ec4594b7176e776330d622e2702954b1c3e9ee" translate="yes" xml:space="preserve">
          <source>Overwrite existing signature file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="aa00a8efe8f9b81ac75da5a75a43b320bd64395d" translate="yes" xml:space="preserve">
          <source>P. R. Peebles Jr., &amp;ldquo;Central Limit Theorem&amp;rdquo; in &amp;ldquo;Probability, Random Variables and Random Signal Principles&amp;rdquo;, 4th ed., 2001, pp. 51, 51, 125.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb033dba7abb6161a0c83b9f27fd0eb075c43755" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852c68657fb7b98de4c0c80a1fc558db4eb1cb65" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="translated">PCG-64: el predeterminado. Un generador r&amp;aacute;pido que admite muchos flujos paralelos y puede avanzar en una cantidad arbitraria. Consulte la documentaci&amp;oacute;n para conocer los &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; . PCG-64 tiene un per&amp;iacute;odo de</target>
        </trans-unit>
        <trans-unit id="ec3f94c212b0721b903c3ee685e360e3ef15a646" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r4523891264fe-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r4523891264fe-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1cc812d4eb7fa422b89cbdb7060063b9828124" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="translated">PCG-64 es una implementaci&amp;oacute;n de 128 bits del generador de congruencia de permutaci&amp;oacute;n de O'Neill ( &lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; ). PCG-64 tiene un per&amp;iacute;odo de</target>
        </trans-unit>
        <trans-unit id="4af2a60ae4795c459c6aaf972e39b31efa85a47c" translate="yes" xml:space="preserve">
          <source>PCG64</source>
          <target state="translated">PCG64</target>
        </trans-unit>
        <trans-unit id="8b80c7ece909214affee51ebe9e335eee960dd93" translate="yes" xml:space="preserve">
          <source>PCG64 (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3f1df54c65ec3141b5ad7708d8f310bb35110f" translate="yes" xml:space="preserve">
          <source>PCG64.advance()</source>
          <target state="translated">PCG64.advance()</target>
        </trans-unit>
        <trans-unit id="f8024fbbc3a3aef5b6b9fb19f286aa8ddd8b1f19" translate="yes" xml:space="preserve">
          <source>PCG64.cffi</source>
          <target state="translated">PCG64.cffi</target>
        </trans-unit>
        <trans-unit id="b27789fa8622c7f5407c0a21c98dc4e2c03c99f5" translate="yes" xml:space="preserve">
          <source>PCG64.ctypes</source>
          <target state="translated">PCG64.ctypes</target>
        </trans-unit>
        <trans-unit id="010490775ec92003581521aea797462d39c6844f" translate="yes" xml:space="preserve">
          <source>PCG64.jumped()</source>
          <target state="translated">PCG64.jumped()</target>
        </trans-unit>
        <trans-unit id="e1d334c49d4a4c7a9578ef9b5cd8b69493afac43" translate="yes" xml:space="preserve">
          <source>PCG64.state</source>
          <target state="translated">PCG64.state</target>
        </trans-unit>
        <trans-unit id="b4ff946c27bb613726f09f76ac9051fb9b0f1727" translate="yes" xml:space="preserve">
          <source>PEP 3141 numeric objects (including builtins)</source>
          <target state="translated">PEP 3141 objetos numéricos (incluidos los incorporados)</target>
        </trans-unit>
        <trans-unit id="93b1d16c8417eaf68b67a446e7919aa4647e6c45" translate="yes" xml:space="preserve">
          <source>PINF (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728c523d01503026dd65bbe13e4eb1af6cdeb12e" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL</source>
          <target state="translated">PY_ARRAY_UNIQUE_SYMBOL</target>
        </trans-unit>
        <trans-unit id="bf891340ec2a11d1acd9aa49c131d2652c5c5626" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL (C macro)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adb71a4a1fa67dfff7b23658e29a4c4a31b4cbc" translate="yes" xml:space="preserve">
          <source>PY_UFUNC_UNIQUE_SYMBOL (C variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61443247e63f7e1c0daa436e40747dc59c5d67e" translate="yes" xml:space="preserve">
          <source>PZERO (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6424a476b9cde6f4b3f1412e542dd2b247eca9" translate="yes" xml:space="preserve">
          <source>PZERO : Defines positive zero.</source>
          <target state="translated">Define el cero positivo.</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="187a0323079ad9d1ef0a509dbcf41c04c294cb65" translate="yes" xml:space="preserve">
          <source>Packaging (&lt;code&gt;numpy.distutils&lt;/code&gt;)</source>
          <target state="translated">Empaquetado ( &lt;code&gt;numpy.distutils&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f08e1747044acab6d3f1cde93a671bbd941456b2" translate="yes" xml:space="preserve">
          <source>Packaging (numpy.distutils)</source>
          <target state="translated">Embalaje (numpy.distutils)</target>
        </trans-unit>
        <trans-unit id="ed87cf15ee01e886c94b1a38b3e93dd2cc6fc493" translate="yes" xml:space="preserve">
          <source>Packs the elements of a binary-valued array into bits in a uint8 array.</source>
          <target state="translated">Empaca los elementos de una matriz de valor binario en bits en una matriz uint8.</target>
        </trans-unit>
        <trans-unit id="bd1a1b48e12df64d08abc99d20b4177d10bc8831" translate="yes" xml:space="preserve">
          <source>Pad an array.</source>
          <target state="translated">Coloca una matriz.</target>
        </trans-unit>
        <trans-unit id="623338c7d8c79f8103d39448c8e5b48ec92bd71f" translate="yes" xml:space="preserve">
          <source>Pad the exponent with zeros until it contains at least this many digits. If omitted, the exponent will be at least 2 digits.</source>
          <target state="translated">Rellena el exponente con ceros hasta que contenga al menos esta cantidad de dígitos.Si se omite,el exponente será de al menos 2 dígitos.</target>
        </trans-unit>
        <trans-unit id="b75a7faadf1505590310ce2efd9e725c23bd6630" translate="yes" xml:space="preserve">
          <source>Pad the left side of the string with whitespace until at least that many characters are to the left of the decimal point.</source>
          <target state="translated">Rellene el lado izquierdo de la cadena con espacios en blanco hasta que al menos tantos caracteres estén a la izquierda del punto decimal.</target>
        </trans-unit>
        <trans-unit id="5afbc760d761bf736b4d58352656b475cf0c23ca" translate="yes" xml:space="preserve">
          <source>Pad the right side of the string with whitespace until at least that many characters are to the right of the decimal point.</source>
          <target state="translated">Rellena el lado derecho de la cadena con espacios en blanco hasta que al menos tantos caracteres estén a la derecha del punto decimal.</target>
        </trans-unit>
        <trans-unit id="d76599ff9339cbc70b09ca989f2b38f16c5bb949" translate="yes" xml:space="preserve">
          <source>Padded array of rank equal to &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; with shape increased according to &lt;code&gt;pad_width&lt;/code&gt;.</source>
          <target state="translated">Matriz acolchada de rango igual a la &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; con forma aumentada seg&amp;uacute;n &lt;code&gt;pad_width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee9a393873e0b61a69dbdfe6eb9af32cf2ca2765" translate="yes" xml:space="preserve">
          <source>Padding Arrays</source>
          <target state="translated">Arreglos de acolchado</target>
        </trans-unit>
        <trans-unit id="0e79fa15dcf3528049b2a29ae0606a9732799d3f" translate="yes" xml:space="preserve">
          <source>Padding arrays</source>
          <target state="translated">Matrices de acolchado</target>
        </trans-unit>
        <trans-unit id="7d526b53b9f3056522af85f26a2d434f580eafad" translate="yes" xml:space="preserve">
          <source>Padding function, see Notes.</source>
          <target state="translated">Función de acolchado,véase Notas.</target>
        </trans-unit>
        <trans-unit id="ed38b70d664fac1df990b27835f8a3a31c0260f4" translate="yes" xml:space="preserve">
          <source>Pads with a constant value.</source>
          <target state="translated">Almohadillas con un valor constante.</target>
        </trans-unit>
        <trans-unit id="d9f2ac48720b42a9d74674f19c7f64e1c0499c32" translate="yes" xml:space="preserve">
          <source>Pads with the edge values of array.</source>
          <target state="translated">Almohadillas con los valores de los bordes de la matriz.</target>
        </trans-unit>
        <trans-unit id="fca51805348b473c846607d0a2857abe02017fd5" translate="yes" xml:space="preserve">
          <source>Pads with the linear ramp between end_value and the array edge value.</source>
          <target state="translated">Las almohadillas con la rampa lineal entre end_value y el valor de borde de la matriz.</target>
        </trans-unit>
        <trans-unit id="630cd57bb220770a2f515175c115bde03142bb98" translate="yes" xml:space="preserve">
          <source>Pads with the maximum value of all or part of the vector along each axis.</source>
          <target state="translated">Almohadillas con el valor máximo de todo o parte del vector a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="d3b2120b9c4caeb3f445da36215883fca44003eb" translate="yes" xml:space="preserve">
          <source>Pads with the mean value of all or part of the vector along each axis.</source>
          <target state="translated">Almohadillas con el valor medio de todo o parte del vector a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="65b8c9f7297b280c0b0ee0ea3cb9a6f56b7bac40" translate="yes" xml:space="preserve">
          <source>Pads with the median value of all or part of the vector along each axis.</source>
          <target state="translated">Almohadillas con el valor medio de todo o parte del vector a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="ec1953311c26ffb67e42015bdd267c1393f31365" translate="yes" xml:space="preserve">
          <source>Pads with the minimum value of all or part of the vector along each axis.</source>
          <target state="translated">Almohadillas con el valor mínimo de todo o parte del vector a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="84bf3b9c4e883de4227d55b10846e004bac799fd" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored along the edge of the array.</source>
          <target state="translated">Almohadillas con el reflejo del vector reflejado a lo largo del borde de la matriz.</target>
        </trans-unit>
        <trans-unit id="4b83447ca8923bd3b3b6c9f855b78e24ddedd519" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</source>
          <target state="translated">Almohadillas con el reflejo del vector reflejado en el primer y último valor del vector a lo largo de cada eje.</target>
        </trans-unit>
        <trans-unit id="ef5d2e46c3cd8911ff34acad9b1fd07efaafaa7f" translate="yes" xml:space="preserve">
          <source>Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</source>
          <target state="translated">Almohadillas con la envoltura del vector a lo largo del eje.Los primeros valores se usan para rellenar el final y los valores finales se usan para rellenar el principio.</target>
        </trans-unit>
        <trans-unit id="5d9b9b2531a80866d4446740404b61350cb894e2" translate="yes" xml:space="preserve">
          <source>Pads with undefined values.</source>
          <target state="translated">Almohadillas con valores no definidos.</target>
        </trans-unit>
        <trans-unit id="30bf8ab0f9434e52331cad6b06732b0029f39c77" translate="yes" xml:space="preserve">
          <source>Paired indices, comma separated (not colon), specifying slices to reduce.</source>
          <target state="translated">Índices emparejados,separados por comas (no por dos puntos),especificando los trozos a reducir.</target>
        </trans-unit>
        <trans-unit id="a438d0b43daa8f2d136f89cacc82c90b7152dea4" translate="yes" xml:space="preserve">
          <source>Papoulis, A., &amp;ldquo;Probability, Random Variables, and Stochastic Processes,&amp;rdquo; 3rd ed., New York: McGraw-Hill, 1991.</source>
          <target state="translated">Papoulis, A., &amp;ldquo;Probabilidad, variables aleatorias y procesos estoc&amp;aacute;sticos&amp;rdquo;, 3&amp;ordf; ed., Nueva York: McGraw-Hill, 1991.</target>
        </trans-unit>
        <trans-unit id="b8d6037f133c5f0d5c4523ae33087584f0a1405b" translate="yes" xml:space="preserve">
          <source>Parallel Applications</source>
          <target state="translated">Aplicaciones paralelas</target>
        </trans-unit>
        <trans-unit id="aac167a2f3e07666230480dee8733fd1d08660a0" translate="yes" xml:space="preserve">
          <source>Parallel Congruent Generator (64-bit, PCG64)</source>
          <target state="translated">Generador Congruente Paralelo (64-bit,PCG64)</target>
        </trans-unit>
        <trans-unit id="c11bc78976f584d51e758640f9947c4868085ffb" translate="yes" xml:space="preserve">
          <source>Parallel Generation</source>
          <target state="translated">Generación paralela</target>
        </trans-unit>
        <trans-unit id="28c385ef0bb17bc2f9b3f8a95422e1692d0ab57f" translate="yes" xml:space="preserve">
          <source>Parallel Random Number Generation</source>
          <target state="translated">Generación de números aleatorios paralelos</target>
        </trans-unit>
        <trans-unit id="a05f67574ff8722f0c85f0dfa090ee3948151417" translate="yes" xml:space="preserve">
          <source>Parallel builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9941199a0536bd27f4ba9e0cd3912352ab02906b" translate="yes" xml:space="preserve">
          <source>Parallel generation</source>
          <target state="translated">Generación paralela</target>
        </trans-unit>
        <trans-unit id="e68f24d053a783af78bf2916ad834b59d3272612" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (k dimension for sample of dimension k).</source>
          <target state="translated">Parámetro de la distribución (dimensión k para la muestra de la dimensión k).</target>
        </trans-unit>
        <trans-unit id="5aa3c312bfd3d4206107887488694b91a51af27a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (length &lt;code&gt;k&lt;/code&gt; for sample of length &lt;code&gt;k&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f52333135962fba02933f939303deb96a3ad5b" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt; 0.</source>
          <target state="translated">Par&amp;aacute;metro de la distribuci&amp;oacute;n,&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="ea913350c134ad81bd1f5863f2b7b64acafebc1a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0 and &amp;lt;=1.</source>
          <target state="translated">Par&amp;aacute;metro de la distribuci&amp;oacute;n,&amp;gt; = 0 y &amp;lt;= 1.</target>
        </trans-unit>
        <trans-unit id="617d0343737dbfbd0f0f6ec71b30f6e0961d6b3c" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0. Floats are also accepted, but they will be truncated to integers.</source>
          <target state="translated">Par&amp;aacute;metro de la distribuci&amp;oacute;n,&amp;gt; = 0. Tambi&amp;eacute;n se aceptan flotantes, pero se truncar&amp;aacute;n a enteros.</target>
        </trans-unit>
        <trans-unit id="41e8c4e61c4d4560f4c6864639517a272c9f4976" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Default is 0.</source>
          <target state="translated">Parámetro de la distribución.El valor por defecto es 0.</target>
        </trans-unit>
        <trans-unit id="699574a6b4b57fab6065ea4b5f6ef3f03b3ea735" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative.</source>
          <target state="translated">Parámetro de la distribución.Debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="1b9843d14161f83cfaa303eb7a8d9c859f6d9f77" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">Parámetro de la distribución.Debe ser no negativo.El valor por defecto es 1.</target>
        </trans-unit>
        <trans-unit id="e42d7698a7fc31da8e47db0ca607a272026fd177" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must satisfy 0 &amp;lt; p &amp;lt;= 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c357c2b875b90cada80608cc164df535a0ecfc" translate="yes" xml:space="preserve">
          <source>Parameter, must be non-negative.</source>
          <target state="translated">Parámetro,debe ser no negativo.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="9e0892c276c48dd008b5fe6e010bfd8cfb08da04" translate="yes" xml:space="preserve">
          <source>Parametric tests</source>
          <target state="translated">Pruebas paramétricas</target>
        </trans-unit>
        <trans-unit id="768ae1b1301865b35eda7aa4c4ef56497e1e3a2c" translate="yes" xml:space="preserve">
          <source>Parent name.</source>
          <target state="translated">Nombre del padre.</target>
        </trans-unit>
        <trans-unit id="0afd4ac6a1f194c4487e49e8f1f570664d022158" translate="yes" xml:space="preserve">
          <source>Pareto, V. (1896). Course of Political Economy. Lausanne.</source>
          <target state="translated">Pareto,V.(1896).Curso de Economía Política.Lausana.</target>
        </trans-unit>
        <trans-unit id="5fa3e0d5937fa68006f8ed4ea820c3f856e05107" translate="yes" xml:space="preserve">
          <source>Parse and compare numpy version strings.</source>
          <target state="translated">Analice y compare las cuerdas de la versión numérica.</target>
        </trans-unit>
        <trans-unit id="89743befa343f135565af63acf81651d7fa56a28" translate="yes" xml:space="preserve">
          <source>Partial sort.</source>
          <target state="translated">Una especie parcial.</target>
        </trans-unit>
        <trans-unit id="c9b347464deed01215a4b73f0c568de4c1b1f29c" translate="yes" xml:space="preserve">
          <source>Partial support for 64-bit f2py extensions with MinGW</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1f476600e3b441461161e5761f11632e411e50" translate="yes" xml:space="preserve">
          <source>Partition (split) each element around the right-most separator.</source>
          <target state="translated">Divide cada elemento alrededor del separador más a la derecha.</target>
        </trans-unit>
        <trans-unit id="8e7a1711564903156f9d326524293916fcf5f95c" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;a&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">Partici&amp;oacute;n cada elemento en &lt;code&gt;a&lt;/code&gt; alrededor de &lt;code&gt;sep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f7f9acaefcb4179a22219e6e4159e78558c3ee" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;self&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f060d2d7460c8bb8da409bb17ec782b77da6c8" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;code&gt;axis=None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cd8d136978e78fbd97dbe5ed74c150dbf70d53" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;em&gt;axis&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="translated">Pase &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; para el eje para lograr el mismo efecto que se obtiene al pasar &lt;em&gt;eje&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; en Python (tratando la matriz como una matriz 1-d).</target>
        </trans-unit>
        <trans-unit id="58a3162e63c74cd0a5b9f30fee127febc4cf5551" translate="yes" xml:space="preserve">
          <source>Pass the data and shape information on to a subroutine or other section of code that actually performs the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156da705bee027f7cedec8eb9921a006c401c66c" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=0&lt;/code&gt; to factory functions in &lt;code&gt;numpy.rec&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10d9cbcf594e625c1e314a82048242c6dbb90d" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=None&lt;/code&gt; to functions with a non-optional shape argument is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15e20b835ab140727ff8c5a5d6d26cf599eec85" translate="yes" xml:space="preserve">
          <source>Passing None for &lt;code&gt;dtype&lt;/code&gt; is different from omitting the parameter, since the former invokes &lt;code&gt;dtype(None)&lt;/code&gt; which is an alias for &lt;code&gt;dtype('float_')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89022c4aa33577203e66e96c9430c9099309a83" translate="yes" xml:space="preserve">
          <source>Passing a single array in the &amp;lsquo;out&amp;rsquo; keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</source>
          <target state="translated">Pasar una sola matriz en el argumento de palabra clave 'out' a un ufunc con m&amp;uacute;ltiples salidas est&amp;aacute; desaprobado y generar&amp;aacute; una advertencia en numpy 1.10 y un error en una versi&amp;oacute;n futura.</target>
        </trans-unit>
        <trans-unit id="cc5f2cbfa94aa687203b7f58cf1ebb3635d8adf8" translate="yes" xml:space="preserve">
          <source>Passing in a unit will change the precision</source>
          <target state="translated">Pasar en una unidad cambiará la precisión</target>
        </trans-unit>
        <trans-unit id="0f7da55a06e16eb446ed0921edff81714e6fd8fa" translate="yes" xml:space="preserve">
          <source>Path to data files can be a function taking no arguments and returning path(s) to data files &amp;ndash; this is a useful when data files are generated while building the package. (XXX: explain the step when this function are called exactly)</source>
          <target state="translated">La ruta a los archivos de datos puede ser una funci&amp;oacute;n que no toma argumentos y devuelve la (s) ruta (s) a los archivos de datos; esto es &amp;uacute;til cuando los archivos de datos se generan mientras se crea el paquete. (XXX: explique el paso cuando se llama a esta funci&amp;oacute;n exactamente)</target>
        </trans-unit>
        <trans-unit id="7b09e5c11956eb9c1498f52bbb0e9c021d2dd1d7" translate="yes" xml:space="preserve">
          <source>Path to install the library, relative to the current sub-package.</source>
          <target state="translated">Ruta para instalar la biblioteca,relativa al subpaquete actual.</target>
        </trans-unit>
        <trans-unit id="bcea45c9bd2476c9e4cd30676023f4aeef1d6024" translate="yes" xml:space="preserve">
          <source>Path to test module, or None. By default, run the module from which this function is called.</source>
          <target state="translated">Camino al módulo de prueba,o ninguno.Por defecto,ejecute el módulo desde el que se llama esta función.</target>
        </trans-unit>
        <trans-unit id="5aaad5ad47911a6ee3698400062dbd905a7c854b" translate="yes" xml:space="preserve">
          <source>Path to the directory where the source file gets downloaded to for use. If &lt;code&gt;destpath&lt;/code&gt; is None, a temporary directory will be created. The default path is the current directory.</source>
          <target state="translated">Ruta al directorio donde se descarga el archivo de origen para su uso. Si &lt;code&gt;destpath&lt;/code&gt; es None, se crear&amp;aacute; un directorio temporal. La ruta predeterminada es el directorio actual.</target>
        </trans-unit>
        <trans-unit id="f9f9dd4b0f8cff037993dd2cabb077c76f25ccdf" translate="yes" xml:space="preserve">
          <source>Path to the mapped file.</source>
          <target state="translated">Camino al archivo mapeado.</target>
        </trans-unit>
        <trans-unit id="469a6fbd3b07320fafdf1032dad3f5f283c78450" translate="yes" xml:space="preserve">
          <source>Pathlib support for &lt;code&gt;fromfile&lt;/code&gt;, &lt;code&gt;tofile&lt;/code&gt; and &lt;code&gt;ndarray.dump&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881e30b3dab6ac95c64ea97e026f084d13c834c1" translate="yes" xml:space="preserve">
          <source>Pauli Virtanen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03200e2fcb1cc9aa1208bae4cef4e55d8221f5a" translate="yes" xml:space="preserve">
          <source>Paver (pip)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d38425a72fb16fe116f884b547ba73162e566c" translate="yes" xml:space="preserve">
          <source>Paver is used to build the source releases. It will create the &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;release/installers&lt;/code&gt; directories and put the &lt;code&gt;*.zip&lt;/code&gt; and &lt;code&gt;*.tar.gz&lt;/code&gt; source releases in the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41a92bed03261664717a6afdad4edf3d5d6ef6e" translate="yes" xml:space="preserve">
          <source>Payment</source>
          <target state="translated">Payment</target>
        </trans-unit>
        <trans-unit id="0e3a3cc21418fc90fe6ecc74f59b0c52c7573497" translate="yes" xml:space="preserve">
          <source>Payment against loan plus interest. If all input is scalar, returns a scalar float. If any input is array_like, returns payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Pago contra el préstamo más los intereses.Si todos los datos son escalares,se devuelve un flotador escalar.Si alguna entrada es tipo array_like,devuelve el pago por cada elemento de entrada.Si varias entradas son tipo_arry,todas deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="271672e73ea39752eac8cd415579fb64e6dce733" translate="yes" xml:space="preserve">
          <source>Peak to peak (maximum - minimum) value along a given axis.</source>
          <target state="translated">Valor de pico a pico (máximo-mínimo)a lo largo de un eje determinado.</target>
        </trans-unit>
        <trans-unit id="6440f5bac3611c7691e3f3b6096a90aded3cd7c7" translate="yes" xml:space="preserve">
          <source>Peak-to-peak (maximum - minimum) value along the given axis.</source>
          <target state="translated">Valor pico a pico (máximo-mínimo)a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="a4d9b598086b2e4807ae948d1154096a596ee878" translate="yes" xml:space="preserve">
          <source>People use the terms &amp;ldquo;how-to&amp;rdquo; and &amp;ldquo;tutorial&amp;rdquo; interchangeably, but we draw a distinction, following Daniele Procida&amp;rsquo;s &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;taxonomy of documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cede1363e0d94b858cd773fa14f118d5eb0e6f" translate="yes" xml:space="preserve">
          <source>Percentile implemented in terms of &lt;code&gt;np.partition&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e770ebd82c1aff8fd49c8c27f132133320abb8f" translate="yes" xml:space="preserve">
          <source>Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.</source>
          <target state="translated">Percentil o secuencia de percentiles a computar,que debe estar entre 0 y 100 inclusive.</target>
        </trans-unit>
        <trans-unit id="a255b994d23ac7634da6f95c324c497d0ac47849" translate="yes" xml:space="preserve">
          <source>Percentile output changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591430971d8daa3533d8d46e03b21bb8d090d46c" translate="yes" xml:space="preserve">
          <source>Percentile supports more interpolation options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5a5c70ff7afff4f74e23e5b6f9bc7ce3c427f" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword.</source>
          <target state="translated">Realice una partici&amp;oacute;n indirecta a lo largo del eje dado utilizando el algoritmo especificado por la palabra clave &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6a3a9823da0a46526f859015ecc6fb3fbea02b" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in partitioned order.</source>
          <target state="translated">Realice una partici&amp;oacute;n indirecta a lo largo del eje dado utilizando el algoritmo especificado por la palabra clave &lt;code&gt;kind&lt;/code&gt; . Se devuelve una matriz de &amp;iacute;ndices de la misma forma que &lt;code&gt;a&lt;/code&gt; que los datos de &amp;iacute;ndice a lo largo del eje dado con el fin particiones.</target>
        </trans-unit>
        <trans-unit id="64032456cbe8319e7d98bde786ae8344738e1455" translate="yes" xml:space="preserve">
          <source>Perform an indirect sort along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in sorted order.</source>
          <target state="translated">Realice una ordenaci&amp;oacute;n indirecta a lo largo del eje dado utilizando el algoritmo especificado por la palabra clave &lt;code&gt;kind&lt;/code&gt; . Se devuelve una matriz de &amp;iacute;ndices de la misma forma que &lt;code&gt;a&lt;/code&gt; que los datos de &amp;iacute;ndice a lo largo del eje dado en orden clasificado.</target>
        </trans-unit>
        <trans-unit id="e51a52f04a9140623599aa3b0b98ea5b1cc97dfc" translate="yes" xml:space="preserve">
          <source>Perform an indirect stable sort using a sequence of keys.</source>
          <target state="translated">Realiza una clasificación estable indirecta usando una secuencia de teclas.</target>
        </trans-unit>
        <trans-unit id="67a1b7c0504ae299de04313d9433cb77c326b1c0" translate="yes" xml:space="preserve">
          <source>Perform consistency check of arguments by evaluating &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt;; if &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt; returns 0, an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="6637203688f192cd4c7831fd72958ca38674eef7" translate="yes" xml:space="preserve">
          <source>Performance differs across platforms due to compiler and hardware availability (e.g., register width) differences. The default bit generator has been chosen to perform well on 64-bit platforms. Performance on 32-bit operating systems is very different.</source>
          <target state="translated">El rendimiento difiere entre las plataformas debido a las diferencias en la disponibilidad de los compiladores y el hardware (por ejemplo,el ancho de registro).Se ha elegido el generador de bits por defecto para que funcione bien en plataformas de 64 bits.El rendimiento en los sistemas operativos de 32 bits es muy diferente.</target>
        </trans-unit>
        <trans-unit id="9c52299828f379fa31ccf418c483aeec41f916ab" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.array&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c97591e66a1a7ade5603056a75445a61446141" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.searchsorted&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9603b88256d72407ab6e6c3f19a0ffa5841913bc" translate="yes" xml:space="preserve">
          <source>Performance improvements and changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f4578a97efb62d654157c29d267317ee2475b0" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;code&gt;packbits&lt;/code&gt; and &lt;code&gt;unpackbits&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dba14d8d4ce495c233d380d634d031e87a8cd0" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isinf&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt; and &lt;code&gt;byteswap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b448d45ff6016d5c9cee889d533aea1f08a20b36" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;median&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced4e57dc2a9cf06efc202bc15e74ab7476bdf9c" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;pad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7518fcdea1f898cd57fb2174ab71737760cfa801" translate="yes" xml:space="preserve">
          <source>Performance improvements via SSE2 vectorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4d87af8409567870f0a8884054dba62da5530d" translate="yes" xml:space="preserve">
          <source>Performance on different Operating Systems</source>
          <target state="translated">Rendimiento en diferentes sistemas operativos</target>
        </trans-unit>
        <trans-unit id="5459d1c079af547b963e3b424e98d9eb9d73b000" translate="yes" xml:space="preserve">
          <source>Performance tuning</source>
          <target state="translated">Ajuste del rendimiento</target>
        </trans-unit>
        <trans-unit id="d8745def767a8cd0cac8c9e4b16803d5c76be3a9" translate="yes" xml:space="preserve">
          <source>Performance-Related Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8da6105b8a6d69384985610612578b000a977b" translate="yes" xml:space="preserve">
          <source>Performs a (local) reduce with specified slices over a single axis.</source>
          <target state="translated">Realiza una reducción (local)con cortes especificados sobre un solo eje.</target>
        </trans-unit>
        <trans-unit id="793e356298f57d9115bf94bc021ff4af3ab35b36" translate="yes" xml:space="preserve">
          <source>Performs element-wise comparison of two string arrays using the comparison operator specified by &lt;code&gt;cmp_op&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5da77705e71b95e951ed4d7ec45e06388841c4" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;.</source>
          <target state="translated">Realiza una operaci&amp;oacute;n in situ sin b&amp;uacute;fer en el operando 'a' para los elementos especificados por '&amp;iacute;ndices'.</target>
        </trans-unit>
        <trans-unit id="64fcbb980b448111a78376527afea140c32d0b99" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;. For addition ufunc, this method is equivalent to &lt;code&gt;a[indices] += b&lt;/code&gt;, except that results are accumulated for elements that are indexed more than once. For example, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; will only increment the first element once because of buffering, whereas &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; will increment the first element twice.</source>
          <target state="translated">Realiza una operaci&amp;oacute;n in situ sin b&amp;uacute;fer en el operando 'a' para los elementos especificados por '&amp;iacute;ndices'. Para la adici&amp;oacute;n ufunc, este m&amp;eacute;todo es equivalente a &lt;code&gt;a[indices] += b&lt;/code&gt; , excepto que los resultados se acumulan para los elementos que est&amp;aacute;n indexados m&amp;aacute;s de una vez. Por ejemplo, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; solo incrementar&amp;aacute; el primer elemento una vez debido al almacenamiento en b&amp;uacute;fer, mientras que &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; incrementar&amp;aacute; el primer elemento dos veces.</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
