<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">He aquí un modismo útil para obtener copias contiguas en lugar de vistas no contiguas.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">Aqu&amp;iacute; hay una funci&amp;oacute;n de ejemplo que opera como una ufunc &quot;lambda&quot;:</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">He aquí un ejemplo de la función del producto exterior:</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">Así es como se utilizan las variables anteriores:</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">Así es como se pueden usar con un conjunto de muestras:</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">As&amp;iacute; es como podr&amp;iacute;amos escribir una funci&amp;oacute;n &lt;code&gt;iter_add&lt;/code&gt; , usando el protocolo de iterador de Python:</target>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">Aquí está la misma función,pero siguiendo el patrón del estilo C:</target>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la lista de sum_squares.pyx:</target>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">Aqu&amp;iacute;, he usado el iterador enumerado incorporado para devolver el &amp;iacute;ndice del iterador y el valor.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">Aquí,la U se dibuja a partir de la distribución uniforme sobre (0,1).</target>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">La clase de la Hermafrodita</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">M&amp;oacute;dulo de Hermite, &quot;F&amp;iacute;sicos&quot; ( &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">M&amp;oacute;dulo de Hermite, &quot;F&amp;iacute;sicos&quot; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">Módulo de Hermite,&quot;Físicos&quot; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">Los coeficientes de Hermite en orden de grado creciente, es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; dan &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Coeficientes de Hermite ordenados de menor a mayor. Si &lt;code&gt;y&lt;/code&gt; era 2-D, los coeficientes de los datos de la columna k de &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n en la columna &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">Serie Hermite</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">Coeficientes de la serie Hermite de la integral.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">La serie de energía de Hermite.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">La serie Hermite del derivado.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">La serie de Hermite cuyo gráfico es una línea recta.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">La función de peso de los hermafroditas</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">Clase HermiteE</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">M&amp;oacute;dulo HermiteE, &quot;Probabilistas&quot; ( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">M&amp;oacute;dulo HermiteE, &quot;Probabilistas&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">Módulo HermiteE,&quot;Probabilistas&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">Los coeficientes de HermiteE en orden de grado creciente, es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; dan &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">Serie HermiteE</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">Funzione peso HermiteE.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">Coefficienti della serie Hermite_e dell'integrale.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Ermitiano (simmetrico se tutti gli elementi sono reali),matrice di ingresso positiva definita.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">FFT ermitiane</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">Matrici ermitiane o reali simmetriche i cui autovalori e autovettori devono essere calcolati.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">I polinomi di alto ordine possono oscillare selvaggiamente:</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">Dimensioni superiori</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L'Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, vol. 20, n&amp;uacute;m. 3, verano de 2008, p&amp;aacute;gs. 385-390.</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">El esquema de Horner &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; se utiliza para evaluar el polinomio. Aun as&amp;iacute;, para polinomios de alto grado, los valores pueden ser inexactos debido a errores de redondeo. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">Cu&amp;aacute;ntos bytes se necesitan para saltar desde el final de una dimensi&amp;oacute;n hasta su comienzo. Tenga en cuenta que &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; , pero se almacena aqu&amp;iacute; como una optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">Quante prove sono riuscite dopo una sola prova?</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">C&amp;oacute;mo tratar las fechas que no caen en un d&amp;iacute;a v&amp;aacute;lido. El valor predeterminado es 'subir'.</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C&amp;oacute;mo utilizar un iterador de matriz en un nivel C se explica con m&amp;aacute;s detalle en secciones posteriores. Normalmente, no es necesario que se preocupe por la estructura interna del objeto iterador y simplemente interact&amp;uacute;e con &amp;eacute;l mediante el uso de las macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) o &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index). Todas estas macros requieren el argumento de &lt;em&gt;que&lt;/em&gt; sea un &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">Tuttavia,gli array scalari sono immutabili,quindi nessuno degli attributi scalari dell'array è impostabile.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">Sin embargo, para una matriz 2D, &lt;code&gt;tolist&lt;/code&gt; se aplica de forma recursiva:</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">Sin embargo, si la longitud del paso es un &lt;strong&gt;n&amp;uacute;mero complejo&lt;/strong&gt; (por ejemplo, 5j), entonces la parte entera de su magnitud se interpreta como la especificaci&amp;oacute;n del n&amp;uacute;mero de puntos a crear entre los valores de inicio y finalizaci&amp;oacute;n, donde el valor de parada &lt;strong&gt;es inclusivo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, tambi&amp;eacute;n proporciona un mecanismo de filtro para solucionar &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">Sin embargo, dado que las matrices de indexaci&amp;oacute;n anteriores simplemente se repiten, se puede usar la transmisi&amp;oacute;n (compare operaciones como &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; ) para simplificar esto:</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">Sin embargo, esta clase no se ejecuta directamente. M&amp;aacute;s bien, sirve como una clase base para varias otras clases de Python, cada una espec&amp;iacute;fica para un tipo de datos en particular. La clase &lt;code&gt;VectorTestCase&lt;/code&gt; almacena dos cadenas para escribir informaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">Coseno iperbolico,elementare.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">Funciones hiperbólicas</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">Seno iperbolico,elementare.</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">IN Bronshtein, KA Semendyayev y KA Hirsch (Ed. Trans. Inglesa), &lt;em&gt;Handbook of Mathematics&lt;/em&gt; , Nueva York, Van Nostrand Reinhold Co., 1985, p&amp;aacute;g. 720.</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dell'infinito (positivo).</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">Rappresentazione in virgola mobile IEEE 754 di Not a Number (NaN).</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dell'infinito negativo.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">Rappresentazione in virgola mobile IEEE 754 dello zero negativo.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754 rappresentazione in virgola mobile dello zero positivo.</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">Norma ISO / IEC 9899: 1999, &quot;Lenguaje de programaci&amp;oacute;n C.&quot;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">Función de identidad.</target>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Si est&amp;aacute; &quot;izquierda&quot;, se proporciona el &amp;iacute;ndice de la primera ubicaci&amp;oacute;n adecuada encontrada. Si es 'correcto', devuelve el &amp;uacute;ltimo &amp;iacute;ndice de este tipo. Si no hay un &amp;iacute;ndice adecuado, devuelve 0 o N (donde N es la longitud de &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">Si 'out' es None (el valor predeterminado), se crea una matriz de retorno no inicializada. Luego, la matriz de salida se llena con los resultados de ufunc en los lugares donde la transmisi&amp;oacute;n 'donde' es Verdadero. Si 'donde' es el escalar Verdadero (el valor predeterminado), esto corresponde a la salida completa que se est&amp;aacute; llenando. Tenga en cuenta que las salidas que no se llenan expl&amp;iacute;citamente se quedan con sus valores no inicializados.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se pasan valores -1 / NULL a &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; y &lt;code&gt;buffersize&lt;/code&gt; , es equivalente a &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">Si &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; est&amp;aacute; #definido, independientemente de si &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; lo&lt;/a&gt; es, la C-API se declara &lt;code&gt;extern void**&lt;/code&gt; , por lo que se espera que se defina en otra unidad de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">Si se llam&amp;oacute; a &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; , es posible que desee habilitar el indicador &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; . Este indicador no est&amp;aacute; permitido junto con &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; , por lo que esta funci&amp;oacute;n se proporciona para habilitar la funci&amp;oacute;n despu&amp;eacute;s de que se &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; . Esta funci&amp;oacute;n tambi&amp;eacute;n restablece el iterador a su estado inicial.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">Si &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; est&amp;aacute; #definido, pero &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; no, la C-API se declara &lt;code&gt;void**&lt;/code&gt; , de modo que tambi&amp;eacute;n ser&amp;aacute; visible para otras unidades de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">Si se establece &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , la matriz se copia solo si dtype no coincide:</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; no son unidimensionales, la salida tambi&amp;eacute;n tiene estas dimensiones.</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; son una cadena, se interpretan como una matriz con comas o espacios que separan las columnas y punto y coma que separan las filas.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">Si los &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; ya son un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , este indicador determina si los datos se copian (el valor predeterminado) o si se construye una vista.</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">Si &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , las &lt;code&gt;reps&lt;/code&gt; se promueven a &lt;code&gt;A&lt;/code&gt; .ndim con 1 pre-pendientes. Por lo tanto, para una &lt;code&gt;A&lt;/code&gt; de forma (2, 3, 4, 5), las &lt;code&gt;reps&lt;/code&gt; de (2, 2) se tratan como (1, 1, 2, 2).</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">Si &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; se promueve a d-dimensional anteponiendo nuevos ejes. Entonces, una matriz de forma (3,) se promueve a (1, 3) para la replicaci&amp;oacute;n 2-D, o forma (1, 1, 3) para la replicaci&amp;oacute;n 3-D. Si este no es el comportamiento deseado, promueva las dimensiones &lt;code&gt;A&lt;/code&gt; a d manualmente antes de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">Si es &lt;code&gt;False&lt;/code&gt; , el resultado contendr&amp;aacute; el n&amp;uacute;mero de muestras en cada contenedor. Si es &lt;code&gt;True&lt;/code&gt; , el resultado es el valor de la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el intervalo , normalizado de manera que la &lt;em&gt;integral&lt;/em&gt; sobre el rango sea 1. Tenga en cuenta que la suma de los valores del histograma no ser&amp;aacute; igual a 1 a menos que se elijan intervalos de ancho unitario; no es una funci&amp;oacute;n de &lt;em&gt;masa de&lt;/em&gt; probabilidad .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Si es &lt;code&gt;None&lt;/code&gt; (predeterminado), se supone que todas las constantes son cero. Si &lt;code&gt;m = 1&lt;/code&gt; , se puede dar un solo escalar en lugar de una lista.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , intercambia bytes en el lugar, el valor predeterminado es &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , el l&amp;iacute;mite de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n se refiere al n&amp;uacute;mero total de d&amp;iacute;gitos despu&amp;eacute;s del punto decimal, incluidos los ceros iniciales. Si es &lt;code&gt;False&lt;/code&gt; , la &lt;code&gt;precision&lt;/code&gt; refiere al n&amp;uacute;mero total de d&amp;iacute;gitos significativos, antes o despu&amp;eacute;s del punto decimal, ignorando los ceros iniciales.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , entonces almacena en cach&amp;eacute; la primera llamada de funci&amp;oacute;n que determina el n&amp;uacute;mero de salidas si no se proporcionan &lt;code&gt;otypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , utilice una estrategia de generaci&amp;oacute;n de d&amp;iacute;gitos que proporcione la representaci&amp;oacute;n m&amp;aacute;s corta que identifique de forma &amp;uacute;nica el n&amp;uacute;mero de punto flotante de otros valores del mismo tipo, mediante un redondeo juicioso. Si se omiti&amp;oacute; la &lt;code&gt;precision&lt;/code&gt; , imprima todos los d&amp;iacute;gitos necesarios; de lo contrario, la generaci&amp;oacute;n de d&amp;iacute;gitos se corta despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n y el valor restante se redondea. Si es &lt;code&gt;False&lt;/code&gt; , los d&amp;iacute;gitos se generan como si se imprimiera un valor de precisi&amp;oacute;n infinita y se detuvieran despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n , redondeando el valor restante.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , utilice una estrategia de generaci&amp;oacute;n de d&amp;iacute;gitos que proporcione la representaci&amp;oacute;n m&amp;aacute;s corta que identifique de forma &amp;uacute;nica el n&amp;uacute;mero de punto flotante de otros valores del mismo tipo, mediante un redondeo juicioso. Si se omiti&amp;oacute; la &lt;code&gt;precision&lt;/code&gt; , imprima todos los d&amp;iacute;gitos necesarios; de lo contrario, la generaci&amp;oacute;n de d&amp;iacute;gitos se corta despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n y el valor restante se redondea. Si es &lt;code&gt;False&lt;/code&gt; , los d&amp;iacute;gitos se generan como si se imprimiera un valor de precisi&amp;oacute;n infinita y se detuvieran despu&amp;eacute;s de &lt;code&gt;precision&lt;/code&gt; d&amp;iacute;gitos de precisi&amp;oacute;n , redondeando el valor restante.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 2-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Si &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , entonces las columnas de &lt;code&gt;V&lt;/code&gt; corresponden a los elementos de una matriz de coeficientes 3-D &lt;code&gt;c&lt;/code&gt; de forma (xdeg + 1, ydeg + 1, zdeg + 1) en el orden</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">Si &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; , devuelve el valor de relleno; de lo contrario, devuelve Ninguno.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">Si &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; , se eliminan las dimensiones especificadas por &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; , y se inserta un nuevo eje en el extremo correspondiente a la diagonal.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">Si &lt;code&gt;a.ndim&lt;/code&gt; es 0, dado que la profundidad de la lista anidada es 0, no ser&amp;aacute; una lista en absoluto, sino un simple escalar de Python.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">Si &lt;code&gt;a.shape&lt;/code&gt; es (5,1), &lt;code&gt;b.shape&lt;/code&gt; es (1,6), &lt;code&gt;c.shape&lt;/code&gt; es (6,) y &lt;code&gt;d.shape&lt;/code&gt; es () de modo que &lt;em&gt;d&lt;/em&gt; es un escalar, entonces &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; , &lt;em&gt;c&lt;/em&gt; , y &lt;em&gt;d&lt;/em&gt; son todos broadcastable a la dimensi&amp;oacute;n (5,6); y</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son escalar, sus &amp;uacute;ltimas dimensiones deben coincidir.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; y cada matriz de opciones no son todas asignables a la misma forma.</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no posee sus propios datos o referencias o vistas, existen, y la memoria de datos debe cambiarse. Solo PyPy: siempre se generar&amp;aacute; si se debe cambiar la memoria de datos, ya que no hay una forma confiable de determinar si existen referencias o vistas a ella.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, entonces se aplican las reglas de transmisi&amp;oacute;n, como se explica en &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;&amp;Aacute;lgebra lineal en varias matrices a la vez&lt;/a&gt; . Esto significa que SVD est&amp;aacute; trabajando en modo &quot;apilado&quot;: itera sobre todos los &amp;iacute;ndices de la primera &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensiones y para cada combinaci&amp;oacute;n SVD se aplica a los dos &amp;uacute;ltimos &amp;iacute;ndices. La matriz &lt;code&gt;a&lt;/code&gt; se puede reconstruir a partir de la descomposici&amp;oacute;n con &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; o &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; . (El operador &lt;code&gt;@&lt;/code&gt; puede ser reemplazado por la funci&amp;oacute;n &lt;code&gt;np.matmul&lt;/code&gt; para versiones de Python por debajo de 3.5).</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, los ejes especificados por axis1 y axis2 se utilizan para determinar las submatrices 2-D cuyas trazas se devuelven. La forma de la matriz resultante es la misma que la de &lt;code&gt;a&lt;/code&gt; con &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; eliminados.</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 1-D, la funci&amp;oacute;n &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; es la misma que &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; donde los &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; son &lt;code&gt;range(len(array) - 1)&lt;/code&gt; con un cero colocado en cada otro elemento: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, devuelve la diagonal de &lt;code&gt;a&lt;/code&gt; con el desplazamiento dado, es decir, la colecci&amp;oacute;n de elementos de la forma &lt;code&gt;a[i, i+offset]&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; tiene m&amp;aacute;s de dos dimensiones, entonces los ejes especificados por &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; se utilizan para determinar la submatriz 2-D cuya diagonal se devuelve. La forma de la matriz resultante se puede determinar quitando &lt;code&gt;axis1&lt;/code&gt; y &lt;code&gt;axis2&lt;/code&gt; y agregando un &amp;iacute;ndice a la derecha igual al tama&amp;ntilde;o de las diagonales resultantes.</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, se devuelve la suma a lo largo de su diagonal con el desplazamiento dado, es decir, la suma de los elementos &lt;code&gt;a[i,i+offset]&lt;/code&gt; para todo i.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es 2-D, se devuelve la suma a lo largo de la diagonal. Si &lt;code&gt;a&lt;/code&gt; tiene dimensiones m&amp;aacute;s grandes, se devuelve una matriz de sumas a lo largo de las diagonales.</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz de 1-D que contiene la diagonal y 2-D, a continuaci&amp;oacute;n, del mismo tipo como &lt;code&gt;a&lt;/code&gt; se devuelve a menos que &lt;code&gt;a&lt;/code&gt; es una &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , en cuyo caso una matriz de 1-D en lugar de un (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; se devuelve para mantener la compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es un objeto de &lt;code&gt;matrix&lt;/code&gt; (a diferencia de un &lt;code&gt;ndarray&lt;/code&gt; ), entonces tambi&amp;eacute;n lo son todos los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una subclase de &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , su clase se conserva. No se realiza ninguna copia si la entrada ya es un &lt;code&gt;ndarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz ND y &lt;code&gt;b&lt;/code&gt; es una matriz de 1-D, que es un producto suma sobre el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es una matriz ND y &lt;code&gt;b&lt;/code&gt; es una matriz MD (donde &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ), que es un producto suma sobre el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; y la segunda a &amp;uacute;ltima eje de &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es complejo, el conjugado complejo se toma antes del c&amp;aacute;lculo del producto escalar.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no es un &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;a&lt;/code&gt; s&amp;iacute; es devuelto. Si &lt;code&gt;a&lt;/code&gt; es un &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;fill_value&lt;/code&gt; es None, &lt;code&gt;fill_value&lt;/code&gt; se establece en &lt;code&gt;a.fill_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; no es cuadrado o falla la inversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es real, se usa el tipo de &lt;code&gt;a&lt;/code&gt; para la salida. Si &lt;code&gt;a&lt;/code&gt; tiene elementos complejos, el tipo devuelto es flotador.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es singular o no 'cuadrado' (en el sentido anterior).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; es singular o no cuadrado.</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">Si &lt;code&gt;arr&lt;/code&gt; no tiene un atributo de forma (es decir, no es un ndarray)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;axes&lt;/code&gt; son m&amp;aacute;s grandes que el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es 0, solo se enmascaran las filas.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es 1 o -1, solo se enmascaran las columnas.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, las filas &lt;em&gt;y&lt;/em&gt; columnas est&amp;aacute;n enmascaradas.</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es un n&amp;uacute;mero entero, especifica el eje de &lt;code&gt;x&lt;/code&gt; a lo largo del cual calcular las normas vectoriales. Si &lt;code&gt;axis&lt;/code&gt; es una tupla bidimensional, especifica los ejes que contienen matrices bidimensionales y se calculan las normas matriciales de estas matrices. Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, se devuelve una norma vectorial (cuando &lt;code&gt;x&lt;/code&gt; es 1-D) o una norma matricial (cuando &lt;code&gt;x&lt;/code&gt; es 2-D).</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">Si se proporciona &lt;code&gt;axis&lt;/code&gt; , el n&amp;uacute;mero de varargs debe ser igual al n&amp;uacute;mero de ejes. Predeterminado: 1.</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es mayor que el &amp;uacute;ltimo eje de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; y un eje que se comprime no tiene una longitud 1</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">Si &lt;code&gt;b&lt;/code&gt; es una matriz, todos los resultados de la matriz se devuelven como matrices.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es una cadena de la lista siguiente, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; utilizar&amp;aacute; el m&amp;eacute;todo elegido para calcular el ancho &amp;oacute;ptimo del bin y, en consecuencia, el n&amp;uacute;mero de bins (consulte &lt;code&gt;Notes&lt;/code&gt; para obtener m&amp;aacute;s detalles sobre los estimadores) a partir de los datos que se encuentran dentro del rango solicitado. Si bien el ancho del contenedor ser&amp;aacute; &amp;oacute;ptimo para los datos reales en el rango, el n&amp;uacute;mero de contenedores se calcular&amp;aacute; para llenar todo el rango, incluidas las porciones vac&amp;iacute;as. Para la visualizaci&amp;oacute;n, se sugiere usar la opci&amp;oacute;n 'auto'. Los datos ponderados no son compatibles con la selecci&amp;oacute;n autom&amp;aacute;tica del tama&amp;ntilde;o del contenedor.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es una cadena, define el m&amp;eacute;todo utilizado para calcular el ancho &amp;oacute;ptimo de bin, seg&amp;uacute;n lo definido por &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es un int, define el n&amp;uacute;mero de bins de igual ancho en el rango dado (10, por defecto). Si &lt;code&gt;bins&lt;/code&gt; es una secuencia, define una matriz de bordes de bin que aumenta mon&amp;oacute;tonamente, incluido el borde m&amp;aacute;s a la derecha, lo que permite anchos de bin no uniformes.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; es un int, define el n&amp;uacute;mero de bins de igual ancho en el rango dado (10, por defecto). Si los &lt;code&gt;bins&lt;/code&gt; son una secuencia, define los bordes del contenedor, incluido el borde m&amp;aacute;s a la derecha, lo que permite anchos de contenedor no uniformes.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">Si &lt;code&gt;bins&lt;/code&gt; no es mon&amp;oacute;tono.</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">Si el &lt;code&gt;buffer&lt;/code&gt; es Ninguno, solo se utilizan la &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , el &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; y el &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">Si &lt;code&gt;buffer&lt;/code&gt; es un objeto que expone la interfaz del b&amp;uacute;fer, se interpretan todas las palabras clave.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">Si el &lt;code&gt;buffersize&lt;/code&gt; es cero, se usa un tama&amp;ntilde;o de b&amp;uacute;fer predeterminado; de lo contrario, especifica qu&amp;eacute; tama&amp;ntilde;o de b&amp;uacute;fer se debe usar. Se recomiendan b&amp;uacute;feres con potencias de 2, como 4096 u 8192.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de 3 dimensiones, se a&amp;ntilde;aden unos impl&amp;iacute;citamente a su forma para convertirla en 3-D. La forma del resultado ser&amp;aacute; c.shape [3:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de tres dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 3-D. La forma del resultado ser&amp;aacute; c.shape [3:] + x.shape + y.shape + z.shape.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de dos dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape + y.shape.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; tiene menos de dos dimensiones, se a&amp;ntilde;aden unas impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D, se agrega uno impl&amp;iacute;citamente a su forma para convertirla en 2-D. La forma del resultado ser&amp;aacute; c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;hermeval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series HermiteE del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;hermval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Hermite del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;lagval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Laguerre del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = legvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;legval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Legendre del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;chebval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de series de Chebyshev del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D de coeficientes de longitud &lt;code&gt;n + 1&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es la matriz &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; , entonces &lt;code&gt;np.dot(V, c)&lt;/code&gt; y &lt;code&gt;polyval(x, c)&lt;/code&gt; son iguales hasta redondear. Esta equivalencia es &amp;uacute;til tanto para el ajuste por m&amp;iacute;nimos cuadrados como para la evaluaci&amp;oacute;n de un gran n&amp;uacute;mero de polinomios del mismo grado y puntos muestrales.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es una matriz 1-D, entonces &lt;code&gt;p(x)&lt;/code&gt; tendr&amp;aacute; la misma forma que &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;c&lt;/code&gt; es multidimensional, entonces la forma del resultado depende del valor del &lt;code&gt;tensor&lt;/code&gt; . Si el &lt;code&gt;tensor&lt;/code&gt; es verdadero, la forma ser&amp;aacute; c.shape [1:] + x.shape. Si el &lt;code&gt;tensor&lt;/code&gt; es falso, la forma ser&amp;aacute; c.shape [1:]. Tenga en cuenta que los escalares tienen forma (,).</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es de longitud &lt;code&gt;n + 1&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es de longitud &lt;code&gt;n + 1&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor:</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">Si la &lt;code&gt;condition&lt;/code&gt; es booleana:</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Si se proporcionan &lt;code&gt;data&lt;/code&gt; , deben permanecer vivos durante la vida &amp;uacute;til de la matriz. Una forma de gestionar esto es a trav&amp;eacute;s de &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">Si &lt;code&gt;dtype&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , entonces requiere ese tipo de datos. Si se permite la copia, har&amp;aacute; una copia temporal si los datos se pueden convertir. Si &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado, tambi&amp;eacute;n copiar&amp;aacute; los datos con otra conversi&amp;oacute;n tras la destrucci&amp;oacute;n del iterador.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">Si &lt;code&gt;enddates&lt;/code&gt; especifica un valor de fecha que es anterior al valor de fecha de &lt;code&gt;begindates&lt;/code&gt; correspondiente , el recuento ser&amp;aacute; negativo.</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; es una matriz 1-D de enteros ordenados, las entradas indican en qu&amp;eacute; parte del &lt;code&gt;axis&lt;/code&gt; se divide la matriz. Por ejemplo, &lt;code&gt;[2, 3]&lt;/code&gt; , para el &lt;code&gt;axis=0&lt;/code&gt; , resultar&amp;iacute;a en</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; es un n&amp;uacute;mero entero, N, la matriz se dividir&amp;aacute; en N matrices iguales a lo largo del &lt;code&gt;axis&lt;/code&gt; . Si tal divisi&amp;oacute;n no es posible, se genera un error.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">Si &lt;code&gt;indices_or_sections&lt;/code&gt; se da como un n&amp;uacute;mero entero, pero una divisi&amp;oacute;n no da como resultado una divisi&amp;oacute;n igual.</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">Si &lt;code&gt;legacy&lt;/code&gt; es False, o BitGenerator no es NT19937, el estado se devuelve como un diccionario.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , o &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , o &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">Si &lt;code&gt;m1&lt;/code&gt; y &lt;code&gt;m2&lt;/code&gt; tienen diferentes tipos de d flexibles.</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">Si &lt;code&gt;m&lt;/code&gt; tiene una sola columna, esa columna se devuelve como la &amp;uacute;nica fila de una matriz. De lo contrario, se devuelve &lt;code&gt;m&lt;/code&gt; . La matriz devuelta es siempre &lt;code&gt;m&lt;/code&gt; en s&amp;iacute; misma o una vista de &lt;code&gt;m&lt;/code&gt; . Proporcionar un argumento de palabra clave de eje no afectar&amp;aacute; la matriz devuelta, pero puede provocar que se genere un error.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">Si se da &lt;code&gt;maxsplit&lt;/code&gt; , como m&amp;aacute;ximo se &lt;code&gt;maxsplit&lt;/code&gt; divisiones de maxsplit , las m&amp;aacute;s a la derecha.</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">Si se da &lt;code&gt;maxsplit&lt;/code&gt; , como m&amp;aacute;ximo se &lt;code&gt;maxsplit&lt;/code&gt; divisiones de maxsplit .</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es par, &lt;code&gt;A[-1]&lt;/code&gt; contiene el t&amp;eacute;rmino que representa la frecuencia de Nyquist tanto positiva como negativa (+ fs / 2 y -fs / 2), y tambi&amp;eacute;n debe ser puramente real. Si &lt;code&gt;n&lt;/code&gt; es impar, no hay t&amp;eacute;rmino en fs / 2; &lt;code&gt;A[-1]&lt;/code&gt; contiene la mayor frecuencia positiva (fs / 2 * (n-1) / n) y es complejo en el caso general.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">Si &lt;code&gt;names&lt;/code&gt; es Verdadero, los nombres de los campos se leen desde la primera l&amp;iacute;nea despu&amp;eacute;s de las primeras l&amp;iacute;neas &lt;code&gt;skip_header&lt;/code&gt; . Opcionalmente, esta l&amp;iacute;nea puede ir precedida de un delimitador de comentarios. Si &lt;code&gt;names&lt;/code&gt; es una secuencia o una sola cadena de nombres separados por comas, los nombres se usar&amp;aacute;n para definir los nombres de los campos en un tipo d estructurado. Si &lt;code&gt;names&lt;/code&gt; es Ninguno, se utilizar&amp;aacute;n los nombres de los campos dtype, si los hay.</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">Si &lt;code&gt;obj.flags&lt;/code&gt; tiene &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; o (en desuso) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n borra las banderas, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; y lo hace escribible, y establece &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; en NULL. A diferencia de &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; , no intenta copiar los datos de &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; . Esto deshace &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Por lo general, esto se llama despu&amp;eacute;s de un error cuando termina con &lt;code&gt;obj&lt;/code&gt; , justo antes de &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Se puede llamar varias veces o con una entrada &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;obj.flags&lt;/code&gt; tiene &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; o (en desuso) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n borra las banderas, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; y lo hace escribible, y establece &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; en NULL. Luego copia &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; a &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; y devuelve el estado de error de la operaci&amp;oacute;n de copia. Esto es lo opuesto a &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Por lo general, esto se llama una vez que haya terminado con &lt;code&gt;obj&lt;/code&gt; , justo antes de &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Se puede llamar varias veces o con una entrada &lt;code&gt;NULL&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; devuelve una matriz unidimensional llena con los elementos de &lt;em&gt;x&lt;/em&gt; correspondientes a los valores &lt;code&gt;True&lt;/code&gt; de &lt;em&gt;obj&lt;/em&gt; . El orden de b&amp;uacute;squeda ser&amp;aacute; &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;por filas&lt;/a&gt; , C-estilo. Si &lt;em&gt;obj&lt;/em&gt; tiene valores &lt;code&gt;True&lt;/code&gt; en las entradas que est&amp;aacute;n fuera de los l&amp;iacute;mites de &lt;em&gt;x&lt;/em&gt; , se generar&amp;aacute; un error de &amp;iacute;ndice. Si &lt;em&gt;obj&lt;/em&gt; es menor que &lt;em&gt;x&lt;/em&gt; , es id&amp;eacute;ntico a llenarlo con &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">Si &lt;code&gt;obj&lt;/code&gt; no es un tipo num&amp;eacute;rico adecuado.</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; implementa cualquier parte de la interfaz de la matriz, entonces &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; una nueva referencia al ndarray reci&amp;eacute;n creado usando la interfaz o &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;NULL&lt;/code&gt; si ocurre un error durante la conversi&amp;oacute;n. De lo contrario, out contendr&amp;aacute; una referencia prestada a &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; &lt;/a&gt; y no se establece ninguna condici&amp;oacute;n de error.</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; implementa cualquier parte de la interfaz de la matriz, entonces &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; una nueva referencia al ndarray reci&amp;eacute;n creado usando la interfaz o &lt;code&gt;out&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;NULL&lt;/code&gt; si ocurre un error durante la conversi&amp;oacute;n. De lo contrario, out contendr&amp;aacute; una referencia prestada a Py_NotImplemented y no se establece ninguna condici&amp;oacute;n de error. Esta versi&amp;oacute;n permite configurar el tipo y contexto en la parte de la interfaz de matriz que busca el atributo &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">Si &lt;code&gt;op&lt;/code&gt; ya es (estilo C) contiguo y se comporta bien, simplemente devuelva una referencia; de lo contrario, devuelva una copia (contigua y con buen comportamiento) de la matriz. El par&amp;aacute;metro op debe ser una (subclase de un) ndarray y no se realiza ninguna verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;op_dtypes&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , especifica un tipo de datos o &lt;code&gt;NULL&lt;/code&gt; para cada &lt;code&gt;op[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">Si no se especifica &lt;code&gt;otypes&lt;/code&gt; , se utilizar&amp;aacute; una llamada a la funci&amp;oacute;n con el primer argumento para determinar el n&amp;uacute;mero de salidas. Los resultados de esta llamada se almacenar&amp;aacute;n en cach&amp;eacute; si la &lt;code&gt;cache&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; para evitar llamar a la funci&amp;oacute;n dos veces. Sin embargo, para implementar la cach&amp;eacute;, la funci&amp;oacute;n original debe estar ajustada, lo que ralentizar&amp;aacute; las llamadas posteriores, por lo que solo haga esto si su funci&amp;oacute;n es costosa.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la desviaci&amp;oacute;n est&amp;aacute;ndar; de lo contrario, devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la desviaci&amp;oacute;n est&amp;aacute;ndar; de lo contrario, devuelve una referencia a la matriz de salida. Si ddof es&amp;gt; = el n&amp;uacute;mero de elementos que no son NaN en un segmento o el segmento contiene solo NaN, entonces el resultado para ese segmento es NaN.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Si &lt;code&gt;out&lt;/code&gt; es None, devuelve una nueva matriz que contiene la varianza; de lo contrario, devuelve una referencia a la matriz de salida. Si ddof es&amp;gt; = el n&amp;uacute;mero de elementos que no son NaN en un segmento o el segmento contiene solo NaN, entonces el resultado para ese segmento es NaN.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">Si se proporciona &lt;code&gt;out&lt;/code&gt; , la funci&amp;oacute;n escribe el resultado en &amp;eacute;l y devuelve una referencia a &lt;code&gt;out&lt;/code&gt; . (Ver ejemplos)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene los valores medios; de lo contrario, se devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene los valores medios; de lo contrario, se devuelve una referencia a la matriz de salida. Se devuelve Nan para los segmentos que contienen solo NaN.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">Si &lt;code&gt;out=None&lt;/code&gt; , devuelve una nueva matriz que contiene la varianza; de lo contrario, se devuelve una referencia a la matriz de salida.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">Si no se proporciona la &lt;code&gt;output&lt;/code&gt; , el c&amp;oacute;digo fuente se imprime en la pantalla (sys.stdout). El objeto de archivo debe crearse con los modos escribir 'w' o agregar 'a'.</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es de longitud N, esta funci&amp;oacute;n devuelve el valor:</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es la serie devuelta, entonces &lt;code&gt;p(x) == x&lt;/code&gt; para todos los valores de x.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es una URL, se descargar&amp;aacute;, se almacenar&amp;aacute; en el directorio &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; y se abrir&amp;aacute; desde all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es una URL, &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; la ubicaci&amp;oacute;n en la que existe el archivo localmente o la ubicaci&amp;oacute;n en la que existir&amp;iacute;a cuando se abriera con el m&amp;eacute;todo &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo percentil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios percentiles, el primer eje del resultado corresponde a los percentiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo percentil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios cuantiles, el primer eje del resultado corresponde a los cuantiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es un solo cuantil y el &lt;code&gt;axis=None&lt;/code&gt; , entonces el resultado es un escalar. Si se dan varios cuantiles, el primer eje del resultado corresponde a los cuantiles. Los otros ejes son los que quedan despu&amp;eacute;s de la reducci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Si la entrada contiene n&amp;uacute;meros enteros o flotantes m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;float64&lt;/code&gt; , el tipo de datos de salida es &lt;code&gt;float64&lt;/code&gt; . De lo contrario, el tipo de datos de salida es el mismo que el de la entrada. Si se especifica &lt;code&gt;out&lt;/code&gt; , esa matriz se devuelve en su lugar.</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es una matriz 1-D, entonces &lt;code&gt;p(x)&lt;/code&gt; tendr&amp;aacute; la misma forma que &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;r&lt;/code&gt; es multidimensional, entonces la forma del resultado depende del valor del &lt;code&gt;tensor&lt;/code&gt; . Si el &lt;code&gt;tensor is ``True`&lt;/code&gt; la forma ser&amp;aacute; r.shape [1:] + x.shape; es decir, cada polinomio se eval&amp;uacute;a en cada valor de &lt;code&gt;x&lt;/code&gt; . Si el &lt;code&gt;tensor&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; , la forma ser&amp;aacute; r.shape [1:]; es decir, cada polinomio se eval&amp;uacute;a solo para el valor de difusi&amp;oacute;n correspondiente de &lt;code&gt;x&lt;/code&gt; . Tenga en cuenta que los escalares tienen forma (,).</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es de longitud &lt;code&gt;N&lt;/code&gt; , esta funci&amp;oacute;n devuelve el valor</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">Si &lt;code&gt;rep&lt;/code&gt; es una instancia de un dtype escalar, se devuelve True. Si no es as&amp;iacute;, se devuelve False.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">Si las &lt;code&gt;reps&lt;/code&gt; tienen una longitud &lt;code&gt;d&lt;/code&gt; , el resultado tendr&amp;aacute; una dimensi&amp;oacute;n de &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">Si &lt;code&gt;rowvar&lt;/code&gt; es True (predeterminado), entonces cada fila representa una variable, con observaciones en las columnas. De lo contrario, la relaci&amp;oacute;n se transpone: cada columna representa una variable, mientras que las filas contienen observaciones.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;axes&lt;/code&gt; tienen diferente longitud, o &lt;code&gt;axes&lt;/code&gt; no determinado y &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;axes&lt;/code&gt; tienen diferente longitud.</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">Si &lt;code&gt;sctype&lt;/code&gt; es un objeto para el que no se puede inferir el tipo.</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">Si &lt;code&gt;self.shape[k] == 1&lt;/code&gt; entonces para cualquier &amp;iacute;ndice de &lt;code&gt;index[k] == 0&lt;/code&gt; legal [k] == 0 . Esto significa que en la f&amp;oacute;rmula para el desplazamiento</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; no es singular, &lt;code&gt;ret&lt;/code&gt; es tal que &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; todos devuelven &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">Si el &lt;code&gt;self&lt;/code&gt; es singular.</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">Si no se especifica &lt;code&gt;sep&lt;/code&gt; o &lt;code&gt;None&lt;/code&gt; , cualquier cadena de espacios en blanco es un separador.</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;shape&lt;/code&gt; tiene una longitud uno, es decir, &lt;code&gt;(N,)&lt;/code&gt; , o es un escalar &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; se convierte en una matriz de fila &amp;uacute;nica de forma &lt;code&gt;(1,N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">Si &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">Si &lt;code&gt;v&lt;/code&gt; es una matriz 2-D, devuelve una copia de su &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal. Si &lt;code&gt;v&lt;/code&gt; es una matriz 1-D, devuelve una matriz 2-D con &lt;code&gt;v&lt;/code&gt; en la &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">Si &lt;code&gt;v&lt;/code&gt; es m&amp;aacute;s largo que &lt;code&gt;a&lt;/code&gt; , las matrices se intercambian antes del c&amp;aacute;lculo.</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;values&lt;/code&gt; no son del mismo tama&amp;ntilde;o que &lt;code&gt;a&lt;/code&gt; y la &lt;code&gt;mask&lt;/code&gt; , se repetir&amp;aacute;. Esto da un comportamiento diferente de los &lt;code&gt;a[mask] = values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">Si los &lt;code&gt;values&lt;/code&gt; son menores que &lt;code&gt;a&lt;/code&gt; , se repite:</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x2&lt;/code&gt; es un escalar, su signo se copiar&amp;aacute; a todos los elementos de &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una lista o tupla, se convierte en un ndarray; de lo contrario, no se modifica y se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la suma y la multiplicaci&amp;oacute;n consigo mismos y con los elementos de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una lista o tupla, se convierte en un ndarray; de lo contrario, no se modifica y se trata como un escalar. En cualquier caso, &lt;code&gt;x&lt;/code&gt; o sus elementos deben soportar la suma y la multiplicaci&amp;oacute;n consigo mismos y con los elementos de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una matriz multidimensional, solo se baraja a lo largo de su primer &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una instancia poly1d, el resultado es la composici&amp;oacute;n de los dos polinomios, es decir, &lt;code&gt;x&lt;/code&gt; se &quot;sustituye&quot; en &lt;code&gt;p&lt;/code&gt; y se devuelve el resultado simplificado. Adem&amp;aacute;s, el tipo de &lt;code&gt;x&lt;/code&gt; - array_like o poly1d - gobierna el tipo de salida: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; un objeto poly1d =&amp;gt; &lt;code&gt;values&lt;/code&gt; tambi&amp;eacute;n lo es.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una secuencia, se devuelve &lt;code&gt;p(x)&lt;/code&gt; para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es otro polinomio, se devuelve el polinomio compuesto &lt;code&gt;p(x(t))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un subtipo de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,&lt;/a&gt; el valor devuelto ser&amp;aacute; del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un n&amp;uacute;mero entero, permuta aleatoriamente &lt;code&gt;np.arange(x)&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es una matriz, haga una copia y mezcle los elementos al azar.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es inexacta, NaN se sustituye por cero o por el valor definido por el usuario en &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; palabra clave, el infinito se sustituye por el m&amp;aacute;s grande finita valores de coma flotante representables por &lt;code&gt;x.dtype&lt;/code&gt; o por el valor definido por el usuario en &lt;code&gt;posinf&lt;/code&gt; palabra clave y se sustituye por -infinity los valores de coma flotante finitos m&amp;aacute;s negativos representables por &lt;code&gt;x.dtype&lt;/code&gt; o por el valor definido por el usuario en la palabra clave &lt;code&gt;neginf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es inexacto, entonces no se realizan reemplazos.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es de un tipo de entero con signo, entonces el tipo de salida es el entero de plataforma predeterminado:</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;xp&lt;/code&gt; y &lt;code&gt;fp&lt;/code&gt; tienen una longitud diferente Si &lt;code&gt;xp&lt;/code&gt; o &lt;code&gt;fp&lt;/code&gt; no son secuencias 1-D Si &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">Si &lt;em&gt;arr&lt;/em&gt; es una matriz, devuelve su descriptor de tipo de datos, pero si &lt;em&gt;arr&lt;/em&gt; es un escalar de matriz (tiene 0 dimensiones), busca el tipo de datos de menor tama&amp;ntilde;o al que se puede convertir el valor sin desbordamiento o truncamiento a un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">Si el &lt;em&gt;eje&lt;/em&gt; es &lt;em&gt;Ninguno&lt;/em&gt; (el valor predeterminado), la matriz se trata como una matriz 1-D y la operaci&amp;oacute;n se realiza en toda la matriz. Este comportamiento tambi&amp;eacute;n es el predeterminado si self es una matriz de dimensi&amp;oacute;n 0 o una matriz escalar. (Un arreglo escalar es una instancia de los tipos / clases float32, float64, etc., mientras que un arreglo de dimensi&amp;oacute;n 0 es una instancia ndarray que contiene precisamente un arreglo escalar).</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">Si el &lt;em&gt;eje&lt;/em&gt; es un n&amp;uacute;mero entero, entonces la operaci&amp;oacute;n se realiza sobre el eje dado (para cada subarreglo 1-D que se puede crear a lo largo del eje dado).</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">Si los &lt;em&gt;datos&lt;/em&gt; son &lt;code&gt;NULL&lt;/code&gt; , entonces se asignar&amp;aacute; una nueva memoria unitaria inicializada y los &lt;em&gt;indicadores&lt;/em&gt; pueden ser distintos de cero para indicar una matriz contigua al estilo Fortran. Utilice &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; para inicializar la memoria.</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">Si los &lt;em&gt;datos&lt;/em&gt; no son &lt;code&gt;NULL&lt;/code&gt; , se supone que apuntan a la memoria que se utilizar&amp;aacute; para la matriz y el argumento de &lt;em&gt;banderas&lt;/em&gt; se usa como las nuevas banderas para la matriz (excepto el estado de &lt;code&gt;NPY_OWNDATA&lt;/code&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; de la nueva matriz ser reiniciado).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">Si &lt;em&gt;descr&lt;/em&gt; es NULL, se utiliza el tipo de datos del &lt;em&gt;prototipo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">Si &lt;em&gt;dtype&lt;/em&gt; es &lt;code&gt;NULL&lt;/code&gt; , la matriz devuelta tendr&amp;aacute; el mismo tipo de datos que &lt;em&gt;self&lt;/em&gt; . El nuevo tipo de datos debe ser coherente con el tama&amp;ntilde;o de &lt;em&gt;uno mismo&lt;/em&gt; . Los tama&amp;ntilde;os de los elementos deben ser id&amp;eacute;nticos o el &lt;em&gt;self&lt;/em&gt; debe ser de un solo segmento y el n&amp;uacute;mero total de bytes debe ser el mismo. En el &amp;uacute;ltimo caso, las dimensiones de la matriz devuelta se modificar&amp;aacute;n en la &amp;uacute;ltima dimensi&amp;oacute;n (o la primera para las matrices contiguas estilo Fortran). El &amp;aacute;rea de datos de la matriz devuelta y self es exactamente la misma.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">Si &lt;em&gt;op&lt;/em&gt; ya es una matriz, pero no satisface los requisitos, se realiza una copia (que cumplir&amp;aacute; los requisitos). Si esta bandera est&amp;aacute; presente y se debe hacer una copia (de un objeto que ya es una matriz), entonces la bandera &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; correspondiente se establece en la copia devuelta y &lt;em&gt;op&lt;/em&gt; se hace para ser de solo lectura. Debe asegurarse de llamar a &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; para copiar el contenido de nuevo en &lt;em&gt;op&lt;/em&gt; y la matriz &lt;em&gt;op se&lt;/em&gt; volver&amp;aacute; a escribir. Si &lt;em&gt;op&lt;/em&gt; no se puede escribir para empezar, o si a&amp;uacute;n no es una matriz, se genera un error.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">Si &lt;em&gt;permute&lt;/em&gt; es &lt;code&gt;NULL&lt;/code&gt; , la forma del resultado es</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">Si &lt;em&gt;subok&lt;/em&gt; es 1, la matriz reci&amp;eacute;n creada usar&amp;aacute; el subtipo de &lt;em&gt;prototipo&lt;/em&gt; para crear la nueva matriz; de lo contrario, crear&amp;aacute; una matriz de clase base.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">Si el &lt;em&gt;subtipo&lt;/em&gt; es de una subclase de matriz en lugar de la base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; , entonces &lt;em&gt;obj&lt;/em&gt; es el objeto para pasar al m&amp;eacute;todo &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt; de la subclase.</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Si A = qr tal que q es ortonormal (lo cual siempre es posible a trav&amp;eacute;s de Gram-Schmidt), entonces &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; . (En la pr&amp;aacute;ctica, sin embargo, simplemente usamos &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">Si es False, se devuelve una vista de las matrices originales para conservar memoria. El valor predeterminado es verdadero. Tenga en cuenta que &lt;code&gt;sparse=False, copy=False&lt;/code&gt; probablemente devolver&amp;aacute; matrices no contiguas. Adem&amp;aacute;s, m&amp;aacute;s de un elemento de una matriz de difusi&amp;oacute;n puede referirse a una &amp;uacute;nica ubicaci&amp;oacute;n de memoria. Si necesita escribir en las matrices, primero haga copias.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">Si es falso,no se comprobará el recuento de referencia.Por defecto es Verdadero.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">Si es False, el valor predeterminado devuelve el n&amp;uacute;mero de muestras en cada contenedor. Si es True, devuelve la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el contenedor, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">Si es False, el valor predeterminado devuelve el n&amp;uacute;mero de muestras en cada contenedor. Si es True, devuelve la funci&amp;oacute;n de &lt;em&gt;densidad de&lt;/em&gt; probabilidad en el contenedor, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">Si K=min(M,N),entonces</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">Si no hay ninguno,el índice está en la matriz aplanada,de lo contrario a lo largo del eje especificado</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">Si no hay ninguno,entonces se asume que la ruta es la ruta local más el nombre del subpaquete.Si no se encuentra un archivo setup.py en la ruta_de_subpaquete,entonces se utiliza una configuración por defecto.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">Si es None, use una instancia de MaskType. De lo contrario, use un nuevo tipo de datos con los mismos campos que &lt;code&gt;dtype&lt;/code&gt; , convertido a tipos booleanos.</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">Si el cálculo del SVD no converge.</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">Si es Verdadero (predeterminado), haga una copia de &lt;code&gt;a&lt;/code&gt; en el resultado. Si es False, modifique &lt;code&gt;a&lt;/code&gt; en el lugar y devuelva una vista.</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">Si es True (predeterminado), &lt;code&gt;u&lt;/code&gt; y &lt;code&gt;vh&lt;/code&gt; tienen las formas &lt;code&gt;(..., M, M)&lt;/code&gt; y &lt;code&gt;(..., N, N)&lt;/code&gt; , respectivamente. De lo contrario, las formas son &lt;code&gt;(..., M, K)&lt;/code&gt; y &lt;code&gt;(..., K, N)&lt;/code&gt; , respectivamente, donde &lt;code&gt;K = min(M, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">Si es Verdadero (predeterminado), se establece la funci&amp;oacute;n para impresi&amp;oacute;n bonita ( &lt;code&gt;__repr__&lt;/code&gt; ), si es Falso, se establece la funci&amp;oacute;n que devuelve la representaci&amp;oacute;n de cadena predeterminada ( &lt;code&gt;__str__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">Si es cierto,se devuelve una red escasa para conservar la memoria.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Si es Verdadero, se supone que &lt;code&gt;M&lt;/code&gt; es hermitiano (sim&amp;eacute;trico si tiene un valor real), lo que permite un m&amp;eacute;todo m&amp;aacute;s eficiente para encontrar valores singulares. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Si es verdad, &lt;code&gt;a&lt;/code&gt; se supone que es hermitiana (sim&amp;eacute;trica si valor real-), lo que permite un m&amp;eacute;todo m&amp;aacute;s eficiente para encontrar valores singulares. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">Si es verdadero, &lt;code&gt;c_or_r&lt;/code&gt; especifica las ra&amp;iacute;ces del polinomio; El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Si es Verdadero, &lt;code&gt;stop&lt;/code&gt; es la &amp;uacute;ltima muestra. De lo contrario, no est&amp;aacute; incluido. El valor predeterminado es verdadero.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">Si es cierto,los NaNs se compararán de igual a igual.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">Si es cierto,alinee los campos por el relleno como lo haría el compilador C.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">Si es True, tambi&amp;eacute;n devuelve los &amp;iacute;ndices de &lt;code&gt;ar&lt;/code&gt; (a lo largo del eje especificado, si se proporciona, o en la matriz plana) que dan como resultado la matriz &amp;uacute;nica.</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Si es Verdadero, tambi&amp;eacute;n devuelve los &amp;iacute;ndices de la matriz &amp;uacute;nica (para el eje especificado, si se proporciona) que se pueden usar para reconstruir &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Si es Verdadero, tambi&amp;eacute;n devuelve el n&amp;uacute;mero de veces que aparece cada elemento &amp;uacute;nico en &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">Si es Verdadero, imprima siempre n&amp;uacute;meros de punto flotante utilizando notaci&amp;oacute;n de punto fijo, en cuyo caso los n&amp;uacute;meros iguales a cero en la precisi&amp;oacute;n actual se imprimir&amp;aacute;n como cero. Si es Falso, entonces se usa notaci&amp;oacute;n cient&amp;iacute;fica cuando el valor absoluto del n&amp;uacute;mero m&amp;aacute;s peque&amp;ntilde;o es &amp;lt;1e-4 o la relaci&amp;oacute;n entre el valor absoluto m&amp;aacute;ximo y el m&amp;iacute;nimo es&amp;gt; 1e3. El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">Si es cierto,siempre devuelve una tupla.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">Si es cierto,se plantea una excepción si se detecta una inconsistencia en el número de columnas.Si es Falso,se emite una advertencia y se saltan las líneas infractoras.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">Si es cierto,no plantee errores por valores inválidos.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">Si es verdadero, los nombres de los campos distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas. Si es False o 'superior', los nombres de los campos se convierten a may&amp;uacute;sculas. Si es 'inferior', los nombres de los campos se convierten a min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">Si es Verdadero, los valores enmascarados se propagan por pares: si un valor est&amp;aacute; enmascarado en &lt;code&gt;x&lt;/code&gt; , el valor correspondiente est&amp;aacute; enmascarado en &lt;code&gt;y&lt;/code&gt; . Si es False, genera una excepci&amp;oacute;n &lt;code&gt;ValueError&lt;/code&gt; cuando faltan algunos valores.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">Si es Verdadero, los valores enmascarados se propagan por pares: si un valor est&amp;aacute; enmascarado en &lt;code&gt;x&lt;/code&gt; , el valor correspondiente est&amp;aacute; enmascarado en &lt;code&gt;y&lt;/code&gt; . Si es falso, genera una excepci&amp;oacute;n. Debido a que el &lt;code&gt;bias&lt;/code&gt; est&amp;aacute; en desuso, este argumento debe tratarse como una palabra clave solo para evitar una advertencia.</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">Si es Verdadero, devuelve ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; ), donde &lt;code&gt;step&lt;/code&gt; es el espacio entre muestras.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">Si es cierto,devuelve un conjunto enmascarado.Si es falso,devuelve una matriz normal.</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">Si es cierto,especifica que el adorno de la llamada es una prueba.Si es falso,especifica que el plato decorado no es una prueba.Por defecto es True.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">Si es cierto,las subclases se conservan.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Si es verdadero, los ejes que se reducen se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra el &lt;code&gt;arr&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">Si es True,los valores en conflicto se añaden al mensaje de error.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">Si es cierto,se devuelven los índices que corresponden a la intersección de las dos matrices.La primera instancia de un valor se utiliza si hay múltiples.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">Si es cierto,se supone que las matrices de entrada son únicas,lo que puede acelerar el cálculo.Por defecto es Falso.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el &lt;code&gt;c_index&lt;/code&gt; o &lt;code&gt;f_index&lt;/code&gt; , y el &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; propiedad se puede usar para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el indicador &lt;code&gt;delay_bufalloc&lt;/code&gt; y a&amp;uacute;n no se llam&amp;oacute; a la funci&amp;oacute;n reset ().</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Si es True, el iterador se cre&amp;oacute; con el indicador &lt;code&gt;multi_index&lt;/code&gt; y se puede usar la propiedad &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">Si es True, la matriz devuelta se transpone, por lo que los argumentos se pueden descomprimir usando &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Si es True, la matriz devuelta se transpone, por lo que los argumentos se pueden descomprimir usando &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; . Cuando se usa con un tipo de datos estructurado, se devuelven matrices para cada campo. El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Si es True, la forma de la matriz de coeficientes se extiende con unos a la derecha, uno para cada dimensi&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; . Los escalares tienen dimensi&amp;oacute;n 0 para esta acci&amp;oacute;n. El resultado es que cada columna de coeficientes en &lt;code&gt;c&lt;/code&gt; se eval&amp;uacute;a para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si es False, &lt;code&gt;x&lt;/code&gt; se difunde sobre las columnas de &lt;code&gt;c&lt;/code&gt; para la evaluaci&amp;oacute;n. Esta palabra clave es &amp;uacute;til cuando &lt;code&gt;c&lt;/code&gt; es multidimensional. El valor por defecto es verdadero.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Si es True, la forma de la matriz de ra&amp;iacute;ces se extiende con unas a la derecha, una para cada dimensi&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; . Los escalares tienen dimensi&amp;oacute;n 0 para esta acci&amp;oacute;n. El resultado es que cada columna de coeficientes en &lt;code&gt;r&lt;/code&gt; se eval&amp;uacute;a para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si es falso, &lt;code&gt;x&lt;/code&gt; se difunde sobre las columnas de &lt;code&gt;r&lt;/code&gt; para la evaluaci&amp;oacute;n. Esta palabra clave es &amp;uacute;til cuando &lt;code&gt;r&lt;/code&gt; es multidimensional. El valor por defecto es verdadero.</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">Si es True, los valores de la matriz devuelta se invierten (es decir, False donde un elemento de &lt;code&gt;ar1&lt;/code&gt; est&amp;aacute; en &lt;code&gt;ar2&lt;/code&gt; y True en caso contrario). El valor predeterminado es falso. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; es equivalente a (pero es m&amp;aacute;s r&amp;aacute;pido que) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">Si es True, los valores de la matriz devuelta se invierten, como si el &lt;code&gt;element not in test_elements&lt;/code&gt; calculado no estuviera en test_elements . El valor predeterminado es falso. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; es equivalente a (pero m&amp;aacute;s r&amp;aacute;pido que) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">Si es verdadero, a continuaci&amp;oacute;n, permitir que la matriz de entrada &lt;code&gt;a&lt;/code&gt; a ser modificado por c&amp;aacute;lculos intermedios, para ahorrar memoria. En este caso, el contenido de la entrada &lt;code&gt;a&lt;/code&gt; despu&amp;eacute;s de que se complete esta funci&amp;oacute;n no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada (a) para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a median. Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Tenga en cuenta que, si &lt;code&gt;overwrite_input&lt;/code&gt; es Verdadero, y la entrada a&amp;uacute;n no es un &lt;code&gt;ndarray&lt;/code&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada &lt;code&gt;a&lt;/code&gt; para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Si &lt;code&gt;overwrite_input&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; no es ya un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Si es verdadero, permita el uso de la memoria de la matriz de entrada &lt;code&gt;a&lt;/code&gt; para los c&amp;aacute;lculos. La matriz de entrada ser&amp;aacute; modificada por la llamada a &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Esto ahorrar&amp;aacute; memoria cuando no necesite conservar el contenido de la matriz de entrada. Trate la entrada como indefinida, pero probablemente estar&amp;aacute; total o parcialmente ordenada. El valor predeterminado es falso. Si &lt;code&gt;overwrite_input&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; no es ya un &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">Si es True,entonces se pasarán las subclases (por defecto),de lo contrario el array devuelto será forzado a ser un array de clase base.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">Si es True,entonces se pasarán subclases,de lo contrario la matriz devuelta será forzada a ser una matriz de clase base (por defecto).</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">Si es True,entonces las subclases se pasarán,de lo contrario las matrices devueltas se verán forzadas a ser una matriz de clase base (por defecto).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Si es True, entonces la matriz reci&amp;eacute;n creada usar&amp;aacute; el tipo de subclase de 'a', de lo contrario ser&amp;aacute; una matriz de clase base. Por defecto es Verdadero.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">Si [matriz,matriz],los bordes de los contenedores en cada dimensión (x_borde,y_borde=contenedor).</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">Si [int,int],el número de contenedores en cada dimensión (nx,ny=contenedores).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">Si la versión __svn_.py existía antes,no se hace nada.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">Si a &amp;lt;1.</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">Si una clase (subclase ndarray o no) que tiene el m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; se usa como el objeto de salida de un &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , los resultados se escribir&amp;aacute;n en el objeto devuelto por &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . Se realiza una conversi&amp;oacute;n similar en matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">Si una clase define el m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , esto deshabilita el &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; descrito a continuaci&amp;oacute;n para ufuncs (que eventualmente puede quedar obsoleto).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">Si se est&amp;aacute; utilizando un b&amp;uacute;fer fijo en tiempo de compilaci&amp;oacute;n (ambos indicadores &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; ), el tama&amp;ntilde;o interno tambi&amp;eacute;n se puede usar como se&amp;ntilde;al. Se garantiza que el tama&amp;ntilde;o se convertir&amp;aacute; en cero cuando &lt;code&gt;iternext()&lt;/code&gt; devuelva falso, lo que habilita la siguiente construcci&amp;oacute;n de bucle. Tenga en cuenta que si usa esta construcci&amp;oacute;n, no debe pasar &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; como una marca , ya que provocar&amp;aacute; tama&amp;ntilde;os m&amp;aacute;s grandes en algunas circunstancias.</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">Si se recupera un campo cuyo objeto dtype tiene este atributo, las dimensiones adicionales impl&amp;iacute;citas en la &lt;em&gt;forma&lt;/em&gt; se agregan al final de la matriz recuperada.</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">Si se especifica un formateador para un tipo determinado, la palabra clave de &lt;code&gt;precision&lt;/code&gt; se ignora para ese tipo.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">Si un determinado conjunto no satisface las restricciones especificadas.</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">Si a es un objeto matricial,entonces el valor de retorno es también matricial:</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">Si a es un int y menos de cero,si a o p no son 1-dimensionales,si a es un array-como de tamaño 0,si p no es un vector de probabilidades,si a y p tienen diferentes longitudes,o si replace=False y el tamaño de la muestra es mayor que el tamaño de la población</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">Si a es un int y menos de cero,si p no es de una dimensión,si a es un array con un tamaño 0,si p no es un vector de probabilidades,si a y p tienen longitudes diferentes,o si replace=False y el tamaño de la muestra es mayor que el tamaño de la población.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">Si se trata de una lista de cuerdas,cada cuerda debe representar un tipo.Si es tipo_arreglo,se utiliza la representación de caracteres del tipo_arreglo.</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">Si es un dtype escalar, se devuelve el car&amp;aacute;cter de cadena correspondiente. Si es un objeto, &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; intenta inferir su tipo escalar y luego devuelve el car&amp;aacute;cter de cadena correspondiente.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">Si se pasa un valor escalar.</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">Si se proporciona un segundo argumento, el resultado se almacena all&amp;iacute;. Si el tipo de esa matriz es un tipo num&amp;eacute;rico, el resultado se representa como ceros y unos, si el tipo es booleano, entonces como Falso y Verdadero. El valor de retorno &lt;code&gt;out&lt;/code&gt; es entonces una referencia a esa matriz.</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">Si una matriz de dimensi&amp;oacute;n cero est&amp;aacute; presente en el &amp;iacute;ndice &lt;em&gt;y&lt;/em&gt; es un &amp;iacute;ndice entero completo, el resultado ser&amp;aacute; un &lt;em&gt;escalar&lt;/em&gt; y no una matriz de dimensi&amp;oacute;n cero. (La indexaci&amp;oacute;n avanzada no se activa).</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">Si lo real y lo deseado no son iguales a la precisión especificada.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">Si lo real y lo deseado no son iguales.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">Si los objetos reales y los deseados no son iguales.</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">Si todos los m&amp;eacute;todos &lt;code&gt;__array_function__&lt;/code&gt; devuelven &lt;code&gt;NotImplemented&lt;/code&gt; , NumPy generar&amp;aacute; &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">Si todas las matrices son 1-D, &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; es equivalente a:</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">Si todos los valores están enmascarados,devuelva Ninguno.En caso contrario,devuelva una lista de dos tuplas,correspondientes a los índices del primer y último valor desenmascarado respectivamente.</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">Si una matriz tiene un determinante muy peque&amp;ntilde;o o muy grande, entonces una llamada a &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; puede desbordarse o subdesbordarse. Esta rutina es m&amp;aacute;s robusta frente a estos problemas, porque calcula el logaritmo del determinante en lugar del determinante en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">Si una matriz no tiene elementos ( &lt;code&gt;self.size == 0&lt;/code&gt; ), no hay un &amp;iacute;ndice legal y las zancadas nunca se utilizan. Cualquier arreglo sin elementos puede considerarse contiguo al estilo C y al estilo Fortran.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">Si se crea una matriz usando un tipo de datos que describe una submatriz, las dimensiones de la submatriz se agregan a la forma de la matriz cuando se crea la matriz. Las submatrices en un campo de un tipo estructurado se comportan de manera diferente, consulte &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Acceso al campo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">Si se crea una matriz con este m&amp;eacute;todo, simplemente agregando 'tama&amp;ntilde;o de elemento' para cada iteraci&amp;oacute;n atravesar&amp;aacute; la nueva matriz que coincide con el iterador.</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si un elemento de &lt;code&gt;axes&lt;/code&gt; es mayor que el n&amp;uacute;mero de ejes de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">Si un &amp;iacute;ndice excede la dimensi&amp;oacute;n de la matriz a lo largo del &lt;code&gt;axis&lt;/code&gt; , se devuelve una submatriz vac&amp;iacute;a correspondientemente.</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">Si una entrada tiene un tama&amp;ntilde;o de dimensi&amp;oacute;n de 1 en su forma, la primera entrada de datos en esa dimensi&amp;oacute;n se utilizar&amp;aacute; para todos los c&amp;aacute;lculos a lo largo de esa dimensi&amp;oacute;n. En otras palabras, la maquinaria paso a paso de &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; simplemente no avanzar&amp;aacute; a lo largo de esa dimensi&amp;oacute;n (el &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;paso&lt;/a&gt; ser&amp;aacute; 0 para esa dimensi&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">Si un ndarray,una muestra aleatoria se genera a partir de sus elementos.Si un int,la muestra aleatoria se genera como si fuera un np.arange(a)</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">Si se proporciona un objeto,su método de escritura debe tomar un argumento,una cadena.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">Si alguna entrada es parecida a una matriz , &lt;code&gt;pv&lt;/code&gt; devuelve una matriz de la misma forma. Comparemos diferentes tipos de inter&amp;eacute;s en el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">Si alguna entrada es como una matriz, devuelve una matriz de la misma forma. Comparemos diferentes tipos de inter&amp;eacute;s del ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">Si existe alguna superposici&amp;oacute;n de lectura / escritura, este indicador garantiza que el resultado de la operaci&amp;oacute;n sea el mismo que si se copiaran todos los operandos. En los casos en que sea necesario realizar copias, &lt;strong&gt;el resultado del c&amp;aacute;lculo puede no estar definido sin esta bandera.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">Si algún valor en el alfa es menor o igual a cero</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">Si algún operando de escritura se ha solapado con algún operando de lectura,elimine todas las superposiciones haciendo copias temporales (habilitando UPDATEIFCOPY para operandos de escritura,si es necesario).Un par de operandos se superpone si hay una dirección de memoria que contiene datos comunes a ambas matrices.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">Si el argumento consiste exclusivamente en los tipos de int.</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">Si los argumentos se pasan sin palabras clave, los nombres de las variables correspondientes, en el archivo &lt;code&gt;.npz&lt;/code&gt; , son 'arr_0', 'arr_1', etc. Si se dan argumentos de palabras clave, los nombres de las variables correspondientes en el archivo &lt;code&gt;.npz&lt;/code&gt; coincidir&amp;aacute;n con los nombres de palabras clave.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">Si es similar a la matriz,los bordes de los contenedores para las dos dimensiones (x_bordes=y_bordes=bins).</target>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">Si el eje es 0,sólo se suprimen las filas.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">Si el eje es 1 o -1,sólo se suprimen las columnas.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">Si el eje es Ninguno,se suprimen tanto las filas como las columnas.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,se realiza un producto en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,se realiza una suma en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Si el eje es una tupla de ints,el promedio se realiza en todos los ejes especificados en la tupla en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">Si el eje es una tupla de ints,el volteo se realiza en todos los ejes especificados en la tupla.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son matrices 1-D, es un producto interno de vectores (sin conjugaci&amp;oacute;n compleja).</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son matrices 2-D, es una multiplicaci&amp;oacute;n de matrices, pero se &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; usar matmul o &lt;code&gt;a @ b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; son &lt;code&gt;NULL&lt;/code&gt; , devuelve &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; ). De lo contrario, se deben dar tanto &lt;em&gt;x&lt;/em&gt; como &lt;em&gt;y&lt;/em&gt; y el objeto devuelto tiene la forma de &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; y tiene elementos de &lt;em&gt;x&lt;/em&gt; e &lt;em&gt;y&lt;/em&gt; donde &lt;em&gt;condici&amp;oacute;n&lt;/em&gt; es respectivamente Verdadero o Falso.</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">Si ambos argumentos son 2-D se multiplican como las matrices convencionales.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">Si tanto el infinito positivo como el negativo están presentes,la suma será un número no A (NaN).</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">Si se le llama con todos los argumentos que no sean la clase de advertencia omitida,puede utilizarse como gestor de contexto:</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">Si la entrada compleja devuelve una matriz real si las partes complejas están cerca de cero.</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">Si los cálculos no convergen.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Si la condici&amp;oacute;n es &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , los valores faltantes se consideran &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">Si copy es False y una de las entradas es &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; , devuelve una vista de la otra m&amp;aacute;scara de entrada. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">Si los datos se pasan a &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; , esta memoria no se debe desasignar hasta que se elimine la nueva matriz. Si estos datos provienen de otro objeto Python, esto se puede lograr usando &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; en ese objeto y configurando el miembro base de la nueva matriz para que apunte a ese objeto. Si se pasan pasos, deben ser coherentes con las dimensiones, el tama&amp;ntilde;o del elemento y los datos de la matriz.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">Si se define, el eje de &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; que define el vector (s) y la cruz producto (s). Anulaciones &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; y &lt;code&gt;axisc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">Si cualquiera de &lt;code&gt;a&lt;/code&gt; o &lt;code&gt;b&lt;/code&gt; es 0-D (escalar), es equivalente a &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; y usando &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; o &lt;code&gt;a * b&lt;/code&gt; se prefiere.</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">Si cualquiera de los argumentos es ND, N&amp;gt; 2, se trata como una pila de matrices que residen en los dos &amp;uacute;ltimos &amp;iacute;ndices y se difunde en consecuencia.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">Si cualquiera de las matrices contiene una o más NaNs,se devuelve Falso.Los infs son tratados como iguales si están en el mismo lugar y del mismo signo en ambas matrices.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">Si el elemento tiene un tipo de complejo con cero parte de complejo,el valor de retorno de ese elemento es Verdadero.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">Si el factoraje falla.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">Si el archivo es una cadena o un objeto parecido a una ruta de acceso,entonces ese archivo se abre,de lo contrario se asume que es un objeto de archivo.El objeto archivo debe admitir el acceso aleatorio (es decir,debe tener métodos de &quot;tell and seek&quot;).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">Si se agregan filtros y se proporciona la palabra clave del &lt;code&gt;module&lt;/code&gt; , el registro de advertencia de este m&amp;oacute;dulo se borrar&amp;aacute; adicionalmente al aplicarlo, ingresar al contexto o salir de &amp;eacute;l. Esto podr&amp;iacute;a hacer que las advertencias aparezcan por segunda vez despu&amp;eacute;s de salir del contexto si se configuraron para imprimirse una vez (predeterminado) y ya se imprimieron antes de ingresar al contexto.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">Si el formato es Ninguno,entonces esto detectará automáticamente los formatos.Utilice la lista de tuplas en lugar de la lista de listas para un procesamiento más rápido.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">Si se da y no es &lt;code&gt;False&lt;/code&gt; , devuelva no solo la estimaci&amp;oacute;n sino tambi&amp;eacute;n su matriz de covarianza. De forma predeterminada, la covarianza se escala mediante chi2 / sqrt (N-dof), es decir, se presume que los pesos no son confiables excepto en un sentido relativo y todo se escala de manera que el chi2 reducido sea la unidad. Esta escala se omite si &lt;code&gt;cov='unscaled'&lt;/code&gt; , como es relevante para el caso de que los pesos sean 1 / sigma ** 2, y se sabe que sigma es una estimaci&amp;oacute;n confiable de la incertidumbre.</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">Si se proporciona, cualquier cadena de la forma &lt;code&gt;@key@&lt;/code&gt; ser&amp;aacute; reemplazada por &lt;code&gt;subst_dict[key]&lt;/code&gt; en el archivo de plantilla cuando se instale. El prefijo de instalaci&amp;oacute;n siempre est&amp;aacute; disponible a trav&amp;eacute;s de la variable &lt;code&gt;@prefix@&lt;/code&gt; , ya que el prefijo de instalaci&amp;oacute;n no es f&amp;aacute;cil de obtener de forma confiable desde setup.py.</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">Si se da, la matriz debe tener la forma &lt;code&gt;[beg, end]&lt;/code&gt; , donde &lt;code&gt;beg&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; son los puntos finales del dominio. Si se proporciona None, se utiliza el dominio de clase. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">Si se da, la matriz resultante debe tener la forma &lt;code&gt;[beg, end]&lt;/code&gt; , donde &lt;code&gt;beg&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; son los puntos finales de la ventana. Si se proporciona Ninguno, se utiliza la ventana de clase. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">Si se da,se devuelve para los objetos cuyos tipos no se pueden determinar.Si no se da,no se devuelve ninguno para esos objetos.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">Si la matriz de entrada &lt;code&gt;a&lt;/code&gt; no es 2D.</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">Si la entrada es de la forma equivocada (la entrada debe ser una matriz de 1-D o 2-D cuadrada).</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">Si es int,el número de contenedores para las dos dimensiones (nx=ny=contenedores).</target>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">Si se dan argumentos de palabras clave,entonces los nombres de archivo se toman de las palabras clave.Si se pasan argumentos sin palabras clave,entonces los nombres de archivo almacenados son arr_0,arr_1,etc.</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">Si las profundidades de la lista no coinciden, por ejemplo, &lt;code&gt;[[a, b], c]&lt;/code&gt; es ilegal y debe escribirse &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">Si las listas est&amp;aacute;n vac&amp;iacute;as, por ejemplo, &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">Si la entrada es multidimensional,devuelve un nuevo ndarray de índices a los valores mínimos a lo largo del eje dado.En caso contrario,devuelve un escalar de índices a los valores mínimos a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">Si es necesario,se aplanará antes de tomar las diferencias.</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">Si no se define ninguno, el C-API se declara &lt;code&gt;static void**&lt;/code&gt; , por lo que solo es visible dentro de la unidad de compilaci&amp;oacute;n que #include numpy / arrayobject.h.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">Si no &lt;code&gt;__array_function__&lt;/code&gt; m&amp;eacute;todos __array_function__ , NumPy llamar&amp;aacute; por defecto a su propia implementaci&amp;oacute;n, destinada a usarse en matrices NumPy. Este caso surge, por ejemplo, cuando todos los argumentos en forma de matriz son n&amp;uacute;meros o listas de Python. (Las matrices NumPy tienen un m&amp;eacute;todo &lt;code&gt;__array_function__&lt;/code&gt; , que se indica a continuaci&amp;oacute;n, pero siempre devuelve &lt;code&gt;NotImplemented&lt;/code&gt; si cualquier argumento que no sea una subclase de matriz NumPy implementa &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">Si ninguna de las entradas anula ufunc, todas las matrices de salida se pasar&amp;aacute;n a los m&amp;eacute;todos &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; de la entrada (adem&amp;aacute;s de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; y escalares) que la define &lt;strong&gt;y&lt;/strong&gt; tiene la mayor &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; de cualquier otra entrada a la funci&amp;oacute;n universal. El &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; predeterminado del ndarray es 0.0 y el &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; predeterminado de un subtipo es 0.0. Las matrices tienen &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; igual a 10.0.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si no es &lt;code&gt;None&lt;/code&gt; ,la normalizaci&amp;oacute;n es por &lt;code&gt;(N - ddof)&lt;/code&gt; , donde &lt;code&gt;N&lt;/code&gt; es el n&amp;uacute;mero de observaciones; esto anula el valor impl&amp;iacute;cito en el &lt;code&gt;bias&lt;/code&gt; . El valor predeterminado es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si no es &lt;code&gt;None&lt;/code&gt; se anula el valor predeterminado impl&amp;iacute;cito en el &lt;code&gt;bias&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;ddof=1&lt;/code&gt; devolver&amp;aacute; la estimaci&amp;oacute;n insesgada, incluso si se especifican tanto los &lt;code&gt;fweights&lt;/code&gt; como los &lt;code&gt;aweights&lt;/code&gt; , y &lt;code&gt;ddof=0&lt;/code&gt; devolver&amp;aacute; el promedio simple. Consulte las notas para obtener m&amp;aacute;s detalles. El valor predeterminado es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">Si no es ninguno,las teclas deben indicar el tipo o tipos a los que se aplica la respectiva función de formato.Las llamadas deben devolver una cadena.Los tipos que no se especifican (mediante sus correspondientes teclas)se manejan mediante los formateadores predeterminados.Los tipos individuales para los que se puede establecer un formateador son:</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">Si no es Ninguno, se usa el dominio especificado en lugar del de la instancia que llama. Debe tener la forma &lt;code&gt;[beg,end]&lt;/code&gt; . El valor predeterminado es Ninguno, en cuyo caso se utiliza el dominio de clase.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">Si no es None, entonces &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt; en memoria el archivo, usando el modo dado (vea numpy.memmap para una descripci&amp;oacute;n detallada de los modos). Una matriz mapeada en memoria se mantiene en disco. Sin embargo, se puede acceder y cortar como cualquier ndarray. La asignaci&amp;oacute;n de memoria es especialmente &amp;uacute;til para acceder a peque&amp;ntilde;os fragmentos de archivos grandes sin leer todo el archivo en la memoria.</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">Si un argumento: un escalar, solo se usa en el caso de que &lt;code&gt;a&lt;/code&gt; sea ​​de tama&amp;ntilde;o 1. Si dos argumentos: el &amp;uacute;ltimo argumento es el valor que se va a establecer y debe ser un escalar, el primer argumento especifica la ubicaci&amp;oacute;n de un solo elemento de matriz. Es un int o una tupla.</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Si uno de los argumentos de entrada o salida tiene un m&amp;eacute;todo &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , se ejecuta en &lt;em&gt;lugar&lt;/em&gt; de ufunc. Si m&amp;aacute;s de uno de los argumentos implementa &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , se prueban en el orden: subclases antes que superclases, entradas antes que salidas, en caso contrario, de izquierda a derecha. La primera rutina que devuelve algo que no sea &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; determina el resultado. Si todas las operaciones &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; devuelven &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; , se genera un &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">Si uno o m&amp;aacute;s elementos difieren en m&amp;aacute;s de &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">Si uno lanza un dado repetidamente hasta la tercera vez que aparece un &quot;1&quot;, entonces la distribuci&amp;oacute;n de probabilidad del n&amp;uacute;mero de no &quot;1&quot; que aparecen antes del tercer &quot;1&quot; es una distribuci&amp;oacute;n binomial negativa.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">Si se utiliza el mismo nombre de dimensión en múltiples lugares,esto hace que se aplique el mismo tamaño de las dimensiones correspondientes.</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">Si se utilizan los indicadores de operandos &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; o &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; , los operandos pueden ser vistas de los datos originales con el indicador &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; . En este caso, nditer debe usarse como administrador de contexto o se debe llamar al m&amp;eacute;todo nditer.close antes de usar el resultado. Los datos temporales se volver&amp;aacute;n a escribir en los datos originales cuando se &lt;code&gt;__exit__&lt;/code&gt; funci&amp;oacute;n __exit__ pero no antes:</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">Si se da fuera y no tiene un atributo de máscara,¡la máscara de un se pierde!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">Si se pasa un solo ndarray o escalar (una lista anidada de profundidad 0),se devuelve sin modificar (y no se copia).</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">Si se proporcionan argumentos positivos de tipo int_like, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; genera una matriz de forma &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; , llena de flotantes aleatorios muestreados a partir de una distribuci&amp;oacute;n univariada &quot;normal&quot; (gaussiana) de media 0 y varianza 1. Un solo flotante Se devuelve una muestra aleatoria de la distribuci&amp;oacute;n si no se proporciona ning&amp;uacute;n argumento.</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">Si se proporciona, obliga al c&amp;aacute;lculo a utilizar el tipo de datos especificado. Tenga en cuenta que puede que tenga que dar tambi&amp;eacute;n una m&amp;aacute;s liberal &lt;code&gt;casting&lt;/code&gt; par&amp;aacute;metro para permitir las conversiones. El valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se proporciona, es una lista de ints o None para cada operando. La lista de ejes de un operando es un mapeo de las dimensiones del iterador a las dimensiones del operando. Se puede colocar un valor de -1 para las entradas, lo que hace que esa dimensi&amp;oacute;n se trate como un &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">Si se proporciona, uno por encima del entero m&amp;aacute;s grande (con signo) que se extraer&amp;aacute; de la distribuci&amp;oacute;n (consulte el comportamiento anterior si es &lt;code&gt;high=None&lt;/code&gt; ). Si es similar a una matriz, debe contener valores enteros</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">Si se proporciona,el cálculo se hace en esta matriz.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">Si se proporciona,el destino para colocar el resultado.La forma debe ser correcta,coincidiendo con la de lo que el concatenado habría devuelto si no se especificara un argumento de salida.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">Si se proporciona,el destino para colocar el resultado.La forma debe ser correcta,coincidiendo con la de la pila que habría regresado si no se especificara un argumento de salida.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">Si se proporciona, el entero m&amp;aacute;s grande (con signo) que se extraer&amp;aacute; de la distribuci&amp;oacute;n (consulte el comportamiento anterior si es &lt;code&gt;high=None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona, el resultado se insertar&amp;aacute; en esta matriz. Debe tener la forma y el tipo &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">Si se proporciona,el resultado se insertará en esta matriz.Debe tener la forma y el tipo apropiados.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Si se proporciona, el resultado se insertar&amp;aacute; en esta matriz. Debe tener la forma y el tipo adecuados. Tenga en cuenta que &lt;code&gt;out&lt;/code&gt; siempre est&amp;aacute; amortiguada si &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; utilice otros modos para un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Si se proporciona, el resultado se colocar&amp;aacute; en esta matriz. Debe tener la forma y el tipo adecuados. Tenga en cuenta que &lt;code&gt;out&lt;/code&gt; siempre est&amp;aacute; amortiguada si &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; utilice otros modos para un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">Si se proporciona,esta matriz se llena con el resultado.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">Si se establece en falso,la matriz devuelta siempre será sólo de lectura.De lo contrario,será escribible si la matriz original lo era.Es aconsejable ponerlo en Falso si es posible (ver Notas).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">Si se establece en la cadena &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; habilita el modo de impresi&amp;oacute;n heredado 1,13. Esto se aproxima a la salida de impresi&amp;oacute;n de 1,13 al incluir un espacio en la posici&amp;oacute;n del signo de los flotantes y un comportamiento diferente para las matrices 0d. Si se establece en &lt;code&gt;False&lt;/code&gt; , desactiva el modo heredado. Las cadenas no reconocidas se ignorar&amp;aacute;n con una advertencia de compatibilidad con versiones posteriores.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">Si se usa la notaci&amp;oacute;n de sector, la sintaxis &lt;code&gt;start:stop:step&lt;/code&gt; es equivalente a &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; dentro de los corchetes. Sin embargo, si el &lt;code&gt;step&lt;/code&gt; es un n&amp;uacute;mero imaginario (es decir, 100j), entonces su parte entera se interpreta como un n&amp;uacute;mero de puntos deseado y el inicio y la parada son inclusivos. En otras palabras, &lt;code&gt;start:stop:stepj&lt;/code&gt; se interpreta como &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; dentro de los corchetes. Despu&amp;eacute;s de la expansi&amp;oacute;n de la notaci&amp;oacute;n de corte, todas las secuencias separadas por comas se concatenan juntas.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Si algunos de los valores singulares de &lt;code&gt;V&lt;/code&gt; son tan peque&amp;ntilde;os que se descuidan (y &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ), se &lt;code&gt;RankWarning&lt;/code&gt; un RankWarning . Esto significa que los valores de los coeficientes pueden estar mal determinados. El ajuste a un polinomio de orden inferior generalmente eliminar&amp;aacute; la advertencia (pero puede que no sea lo que desea, por supuesto; si tiene razones independientes para elegir el t&amp;iacute;tulo que no funciona, es posible que deba: a) reconsiderar esos motivos, y / o b) reconsiderar la calidad de sus datos). El par&amp;aacute;metro &lt;code&gt;rcond&lt;/code&gt; tambi&amp;eacute;n se puede establecer en un valor menor que su predeterminado, pero el ajuste resultante puede ser falso y tener grandes contribuciones del error de redondeo.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Si algunos de los valores singulares de &lt;code&gt;V&lt;/code&gt; son tan peque&amp;ntilde;os que se descuidan, se &lt;code&gt;RankWarning&lt;/code&gt; un RankWarning . Esto significa que los valores de los coeficientes pueden estar mal determinados. El uso de un ajuste de orden inferior generalmente eliminar&amp;aacute; la advertencia. El par&amp;aacute;metro &lt;code&gt;rcond&lt;/code&gt; tambi&amp;eacute;n se puede establecer en un valor menor que su predeterminado, pero el ajuste resultante puede ser falso y tener grandes contribuciones del error de redondeo.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">Si lo disperso es falso:</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">Si lo disperso es cierto:</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">Si se establece que lo disperso es verdadero,la red será devuelta en una representación dispersa.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se especifica, todos los campos se cambiar&amp;aacute;n al orden de bytes proporcionado. De lo contrario, se utiliza el orden de bytes predeterminado. Para todos los especificadores de cadena disponibles, consulte &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">Si el estado es un diccionario, se establece directamente mediante la propiedad de &lt;code&gt;state&lt;/code&gt; BitGenerators .</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">Si se establecen las banderas (obsoletas) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , tiene un significado diferente, es decir, base es la matriz en la que se copiar&amp;aacute; la matriz actual tras la resoluci&amp;oacute;n de la copia. Es probable que esta sobrecarga de la propiedad base para dos funciones cambie en una versi&amp;oacute;n futura de NumPy.</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">Si el objeto &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; es una matriz estructurada, se puede acceder a los &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;campos&lt;/a&gt; de la matriz indexando la matriz con cadenas, como en un diccionario.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">Si se especifica el argumento de palabra clave de &lt;code&gt;order&lt;/code&gt; . Este comportamiento es un error en NumPy.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">Si el valor del &lt;code&gt;width&lt;/code&gt; es insuficiente, se ignorar&amp;aacute; y &lt;code&gt;num&lt;/code&gt; se devolver&amp;aacute; en forma binaria ( &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) o en complemento a dos ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) con su ancho igual al n&amp;uacute;mero m&amp;iacute;nimo de bits necesarios para representar el n&amp;uacute;mero en el forma designada. Este comportamiento est&amp;aacute; desaprobado y luego generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">Si el cálculo del SVD no converge.</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">Si el campo al que se accede es un subconjunto,las dimensiones del subconjunto se añaden a la forma del resultado.</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">Si el acumulador es demasiado pequeño,se produce un desbordamiento:</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">Si la matriz no tiene m&amp;aacute;scara, se devuelve la direcci&amp;oacute;n de &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Esta direcci&amp;oacute;n generalmente no est&amp;aacute; cerca de los datos en la memoria:</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">Si la matriz no es compatible con la nueva forma de acuerdo con las reglas de transmisi&amp;oacute;n de NumPy.</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">Si la memoria intermedia tiene datos que no están en el orden de bytes de la máquina,esto debe especificarse como parte del tipo de datos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">Si el tipo de datos com&amp;uacute;n se conoce de antemano, no use esta marca. En su lugar, establezca el dtype solicitado para todos los operandos.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">Si la condición es llamable,se utiliza en tiempo de ejecución para tomar la decisión de forma dinámica.Esto es útil para las pruebas que pueden requerir importaciones costosas,para retrasar el costo hasta que el conjunto de pruebas se ejecute realmente.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">Si la conversión no es posible</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">Si el m&amp;oacute;dulo ctypes no est&amp;aacute; disponible, entonces el atributo ctypes de los objetos de matriz todav&amp;iacute;a devuelve algo &amp;uacute;til, pero los objetos ctypes no se devuelven y pueden surgir errores en su lugar. En particular, el objeto seguir&amp;aacute; teniendo el atributo &lt;code&gt;as_parameter&lt;/code&gt; que devolver&amp;aacute; un n&amp;uacute;mero entero igual al atributo de datos.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">Si el dominio actual es el intervalo &lt;code&gt;[l1, r1]&lt;/code&gt; y la ventana es &lt;code&gt;[l2, r2]&lt;/code&gt; , entonces la funci&amp;oacute;n de mapeo lineal &lt;code&gt;L&lt;/code&gt; est&amp;aacute; definida por las ecuaciones:</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">Si el tipo de datos es &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;un tipo de datos estructurado&lt;/a&gt; , un agregado de otros tipos de datos ( &lt;em&gt;por ejemplo&lt;/em&gt; , que describe un elemento de matriz que consta de un n&amp;uacute;mero entero y un flotante),</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">Si el tipo de datos es un subconjunto,¿cuál es su forma y tipo de datos?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">Si la descomposici&amp;oacute;n falla, por ejemplo, si &lt;code&gt;a&lt;/code&gt; no es positivo-definido.</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo amax de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; a &lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo de subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;code&gt;ndarray&lt;/code&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo de &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; a&lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si se pasa el valor predeterminado, &lt;code&gt;keepdims&lt;/code&gt; no se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;code&gt;ndarray&lt;/code&gt; , sin embargo, cualquier valor no predeterminado s&amp;iacute; lo ser&amp;aacute;. Si el m&amp;eacute;todo de la &lt;code&gt;keepdims&lt;/code&gt; no implementa keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">Si la dimensi&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; es menor que 2.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">Si la discontinuidad en &lt;code&gt;p&lt;/code&gt; es menor que &lt;code&gt;pi&lt;/code&gt; , pero mayor que &lt;code&gt;discont&lt;/code&gt; , no se realiza ning&amp;uacute;n desenvolvimiento porque tomar el complemento 2 * pi solo aumentar&amp;iacute;a la discontinuidad.</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">Si el cálculo de los valores propios no converge.</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">Si el archivo contiene datos de pepinillos,entonces se devuelve cualquier objeto almacenado en el pepinillo.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npy&lt;/code&gt; , se devuelve una &amp;uacute;nica matriz.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npz&lt;/code&gt; , el valor devuelto admite el protocolo del administrador de contexto de forma similar a la funci&amp;oacute;n de apertura:</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">Si el archivo es un archivo &lt;code&gt;.npz&lt;/code&gt; , se devuelve un objeto similar a un diccionario, que contiene pares clave-valor &lt;code&gt;{filename: array}&lt;/code&gt; , uno para cada archivo en el archivo.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">Si el nombre del archivo termina en &lt;code&gt;.gz&lt;/code&gt; , el archivo se guarda autom&amp;aacute;ticamente en formato gzip comprimido. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; comprende los archivos comprimidos con gzip de forma transparente.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">Si el primer argumento es 1-D se trata como un vector fila.Si el último argumento es 1-D se trata como un vector de columna.Los otros argumentos deben ser 2-D.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">Si el primer argumento es 1-D se trata como un vector fila.Si el último argumento es 1-D se trata como un vector de columna.Los otros argumentos deben ser 2-D.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">Si el primer argumento es 1-D,se promueve a una matriz preparando un 1 a sus dimensiones.Después de la multiplicación de la matriz,el 1 preparado se elimina.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">Si el primer argumento es una tupla,los otros argumentos son ignorados:</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">Si la siguiente ecuaci&amp;oacute;n es Verdadera en cuanto a elementos, entonces &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; devuelve Verdadero:</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">Si la siguiente ecuación es de elemento Verdadero,entonces allclose devuelve Verdadero.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">Si las cadenas dadas son iguales, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; no hace nada. Si no son iguales, se genera un AssertionError y se muestra la diferencia entre las cadenas.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">Si el archivo de encabezado que contiene el prototipo de &lt;code&gt;double dot()&lt;/code&gt; tambi&amp;eacute;n contiene otros prototipos que desea ajustar, por lo que necesita &lt;code&gt;%include&lt;/code&gt; este archivo de encabezado, entonces tambi&amp;eacute;n necesitar&amp;aacute; un &lt;code&gt;%ignore dot;&lt;/code&gt; directiva, colocada despu&amp;eacute;s de &lt;code&gt;%rename&lt;/code&gt; y antes de &lt;code&gt;%include&lt;/code&gt; directivas. O, si la funci&amp;oacute;n en cuesti&amp;oacute;n es un m&amp;eacute;todo de clase, querr&amp;aacute; usar &lt;code&gt;%extend&lt;/code&gt; lugar de &lt;code&gt;%inline&lt;/code&gt; adem&amp;aacute;s de &lt;code&gt;%ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">Si la expresión del índice contiene matrices separadas por comas,entonces apílalas a lo largo de su primer eje.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">Si la expresión del índice contiene notación de corte o escalares,entonces cree una matriz 1-D con un rango indicado por la notación de corte.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">Si la entrada &lt;code&gt;a&lt;/code&gt; contiene una parte imaginaria, se descarta silenciosamente.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">Si el archivo de entrada no existe o no puede ser leído.</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">Si la entrada tiene un tipo entero la función es equivalente a np.max.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">Si la entrada tiene un tipo entero la función es equivalente a np.min.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">Si la entrada es 2d y se especifica el eje,el resultado es una lista de listas.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">Si la entrada no es unidimensional o contiene elementos con valores negativos, o si &lt;code&gt;minlength&lt;/code&gt; es negativo.</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el par&amp;aacute;metro de entrada &lt;code&gt;n&lt;/code&gt; es mayor que el tama&amp;ntilde;o de la entrada, la entrada se rellena a&amp;ntilde;adiendo ceros al final. Aunque este es el enfoque com&amp;uacute;n, puede dar lugar a resultados sorprendentes. Si se desea un relleno diferente, se debe realizar antes de llamar a &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">Si las entradas son ndarrays, entonces np.greater es equivalente a '&amp;gt;'.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">Si las entradas o el tipo d son complejas,la salida seguirá una espiral logarítmica en el plano complejo.(Hay un número infinito de espirales que pasan por dos puntos;la salida seguirá el camino más corto de estos.)</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">Si el iterador está almacenado en un búfer,devuelve el tamaño del búfer que se está utilizando,de lo contrario devuelve 0.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">Si el iterador está rastreando un multiíndice,éste les da soporte,y realiza otras optimizaciones del iterador que son posibles si los multiíndices no son necesarios.Esta función también restablece el iterador a su estado inicial.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">Si la &amp;uacute;ltima dimensi&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tiene un tama&amp;ntilde;o diferente.</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Si la &amp;uacute;ltima dimensi&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; no es del mismo tama&amp;ntilde;o que la pen&amp;uacute;ltima dimensi&amp;oacute;n de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">Si la matriz enmascarada tiene campos con nombre, acceder a una sola entrada devuelve un objeto &lt;code&gt;numpy.void&lt;/code&gt; si ninguno de los campos est&amp;aacute; enmascarado, o una matriz enmascarada 0d con el mismo tipo d que la matriz inicial si al menos uno de los campos est&amp;aacute; enmascarado.</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">Si el modo es de llenado constante (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING),fill_value debe apuntar a un objeto de la matriz que contenga el valor de llenado (el primer elemento será el valor de llenado si la matriz contiene más de un elemento).En otros casos,fill_value puede ser NULL.</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">Si el nombre tiene el sufijo &quot;?&quot; modificador, la dimensi&amp;oacute;n es una dimensi&amp;oacute;n central solo si existe en todas las entradas y salidas que la comparten; de lo contrario, se ignora (y se reemplaza por una dimensi&amp;oacute;n de tama&amp;ntilde;o 1 para la funci&amp;oacute;n elemental).</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si la nueva matriz es m&amp;aacute;s grande que la matriz original, entonces la nueva matriz se llena con copias repetidas de &lt;code&gt;a&lt;/code&gt; . Tenga en cuenta que este comportamiento es diferente de a.resize (new_shape) que se llena con ceros en lugar de copias repetidas de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">Si el n&amp;uacute;mero de objetos en la tupla de selecci&amp;oacute;n es menor que &lt;em&gt;N&lt;/em&gt; , entonces &lt;code&gt;:&lt;/code&gt; se asume para cualquier dimensi&amp;oacute;n subsecuente.</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">Si el objeto proporcionado es una matriz, esta funci&amp;oacute;n atraviesa la cadena de punteros &lt;code&gt;base&lt;/code&gt; para que cada matriz apunte directamente al propietario de la memoria. Una vez que se establece la base, no se puede cambiar a otro valor.</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">Si el operando est&amp;aacute; marcado como de solo escritura y se necesita una copia, se crear&amp;aacute; una matriz temporal no inicializada y luego se copiar&amp;aacute; para volver a &lt;code&gt;op[i]&lt;/code&gt; al llamar a &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; , en lugar de realizar la operaci&amp;oacute;n de copia innecesaria.</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">Si se proporciona el &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; argumentos opcional , solo se reemplazan las primeras apariciones del &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">Si se cambia la posición de iter,cualquier llamada posterior a PyArrayNeighborhoodIter_Next es un comportamiento indefinido,y se debe llamar a PyArrayNeighborhoodIter_Reset.</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">Si el tipo de datos solicitado está en orden de bytes no nativos,el indicador NBO lo anula y el tipo de datos solicitado se convierte en orden de bytes nativos.</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">Si los coeficientes devueltos son &lt;code&gt;c&lt;/code&gt; , entonces</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">Si el segundo argumento es 1-D,se promueve a una matriz agregando un 1 a sus dimensiones.Después de la multiplicación de la matriz,el 1 agregado se elimina.</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">Si la tupla de selecci&amp;oacute;n tiene todas las entradas &lt;code&gt;:&lt;/code&gt; excepto la &lt;em&gt;p&lt;/em&gt; -&amp;eacute;sima entrada que es un objeto de corte &lt;code&gt;i:j:k&lt;/code&gt; , entonces la matriz devuelta tiene la dimensi&amp;oacute;n &lt;em&gt;N&lt;/em&gt; formada al concatenar las submatrices devueltas por la indexaci&amp;oacute;n de enteros de los elementos &lt;em&gt;i&lt;/em&gt; , &lt;em&gt;i + k&lt;/em&gt; ,&amp;hellip;, &lt;em&gt;I + (m - 1) k &amp;lt;j&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">Si la separaci&amp;oacute;n entre &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; para uno o m&amp;aacute;s elementos es mayor que &lt;code&gt;nulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Si la cadena no tiene el tama&amp;ntilde;o correcto para satisfacer el &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;count&lt;/code&gt; solicitados .</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">Si el tipo de &lt;code&gt;x&lt;/code&gt; no tiene signo, entonces el tipo de salida es el entero de plataforma sin signo:</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">Si el tipo de entrada es complejo.</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">Si el tipo de la entrada es flotante o compleja.</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">Si el ufunc tiene 2 entradas y 1 salida y la segunda entrada es un array de objetos,se realiza una comprobación de caso especial para que se devuelva NotImplemented si la segunda entrada no es un ndarray,tiene el atributo __array_priority__y tiene un método especial __r{op}__.De esta forma,se señala a Python para dar al otro objeto la oportunidad de completar la operación en lugar de utilizar cálculos genéricos de objetos-matrices.Esto permite (por ejemplo)que las matrices dispersas anulen el bucle del operador de multiplicación 1-D.</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">Si los datos subyacentes son una subclase de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , se devuelven como tales.</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si el valor es cualquier cosa menos el predeterminado, &lt;code&gt;keepdims&lt;/code&gt; se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; de subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Si los m&amp;eacute;todos de las &lt;code&gt;keepdims&lt;/code&gt; no implementan keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si el valor es cualquier cosa menos el predeterminado, entonces &lt;code&gt;keepdims&lt;/code&gt; se pasar&amp;aacute; al m&amp;eacute;todo &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Si los m&amp;eacute;todos de las &lt;code&gt;keepdims&lt;/code&gt; no implementan keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Si el valor no es el predeterminado, &lt;code&gt;keepdims&lt;/code&gt; se pasar&amp;aacute; a los m&amp;eacute;todos &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; de las subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Si los m&amp;eacute;todos de las &lt;code&gt;keepdims&lt;/code&gt; no implementan keepdims , se generar&amp;aacute;n excepciones.</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Si solo hay escalares o la categor&amp;iacute;a m&amp;aacute;xima de los escalares es mayor que la categor&amp;iacute;a m&amp;aacute;xima de las matrices, los tipos de datos se combinan con &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; para producir el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Si solo hay escalares o la categor&amp;iacute;a m&amp;aacute;xima de los escalares es mayor que la categor&amp;iacute;a m&amp;aacute;xima de las matrices, los tipos de datos se combinan con &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; para producir el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">Si no hay una biblioteca con la extensión esperada,o la biblioteca es defectuosa y no puede ser cargada.</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">Si solo hay una matriz booleana y no hay una matriz de indexaci&amp;oacute;n de enteros presente, esto es sencillo. Solo se debe tener cuidado para asegurarse de que el &amp;iacute;ndice booleano tenga &lt;em&gt;exactamente&lt;/em&gt; tantas dimensiones como se supone que debe funcionar.</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">Si todas estas matrices se recopilan en una matriz estructurada, entonces &lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) tambi&amp;eacute;n se puede utilizar para ordenar la matriz directamente.</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">Si estas condiciones se &lt;code&gt;__array_function__&lt;/code&gt; , __array_function__ deber&amp;iacute;a devolver el resultado de llamar a su implementaci&amp;oacute;n para &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; . De lo contrario, deber&amp;iacute;a devolver el valor centinela &lt;code&gt;NotImplemented&lt;/code&gt; , lo que indica que estos tipos no implementan la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">Si esta matriz no posee su propia memoria,entonces la base apunta al objeto Python que la posee (tal vez otro objeto de la matriz)</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">Si esta matriz tiene la bandera (obsoleta) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; establecida, entonces esta matriz es una copia de trabajo de una matriz &quot;mal comportada&quot;.</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">Si esta función vuelve a ser verdadera,el llamador también debe comprobar la zancada del bucle interior del operando,porque si esa zancada es 0,entonces sólo se está visitando por primera vez el primer elemento del bucle exterior más interno.</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si es &lt;code&gt;None&lt;/code&gt; , se realiza una reducci&amp;oacute;n en todos los ejes. Si se trata de una tupla de ints, se realiza una reducci&amp;oacute;n en varios ejes, en lugar de en un solo eje o en todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,se realiza una media sobre varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,se realiza una reducción en varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,se realiza una desviación estándar sobre varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,se realiza una variación sobre varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,el recuento se realiza en varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,el máximo se selecciona sobre varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Si se trata de una tupla de ints,el mínimo se selecciona sobre varios ejes,en lugar de un solo eje o todos los ejes como antes.</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">Si esto es cualquier cosa menos el valor predeterminado, se pasar&amp;aacute; (en el caso especial de una matriz vac&amp;iacute;a) a la funci&amp;oacute;n &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; de la matriz subyacente. Si la matriz es una subclase y la &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; no tiene los kwarg &lt;code&gt;keepdims&lt;/code&gt; , esto generar&amp;aacute; un RuntimeError.</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">Si no es &lt;code&gt;NULL&lt;/code&gt; , entonces este descriptor de tipo de datos es una matriz contigua de estilo C de otro descriptor de tipo de datos. En otras palabras, cada elemento que describe este descriptor es en realidad una matriz de alg&amp;uacute;n otro descriptor base. Esto es m&amp;aacute;s &amp;uacute;til como descriptor de tipo de datos para un campo en otro descriptor de tipo de datos. El miembro de campos debe ser &lt;code&gt;NULL&lt;/code&gt; si no es &lt;code&gt;NULL&lt;/code&gt; (sin embargo, el miembro de campos del descriptor base puede ser no &lt;code&gt;NULL&lt;/code&gt; ). La estructura &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; se define usando</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">Si esto no es NULL,entonces este descriptor de tipo de datos tiene campos descritos por un diccionario Python cuyas claves son nombres (y también títulos si se dan)y cuyos valores son tuplas que describen los campos.Recordemos que un descriptor de tipo de datos siempre describe un conjunto de bytes de longitud fija.Un campo es una sub-región nombrada de esa colección total de longitudes fijas.Un campo se describe por una tupla compuesta por otro tipo de datos-descriptor y un desplazamiento de bytes.Opcionalmente,la tupla puede contener un título que normalmente es una cadena de Python.Estas tuplas se colocan en este diccionario tecleadas por nombre (y también por título si se da).</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">Si esto no es deseable,entonces el conjunto debe ser lanzado a un tipo entero más grande primero:</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Si se establece en &lt;code&gt;True&lt;/code&gt; , los ejes que se reducen se dejar&amp;aacute;n en el resultado como una dimensi&amp;oacute;n con tama&amp;ntilde;o uno, de modo que el resultado se transmitir&amp;aacute; correctamente contra las entradas. Esta opci&amp;oacute;n solo se puede usar para ufuncs generalizados que operan en entradas que tienen el mismo n&amp;uacute;mero de dimensiones de n&amp;uacute;cleo y con salidas que no tienen dimensiones de n&amp;uacute;cleo, es decir, con firmas como &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; o &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . Si se usa, la ubicaci&amp;oacute;n de las dimensiones en la salida se puede controlar con &lt;code&gt;axes&lt;/code&gt; y &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si se establece en Verdadero, los ejes normativos se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra la &lt;code&gt;x&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">Si esto se establece en True,los ejes que se reducen se dejan en el resultado como dimensiones con tamaño uno.Con esta opción,el resultado se emitirá correctamente contra la matriz.</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">Si esto se establece en True,los ejes que se reducen se dejan en el resultado como dimensiones con tamaño uno.Con esta opción,el resultado se emitirá correctamente contra la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si se establece en Verdadero, los ejes que se reducen se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra el original &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Si se establece en Verdadero, los ejes que se reducen se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra el &lt;code&gt;arr&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si se establece en Verdadero, los ejes que se reducen se dejan en el resultado como dimensiones con tama&amp;ntilde;o uno. Con esta opci&amp;oacute;n, el resultado se transmitir&amp;aacute; correctamente contra la matriz original &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">Si este valor no es el predeterminado, se pasa tal cual a las funciones relevantes de las subclases. Si estas funciones no tienen un &lt;code&gt;keepdims&lt;/code&gt; keepdims, se generar&amp;aacute; un RuntimeError.</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Si es verdadero (predeterminado), entonces se copia el objeto. De lo contrario, solo se realizar&amp;aacute; una copia si __array__ devuelve una copia, si obj es una secuencia anidada o si se necesita una copia para satisfacer cualquiera de los otros requisitos ( &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Si es verdadero (predeterminado), entonces se copia el objeto. De lo contrario, solo se realizar&amp;aacute; una copia si __array__ devuelve una copia, si obj es una secuencia anidada o si se necesita una copia para satisfacer cualquiera de los otros requisitos ( &lt;code&gt;itemsize&lt;/code&gt; , unicode, &lt;code&gt;order&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Si es verdadero, &lt;code&gt;stop&lt;/code&gt; es la &amp;uacute;ltima muestra. De lo contrario, no est&amp;aacute; incluido. El valor predeterminado es verdadero.</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">Si es cierto,la muestra del intervalo [bajo,alto]en lugar de la predeterminada [bajo,alto]se convierte en Falso</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">Si se usa con &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; , el bucle interno de la persona que llama puede obtener fragmentos m&amp;aacute;s grandes de lo que ser&amp;iacute;a posible sin almacenamiento en b&amp;uacute;fer, debido a c&amp;oacute;mo se distribuyen los pasos.</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">Si los valores de &lt;code&gt;x&lt;/code&gt; est&amp;aacute;n m&amp;aacute;s all&amp;aacute; de los l&amp;iacute;mites de los &lt;code&gt;bins&lt;/code&gt; , se devuelve 0 o &lt;code&gt;len(bins)&lt;/code&gt; seg&amp;uacute;n corresponda.</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">Si los valores en &lt;code&gt;x&lt;/code&gt; son tales que quedan fuera del rango de bin, intentar indexar &lt;code&gt;bins&lt;/code&gt; con los &amp;iacute;ndices que &lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt; retornos resultar&amp;aacute; en un IndexError.</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">Si dise&amp;ntilde;amos &lt;code&gt;rms&lt;/code&gt; , probablemente lo hicimos una rutina que toma una matriz de solo entrada de longitud &lt;code&gt;n&lt;/code&gt; de valores &lt;code&gt;double&lt;/code&gt; llamada &lt;code&gt;seq&lt;/code&gt; y devuelve la ra&amp;iacute;z cuadrada media. El comportamiento predeterminado de &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; , sin embargo, ser&amp;aacute; crear una funci&amp;oacute;n contenedora que compile, pero es casi imposible de usar desde el lenguaje de scripting de la forma en que se concibi&amp;oacute; la rutina C.</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">Si queremos obtener el máximo y el mínimo al mismo tiempo,podemos apilar los índices primero</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">Si se desea escribir en el valor en 'op', establezca el booleano 'escribible' en 1. Esto genera un error cuando 'op' es un escalar, una lista de listas u otra 'op' no escribible. Esto difiere de pasar &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; a PyArray_FromAny, donde la matriz grabable puede ser una copia de la entrada.</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">Si est&amp;aacute; construyendo una matriz usando la API de C y especificando su propia memoria, debe usar la funci&amp;oacute;n &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt; para establecer la base en un objeto que posee la memoria.</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no es una subclase de &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , le recomendamos que su clase defina m&amp;eacute;todos especiales como &lt;code&gt;__add__&lt;/code&gt; y &lt;code&gt;__lt__&lt;/code&gt; que deleguen a ufuncs tal como lo hace ndarray. Una manera f&amp;aacute;cil de hacer esto es subclasificar de &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">Si construye una matriz pasando su propio b&amp;uacute;fer de memoria como par&amp;aacute;metro, debe establecer la propiedad &lt;code&gt;base&lt;/code&gt; de la matriz para asegurarse de que la vida &amp;uacute;til del b&amp;uacute;fer de memoria sea adecuada.</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">Si define &lt;code&gt;__array_ufunc__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">Si depende del comportamiento actual, le sugerimos que copie la matriz devuelta expl&amp;iacute;citamente, es decir, use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; lugar de solo &lt;code&gt;np.diagonal(a)&lt;/code&gt; . Esto funcionar&amp;aacute; con versiones pasadas y futuras de NumPy.</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Si desea utilizar la ordenaci&amp;oacute;n de Fortran, tenga en cuenta que hay dos enfoques a considerar: 1) acepte que el primer &amp;iacute;ndice no es el que cambia m&amp;aacute;s r&amp;aacute;pidamente en la memoria y haga que todas sus rutinas de E / S reordenen sus datos al pasar de la memoria al disco o viceversa, o use el mecanismo de Numpy para mapear el primer &amp;iacute;ndice con los datos que var&amp;iacute;an m&amp;aacute;s r&amp;aacute;pidamente. Recomendamos el primero si es posible. La desventaja de este &amp;uacute;ltimo es que muchas de las funciones de numpy producir&amp;aacute;n matrices sin el orden de Fortran a menos que tenga cuidado de usar la palabra clave 'order'. Hacer esto ser&amp;iacute;a muy inconveniente.</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">Si no escribe en la matriz devuelta por esta funci&amp;oacute;n, puede ignorar todo lo anterior.</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">Si obtienes un error de Python que se parece a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">Si tiene una colecci&amp;oacute;n de pruebas que se deben ejecutar varias veces con variaciones menores, puede ser &amp;uacute;til crear una clase base que contenga todas las pruebas comunes y luego crear una subclase para cada variaci&amp;oacute;n. Existen varios ejemplos de esta t&amp;eacute;cnica en NumPy; a continuaci&amp;oacute;n se muestran extractos de uno en &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.py&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">Si tienes una matriz de valores de fecha-hora64 días,y quieres un recuento de cuántas de ellas son fechas válidas,puedes hacerlo:</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">Si necesita generar una buena semilla &quot;fuera de l&amp;iacute;nea&quot;, entonces la &lt;code&gt;SeedSequence().entropy&lt;/code&gt; O el uso de &lt;code&gt;secrets.randbits(128)&lt;/code&gt; de la biblioteca est&amp;aacute;ndar son ambas formas convenientes.</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">Si sólo tuvieras 150 dólares al mes para pagar el préstamo,¿cuánto tiempo tardarías en pagar un préstamo de 8.000 dólares al 7% de interés anual?</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">Si se encuentra en una situaci&amp;oacute;n en la que una funci&amp;oacute;n o m&amp;eacute;todo devuelve un puntero a una matriz, lo mejor que puede hacer es escribir su propia versi&amp;oacute;n de la funci&amp;oacute;n que se va a ajustar, ya sea con &lt;code&gt;%extend&lt;/code&gt; para el caso de m&amp;eacute;todos de clase o &lt;code&gt;%ignore&lt;/code&gt; y &lt;code&gt;%rename&lt;/code&gt; para el caso de funciones.</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">Si especifica una &lt;code&gt;n&lt;/code&gt; tal que &lt;code&gt;a&lt;/code&gt; debe rellenarse con ceros o truncarse, los valores extra / eliminados se agregar&amp;aacute;n / eliminar&amp;aacute;n a altas frecuencias. Por tanto, se puede volver a muestrear una serie en &lt;code&gt;m&lt;/code&gt; puntos a trav&amp;eacute;s de la interpolaci&amp;oacute;n de Fourier mediante: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">Si subclasifica &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , le recomendamos que ponga toda su l&amp;oacute;gica de anulaci&amp;oacute;n en &lt;code&gt;__array_ufunc__&lt;/code&gt; y no anule tambi&amp;eacute;n m&amp;eacute;todos especiales. Esto asegura que la jerarqu&amp;iacute;a de clases est&amp;eacute; determinada en un solo lugar en lugar de por separado por la maquinaria ufunc y por las reglas de operaci&amp;oacute;n binaria (que da preferencia a m&amp;eacute;todos especiales de subclases; la forma alternativa de hacer cumplir una jerarqu&amp;iacute;a de un solo lugar, de establecer &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; a &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , parecer&amp;iacute;a muy inesperado y, por lo tanto, confuso, ya que entonces la subclase no funcionar&amp;iacute;a en absoluto con ufuncs).</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">Si desea editar una matriz con c&amp;oacute;digo &lt;code&gt;double&lt;/code&gt; alineado , pero el orden no importa, debe usar esto.</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">Si desea restablecer tanto el rango de &lt;code&gt;iterindex&lt;/code&gt; como los punteros base al mismo tiempo, puede hacer lo siguiente para evitar la copia de b&amp;uacute;fer adicional (aseg&amp;uacute;rese de agregar las verificaciones de error del c&amp;oacute;digo de retorno cuando copie este c&amp;oacute;digo).</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">Ignorar los valores extremos</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">Imagen de ilustraci&amp;oacute;n: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">La ilustraci&amp;oacute;n, utilizando el hecho de que los valores propios de una matriz diagonal son sus elementos diagonales, que al multiplicar una matriz a la izquierda por una matriz ortogonal, &lt;code&gt;Q&lt;/code&gt; , y a la derecha por &lt;code&gt;Q.T&lt;/code&gt; (la transpuesta de &lt;code&gt;Q&lt;/code&gt; ), conserva los valores propios de la &amp;ldquo; matriz &quot;media&quot;. En otras palabras, si &lt;code&gt;Q&lt;/code&gt; es ortogonal, entonces &lt;code&gt;Q * A * Q.T&lt;/code&gt; tiene los mismos valores propios que &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">La imagen &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; ilustra la regla trapezoidal: las ubicaciones de los puntos en el eje y se tomar&amp;aacute;n de la matriz &lt;code&gt;y&lt;/code&gt; , por defecto las distancias en el eje x entre puntos ser&amp;aacute;n 1.0, alternativamente se pueden proporcionar con una matriz &lt;code&gt;x&lt;/code&gt; o con un escalar &lt;code&gt;dx&lt;/code&gt; . El valor devuelto ser&amp;aacute; igual al &amp;aacute;rea combinada debajo de las l&amp;iacute;neas rojas.</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">Imagina un conjunto de números enteros de 32 bits (cada uno de 4 bytes):</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Detalles de la implementación</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;__array_function__&lt;/code&gt; indican que pueden manejar la operaci&amp;oacute;n devolviendo cualquier valor que no sea &lt;code&gt;NotImplemented&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">Implementa la función exec_command que es (casi)equivalente a la función comandos.getstatusoutput pero en los sistemas NT,DOS el estado devuelto es en realidad correcto (aunque los valores de estado devueltos pueden ser diferentes por un factor).Además,exec_command toma los argumentos de las palabras clave para (re)definir las variables de entorno.</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">Implementa las comparaciones complejas entre dos n&amp;uacute;meros complejos (estructuras con un miembro real e imag) usando la definici&amp;oacute;n de NumPy del ordenamiento que es lexicogr&amp;aacute;fico: comparando las partes reales primero y luego las partes complejas si las partes reales son iguales.</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">Implementa las reglas de coerci&amp;oacute;n escalar. Los escalares solo son coaccionados silenciosamente de este tipo a tipo necesario si esta funci&amp;oacute;n devuelve un valor distinto de cero. Si escalar es &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; , entonces esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; . La regla es que los escalares del mismo TIPO se pueden coaccionar en matrices del mismo TIPO. Esta regla significa que los escalares de alta precisi&amp;oacute;n nunca provocar&amp;aacute;n la conversi&amp;oacute;n ascendente de matrices de baja precisi&amp;oacute;n del mismo TIPO.</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">Importar el API</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">En el modo 'clip', un &amp;iacute;ndice negativo que normalmente se ajusta se recortar&amp;aacute; a 0 en su lugar.</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">En el &lt;code&gt;range(6)&lt;/code&gt; , informaci&amp;oacute;n sobre qu&amp;eacute; tipo de redondeo se realiza adem&amp;aacute;s y c&amp;oacute;mo se maneja el subdesbordamiento.</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">En &lt;em&gt;modo expl&amp;iacute;cito,&lt;/em&gt; la salida se puede controlar directamente especificando etiquetas de sub&amp;iacute;ndice de salida. Esto requiere el identificador '-&amp;gt;' as&amp;iacute; como la lista de etiquetas de sub&amp;iacute;ndice de salida. Esta caracter&amp;iacute;stica aumenta la flexibilidad de la funci&amp;oacute;n, ya que la suma se puede desactivar o forzar cuando sea necesario. La llamada &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; es como &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt; , y &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; es como &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt; . La diferencia es que &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; no permite la transmisi&amp;oacute;n por defecto. Adem&amp;aacute;s, &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; especifica directamente el orden de las etiquetas del sub&amp;iacute;ndice de salida y, por lo tanto, devuelve la multiplicaci&amp;oacute;n de matrices, a diferencia del ejemplo anterior en modo impl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">En modo &lt;em&gt;expl&amp;iacute;cito&lt;/em&gt; , &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; proporciona mayor flexibilidad para calcular otras operaciones de matriz que podr&amp;iacute;an no considerarse operaciones de suma de Einstein cl&amp;aacute;sicas, al deshabilitar o forzar la suma sobre etiquetas de sub&amp;iacute;ndice especificadas.</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">En &lt;em&gt;modo impl&amp;iacute;cito&lt;/em&gt; , los sub&amp;iacute;ndices elegidos son importantes ya que los ejes de la salida se reordenan alfab&amp;eacute;ticamente. Esto significa que &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; no afecta a una matriz 2D, mientras que &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; toma su transposici&amp;oacute;n. Adem&amp;aacute;s, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; devuelve una multiplicaci&amp;oacute;n de matrices, mientras que &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; devuelve la transposici&amp;oacute;n de la multiplicaci&amp;oacute;n ya que el sub&amp;iacute;ndice 'h' precede al sub&amp;iacute;ndice 'yo'.</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">En C,no hay equivalente a las advertencias de deprecación que soporta Python.Una forma de hacer deprecaciones es marcarlas en la documentación y en las notas de lanzamiento,y luego eliminar o cambiar las características depreciadas en una futura versión principal (NumPy 2.0 y posteriores).Sin embargo,las versiones menores de NumPy no deben tener cambios importantes en la C-API que impidan que el código funcione en una versión menor anterior.Por ejemplo,haremos todo lo posible para asegurar que el código que compiló y funcionó en NumPy 1.4 debería seguir funcionando en NumPy 1.7 (pero tal vez con advertencias del compilador).</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">En NumPy 1.16, debe establecer la variable de entorno &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; antes de importar NumPy para usar anulaciones de funciones de NumPy.</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">En NumPy 1.17, el protocolo est&amp;aacute; habilitado de forma predeterminada, pero se puede deshabilitar con &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">En NumPy 1.6.0, se cre&amp;oacute; una API de promoci&amp;oacute;n de tipos para encapsular el mecanismo para determinar los tipos de salida. Consulte las funciones &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">En NumPy 1.7 y 1.8,continúa devolviendo una copia de la diagonal,pero dependiendo de este hecho es obsoleto.La escritura en la matriz resultante sigue funcionando como antes,pero se emite un Aviso de Futuro.</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">En NumPy 1.7 y posteriores, este formulario permite que &lt;code&gt;base_dtype&lt;/code&gt; se interprete como un dtype estructurado. Las matrices creadas con este dtype tendr&amp;aacute;n un dtype &lt;code&gt;base_dtype&lt;/code&gt; subyacente pero tendr&amp;aacute;n campos e indicadores tomados de &lt;code&gt;new_dtype&lt;/code&gt; . Esto es &amp;uacute;til para crear dtypes estructurados personalizados, como se hace en &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;matrices de registros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">En las versiones de NumPy &amp;lt;= 1.9.0 Nan se devuelve para los segmentos que son completamente NaN o vac&amp;iacute;os. En versiones posteriores se devuelve cero.</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">En NumPy, hay 24 nuevos tipos fundamentales de Python para describir diferentes tipos de escalares. Estos descriptores de tipo se basan principalmente en los tipos disponibles en el lenguaje C en el que est&amp;aacute; escrito CPython, con varios tipos adicionales compatibles con los tipos de Python.</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">En NumPy, las funciones universales son instancias de la clase &lt;code&gt;numpy.ufunc&lt;/code&gt; . Muchas de las funciones integradas se implementan en c&amp;oacute;digo C compilado. Los ufuncs b&amp;aacute;sicos operan sobre escalares, pero tambi&amp;eacute;n hay un tipo generalizado para el cual los elementos b&amp;aacute;sicos son submatrices (vectores, matrices, etc.), y la difusi&amp;oacute;n se realiza sobre otras dimensiones. Tambi&amp;eacute;n se pueden producir instancias de &lt;code&gt;ufunc&lt;/code&gt; personalizadas utilizando la funci&amp;oacute;n de f&amp;aacute;brica &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">En Numeric, el antepasado de Numpy, la transmisi&amp;oacute;n se implement&amp;oacute; en varias l&amp;iacute;neas de c&amp;oacute;digo enterradas en ufuncobject.c. En NumPy, la noci&amp;oacute;n de transmisi&amp;oacute;n se ha abstra&amp;iacute;do para que se pueda realizar en m&amp;uacute;ltiples lugares. La transmisi&amp;oacute;n es manejada por la funci&amp;oacute;n &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; . Esta funci&amp;oacute;n requiere que se &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; un PyArrayMultiIterObject (o algo que sea un equivalente binario). &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; realiza un seguimiento del n&amp;uacute;mero de difusi&amp;oacute;n de dimensiones y tama&amp;ntilde;o en cada dimensi&amp;oacute;n junto con el tama&amp;ntilde;o total del resultado de la difusi&amp;oacute;n. Tambi&amp;eacute;n realiza un seguimiento del n&amp;uacute;mero de matrices que se transmiten y un puntero a un iterador para cada una de las matrices que se difunden.</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">En Python 3.0, &lt;code&gt;//&lt;/code&gt; es el operador de divisi&amp;oacute;n de piso y &lt;code&gt;/&lt;/code&gt; el verdadero operador de divisi&amp;oacute;n. La funci&amp;oacute;n &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; es equivalente a la verdadera divisi&amp;oacute;n en Python.</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">En Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; es equivalente &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; ; el &amp;uacute;ltimo es simplemente az&amp;uacute;car sint&amp;aacute;ctico para el primero.</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">En un estudio, probar una alternativa espec&amp;iacute;fica a la hip&amp;oacute;tesis nula requiere el uso de la distribuci&amp;oacute;n F no central. Necesitamos calcular el &amp;aacute;rea en la cola de la distribuci&amp;oacute;n que excede el valor de la distribuci&amp;oacute;n F para la hip&amp;oacute;tesis nula. Trazaremos las dos distribuciones de probabilidad para compararlas.</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">En un sistema de complemento a dos, los n&amp;uacute;meros negativos est&amp;aacute;n representados por el complemento a dos del valor absoluto. Este es el m&amp;eacute;todo m&amp;aacute;s com&amp;uacute;n para representar n&amp;uacute;meros enteros con signo en computadoras &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . Un sistema de complemento a dos de N bits puede representar cada entero en el rango</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">Adem&amp;aacute;s &lt;code&gt;a&lt;/code&gt; o &lt;code&gt;b&lt;/code&gt; pueden ser escalares, en cuyo caso:</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">Adem&amp;aacute;s de los atributos que se pueden especificar mediante argumentos de palabras clave en el constructor de &lt;code&gt;Configuration&lt;/code&gt; , la instancia de &lt;code&gt;Configuration&lt;/code&gt; (denotamos como &lt;code&gt;config&lt;/code&gt; ) tiene los siguientes atributos que pueden ser &amp;uacute;tiles para escribir scripts de configuraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">Adem&amp;aacute;s de la clase &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , el m&amp;oacute;dulo &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; define varias constantes.</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">Adem&amp;aacute;s, si los &lt;em&gt;datos&lt;/em&gt; no son NULL, tambi&amp;eacute;n se pueden proporcionar &lt;em&gt;pasos&lt;/em&gt; . Si &lt;em&gt;pasos&lt;/em&gt; es &lt;code&gt;NULL&lt;/code&gt; , entonces los pasos de matriz se calculan como contiguos de estilo C (predeterminado) o contigua de estilo Fortran ( &lt;em&gt;banderas&lt;/em&gt; es distinto de cero para &lt;em&gt;los datos&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; o &lt;em&gt;banderas&lt;/em&gt; y &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; es distinto de cero no NULL &lt;em&gt;datos&lt;/em&gt; ). Las &lt;em&gt;atenuaciones&lt;/em&gt; y los &lt;em&gt;pasos&lt;/em&gt; proporcionados se copian en las matrices de dimensiones y pasos reci&amp;eacute;n asignados para el nuevo objeto de matriz.</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">En todos los ejemplos hasta ahora, el iterador proporciona los elementos de &lt;code&gt;a&lt;/code&gt; uno a la vez, porque toda la l&amp;oacute;gica de bucle es interna del iterador. Si bien esto es simple y conveniente, no es muy eficiente. Un mejor enfoque es mover el bucle m&amp;aacute;s interno unidimensional a su c&amp;oacute;digo, externo al iterador. De esta manera, las operaciones vectorizadas de NumPy se pueden usar en partes m&amp;aacute;s grandes de los elementos que se visitan.</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">En casi todos los casos, se debe &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; lugar de esta funci&amp;oacute;n, ya que tambi&amp;eacute;n devolver&amp;aacute; verdadero para las matrices 0d. As&amp;iacute; es como funcionan las sobrecargas numpy en el estilo de los argumentos &lt;code&gt;dx&lt;/code&gt; para &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; e&lt;/a&gt; y el argumento &lt;code&gt;bins&lt;/code&gt; para &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; a&lt;/a&gt; . Algunas diferencias clave:</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">En caso de ocurrencia múltiple de los valores máximos,se devuelven los índices correspondientes a la primera ocurrencia.</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">En caso de ocurrencia múltiple de los valores mínimos,se devuelven los índices correspondientes a la primera ocurrencia.</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">En el modo de copia, 'copiar' se especifica como un indicador por operando. Esto se hace para proporcionar control por operando. El modo de almacenamiento en b&amp;uacute;fer se especifica como una bandera de iterador.</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">En todos los casos, la tecla 'descr' es opcional, pero por supuesto proporciona m&amp;aacute;s informaci&amp;oacute;n que puede ser importante para varias aplicaciones:</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">En general, si un &amp;iacute;ndice incluye una matriz booleana, el resultado ser&amp;aacute; id&amp;eacute;ntico a insertar &lt;code&gt;obj.nonzero()&lt;/code&gt; en la misma posici&amp;oacute;n y usar el mecanismo de indexaci&amp;oacute;n de matriz de enteros descrito anteriormente. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; es equivalente &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">En general, por &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, la divisi&amp;oacute;n (polinomial) de una serie C por otra da como resultado t&amp;eacute;rminos de cociente y resto que no est&amp;aacute;n en el conjunto de bases polinomiales de Chebyshev. Por lo tanto, para expresar estos resultados como serie C, normalmente es necesario &quot;reproyectar&quot; los resultados en dicho conjunto de bases, lo que normalmente produce resultados &quot;poco intuitivos&quot; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, la divisi&amp;oacute;n (polinomial) de una serie de Hermite por otra da como resultado t&amp;eacute;rminos de cociente y resto que no est&amp;aacute;n en el conjunto de bases polinomiales de Hermite. Por lo tanto, para expresar estos resultados como una serie de Hermite, es necesario &quot;reproyectar&quot; los resultados en el conjunto de bases de Hermite, lo que puede producir resultados &quot;poco intuitivos&quot; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, la divisi&amp;oacute;n (polinomial) de una serie de Laguerre por otra da como resultado t&amp;eacute;rminos de cociente y resto que no est&amp;aacute;n en el conjunto de bases polinomiales de Laguerre. Por lo tanto, para expresar estos resultados como una serie de Laguerre, es necesario &quot;reproyectar&quot; los resultados en el conjunto de bases de Laguerre, lo que puede producir resultados &quot;poco intuitivos&quot; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, la divisi&amp;oacute;n (polinomial) de una serie de Legendre por otra da como resultado t&amp;eacute;rminos de cociente y resto que no est&amp;aacute;n en el conjunto de bases polinomiales de Legendre. Por lo tanto, para expresar estos resultados como una serie de Legendre, es necesario &quot;reproyectar&quot; los resultados en el conjunto base de Legendre, lo que puede producir resultados &quot;poco intuitivos&quot; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, el producto (polinomial) de dos series C resulta en t&amp;eacute;rminos que no est&amp;aacute;n en el conjunto de bases polinomiales de Chebyshev. Por lo tanto, para expresar el producto como una serie C, normalmente es necesario &quot;reproyectar&quot; el producto en dicho conjunto de bases, lo que normalmente produce resultados &quot;en vivo no intuitivos&quot; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, el producto (polinomial) de dos series C resulta en t&amp;eacute;rminos que no est&amp;aacute;n en el conjunto de bases polinomiales de Hermite. As&amp;iacute;, para expresar el producto como una serie de Hermite, es necesario &amp;ldquo;reproyectar&amp;rdquo; el producto sobre dicho conjunto de bases, lo que puede producir resultados &amp;ldquo;poco intuitivos&amp;rdquo; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, el producto (polinomial) de dos series C resulta en t&amp;eacute;rminos que no est&amp;aacute;n en el conjunto de bases polinomiales de Laguerre. As&amp;iacute;, para expresar el producto como una serie de Laguerre, es necesario &amp;ldquo;reproyectar&amp;rdquo; el producto sobre dicho conjunto de bases, lo que puede producir resultados &amp;ldquo;poco intuitivos&amp;rdquo; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">En general, el producto (polinomial) de dos series C resulta en t&amp;eacute;rminos que no est&amp;aacute;n en el conjunto de bases polinomiales de Legendre. As&amp;iacute;, para expresar el producto como una serie Legendre, es necesario &amp;ldquo;reproyectar&amp;rdquo; el producto sobre dicho conjunto de bases, lo que puede producir resultados &amp;ldquo;poco intuitivos&amp;rdquo; (pero correctos); consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">En general, el resultado de diferenciar una serie C necesita ser &quot;reproyectado&quot; en el conjunto base de la serie C. Por lo tanto, t&amp;iacute;picamente, el resultado de esta funci&amp;oacute;n es &amp;ldquo;poco intuitivo&amp;rdquo;, aunque correcto; consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">En general, el resultado de diferenciar una serie de Hermite no se asemeja a la misma operaci&amp;oacute;n en una serie de potencia. Por tanto, el resultado de esta funci&amp;oacute;n puede ser &quot;poco intuitivo&quot;, aunque correcto; consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">En general, el resultado de diferenciar una serie de Laguerre no se asemeja a la misma operaci&amp;oacute;n en una serie de potencias. Por tanto, el resultado de esta funci&amp;oacute;n puede ser &quot;poco intuitivo&quot;, aunque correcto; consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">En general, el resultado de diferenciar una serie Legendre no se asemeja a la misma operaci&amp;oacute;n en una serie de potencia. Por tanto, el resultado de esta funci&amp;oacute;n puede ser &quot;poco intuitivo&quot;, aunque correcto; consulte la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">En general,debe apuntar estas firmas tipográficas específicamente donde las quiere,y luego borrarlas cuando haya terminado.</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">En las dimensiones superiores,las FFT se utilizan,por ejemplo,para el análisis y el filtrado de imágenes.La eficiencia de cálculo de la TFT significa que también puede ser una forma más rápida de calcular grandes convoluciones,utilizando la propiedad de que una convolución en el dominio del tiempo equivale a una multiplicación punto por punto en el dominio de la frecuencia.</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">En las interacciones entre objetos &lt;code&gt;ArrayLike&lt;/code&gt; y n&amp;uacute;meros o matrices numpy, el resultado es siempre otro &lt;code&gt;ArrayLike&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">En el espacio lineal, la secuencia comienza en &lt;code&gt;base ** start&lt;/code&gt; ( &lt;code&gt;base&lt;/code&gt; a la potencia de &lt;code&gt;start&lt;/code&gt; ) y termina con &lt;code&gt;base ** stop&lt;/code&gt; (ver &lt;code&gt;endpoint&lt;/code&gt; continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">En muchas circunstancias, los conjuntos de datos pueden estar incompletos o contaminados por la presencia de datos no v&amp;aacute;lidos. Por ejemplo, es posible que un sensor no haya podido registrar datos o haya registrado un valor no v&amp;aacute;lido. El m&amp;oacute;dulo &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; proporciona una forma conveniente de abordar este problema mediante la introducci&amp;oacute;n de matrices enmascaradas.</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">En las verificaciones de superposici&amp;oacute;n de memoria, suponga que se accede a los operandos con &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; habilitado solo en el orden del iterador.</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">En el almacenamiento en b&amp;uacute;fer normal, el tama&amp;ntilde;o de cada bucle interno es igual al tama&amp;ntilde;o del b&amp;uacute;fer, o posiblemente mayor si se especifica &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; . Si &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado y se produce una reducci&amp;oacute;n, los bucles internos pueden volverse m&amp;aacute;s peque&amp;ntilde;os dependiendo de la estructura de la reducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">En versiones numpy&amp;gt; = 1.7.0 las &lt;code&gt;basis&lt;/code&gt; y &lt;code&gt;cast&lt;/code&gt; m&amp;eacute;todos de la clase est&amp;aacute;n tambi&amp;eacute;n disponibles. El m&amp;eacute;todo de conversi&amp;oacute;n funciona como el m&amp;eacute;todo de conversi&amp;oacute;n, mientras que el m&amp;eacute;todo de base devuelve el polinomio base de un grado dado:</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">Para agregar un paquete de Python a SciPy, su script de compilaci&amp;oacute;n ( &lt;code&gt;setup.py&lt;/code&gt; ) debe cumplir con ciertos requisitos. El requisito m&amp;aacute;s importante es que el paquete defina una funci&amp;oacute;n de &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; que devuelva un diccionario adecuado para pasar a &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; . Para simplificar la construcci&amp;oacute;n de este diccionario, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; proporciona la clase &lt;code&gt;Configuration&lt;/code&gt; , que se describe a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">Para hacer uso de la C-API desde otro m&amp;oacute;dulo de extensi&amp;oacute;n, se debe &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n import_array . Si el m&amp;oacute;dulo de extensi&amp;oacute;n est&amp;aacute; contenido en un solo archivo .c, entonces eso es todo lo que debe hacerse. Sin embargo, si el m&amp;oacute;dulo de extensi&amp;oacute;n involucra varios archivos donde se necesita la C-API, entonces se deben tomar algunos pasos adicionales.</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">Para liquidar (es decir, tener un valor futuro de 0) los $ 200,000 obtenidos hoy, se requerir&amp;iacute;a un pago mensual de $ 1,854.02. Tenga en cuenta que este ejemplo ilustra el uso de &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt; con un valor predeterminado de 0.</target>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">En otras palabras, cada entrada de &lt;code&gt;out[i,j,...,:]&lt;/code&gt; es un valor N-dimensional extra&amp;iacute;do de la distribuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">En otras palabras,el uso de la información es exactamente el mismo que cuando se usa blas_info y co.</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">En nuestros ejemplos, trataremos la matriz de entrada con un tipo de datos complejo, de modo que podamos sacar ra&amp;iacute;ces cuadradas de n&amp;uacute;meros negativos. Sin habilitar las copias o el modo de almacenamiento en b&amp;uacute;fer, el iterador generar&amp;aacute; una excepci&amp;oacute;n si el tipo de datos no coincide con precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">Las operaciones in situ realizar&amp;aacute;n el c&amp;aacute;lculo utilizando la precisi&amp;oacute;n decidida por el tipo de datos de los dos operandos, pero reducir&amp;aacute;n silenciosamente el resultado (si es necesario) para que pueda volver a encajar en la matriz. Por lo tanto, para los c&amp;aacute;lculos de precisi&amp;oacute;n mixtas, &lt;code&gt;A {op}= B&lt;/code&gt; puede ser diferente de &lt;code&gt;A = A {op} B&lt;/code&gt; . Por ejemplo, suponga que &lt;code&gt;a = ones((3,3))&lt;/code&gt; . Luego, &lt;code&gt;a += 3j&lt;/code&gt; es diferente que &lt;code&gt;a = a + 3j&lt;/code&gt; : mientras ambos realizan la misma computaci&amp;oacute;n, &lt;code&gt;a += 3&lt;/code&gt; moldes el resultado para encajar de nuevo en &lt;code&gt;a&lt;/code&gt; , mientras que &lt;code&gt;a = a + 3j&lt;/code&gt; re-une el nombre de &lt;code&gt;a&lt;/code&gt; a la resultado.</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">En versiones anteriores de NumPy,el tipo datetime64 siempre almacenaba las horas en UTC.Por defecto,al crear un objeto datetime64 a partir de una cadena o al imprimirlo se convertiría de o a la hora local:</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">En el orden de fila mayor,estilo C,en dos dimensiones,el índice de fila varía el más lento,y el índice de columna el más rápido.Esto puede generalizarse a múltiples dimensiones,en las que el orden mayor de las filas implica que el índice a lo largo del primer eje varía más lentamente,y el índice a lo largo del último más rápidamente.Lo contrario ocurre con el orden del índice de la columna mayor,estilo Fortran.</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">En precisi&amp;oacute;n simple, la &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; puede ser inexacta:</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">En la precisión simple,std()puede ser inexacto:</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">Con una sola precisión,la var()puede ser inexacta:</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">En algunos casos,es necesario un uso apropiado del rollo y el desplazamiento para obtener una respuesta deseada.</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">En algunos casos, como las matrices estructuradas y la interfaz &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; , es necesario utilizar un tipo de datos para darle sentido al objeto. Cuando sea necesario, proporcione una Descr para 'required_dtype', de lo contrario, proporcione NULL. Esta referencia no se roba. Adem&amp;aacute;s, si el dtype solicitado no modifica la interpretaci&amp;oacute;n de la entrada, out_dtype seguir&amp;aacute; obteniendo el dtype &amp;ldquo;innato&amp;rdquo; del objeto, no el dtype pasado en 'required_dtype'.</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">En algún futuro lanzamiento,devolverá una vista de lectura/escritura y la escritura en la matriz devuelta alterará su matriz original.La matriz devuelta tendrá el mismo tipo que la matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">En algunas situaciones, es posible que pueda usar la macro &lt;code&gt;%numpy_typemaps&lt;/code&gt; para implementar mapas de tipos para sus propios tipos. Consulte las secciones &lt;a href=&quot;#other-common-types-bool&quot;&gt;Otros tipos comunes: bool&lt;/a&gt; u &lt;a href=&quot;#other-common-types-complex&quot;&gt;Otros tipos comunes: complejas&lt;/a&gt; para ver ejemplos. Otra situaci&amp;oacute;n es si sus dimensiones son de un tipo distinto de &lt;code&gt;int&lt;/code&gt; (digamos &lt;code&gt;long&lt;/code&gt; , por ejemplo):</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">En el caso de 1-D y 0-D,la indexación y las palabras clave dispersas no tienen efecto.</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">En el caso de pruebas de doble precisi&amp;oacute;n, esto devolver&amp;aacute; la funci&amp;oacute;n de python &lt;code&gt;Vector.doubleLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">En el caso común de 2-D (N=1),la estructura de bloques puede ser visualizada:</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">Al final,lo que se hace para Fortran o C depende de lo que es más importante,no reordenar los datos o preservar la convención de indexación.Para imágenes grandes,reordenar los datos es potencialmente caro,y a menudo la convención de indexación se invierte para evitarlo.</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">En el archivo, los datos de la matriz comienzan en este desplazamiento. Dado que el &lt;code&gt;offset&lt;/code&gt; se mide en bytes, normalmente deber&amp;iacute;a ser un m&amp;uacute;ltiplo del tama&amp;ntilde;o de byte de &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; . Cuando &lt;code&gt;mode != 'r'&lt;/code&gt; , incluso las compensaciones positivas m&amp;aacute;s all&amp;aacute; del final del archivo son v&amp;aacute;lidas; El archivo se ampliar&amp;aacute; para dar cabida a los datos adicionales. De forma predeterminada, &lt;code&gt;memmap&lt;/code&gt; comenzar&amp;aacute; al principio del archivo, incluso si el &lt;code&gt;filename&lt;/code&gt; es un puntero de archivo &lt;code&gt;fp&lt;/code&gt; y &lt;code&gt;fp.tell() != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">En el primer caso el límite inferior de la integración se establece en -1 y la constante de integración es 0.En el segundo la constante de integración se establece en 1 también.La diferenciación es más simple ya que la única opción es el número de veces que se diferencia el polinomio:</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">En el primer caso,las dimensiones resultantes de la operación de indexación avanzada vienen primero en la matriz de resultados,y las dimensiones subespaciales después de eso.En el segundo caso,las dimensiones resultantes de las operaciones de indexación avanzada se insertan en la matriz de resultados en el mismo punto en que se encontraban en la matriz inicial (esta última lógica es la que hace que la indexación avanzada simple se comporte igual que el rebanado).</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">En las siguientes descripciones, hacemos referencia a un &lt;code&gt;DATA_TYPE&lt;/code&gt; gen&amp;eacute;rico , que podr&amp;iacute;a ser cualquiera de los tipos de datos C enumerados anteriormente, y &lt;code&gt;DIM_TYPE&lt;/code&gt; , que deber&amp;iacute;a ser uno de los muchos tipos de n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">En el pasado, la mayor&amp;iacute;a de las implementaciones usaban el miembro &quot;desc&quot; del &lt;code&gt;PyCObject&lt;/code&gt; en s&amp;iacute; (no lo confunda con el miembro &quot;descr&quot; de la estructura &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; anterior, son dos cosas separadas) para mantener el puntero al objeto que expone la interfaz. Esta es ahora una parte expl&amp;iacute;cita de la interfaz. Aseg&amp;uacute;rese de poseer una referencia al objeto cuando el &lt;code&gt;PyCObject&lt;/code&gt; se ha creado usando &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">En el rango -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 son agradables, las funciones de equiripulaci&amp;oacute;n se encuentran entre +/- 1. Los mismos gr&amp;aacute;ficos en el rango -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 se ven muy diferentes:</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">En el caso m&amp;aacute;s simple, s&amp;oacute;lo hay un &lt;em&gt;&amp;uacute;nico&lt;/em&gt; &amp;iacute;ndice de avanzada. Un solo &amp;iacute;ndice avanzado puede, por ejemplo, reemplazar un segmento y la matriz de resultados ser&amp;aacute; la misma, sin embargo, es una copia y puede tener un dise&amp;ntilde;o de memoria diferente. Es preferible un trozo cuando sea posible.</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">En las tablas siguientes, &lt;code&gt;platform?&lt;/code&gt; significa que es posible que el tipo no est&amp;eacute; disponible en todas las plataformas. Se indica compatibilidad con diferentes tipos de C o Python: dos tipos son compatibles si sus datos son del mismo tama&amp;ntilde;o y se interpretan de la misma manera.</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">En este c&amp;aacute;lculo, podemos ignorar la cantidad de n&amp;uacute;meros extra&amp;iacute;dos de cada flujo. Cada uno de los PRNG que proporcionamos tiene una protecci&amp;oacute;n adicional incorporada que evita superposiciones si las agrupaciones de &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; difieren en lo m&amp;aacute;s m&amp;iacute;nimo. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; tiene</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">En este caso, quer&amp;iacute;amos probar la resoluci&amp;oacute;n de un problema de &amp;aacute;lgebra lineal usando matrices de varios tipos de datos, usando &lt;code&gt;linalg.solve&lt;/code&gt; y &lt;code&gt;linalg.inv&lt;/code&gt; . Los casos de prueba comunes (para matrices de precisi&amp;oacute;n simple, precisi&amp;oacute;n doble, etc.) se recopilan en &lt;code&gt;LinalgTestCase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">En este capítulo se presentan los documentos de rutina,agrupados por funcionalidad.Muchas cadenas de documentos contienen código de ejemplo,que demuestra el uso básico de la rutina.Los ejemplos asumen que NumPy se importa con:</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">En este ejemplo, si &lt;code&gt;a&lt;/code&gt; es un ndarray, se puede usar una indexaci&amp;oacute;n &quot;elegante&quot;.</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">En este ejemplo también se especifica el espaciado:uniforme para el eje=0 y no uniforme para el eje=1</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">En este ejemplo, la entrada real tiene una FFT que es hermitiana, es decir, sim&amp;eacute;trica en la parte real y antisim&amp;eacute;trica en la imaginaria, como se describe en la documentaci&amp;oacute;n de &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">En dos dimensiones,el DFT se define como</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">En las versiones 1.6 y anteriores de NumPy,las siguientes banderas no tenían el espacio de nombres de la macro _ARRAY_.Esa forma de los nombres de las constantes está desactualizada en 1.7.</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">En las versiones de NumPy anteriores a la 1.7,esta función siempre devolvía una nueva matriz independiente que contenía una copia de los valores en la diagonal.</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">Matrices in situ</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">Las matrices in situ se definen como matrices que se modifican in situ.Los valores de entrada pueden o no ser utilizados,pero los valores en el momento en que la función regresa son significativos.Por lo tanto,el argumento Python proporcionado debe ser una matriz NumPy del tipo requerido.Las firmas in situ son</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">En el lugar de la clase.</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">Incremente el &amp;iacute;ndice y los miembros dataptr del &lt;em&gt;iterador&lt;/em&gt; para apuntar al siguiente elemento de la matriz. Si la matriz no es (estilo C) contigua, incremente tambi&amp;eacute;n la matriz de coordenadas N-dimensionales.</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">Incrementar los ítems 0 y 1,e incrementar el ítem 2 dos veces:</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">Incrementar el índice multidimensional en uno.</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">De hecho,el hecho es que la indexación de Python en las listas y otras secuencias conduce naturalmente a un ordenamiento de afuera hacia adentro (el primer índice obtiene la mayor agrupación,el siguiente la mayor,y el último obtiene el elemento más pequeño).Dado que los datos de imagen se almacenan normalmente por filas,esto corresponde a la posición dentro de las filas siendo el último elemento indexado.</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">Corrientes independientes</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Índice de la diagonal:0 (por defecto)se refiere a la diagonal principal,un valor positivo se refiere a una diagonal superior,y un valor negativo a una diagonal inferior.</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Índice de la diagonal:0 se refiere a la diagonal principal,un valor positivo se refiere a una diagonal superior,y un valor negativo a una diagonal inferior.</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">Índices de los elementos máximos de una matriz N-dimensional:</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">Índices de los valores máximos a lo largo de un eje.</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">Índices de los valores mínimos a lo largo de un eje.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">Indexar &lt;code&gt;x['field-name']&lt;/code&gt; devuelve una nueva &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;vista&lt;/a&gt; a la matriz, que tiene la misma forma que &lt;em&gt;x&lt;/em&gt; (excepto cuando el campo es una &lt;code&gt;x.dtype['field-name']&lt;/code&gt; ) pero del tipo de datos x.dtype ['field-name'] y contiene solo la parte de los datos en el campo especificado. Adem&amp;aacute;s &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;, los&lt;/a&gt; escalares de matriz de registros se pueden &quot;indexar&quot; de esta manera.</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">Indización y corte</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">Matrices de indexación</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">La indexaci&amp;oacute;n en una matriz estructurada tambi&amp;eacute;n se puede hacer con una lista de nombres de campo, &lt;em&gt;por ejemplo&lt;/em&gt; , &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; . A partir de NumPy 1.16, esto devuelve una vista que contiene solo esos campos. En versiones anteriores de numpy, devolv&amp;iacute;a una copia. Consulte la secci&amp;oacute;n de la gu&amp;iacute;a del usuario sobre &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;matrices estructuradas&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la indexaci&amp;oacute;n de campos m&amp;uacute;ltiples.</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">Rutinas de indexación</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">Operaciones similares a la indexación</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">Indique c&amp;oacute;mo el usuario del iterador leer&amp;aacute; o escribir&amp;aacute; en &lt;code&gt;op[i]&lt;/code&gt; . Debe especificarse exactamente uno de estos indicadores por operando. El uso de &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; o &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; para un operando proporcionado por el usuario puede activar la sem&amp;aacute;ntica &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; . Los datos se volver&amp;aacute;n a escribir en la matriz original cuando se &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">Indique los índices de los sub-arreglos a remover a lo largo del eje especificado.</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">Indica que las matrices de este tipo de datos deben ser convertidas en una lista antes de ser decapadas.</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">Indica que la memoria para este tipo de datos debe ser inicializada (puesta a 0)en la creación.</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">Indica que deben permitirse las matrices con un tamaño de cero.Dado que el típico bucle de iteración no funciona naturalmente con arreglos de tamaño cero,debes comprobar que el IterSize es mayor que cero antes de entrar en el bucle de iteración.Actualmente sólo se comprueban los operandos,no una forma forzada.</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">Indica que las matrices con tipos de referencia (matrices de objetos o matrices estructuradas que contienen un tipo de objeto) pueden aceptarse y utilizarse en el iterador. Si esta bandera est&amp;aacute; habilitada, la persona que llama debe asegurarse de verificar si &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; es verdadero, en cuyo caso no puede liberar el GIL durante la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Indica que los elementos de este tipo de datos deben contarse por referencia (utilizando &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">Indica que este operando es la m&amp;aacute;scara que se usa para seleccionar elementos al escribir en operandos que tienen la bandera &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt; aplicada. Solo un operando puede tener &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; indicador NPY_ITER_ARRAYMASK .</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">Indica que el artículo es un puntero a algún otro tipo de datos</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">Indica que este tipo de datos requiere Python C-API durante el acceso (as&amp;iacute; que no renuncie a GIL si se va a necesitar acceso a la matriz).</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">Indica si los intervalos incluyen el borde derecho o izquierdo del contenedor. El comportamiento predeterminado es (right == False), lo que indica que el intervalo no incluye el borde derecho. El extremo izquierdo del contenedor est&amp;aacute; abierto en este caso, es decir, los contenedores [i-1] &amp;lt;= x &amp;lt;contenedores [i] es el comportamiento predeterminado para los contenedores que aumentan mon&amp;oacute;tonamente.</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">Los índices también pueden ser agrupados por elementos.</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndices para el tri&amp;aacute;ngulo superior de &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">Índices de elementos que no son cero.</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">Índices de elementos que no son cero.Los índices se agrupan por elementos.</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">Índices de los elementos mínimos de un conjunto de dimensiones N:</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">Índices de los elementos ordenados de una matriz N-dimensional:</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndices para cambiar a lo largo de cada 1d segmento de &lt;code&gt;arr&lt;/code&gt; . Debe coincidir con la dimensi&amp;oacute;n de arr, pero las dimensiones en Ni y Nj pueden ser 1 para transmitir contra &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndices para llevar a lo largo de cada rebanada 1d de &lt;code&gt;arr&lt;/code&gt; . Debe coincidir con la dimensi&amp;oacute;n de arr, pero las dimensiones Ni y Nj solo deben transmitirse contra &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">Clasificación parcial indirecta.</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">Partición indirecta.</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">Clasificación indirecta.</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">Ordenación indirecta estable en múltiples claves.</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">Ordenamiento indirecto estable con múltiples claves.</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">Los valores individuales no están despojados de espacios por defecto.Cuando utilice un convertidor personalizado,asegúrese de que la función elimine los espacios.</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Los datos fueron recuperados f&amp;aacute;cilmente de la &lt;code&gt;get_info&lt;/code&gt; funci&amp;oacute;n en &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">Información (a través del objeto dtype)sobre la interpretación del elemento de datos básicos.El elemento de datos básico puede ser tan simple como un int o un float,o puede ser un objeto compuesto (por ejemplo,de tipo estructural),un campo de caracteres fijos o punteros de objetos pitón.</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">Informaci&amp;oacute;n sobre subtipos de datos en un &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;tipo de datos estructurados&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">Información sobre la disposición de la memoria de la matriz.</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Inicialice todos los punteros y miembros de funci&amp;oacute;n en &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">Producto interno</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">Producto interno de dos matrices.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">Partición en el lugar.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">Dentro y fuera.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Entrada 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">Ingrese &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; para el que se requiere la m&amp;aacute;scara.</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">Ingrese &lt;code&gt;MaskedArray&lt;/code&gt; , alternativamente un ndarray o una subclase del mismo.</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">Matrices de entrada</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">Entrada y salida</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">El argumento de entrada,puede ser de cualquier tipo y forma.</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">Matriz de entrada</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">Matriz de entrada en grados.</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">Matriz de entrada en radianes.</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">Matriz de entrada de tamaño 1.</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">Introducir una serie de cadenas para capitalizar.</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">Matriz de entrada del mismo tama&amp;ntilde;o que la &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">Una matriz de entrada o un objeto que puede ser convertido en una matriz,que contiene valores nan para ser ignorados</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">Una matriz de entrada o un objeto que puede ser convertido en una matriz,que contiene valores nanométricos que deben ser ignorados.</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">Matriz de entrada u objeto que puede ser convertido en una matriz.</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">La matriz de entrada será destruida.Antes de NumPy 1.10.0,esta matriz tenía que ser unidimensional,pero ahora puede tener cualquier forma.</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">Matriz de entrada para calcular los determinantes de.</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">Matriz de entrada para integrar.</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">Matriz de entrada con datos de tipo datetime o timedelta.</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">Matriz de entrada,una (subclase de)ndarray.</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">La matriz de entrada,puede ser compleja</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">La matriz de entrada,puede ser compleja.</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">Matriz de entrada,de la cual se toman las diagonales.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">La matriz de entrada,tiene que ser una matriz cuadrada de 2-D.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">La matriz de entrada,debe ser al menos 2-D.</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">Matriz de entrada,tomada como real.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">Matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">Matriz de entrada. Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, &lt;code&gt;x&lt;/code&gt; debe ser 1-D o 2-D.</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">Matriz de entrada. Si &lt;code&gt;sorter&lt;/code&gt; es Ninguno, entonces se debe clasificar en orden ascendente; de ​​lo contrario, el &lt;code&gt;sorter&lt;/code&gt; debe ser una matriz de &amp;iacute;ndices que lo clasifiquen.</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">Matriz de entrada. Los elementos de &lt;code&gt;a&lt;/code&gt; se leen en el orden especificado por &lt;code&gt;order&lt;/code&gt; y se empaquetan como una matriz 1-D.</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">Matriz de entrada. A menos que se especifique el &lt;code&gt;axis&lt;/code&gt; , se aplanar&amp;aacute; si a&amp;uacute;n no es 1-D.</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">Matrices de entrada</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">Las matrices de entrada se definen como matrices de datos que se pasan a una rutina pero que no se alteran en el lugar o se devuelven al usuario.Por lo tanto,se permite que la matriz de entrada Python sea casi cualquier secuencia Python (como una lista)que pueda ser convertida al tipo de matriz solicitada.Las firmas de la matriz de entrada son</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">Matrices de entrada de la misma forma.</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">Matrices de entrada para ser comparadas.</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Matrices de entrada que se van a multiplicar. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">Matrices de entrada para comparar.</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">Matrices de entrada,no se permiten los escalares.</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">Matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Matrices de entrada. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">Matrices de entrada.Se aplastan si no son ya 1D.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">Matrices de entrada.Se aplanará si no es ya 1D.</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">Ingrese los flujos de efectivo por per&amp;iacute;odo de tiempo. Por convenci&amp;oacute;n, los &amp;ldquo;dep&amp;oacute;sitos&amp;rdquo; netos son negativos y los &amp;ldquo;retiros&amp;rdquo; netos son positivos. As&amp;iacute;, por ejemplo, al menos el primer elemento de &lt;code&gt;values&lt;/code&gt; , que representa la inversi&amp;oacute;n inicial, normalmente ser&amp;aacute; negativo.</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">Clase de entrada. Si es una tupla de clases, se devuelve True si &lt;code&gt;arg1&lt;/code&gt; es una subclase de cualquiera de los elementos de la tupla.</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">Clase de entrada. Se devuelve verdadero si &lt;code&gt;arg1&lt;/code&gt; es una subclase de &lt;code&gt;arg2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">Matriz de comparación de entrada.</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">Datos de entrada,en cualquier forma que pueda ser convertida en un conjunto enmascarado.Esto incluye listas,listas de tuplas,tuplas,tuplas de tuplas,tuplas de listas,ndarrays y matrices enmascaradas.</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">Datos de entrada,en cualquier forma que pueda ser convertida en una matriz.</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">Datos de entrada,en cualquier forma que pueda ser convertida en una matriz.Esto incluye listas,listas de tuplas,tuplas,tuplas de tuplas,tuplas de listas y ndarrays.</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">Datos de entrada,en cualquier forma que pueda ser convertida en una matriz.Esto incluye listas,listas de tuplas,tuplas,tuplas de tuplas,tuplas de listas y ndarrays.Para tener éxito no se necesitan NaNs o Infs.</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">Datos de entrada,en cualquier forma que pueda ser convertida en una matriz.Esto incluye escalas,listas,listas de tuplas,tuplas,tuplas de tuplas,tuplas de listas y ndarrays.</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">Datos de entrada, que se aplanan y se establecen como la &lt;code&gt;k&lt;/code&gt; -&amp;eacute;sima diagonal de la salida.</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">Datos de entrada.</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">Datos de entrada.Si se trata de una cadena,las variables del ámbito actual pueden ser referenciadas por su nombre.</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">Datos de entrada.El histograma se calcula sobre la matriz aplanada.</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">Máscaras de entrada.</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">La entrada debe ser un ndarray (o tener atributos similares)para que se considere una máscara válida.</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">Introduzca el objeto o el nombre sobre el que obtener informaci&amp;oacute;n. Si el &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; es un objeto numpy, se proporciona su docstring. Si es una cadena, se buscan los m&amp;oacute;dulos disponibles para buscar objetos coincidentes. Si es Ninguno, se devuelve informaci&amp;oacute;n sobre la &lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; rmaci&amp;oacute;n en&lt;/a&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">Objeto de entrada. Puede ser cualquier objeto (funci&amp;oacute;n, clase, m&amp;oacute;dulo,&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">Parámetros de entrada.</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">Polinomios de entrada.</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">Secuencias de entrada.</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">Valor de entrada.</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">Valores de entrada</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">Valores de entrada.</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Valores de entrada. Si &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , deben ser ampliables a una forma com&amp;uacute;n (que se convierte en la forma de la salida).</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">Vector de entrada o pila de matrices.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">Comportamiento de argot sólo de entrada,in situ,argout,argoutview y argoutview administrado por la memoria.</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">Matrices de entrada.</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">Inserte un nuevo eje que aparecer&amp;aacute; en la posici&amp;oacute;n del &lt;code&gt;axis&lt;/code&gt; en la forma de matriz expandida.</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">Insertar elementos en una matriz.</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">Insertar escalar en una matriz (el escalar se convierte en el tipo d de la matriz, si es posible)</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">Insertar valores a lo largo del eje dado antes de los índices dados.</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">Insertar,quitar y combinar las dimensiones,y cambiar el tamaño de las existentes</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">Insertado entre los elementos.</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">Insertar datos en las matrices</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">Inserta nuevas l&amp;iacute;neas si el texto es m&amp;aacute;s largo que &lt;code&gt;max_line_width&lt;/code&gt; . El valor predeterminado es &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">Inspeccionando la matriz</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">Las instancias de subclases de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; se pasan tal cual:</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">En lugar de nombres de m&amp;eacute;todos especiales que definen el comportamiento de las clases de Python, existen &quot;tablas de funciones&quot; que apuntan a funciones que implementan los resultados deseados. Desde Python 2.2, el propio PyTypeObject se ha vuelto din&amp;aacute;mico, lo que permite los tipos C que pueden ser &quot;subtipificados&quot; de otros tipos C en C y subclasificados en Python. Los tipos secundarios heredan los atributos y m&amp;eacute;todos de sus padres.</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">En lugar de especificar la matriz de covarianza completa,las aproximaciones más populares incluyen:</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">En lugar de la tradicional 'divisi&amp;oacute;n de piso' de Python, esto devuelve una verdadera divisi&amp;oacute;n. La divisi&amp;oacute;n verdadera ajusta el tipo de salida para presentar la mejor respuesta, independientemente de los tipos de entrada.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">Indexación de la matriz de números enteros</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">La indexaci&amp;oacute;n de matrices enteras permite la selecci&amp;oacute;n de elementos arbitrarios en la matriz en funci&amp;oacute;n de su &amp;iacute;ndice &lt;em&gt;N-&lt;/em&gt; dimensional. Cada matriz de enteros representa un n&amp;uacute;mero de &amp;iacute;ndices en esa dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Exponentes enteros de 2. Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">Un número entero que indica cómo se relaciona este tipo con los tipos incorporados.</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">El rendimiento de los números enteros tiene un orden similar.</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">Un entero que puede sostener un puntero</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Parte integral de &lt;code&gt;x&lt;/code&gt; . Este es un escalar si &lt;code&gt;x&lt;/code&gt; es un escalar.</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">Integra &lt;code&gt;y&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) a lo largo del eje dado.</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">Integrar una serie de Chebyshev.</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">Integrar una serie de Hermite.</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Integrar una serie de Hermite_e.</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">Integrado en la serie de Laguerre.</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">Integrar a la serie Legendre.</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">Integrar un polinomio.</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">Integrar a lo largo del eje dado usando la regla trapezoidal compuesta.</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Constante (s) de integraci&amp;oacute;n. El valor de la primera integral en &lt;code&gt;lbnd&lt;/code&gt; es el primer valor de la lista, el valor de la segunda integral en &lt;code&gt;lbnd&lt;/code&gt; es el segundo valor, etc. Si &lt;code&gt;k == []&lt;/code&gt; (el valor predeterminado), todas las constantes se establecen en cero. Si &lt;code&gt;m == 1&lt;/code&gt; , se puede dar un solo escalar en lugar de una lista.</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Constante (s) de integraci&amp;oacute;n. El valor de la primera integral en cero es el primer valor de la lista, el valor de la segunda integral en cero es el segundo valor, etc. Si &lt;code&gt;k == []&lt;/code&gt; (el valor predeterminado), todas las constantes se establecen en cero. Si &lt;code&gt;m == 1&lt;/code&gt; , se puede dar un solo escalar en lugar de una lista.</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">Constantes de integraci&amp;oacute;n. La primera constante se aplica a la primera integraci&amp;oacute;n, la segunda a la segunda, y as&amp;iacute; sucesivamente. La lista de valores deben menos de o igual a &lt;code&gt;m&lt;/code&gt; de longitud y los valores que faltan se establece en cero.</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">Constantes de integración.Se dan en el orden de la integración:las correspondientes a los términos de mayor orden están en primer lugar.</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">Integración de los valores de la matriz usando la regla trapezoidal compuesta.</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">Intercambiar dos ejes de una matriz.</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">Los intereses pagados contra el pr&amp;eacute;stamo cambian durante la vida del pr&amp;eacute;stamo. El &lt;code&gt;per&lt;/code&gt; es el per&amp;iacute;odo de pago para calcular el monto de inter&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">La parte del pago de intereses.Si toda la entrada es escalar,devuelve un flotador escalar.Si alguna entrada es tipo_arry,devuelve la bonificación de intereses para cada elemento de entrada.Si varias entradas son tipo_arry,todas deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">Tasa de interés pagada sobre las corrientes de efectivo</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">Tasa de interés recibida por las corrientes de efectivo al reinvertirse</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">Flexibilidad interna</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">Tasa interna de retorno para los valores de entrada periódica.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">Funciones internas</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">La disposición de la memoria interna de un ndarray</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">Organización interna de las matrices de numeración</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">Estructuras utilizadas internamente</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">Internamente,los buffers se utilizan para datos desalineados,datos intercambiados y datos que deben ser convertidos de un tipo de datos a otro.El tamaño de los buffers internos se puede establecer en base a cada hilo.Puede haber hasta</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">Internamente,el código utiliza algunos objetos Python adicionales principalmente para la administración de la memoria.Estos tipos no son accesibles directamente desde Python,y no están expuestos al C-API.Se incluyen aquí sólo para completar y ayudar a entender el código.</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">Internamente,estas #definiciones funcionan de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">Interpolar una función en los puntos Chebyshev del primer tipo.</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">Interpolando la instancia de Chebyshev.</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">Interpolación con coordenadas x periódicas:</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">Interpreta un búfer como una matriz unidimensional.</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">Interpreta la entrada como una matriz.</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">manejo de interrupciones</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">Los datos no v&amp;aacute;lidos significan valores de &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">Operación inválida:el resultado no es un número expresable,típicamente indica que se produjo un NaN.</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">Coseno hiperbólico inverso,en cuanto a los elementos.</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">Elemento senoidal hiperbólico inverso.</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">Elemento tangente hiperbólico inverso.</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">Seno inverso,en cuanto a los elementos.</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">Se pueden calcular las inversiones de varias matrices a la vez:</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">Es equivalente a &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; , pero permite un uso posterior de la &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">Es sencillo realizar ingenier&amp;iacute;a inversa. Los conjuntos de datos a menudo viven m&amp;aacute;s que los programas que los crearon. Un desarrollador competente deber&amp;iacute;a poder crear una soluci&amp;oacute;n en su lenguaje de programaci&amp;oacute;n preferido para leer la mayor&amp;iacute;a de los archivos &lt;code&gt;.npy&lt;/code&gt; que se le han proporcionado sin mucha documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">¿Es la función dada algo que sabemos cómo sobrecargar?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Emitido por &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; cuando la matriz de Vandermonde tiene un rango deficiente.</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Emitido por &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; cuando la matriz de Vandermonde tiene un rango deficiente.</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">Emitido por chebfit cuando la matriz de diseño es deficiente.</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">Emitido por la clase Poly gen&amp;eacute;rica cuando dos dominios no coinciden.</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Tambi&amp;eacute;n se puede utilizar en lugares de &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">Puede considerarse como una generalizaci&amp;oacute;n de EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; , y no deber&amp;iacute;a haber ning&amp;uacute;n n&amp;uacute;mero representable entre &lt;code&gt;x + spacing(x)&lt;/code&gt; yx para cualquier x finito.</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">Se puede demostrar que una convolución</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">Se puede demostrar que si</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">Difiere de la transformación hacia adelante por el signo del argumento exponencial y la normalización por defecto por</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">Generalmente &lt;em&gt;no&lt;/em&gt; se sostiene que &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; para arreglos contiguos de estilo C o &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; para arreglos contiguos de estilo Fortran sea verdadero.</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">Tiene la siguiente estructura:</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">Tiene la función de densidad de probabilidad</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">Es &amp;uacute;til comprender un poco c&amp;oacute;mo se manejan las matrices numpy debajo de las s&amp;aacute;banas para ayudar a comprender mejor numpy. Esta secci&amp;oacute;n no entrar&amp;aacute; en grandes detalles. Aquellos que deseen comprender todos los detalles pueden consultar el libro de Travis Oliphant &quot;Guide to NumPy&quot;.</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">Se supone que todos los &amp;iacute;ndices de &lt;code&gt;x&lt;/code&gt; se suman en el producto, junto con los &amp;iacute;ndices m&amp;aacute;s a la derecha de &lt;code&gt;a&lt;/code&gt; , como se hace, por ejemplo, en &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">Es conveniente utilizar objetos &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; para tratar con polinomios:</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">Es conveniente utilizar objetos &lt;code&gt;poly1d&lt;/code&gt; para tratar con polinomios:</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">Es equivalente a &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">Es importante mantener las banderas actualizadas (el uso de &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt; puede ayudar) siempre que se realice una manipulaci&amp;oacute;n con una matriz que pueda hacer que cambien. Los c&amp;aacute;lculos posteriores en NumPy que se basan en el estado de estos indicadores no repiten el c&amp;aacute;lculo para actualizarlos.</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">Es importante tener en cuenta que una vez que se sale del iterador, las referencias colgantes (como &lt;code&gt;x&lt;/code&gt; en el ejemplo) pueden o no compartir datos con los datos originales &lt;code&gt;a&lt;/code&gt; . Si la sem&amp;aacute;ntica de reescritura estaban activos, es decir, si &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; , entonces salir del iterador cortar&amp;aacute; la conexi&amp;oacute;n entre &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; , escribiendo a &lt;code&gt;x&lt;/code&gt; ya no escritura a &lt;code&gt;a&lt;/code&gt; . Si la sem&amp;aacute;ntica de escritura &lt;code&gt;x.data&lt;/code&gt; no est&amp;aacute; activa, entonces x.data seguir&amp;aacute; apuntando a alguna parte de &lt;code&gt;a.data&lt;/code&gt; , y la escritura en uno afectar&amp;aacute; a la otra.</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">Se pretende que todas las instancias polinomiales sean inmutables, por lo tanto, las operaciones aumentadas ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.) y cualquier otra funcionalidad que viole la inmutabilidad de una instancia polinomial no se implementan intencionalmente.</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">Lleva el nombre del lingüista estadounidense George Kingsley Zipf,quien observó que la frecuencia de cualquier palabra en una muestra de un idioma es inversamente proporcional a su rango en la tabla de frecuencias.</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">Ya no se recomienda usar esta clase,ni siquiera para los lineales...</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">Ya no se recomienda usar esta clase,ni siquiera para el álgebra lineal.En lugar de eso,use arreglos regulares.La clase puede ser eliminada en el futuro.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">No siempre es posible cambiar la forma de una matriz sin copiar los datos.Si se desea que se produzca un error al copiar los datos,se debe asignar la nueva forma al atributo de forma de la matriz:</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">Se ve a menudo en las estadísticas de inferencia y orden bayesiano.</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">Es una de una clase de distribuciones de valor extremo,las distribuciones de Valor Extremo Generalizado (GEV),que también incluye a los Weibull y los Frechet.</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">Es posible cargar una biblioteca usando &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;] # doctest: + SKIP</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">Es posible especificar las opciones de config_fc en los scripts de setup.py.Por ejemplo,utilizando</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">Es posible especificar c&amp;oacute;mo se tratan los l&amp;iacute;mites usando &lt;code&gt;edge_order&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">Se recomienda utilizar una de las &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; en&lt;/a&gt; lugar de esta funci&amp;oacute;n para obtener comparaciones de punto flotante m&amp;aacute;s consistentes.</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">Se recomienda encarecidamente &lt;em&gt;no&lt;/em&gt; utilizar la subclase de matriz. Como se describe a continuaci&amp;oacute;n, hace que escribir funciones que se ocupen de manera coherente con matrices y arreglos regulares sea muy dif&amp;iacute;cil. Actualmente, se utilizan principalmente para interactuar con &lt;code&gt;scipy.sparse&lt;/code&gt; . Sin embargo, esperamos proporcionar una alternativa para este uso y eventualmente eliminar la subclase de &lt;code&gt;matrix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">Se utiliza,por ejemplo,en el modelado de la declaración excesiva de reclamaciones de seguros.</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">Es &amp;uacute;til para escribir clases que no heredan de &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , pero que deber&amp;iacute;an admitir funciones universales aritm&amp;eacute;ticas y numpy como matrices, como se describe en &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;Mecanismo para anular Ufuncs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">Cabe señalar que si</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">No siempre es conveniente usar expl&amp;iacute;citamente instancias de Polynomial, por lo que las tuplas, listas, matrices y escalares se lanzan autom&amp;aacute;ticamente en las operaciones aritm&amp;eacute;ticas:</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">Aterrizó 4 veces en el 1,una vez en el 2,etc.</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">Tambi&amp;eacute;n puede ser conveniente definir decoradores personalizados ( &lt;code&gt;implements&lt;/code&gt; continuaci&amp;oacute;n) para registrar implementaciones de &lt;code&gt;__array_function__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">Debe quedar claro que cualquier tipo estructurado podría ser descrito usando esta interfaz.</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">También funciona en 2-D:</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">Es posible asignar a una matriz de copia en escritura, pero los valores solo se escriben en la copia de memoria de la matriz y no en el disco:</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">Se recomienda especificar solo esas opciones config_fc de tal manera que sean independientes del compilador.</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">Selección y manipulación de objetos</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">Los elementos de una matriz de este tipo de datos se envuelven en un tipo &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;escalar de matriz&lt;/a&gt; que tambi&amp;eacute;n tiene dos campos:</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">Iterando sobre los arreglos</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">Iteración como un tipo de datos específicos</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">Iterando sobre las matrices</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">La iteración se hace en orden de fila mayor,estilo C (el último índice que varía más rápido).El iterador también puede ser indexado usando el corte básico o la indexación avanzada.</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">Tipos de datos del Iterator</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; iterador NPY_ITER_COMMON_DTYPE</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; iterador NPY_ITER_EXTERNAL_LOOP</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">Iterador para la radiodifusión</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">Matrices de salida asignadas por iteradores</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">Los iteradores son un concepto poderoso para el procesamiento de arreglos. Esencialmente, los iteradores implementan un bucle for generalizado. Si &lt;em&gt;myiter&lt;/em&gt; es un objeto iterador, entonces el c&amp;oacute;digo Python:</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">Su función de densidad de probabilidad es</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser, &amp;ldquo;Filtros digitales&amp;rdquo; - Cap&amp;iacute;tulo 7 en &amp;ldquo;An&amp;aacute;lisis de sistemas por computadora digital&amp;rdquo;, Editores: FF Kuo y JF Kaiser, p 218-285. John Wiley and Sons, Nueva York, (1966).</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon, Mark A. Moraes, Ron O. Dror y David E. Shaw, &quot;Parallel Random Numbers: Tan Easy as 1, 2, 3&quot;, Actas de la Conferencia Internacional de Computaci&amp;oacute;n de Alto Rendimiento, Redes, Almacenamiento y Analysis (SC11), Nueva York, NY: ACM, 2011.</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">Unir una secuencia de matrices a lo largo de un nuevo eje.</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">Unir una secuencia de matrices a lo largo de un eje existente.</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">Unir una secuencia de matrices.</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">Une la secuencia de objetos en &lt;em&gt;obj&lt;/em&gt; a lo largo del &lt;em&gt;eje&lt;/em&gt; en una sola matriz. Si las dimensiones o los tipos no son compatibles, se genera un error.</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">Uniendo las matrices</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">26 de julio de 2019</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">Tamaño del salto</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">Saltando el estado de BitGenerator</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">Salta el estado as-if salta*210306068529402873165736369884012333109 se han generado números aleatorios.</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">Al igual que en el caso de los m&amp;eacute;todos especiales incorporados como &lt;code&gt;__add__&lt;/code&gt; , los m&amp;eacute;todos &lt;code&gt;__array_function__&lt;/code&gt; escritos correctamente siempre deben devolver &lt;code&gt;NotImplemented&lt;/code&gt; cuando se encuentra un tipo desconocido. De lo contrario, ser&amp;aacute; imposible invalidar correctamente las funciones NumPy de otro objeto si la operaci&amp;oacute;n tambi&amp;eacute;n incluye uno de sus objetos.</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Clave para usar en el estado Philox. A diferencia de la semilla, el valor de la clave se establece directamente. Puede ser un int de Python en [0, 2 ** 128) o una matriz uint64 de 2 elementos. &lt;code&gt;key&lt;/code&gt; y la &lt;code&gt;seed&lt;/code&gt; no se pueden utilizar a la vez.</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Los argumentos de palabras clave pasados ​​a &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">Los argumentos de palabras clave que se utilizan para llamar por &lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; se pasan a las funciones durante la ejecuci&amp;oacute;n, es decir, si se llaman por &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; , entonces cada funci&amp;oacute;n se llama como &lt;code&gt;f(x, alpha=1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">Argumentos de palabras clave. Las palabras clave v&amp;aacute;lidas son las posibles excepciones de punto flotante. Cada palabra clave debe tener un valor de cadena que defina el tratamiento para el error en particular. Los valores posibles son {'ignorar', 'advertir', 'subir', 'llamar', 'imprimir', 'registrar'}.</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Las palabras clave distintas de &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; se pasan a la &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Las palabras clave distintas de &lt;code&gt;dtype&lt;/code&gt; se pasan a la &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">Una especie de punto flotante de datos sobre el cual obtener información.</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">Bichos conocidos:</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">Fallos conocidos y pruebas de omisi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Kotz, Samuel, et. Alabama. &amp;ldquo;La distribuci&amp;oacute;n y generalizaciones de Laplace&amp;rdquo;, Birkhauser, 2001.</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">Kronecker producto de dos matrices.</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman, &amp;ldquo;Principios de las finanzas gerenciales, Breve&amp;rdquo;, 3&amp;ordf; ed., Addison-Wesley, 2003, p&amp;aacute;g. 346.</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman, &amp;ldquo;Principios de las finanzas gerenciales, Breve&amp;rdquo;, 3&amp;ordf; ed., Addison-Wesley, 2003, p&amp;aacute;g. 348.</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">Etiquete una prueba como &quot;lenta&quot;.</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">Pruebas de etiquetado</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">Clase Laguerre</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">M&amp;oacute;dulo Laguerre ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Módulo de Laguerre (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">Los coeficientes de Laguerre en orden de grado creciente, es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; dan &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Coeficientes de Laguerre ordenados de menor a mayor. Si &lt;code&gt;y&lt;/code&gt; era 2-D, los coeficientes de los datos de la columna k de &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n en la columna &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">Serie Laguerre</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">Coeficientes de la serie de Laguerre de la integral.</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">La serie de energía de Laguerre.</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">La serie Laguerre del derivado.</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">La serie de Laguerre cuyo gráfico es una línea recta.</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">La función de peso de Laguerre.</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">Gran parte de este manual proviene del libro de Travis E. Oliphant &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (que ingres&amp;oacute; generosamente al dominio p&amp;uacute;blico en agosto de 2008). La documentaci&amp;oacute;n de referencia para muchas de las funciones est&amp;aacute; escrita por numerosos contribuyentes y desarrolladores de NumPy.</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">El mayor tamaño permitido para los buffers configurables por el usuario.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
