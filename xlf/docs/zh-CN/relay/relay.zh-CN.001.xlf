<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013年至今Facebook Inc.。</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">*现代API不支持突变片段。您可能必须将遗留突变中的突变片段内联到组件片段中。</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;返回一个基本容器，该基本容器无法获取其片段中声明的内容以外的其他数据。Relay Modern还为动态用例提供了更高级的容器（以前在Relay Classic中通过 &lt;code&gt;setVariables&lt;/code&gt; 处理）：</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome扩展&lt;/a&gt;程序在开发人员工具界面中创建了&amp;ldquo;中继&amp;rdquo;标签，用于调试Chrome中的应用</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;允许将视图定义为组件，其中每个组件都负责呈现UI的一部分。组成其他组件是如何构建复杂的UI。每个React组件不需要知道组成组件的内部工作原理。</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;电子应用程序&lt;/a&gt;连接到运行Relay的React Native应用程序</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;管理GraphQL查询的执行。它使用给定的变量发送查询，解析响应，将数据保存到内部缓存中，最后呈现视图。</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;createFragmentContainer&lt;/code&gt; 的变体，用于解决&amp;ldquo;查看更多&amp;rdquo;用例，其中先呈现数据子集，然后按需获取其他数据。Refetch容器最初像片段容器一样获取其片段的数据，但也提供 &lt;code&gt;refetch()&lt;/code&gt; 方法，通过该方法可以获取其他数据，或者可以使用不同的变量重新渲染该容器以读取数据。</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt;允许在现有Relay应用程序中逐步采用Relay Modern API。与Relay Classic相比，此方法具有以下功能：</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 接收带有纯JavaScript数据（对象，数组，字符串）的 &lt;code&gt;user&lt;/code&gt; 道具，并照常进行渲染。</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; 指令</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash;事务已排队等待提交，但另一个具有相同冲突键的事务失败。冲突队列中的所有事务（包括该事务）均已失败。事务可以重新提交或回滚。</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash;事务正在等待服务器响应。</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash;事务已发送到服务器以进行提交，但失败。</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; -事务已提交，但另一个具有相同冲突密钥的事务正在等待处理，因此该事务已排队发送给服务器。</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 中继容器，用于定义片段和要呈现的视图。</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; 中继容器，用于定义片段和要渲染的视图。</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; 旨在简化在列表中加载更多项目的工作流程-在许多情况下，我们不想一次获取所有数据，而是懒惰地加载更多数据。它依靠GraphQL服务器以标准化方式公开连接。有关详细规格，请查看&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;此页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 是中继树的根。它进行查询，获取数据并使用该数据调用 &lt;code&gt;render&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 支持直接呈现少量数据，而不需要容器来访问数据。&lt;a href=&quot;fragment-container&quot;&gt;容器&lt;/a&gt;是可选的，可以随着应用程序的大小和复杂性的增长而使用。</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 不会提供任何麻烦，例如胖查询或跟踪查询（即，将要发送到服务器的变异查询在运行时自动合成），而是让用户定义静态和显式查询。将自己限制在底层API是一个有用的准备步骤，它将帮助您准备好代码库，以迁移到新的静态Relay核心。同时，如果您需要这些动态功能，则可以选择上级的 &lt;code&gt;Relay.Mutation&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 是用于对GraphQL突变建模的低级API。</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; 以下API使用Relay.QL对象：</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; 然后，Relay.Renderer可以协调查询的获取。将它们与缓存的数据进行比较，获取所有丢失的信息，更新缓存，并在数据可用时最终渲染 &lt;code&gt;StoryContainer&lt;/code&gt; 。默认值为在获取数据时不渲染任何内容，但可以通过 &lt;code&gt;render&lt;/code&gt; 道具自定义加载视图。正如React允许开发人员在不直接操作基础视图的情况下呈现视图一样，Relay和 &lt;code&gt;Relay.Renderer&lt;/code&gt; 消除了直接与网络通信的需求。</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; 是中继库的入口点。如果您使用的是预构建的软件包之一，则可以作为全局软件包使用；如果您使用的是CommonJS模块，则可以使用 &lt;code&gt;require()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; 是一个高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; 封装了Relay需要发送到服务器的突变。通过 &lt;code&gt;sendMutation&lt;/code&gt; 方法，它们可用于网络层。</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; 可以返回以下字符串之一：</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; 封装了Relay需要发送到服务器的查询。通过 &lt;code&gt;sendQueries&lt;/code&gt; 方法，它们可用于网络层。</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; -事务尚未发送到服务器。事务可以被提交或回滚。</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含不同optimisticUpdater / updater配置的数组。它提供了一种方便的方法来指定 &lt;code&gt;updater&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含更新程序配置的数组。这是一样的&lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; ：包含连接键的对象数组，包含可选过滤器的对象以及范围行为，具体取决于我们期望的行为（追加，前置，或忽略）。</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; ：包含连接键和过滤器的对象数组。</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：响应中的字段名称，其中包含已删除节点的DataID或从连接中删除的节点的路径</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：响应中包含已删除节点的DataID的字段名称</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; ：响应中代表新创建的边的字段名称</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; Relay.Environment的实例或实现RelayEnvironment接口的任何对象。</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：一个包含GraphQL调用的对象，例如 &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 是否发送服务器请求，而不管客户端上可用的数据如何。</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 可以使用空的部分变量集来调用forceFetch，这意味着它可以触发刷新当前呈现的数据集。</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 类似于 &lt;code&gt;setVariables&lt;/code&gt; ，因为它也可以用来改变通过改变数据要求 &lt;code&gt;variables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; 使用片段声明组件的数据要求。</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; 获取对包含在父片段中的容器片段的引用。</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; 此组件的片段可用的初始变量值集。</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的突变查询。</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：对等方关闭订阅而没有错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：使用更新 &lt;code&gt;updater&lt;/code&gt; 更新内存中的中继存储后，使用&amp;ldquo;原始&amp;rdquo;响应和服务器中的错误执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：当Relay遇到错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：当Relay或服务器在处理订阅时遇到错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; 如果突变失败，则调用onFailure。</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; ：每次从服务器收到响应时使用原始GraphQL响应有效负载执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; 如果突变成功，则调用onSuccess。</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：符合突变的响应类型定义的对象。如果提供的话，乐观响应将在执行 &lt;code&gt;optimisticUpdater&lt;/code&gt; 之前标准化为代理存储。我们建议您为两个好处提供一个 &lt;code&gt;optimisticResponse&lt;/code&gt; 的响应：</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：一个函数，用于接收内存中中继存储的代理。在此功能中，客户端以命令方式定义&amp;ldquo;如何&amp;rdquo;通过代理更新商店。</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; ：包含连接的父节点的DataID。</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; ：一个数组，其中包含父级和连接之间的字段名称，包括父级和连接。</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; 包含用于获取新道具的变量集，即，当 &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; 或 &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; 并且相应的请求正在执行中时。</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; 一种基于运行时环境或以前的变量值修改变量的方法。</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; 定义查询根的&amp;ldquo; QueryConfig&amp;rdquo;或&amp;ldquo; Relay.Route&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; 是一袋变量，或者是一个函数，它接受以前的片段变量并返回新变量。</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 在满足数据需求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; 在数据未能实现时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 在满足数据要求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; 在满足数据要求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; 是一个可选参数，用于告诉Relay在提取后重新呈现组件时要在哪个变量中使用。如果没有这一点， &lt;code&gt;refetchVariables&lt;/code&gt; 将被使用。您可以将其用于更高级的用法，例如，实现分页，在该页面中，您将获取一个包含诸如 &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; 类的变量的附加页面，但随后您将使用 &lt;code&gt;{first: 10}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; 定义查询根的路由。</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; 不会立即对 &lt;code&gt;variables&lt;/code&gt; 突变，但会创建一个挂起的状态转换。 &lt;code&gt;variables&lt;/code&gt; 将继续返回以前的值，直到用满足新变量值的数据填充 &lt;code&gt;this.props&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; (可选）重写RelayContainer的默认参数&amp;ldquo; shouldComponentUpdate&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; 一个prop类型验证器，它声明prop是有效的Relay容器。</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; 一个prop类型验证器，它断言prop是有效的路由。</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; 向队列添加MutationTransaction而不提交它。</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; 启动对变异的处理。</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; 创建静态变异</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; 创建一个中继容器。</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; 创建一个接受&amp;ldquo;文件&amp;rdquo;对象的静态变异</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; 此声明此突变的数据依赖性</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; 一组默认变量，可用于此突变的片段构建器</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; 定制如何将查询和变异发送到服务器。</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; 配置何时进行中继处理。</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; 确定给定对象是否是Relay.Container。</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; 声明期望的参数。</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; 声明其他参数或参数的转换。</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; 一种基于运行时环境，先前的变量或元路由来修改变量的方法</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; 声明查询根的集合。</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; 声明此路由类的名称。</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的订阅查询。</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; 可以调用this.props.relay.setVariables来同时更新子集或所有变量。作为回报，Relay将使用新变量来尝试实现新片段。如果客户端上尚不可用数据，则这可能涉及向服务器发送请求。</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 导出以下API以执行refetch查询：</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 公开以下API：</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 旧API中的this.props.setVariables在新API中没有直接等效项。进行此更改的一个主要原因是，新内核不再跟踪如何从查询中重新获取任何特定的子树。这使新内核快得多，但是需要显式查询以获取新数据。查看以下四种不同的情况：</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：基于&lt;strong&gt;真实&lt;/strong&gt;服务器响应更新内存中中继存储的功能。当服务器响应返回时，中继首先还原由 &lt;code&gt;optimisticUpdater&lt;/code&gt; 或 &lt;code&gt;optimisticResponse&lt;/code&gt; 引入的所有更改，然后将 &lt;code&gt;updater&lt;/code&gt; 应用于存储。</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：可选功能，可以提供自定义逻辑，用于基于服务器响应来更新内存中的中继存储。</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; 包含用于获取当前道具集的变量集。</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：一个对象，其中包含突变所需的变量。</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：一个对象，其中包含预订所需的变量。</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; 已弃用。将&lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt;与Relay Classic一起使用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;容器规格&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;属性和方法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;静态方法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-up&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;EXPRESS-graphql&lt;/a&gt;&lt;/strong&gt;上&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-relay-js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt;（&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;快速入门教程&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;乐观更新只能应用一次。</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;this.props.relay&lt;/code&gt; 道具上还提供了等效的 &lt;code&gt;applyUpdate&lt;/code&gt; 和 &lt;code&gt;commitUpdate&lt;/code&gt; 方法，该道具由 &lt;code&gt;Relay.Container&lt;/code&gt; 传递给组件。这些分派突变是在当前活动的 &lt;code&gt;Relay.Environment&lt;/code&gt; 的上下文中。</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container&lt;/strong&gt;允许组件声明片段。</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer&lt;/strong&gt;替代了 &lt;code&gt;Relay.RootContainer&lt;/code&gt; ，后者构成了 &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; 并为给定的 &lt;code&gt;queryConfig&lt;/code&gt; 执行数据获取。</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;接受三个可选的回调作为道具，它们使我们可以更精细地控制渲染行为。</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;还支持 &lt;code&gt;onReadyStateChange&lt;/code&gt; 道具，该道具使我们可以在满足数据要求的同时接收细粒度的事件。</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;是一个React组件，它试图完成所需的数据，以便呈现给定 &lt;code&gt;route&lt;/code&gt; 的 &lt;code&gt;Component&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;是一个React组件，在给定 &lt;code&gt;Component&lt;/code&gt; 和 &lt;code&gt;route&lt;/code&gt; ，它试图满足渲染 &lt;code&gt;Component&lt;/code&gt; 实例所需的数据。</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;每当无法立即完成渲染所需的数据时，&lt;strong&gt;就会&lt;/strong&gt;渲染加载状态。这通常发生在初始渲染中，但是如果 &lt;code&gt;Component&lt;/code&gt; 或 &lt;code&gt;route&lt;/code&gt; 发生更改，也可能发生。</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route&lt;/strong&gt;让我们声明查询根。</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">一个 &lt;code&gt;QueryRenderer&lt;/code&gt; 是一个阵营组成部分，因此它可以在任何地方呈现一个阵营组件可以呈现，而不是仅仅在顶层。甲 &lt;code&gt;QueryRenderer&lt;/code&gt; 可以呈现&lt;em&gt;内&lt;/em&gt;其他中继部件，例如用于一个酥料饼到懒惰地提取附加数据。但是， &lt;code&gt;QueryRenderer&lt;/code&gt; 在挂载之前不会开始加载其数据，因此，如果不必要地使用嵌套的 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件，则会导致可避免的请求瀑布。</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">一个 &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 配置用于附加的儿童追加到突变查询。例如，您可能需要使用它来获取由该突变创建的新对象上的字段（并且中继通常不会尝试获取该对象，因为该对象先前没有为该对象获取任何东西）。</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">一个 &lt;code&gt;RefetchContainer&lt;/code&gt; 第一呈现像一个普通的&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt;，但必须执行不同的变量，一个新的查询和渲染该查询的响应，而不是当请求回来的选项。</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">一个 &lt;code&gt;renderLoading&lt;/code&gt; 回调可以返回模拟的默认行为 &lt;code&gt;undefined&lt;/code&gt; 。请注意，这与返回 &lt;code&gt;null&lt;/code&gt; 的 &lt;code&gt;renderLoading&lt;/code&gt; 回调不同，该回调将在加载数据时不呈现任何内容，即使存在先前的视图也是如此。</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">一个GraphQL方案</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">一个GraphQL服务器</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">GraphQL模式描述您的数据模型，并为GraphQL服务器提供一组关联的解析方法，这些方法知道如何获取数据。我们将使用&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;和&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;构建我们的模式。</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">说明如何在连接中翻页。</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">对你的数据模型的描述,以及一组相关的解析方法,这些方法知道如何获取你的应用程序可能需要的任何数据。</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">在星球大战宇宙中,一个派系有很多舰船。Relay包含的功能使操作一对多关系变得简单,使用一种标准化的方式来表达这些一对多关系。这种标准的连接模型提供了通过连接进行切片和分页的方法。</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">响应中的 &lt;code&gt;fieldName&lt;/code&gt; 与商店中的一个或多个DataID 之间的映射。</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">&lt;em&gt;在按字母顺序&lt;/em&gt;打印，按点分隔的GraphQL调用与我们希望Relay表现出来的行为之间的映射，这些行为是在那些调用或接受连接参数数组的函数的影响下向连接添加新边时返回的行为。</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">重取对象的机制。</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">建议为片段使用 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 的命名约定。从经典API迁移到现代API时需要此限制，以实现交叉兼容性。</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">规范化的缓存可确保&lt;em&gt;缓存&lt;/em&gt;保持一致。但是我们的看法呢？理想情况下，我们的React视图将始终反映缓存中的当前信息。</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;在测试套件中&lt;/a&gt;可以找到许多更详细的用法示例。</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">父组件将传递对某些 &lt;code&gt;User&lt;/code&gt; &amp;ldquo;记录&amp;rdquo; 的引用。</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;支持旧版浏览器的Relay的多填充环境可能类似于：</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">用于翻译Relay Classic和Relay Modern APIs的参考。</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">一个简单的数据库</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">一个更简单、更可预测的突变API。还删除了Relay Classic中对突变查询的限制:突变查询是静态的,字段可以任意嵌套,并且可以使用任意参数。</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">一个标准的响应是&amp;ldquo;只使用不可变的数据结构&amp;rdquo;，但让我们看看如果这样做：</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">对Relay Modern的改进和新功能的总结。</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">寻宝的工作副本可以在&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;接力范例&lt;/a&gt;库中找到。</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">API工作表</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API和运行时</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">实现视图的一致性</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">在您的.babelrc文件的插件列表中添加 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 。如果升级现有的中继应用程序，请参阅&lt;a href=&quot;babel-plugin-relay&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">将该变量添加到使用该片段的查询中,并在获取查询时将其传入。对于这一点,拥有一个包含你的产品的变量集合的模块是很有用的。</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">添加一个 &lt;code&gt;handlerProvider&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">附加选项</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">此外，您需要一个包含 &lt;code&gt;.js&lt;/code&gt; 文件的目录，该文件使用 &lt;code&gt;graphql&lt;/code&gt; 标记描述GraphQL查询和片段。我们称它为 &lt;code&gt;./src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">高级突变实例</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">高级用法</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">最初获取此故事后，我们的缓存可能如下。请注意，故事和评论都链接到与 &lt;code&gt;author&lt;/code&gt; 相同的记录：</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">所有的数据都是一次往返获取的。</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">到目前为止,我们进行的所有突变都是在更新客户端存储之前等待服务器的响应。Relay为我们提供了一个机会,让我们可以根据我们对服务器在突变成功时的响应预期,制作一个相同形状的乐观响应。</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">或者，也可以使用&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">另外，您可以全局安装 &lt;code&gt;relay-compiler&lt;/code&gt; ，这样就可以直接访问它：</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">虽然响应是分层的,但我们将通过扁平化所有记录来缓存。下面是一个Relay如何缓存这个查询响应的例子。</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">我们收到很多问题的一个领域是突变及其配置。Relay Modern引入了一个新的突变API,允许以更直接的方式更新记录和字段。</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">包含父节点和连接之间的字段名的数组,包括父节点和连接。</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">使用 &lt;code&gt;fetch&lt;/code&gt; 的示例如下所示：</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-environment&quot;&gt;中继环境&lt;/a&gt;的实例封装了GraphQL数据的内存缓存和网络层，该层提供对GraphQL服务器的访问。开发人员通常不直接使用Environment对象，而是将其传递给每个&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;，后者使用环境来访问，修改和获取数据。在容器内，可以通过 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 访问当前环境。这是最常用于&lt;a href=&quot;mutations&quot;&gt;执行突变的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">符合 &lt;code&gt;Relay.Environment&lt;/code&gt; 接口的对象，例如 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">可以提供可选的 &lt;code&gt;onReadyStateChange&lt;/code&gt; 回调以响应与数据实现有关的事件。</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">这里有一个可能的回应。</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">而这个片段就可以用来定义Story容器。</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">有效载荷中的任何字段,如果可以通过DataID与客户端存储中的一条或多条记录相关联,将与存储中的记录合并。</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">我们传递给变异构造函数的所有props都可以作为 &lt;code&gt;this.props&lt;/code&gt; 用于其实例方法。就像在中继容器中使用的组件中一样，中继将使用查询数据填充已为其定义了相应片段的道具：</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">可以教会任何服务器加载架构并说出GraphQL。我们的&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;示例&lt;/a&gt;使用Express。</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">创建中继环境的实例时，应用程序必须提供&lt;a href=&quot;network-layer&quot;&gt;网络层&lt;/a&gt;。网络层是符合简单接口的对象，中继可以通过该接口执行查询，变异和预订。本质上，该对象教中继如何与您的GraphQL服务器通信。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">阵列字段</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">举个例子,我们可以将每次发送到服务器的突变记录如下。</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">据了解，Relay容器将数据需求声明为GraphQL片段。这意味着，例如， &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 不仅可以嵌入在 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 中，而且可以嵌入任何获取 &lt;code&gt;User&lt;/code&gt; 类型的字段的容器中。</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">如我们所知，Relay片段容器将数据需求声明为GraphQL片段。我们几乎准备好让Relay满足这些组件的数据要求并进行渲染。但是，有一个问题。为了使用GraphQL实际获取数据，我们需要一个查询根。例如，我们需要将 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 片段置于GraphQL查询中。</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">此时，您可以删除所有内容，直到 &lt;code&gt;queryType&lt;/code&gt; 中的 &lt;code&gt;./data/schema.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">编写模式</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">巴别继电器插件</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">基础React组件</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">在继续之前,我们需要将我们的可执行模式序列化为JSON,供Relay.QL transpiler使用,然后启动服务器。在命令行中。</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">在深入研究变异API之前，让我们看一个完整的示例。在这里，我们将 &lt;code&gt;Relay.Mutation&lt;/code&gt; 子类化以创建一个自定义突变，我们可以使用它来讲述一个故事。</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">行为可以是 &lt;code&gt;'append'&lt;/code&gt; ， &lt;code&gt;'ignore'&lt;/code&gt; ， &lt;code&gt;'prepend'&lt;/code&gt; ， &lt;code&gt;'refetch'&lt;/code&gt; 或 &lt;code&gt;'remove'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">这两个 &lt;code&gt;Faction&lt;/code&gt; 和 &lt;code&gt;Ship&lt;/code&gt; 有，我们可以用它来重新获取他们的标识符。我们通过 &lt;code&gt;Node&lt;/code&gt; 接口和根查询类型上的 &lt;code&gt;node&lt;/code&gt; 字段向中继提供此功能。</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">但是现在，我们还可以为任意用户ID创建路由。例如，如果我们想构造一条路由来获取由 &lt;code&gt;userID&lt;/code&gt; 查询参数定义的用户的数据，则可以使用：</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">按照惯例,突变被命名为动词,它们的输入是名字,最后附加 &quot;Input&quot;,返回的对象是名字,后面附加 &quot;Payload&quot;。</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">默认情况下，Relay假定在相对于提供我们应用程序的源的 &lt;code&gt;/graphql&lt;/code&gt; 处提供GraphQL。可以通过注入默认网络层的自定义实例来重新配置它。</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">默认情况下，为初始渲染加载数据时不渲染任何内容。如果满足并渲染了先前的 &lt;code&gt;Component&lt;/code&gt; 和 &lt;code&gt;route&lt;/code&gt; 集合，则默认行为是继续渲染先前的视图。</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">缓存一致性</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">缓存更新</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">缓存一个图形</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">调用这个来乐观地对商店进行更新。</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">调用此功能将突变发送到服务器。</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">调用者必须提供适当的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; 。根据GraphQL中继规范：</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">调用 &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; 从创纪录的 &lt;code&gt;this.props&lt;/code&gt; 将返回给定的记录是否被看好突变的影响。它允许组件以与成功与服务器同步的数据不同的方式呈现本地乐观更改。</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">调用组件实例方法</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">可以使用经典环境（ &lt;code&gt;Store&lt;/code&gt; 在 &lt;code&gt;react-relay/classic&lt;/code&gt; 中）的QueryRenderer 使用：</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">使用现代环境的QueryRenderer可以使用。</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">可以React经典组件使用。</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">可以React Compat组件使用。</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">可以React Modern组件使用。</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">RelayRootContainer可以使用。</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">更改参数</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">改变一个系统中的一件事,会产生连锁反应,反过来引起其他事物的改变。想象一下,我们可以利用一个突变来接受好友请求。这可以产生广泛的影响。</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">经典组件</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">经典突变</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">客户端缓存</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">客户端模式扩展(实验性)</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Relay Classic和Relay Modern的比较</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">兼容性组件</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">兼容性模式</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">兼容性突变</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">兼容性工作表</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">兼容性模式</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt;规范中提供了有关服务器行为的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL输入对象突变&lt;/a&gt;规范中提供了有关服务器应如何运行的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL对象标识&lt;/a&gt;规范中提供了有关服务器应如何运行的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">组件和路线</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">组件可以通过使用 &lt;code&gt;setVariables&lt;/code&gt; 请求更新当前 &lt;code&gt;variables&lt;/code&gt; 集来更改其数据要求。</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">组件可以检查任何记录上即将发生的突变（即，具有相应片段的道具中可用的数据）。用一条记录调用 &lt;code&gt;getPendingTransactions&lt;/code&gt; 将返回影响该特定记录的未决突变事务的列表。</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">组成片段</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">组成视图--这就是普通的React。</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">在父片段中组成子元件片段。</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">组成定义为局部变量的片段。</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">组成数据描述。</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">《&lt;a href=&quot;guides-containers&quot;&gt;容器指南》&lt;/a&gt;中详细讨论了组成子组件的片段的方法，但这是一个简单的示例：</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">组成视图逻辑,以及</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">条件领域</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">考虑一个带有服务器定义的占位符文本的输入,以及聚焦输入节点的必要方法。</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">考虑渲染一个故事的文本和评论以及相应的作者姓名和照片。下面是GraphQL查询。</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">容器构成</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">集装箱规格</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">容器是高阶组件</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">容器可以定义 &lt;code&gt;prepareVariables&lt;/code&gt; 方法，该方法提供机会修改可用于片段的变量。除了运行时环境之外，还可以基于先前的变量（如果不存在先前的变量，则可以基于 &lt;code&gt;initialVariables&lt;/code&gt; )生成新变量。</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">容器使用GraphQL片段声明有关 &lt;code&gt;fragments&lt;/code&gt; 数据要求。</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">封装构造函数的方便方法,传递一些默认参数并返回一个实例。</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">转换游戏手册</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">转换脚本</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 关键字创建一个变异实例，可以选择向其传递一些道具。需要注意的是 &lt;code&gt;this.props&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;可用的构造函数中，但所有的方法下文提到的（被设定 &lt;code&gt;getCollisionKey&lt;/code&gt; ， &lt;code&gt;getOptimisticResponse&lt;/code&gt; 等）。这种限制是由于突变道具可能取决于RelayEnvironment的数据这一事实，直到使用 &lt;code&gt;applyUpdate&lt;/code&gt; 或 &lt;code&gt;commitUpdate&lt;/code&gt; 进行突变后才知道。</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 关键字创建一个路由实例，可以选择向其传递一些参数。</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">创建一个新的中继容器- 有关更多详细信息和示例，请参见&lt;a href=&quot;guides-containers&quot;&gt;容器指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">当前最简单的创建网络层的方法是通过 &lt;code&gt;relay-runtime&lt;/code&gt; 包中的帮助程序：</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">可以通过提供 &lt;code&gt;headers&lt;/code&gt; 对象来配置自定义HTTP标头：</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">自定义网络层</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">自定义路由和更多</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">自定义网络层必须符合以下&lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;接口。尽管默认网络层是接受某些配置的可实例化类，但这不是注入网络层的要求。</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">必须符合 &lt;code&gt;RelayNetworkLayer&lt;/code&gt; 接口的自定义网络层。</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">数据组件又称容器</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">使用GraphQL的数据依赖性</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">数据屏蔽</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">由于 &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 配置而获取的数据未写入客户端存储，但是您可以在传递给 &lt;code&gt;commitUpdate()&lt;/code&gt; 的 &lt;code&gt;onSuccess&lt;/code&gt; 回调中添加处理该数据的代码：</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">数据获取API</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">数据/视图一致性</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">程序化调试</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">视觉调试</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">默认网络层</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer(静态属性</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">设计一个胖子查询,覆盖每一个可能改变的字段。</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">在此迁移期间，请使用&lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt;工具和API与Relay Classic和Relay Modern一起使用。</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">每个 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 都有检查突变状态的方法，并提供了根据需要回滚或重新发送突变的方法。</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">任一实例 &lt;code&gt;Relay.Route&lt;/code&gt; 或与对象 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;queries&lt;/code&gt; ，以及任选的 &lt;code&gt;params&lt;/code&gt; 性质。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">即使我们可以访问 &lt;code&gt;renderFetched&lt;/code&gt; 中的 &lt;code&gt;data&lt;/code&gt; 对象，实际的数据还是故意不透明的。这样可以防止 &lt;code&gt;renderFetched&lt;/code&gt; 对 &lt;code&gt;Component&lt;/code&gt; 声明的片段创建隐式依赖。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">有关如何从旧API 迁移 &lt;code&gt;this.props.setVariables&lt;/code&gt; 调用的示例。</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">可扩展核心</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">获取数据</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">为一个视图获取数据</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">从服务器获取数据</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">获取一个视图层次结构的所有数据。</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">围绕路由的要求更少</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">最后，让我们在 &lt;code&gt;./js/components/App.js&lt;/code&gt; 中将它们捆绑在一起：</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">最后,我们构建我们的模式(其起始查询类型是我们在上面定义的查询类型)并将其导出。</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">查找或创建与可变记录关联的单个记录。如果关联记录不存在，这是使用 &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; 到 &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">首先，安装插件（通常是 &lt;code&gt;devDependency&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">首先，让我们看一下 &lt;code&gt;environment&lt;/code&gt; 输入。为了使用相关数据在正确的 &lt;code&gt;environment&lt;/code&gt; 执行变异，最好使用用于渲染组件的 &lt;code&gt;environment&lt;/code&gt; 。可从组件的 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 访问它。</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">首先，您需要安装&lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;守卫&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">平路</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">流量类型生成</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">有关如何加载 &lt;code&gt;schema.js&lt;/code&gt; 文件，运行自省查询以获取模式信息并将其保存到JSON文件的完整示例，请查看&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;入门工具包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">对于一个简单的应用来说,这已经是一个不错的进步了。</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">例如， &lt;code&gt;rangeBehaviors&lt;/code&gt; 可以这样写：</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">例如,网络层可以是一个符合接口的简单对象。</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">例如,给定两个文件。</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">例如，如果在 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; 设置了 &lt;code&gt;currentDate&lt;/code&gt; ，则$ currentDate可以在 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 包括的任何片段中引用。</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">有关更复杂的乐观更新（包括从列表中添加和删除）的&lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;示例&lt;/a&gt;，请参见Relay Modern Todo示例应用程序。</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">对于更复杂的用例，您可能希望执行自定义逻辑以在收到每个订阅响应时更新Relay的内存中缓存。为此，请传递一个 &lt;code&gt;updater&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">对于更复杂的突变， &lt;code&gt;optimisticUpdater&lt;/code&gt; 和 &lt;code&gt;updater&lt;/code&gt; 可以是相同的功能。</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">有关创建网络的更多详细信息，请参见&lt;a href=&quot;network-layer&quot;&gt;NetworkLayer指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">对于新的Relay应用或已经完全转换为Compat API的现有应用,可以启用Relay Modern运行时来激活更多的功能。除上述功能外,还包括:1:</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">强制取件</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">强制从客户端获取数据</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found通过&lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;提供与Relay Modern和Relay Classic的集成。找到的中继并行运行查询匹配的路由，并支持并行获取中继数据，并在使用Relay Modern时从代码拆分中下载异步包。</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">片段构成</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">片段组成是通过ES6模板字符串插值和 &lt;code&gt;getFragment&lt;/code&gt; 实现的：</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">片段组成的工作原理相似-父容器的片段组成了每个子容器的片段。在这种情况下， &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 需要获取 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 所需的有关 &lt;code&gt;User&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">片段组成的工作原理相似-父容器的片段组成了每个子容器的片段。在这种情况下， &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 需要获取有关信息的 &lt;code&gt;Todo&lt;/code&gt; 是由所需的小号 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">片段变量</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">碎片可以用两种方式组成。</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">片段可以嵌入其他片段或查询中。例如，以上片段可用于获取用户 &lt;code&gt;123&lt;/code&gt; 的个人资料照片：</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">片段也可以组成其他片段,这些片段被分配给局部变量。</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">使用JavaScript构建GraphQL模式的通用工具。</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">获取一个片段引用,用于父的查询片段。</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">获取对子容器片段的引用,以便包含在父片段中。</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">获取一个字符串名称,用来指代这个打印调试输出的请求。</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">获取GraphQL突变的字符串表示。</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">获取GraphQL查询的字符串表示。</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">获取此突变的唯一标识符。这些标识符对于在单个GraphQL请求中发送时将响应有效载荷分配给相应的突变非常有用。</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">获取此查询的唯一标识符。这些标识符对于在单个GraphQL请求中发送响应有效载荷时,将响应有效载荷分配给相应的查询非常有用。</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">获取从名字到文件对象的可选映射。</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">获取突变所使用的变量。这些变量应该被序列化并在GraphQL请求中发送。</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">获取查询使用的变量。这些变量应该被序列化并在GraphQL请求中发送。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">给定一个连接、响应有效载荷中的一个或多个DataID以及父连接和连接之间的路径,Relay将从连接中移除节点,但在存储中保留相关记录。</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">给定删除的IDFieldName,Relay将从连接中移除节点。</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">给定一个父节点、一个连接和响应有效载荷中的一个或多个DataID,Relay将从连接中移除节点,并从存储中删除相关记录。</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">给定一个父节点、一个连接和响应有效载荷中新创建的边缘的名称,Relay将把节点添加到存储中,并根据指定的范围行为将其附加到连接上。</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">给定一个父节点、连接键、响应有效载荷中的一个或多个DataID以及父节点和连接之间的路径,Relay将从连接中移除节点,但在存储中保留相关记录。</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">给定父节点、连接信息和响应有效载荷中新创建的边缘的名称,Relay 将根据 connectionInfo 中指定的范围行为将节点添加到存储中,并将其附加到连接上。</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">给定普通的React组件和GraphQL片段，我们现在可以定义一个 &lt;code&gt;Container&lt;/code&gt; 来向Relay告知该组件的数据要求。让我们先看一下代码，然后看看发生了什么：</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">考虑到这些现实世界的限制，GraphQL中的方法是让客户查询在突变后可能发生变化的事物。但是，我们到底要输入什么呢？在Relay的开发过程中，我们探索了几种想法-让我们简要地看一下它们，以了解为什么Relay使用它所采用的方法：</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">GraphQL中继规范</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">图形QL方案</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">GraphQL订阅和实时查询</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL旨在支持广泛的数据访问模式。为了了解应用程序数据的结构，Relay要求您在定义架构时遵循某些约定。这些在&lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL继电器规范中有说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL通过关注产品开发者和客户端应用的需求,为客户端获取数据提供了新的方式。它为开发人员提供了一种方法,可以指定视图所需的精确数据,并使客户端能够在一次网络请求中获取这些数据。与传统的方法(如REST)相比,GraphQL帮助应用程序更有效地获取数据(与面向资源的REST方法相比),并避免服务器逻辑的重复(自定义端点可能会发生)。此外,GraphQL还能帮助开发人员将产品代码和服务器逻辑解耦。例如,一个产品可以获取更多或更少的信息,而不需要改变每个相关的服务器端点。这是一种很好的数据获取方式。</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL提供了一个功能强大的工具，可用于构建高效的，解耦的客户端应用程序。中继基于此功能提供&lt;strong&gt;声明式数据获取&lt;/strong&gt;的框架。通过分离&lt;em&gt;哪些&lt;/em&gt;数据从获取&lt;em&gt;如何&lt;/em&gt;是牵强，接力帮助开发人员构建是强大的，透明的和高性能的应用程序默认。这是对React倡导的以组件为中心的思维方式的巨大补充。虽然上述每种技术（React，Relay和GraphQL）都具有强大的功能，但两者的结合是一个&lt;strong&gt;UI平台&lt;/strong&gt;，使我们能够&lt;em&gt;快速移动&lt;/em&gt;并&lt;em&gt;大规模&lt;/em&gt;交付&lt;em&gt;高质量的应用程序&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">这是 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 的基本实现，该实现忽略样式以突出显示功能：</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">这是 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 的基本实现，该实现忽略样式以突出功能：</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">这是 &lt;code&gt;LikeButton&lt;/code&gt; 组件正在使用的这种变异的示例：</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">下面是一个查询的例子,可以获取一个故事的文本和作者的名字。</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">下面是呈现容器时的情况。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">从历史上看,Relay最初在Facebook内部是一个路由框架。然而,Relay不再对路由进行任何假设,而是与各种路由选项一起工作。</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">嗯 没有更多的船了。猜想叛军中只有五个人。很高兴知道我们已经到达连接的末端，而不必进行另一次往返来验证这一点。连接模型使用称为 &lt;code&gt;PageInfo&lt;/code&gt; 的类型来公开此功能。因此，让我们发出使我们再次发货的两个查询，但是这次要求 &lt;code&gt;hasNextPage&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">但是，使用Relay Modern API（ &lt;code&gt;'react-relay'&lt;/code&gt; ）和Relay Classic API（ &lt;code&gt;'react-relay/classic'&lt;/code&gt; ）的组件不能相互使用。</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">但是，Relay Compiler也会自动生成流类型，作为&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;类型注释&lt;/a&gt;。导入类型：</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">但是，Relay Modern希望定义现代JavaScript全局类型（ &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Promise&lt;/code&gt; ， &lt;code&gt;Object.assign&lt;/code&gt; ）。如果您支持可能还没有原生提供这些功能的旧版浏览器和设备，请考虑在捆绑的应用程序中包括全局polyfill，例如&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">但是，该片段也可以获取用户 &lt;code&gt;123&lt;/code&gt; 的每个朋友的个人资料照片：</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">如果发生&amp;ldquo;强制获取&amp;rdquo;并且客户端上没有足够的数据，则可以预期&lt;strong&gt;与从服务器获取数据&lt;/strong&gt;相同的行为。但是，如果出现一个&amp;ldquo;力取&amp;rdquo;有&lt;em&gt;是&lt;/em&gt;在客户端上足够的数据来呈现，我们可以预期以下行为：</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">如果片段使用在运行时确定的变量，&lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;请参见下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">如果服务器请求导致加载数据失败,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">如果发生错误，导致&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;无法获取呈现 &lt;code&gt;Component&lt;/code&gt; 所需的数据，则默认情况下不会呈现任何内容。可以通过为 &lt;code&gt;renderFailure&lt;/code&gt; 属性提供回调来配置错误处理行为：</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">如果 &lt;code&gt;Component&lt;/code&gt; 或 &lt;code&gt;route&lt;/code&gt; 发生更改，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将立即开始尝试满足新数据要求。</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">如果客户端数据不足,导致Relay发送服务器请求获取更多数据,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有任何请求在进行中，则Patricks为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">如果没有提供,则会推导出一个唯一的碰撞键(意味着所创建的突变将是独立的,不会与任何其他突变发生碰撞)。</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">如果客户端有足够的数据,Relay不需要发送服务器请求,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">如果提供并设置为 &quot;true&quot;,则无论客户端的数据是否已经可用,都会向服务器发出数据请求。</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">如果提供并设置为 &quot;true&quot;,则无论客户机上的数据是否可以立即满足数据要求,都会向服务器发出数据请求。</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">如果应用程序的&amp;ldquo;中继&amp;rdquo;部分是某个窗口小部件或作为较大应用程序的一部分的单个视图，则不需要任何路由。您可以仅在页面上的某个位置呈现 &lt;code&gt;QueryRenderer&lt;/code&gt; ，以在那里获取和呈现所需的数据。此选项很简单，应在足够时使用。</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">如果回调返回 &lt;code&gt;undefined&lt;/code&gt; ，则呈现先前呈现的视图（如果没有先前的视图则不呈现）（例如，从一个 &lt;code&gt;queryConfig&lt;/code&gt; 转换到另一个queryConfig时）。</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">如果组件实际上不使用 &lt;code&gt;setVariables()&lt;/code&gt; ，而仅使用 &lt;code&gt;initialVariables&lt;/code&gt; 在JS和GraphQL之间共享值，则有两种替代方法：</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">如果突变定义了一个乐观的有效载荷--在等待服务器响应时在本地应用的一组数据,Relay就会应用这个变化,并更新任何受影响的React组件(注意,乐观的更新不会覆盖缓存中的已知服务器数据)。</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">如果该突变不会与其他未决突变发生&amp;ldquo;冲突&amp;rdquo;（重叠）（如其 &lt;code&gt;getCollisionKey&lt;/code&gt; 实现所指定的那样），则会将其发送到服务器。如果发生冲突，则将其排队直到冲突的突变完成。</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">如果没有提供render回调,那么默认的行为是在数据可用的情况下渲染容器,在现有视图存在的情况下渲染现有视图,或者什么都不渲染。</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">如果没有 &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 后缀，则将使用 &lt;code&gt;data&lt;/code&gt; prop名称：</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">如果我们对帝国做同样的事情,我们会发现它返回的ID不同,我们也可以重新获取它。</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">如果我们为突变提供了一种符合上述签名的方法，则将有机会根据先前的变量（如果不存在先前的 &lt;code&gt;initialVariables&lt;/code&gt; 则为initialVariables），片段路径，修改片段生成器的变量，和运行时环境。该方法返回的任何变量都可用于此突变的片段构建器。</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">如果将 &lt;code&gt;2&lt;/code&gt; 替换为新的不可变记录，我们还将获得缓存对象的新的不可变实例。但是，记录 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 保持不变。因为数据是规范化的，所以仅查看 &lt;code&gt;story&lt;/code&gt; 记录就无法判断 &lt;code&gt;story&lt;/code&gt; 的内容已更改。</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">如果要为任意用户创建此路由的实例，则可以将 &lt;code&gt;Relay.Route&lt;/code&gt; 抽象类作为子类。 &lt;code&gt;Relay.Route&lt;/code&gt; 可以轻松定义一组查询和所需的参数，以供多次重用：</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">如果你发现你需要做一些独特的东西（如生成符合旧版本的流类型，或解析非JavaScript源文件），你可以在自己的交换建立自己的编译器版本 &lt;code&gt;FileWriter&lt;/code&gt; 和 &lt;code&gt;ASTCache&lt;/code&gt; ，或通过添加其他 &lt;code&gt;IRTransform&lt;/code&gt; 。请注意， &lt;code&gt;RelayCompiler&lt;/code&gt; 的内部API 处于不断的迭代中，因此滚动您自己的版本可能会导致与将来的发行版不兼容。</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">如果您希望提供自己的 &lt;code&gt;handlerProvider&lt;/code&gt; ，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">如果使用 &lt;code&gt;createRefetchContainer&lt;/code&gt; ,则您的 &lt;code&gt;refetch&lt;/code&gt; 方法也可能会更新这些变量以使用新值进行渲染。</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">如果您使用的是不同的GraphQL服务器实现,我们建议调整上面的例子,从您的GraphQL服务器加载模式(例如通过HTTP请求),然后将结果保存为JSON。</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">想象一下,我们有一个简单的应用程序,可以获取一个故事列表,以及每个故事的一些细节。下面是在面向资源的REST中的样子。</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">在处理乐观响应所需的突变器配置需要与处理服务器响应的配置不同的情况下,实现该方法。</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">实现这个方法来制作一个乐观的响应,其形状与服务器响应有效载荷相同。这个乐观的响应将被用来在服务器返回之前先发制人地更新客户端缓存,给人一种突变瞬间完成的感觉。</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">实现这个方法来返回一个碰撞键。Relay将把具有相同碰撞键的任何突变按顺序串行地发送到服务器。</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">实现此方法以返回 &lt;code&gt;File&lt;/code&gt; 对象的映射，以作为突变的一部分上载。</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">当提供的选项被该网络层支持时,实现该方法返回true。这用来声明网络层支持哪些功能。</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">实现此方法以将变异发送到服务器。当获得了服务器的响应，该方法要么必须调用 &lt;code&gt;mutationRequest.resolve&lt;/code&gt; 与响应数据，或 &lt;code&gt;mutationRequest.reject&lt;/code&gt; 与 &lt;code&gt;Error&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">实现此方法以将查询发送到服务器。对于每个查询请求，当收到服务器响应时，此方法必须使用响应数据调用 &lt;code&gt;resolve&lt;/code&gt; 或使用 &lt;code&gt;Error&lt;/code&gt; 对象 &lt;code&gt;reject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">实施此必需的方法来设计&amp;ldquo;胖查询&amp;rdquo;，该查询表示数据模型中可能由于此突变而发生变化的每个字段。</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">实现这个所需的方法,给Relay指示如何使用每次突变的响应有效载荷来更新客户端存储。</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">实现这个所需的方法来准备变量作为突变的输入。</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">实现这个所需的方法,以返回一个表示要进行突变的GraphQL突变操作。</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">导入生成的定义</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">在GraphQL中，&lt;strong&gt;查询&lt;/strong&gt;声明根查询类型上存在的字段。例如，以下查询可能会获取 &lt;code&gt;id&lt;/code&gt; 为 &lt;code&gt;123&lt;/code&gt; 的用户名：</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">在React Native中,我们可以安排Relay处理,以避免中断触摸手势,具体如下。</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在React中，渲染视图需要两个输入：要渲染的&lt;em&gt;组件&lt;/em&gt;和要渲染到的&lt;em&gt;根&lt;/em&gt; DOM（UI）节点。渲染中继容器类似：我们需要一个&lt;em&gt;容器&lt;/em&gt;进行渲染，并需要从图中的&lt;em&gt;根&lt;/em&gt;开始查询。我们还必须确保执行了对容器的查询，并且可能希望在获取数据时显示加载指示符。与 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; 相似，Relay &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; 提供了&amp;lt;Relay.Renderer Container = {...} queryConfig = {...}&amp;gt;。该容器呈现项目，以及queryConfig提供了指定查询&lt;em&gt;其&lt;/em&gt;获取项目。这是我们可能的渲染方式 &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">在Relay中，使用&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;描述数据依赖关系。对于 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; ，依赖性可以表示如下。请注意，这与组件用于 &lt;code&gt;user&lt;/code&gt; 道具的形状完全匹配。</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">在Relay中，使用&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;描述数据依赖关系。对于 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; ，依赖性可以表示如下。请注意，这正是形状的部件预期的匹配 &lt;code&gt;item&lt;/code&gt; 道具。</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">在Relay中，查询的&lt;strong&gt;根由QueryRenderer&lt;/strong&gt;定义，因此请查看该部分以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">在Relay中，查询的根由&lt;strong&gt;Route&lt;/strong&gt;定义。继续了解中继路线。</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">在面向资源的REST系统中，我们可以维护基于URI 的&lt;strong&gt;响应缓存&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">在简单的突变中，您只需要 &lt;code&gt;mutation&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">在简单的订阅中，只需要 &lt;code&gt;subscription&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; 。当您仅更改可以由其 &lt;code&gt;id&lt;/code&gt; 标识的现有记录的属性时，这是适当的：</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">除bin脚本外， &lt;code&gt;relay-compiler&lt;/code&gt; 软件包还&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;导出库代码&lt;/a&gt;，您可以使用这些库代码为编译器创建更复杂的配置，或使用您自己的自定义输出扩展编译器。</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">为了增量转换现有的代码库,我们需要使用Relay Modern API,同时继续使用Relay Classic运行时,直到所有组件转换完毕。</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">为了了解如何访问GraphQL服务器，Relay Modern要求开发人员在创建&lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;的实例时提供实现 &lt;code&gt;NetworkLayer&lt;/code&gt; 接口的对象。该环境使用此网络层执行查询，变异和（如果您的服务器支持）订阅。这使开发人员可以使用最适合其应用程序的任何传输方式（HTTP，WebSockets等）和身份验证，从而将环境与每个应用程序的网络配置的细节脱钩。</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">为了将片段解析为对象数组，您必须使用 &lt;code&gt;@relay(plural: true)&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">根据我们的经验，绝大多数产品都希望一种特定的行为：在显示加载指示器的同时获取视图层次结构的&lt;em&gt;所有&lt;/em&gt;数据，然后在数据准备好后呈现&lt;em&gt;整个&lt;/em&gt;视图。</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">在最后一个示例中，将 &lt;code&gt;$format&lt;/code&gt; 和 &lt;code&gt;variables.format&lt;/code&gt; 视为相同的值。</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">在上图中。</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;user&lt;/code&gt; 属性将在包含 &lt;code&gt;...Component_internUser&lt;/code&gt; 的所有位置包括 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 字段的数据，而不是Relay屏蔽这些字段的常规行为。</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">未来,Relay中的高级功能可能取决于网络层是否能够支持某些功能。</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">在本文中，我们将探讨构建GraphQL客户端框架的含义以及与传统REST系统的客户端相比如何。在此过程中，我们将研究Relay背后的设计决策，并发现它不仅是GraphQL客户端，还是&lt;em&gt;声明式数据获取&lt;/em&gt;的框架。让我们从头开始，获取一些数据！</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">在此示例中，应使用传递给查询的 &lt;code&gt;userID&lt;/code&gt; 来初始化Route 。该 &lt;code&gt;userID&lt;/code&gt; 变量将自动向下传递到顶级容器，并在需要时可以在此处使用。此外，顶级RelayContainer应该具有一个 &lt;code&gt;user&lt;/code&gt; 片段，其中包含要查询的字段。</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">在此示例中，将为初始渲染获取 &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">在此示例中，基于传递到您的&lt;a href=&quot;relay-environment&quot;&gt;Relay Environment中&lt;/a&gt;的相同源创建检查器对象。以后，您可以使用此检查器对象检查记录。Inspector仅在开发版本中可用。</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">在此示例中，渲染图像的 &lt;code&gt;width&lt;/code&gt; 将始终与用于获取 &lt;code&gt;profilePicture.uri&lt;/code&gt; 当前版本的 &lt;code&gt;$size&lt;/code&gt; 变量相对应。</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">在此示例中，将在 &lt;code&gt;this.props.ship&lt;/code&gt; 上提供与 &lt;code&gt;ship&lt;/code&gt; 片段关联的字段。</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">在此示例中，每当提取 &lt;code&gt;Parent&lt;/code&gt; 时，还将提取 &lt;code&gt;Child&lt;/code&gt; 的片段。渲染时， &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; 将只能访问 &lt;code&gt;props.foo.id&lt;/code&gt; 字段；来自子片段的数据将被&lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;屏蔽&lt;/em&gt;&lt;/a&gt;。默认情况下， &lt;code&gt;childFragment&lt;/code&gt; 将使用其相应的初始变量。中继将获取 &lt;code&gt;photo(size: 64)&lt;/code&gt; 。当 &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; 被呈现它也将提供作为初始变量 &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">在这个例子中,每当加载一个新尺寸的图片时,就会显示一个微调器来代替图片。</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">在此特定示例中， &lt;code&gt;LikeButton&lt;/code&gt; 关心的唯一字段是 &lt;code&gt;viewerDoesLike&lt;/code&gt; 。该字段将构成跟踪查询的一部分，Relay将与该跟踪查询与 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 的胖查询相交，以确定要请求哪些字段作为服务器响应突变的一部分。应用程序中其他位置的另一个组件可能会对&amp;ldquo;关注者人数&amp;rdquo;或&amp;ldquo;喜欢的句子&amp;rdquo;感兴趣。由于这些字段将自动添加到Relay的跟踪查询中，因此 &lt;code&gt;LikeButton&lt;/code&gt; 不必担心显式请求它们。</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">在本教程中，我们将使用GraphQL突变构建游戏。游戏的目标是在9个正方形的网格中找到隐藏的宝藏。我们将给玩家三种尝试来寻找宝藏。这应该使我们对中继进行端到端的研究-从服务器上的GraphQL模式到客户端上的React应用程序。</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">通过以下步骤对您的Relay Classic应用进行升级。</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">可注入式自定义字段处理程序</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">内联片段</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">内联在GraphQL查询的价值，用GraphQL评论潜在的注释（即 &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;relay-modern&quot;&gt;入门指南中&lt;/a&gt;安装最新版本的Relay 。</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">集成选项可用于开源路由库,而是可以并行地获取嵌套路由的数据。在许多这样的情况下,使用批处理网络层可以带来额外的好处,避免发送多个HTTP请求。</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">可通过&lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt;与React Classic v2或v3的Relay Classic集成，这将聚合对匹配路由的查询，并并行请求所有路由的数据。</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">现代继电器简介</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">还假定读者已经熟悉&lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;&amp;ldquo;星球大战&amp;rdquo;&lt;/a&gt; ; 如果不是的话，1977年版的《星球大战》是一个很好的起点，尽管1997年特别版将用于本文档。</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">假定读者已经熟悉GraphQL；如果不是，那么&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt;的README 是一个不错的起点。</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">它返回一个 &lt;code&gt;Disposable&lt;/code&gt; ，您可以在其上调用 &lt;code&gt;dispose()&lt;/code&gt; 来取消刷新。</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">JavaScript环境要求</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">用于定义数据之间的连接和突变的JavaScript助手,与Relay平滑集成。</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">请记住，创建在多个容器之间共享的单个片段通常被视为&lt;strong&gt;反模式&lt;/strong&gt;。滥用此指令可能会导致应用程序过度获取。</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">在我们的下一个指南&lt;a href=&quot;guides-ready-state&quot;&gt;Ready State中&lt;/a&gt;学习如何使用 &lt;code&gt;onReadyStateChange&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">让我们把刚才创建的突变与根突变类型联系起来。</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">让我们对上面的 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 示例做出乐观的回应：</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">让我们通过一个由上方组成 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 组件来探索其工作原理。</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">让我们通过上面组成 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 组件来探索它的工作原理。</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">让我们看看一些产品用例,了解我们是如何将这些想法融入到Relay中的。我们将假设对React有基本的熟悉。</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">让我们打开启动包的模式,用我们刚刚创建的数据库导入替换。</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">我们来看看这个操作,查询叛军的ID。</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">让我们以&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;为基础开始一个项目。</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">我们带着叛军,向他们要第一艘船。</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">让我们调整文件 &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; ，将我们的游戏锚定到架构的 &lt;code&gt;game&lt;/code&gt; 根字段：</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">采用BSD授权许可。</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">像 &lt;code&gt;updater&lt;/code&gt; 一样，不需要为简单的突变（字段更改）提供 &lt;code&gt;optimisticUpdater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">就像可以使用&lt;a href=&quot;guides-containers&quot;&gt;Relay容器一样&lt;/a&gt;，我们可以基于先前的变量和运行时环境，准备供变量的片段生成器使用的变量。</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">像大多数中继API一样，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;尝试在将请求发送到服务器之前使用客户端存储解析数据。如果相反，即使客户端上有可用数据，我们也想强制服务器请求，则可以使用 &lt;code&gt;forceFetch&lt;/code&gt; 布尔属性。</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">像GraphQL URI一样,超时和重试行为可以被配置。</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">管理异步状态转换和协调并发请求。</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">管理错误;</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">将Relay Classic应用迁移到Relay Modern,不需要从头开始重新编写。相反,每次只需将一个组件转换为Relay Modern API,同时继续保持应用程序的正常运行。一旦所有组件都转换完毕,就可以使用更小更快的Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">将Relay Classic应用迁移到Relay Modern,不需要从头开始重新编写。相反,您可以一次将一个组件转换为Relay Modern API,同时继续保持应用程序的正常运行。一旦所有组件都转换完毕,就可以使用更小更快的Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">迁移到现代继电器</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">现代 &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">分页容器中的现代 &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">现代组件</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">现代突变</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">现代运行时</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">现代： &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; 在Refetch容器中</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">现代：分页容器中的 &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">大多数应用程序将创建一个环境实例并在整个过程中使用它。然而,在特定情况下,您可能希望为不同的目的创建多个环境。例如,每当用户登录或退出时,您可能会创建一个新的环境实例,以防止不同用户的数据被一起缓存。同样,一个服务器渲染的应用程序可能会在每个请求中创建一个新的环境实例,这样每个请求都会得到自己的缓存,用户数据不会重叠。另外,你可能在一个大的应用中拥有多个产品或功能,你希望每个产品都有特定的网络处理或缓存。</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">必须是有效的 &lt;code&gt;RelayContainer&lt;/code&gt; 。中继将在呈现数据之前尝试满足其数据要求。</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">突变道具</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">突变器配置</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">嵌套路线</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">具有中继数据依赖性的嵌套路由会带来额外的复杂性。尽管可以为每个路由呈现 &lt;code&gt;QueryRenderer&lt;/code&gt; ，但在通常情况下，父路由只有在可用父路由的数据可用之前才呈现其子路由，这样会导致请求瀑布。通常，这会导致为页面加载数据带来不必要的额外延迟，但对于小型应用程序或浅层路由树的应用程序可能是可接受的。</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">网络层</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">网络层</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">切勿直接 &lt;code&gt;this.props.relay.variables&lt;/code&gt; ，因为它不会触发正确获取数据。像对待 &lt;code&gt;this.props.relay.variables&lt;/code&gt; 一样，将this.props.relay.variables视为不可变的。</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">现代继电器的新产品</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">接下来，安装编译器（通常是 &lt;code&gt;devDependency&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">接下来，让我们在 &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; 中创建一个文件，并创建 &lt;code&gt;Relay.Mutation&lt;/code&gt; 的子类，称为 &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; ,以保存我们的突变实现：</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">接下来,让我们定义一个节点接口和类型。我们只需要提供一种方式,让Relay从一个对象映射到与该对象相关联的GraphQL类型,以及从一个全局ID映射到它所指向的对象。</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">接下来,让我们定义一下我们的游戏和隐藏点类型,以及每个类型上可用的字段。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">无路由</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">请注意， &lt;code&gt;ready&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 将继续为假。</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">请注意，&lt;em&gt;强烈&lt;/em&gt;建议 &lt;code&gt;Relay.Container&lt;/code&gt; 定义自己的片段，并避免在容器或文件之间共享内联 &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; 值。如果您发现自己想要共享内联片段，则可能表明该是重构和引入新容器的时候了。</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">请注意，此方法需要对服务器的&lt;em&gt;n + 1个&lt;/em&gt;请求：1提取列表，&lt;em&gt;n&lt;/em&gt;提取每个项目。使用GraphQL，我们可以在对服务器的单个网络请求中获取相同的数据（而无需创建随后必须维护的自定义端点）：</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">请注意，这是一个帮助您入门的基本示例。该示例可以使用其他功能扩展，例如请求/响应缓存（例如，在 &lt;code&gt;cacheConfig.force&lt;/code&gt; 为false 时启用）以及上载表单数据以进行变异（ &lt;code&gt;uploadables&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">请注意,这种归一化的缓存结构允许重叠的结果被缓存而不重复。每条记录无论如何获取,都只存储一次。让我们回到前面那个数据不一致的例子,看看这个缓存在这种情况下有什么帮助。</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">请注意，该解决方案也适用于&lt;em&gt;写入&lt;/em&gt;：对缓存的任何更新都会通知受影响的视图，而写入只是更新缓存的另一件事。</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">请注意，组成片段时，组成的片段的类型必须与嵌入片段的父对象上的字段匹配。例如，将 &lt;code&gt;Story&lt;/code&gt; 类型的片段嵌入到 &lt;code&gt;User&lt;/code&gt; 类型的父级字段中是没有意义的。如果您弄错了，Relay和GraphQL将提供有用的错误消息（如果它们没有帮助，请告诉我们！）。</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">注意:在运行时确定变量值</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">注意：在大多数情况下，有可能依赖于默认的环境单例实例，该实例显示为 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">注意:本方法每个实例只能调用一次。</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">注意,它立即执行下一个任务。Relay管理任务的顺序,以确保正确的操作顺序--调度器不能跳过或重新排序任务,只能决定何时执行下一个任务。</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">请注意，游标是base64字符串。这就是之前的模式：服务器提醒我们这是一个不透明的字符串。我们可以将此字符串作为 &lt;code&gt;after&lt;/code&gt; 参数传递回服务器到 &lt;code&gt;ships&lt;/code&gt; 字段，这将让我们要求在上一个结果中的最后一个之后的下三艘船：</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">注意，我们正在查询的数据&lt;em&gt;可能&lt;/em&gt;由于突变而发生了变化。一个明显的问题是：服务器为什么不能只告诉我们发生了什么变化？答案是：很复杂。GraphQL在&lt;em&gt;任何&lt;/em&gt;数据存储层（或多个源的聚合）上进行抽象，并与任何编程语言一起使用。此外，GraphQL的目标是以对产品开发人员构建视图有用的形式提供数据。</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">现在，Relay将同时获取较大的照片尺寸&lt;em&gt;，&lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; 将知道要渲染它。</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">现在Relay将获取大小为128的照片-但是 &lt;code&gt;Child&lt;/code&gt; 容器不会神奇地知道此变量。我们必须通过传递变量值作为道具来告诉它：</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">现在让我们将这些类型与根查询类型关联起来。</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">现在，让我们仔细看一下 &lt;code&gt;config&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">现在我们已经通过这个教程,让我们深入了解一下构建GraphQL客户端框架的意义,以及这与更传统的REST系统的客户端相比有何不同。</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">现在，我们可以实例化一个 &lt;code&gt;ProfileRoute&lt;/code&gt; 来获取用户 &lt;code&gt;123&lt;/code&gt; 的数据：</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">现在,对以前缓存数据的请求可以立即得到响应,而无需进行网络请求。这是一种提高应用程序感知性能的实用方法。但是,这种缓存方法会造成数据一致性的问题。</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">对象识别</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">在中继容器上， &lt;code&gt;bars&lt;/code&gt; 将是数组而不是对象。</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">另一方面，GraphQL &lt;strong&gt;片段&lt;/strong&gt;声明存在于任何任意类型上的字段。例如，以下片段为&lt;em&gt;某个&lt;/em&gt; &lt;code&gt;User&lt;/code&gt; 获取个人资料图片URI 。</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">一旦你的观点的几个或全部使用 &lt;code&gt;QueryRenderer&lt;/code&gt; ， &lt;code&gt;Store&lt;/code&gt; 从 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 可以与被替换 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 。请记住， &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 和 &lt;code&gt;Store&lt;/code&gt; 不共享任何数据。您可能要推迟此步骤，直到可以同时切换具有大量数据重叠的视图。这一步可以为您的应用解锁性能优势。使用 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 的应用程序可以将持久查询ID而不是完整的查询字符串发送到服务器，以及更优化的数据规范化和处理。</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">一旦将所有组件和变体都转换为可以使用Relay Modern API，就可以转换为 &lt;code&gt;QueryRenderer&lt;/code&gt; 而不是 &lt;code&gt;Relay.Renderer&lt;/code&gt; 或 &lt;code&gt;Relay.RootContainer&lt;/code&gt; 。在大多数情况下，您可以从 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 提供 &lt;code&gt;Store&lt;/code&gt; 作为 &lt;code&gt;environment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">一次将 &lt;code&gt;error&lt;/code&gt; 设置为 &lt;code&gt;Error&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; 设置为true，但是将 &lt;code&gt;stale&lt;/code&gt; 设置为false。</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">一旦与 &lt;code&gt;ready&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 设置为true。</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; 设置为false。</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; ， &lt;code&gt;done&lt;/code&gt; 和 &lt;code&gt;stale&lt;/code&gt; 设置为true。</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">一旦有了环境，就可以将其传递到&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;实例，或通过 &lt;code&gt;commitUpdate&lt;/code&gt; 函数传递给变异（请参见&amp;ldquo; &lt;a href=&quot;mutations&quot;&gt;变异&lt;/a&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">新API背后的主要思想之一是，通过提前进行工作（从应用程序的运行时到构建时），可以提高执行效率。这样，对GraphQL片段的更改需要一个构建步骤来重新生成一组工件。有关&lt;a href=&quot;relay-compiler&quot;&gt;中继编译器的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">一种解决方案是让根组件获取其所有子代的数据。但是，这会引入耦合：对组件的每次更改都将需要更改可能呈现该组件的&lt;em&gt;任何&lt;/em&gt;根组件，并且经常更改它与根之间的某些组件。这种耦合可能意味着更大的错误机会并减慢了开发速度。最终，这种方法没有利用React的组件模型。指定数据依赖关系的自然位置是&lt;em&gt;components&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">上面的示例中剩下一件事&amp;ndash;实现 &lt;code&gt;setSize()&lt;/code&gt; ，当滑块值更改时，应该更改照片的大小。除了将每个查询的结果传递给组件之外，Relay还提供了一个具有中继特定方法和元数据的 &lt;code&gt;relay&lt;/code&gt; 道具。其中包括 &lt;code&gt;variables&lt;/code&gt; （用于获取当前 &lt;code&gt;props&lt;/code&gt; 的活动变量 &lt;code&gt;setVariables()&lt;/code&gt; 和setVariables（）（可用于请求不同变量值的数据的回调）。</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">呈现组件时， &lt;code&gt;this.props&lt;/code&gt; 在this.props中填充这些片段指定的字段。这确保了组件在其父组件或任何子组件上都没有隐式依赖性。</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">乐观的更新</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">在等待服务器响应突变的同时,优化更新UI。</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">选项1：重新获取应用程序曾经查询过的所有内容。即使这些数据的一小部分实际上会发生变化，我们仍然必须等待服务器执行&lt;em&gt;整个&lt;/em&gt;查询，等待下载结果，然后再次处理它们。这是非常低效的。</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">选项2：仅重新获取主动呈现的视图所需的查询。这是对的选择。然而，该缓存数据略有好转&lt;em&gt;不是&lt;/em&gt;当前正在查看将不会被更新。除非将此数据以某种方式标记为过期或从缓存中清除，否则后续查询将读取过时的信息。</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">选项3：重新获取固定的字段列表，这些字段在突变后&lt;em&gt;可能会&lt;/em&gt;发生变化。我们将此列表称为&lt;strong&gt;繁琐的查询&lt;/strong&gt;。我们发现这也是低效的，因为典型的应用程序仅呈现胖查询的子集，但是这种方法将需要获取所有这些字段。</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">选项4（中继）：重新获取可能发生变化的内容（繁琐的查询）与缓存中的数据的交集。除了缓存数据外，Relay还记得用于提取每个项目的查询。这些称为&lt;strong&gt;跟踪查询&lt;/strong&gt;。通过与跟踪查询和胖查询相交，Relay可以准确查询应用程序需要更新的信息集，仅此而已。</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">可选择在全球范围内安装</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">（可选）跟进对 &lt;code&gt;commit()&lt;/code&gt; 的调用，以将突变发送到服务器。</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">（可选）在调用 &lt;code&gt;applyOptimistic()&lt;/code&gt; 之前，将更新乐观地应用于商店。</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">或者这样,结果一样。</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">重写&lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">覆盖片段变量</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">分页容器</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 插件应在其他插件或预设之前运行，以确保正确转换 &lt;code&gt;graphql&lt;/code&gt; 模板文字。请参阅&lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;有关此主题的&lt;/a&gt; Babel 文档。</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">请注意，这将替换&lt;a href=&quot;guides-babel-plugin&quot;&gt;旧的Babel Relay插件&lt;/a&gt;。不必同时包含两个插件。</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">填充缓存</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">填充缓存涉及遍历分层的GraphQL响应以及创建或更新规范化的缓存记录。乍一看来，仅响应就足以处理响应，但是实际上，这仅适用于非常简单的查询。考虑 &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash;我们应该如何存储 &lt;code&gt;photo&lt;/code&gt; ？将 &lt;code&gt;photo&lt;/code&gt; 用作缓存中的字段名称将不起作用，因为不同的查询可能会获取相同的字段但参数值不同（例如 &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ）。分页也会发生类似的问题。如果我们获取包含 &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; 的第11到第20个故事，则这些新结果应&lt;em&gt;附加&lt;/em&gt;到现有列表中。</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">处理模式</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">属性和方法</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">查询与片段</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">查询命名惯例</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">查询渲染器</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">排队突变,避免竞赛条件。</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">快速入门</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">React Native配置</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">React Router</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React和Relay支持通过&lt;em&gt;合成来&lt;/em&gt;创建任意复杂的应用程序。可以通过组合较小的组件来创建较大的组件，从而帮助我们创建模块化，强大的应用程序。在Relay中组成组件有两个方面：</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">React组件类可能具有通常通过&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;访问的方法。由于Relay将这些组件实例组成一个容器，因此您需要使用 &lt;code&gt;componentRef&lt;/code&gt; 属性来访问它们：</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">从高速缓存读取</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">通过字段名和代表预定义参数值的对象读取记录上的属性值。</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">准备状态</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">准备状态变化</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">重取数据(也就是 &quot;查看更多&quot;)。</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">相关API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">中继经典API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">接力经典指南</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">中继经典接口</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">继电器兼容性</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat是 &lt;code&gt;'react-relay'&lt;/code&gt; 一部分，它使您能够做到这一点，为Relay Modern提供相同的API，同时允许与两个运行时互操作。</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">继电器编译器</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">中继容器</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools是一款旨在帮助开发人员检查他们的Relay状态并了解商店如何随时间变化的工具。Relay DevTools以两种方式发布。</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">中继文件</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">中继环境</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">现代中继</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern附带了基于GraphQL模式为中继容器中使用的片段自动生成流类型的功能。通过确保考虑所有可能的 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 情况（即使它们不经常发生），使用这些Flow类型可以帮助降低应用程序的错误率。</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Relay Modern容器将标准React组件与其数据要求的描述结合在一起，以一个或多个GraphQL片段表示。每个容器本身就是一个标准的React组件，可以使用标准的React API来呈现（例如 &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ）。呈现后，容器将从中继缓存中读取其片段的数据。随着片段数据的变化（例如，由于突变，订阅或更新的查询响应），容器将自动重新呈现组件。</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern支持多种新功能。有些可以通过Compat API获得，而另一些则需要完全升级到Modern运行时。有关更多详细信息，请参见&lt;a href=&quot;new-in-relay-modern&quot;&gt;Relay Modern中的新增功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern是Relay的新版本,它的设计从头开始,更容易使用,更可扩展,而且最重要的是,能够提高移动设备的性能。Relay Modern通过静态查询和超前的代码生成实现了这一点。</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern需要一个Babel插件来将GraphQL转换为运行时工件。</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern支持GraphQL订阅,使用必要的更新API,允许在收到有效载荷时对存储进行修改。它还具有通过轮询对GraphQL实时查询的实验性支持。</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modern支持以下指令</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern使用Relay编译器将 &lt;code&gt;graphql&lt;/code&gt; 文字转换为与源文件一起存在的生成文件。</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Relay Modern的超前编译需要新的Relay编译器。</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Relay Modern的核心本质上是一个GraphQL数据的非opinionated存储。它可以独立于使用React渲染视图,并可以扩展到与其他框架一起使用。</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">继电器规格</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">中继允许开发人员通过创建&lt;strong&gt;容器&lt;/strong&gt;来注释其React组件与数据的依赖关系。这些是包装原始文档的常规React组件。一个关键的设计约束是React组件可以重用，因此Relay容器也必须是可重用的。例如， &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 组件可能实现用于呈现任何 &lt;code&gt;Story&lt;/code&gt; 项目的视图。要呈现的实际故事将由传递给组件的数据确定： &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; 。 GraphQL中的等效项是&lt;strong&gt;片段&lt;/strong&gt;：命名查询片段，用于指定要&lt;em&gt;为给定类型的对象&lt;/em&gt;获取哪些数据。我们可以如下描述 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 所需的数据：</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">中继也走得更远：它在 &lt;code&gt;props&lt;/code&gt; 上使用不透明标识符，以验证我们在呈现组件之前已明确获取了组件的数据。如果 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 呈现了 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; ,但忘记了包含其片段，Relay将警告 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 的数据丢失。实际上，&lt;em&gt;即使&lt;/em&gt;某些其他组件碰巧获取了 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 所需的相同数据，Relay也会发出警告。这个警告告诉我们，尽管事情现在&lt;em&gt;可能会&lt;/em&gt;奏效，但以后很有可能会崩溃。</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">Relay还可以让我们完全取代默认的网络层。</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">Relay可以被认为是两个共同工作的部分:一个是用于构建数据驱动组件的API,另一个是用于从GraphQL中获取和存储数据以填充您的应用程序的运行时。Relay Modern同时带来了新的API和新的运行时。</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">中继容器是使用 &lt;code&gt;Relay.createContainer&lt;/code&gt; 创建的。</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">中继容器是高阶组件&amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; 是一个函数，该函数将React组件作为输入，并返回一个新组件作为输出。这意味着容器可以管理数据获取和解析逻辑，而不会干扰内部组件的 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">中继容器提供了静态的 &lt;code&gt;getFragment()&lt;/code&gt; 方法，该方法返回对该组件片段的引用：</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">Relay将React与GraphQL结合起来,并进一步发展了封装的思想。它允许组件指定它们需要的数据,而Relay框架提供数据。这使得内部组件的数据需求变得不透明,并允许对这些需求进行组合。思考一个应用需要什么数据变得本地化到组件上,使得推理哪些字段需要或不再需要变得更容易。</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">Relay确保这些数据在组件渲染之前就可以使用。</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">Relay提供以下API来创建订阅。</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Relay公开了以下API来执行突变。</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">中继片段，突变和查询必须使用带有 &lt;code&gt;Relay.QL&lt;/code&gt; 标签的ES6模板文字来指定。例如：</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">Relay有一个网络层的抽象,它将突变和查询从向GraphQL服务器发送请求的实际机器中分离出来。这让我们可以灵活地配置甚至通过注入完全取代默认的网络层。</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">中继实现了&lt;strong&gt;查询遍历的&lt;/strong&gt;几种变体：将查询与其他数据（如缓存或响应有效负载）一起&lt;strong&gt;遍历的&lt;/strong&gt;操作。例如，当获取查询时，Relay执行&amp;ldquo; diff&amp;rdquo;遍历以确定缺少哪些字段（非常类似于React diffs虚拟DOM树）。在许多常见情况下，这可以减少获取的数据量，甚至在完全缓存查询时甚至允许Relay完全避免网络请求。</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay引入了两类新的对象： &lt;code&gt;RelayContainer&lt;/code&gt; 和 &lt;code&gt;Relay.Route&lt;/code&gt; 。 &lt;code&gt;Relay.PropTypes&lt;/code&gt; 提供了道具验证器，用于断言道具属于这些类型。</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">中继已预先配置为使用与&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;一起使用的默认网络层。此默认网络层通过 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 公开。</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">中继利用GraphQL突变；使我们能够更改客户端和服务器上的数据的操作。要创建在我们的应用中使用的变体，我们将 &lt;code&gt;Relay.Mutation&lt;/code&gt; 子类化，并至少实现下面列出的四个抽象方法。</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">Relay routes并没有真正实现任何URL路由的特定逻辑,也没有与History API一起工作。在未来,我们也许会将RelayRoute改名为更像RelayQueryRoots或RelayQueryConfig的东西。</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">中继路由实际上并没有实现任何URL路由特定的逻辑，也没有使用History API。将来，我们可能会将RelayRoute重命名为更像RelayQueryRoots或RelayQueryConfig。有关中继为什么不提供URL路由功能的更多信息，以及有关此类解决方案的建议，请参阅&lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">中继通过网络层与GraphQL服务器对话。Relay随附的&lt;a href=&quot;guides-network-layer&quot;&gt;网络层&lt;/a&gt;与现成的express-graphql兼容，并且会随着我们向传输中添加新功能而继续发展。</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">每当基础数据发生变化时,继电器就会更新组件。</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay使用&lt;strong&gt;Babel&lt;/strong&gt;插件将 &lt;code&gt;graphql&lt;/code&gt; 文字转换为对Relay Compiler生成的代码的需求。</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay使用&lt;strong&gt;babel&lt;/strong&gt;插件将 &lt;code&gt;Relay.QL&lt;/code&gt; 字符串模板转换为描述每个查询并包含GraphQL模式数据的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">中继对突变使用一种通用模式，其中它们是具有单个参数 &lt;code&gt;input&lt;/code&gt; 的突变类型的根字段，并且其中输入和输出均包含用于协调请求和响应的客户端突变标识符。</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relay使用所有这些功能来构建围绕连接的抽象,使这些连接易于高效工作,而无需在客户端手动管理游标。</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relay使用路由来定义进入Relay应用的入口点。</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0引入了Relay Modern API。</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">中继将其核心处理功能包装在轻量级任务中，这些任务默认情况下会立即执行（即同步执行）。为了定制&lt;em&gt;当&lt;/em&gt;这些任务运行-例如，以避免触摸手势期间中断的动画-应用程序可以提供自定义调度功能。</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">Relay的数据获取方法在很大程度上得益于我们在React方面的经验。特别是，React将复杂的接口分解为可重用的&lt;strong&gt;组件&lt;/strong&gt;，从而使开发人员可以独立地考虑应用程序的离散单元，并减少应用程序不同部分之间的耦合。更重要的是，这些组件&lt;strong&gt;的声明&lt;/strong&gt;：它们允许开发者指定&lt;em&gt;哪些&lt;/em&gt;用户界面应该看起来像一个给定的状态，而不必操心&lt;em&gt;如何&lt;/em&gt;证明UI。与以前使用命令式命令来处理本地视图（例如DOM）的方法不同，React使用UI描述来自动确定必要的命令。</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relay.PropTypes.QueryConfig:ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer实现一个保守的默认 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ，如果没有片段道具改变并且所有其他道具都是相同的标量值，则返回 &lt;code&gt;false&lt;/code&gt; 。这可能会阻止对通过上下文接收数据的组件的更新。为了确保在这种情况下进行更新，可以通过指定 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 函数来覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">渲染回调</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">渲染容器</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">反复从服务器重新获取信息会变得很慢。例如，从故事列表导航到列表项，然后返回故事列表意味着我们必须重新获取整个列表。我们将使用标准解决方案来解决此问题：&lt;em&gt;缓存&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">申请不同的数据</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">需要从 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 使用Relay Compat API，并像使用Relay Modern一样使用它。使用Relay Compat的组件可以被其他Relay Modern和Relay Classic组件引用。</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">从客户端解析数据</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">响应缓存也可以应用于GraphQL。一个基本的方法与REST版本的工作原理类似。查询本身的文本可以被用作缓存键。</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">检索与给定记录相关联的记录,通过字段名和一个代表预定义参数值的对象来横向检索源。</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">重试失败的请求。</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">Returns a proxy class for manipulating records from a record source,example a query,mutation,or store.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">返回保存所有记录的商店内部RecordSource的只读视图。</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">返回给定记录的GraphQL类型名称。</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">返回一个记录的全局唯一标识符字符串。</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">在上述用例中组成可重复使用的碎片。</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">滚回乐观的的变异。</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">根部容器</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">Route在提供渲染组件所处的上下文时很有用。它包含有关当前路由的 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;params&lt;/code&gt; 和 &lt;code&gt;queries&lt;/code&gt; 的信息。</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">路由和查询</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">路由现在是可选的：可以在不定义路由的情况下使用 &lt;code&gt;QueryRenderer&lt;/code&gt; 。&lt;a href=&quot;routing&quot;&gt;路由指南中有&lt;/a&gt;更多内容。</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">路由是定义一组根查询和输入参数的对象。这是一条简单的路线，可用于呈现用户 &lt;code&gt;123&lt;/code&gt; 的个人资料：</target>
        </trans-unit>
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">路由负责定义进入Relay应用的入口点。但是为了理解为什么需要路由,我们必须先了解GraphQL查询和片段之间的区别。</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">路由可以声明一组需要提供给构造函数的参数名称。这也是一个记录有效参数集的方便地方。</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">路由可以使用 &lt;code&gt;prepareParams&lt;/code&gt; 提供默认参数，或者通过，转换或抑制传入的参数。</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">路由必须使用 &lt;code&gt;Relay.QL&lt;/code&gt; 声明一组查询根。这些查询将在&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;上与该路由一起使用的Relay容器上自动组成一个名为 &lt;code&gt;queryName&lt;/code&gt; 的匹配片段。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">路由必须定义一个字符串名称。</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">路由不再需要了解Relay Modern中的查询根。中继组件可以呈现在 &lt;code&gt;QueryRenderer&lt;/code&gt; 中的任何位置。这将为选择路由框架带来更多的灵活性。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">在您的Relay应用程序中对任何GraphQL进行更改后，运行Relay Compiler。将其添加为 &lt;code&gt;yarn script&lt;/code&gt; 可能会有所帮助。在package.json文件中的 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 中添加一个条目。</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">Schema JSON</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">有关参数对象上可用的方法，请参见&lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">有关参数对象上可用的方法，请参见&lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt;构造函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;容器&amp;gt;中继容器&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;容器&amp;gt;请求其他数据&lt;/a&gt;，&lt;a href=&quot;guides-ready-state&quot;&gt;就绪状态&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;变异&amp;gt;片段变量&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;变异&amp;gt;片段变量&lt;/a&gt;和&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;突变&amp;gt;突变体配置&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;变异&amp;gt;胖查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-ready-state&quot;&gt;就绪状态&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;根容器&amp;gt;组件和路由&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;根容器&amp;gt;强制提取&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;根容器&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;根容器&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;根容器&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-routes&quot;&gt;路线&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅《&lt;a href=&quot;guides-mutations&quot;&gt;变异指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;guides-network-layer&quot;&gt;网络层指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅《&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;guides-routes&quot;&gt;路线指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">服务器错误</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">设置babel-plugin-relay。</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">设置继电器编译器</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">设置继电器编译器</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">设置babel-plugin-relay。</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">显示更多</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">与React组件的 &lt;code&gt;render&lt;/code&gt; 方法不直接修改本机视图的方式类似，Relay容器也不直接获取数据。相反，容器声明了呈现所需数据的&lt;em&gt;规范&lt;/em&gt;。中继可确保&lt;em&gt;在&lt;/em&gt;渲染&lt;em&gt;之前&lt;/em&gt;此数据可用。</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">更简单的突变API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">由于Relay容器定义的是片段而非查询,因此它们可以轻松地嵌入到多个上下文中。和React组件一样,Relay容器也是高度可重用的。</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">由于一个游戏可以有很多隐藏点,我们需要创建一个连接,我们可以用它把它们连接起来。</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">小包装尺寸</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">到目前为止,我们看了数据提取的低层次方面,并看到了各种熟悉的概念如何转化为GraphQL。接下来,让我们回过头来看看产品开发人员经常面对的一些围绕数据提取的更高层次的问题。</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">到目前为止,我们只是将GraphQL作为典型的REST方法的一个更有效的版本。请注意GraphQL版本中的两个重要好处。</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">到目前为止，我们已经研究了查询数据和保持视图最新的过程，但是还没有研究写入。在GraphQL中，写入称为&lt;strong&gt;突变&lt;/strong&gt;。我们可以将它们视为具有副作用的查询。这是一个调用变异的示例，该变异可能会将给定故事标记为当前用户喜欢的故事：</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">到目前为止,我们已经介绍了两块各自有助于声明数据的内容。</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">因此，对于我们的 &lt;code&gt;introduceShip&lt;/code&gt; 突变，我们创建两种类型： &lt;code&gt;IntroduceShipInput&lt;/code&gt; 和 &lt;code&gt;IntroduceShipPayload&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">那么我们如何使用这个缓存呢？让我们看一下两个操作：接收到响应时写入缓存，以及从缓存中读取以确定查询是否可以在本地实现（与上面的 &lt;code&gt;_cache.has(key)&lt;/code&gt; 等效，但用于图形）。</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">所以现在我们知道了系统中叛军的ID。我们现在可以重新获取他们。</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">所以在第一次查询船舶的时候,GraphQL告诉我们有下一个页面,但是在下一个页面上,它告诉我们已经到了连接的终点。</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">有些字段--尤其是分页数据的字段--可能需要在客户端进行后处理,以便将之前获取的数据与新的信息合并。Relay Modern支持自定义字段处理程序,可用于处理这些字段,以适应各种分页模式和其他用例。</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">有时，父级需要覆盖子级组件的默认变量。想象一下，我们想以128张照片而不是默认的64张照片渲染 &lt;code&gt;Child&lt;/code&gt; ，为此，我们必须确保片段&lt;em&gt;和&lt;/em&gt;容器都知道自定义变量。要在&lt;em&gt;查询中&lt;/em&gt;设置自定义变量，请对 &lt;code&gt;getFragment&lt;/code&gt; 使用第二个参数：</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">源文件</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">将`Relay.Container`的数据依赖关系指定为GraphQL片段。</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">在`Relay.Mutation`中指定突变领域。</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">指定`Relay.Route`的查询。</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">从 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 模块（ &lt;code&gt;createFragmentContainer&lt;/code&gt; ， &lt;code&gt;createRefetchContainer&lt;/code&gt; ， &lt;code&gt;createPaginationContainer&lt;/code&gt; ， &lt;code&gt;commitMutation&lt;/code&gt; ）开始转换组件和变体以使用Relay Modern API 。从叶组件开始向上比较容易。该&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;转换脚本&lt;/a&gt;应该走这一步不那么单调乏味。</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">静态方法</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">步骤0:安装Relay v1.0</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">步骤1:逐步转换为继电器兼容性</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">步骤2：介绍&amp;lt;QueryRenderer&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">第三步:引入Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">第四步:清理,将Relay Compat更换为Relay Modern。</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">围绕突变的结构,使其可预测。</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在兼容和现代模式下均受支持。使用分页容器时，Relay希望使用 &lt;code&gt;@connection&lt;/code&gt; 指令注释连接字段，有关更多详细信息和示例，请转到&lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在经典，兼容和现代模式下受支持。详细用法在&lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; 中进行了&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">真棒!让我们继续前进,并得到下一个四!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">将应用中的 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 引用切换为 &lt;code&gt;'react-relay'&lt;/code&gt; 。这更多是一个清理步骤，可防止您的应用提取不必要的 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">该输入参数应包含（字符串）&amp;ldquo; clientMutationId&amp;rdquo;属性，以协调请求和响应（由 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API 自动添加）。</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">所使用的 &lt;code&gt;first&lt;/code&gt; 参数 &lt;code&gt;ships&lt;/code&gt; 切片结果集到的第一个。但是，如果我们想分页怎么办？在每个边缘上，将显示一个游标，可用于分页。这次让我们询问前两个，并获取光标：</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Node&lt;/code&gt; 接口和&amp;ldquo; &lt;code&gt;node&lt;/code&gt; 字段为此重新假定使用全局唯一的ID。没有全局唯一ID的系统通常可以通过将类型与特定于类型的ID相结合来合成它们，这就是本例中所做的。</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">该 &lt;code&gt;Node&lt;/code&gt; 接口只包含一个领域， &lt;code&gt;id&lt;/code&gt; ，这是一个 &lt;code&gt;ID!&lt;/code&gt; 。的 &lt;code&gt;node&lt;/code&gt; 根字段接受一个参数，一个 &lt;code&gt;ID!&lt;/code&gt; ，并返回一个 &lt;code&gt;Node&lt;/code&gt; 。这两个协同工作以允许重新引用；如果我们将在该字段中返回的 &lt;code&gt;id&lt;/code&gt; 传递给 &lt;code&gt;node&lt;/code&gt; 字段，我们将获得该对象。</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">该 &lt;code&gt;applyUpdate&lt;/code&gt; 增加了一个突变就像 &lt;code&gt;update&lt;/code&gt; ，但没有提交。它返回可以提交或回滚的 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 必须运行之前 &lt;code&gt;react-native&lt;/code&gt; 通天预设。因此，在 &lt;code&gt;.babelrc&lt;/code&gt; 中, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 必须在 &lt;code&gt;babelRelayPlugin&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">该 &lt;code&gt;commitUpdate&lt;/code&gt; 方法类似于在调度磁通的动作。中继对突变的处理如下：</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">该 &lt;code&gt;react-relay&lt;/code&gt; NPM模块包括 &lt;code&gt;react&lt;/code&gt; 作为&lt;em&gt;对等体依赖性&lt;/em&gt;。您的应用程序应明确指定React作为依赖项。</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">该 &lt;code&gt;relay-compiler&lt;/code&gt; 脚本既需要保持你的源文件，以及作为一个通道，你GraphQL模式在任何一个以.json或.graphql架构文件的目录。</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;renderFailure&lt;/code&gt; 回调调用与两个参数：一个 &lt;code&gt;Error&lt;/code&gt; 对象和重试请求的功能。如果错误是服务器响应中传达的服务器错误的结果，则可以在 &lt;code&gt;error.source&lt;/code&gt; 上检查响应有效负载。</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;renderFetched&lt;/code&gt; 回调总是调用一个 &lt;code&gt;data&lt;/code&gt; 参数，它是一个对象映射从 &lt;code&gt;propName&lt;/code&gt; 到查询数据。期望 &lt;code&gt;renderFetched&lt;/code&gt; 回调使用它们来渲染提供的 &lt;code&gt;Component&lt;/code&gt; （例如，使用&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX传播属性功能&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">API整体上更简单,更可预测。</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">包含连接的父节点的DataID。这个参数是可选的。</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">我们返回的ID是base64字符串。ID被设计为不透明的（应该传递给 &lt;code&gt;node&lt;/code&gt; 上 &lt;code&gt;id&lt;/code&gt; 参数的唯一事情是查询系统中某个对象的 &lt;code&gt;id&lt;/code&gt; 的不变结果），并且在GraphQL中base64字符串是一个有用的约定，以提醒查看者字符串是不透明的标识符。</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">接力赛 &quot;环境&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relay &quot;环境 &quot;将Relay运行所需的配置、缓存存储和网络处理捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">接力&amp;ldquo;环境&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">中继 &lt;code&gt;Store&lt;/code&gt; 提供了一个API，用于将变异发送到服务器。</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay Classic和Relay Compat模式可在线生成内容,并可捕获和记录任何检测到的GraphQL验证错误,让这些错误在运行时被抛出。</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">Relay编译器负责生成代码,作为构建步骤的一部分,在运行时可以静态使用。通过提前构建查询,客户端的JS运行时不需要负责生成查询字符串,而且在构建步骤中可以合并查询中重复的字段,以提高解析效率。如果你有能力将查询持久化到服务器上,编译器的代码生成过程提供了一个方便的时间,将查询或突变的文本转换为唯一的标识符,这大大减少了上传所需的字节数。</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Core增加了对客户端模式扩展的支持。这些扩展允许Relay方便地将一些额外的信息与从服务器获取的数据一起存储,并像其他从服务器获取的字段一样进行渲染。这应该能够取代一些以前需要在侧面存储Flux/Redux的用例。</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPM上发布的Relay Modern包使用了广泛支持的ES5版本的JavaScript,以支持尽可能多的浏览器环境。</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">中继网络层</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">Relay运行时捆绑的规模大约是Relay Classic的20%。</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">在高级边缘情况下,当优化更新需要更精细的控制时,可以对Relay存储进行程序化突变。以下API方法对突变您的连接和碎片很有用。</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">这个故事的作者也对此进行了评论-很常见。现在，假设其他视图正在获取有关作者的新信息，并且她的个人资料照片已更改为新的URI。这里是&lt;em&gt;唯一&lt;/em&gt;改变我们的缓存数据的一部分：</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">现在最好的入门方法是看一下这三个部分是如何结合在一起形成一个有效的示例的。下一页的教程将使用&lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;引导您完成一个示例应用程序，以使您了解如何开始在自己的继电器上使用Relay。</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">客户端和服务器是分离的：客户端指定所需的数据，而不是&lt;em&gt;依靠&lt;/em&gt;服务器端点返回正确的数据。</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4的基于组件的方法无法轻松地汇总嵌套路由的数据需求，因此，也无法轻易地避免避免嵌套 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件的请求瀑布的方法。</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">名为 &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; 进行调试的容器将从本地存储中检索每个GraphQL片段的响应。</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">容器将每个片段的结果（以及其他属性）传递到 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">默认的实现方式如下:</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">我们在这里指定的默认值将对我们的片段构建器可用。</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">目前，最简单的入门方法是使用&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;中继入门工具包&lt;/a&gt; -该工具包包括一个示例架构文件，并将&lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npm模块配置为可转换查询。</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">上面的示例没有配置 &lt;code&gt;handlerProvider&lt;/code&gt; ，这意味着将提供默认值。 Relay Modern附带了一些内置的处理程序，这些处理程序通过用于处理连接的特殊功能扩展了内核（这不是标准的GraphQL功能，而是Facebook使用的一组分页约定，详细信息在&lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification中&lt;/a&gt;，并由Relay本身很好地支持）和 &lt;code&gt;viewer&lt;/code&gt; 字段（同样，不是标准的GraphQL模式功能，而是Facebook内部常规使用的功能）。</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">上面的示例与经典容器API非常相似，但是在现代API中，我们可以直接将 &lt;code&gt;graphql&lt;/code&gt; 模板文字作为第二个参数直接传递。中继将根据片段命名约定 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 从片段名称推断prop名称。下面的示例与上面的示例等效：</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">脂肪查询</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">响应中包含被删除节点的DataID的字段名。</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">响应中的字段名,包含被移除节点的DataID,或从连接中移除的节点的路径。</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">响应中代表连接的字段名。</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">响应中代表新创建的边缘的字段名。</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">响应中代表连接父体的字段名。</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">最后的数据声明相当于下面的普通GraphQL。</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">第一次查询的是一个故事清单。</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">该组件的片段可用的初始变量值集。</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">最常用的函数是&lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt;，它使用数据声明包装组件。</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">突变应该接受一个名为 &quot;输入 &quot;的单一参数。</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">新的Relay Modern核心比之前的版本更加轻量级,速度也明显加快。它经过重新设计,可与静态查询配合使用,使我们能够将更多的工作推向构建/编译时间。由于去掉了很多动态查询所需的复杂功能,Modern core的体积更小。新的内核在处理响应时也快了一个数量级,它采用了在构建时生成的优化解析指令集。我们不再将动态查询生成所需的跟踪信息保留在周围,这大大降低了使用Relay的内存开销。这意味着有更多的内存可以用来制作UI的响应速度。Relay Modern还支持持久化查询,将请求的上传大小从完整的查询文本减少到一个简单的id。</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">下一个逻辑方法是使用 &lt;code&gt;render()&lt;/code&gt; 作为启动数据获取的方式。我们可以只对应用程序进行一次渲染，查看它需要什么数据，获取该数据，然后再次渲染。这听起来不错，但问题在于&lt;em&gt;组件使用数据来找出要渲染的内容！&lt;/em&gt;换句话说，这将强制进行数据获取：首先渲染根并查看其需要什么数据，然后渲染其子节点并查看它们到底需要什么，一直到树下。如果每个阶段都引发网络请求，则渲染将需要缓慢的串行往返。我们需要一种方法来预先确定或&lt;em&gt;静态&lt;/em&gt;确定所有数据需求。</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">根据 &lt;code&gt;Relay.Mutation&lt;/code&gt; API ，可选的 &lt;code&gt;config&lt;/code&gt; 参数可用于配置 &lt;code&gt;RANGE_ADD&lt;/code&gt; 或其他类型的突变。这告诉中继如何处理响应。</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">可选的 &lt;code&gt;config&lt;/code&gt; 参数可用于配置 &lt;code&gt;RANGE_ADD&lt;/code&gt; 或其他类型的突变，类似于 &lt;code&gt;Relay.Mutation&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">上面列出的选项并不详尽。如果您知道其他适用于Relay Modern的路由解决方案，&lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;请告知我们&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">分页容器希望使用 &lt;code&gt;@connection(key: ...)&lt;/code&gt; 指令对连接字段进行注释，其中该 &lt;code&gt;key&lt;/code&gt; 是父字段类型 &lt;code&gt;User&lt;/code&gt; 下的唯一标识符。一个好的做法是 &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。默认情况下，Relay根据用户提供的 &lt;code&gt;key&lt;/code&gt; 和该字段的所有非过滤器变量生成存储密钥。中继还提供了一个高级功能 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; ，可让您明确指定应使用哪些变量来生成存储密钥。特别是，如果您编写 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; ，Relay将忽略所有变量。</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">插件需要了解您的架构- 以上代码段中的 &lt;code&gt;schemaData&lt;/code&gt; 。有两种获取此信息的方法，具体取决于GraphQL的实现。</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">这个例子的前提是,我们要使用GraphQL来查询《星球大战》原版三部曲中的舰船和派系信息。</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">声明数据需求的主要方式是通过 &lt;code&gt;Relay.Container&lt;/code&gt; -一种高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">声明数据需求的主要方法是通过 &lt;code&gt;createFragmentContainer&lt;/code&gt; -一种高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">可以从包装 &lt;code&gt;this.props.relay&lt;/code&gt; React组件的this.props.relay访问以下列出的属性和方法。</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">查询应该要求 &quot;clientMutationId &quot;作为一个子选择。</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">原因是，如果 &lt;code&gt;babel-plugin-relay&lt;/code&gt; 在 &lt;code&gt;es2015-template-literals&lt;/code&gt; 转换之前未运行，则不会正确转换Relay.QL模板文字。同样在Babel 6中，您无法控制插件顺序。因此，在React Native中， &lt;code&gt;.babelrc&lt;/code&gt; 中的插件在项目 &lt;code&gt;.babelrc&lt;/code&gt; 之前加载。要使用Babel Relay插件，就必须覆盖整个转换列表。</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">运行时自动删除不再引用的缓存数据,有助于减少内存使用。</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下面描述的模式将用于演示Relay使用的GraphQL服务器应实现的功能。这两个核心类型是派系和&amp;ldquo;星球大战&amp;rdquo;宇宙中的一艘船，派系中有许多与之相关的船。下面的模式是GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt;的输出。</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">第二个查询则是重新检索其中一个故事的信息。</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">缓存GraphQL的解决方案是将层次响应标准化为平坦的&lt;strong&gt;记录&lt;/strong&gt;集合。中继将此缓存实现为从ID到记录的映射。每个记录都是从字段名称到字段值的映射。记录也可以链接到其他记录（允许它描述循环图），并且这些链接被存储为引用回顶级映射的特殊值类型。通过这种方法，每个服务器记录都存储&lt;em&gt;一次，&lt;/em&gt;无论如何获取。</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">此处的&amp;ldquo;变量&amp;rdquo;一词是指服务器端突变的输入，&lt;strong&gt;而不是&lt;/strong&gt;指可用于此突变的片段构建器的变量。</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Relay对GraphQL服务器的三个核心假设是,它提供。</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">两种方法的不同之处在于， &lt;code&gt;forceFetch&lt;/code&gt; 不会发送仅包含客户端缺少的字段的查询，而是发送请求以重新获取每个片段。这样可以确保从服务器中新获取组件的道具。</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; 场的值已更改；因此，记录 &lt;code&gt;2&lt;/code&gt; 也已更改。就是这样。&lt;em&gt;缓存中的&lt;/em&gt;其他内容均不受影响。但是很明显，我们的&lt;em&gt;观点&lt;/em&gt;需要反映更新：UI中的两个作者实例（分别是故事作者和评论作者）都需要显示新照片。</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">然后，在对应用程序文件进行编辑后，只需运行 &lt;code&gt;yarn run relay&lt;/code&gt; 以生成新文件，或 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; 作为长期存在的进程来运行编译器，该进程将在您保存时自动生成新文件。</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">然后，在对您的应用程序文件进行编辑之后，运行 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; 生成新文件，或者运行 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; 将编译器作为一个长期运行的进程运行，只要您保存，它就会自动生成新文件。</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">然后按照之前的步骤运行 &lt;code&gt;yarn run relay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">然后，在您的.babelrc文件中的插件列表中添加 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">有多种解决方案可通过平缓的缓存使视图保持最新状态。 Relay采取的方法是维护从每个UI视图到其引用的ID集的映射。在这种情况下，故事视图将订阅故事（ &lt;code&gt;1&lt;/code&gt; ），作者（ &lt;code&gt;2&lt;/code&gt; ）和评论（ &lt;code&gt;3&lt;/code&gt; 和其他任何内容）的更新。将数据写入缓存时，中继会跟踪受影响的ID，并&lt;em&gt;仅&lt;/em&gt;通知已订阅这些ID的视图。受影响的视图会重新渲染，而未受影响的视图会选择退出重新渲染以获取更好的性能（Relay提供了一个安全但有效的默认值 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ）。没有这种策略，即使是最小的更改，每个视图都会重新呈现。</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">目前只有一个动态地设置一个变量的初始值支持的方法：使用在包括该片段（或通过查询中定义的全局变量 &lt;code&gt;variables&lt;/code&gt; 上的 &lt;code&gt;QueryRenderer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">因此，用于GraphQL的规范化响应缓存需要并行处理有效负载和查询。例如，上面的 &lt;code&gt;photo&lt;/code&gt; 字段可能会与生成的字段名称（例如 &lt;code&gt;photo_size(32)&lt;/code&gt; )一起缓存，以便唯一地标识该字段及其参数值。</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">这些是容器将在普通React组件中作为 &lt;code&gt;this.props.relay&lt;/code&gt; 提供的方法和属性。</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">这些功能可以用在几个常见的场景中:记录客户端状态以便以后检查,或者从浏览器的调试器中交互式地探查商店。</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">思考接力</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">用GraphQL思考</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">当数据解析的各种事件发生时,这个回调道具被调用。</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">这个回调道具在数据解析的各种事件发生时被调用。</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">可以通过有条件地呈现&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;进行升级，该QueryRenderer将在呈现数据后加载数据。新的API大大减少了这样做的代码开销。</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">可以使用&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; 对其&lt;/a&gt;进行升级，该RefetchContainer允许您指定用于获取新数据的确切查询。</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">这将导致生成的文件出现在 &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; ，同时具有运行时工件（有助于从中继存储读取和写入）和&lt;a href=&quot;https://flow.org/&quot;&gt;Flow类型&lt;/a&gt;以帮助您编写类型安全的代码。</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">这个例子展示了所有这三个假设。</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">这个例子并不全面,但它的目的是为了快速介绍这些核心假设,在深入研究更详细的库规范之前提供一些背景。</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">此胖查询看起来与任何其他GraphQL查询一样，但有一个重要区别。我们知道其中一些字段是非标量的（例如 &lt;code&gt;friendEdge&lt;/code&gt; 和 &lt;code&gt;friends&lt;/code&gt; ），但是请注意，我们还没有通过子查询来命名它们的任何子级。这样，我们向中继指示，由于这种突变，那些非标量字段下的&lt;em&gt;任何内容都&lt;/em&gt;可能发生变化。</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">这将被转换成一个生成文件的 &quot;懒惰 &quot;需求。</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">这就会被转换成一个立即调用的函数。</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">这会将bin脚本 &lt;code&gt;relay-compiler&lt;/code&gt; 安装在node_modules文件夹中。建议从yarn / npm脚本运行此脚本，方法是将脚本添加到 &lt;code&gt;package.json&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">这是通用重新获取容器的一种特殊化，它针对通过依次获取更多页面的数据来对项目集合进行分页的常见情况而量身定制。有关详细信息，请参见&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">这是到目前为止接收到的事件的数组（请参见下面的 &lt;code&gt;ReadyStateEvent&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果失败，这是 &lt;code&gt;Error&lt;/code&gt; 的一个实例。否则，为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">这只是一个简单的例子:在现实中,缓存必须处理一对多的关联和分页(除此之外)。</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">这是用于创建带有可选 &lt;code&gt;files&lt;/code&gt; ， &lt;code&gt;callbacks&lt;/code&gt; 和 &lt;code&gt;collisionKey&lt;/code&gt; 参数的 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 实例的常规构造函数。</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">这是产品代码可以处理Relay中的突变的最低抽象级别，它对应于&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL规范中&lt;/a&gt;描述的突变操作（&amp;ldquo;先写后取&amp;rdquo;）。您可以指定突变，输入和查询。</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">当&lt;em&gt;所有&lt;/em&gt;数据需求均已准备好呈现时，这是正确的。</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">当渲染所需的数据子集准备就绪时,这是真的。</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">当处理单个组件内的嵌套或递归数据时,这可能有助于减少冗余片段。</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">这个方法可以选择返回一个承诺,以方便正确的错误传播。</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">在应用了 &lt;code&gt;setVariables&lt;/code&gt; 中的部分变量集之后，也会调用此方法。返回的变量用于填充片段。</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">该方法接收一个数组的查询(而不是单个查询),以便于批量查询,提高网络效率。</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">应该将其升级为使用&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">此代码段将&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;配置为在数据准备就绪后立即在 &lt;code&gt;ScrollView&lt;/code&gt; 组件中呈现 &lt;code&gt;ProfilePicture&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">此代码段配置&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;在需要获取数据时呈现&amp;ldquo; Loading ...&amp;rdquo;文本。</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">这将创建一系列 &lt;code&gt;__generated__&lt;/code&gt; 目录，这些目录与包含 &lt;code&gt;graphql&lt;/code&gt; 标签的相应文件位于同一位置。</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">这将通知 &lt;code&gt;Relay.QL&lt;/code&gt; 此特定字段是一个数组。这也将允许您为片段使用复数名称（即， &lt;code&gt;bars&lt;/code&gt; 而不是 &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">这将产生三个生成的文件，以及两个 &lt;code&gt;__generated__&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">要添加一个新的分页继电器容器</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">要添加一个新的继电器容器</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">要添加一个新的中继容器,有变化的数据要求。</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">要为继电器组件添加新的根</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">要在基础组件上调用此方法，请首先向Relay容器提供 &lt;code&gt;componentRef&lt;/code&gt; 函数。这不同于提供&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;函数的功能，后者将提供对Relay容器本身的引用，而不是对底层React组件的引用。</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">要进行一次突变</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">要在Relay Modern中创建环境实例，请使用 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">要启用&lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt;， &lt;code&gt;relay-compiler&lt;/code&gt; 将为查询强制执行简单的命名约定。查询必须命名为 &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; ，其中&amp;ldquo; &amp;lt;OperationType&amp;gt;&amp;rdquo;是&amp;ldquo;查询&amp;rdquo;，&amp;ldquo;更改&amp;rdquo;或&amp;ldquo;订阅&amp;rdquo;之一。上面的查询名为 &lt;code&gt;ExampleQuery&lt;/code&gt; ,因此应放置在 &lt;code&gt;Example.js&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">要执行此代码，Relay需要访问架构-该架构可能太大而无法捆绑在应用程序内部。而是将这些 &lt;code&gt;Relay.QL&lt;/code&gt; 模板表达式通过 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 转换为JavaScript描述。此架构信息使Relay可以了解诸如字段参数的类型，哪些字段是连接或列表以及如何从服务器有效地重新获取记录之类的内容。</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">强制取回一个组件</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">要开始构建Relay应用,你需要三样东西。</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">为了提高感知到的响应速度，您可能希望执行&amp;ldquo;乐观更新&amp;rdquo;，在该更新中，即使在服务器响应返回之前，客户端也会立即更新以反映预期的新值。为此，我们提供了一个 &lt;code&gt;optimisticResponse&lt;/code&gt; 并将其添加到我们传递给 &lt;code&gt;commitMutation&lt;/code&gt; 的 &lt;code&gt;config&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">通过连接进行分页</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">要从缓存中读取信息，我们可以查询并解析每个字段。但是，等等：这听起来与GraphQL服务器处理查询时的操作&lt;em&gt;完全&lt;/em&gt;一样。是的！从缓存读取是执行程序的一种特殊情况，其中a）不需要用户定义的字段函数，因为所有结果都来自固定的数据结构，并且b）结果始终是同步的-我们要么缓存了数据，要么不缓存数据。 t。</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">首先，让我们构建 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 组件的普通React版本，该组件显示用户的个人资料照片和用于调整照片大小的滑块。</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">首先，让我们构建一个 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 组件的普通React版本，该组件显示 &lt;code&gt;Todo&lt;/code&gt; 的文本和完成状态。</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">为我的组件更新一个变量</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">要使用中继编译器，您需要一个.graphql或.json GraphQL模式文件，以描述GraphQL服务器的API。通常，这些文件是服务器真实来源的本地表示，并且不直接编辑。例如，我们可能有一个 &lt;code&gt;schema.graphql&lt;/code&gt; 像这样：</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">为了使用这些片段来构建可以发送到服务器以获取数据的成熟的GraphQL查询，我们需要使用&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">典型的Relay Classic代码。</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">典型的旧代码。</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">通常，您将不需要导入生成的定义。该&lt;a href=&quot;babel-plugin-relay&quot;&gt;继电器巴贝尔插件&lt;/a&gt;会转换 &lt;code&gt;graphql&lt;/code&gt; 文字到 &lt;code&gt;require()&lt;/code&gt; 生成的文件。</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">在引擎盖下，默认网络层使用 &lt;code&gt;fetch&lt;/code&gt; （&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;）。 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 的构造函数采用一个可选的第二个参数，该参数接受 &lt;code&gt;fetch&lt;/code&gt; 接受的任何有效初始化属性。</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">与查询不同,失败的突变请求不会自动重试。</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">到目前为止，我们仅与GraphQL端点进行交互以执行获取数据的查询。在本指南中，您将学习如何使用中继执行突变-这些操作包括对数据存储的写操作，然后是对任何已更改字段的获取。</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">更新与可变记录相关联的记录,通过字段名和代表预定义参数值的对象横向更新源。</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">更新由字段名和代表预定义参数值的对象给出的可变记录的属性值。</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">在每次响应时更新客户端</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">乐观地更新客户端</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">接收到查询/变异响应后更新本地缓存。</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">以程序方式更新商店(高级</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">升级到 react-relay v1.0.0。</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">升级setVariables</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">使用 &lt;code&gt;introspectionQuery&lt;/code&gt; 为Babel中继插件生成Schema JSON，并使用 &lt;code&gt;printSchema&lt;/code&gt; 生成用户可读类型的系统速记：</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;graphql&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">使用其他GraphQL实现</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">使用缓存</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt; &amp;rdquo; 下转换期间使用</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">与Relay Classic一起使用</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">视图构图&lt;em&gt;正是&lt;/em&gt;您习惯的-中继容器是标准的React组件。这是 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">视图合成&lt;em&gt;正是&lt;/em&gt;您所习惯的-中继容器是标准的React组件。这是 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">热身</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">我们构建了一些脚本来帮助您完成转换过程。在&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod上&lt;/a&gt;查看它们。</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">我们可以通过提供 &lt;code&gt;renderLoading&lt;/code&gt; 道具来更改此行为：</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">我们可以以配置数组的形式给Relay下达指令,说明如何使用每个突变的响应来更新客户端的存储。我们通过用以下一种或多种突变类型配置突变来实现。</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">我们在这里声明我们的突变的数据依赖性,就像在容器中一样。这对于确保我们可能想在这个突变的乐观响应中使用的一组字段已经被获取特别有用。</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">我们需要一个藏宝的地方,一个检查藏宝地点的方法,以及一个跟踪我们剩余回合的方法。在本教程中,我们将把这些数据隐藏在内存中。</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">我们需要给Relay下达指令,说明如何使用每个突变的响应有效载荷来更新客户端存储。我们通过将突变配置为以下一种或多种突变类型来实现。</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">我们最终选择了静态方法。组件将有效地返回与视图树分离的查询树，以描述其数据依赖性。然后，Relay可以使用此查询树来获取单个阶段所需的所有信息，并使用它来呈现组件。问题在于找到一种描述查询树的适当机制，以及一种从服务器（即在单个网络请求中）有效获取查询树的方法。这是GraphQL的完美用例，因为它提供了一种语法，用于&lt;em&gt;将数据依赖关系描述为data&lt;/em&gt;，而无需指定任何特定的API。请注意，通常建议将Promises和Observables作为替代方案，但它们表示&lt;em&gt;不透明的命令，&lt;/em&gt;并且会排除各种优化方法，例如查询批处理。</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">现在，根据访问故事的方式，我们将看到不同的 &lt;code&gt;likeCount&lt;/code&gt; 。使用第一个查询的视图将看到过期的计数，而使用第二个查询的视图将看到更新的计数。</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">我们几乎准备好让Relay满足这些组件的数据要求并进行渲染。但是，有一个问题。为了使用GraphQL实际获取数据，我们需要一个查询根。例如，我们需要将 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 片段置于 &lt;code&gt;User&lt;/code&gt; 类型的具体节点中。</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">我们发现，GraphQL模式与磁盘上存储数据的形式略有不同甚至根本不同的情况很常见。简而言之：基础&lt;em&gt;数据存储&lt;/em&gt;（磁盘）中的数据更改与&lt;em&gt;产品可视化架构&lt;/em&gt;（GraphQL）中的数据更改之间并不总是存在1：1的对应关系。完美的例子就是隐私：返回 &lt;code&gt;age&lt;/code&gt; 等面向用户的字段可能需要访问我们的数据存储层中的许多记录，以确定是否甚至允许活动用户&lt;em&gt;看到&lt;/em&gt;该 &lt;code&gt;age&lt;/code&gt; （我们是朋友吗？我的年龄是否共享？ ？我阻止了您吗？等。</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">我们发现，使用命令性API进行数据提取的典型方法迫使开发人员处理过多的这种不必要的复杂性。例如，考虑&lt;em&gt;乐观的UI更新&lt;/em&gt;。这是在等待服务器响应时向用户提供反馈的一种方式。的逻辑&lt;em&gt;是什么&lt;/em&gt;做的可以说是相当清楚的：当用户点击&amp;ldquo;喜欢&amp;rdquo;，纪念的故事，被人喜欢和发送请求到服务器。但是实现通常要复杂得多。命令式方法要求我们执行所有这些步骤：进入UI并切换按钮，发起网络请求，在必要时重试，在失败时显示错误（并取消切换按钮）等。数据也是如此-获取：指定我们通常需要指示&lt;em&gt;哪些&lt;/em&gt;数据&lt;em&gt;如何&lt;/em&gt;以及&lt;em&gt;何时&lt;/em&gt;获取。接下来，我们将探索使用&lt;strong&gt;Relay&lt;/strong&gt;解决这些问题的方法。</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">我们已经看到，中继容器确保&lt;em&gt;在&lt;/em&gt;呈现组件&lt;em&gt;之前&lt;/em&gt;获取GraphQL片段。但是容器还提供了另一个尚不立即显而易见的好处：&lt;strong&gt;数据屏蔽&lt;/strong&gt;。中继仅允许组件访问其专门要求的数据 &lt;code&gt;fragments&lt;/code&gt; ，仅此而已。因此，如果一个故事的一个组成部分的查询 &lt;code&gt;text&lt;/code&gt; ，另一个是它的 &lt;code&gt;author&lt;/code&gt; ，每个人都可以看到&lt;em&gt;只有&lt;/em&gt;他们要求的领域。实际上，组件甚至看不到其&lt;em&gt;子级&lt;/em&gt;请求的数据：这也会破坏封装。</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">我们在这里写的是一个模拟的数据库接口。我们可以想象将它连接到一个真实的数据库,但现在让我们继续前进。</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">有什么用？中继兼容性（ &lt;code&gt;'react-relay/compat'&lt;/code&gt; ）是最灵活的。兼容组件和变异可以被任何事物使用。兼容组件也可以具有任何子代。</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">当&amp;ldquo;强制获取&amp;rdquo;时，如果由于服务器请求完成之前客户端上的数据可用而导致 &lt;code&gt;ready&lt;/code&gt; 为true，则为true。</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">当 &lt;code&gt;forceFetch&lt;/code&gt; 是真实的， &lt;code&gt;renderFetched&lt;/code&gt; 被称为可用的客户端数据的结果， &lt;code&gt;renderFetched&lt;/code&gt; 被调用，具有第二个参数 &lt;code&gt;stale&lt;/code&gt; 布尔属性。该 &lt;code&gt;stale&lt;/code&gt; ，如果属性为true &lt;code&gt;renderFetched&lt;/code&gt; 被强制要求服务器完成之前调用。</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">当 &lt;code&gt;forceFetch&lt;/code&gt; 为true时，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将始终向服务器发送请求。但是，如果渲染所需的所有数据在客户端上也都可用，则在服务器请求完成之前仍可以调用 &lt;code&gt;renderFetched&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">当Relay完成数据时，将使用描述当前&amp;ldquo;就绪状态&amp;rdquo;的对象一次或多次调用 &lt;code&gt;onReadyStateChange&lt;/code&gt; 回调。该对象具有以下属性：</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">当渲染所需的所有数据可用时，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将默认渲染提供的 &lt;code&gt;Component&lt;/code&gt; 。但是，我们可以通过为 &lt;code&gt;renderFetched&lt;/code&gt; 属性提供回调来更改此行为：</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">当满足所有数据要求时，将调用 &lt;code&gt;renderFetched&lt;/code&gt; 呈现视图。渲染时，预期此回调会将 &lt;code&gt;data&lt;/code&gt; 传播到提供的 &lt;code&gt;Container&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">在编译代码进行生产部署时,插件可以配置为遇到验证问题时立即抛出。该插件可以通过以下选项针对不同环境进一步定制。</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">当无法满足数据要求时，将调用 &lt;code&gt;renderFailure&lt;/code&gt; 呈现视图。</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">当尚未满足数据要求时，将调用 &lt;code&gt;renderLoading&lt;/code&gt; 呈现视图。如果返回 &lt;code&gt;undefined&lt;/code&gt; ，则呈现先前呈现的视图（如果没有先前的视图则不呈现）。</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">设计胖查询时，请考虑由于变异而可能更改的&lt;em&gt;所有&lt;/em&gt;数据，而不仅仅是应用程序当前正在使用的数据。我们不必担心超量获取；在未与应用程序实际需要的数据的&amp;ldquo;跟踪查询&amp;rdquo;相交之前，绝不会执行此查询。如果在胖查询中省略字段，则将来在添加具有新数据依赖项的视图或向现有视图添加新数据依赖项时，我们可能会观察到数据不一致的情况。</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">当将Relay Classic应用程序逐步转换为Relay Modern 时，如果配置为使用兼容模式， &lt;code&gt;graphql&lt;/code&gt; 文字可以转换为&lt;em&gt;两个&lt;/em&gt;运行时&lt;em&gt;都&lt;/em&gt;可以使用：</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">当它发送查询时,会在超时15秒后自动失败请求。同时,失败的请求会自动重试两次,分别延迟1秒和3秒。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
