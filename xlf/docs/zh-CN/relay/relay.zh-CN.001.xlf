<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013年至今Facebook Inc.。</target>
        </trans-unit>
        <trans-unit id="62a57a41103550669d926f2e0d40ca12b0b6a458" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2020年至今Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="6c885f04e75b4bbf0d9edbb67f250e651d298c71" translate="yes" xml:space="preserve">
          <source>(subsequent sections explain how these types are used in practice):</source>
          <target state="translated">（以下各节说明如何在实践中使用这些类型）：</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">*现代API不支持突变片段。您可能必须将遗留突变中的突变片段内联到组件片段中。</target>
        </trans-unit>
        <trans-unit id="3c78bed46629a737d7ec7580861338032fb6f8d8" translate="yes" xml:space="preserve">
          <source>...which calls the callbacks for any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed. Each subscription is checked as follows:</source>
          <target state="translated">...这会为结果已更改的任何subscription &lt;code&gt;subscribe()&lt;/code&gt; ers调用回调。每个订阅的检查如下：</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;返回一个基本容器，该基本容器无法获取其片段中声明的内容以外的其他数据。Relay Modern还为动态用例提供了更高级的容器（以前在Relay Classic中通过 &lt;code&gt;setVariables&lt;/code&gt; 处理）：</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome扩展&lt;/a&gt;程序在开发人员工具界面中创建了&amp;ldquo;中继&amp;rdquo;标签，用于调试Chrome中的应用</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;允许将视图定义为组件，其中每个组件都负责呈现UI的一部分。组成其他组件是如何构建复杂的UI。每个React组件不需要知道组成组件的内部工作原理。</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;电子应用程序&lt;/a&gt;连接到运行Relay的React Native应用程序</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;管理GraphQL查询的执行。它使用给定的变量发送查询，解析响应，将数据保存到内部缓存中，最后呈现视图。</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;createFragmentContainer&lt;/code&gt; 的变体，用于解决&amp;ldquo;查看更多&amp;rdquo;用例，其中先呈现数据子集，然后按需获取其他数据。Refetch容器最初像片段容器一样获取其片段的数据，但也提供 &lt;code&gt;refetch()&lt;/code&gt; 方法，通过该方法可以获取其他数据，或者可以使用不同的变量重新渲染该容器以读取数据。</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt;允许在现有Relay应用程序中逐步采用Relay Modern API。与Relay Classic相比，此方法具有以下功能：</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 接收带有纯JavaScript数据（对象，数组，字符串）的 &lt;code&gt;user&lt;/code&gt; 道具，并照常进行渲染。</target>
        </trans-unit>
        <trans-unit id="540f04ea4575b6b8ef0b102ef7464ad435fbcfde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@argumentDefinitions&lt;/code&gt; is a directive used to specify arguments taken by a fragment. For example:</source>
          <target state="translated">&lt;code&gt;@argumentDefinitions&lt;/code&gt; 是用于指定片段采用的参数的指令。例如：</target>
        </trans-unit>
        <trans-unit id="8c1b1f1da3ceb037a205f174a8917520d0d4ffd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@arguments&lt;/code&gt; is a directive used to pass arguments to a fragment that was defined using &lt;a href=&quot;#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;code&gt;@arguments&lt;/code&gt; 是用于将参数传递给使用&lt;a href=&quot;#argumentdefinitions&quot;&gt; &lt;code&gt;@argumentDefinitions&lt;/code&gt; &lt;/a&gt;定义的片段的指令。例如：</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; 指令</target>
        </trans-unit>
        <trans-unit id="1bc35103d12ff175f274fc790197926805195584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@relay(mask: false)&lt;/code&gt; can be used to prevent data masking; when including a fragment and annotating it with &lt;code&gt;@relay(mask: false)&lt;/code&gt;, its data will be available directly to the parent instead of being masked for a different container.</source>
          <target state="translated">&lt;code&gt;@relay(mask: false)&lt;/code&gt; 可用于防止数据屏蔽；当包含一个片段并使用 &lt;code&gt;@relay(mask: false)&lt;/code&gt; 对其进行注释时，其数据将直接提供给父对象，而不是被其他容器屏蔽。</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash;事务已排队等待提交，但另一个具有相同冲突键的事务失败。冲突队列中的所有事务（包括该事务）均已失败。事务可以重新提交或回滚。</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash;事务正在等待服务器响应。</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash;事务已发送到服务器以进行提交，但失败。</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; -事务已提交，但另一个具有相同冲突密钥的事务正在等待处理，因此该事务已排队发送给服务器。</target>
        </trans-unit>
        <trans-unit id="d35b1de34e23cc42d8709b3e3b9f29da3640030e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CompilerContext&lt;/code&gt;: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).</source>
          <target state="translated">&lt;code&gt;CompilerContext&lt;/code&gt; ：GraphQL文档语料库的不可变表示形式。它包含模式和文档名称到文档表示的映射（如IR，请参见上文）。</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 中继容器，用于定义片段和要呈现的视图。</target>
        </trans-unit>
        <trans-unit id="7e0e496215e40a981e6b2de27c4b054fef09ee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectionHandler&lt;/code&gt; is a utility module exposed by &lt;code&gt;relay-runtime&lt;/code&gt; that aids in the manipulation of connections. &lt;code&gt;ConnectionHandler&lt;/code&gt; exposes the following interface:</source>
          <target state="translated">&lt;code&gt;ConnectionHandler&lt;/code&gt; 是 &lt;code&gt;relay-runtime&lt;/code&gt; 公开的实用程序模块，有助于操作连接。 &lt;code&gt;ConnectionHandler&lt;/code&gt; 公开以下接口：</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; 中继容器，用于定义片段和要渲染的视图。</target>
        </trans-unit>
        <trans-unit id="6e013f788fda8dc5f1f6d2035114dc14dbf0b578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DataID&lt;/code&gt; (type): A globally unique or client-generated identifier for a record, stored as a string.</source>
          <target state="translated">&lt;code&gt;DataID&lt;/code&gt; （类型）：记录的全局唯一标识符或客户端生成的标识符，存储为字符串。</target>
        </trans-unit>
        <trans-unit id="ce201c06fa6c11d5f36ef9be515d40d9178e1a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Environment&lt;/code&gt; (type): Represents an encapsulated environment combining a &lt;code&gt;Store&lt;/code&gt; and &lt;code&gt;Network&lt;/code&gt;, providing a high-level API for interacting with both. This is the main public API of &lt;code&gt;RelayRuntime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Environment&lt;/code&gt; （类型）：表示一个结合了 &lt;code&gt;Store&lt;/code&gt; 和 &lt;code&gt;Network&lt;/code&gt; 的封装环境，提供了用于与两者交互的高级API。这是 &lt;code&gt;RelayRuntime&lt;/code&gt; 的主要公共API 。</target>
        </trans-unit>
        <trans-unit id="1e3ea2f8d9422eb5a55274a578df6f8f2c6bd0ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FlattenTransform&lt;/code&gt;: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:</source>
          <target state="translated">&lt;code&gt;FlattenTransform&lt;/code&gt; ：减少查询中不必要的间接级别，将匿名片段中的字段与父类型匹配的位置内联。当生成代码以读取查询结果或处理查询结果时，这将是有益的，因为它减少了重复字段的处理。例如：</target>
        </trans-unit>
        <trans-unit id="e8491c1573884a469fe6759e485e0a2a6e275e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt;: This optional, Relay-specific transform inserts &lt;code&gt;id&lt;/code&gt; fields for globally identifiable objects and &lt;code&gt;__typename&lt;/code&gt; fields wherever the type cannot be statically determined (e.g. for unions).</source>
          <target state="translated">&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt; ：此可选的，中继特定的转换在无法静态确定类型的位置（例如，对于联合）插入用于全局可识别对象的 &lt;code&gt;id&lt;/code&gt; 字段和 &lt;code&gt;__typename&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="cfa5e3950beed71919f93e9725e12ccd2524ec5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IR&lt;/code&gt; (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. &lt;code&gt;graphql-js&lt;/code&gt;) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (&lt;code&gt;@include&lt;/code&gt; and &lt;code&gt;@skip&lt;/code&gt;) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).</source>
          <target state="translated">&lt;code&gt;IR&lt;/code&gt; （中间表示）：GraphQL文档（查询，片段，字段等）作为树结构的（有效不变）表示，包括来自架构的类型信息。与标准GraphQL AST（例如由 &lt;code&gt;graphql-js&lt;/code&gt; 产生）相比，主要区别在于它编码了GraphQL的更多语义。例如，直接表示条件分支（ &lt;code&gt;@include&lt;/code&gt; 和 &lt;code&gt;@skip&lt;/code&gt; ），从而使针对这些指令的优化更加容易（一种优化是将具有相同条件的同级字段合并，从而潜在地减少了必须在处评估的条件数量运行）。</target>
        </trans-unit>
        <trans-unit id="80030d53df3c7d765455bf7613659bf4eb278701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Network&lt;/code&gt; (type): Provides methods for fetching query data from and executing mutations against an external data source.</source>
          <target state="translated">&lt;code&gt;Network&lt;/code&gt; （类型）：提供用于从外部数据源获取查询数据并对其执行更改的方法。</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; 旨在简化在列表中加载更多项目的工作流程-在许多情况下，我们不想一次获取所有数据，而是懒惰地加载更多数据。它依靠GraphQL服务器以标准化方式公开连接。有关详细规格，请查看&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;此页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36a682fa10b4ab6dd0259f5b624dca4803e8ff33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Parser&lt;/code&gt;: Converts a GraphQL schema and raw GraphQL text into typed IR objects.</source>
          <target state="translated">&lt;code&gt;Parser&lt;/code&gt; ：将GraphQL模式和原始GraphQL文本转换为类型化的IR对象。</target>
        </trans-unit>
        <trans-unit id="2f603ad3da9b9bbbb0030816e3352c33635f9a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Printer&lt;/code&gt;: a function that accepts IR and converts it to a GraphQL string.</source>
          <target state="translated">&lt;code&gt;Printer&lt;/code&gt; ：接受IR并将其转换为GraphQL字符串的函数。</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 是中继树的根。它进行查询，获取数据并使用该数据调用 &lt;code&gt;render&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 支持直接呈现少量数据，而不需要容器来访问数据。&lt;a href=&quot;fragment-container&quot;&gt;容器&lt;/a&gt;是可选的，可以随着应用程序的大小和复杂性的增长而使用。</target>
        </trans-unit>
        <trans-unit id="99e84e643c97bf62b99096002ffcdeabf9974b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; will then fetch the data and render &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 然后，QueryRenderer将获取数据并在可用数据后渲染 &lt;code&gt;StoryContainer&lt;/code&gt; 。正如React允许开发人员在不直接操纵基础视图的情况下呈现视图一样，Relay消除了与网络直接通信的需要。</target>
        </trans-unit>
        <trans-unit id="aa5389da6f3012b6c1290dfc4aabb66ac37a4a88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Record&lt;/code&gt; (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to &lt;code&gt;Record&lt;/code&gt; objects (including record creation) is mediated through the &lt;code&gt;RelayModernRecord&lt;/code&gt; module. This allows the representation itself to be changed in a single place (e.g. to use &lt;code&gt;Map&lt;/code&gt;s or a custom class). It is important that other code does not assume that &lt;code&gt;Record&lt;/code&gt;s will always be plain objects.</source>
          <target state="translated">&lt;code&gt;Record&lt;/code&gt; （类型）：具有标识，类型和字段的不同数据实体的表示。请注意，实际的运行时表示对系统而言是不透明的：对 &lt;code&gt;Record&lt;/code&gt; 对象的所有访问（包括记录创建）都通过 &lt;code&gt;RelayModernRecord&lt;/code&gt; 模块进行调解。这允许在一个地方更改表示本身（例如，使用 &lt;code&gt;Map&lt;/code&gt; 或自定义类）。重要的是其他代码不要假定 &lt;code&gt;Record&lt;/code&gt; 始终是纯对象。</target>
        </trans-unit>
        <trans-unit id="0c286a93f7d02b418c79e236a3f655909cd0828b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RecordSource&lt;/code&gt; (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a &lt;code&gt;RecordSource&lt;/code&gt; and the results of queries/mutations/subscriptions are normalized into &lt;code&gt;RecordSource&lt;/code&gt;s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt;; future implementations may add support for loading records from disk.</source>
          <target state="translated">&lt;code&gt;RecordSource&lt;/code&gt; （类型）：由其数据ID键控的记录的集合，用于表示高速缓存和对其的更新。例如，商店的记录缓存是 &lt;code&gt;RecordSource&lt;/code&gt; ，查询/更改/订阅的结果被标准化为 &lt;code&gt;RecordSource&lt;/code&gt; ，并发布到商店。源还定义了异步加载记录的方法，以（最终）支持离线用例。当前，此接口的唯一实现是 &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt; ;将来的实现可能会增加对从磁盘加载记录的支持。</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 不会提供任何麻烦，例如胖查询或跟踪查询（即，将要发送到服务器的变异查询在运行时自动合成），而是让用户定义静态和显式查询。将自己限制在底层API是一个有用的准备步骤，它将帮助您准备好代码库，以迁移到新的静态Relay核心。同时，如果您需要这些动态功能，则可以选择上级的 &lt;code&gt;Relay.Mutation&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 是用于对GraphQL突变建模的低级API。</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; 以下API使用Relay.QL对象：</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; 然后，Relay.Renderer可以协调查询的获取。将它们与缓存的数据进行比较，获取所有丢失的信息，更新缓存，并在数据可用时最终渲染 &lt;code&gt;StoryContainer&lt;/code&gt; 。默认值为在获取数据时不渲染任何内容，但可以通过 &lt;code&gt;render&lt;/code&gt; 道具自定义加载视图。正如React允许开发人员在不直接操作基础视图的情况下呈现视图一样，Relay和 &lt;code&gt;Relay.Renderer&lt;/code&gt; 消除了直接与网络通信的需求。</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; 是中继库的入口点。如果您使用的是预构建的软件包之一，则可以作为全局软件包使用；如果您使用的是CommonJS模块，则可以使用 &lt;code&gt;require()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; 是一个高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; 封装了Relay需要发送到服务器的突变。通过 &lt;code&gt;sendMutation&lt;/code&gt; 方法，它们可用于网络层。</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; 可以返回以下字符串之一：</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; 封装了Relay需要发送到服务器的查询。通过 &lt;code&gt;sendQueries&lt;/code&gt; 方法，它们可用于网络层。</target>
        </trans-unit>
        <trans-unit id="fa983dda38587dddabcba1aaf5a70bd38e50d1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Selector&lt;/code&gt; (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this &quot;selects&quot; a portion of the object graph.</source>
          <target state="translated">&lt;code&gt;Selector&lt;/code&gt; （类型）：选择器定义了遍历图形的起点，以针对子图为目标，并结合了GraphQL片段，变量和应从中进行遍历的根对象的数据ID。直观地，这&amp;ldquo;选择&amp;rdquo;了对象图的一部分。</target>
        </trans-unit>
        <trans-unit id="af3c71166345fc66296a2fcfde6e211df573f098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt;: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:</source>
          <target state="translated">&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt; ：扁平化的更高级版本，它消除了更复杂的字段重复情况，例如无条件和有条件地获取字段，或者由两个不同的子片段获取字段时。例如：</target>
        </trans-unit>
        <trans-unit id="fba6d300e8d2beebd7043543022bbc6158c521d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Snapshot&lt;/code&gt; (type): The (immutable) results of executing a &lt;code&gt;Selector&lt;/code&gt; at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).</source>
          <target state="translated">&lt;code&gt;Snapshot&lt;/code&gt; （类型）：在给定的时间点执行 &lt;code&gt;Selector&lt;/code&gt; 的（不可变的）结果。这包括选择器本身，执行它的结果以及从中检索数据的数据ID的列表（在确定这些结果何时可能更改时很有用）。</target>
        </trans-unit>
        <trans-unit id="bd6f9d1898c7f71f61996e47d31e4669e9f6ea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Store&lt;/code&gt; (type): The source of truth for an instance of &lt;code&gt;RelayRuntime&lt;/code&gt;, holding the canonical set of records in the form of a &lt;code&gt;RecordSource&lt;/code&gt; (though this is not required). Currently the only implementation is &lt;code&gt;RelayModernStore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Store&lt;/code&gt; （类型）： &lt;code&gt;RelayRuntime&lt;/code&gt; 实例的真相源，以 &lt;code&gt;RecordSource&lt;/code&gt; 的形式保存规范的记录集（尽管这不是必需的）。当前，唯一的实现是 &lt;code&gt;RelayModernStore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6953a65cec76dd55ffb8686c4013c2fe83a10320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transform&lt;/code&gt;: a &quot;map&quot;-like function that accepts a &lt;code&gt;CompilerContext&lt;/code&gt; as input and returns a new, modified context as output. Examples below.</source>
          <target state="translated">&lt;code&gt;Transform&lt;/code&gt; ：类似于&amp;ldquo;地图&amp;rdquo;的函数，该函数接受 &lt;code&gt;CompilerContext&lt;/code&gt; 作为输入，并返回一个新的，经过修改的上下文作为输出。下面的例子。</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; -事务尚未发送到服务器。事务可以被提交或回滚。</target>
        </trans-unit>
        <trans-unit id="251d369c69abccbd72c957636015d12c5ab2df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：包含一组缓存配置选项的可选对象</target>
        </trans-unit>
        <trans-unit id="44015182f39e2d46ef207ac1787ea9eab09b8733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache.</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：包含一组缓存配置选项的可选对象，即 &lt;code&gt;force: true&lt;/code&gt; ，无论任何已配置的响应缓存的状态如何，都要求发出提取信息。</target>
        </trans-unit>
        <trans-unit id="a1e2ffe769d943340c0e937aef710727a6236ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache. See &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;the types&lt;/a&gt; for more &lt;code&gt;cacheConfig&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：包含一组缓存配置选项的可选对象，即 &lt;code&gt;force: true&lt;/code&gt; ，无论任何已配置的响应缓存的状态如何，都要求发出提取信息。有关更多 &lt;code&gt;cacheConfig&lt;/code&gt; 选项的信息，请参见&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90c165e6157296f7bcc1ff33984b3b1b9a2c82c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; ：提取新页面时调用的函数。如果在重新提取过程中发生错误，则此函数将接收该错误作为参数。</target>
        </trans-unit>
        <trans-unit id="5a549ab3ecb985d7c1e6a0bcdb2975890cf8213e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; ：refetch完成后要调用的函数。如果在重新提取过程中发生错误，则此函数将接收该错误作为参数。</target>
        </trans-unit>
        <trans-unit id="6ddb9c091b2339b506a0b25d46c1b43d0aec3f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;component&lt;/code&gt;: The React Component &lt;em&gt;class&lt;/em&gt; of the component requiring the fragment data.</source>
          <target state="translated">&lt;code&gt;component&lt;/code&gt; ：需要片段数据的组件的React Component&lt;em&gt;类&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d84b6d9b41c57662dbad63044ec256b7ffeb4679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="06f15b2aa1dd0d5d58698483052939daa832e202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: Array containing objects describing &lt;code&gt;optimisticUpdater&lt;/code&gt;/&lt;code&gt;updater&lt;/code&gt; configurations. &lt;code&gt;configs&lt;/code&gt; provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior without having to write an &lt;code&gt;updater&lt;/code&gt; function. See our section on &lt;a href=&quot;#updater-configs&quot;&gt;Updater Configs&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含描述 &lt;code&gt;optimisticUpdater&lt;/code&gt; / &lt;code&gt;updater&lt;/code&gt; 配置的对象的数组。 &lt;code&gt;configs&lt;/code&gt; 提供了一种方便的方法来指定 &lt;code&gt;updater&lt;/code&gt; 行为，而无需编写 &lt;code&gt;updater&lt;/code&gt; 功能。有关更多详细信息，请参见我们的&amp;ldquo; &lt;a href=&quot;#updater-configs&quot;&gt;Updater Configs&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含不同optimisticUpdater / updater配置的数组。它提供了一种方便的方法来指定 &lt;code&gt;updater&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含更新程序配置的数组。这是一样的&lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62ed1b32bc4ea099a4726b7185046d66828e634b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#updater-configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：包含更新程序配置的数组。这是一样的&lt;a href=&quot;mutations#updater-configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="007117b0cb1510ebdd6ccffcf08576a3c37cde5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionConfig&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connectionConfig&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; ：包含连接键的对象数组，包含可选过滤器的对象以及范围行为，具体取决于我们期望的行为（追加，前置，或忽略）。</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; ：包含连接键和过滤器的对象数组。</target>
        </trans-unit>
        <trans-unit id="3d66112758b5fe7d9ec709917fc9645fa7ce2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createFragmentContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createFragmentContainer&lt;/code&gt; 具有以下签名：</target>
        </trans-unit>
        <trans-unit id="38957bb815ee45a69777b60c1f154618685af8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createPaginationContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createPaginationContainer&lt;/code&gt; 具有以下签名：</target>
        </trans-unit>
        <trans-unit id="3466a399b65ec8fadadd39718cdbdde5b6b2fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createRefetchContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; 具有以下签名：</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：响应中的字段名称，其中包含已删除节点的DataID或从连接中删除的节点的路径</target>
        </trans-unit>
        <trans-unit id="876617472fa789679ebf9a0b7c9f1eb24f355aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：响应中的字段名称，其中包含已删除节点的DataID或DataID，或者从连接中删除节点的路径。</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：响应中包含已删除节点的DataID的字段名称</target>
        </trans-unit>
        <trans-unit id="bf1fd5c8652f9301a307527a2205d4d2b4a75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：响应中的字段名称，其中包含一个或多个已删除节点的一​​个或多个DataID</target>
        </trans-unit>
        <trans-unit id="999f3fdfc8dda2a0f3aa0796444cc77a3d69202e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt;: Either &quot;forward&quot; to indicate forward pagination using after/first, or &quot;backward&quot; to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; ：&amp;ldquo; forward&amp;rdquo;使用后/首指示前向分页，或&amp;ldquo; backward&amp;rdquo;使用前/后指示前向分页。如果未提供，则Relay将根据提供的 &lt;code&gt;@connection&lt;/code&gt; 指令推断方向。</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; ：响应中代表新创建的边的字段名称</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; Relay.Environment的实例或实现RelayEnvironment接口的任何对象。</target>
        </trans-unit>
        <trans-unit id="934fc584b2cbd07fff4713741be349d8db57ed53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：&lt;a href=&quot;relay-environment&quot;&gt;中继环境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c04830e6cd3cb5a81acacd5ef47ab3c8d851603a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. &lt;strong&gt;Note:&lt;/strong&gt; To ensure the mutation is performed on the correct &lt;code&gt;environment&lt;/code&gt;, it's recommended to use the environment available within components (from &lt;code&gt;this.props.relay.environment&lt;/code&gt;), instead of referencing a global environment.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：&lt;a href=&quot;relay-environment&quot;&gt;中继环境&lt;/a&gt;。&lt;strong&gt;注意：&lt;/strong&gt;为确保在正确的 &lt;code&gt;environment&lt;/code&gt; 上执行变异，建议使用组件内可用的环境（来自 &lt;code&gt;this.props.relay.environment&lt;/code&gt; ），而不要引用全局环境。</target>
        </trans-unit>
        <trans-unit id="c42e0b6673753c1ecd9043bed1858fc0974cabb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The current &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：当前的&lt;a href=&quot;relay-environment&quot;&gt;中继环境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="516a6ee32a7083dc25663e4b1b51d53113bbfc43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: Error will be defined if an error has occurred while fetching the query.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; ：如果在获取查询时发生错误，则将定义错误。</target>
        </trans-unit>
        <trans-unit id="933f09a28ce1c93df86693d7ec2e3b4c3c2c539a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy&lt;/code&gt;: If the data is already present in the store, using the &lt;code&gt;'store-or-network'&lt;/code&gt; option will use that data without making an additional network request. Using the &lt;code&gt;'network-only'&lt;/code&gt; option, which is the default behavior, will ignore any data present in the store and make a network request.</source>
          <target state="translated">&lt;code&gt;fetchPolicy&lt;/code&gt; ：如果商店中已经存在数据，则使用 &lt;code&gt;'store-or-network'&lt;/code&gt; 选项将使用该数据，而无需发出额外的网络请求。使用 &lt;code&gt;'network-only'&lt;/code&gt; 选项（这是默认行为）将忽略存储中存在的任何数据并发出网络请求。</target>
        </trans-unit>
        <trans-unit id="094d53375b81243f7e2c05c1de339c8e282ff5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy?&lt;/code&gt;: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the &lt;code&gt;store-and-network&lt;/code&gt; key. Using the &lt;code&gt;network-only&lt;/code&gt; key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.</source>
          <target state="translated">&lt;code&gt;fetchPolicy?&lt;/code&gt; ：可选的道具，用于指示是否应使用商店中存在的数据来立即渲染商店中已经存在的数据并随后使用 &lt;code&gt;store-and-network&lt;/code&gt; 密钥从网络中进行更新。使用 &lt;code&gt;network-only&lt;/code&gt; 密钥（这是默认行为），它将忽略存储中已经存在的数据，并等待网络结果返回。</target>
        </trans-unit>
        <trans-unit id="a2b9d698f04dcb6c9b4de74dbaccc7db4327ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: &lt;strong&gt;Optional&lt;/strong&gt; Array of strings that belong to the set of argument variables defined for the connection field (e.g. &lt;code&gt;orderBy&lt;/code&gt;, &lt;code&gt;searchTerm&lt;/code&gt;, etc). The values for the variables specified in this array will be used alongside the user-supplied &lt;code&gt;key&lt;/code&gt; to uniquely identify a connection. If &lt;code&gt;filters&lt;/code&gt; is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;/&lt;code&gt;before&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：&lt;strong&gt;可选&lt;/strong&gt;的字符串数组，它们属于为连接字段定义的参数变量集（例如 &lt;code&gt;orderBy&lt;/code&gt; ， &lt;code&gt;searchTerm&lt;/code&gt; 等）。在此数组中指定的变量的值将与用户提供的 &lt;code&gt;key&lt;/code&gt; 一起使用，以唯一地标识连接。如果未提供 &lt;code&gt;filters&lt;/code&gt; 则默认情况下，Relay将使用连接字段采用的所有参数的集合，但不包括分页特定的参数（即 &lt;code&gt;first&lt;/code&gt; / &lt;code&gt;last&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; / &lt;code&gt;before&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：一个包含GraphQL调用的对象，例如 &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="499b17304b2bef431abd97d0542599af80ca0ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: If the &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; ：如果&lt;a href=&quot;network-layer&quot;&gt;网络层&lt;/a&gt;已配置了缓存，则即使此查询和变量的数据在缓存中已经可用，此选项也会强制进行重新提取。</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 是否发送服务器请求，而不管客户端上可用的数据如何。</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 可以使用空的部分变量集来调用forceFetch，这意味着它可以触发刷新当前呈现的数据集。</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 类似于 &lt;code&gt;setVariables&lt;/code&gt; ，因为它也可以用来改变通过改变数据要求 &lt;code&gt;variables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="690e2c556d1d75133f45a6c4a69283c5b06e6d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a &lt;a href=&quot;#connection&quot;&gt;&lt;code&gt;@connection&lt;/code&gt;&lt;/a&gt; for pagination. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="translated">&lt;code&gt;fragmentSpec&lt;/code&gt; ：通过GraphQL片段指定组件的数据要求。预期此处指定的片段之一将包含用于分页的&lt;a href=&quot;#connection&quot;&gt; &lt;code&gt;@connection&lt;/code&gt; &lt;/a&gt;。所需数据将作为与提供的片段形状匹配的道具在组件上可用。 &lt;code&gt;fragmentSpec&lt;/code&gt; 应该是一个对象，其键是prop名称，值是 &lt;code&gt;graphql&lt;/code&gt; 标记的片段。在此对象中指定的每个键将对应于可用于生成的Component的道具。</target>
        </trans-unit>
        <trans-unit id="3ebe3bc29a0cf52244f436e5b9f683f8e5e726a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="translated">&lt;code&gt;fragmentSpec&lt;/code&gt; ：通过GraphQL片段指定组件的数据要求。所需数据将作为与提供的片段形状匹配的道具在组件上可用。 &lt;code&gt;fragmentSpec&lt;/code&gt; 应该是一个对象，其键是prop名称，值是 &lt;code&gt;graphql&lt;/code&gt; 标记的片段。在此对象中指定的每个键将对应于可用于生成的Component的道具。</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; 使用片段声明组件的数据要求。</target>
        </trans-unit>
        <trans-unit id="f347d7322bb64c982a8914c374d1d9989d23caa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getConnectionFromProps&lt;/code&gt;: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the &lt;code&gt;fragmentSpec&lt;/code&gt;). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided &lt;code&gt;@connection&lt;/code&gt; directive. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getConnectionFromProps&lt;/code&gt; ：功能应该指示分页在其上连接，给定片段的道具（即，对应于道具 &lt;code&gt;fragmentSpec&lt;/code&gt; ）。在大多数情况下，这是必需的，因为中继无法自动告诉您要分页的连接（容器可以获取多个片段和连接，但只能分页其中之一）。如果未提供，则Relay将尝试根据提供的 &lt;code&gt;@connection&lt;/code&gt; 指令推断正确的连接进行分页。有关更多详细信息，请参见我们的&lt;a href=&quot;#pagination-example&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; 获取对包含在父片段中的容器片段的引用。</target>
        </trans-unit>
        <trans-unit id="cff5af6182f7fb8ef3f8ecccc18f0ba0cbe50adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragmentVariables&lt;/code&gt;: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination &lt;code&gt;query&lt;/code&gt;, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store &lt;em&gt;after&lt;/em&gt; the new pagination &lt;code&gt;query&lt;/code&gt; has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the &lt;code&gt;count&lt;/code&gt; variable. This option is analogous to &lt;a href=&quot;refetch-container#refetch&quot;&gt;&lt;code&gt;renderVariables&lt;/code&gt;&lt;/a&gt; in the Refetch Container. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getFragmentVariables&lt;/code&gt; ：该函数应返回一袋变量，用于在重新呈现组件时从存储中读取数据。此函数采用传递给分页 &lt;code&gt;query&lt;/code&gt; 的上一组变量，以及到目前为止总共已获取的元素数。具体来说，这表示在获取新的分页 &lt;code&gt;query&lt;/code&gt; &lt;em&gt;之后&lt;/em&gt;从本地数据存储中读取数据时要使用哪些变量。如果未指定，则Relay将默认使用所有先前的变量，并使用 &lt;code&gt;count&lt;/code&gt; 变量的总计数。此选项类似于&lt;a href=&quot;refetch-container#refetch&quot;&gt; &lt;code&gt;renderVariables&lt;/code&gt; &lt;/a&gt;容器中的renderVariables。看我们的&lt;a href=&quot;#pagination-example&quot;&gt;例子&lt;/a&gt; 更多细节。</target>
        </trans-unit>
        <trans-unit id="626651fb7fc8a336ea351887a559499388854ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getVariables&lt;/code&gt;: Function that should return the variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server, given the current &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;cursor&lt;/code&gt;. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getVariables&lt;/code&gt; ：在给定当前 &lt;code&gt;props&lt;/code&gt; ， &lt;code&gt;count&lt;/code&gt; 和 &lt;code&gt;cursor&lt;/code&gt; 的情况下，从服务器获取分页 &lt;code&gt;query&lt;/code&gt; 时应返回变量以传递给分页查询的函数。您可以在此处设置任何变量，也可以修改默认值以用于after / first / before / last参数。有关更多详细信息，请参见我们的&lt;a href=&quot;#pagination-example&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a5a41dfd716e53597f64c88977873298358ac32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates whether there are more pages to fetch from the server or not.</source>
          <target state="translated">&lt;code&gt;hasMore&lt;/code&gt; 是 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;道具&lt;/a&gt;上可用的功能。此功能指示是否还有更多页面要从服务器获取。</target>
        </trans-unit>
        <trans-unit id="1035c3f8ef8bea7423860896c5ab932f003bfcca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt;: See &lt;code&gt;hasMore&lt;/code&gt;&lt;a href=&quot;#hasmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasMore&lt;/code&gt; ：请参阅 &lt;code&gt;hasMore&lt;/code&gt; &lt;a href=&quot;#hasmore&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; 此组件的片段可用的初始变量值集。</target>
        </trans-unit>
        <trans-unit id="b0b6cb762b7bc1dde73e00ccfd867874ca46a854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates if a previous call to &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore()&lt;/code&gt;&lt;/a&gt; is still pending. This is convenient for avoiding duplicate load calls.</source>
          <target state="translated">&lt;code&gt;isLoading&lt;/code&gt; 是 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;道具&lt;/a&gt;上可用的功能。该函数指示是否仍未处理对&lt;a href=&quot;#loadmore&quot;&gt; &lt;code&gt;loadMore()&lt;/code&gt; &lt;/a&gt;的先前调用。这对于避免重复的加载调用很方便。</target>
        </trans-unit>
        <trans-unit id="c3cf1633778c794a6d5137a6fc7ee91e9dc015a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt;: See &lt;code&gt;isLoading&lt;/code&gt;&lt;a href=&quot;#isloading&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;isLoading&lt;/code&gt; ：请参阅 &lt;code&gt;isLoading&lt;/code&gt; &lt;a href=&quot;#isloading&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f96bf65801e1e45617b0b7293698801c726cb5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: &lt;strong&gt;Required&lt;/strong&gt; String that serves as a unique identifier for the connection under the parent field type. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; ：&lt;strong&gt;必需的&lt;/strong&gt;字符串，用作父字段类型下的连接的唯一标识符。一个好的做法是 &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699706e765e60007f25a7dad7551d2b11ce95c76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;loadMore()&lt;/code&gt; to fetch more items from the server based on the &lt;code&gt;connectionConfig&lt;/code&gt; provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.</source>
          <target state="translated">&lt;code&gt;loadMore&lt;/code&gt; 是 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;道具&lt;/a&gt;上可用的功能。您可以调用 &lt;code&gt;loadMore()&lt;/code&gt; ,以根据提供给容器的 &lt;code&gt;connectionConfig&lt;/code&gt; 从服务器获取更多项目。如果没有更多要提取的项目，则将返回null，否则它将获取更多的项目并返回可用于取消提取的Disposable。</target>
        </trans-unit>
        <trans-unit id="9fe3cacb8f804fae55fb785b3fe1234cd03400a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt;: See &lt;code&gt;loadMore&lt;/code&gt;&lt;a href=&quot;#loadmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;loadMore&lt;/code&gt; ：请参阅 &lt;code&gt;loadMore&lt;/code&gt; &lt;a href=&quot;#loadmore&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76264748ee4f7e2b85f5ec429b655faa6e2afb7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt;: Reads the results of a selector from the store, returning the value given the data currently in the store.</source>
          <target state="translated">&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt; ：从存储中读取选择器的结果，返回给定当前存储中数据的值。</target>
        </trans-unit>
        <trans-unit id="40b36321c1572c121ad403c4633eda3e50781805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的突变查询。</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的突变查询。</target>
        </trans-unit>
        <trans-unit id="8757e61c041c5769ac4b56cae5108d1ce8243f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(): void&lt;/code&gt;: Calls any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed due to intervening &lt;code&gt;publish()&lt;/code&gt;-es. Separating &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; allows for multiple payloads to be published before performing any downstream update logic (such as rendering).</source>
          <target state="translated">&lt;code&gt;notify(): void&lt;/code&gt; ：调用由于干预 &lt;code&gt;publish()&lt;/code&gt; - es而导致其结果已更改的任何subscription &lt;code&gt;subscribe()&lt;/code&gt; ers 。分开 &lt;code&gt;publish()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 允许在执行任何下游更新逻辑（例如渲染）之前发布多个有效负载。</target>
        </trans-unit>
        <trans-unit id="9bfa68e762b718f3167374497af4ce681b706e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: Callback function executed when the request is completed and the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt; function. Takes a &lt;code&gt;response&lt;/code&gt; object, which is the updated response from the store, and &lt;code&gt;errors&lt;/code&gt;, an array containing any errors from the server.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：在请求完成并且使用 &lt;code&gt;updater&lt;/code&gt; 功能更新内存中的中继存储时执行的回调函数。获取一个 &lt;code&gt;response&lt;/code&gt; 对象，该对象是来自商店的更新后的响应，以及一个 &lt;code&gt;errors&lt;/code&gt; ，一个包含服务器中所有错误的数组。</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：对等方关闭订阅而没有错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：使用更新 &lt;code&gt;updater&lt;/code&gt; 更新内存中的中继存储后，使用&amp;ldquo;原始&amp;rdquo;响应和服务器中的错误执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="6c178dbfaff171f363cbc5ee015a82adb2c39a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: Callback function executed if Relay encounters an error during the request.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：如果中继在请求期间遇到错误，则执行回调函数。</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：当Relay遇到错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：当Relay或服务器在处理订阅时遇到错误时执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; 如果突变失败，则调用onFailure。</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; ：每次从服务器收到响应时使用原始GraphQL响应有效负载执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; 如果突变成功，则调用onSuccess。</target>
        </trans-unit>
        <trans-unit id="f106ec445789577b27b8a00bf7ea0a1de269df16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the &lt;code&gt;optimisticResponse&lt;/code&gt; data to update the fields on the relevant records in the local data store, &lt;em&gt;before&lt;/em&gt;&lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：包含数据的对象，用于乐观地更新本地内存存储，即在变异请求完成之前立即更新。该对象必须具有与GraphQL架构定义的突变的响应类型相同的形状。如果提供，接力将使用 &lt;code&gt;optimisticResponse&lt;/code&gt; 数据以更新相关记录的字段在本地数据存储，&lt;em&gt;之前&lt;/em&gt; &lt;code&gt;optimisticUpdater&lt;/code&gt; 执行。如果在变异请求期间发生错误，乐观更新将被回滚。</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：符合突变的响应类型定义的对象。如果提供的话，乐观响应将在执行 &lt;code&gt;optimisticUpdater&lt;/code&gt; 之前标准化为代理存储。我们建议您为两个好处提供一个 &lt;code&gt;optimisticResponse&lt;/code&gt; 的响应：</target>
        </trans-unit>
        <trans-unit id="bbad0ba283ad50214764ae5e67837a37a21bb012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;. &lt;strong&gt;Please note:&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：用于乐观地更新本地内存存储的功能，即在变异请求完成之前立即更新。如果在变异请求期间发生错误，乐观更新将被回滚。此功能需要一个 &lt;code&gt;store&lt;/code&gt; ，该存储是内存中的&lt;a href=&quot;relay-store&quot;&gt;中继存储&lt;/a&gt;的代理。在此功能中，客户端通过 &lt;code&gt;store&lt;/code&gt; 实例定义&amp;ldquo;如何&amp;rdquo;更新本地数据。有关如何使用 &lt;code&gt;store&lt;/code&gt; 详细信息，请参阅我们的&lt;a href=&quot;relay-store&quot;&gt;中继商店API参考&lt;/a&gt;。&lt;strong&gt;请注意：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：一个函数，用于接收内存中中继存储的代理。在此功能中，客户端以命令方式定义&amp;ldquo;如何&amp;rdquo;通过代理更新商店。</target>
        </trans-unit>
        <trans-unit id="5c56eae08c5039c703ead5297dcb43b136ebc215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: Optional object containing set of options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; ：包含选项集的可选对象。</target>
        </trans-unit>
        <trans-unit id="6f1ee884cdcbedfd5023f2b423e04d3d21c8d4a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pageSize&lt;/code&gt;: The number of &lt;strong&gt;additional&lt;/strong&gt; items to fetch (not the total).</source>
          <target state="translated">&lt;code&gt;pageSize&lt;/code&gt; ：要提取的&lt;strong&gt;其他&lt;/strong&gt;项目数（不是总数）。</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; ：包含连接的父节点的DataID。</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; ：一个数组，其中包含父级和连接之间的字段名称，包括父级和连接。</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; 包含用于获取新道具的变量集，即，当 &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; 或 &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; 并且相应的请求正在执行中时。</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; 一种基于运行时环境或以前的变量值修改变量的方法。</target>
        </trans-unit>
        <trans-unit id="27da47c52c7e5a8a5a90e5286ef17b4aff5e91dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt;: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; ：包含从查询获得的数据的对象；该对象的形状将与查询的形状匹配。如果未定义此对象，则意味着仍在获取数据。</target>
        </trans-unit>
        <trans-unit id="8d5f419565d76e695cd1691d3b10750a870140ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt;: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new &lt;code&gt;RecordSource&lt;/code&gt; instance and ultimately publish it to the store. Note that &lt;code&gt;publish()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; immediately update any &lt;code&gt;subscribe()&lt;/code&gt;-ers. Internally, the store compares the new &lt;code&gt;RecordSource&lt;/code&gt; with its internal source, updating it as necessary:</source>
          <target state="translated">&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt; ：用新信息更新商店。商店的所有更新都以这种形式表示，包括查询/更改/订阅的结果以及乐观的更改更新。所有这些操作在内部创建一个新的 &lt;code&gt;RecordSource&lt;/code&gt; 实例，并最终将其发布到商店。需要注意的是 &lt;code&gt;publish()&lt;/code&gt; 并&lt;em&gt;不会&lt;/em&gt;立即更新任何 &lt;code&gt;subscribe()&lt;/code&gt; -ers。在内部，商店将新的 &lt;code&gt;RecordSource&lt;/code&gt; 及其内部源进行比较，并根据需要进行更新：</target>
        </trans-unit>
        <trans-unit id="dddbd60d4182ffffea94bf3a02f0ae852dd10463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be used as the pagination query to fetch more data upon calling &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ：一个 &lt;code&gt;graphql&lt;/code&gt; 标记的查询，用作分页查询，以在调用&lt;a href=&quot;#loadmore&quot;&gt; &lt;code&gt;loadMore&lt;/code&gt; &lt;/a&gt;时获取更多数据。</target>
        </trans-unit>
        <trans-unit id="7736ddcb416c3d04d04b11455e591b874d6eeb31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的查询。&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; 强制将查询命名为 &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="676a2960bbec143afaff222f0801213498fb3f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;. Optional, if not provided, an empty &lt;code&gt;props&lt;/code&gt; object is passed to the &lt;code&gt;render&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的查询。&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; 强制将查询命名为 &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt; 。可选，如果未提供，则将一个空的 &lt;code&gt;props&lt;/code&gt; 对象传递给 &lt;code&gt;render&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; 定义查询根的&amp;ldquo; QueryConfig&amp;rdquo;或&amp;ldquo; Relay.Route&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="660ec684b77a45a8bf1e84dae51a6cda4f520d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; 具有以下签名：</target>
        </trans-unit>
        <trans-unit id="58466669d85d4a95720a5f7d66d78440d31839cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt; which can be used to execute the &lt;code&gt;refetchQuery&lt;/code&gt; and potentially re-render the component with the newly fetched data. Specifically, upon fetching the &lt;code&gt;refetchQuery&lt;/code&gt;, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; 是 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;道具&lt;/a&gt;上可用的功能，可用于执行 &lt;code&gt;refetchQuery&lt;/code&gt; 并可能使用新获取的数据重新呈现组件。具体而言，在获取 &lt;code&gt;refetchQuery&lt;/code&gt; 时，其结果将被规范化到存储中，并且将触发与已更改的记录相关联的任何相关订阅，从而导致重新呈现相关组件。</target>
        </trans-unit>
        <trans-unit id="ac65c56250fa7ff709fdc7de7fca9f97dfd96bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt;: See &lt;code&gt;refetch&lt;/code&gt;&lt;a href=&quot;#refetch&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; ：请参阅 &lt;code&gt;refetch&lt;/code&gt; &lt;a href=&quot;#refetch&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76ca6f4f7119df5fafa685e8fb3699107703e078" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;refetchConnection&lt;/code&gt; to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt;. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.</source>
          <target state="translated">&lt;code&gt;refetchConnection&lt;/code&gt; 是 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;道具&lt;/a&gt;上可用的功能。您可以调用 &lt;code&gt;refetchConnection&lt;/code&gt; 从头开始在连接上重新启动分页，并可以选择使用一组全新的变量传递给分页 &lt;code&gt;query&lt;/code&gt; 。例如，如果您要基于用户ID对集合进行分页并且用户ID发生更改，而您想开始为新用户对新集合进行分页，则此功能非常有用。</target>
        </trans-unit>
        <trans-unit id="7ef81b21678260e29c69b60a2bcfd25a86847861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt;: See &lt;code&gt;refetchConnection&lt;/code&gt;&lt;a href=&quot;#refetchconnection&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;refetchConnection&lt;/code&gt; ：请参阅 &lt;code&gt;refetchConnection&lt;/code&gt; &lt;a href=&quot;#refetchconnection&quot;&gt;文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10676cecd666f761ab642682bd7775c74b16d502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchQuery&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be fetched upon calling &lt;a href=&quot;#refetch&quot;&gt;&lt;code&gt;props.relay.refetch&lt;/code&gt;&lt;/a&gt;. As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.</source>
          <target state="translated">&lt;code&gt;refetchQuery&lt;/code&gt; ：一个在调用&lt;a href=&quot;#refetch&quot;&gt; &lt;code&gt;props.relay.refetch&lt;/code&gt; 时&lt;/a&gt;要提取的 &lt;code&gt;graphql&lt;/code&gt; 标记的查询。与任何查询一样，在获取此查询时，其结果将被规范化到存储中，与已更改的记录相关联的所有相关订阅都将被触发，并且订阅的组件将重新呈现。</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; 是一袋变量，或者是一个函数，它接受以前的片段变量并返回新变量。</target>
        </trans-unit>
        <trans-unit id="d29742cf5cf442b9264eba2a1008fd847c52bb3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="82c4436a668f413322c65f8837cdeba1c55ebf58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;: A potentially new bag of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; ：从服务器获取分页 &lt;code&gt;query&lt;/code&gt; 时可能会传递给分页查询的潜在新变量。</target>
        </trans-unit>
        <trans-unit id="eccac01b26009021b9b8585de4682fa623cd62b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relay&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;relay&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 在满足数据需求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="3a3d4b8d0af15655fd443916c3671fd28e5c8260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: Function of type &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt;. The output of this function will be rendered by the &lt;code&gt;QueryRenderer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; ：类型的函数 &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt; 。该函数的输出将由 &lt;code&gt;QueryRenderer&lt;/code&gt; 呈现。</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; 在数据未能实现时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 在满足数据要求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; 在满足数据要求时调用以呈现。</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; 是一个可选参数，用于告诉Relay在提取后重新呈现组件时要在哪个变量中使用。如果没有这一点， &lt;code&gt;refetchVariables&lt;/code&gt; 将被使用。您可以将其用于更高级的用法，例如，实现分页，在该页面中，您将获取一个包含诸如 &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; 类的变量的附加页面，但随后您将使用 &lt;code&gt;{first: 10}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d435346ad63d7a3c79570642e3436876c685e77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt;: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store &lt;em&gt;after&lt;/em&gt; the new query has been fetched. If not specified, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt;, but you might want to render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; ：可选的变量包，用于指示在重新渲染组件时使用哪些变量从存储中读取数据。具体来说，这表示在获取新查询&lt;em&gt;之后&lt;/em&gt;从本地数据存储中查询数据时要使用哪些变量。如果未指定，将使用 &lt;code&gt;refetchVariables&lt;/code&gt; 。当您需要在组件中呈现的数据不一定与您向服务器查询的数据匹配时，这很有用。例如，要实现分页，您将使用诸如 &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt; 类的变量来获取页面，之后是'&amp;lt;cursor&amp;gt;'}，但您可能希望使用 &lt;code&gt;{first: 10}&lt;/code&gt; 来呈现完整集合。</target>
        </trans-unit>
        <trans-unit id="e8a7275c94b7363157c7bfb49920e6d9a95cf6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt;: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.</source>
          <target state="translated">&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt; ：确保满足给定选择器的所有必要记录都保留在内存中。在处理返回的引用之前，这些记录将不符合垃圾收集的条件。</target>
        </trans-unit>
        <trans-unit id="d6d78182a7d6ce562110f2264694e37c53c96b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt;: Reload the data. It is null if &lt;code&gt;query&lt;/code&gt; was not provided.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; ：重新加载数据。如果未提供 &lt;code&gt;query&lt;/code&gt; ，则为null 。</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; 定义查询根的路由。</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; 不会立即对 &lt;code&gt;variables&lt;/code&gt; 突变，但会创建一个挂起的状态转换。 &lt;code&gt;variables&lt;/code&gt; 将继续返回以前的值，直到用满足新变量值的数据填充 &lt;code&gt;this.props&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; (可选）重写RelayContainer的默认参数&amp;ldquo; shouldComponentUpdate&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; 一个prop类型验证器，它声明prop是有效的Relay容器。</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; 一个prop类型验证器，它断言prop是有效的路由。</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; 向队列添加MutationTransaction而不提交它。</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; 启动对变异的处理。</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; 创建静态变异</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; 创建一个中继容器。</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; 创建一个接受&amp;ldquo;文件&amp;rdquo;对象的静态变异</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; 此声明此突变的数据依赖性</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; 一组默认变量，可用于此突变的片段构建器</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; 定制如何将查询和变异发送到服务器。</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; 配置何时进行中继处理。</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; 确定给定对象是否是Relay.Container。</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; 声明期望的参数。</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; 声明其他参数或参数的转换。</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; 一种基于运行时环境，先前的变量或元路由来修改变量的方法</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; 声明查询根的集合。</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; 声明此路由类的名称。</target>
        </trans-unit>
        <trans-unit id="4d2883724190fe655277a940ee21fbf4028c5557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt;: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.</source>
          <target state="translated">&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt; ：订阅对选择器结果的更改。当数据发布到存储中会导致快照选择器的结果发生更改时，将调用该回调。</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; 标记的订阅查询。</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; 可以调用this.props.relay.setVariables来同时更新子集或所有变量。作为回报，Relay将使用新变量来尝试实现新片段。如果客户端上尚不可用数据，则这可能涉及向服务器发送请求。</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 导出以下API以执行refetch查询：</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 公开以下API：</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 旧API中的this.props.setVariables在新API中没有直接等效项。进行此更改的一个主要原因是，新内核不再跟踪如何从查询中重新获取任何特定的子树。这使新内核快得多，但是需要显式查询以获取新数据。查看以下四种不同的情况：</target>
        </trans-unit>
        <trans-unit id="63392efb72105686affa5267c72c15150a57d7b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;totalCount&lt;/code&gt;: The total number of elements to fetch</source>
          <target state="translated">&lt;code&gt;totalCount&lt;/code&gt; ：要获取的元素总数</target>
        </trans-unit>
        <trans-unit id="a3ba6c9e4640fb1b2e64f085573522ecee404aff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt; and &lt;code&gt;optimisticUpdater&lt;/code&gt; are functions that you can pass to a &lt;code&gt;commitMutation&lt;/code&gt; call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; 和 &lt;code&gt;optimisticUpdater&lt;/code&gt; 是可以在需要乐观地或基于服务器响应来控制如何更新本地数据存储时完全传递给 &lt;code&gt;commitMutation&lt;/code&gt; 调用的函数。通常，这两个功能可能都相同。</target>
        </trans-unit>
        <trans-unit id="259e28d5505528a6b53e6871c75fe6204e8b732e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: Function used to update the local in-memory store based on the &lt;strong&gt;real&lt;/strong&gt; server response from the mutation. If &lt;code&gt;updater&lt;/code&gt; is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an &lt;code&gt;updater&lt;/code&gt; if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and will then execute &lt;code&gt;updater&lt;/code&gt;. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data based on the server response via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：用于根据来自突变的&lt;strong&gt;真实&lt;/strong&gt;服务器响应来更新本地内存存储的功能。如果未提供 &lt;code&gt;updater&lt;/code&gt; 则默认情况下，中继将知道自动更新变异响应中引用的记录上的字段；但是，如果您需要进行的更新不仅限于更新字段（例如，删除记录或向集合中添加项目），还应该通过 &lt;code&gt;updater&lt;/code&gt; 。当服务器响应返回时，Relay首先还原由 &lt;code&gt;optimisticUpdater&lt;/code&gt; 或 &lt;code&gt;optimisticResponse&lt;/code&gt; 引入的所有更改，然后将执行 &lt;code&gt;updater&lt;/code&gt; 。此函数需要一个 &lt;code&gt;store&lt;/code&gt; ，它是内存中的代理&lt;a href=&quot;relay-store&quot;&gt;中继商店&lt;/a&gt;。在此功能中，客户端根据服务器通过 &lt;code&gt;store&lt;/code&gt; 实例的响应来定义&amp;ldquo;如何&amp;rdquo;更新本地数据。有关如何使用 &lt;code&gt;store&lt;/code&gt; 详细信息，请参阅我们的&lt;a href=&quot;relay-store&quot;&gt;中继商店API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：基于&lt;strong&gt;真实&lt;/strong&gt;服务器响应更新内存中中继存储的功能。当服务器响应返回时，中继首先还原由 &lt;code&gt;optimisticUpdater&lt;/code&gt; 或 &lt;code&gt;optimisticResponse&lt;/code&gt; 引入的所有更改，然后将 &lt;code&gt;updater&lt;/code&gt; 应用于存储。</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：可选功能，可以提供自定义逻辑，用于基于服务器响应来更新内存中的中继存储。</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; 包含用于获取当前道具集的变量集。</target>
        </trans-unit>
        <trans-unit id="90132fff5a43a587dfddbf62f547768d85225cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：包含要传递给GraphQL查询的变量集的对象，即从变量名到值的映射。</target>
        </trans-unit>
        <trans-unit id="9b2d4dca964b4002488e5ba0931c7fdd0e1843a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. &lt;strong&gt;Note:&lt;/strong&gt; If a new set of variables is passed, the &lt;code&gt;QueryRenderer&lt;/code&gt; will re-fetch the query.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：包含要传递给GraphQL查询的变量集的对象，即从变量名到值的映射。&lt;strong&gt;注意：&lt;/strong&gt;如果传递了一组新的变量，则 &lt;code&gt;QueryRenderer&lt;/code&gt; 将重新获取查询。</target>
        </trans-unit>
        <trans-unit id="0475335b0b11da8a5bdf97828dbf873aa0e03035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing the variables needed for the mutation. For example, if the mutation defines an &lt;code&gt;$input&lt;/code&gt; variable, this object should contain an &lt;code&gt;input&lt;/code&gt; key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：包含突变所需变量的对象。例如，如果变异定义了 &lt;code&gt;$input&lt;/code&gt; 变量，则此对象应包含一个 &lt;code&gt;input&lt;/code&gt; 键，其形状必须与GraphQL架构定义的变异所期望的数据形状匹配。</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：一个对象，其中包含突变所需的变量。</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：一个对象，其中包含预订所需的变量。</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; 已弃用。将&lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt;与Relay Classic一起使用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;容器规格&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;属性和方法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;静态方法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-up&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;EXPRESS-graphql&lt;/a&gt;&lt;/strong&gt;上&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt; graphql-relay-js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cf00569ac1dc01caeaaea97e38c45c13b4f2663" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;react-relay-network-modern&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt;npm&lt;/a&gt; - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;&lt;/a&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt;npm&lt;/a&gt;上的&lt;strong&gt;react-relay-network-&lt;/strong&gt; modern-是Relay Modern的网络层，具有内置的高度可定制的中间件，可用于常见情况：批处理查询请求，缓存，身份验证，请求重试，日志记录。此外，您可以使用自定义逻辑编写自己的中间件。</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt;（&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;快速入门教程&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;乐观更新只能应用一次。</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;this.props.relay&lt;/code&gt; 道具上还提供了等效的 &lt;code&gt;applyUpdate&lt;/code&gt; 和 &lt;code&gt;commitUpdate&lt;/code&gt; 方法，该道具由 &lt;code&gt;Relay.Container&lt;/code&gt; 传递给组件。这些分派突变是在当前活动的 &lt;code&gt;Relay.Environment&lt;/code&gt; 的上下文中。</target>
        </trans-unit>
        <trans-unit id="9ddd68157613fe72f3a31d973424adc5689fd03d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The relay-compiler will maintain any directives supported by your server (such as &lt;code&gt;@include&lt;/code&gt; or &lt;code&gt;@skip&lt;/code&gt;) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;中继编译器将维护服务器支持的所有指令（例如 &lt;code&gt;@include&lt;/code&gt; 或 &lt;code&gt;@skip&lt;/code&gt; ），因此它们仍是对GraphQL服务器的请求的一部分，并且不会更改生成的运行时工件。</target>
        </trans-unit>
        <trans-unit id="9339553ac0cb3d1045417a0b2b8896e539d03c5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;refetch&lt;/code&gt; is meant to be used for changing variables in the component's fragment. Specifically, in order for &lt;em&gt;this&lt;/em&gt; component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using &lt;code&gt;refetch&lt;/code&gt; to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;refetch&lt;/code&gt; 用于更改组件片段中的变量。具体而言，为了重新呈现&lt;em&gt;此&lt;/em&gt;组件，必须订阅&lt;em&gt;该&lt;/em&gt;组件以使其受到此查询影响的记录中的更改。如果该组件的片段不使用变量，则该组件将不会订阅对该查询可能获取的新记录的更改。一个常见的例子是使用 &lt;code&gt;refetch&lt;/code&gt; 来获取一个新节点，并使用该新节点的数据重新渲染组件。在这种情况下，该片段需要使用变量作为节点的ID，否则该组件将无法接收新节点的更改。</target>
        </trans-unit>
        <trans-unit id="fce6daad416ee7ed28c950cdb80e05140a6ea38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces fragments to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; 强制将片段命名为 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cab013d8e57c0158f4b400d4d762529e18b3a5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at &lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETE&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这不会从可能存在的任何连接中删除它。如果要从连接中删除节点，请查看&lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0b283c8b5fe80a6754d48027d166c1b33cf5b5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React/Relay:&lt;/strong&gt; A high-level &lt;em&gt;product API&lt;/em&gt; that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).</source>
          <target state="translated">&lt;strong&gt;React / Relay：&lt;/strong&gt;一种高级&lt;em&gt;产品API&lt;/em&gt;，将Relay Runtime与React集成在一起。对于大多数产品开发人员而言，这是Relay的主要公共接口，具有API来获取查询数据或为可重用组件（也称为容器）定义数据相关性。</target>
        </trans-unit>
        <trans-unit id="efdd8302b44cc971aea46ff3458176ce0281a174" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Compiler:&lt;/strong&gt; A GraphQL to GraphQL optimizing &lt;em&gt;compiler&lt;/em&gt;, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.</source>
          <target state="translated">&lt;strong&gt;中继编译器：&lt;/strong&gt;从GraphQL到GraphQL的优化&lt;em&gt;编译器&lt;/em&gt;，提供用于转换和优化查询以及生成构建工件的通用实用程序。编译器的一个新颖功能是通过使用自定义指令的形式轻松地将使用这些指令的代码转换为符合规范的标准GraphQL，从而简化了GraphQL新功能的试验。</target>
        </trans-unit>
        <trans-unit id="c4b7a80e6d04a3ccce4e25ffec6090751cc2e7f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Runtime:&lt;/strong&gt; A full-featured, high-performance GraphQL &lt;em&gt;runtime&lt;/em&gt; that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized &quot;write&quot; and &quot;read&quot; operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.</source>
          <target state="translated">&lt;strong&gt;中继运行时：&lt;/strong&gt;功能齐全的高性能GraphQL&lt;em&gt;运行时&lt;/em&gt;，可用于构建更高级别的客户端API。运行时具有标准化的对象缓存，优化的&amp;ldquo;写入&amp;rdquo;和&amp;ldquo;读取&amp;rdquo;操作，用于增量获取字段数据（例如用于分页）的通用抽象，用于删除未引用的缓存条目的垃圾收集，具有任意逻辑的乐观突变，对构建的支持订阅和实时查询等。</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container&lt;/strong&gt;允许组件声明片段。</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer&lt;/strong&gt;替代了 &lt;code&gt;Relay.RootContainer&lt;/code&gt; ，后者构成了 &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; 并为给定的 &lt;code&gt;queryConfig&lt;/code&gt; 执行数据获取。</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;接受三个可选的回调作为道具，它们使我们可以更精细地控制渲染行为。</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;还支持 &lt;code&gt;onReadyStateChange&lt;/code&gt; 道具，该道具使我们可以在满足数据要求的同时接收细粒度的事件。</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;是一个React组件，它试图完成所需的数据，以便呈现给定 &lt;code&gt;route&lt;/code&gt; 的 &lt;code&gt;Component&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;是一个React组件，在给定 &lt;code&gt;Component&lt;/code&gt; 和 &lt;code&gt;route&lt;/code&gt; ，它试图满足渲染 &lt;code&gt;Component&lt;/code&gt; 实例所需的数据。</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;每当无法立即完成渲染所需的数据时，&lt;strong&gt;就会&lt;/strong&gt;渲染加载状态。这通常发生在初始渲染中，但是如果 &lt;code&gt;Component&lt;/code&gt; 或 &lt;code&gt;route&lt;/code&gt; 发生更改，也可能发生。</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route&lt;/strong&gt;让我们声明查询根。</target>
        </trans-unit>
        <trans-unit id="c9948e83f56c83dcc4c3f5e36e015ebfe88bc455" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React Component at the root of a Relay component tree. It takes a query, fetches the given query, and uses the &lt;code&gt;render&lt;/code&gt; prop to render the resulting data.</source>
          <target state="translated">甲 &lt;code&gt;QueryRenderer&lt;/code&gt; 处于继电器组件树的根阵营组件。它接受一个查询，获取给定的查询，并使用 &lt;code&gt;render&lt;/code&gt; 属性来渲染结果数据。</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">一个 &lt;code&gt;QueryRenderer&lt;/code&gt; 是一个阵营组成部分，因此它可以在任何地方呈现一个阵营组件可以呈现，而不是仅仅在顶层。甲 &lt;code&gt;QueryRenderer&lt;/code&gt; 可以呈现&lt;em&gt;内&lt;/em&gt;其他中继部件，例如用于一个酥料饼到懒惰地提取附加数据。但是， &lt;code&gt;QueryRenderer&lt;/code&gt; 在挂载之前不会开始加载其数据，因此，如果不必要地使用嵌套的 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件，则会导致可避免的请求瀑布。</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">一个 &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 配置用于附加的儿童追加到突变查询。例如，您可能需要使用它来获取由该突变创建的新对象上的字段（并且中继通常不会尝试获取该对象，因为该对象先前没有为该对象获取任何东西）。</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">一个 &lt;code&gt;RefetchContainer&lt;/code&gt; 第一呈现像一个普通的&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt;，但必须执行不同的变量，一个新的查询和渲染该查询的响应，而不是当请求回来的选项。</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">一个 &lt;code&gt;renderLoading&lt;/code&gt; 回调可以返回模拟的默认行为 &lt;code&gt;undefined&lt;/code&gt; 。请注意，这与返回 &lt;code&gt;null&lt;/code&gt; 的 &lt;code&gt;renderLoading&lt;/code&gt; 回调不同，该回调将在加载数据时不呈现任何内容，即使存在先前的视图也是如此。</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="961bc4600b75e68461ede605310ceced00dd4863" translate="yes" xml:space="preserve">
          <source>A Fragment Container is a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that allows components to specify their data requirements. A container does not directly fetch data, but instead declares a &lt;em&gt;specification&lt;/em&gt; of the data needed for rendering, and then Relay will guarantee that this data is available &lt;em&gt;before&lt;/em&gt; rendering occurs.</source>
          <target state="translated">片段容器是一个&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;高阶组件&lt;/a&gt;，它允许组件指定其数据要求。容器不直接获取数据，而是声明渲染所需数据的&lt;em&gt;规范&lt;/em&gt;，然后Relay将保证&lt;em&gt;在&lt;/em&gt;渲染发生&lt;em&gt;之前&lt;/em&gt;该数据可用。</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">一个GraphQL方案</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">一个GraphQL服务器</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">GraphQL模式描述您的数据模型，并为GraphQL服务器提供一组关联的解析方法，这些方法知道如何获取数据。我们将使用&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;和&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;构建我们的模式。</target>
        </trans-unit>
        <trans-unit id="48b78b689c15abba06f0159436cde03009fad264" translate="yes" xml:space="preserve">
          <source>A Refetch Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that works like a regular &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result.</source>
          <target state="translated">Refetch Container也是一个&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;高阶组件&lt;/a&gt;，其工作方式与常规&lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;相似，但提供了额外的功能，以获取具有不同变量的新GraphQL查询并以新结果重新呈现该组件。</target>
        </trans-unit>
        <trans-unit id="bc6cdf397779ac0008665fa5d7d262a02b419170" translate="yes" xml:space="preserve">
          <source>A bag of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">从服务器获取时，将一袋变量传递给 &lt;code&gt;refetchQuery&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">说明如何在连接中翻页。</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">对你的数据模型的描述,以及一组相关的解析方法,这些方法知道如何获取你的应用程序可能需要的任何数据。</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">在星球大战宇宙中,一个派系有很多舰船。Relay包含的功能使操作一对多关系变得简单,使用一种标准化的方式来表达这些一对多关系。这种标准的连接模型提供了通过连接进行切片和分页的方法。</target>
        </trans-unit>
        <trans-unit id="af85210772abecb804d78217a7325698b05fe83e" translate="yes" xml:space="preserve">
          <source>A generic mechanism for intercepting data prior to publishing it to the cache and either synthesizing new data or merging new and existing data together (which among other things enables the creation of a variety of pagination schemes).</source>
          <target state="translated">一种通用机制,用于在将数据发布到缓存之前截取数据,并合成新的数据或将新数据和现有数据合并在一起(除其他外,可以创建各种分页方案)。</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">响应中的 &lt;code&gt;fieldName&lt;/code&gt; 与商店中的一个或多个DataID 之间的映射。</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">&lt;em&gt;在按字母顺序&lt;/em&gt;打印，按点分隔的GraphQL调用与我们希望Relay表现出来的行为之间的映射，这些行为是在那些调用或接受连接参数数组的函数的影响下向连接添加新边时返回的行为。</target>
        </trans-unit>
        <trans-unit id="df6534fbc976a915dd2ab9e7fdb121c13f0a1f35" translate="yes" xml:space="preserve">
          <source>A mechanism for reading data from the cache and subscribing for updates when these results change due to a mutation, subscription update, etc.</source>
          <target state="translated">当这些结果因突变、订阅更新等原因发生变化时,从缓存中读取数据并订阅更新的机制。</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">重取对象的机制。</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">建议为片段使用 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 的命名约定。从经典API迁移到现代API时需要此限制，以实现交叉兼容性。</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">规范化的缓存可确保&lt;em&gt;缓存&lt;/em&gt;保持一致。但是我们的看法呢？理想情况下，我们的React视图将始终反映缓存中的当前信息。</target>
        </trans-unit>
        <trans-unit id="ae22c4f42331ba6c74de6dc551bc9f18b6a1ae62" translate="yes" xml:space="preserve">
          <source>A normalized, in-memory object graph/cache.</source>
          <target state="translated">一个规范化的、内存中的对象图/缓存。</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;在测试套件中&lt;/a&gt;可以找到许多更详细的用法示例。</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">父组件将传递对某些 &lt;code&gt;User&lt;/code&gt; &amp;ldquo;记录&amp;rdquo; 的引用。</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;支持旧版浏览器的Relay的多填充环境可能类似于：</target>
        </trans-unit>
        <trans-unit id="d9c2b7e55915b27a1958903b288baadab9b9ebc4" translate="yes" xml:space="preserve">
          <source>A query like the following:</source>
          <target state="translated">像下面这样的查询:</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">用于翻译Relay Classic和Relay Modern APIs的参考。</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">一个简单的数据库</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">一个更简单、更可预测的突变API。还删除了Relay Classic中对突变查询的限制:突变查询是静态的,字段可以任意嵌套,并且可以使用任意参数。</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">一个标准的响应是&amp;ldquo;只使用不可变的数据结构&amp;rdquo;，但让我们看看如果这样做：</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">对Relay Modern的改进和新功能的总结。</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">寻宝的工作副本可以在&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;接力范例&lt;/a&gt;库中找到。</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">API工作表</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API和运行时</target>
        </trans-unit>
        <trans-unit id="30decd745bda6efb9c328a25620c92f31665d9ed" translate="yes" xml:space="preserve">
          <source>Accessing a plain connection field like this is the same as other regular field:</source>
          <target state="translated">访问这样的普通连接字段和其他普通字段一样。</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">实现视图的一致性</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">在您的.babelrc文件的插件列表中添加 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 。如果升级现有的中继应用程序，请参阅&lt;a href=&quot;babel-plugin-relay&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">将该变量添加到使用该片段的查询中,并在获取查询时将其传入。对于这一点,拥有一个包含你的产品的变量集合的模块是很有用的。</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">添加一个 &lt;code&gt;handlerProvider&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">附加选项</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">此外，您需要一个包含 &lt;code&gt;.js&lt;/code&gt; 文件的目录，该文件使用 &lt;code&gt;graphql&lt;/code&gt; 标记描述GraphQL查询和片段。我们称它为 &lt;code&gt;./src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">高级突变实例</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">高级用法</target>
        </trans-unit>
        <trans-unit id="65b03cca363991c35ae10c0088f588b27ac28625" translate="yes" xml:space="preserve">
          <source>After global invalidation, any query that is checked before refetching it will be considered stale:</source>
          <target state="translated">在全局无效后,任何在重取之前被检查过的查询都将被认为是陈旧的。</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">最初获取此故事后，我们的缓存可能如下。请注意，故事和评论都链接到与 &lt;code&gt;author&lt;/code&gt; 相同的记录：</target>
        </trans-unit>
        <trans-unit id="f2dd7e26249b6d8637a717ed4d6b92305ed4d8d7" translate="yes" xml:space="preserve">
          <source>After invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:</source>
          <target state="translated">在无效记录后,任何引用无效记录的查询以及在重新获取记录前被检查的查询都将被认为是陈旧的。</target>
        </trans-unit>
        <trans-unit id="20d5e5845a458c2e48e4a1e3d9fcce05c093f36b" translate="yes" xml:space="preserve">
          <source>After the network comes back, if any optimistic update was applied, it will be rolled back.</source>
          <target state="translated">在网络恢复后,如果应用了任何乐观的更新,将被回滚。</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">所有的数据都是一次往返获取的。</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">到目前为止,我们进行的所有突变都是在更新客户端存储之前等待服务器的响应。Relay为我们提供了一个机会,让我们可以根据我们对服务器在突变成功时的响应预期,制作一个相同形状的乐观响应。</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">或者，也可以使用&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">另外，您可以全局安装 &lt;code&gt;relay-compiler&lt;/code&gt; ，这样就可以直接访问它：</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">虽然响应是分层的,但我们将通过扁平化所有记录来缓存。下面是一个Relay如何缓存这个查询响应的例子。</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">我们收到很多问题的一个领域是突变及其配置。Relay Modern引入了一个新的突变API,允许以更直接的方式更新记录和字段。</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">包含父节点和连接之间的字段名的数组,包括父节点和连接。</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">使用 &lt;code&gt;fetch&lt;/code&gt; 的示例如下所示：</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-environment&quot;&gt;中继环境&lt;/a&gt;的实例封装了GraphQL数据的内存缓存和网络层，该层提供对GraphQL服务器的访问。开发人员通常不直接使用Environment对象，而是将其传递给每个&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;，后者使用环境来访问，修改和获取数据。在容器内，可以通过 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 访问当前环境。这是最常用于&lt;a href=&quot;mutations&quot;&gt;执行突变的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">符合 &lt;code&gt;Relay.Environment&lt;/code&gt; 接口的对象，例如 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31091cd5447f1a5facd7ba679b86a188b803a23a" translate="yes" xml:space="preserve">
          <source>An optimized &quot;write&quot; operation for updating the cache with the results of queries/mutations/subscriptions.</source>
          <target state="translated">一个优化的 &quot;写 &quot;操作,用于用查询/变异/订阅的结果更新缓存。</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">可以提供可选的 &lt;code&gt;onReadyStateChange&lt;/code&gt; 回调以响应与数据实现有关的事件。</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">这里有一个可能的回应。</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">而这个片段就可以用来定义Story容器。</target>
        </trans-unit>
        <trans-unit id="4dfa35597a4d927f5cbf51a45486138efe15e61b" translate="yes" xml:space="preserve">
          <source>Another way to enable optimistic updates is via the &lt;code&gt;optimisticUpdater&lt;/code&gt;, which can be used for more complicated update scenarios. Using &lt;code&gt;optimisticUpdater&lt;/code&gt; is covered in the section &lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">启用乐观更新的另一种方法是通过 &lt;code&gt;optimisticUpdater&lt;/code&gt; ，它可以用于更复杂的更新方案。&lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;以下&lt;/a&gt;部分介绍了如何使用 &lt;code&gt;optimisticUpdater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="880246192858f60438eac48b83d096fc7d5b0a5d" translate="yes" xml:space="preserve">
          <source>Any arguments defined inside &lt;code&gt;@argumentDefinitions&lt;/code&gt; will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.</source>
          <target state="translated">&lt;code&gt;@argumentDefinitions&lt;/code&gt; 内部定义的任何参数都是片段范围内可用的局部变量。但是，片段也可以引用在根查询中定义的全局变量。</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">有效载荷中的任何字段,如果可以通过DataID与客户端存储中的一条或多条记录相关联,将与存储中的记录合并。</target>
        </trans-unit>
        <trans-unit id="0fefe11020485e10d8f3308edf7710a3715bb28f" translate="yes" xml:space="preserve">
          <source>Any fields specified in the client schema, can be fetched from the &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;, by selecting it in a query or fragment.</source>
          <target state="translated">通过在查询或片段中选择&lt;a href=&quot;relay-store&quot;&gt;中继&lt;/a&gt;模式，可以从中继存储中获取客户端模式中指定的任何字段。</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">我们传递给变异构造函数的所有props都可以作为 &lt;code&gt;this.props&lt;/code&gt; 用于其实例方法。就像在中继容器中使用的组件中一样，中继将使用查询数据填充已为其定义了相应片段的道具：</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">可以教会任何服务器加载架构并说出GraphQL。我们的&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;示例&lt;/a&gt;使用Express。</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">创建中继环境的实例时，应用程序必须提供&lt;a href=&quot;network-layer&quot;&gt;网络层&lt;/a&gt;。网络层是符合简单接口的对象，中继可以通过该接口执行查询，变异和预订。本质上，该对象教中继如何与您的GraphQL服务器通信。</target>
        </trans-unit>
        <trans-unit id="b73a641a18b041c9d0f67faadd8eeb909c673be7" translate="yes" xml:space="preserve">
          <source>Applied to a fragment definition, &lt;code&gt;@relay(mask: false)&lt;/code&gt; changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.</source>
          <target state="translated">如果将片段包含在同一指令中，则 &lt;code&gt;@relay(mask: false)&lt;/code&gt; 应用于片段定义时，会将生成的Flow类型更改为更好地使用。流类型将不再是精确的对象，并且不再包含内部标记字段。</target>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="translated">架构概述</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">阵列字段</target>
        </trans-unit>
        <trans-unit id="db828dbd3d02709c19e5c4f2577f94833837f6ee" translate="yes" xml:space="preserve">
          <source>As React components, &lt;code&gt;QueryRenderer&lt;/code&gt;s can be rendered anywhere that a React component can be rendered, i.e. not just at the top level but &lt;em&gt;within&lt;/em&gt; other components or containers; for example, to lazily fetch additional data for a popover.</source>
          <target state="translated">作为React组件， &lt;code&gt;QueryRenderer&lt;/code&gt; 可以在React组件可以呈现的任何位置呈现，即不仅在顶层，还可以&lt;em&gt;在&lt;/em&gt;其他组件或容器&lt;em&gt;内&lt;/em&gt;呈现。例如，懒惰地获取弹出窗口的其他数据。</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">举个例子,我们可以将每次发送到服务器的突变记录如下。</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">据了解，Relay容器将数据需求声明为GraphQL片段。这意味着，例如， &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 不仅可以嵌入在 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 中，而且可以嵌入任何获取 &lt;code&gt;User&lt;/code&gt; 类型的字段的容器中。</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">如我们所知，Relay片段容器将数据需求声明为GraphQL片段。我们几乎准备好让Relay满足这些组件的数据要求并进行渲染。但是，有一个问题。为了使用GraphQL实际获取数据，我们需要一个查询根。例如，我们需要将 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 片段置于GraphQL查询中。</target>
        </trans-unit>
        <trans-unit id="aca9c86fb3d13923d8fed77382029e60cce8b3f9" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a &lt;code&gt;QueryRenderer&lt;/code&gt; component to render a root query and any fragment containers included within. Please refer to our &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; docs for more details.</source>
          <target state="translated">如我们所知，Relay片段容器仅将数据需求声明为GraphQL片段。为了实际获取和呈现指定的数据，我们需要使用 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件来呈现根查询和其中包含的任何片段容器。请参阅我们的&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">此时，您可以删除所有内容，直到 &lt;code&gt;queryType&lt;/code&gt; 中的 &lt;code&gt;./data/schema.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">编写模式</target>
        </trans-unit>
        <trans-unit id="f959176d994ae939a23354811509dadf3863fa24" translate="yes" xml:space="preserve">
          <source>Available Props</source>
          <target state="translated">可用道具</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">巴别继电器插件</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">基础React组件</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">在继续之前,我们需要将我们的可执行模式序列化为JSON,供Relay.QL transpiler使用,然后启动服务器。在命令行中。</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">在深入研究变异API之前，让我们看一个完整的示例。在这里，我们将 &lt;code&gt;Relay.Mutation&lt;/code&gt; 子类化以创建一个自定义突变，我们可以使用它来讲述一个故事。</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">行为可以是 &lt;code&gt;'append'&lt;/code&gt; ， &lt;code&gt;'ignore'&lt;/code&gt; ， &lt;code&gt;'prepend'&lt;/code&gt; ， &lt;code&gt;'refetch'&lt;/code&gt; 或 &lt;code&gt;'remove'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">这两个 &lt;code&gt;Faction&lt;/code&gt; 和 &lt;code&gt;Ship&lt;/code&gt; 有，我们可以用它来重新获取他们的标识符。我们通过 &lt;code&gt;Node&lt;/code&gt; 接口和根查询类型上的 &lt;code&gt;node&lt;/code&gt; 字段向中继提供此功能。</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">但是现在，我们还可以为任意用户ID创建路由。例如，如果我们想构造一条路由来获取由 &lt;code&gt;userID&lt;/code&gt; 查询参数定义的用户的数据，则可以使用：</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">按照惯例,突变被命名为动词,它们的输入是名字,最后附加 &quot;Input&quot;,返回的对象是名字,后面附加 &quot;Payload&quot;。</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">默认情况下，Relay假定在相对于提供我们应用程序的源的 &lt;code&gt;/graphql&lt;/code&gt; 处提供GraphQL。可以通过注入默认网络层的自定义实例来重新配置它。</target>
        </trans-unit>
        <trans-unit id="cb2b20c497e96eb4a4f4f36c0d7cc25608d4e73c" translate="yes" xml:space="preserve">
          <source>By default, Relay will only expose the data for fields explicitly requested by a &lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;component's fragment&lt;/a&gt;, which is known as &lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;data masking&lt;/a&gt;. Fragment data is unmasked for use in React components by &lt;code&gt;createFragmentContainer&lt;/code&gt;. However, you may want to use fragment data in non-React functions that are called from React.</source>
          <target state="translated">默认情况下，Relay仅公开&lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;组件片段&lt;/a&gt;明确请求的字段的数据，这称为&lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;数据屏蔽&lt;/a&gt;。片段数据由 &lt;code&gt;createFragmentContainer&lt;/code&gt; 取消屏蔽以在React组件中使用。但是，您可能需要在React中调用的非React函数中使用片段数据。</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">默认情况下，为初始渲染加载数据时不渲染任何内容。如果满足并渲染了先前的 &lt;code&gt;Component&lt;/code&gt; 和 &lt;code&gt;route&lt;/code&gt; 集合，则默认行为是继续渲染先前的视图。</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">缓存一致性</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">缓存更新</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">缓存一个图形</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">调用这个来乐观地对商店进行更新。</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">调用此功能将突变发送到服务器。</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">调用者必须提供适当的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; 。根据GraphQL中继规范：</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">调用 &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; 从创纪录的 &lt;code&gt;this.props&lt;/code&gt; 将返回给定的记录是否被看好突变的影响。它允许组件以与成功与服务器同步的数据不同的方式呈现本地乐观更改。</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">调用组件实例方法</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">可以使用经典环境（ &lt;code&gt;Store&lt;/code&gt; 在 &lt;code&gt;react-relay/classic&lt;/code&gt; 中）的QueryRenderer 使用：</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">使用现代环境的QueryRenderer可以使用。</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">可以React经典组件使用。</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">可以React Compat组件使用。</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">可以React Modern组件使用。</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">RelayRootContainer可以使用。</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">更改参数</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">改变一个系统中的一件事,会产生连锁反应,反过来引起其他事物的改变。想象一下,我们可以利用一个突变来接受好友请求。这可以产生广泛的影响。</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">经典组件</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">经典突变</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">经典： &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">客户端缓存</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">客户端模式扩展(实验性)</target>
        </trans-unit>
        <trans-unit id="825764a68e0dc6e933619f703142c815e2415444" translate="yes" xml:space="preserve">
          <source>Client schema extensions</source>
          <target state="translated">客户端模式扩展</target>
        </trans-unit>
        <trans-unit id="37d72336fa3d155eac5f2b8f6e5f8d2e326546c2" translate="yes" xml:space="preserve">
          <source>Committing Local Updates</source>
          <target state="translated">承诺本地更新</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Relay Classic和Relay Modern的比较</target>
        </trans-unit>
        <trans-unit id="fb10d488b2ce3717647b6821e5a1c02381aeca3a" translate="yes" xml:space="preserve">
          <source>Comparison to Classic Relay</source>
          <target state="translated">与经典继电器的比较</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">兼容性组件</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">兼容性模式</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">兼容性突变</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">兼容性工作表</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">兼容性模式</target>
        </trans-unit>
        <trans-unit id="e2e7a6441928ea51ba685ebeb68d5198d58d0008" translate="yes" xml:space="preserve">
          <source>Compiler Architecture</source>
          <target state="translated">编译器架构</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt;规范中提供了有关服务器行为的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL输入对象突变&lt;/a&gt;规范中提供了有关服务器应如何运行的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL对象标识&lt;/a&gt;规范中提供了有关服务器应如何运行的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">组件和路线</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">组件可以通过使用 &lt;code&gt;setVariables&lt;/code&gt; 请求更新当前 &lt;code&gt;variables&lt;/code&gt; 集来更改其数据要求。</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">组件可以检查任何记录上即将发生的突变（即，具有相应片段的道具中可用的数据）。用一条记录调用 &lt;code&gt;getPendingTransactions&lt;/code&gt; 将返回影响该特定记录的未决突变事务的列表。</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">组成片段</target>
        </trans-unit>
        <trans-unit id="0c70e5846878a796dcb7c94e3f0ca5de9a047eee" translate="yes" xml:space="preserve">
          <source>Composing Views</source>
          <target state="translated">组成观点</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">组成视图--这就是普通的React。</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">在父片段中组成子元件片段。</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">组成定义为局部变量的片段。</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">组成数据描述。</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">《&lt;a href=&quot;guides-containers&quot;&gt;容器指南》&lt;/a&gt;中详细讨论了组成子组件的片段的方法，但这是一个简单的示例：</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">组成视图逻辑,以及</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">条件领域</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="2de632b51a33bf8e3ed45599633fb58061f6d4dc" translate="yes" xml:space="preserve">
          <source>Configure Network</source>
          <target state="translated">配置网络</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="2d3d0c339708a6485641055e4d0d9e905ec021cc" translate="yes" xml:space="preserve">
          <source>ConnectionHandler</source>
          <target state="translated">ConnectionHandler</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">考虑一个带有服务器定义的占位符文本的输入,以及聚焦输入节点的必要方法。</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">考虑渲染一个故事的文本和评论以及相应的作者姓名和照片。下面是GraphQL查询。</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">容器构成</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">集装箱规格</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">容器是高阶组件</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">容器可以定义 &lt;code&gt;prepareVariables&lt;/code&gt; 方法，该方法提供机会修改可用于片段的变量。除了运行时环境之外，还可以基于先前的变量（如果不存在先前的变量，则可以基于 &lt;code&gt;initialVariables&lt;/code&gt; )生成新变量。</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">容器使用GraphQL片段声明有关 &lt;code&gt;fragments&lt;/code&gt; 数据要求。</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">封装构造函数的方便方法,传递一些默认参数并返回一个实例。</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">转换游戏手册</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">转换脚本</target>
        </trans-unit>
        <trans-unit id="bc6e3a410aa372c2487ec123aa51c13c61ba9355" translate="yes" xml:space="preserve">
          <source>Core Modules</source>
          <target state="translated">核心模块</target>
        </trans-unit>
        <trans-unit id="06ee6cde901e483137128dd1aaa541e9ba1b4f92" translate="yes" xml:space="preserve">
          <source>Core primitives for building offline/persisted caching.</source>
          <target state="translated">用于构建离线/持久缓存的核心基元。</target>
        </trans-unit>
        <trans-unit id="7b3852c7992c04bd7a1c305779c938fba2763c16" translate="yes" xml:space="preserve">
          <source>Core primitives to enable subscriptions.</source>
          <target state="translated">启用订阅的核心基元。</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 关键字创建一个变异实例，可以选择向其传递一些道具。需要注意的是 &lt;code&gt;this.props&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;可用的构造函数中，但所有的方法下文提到的（被设定 &lt;code&gt;getCollisionKey&lt;/code&gt; ， &lt;code&gt;getOptimisticResponse&lt;/code&gt; 等）。这种限制是由于突变道具可能取决于RelayEnvironment的数据这一事实，直到使用 &lt;code&gt;applyUpdate&lt;/code&gt; 或 &lt;code&gt;commitUpdate&lt;/code&gt; 进行突变后才知道。</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 关键字创建一个路由实例，可以选择向其传递一些参数。</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">创建一个新的中继容器- 有关更多详细信息和示例，请参见&lt;a href=&quot;guides-containers&quot;&gt;容器指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59d477c173081caca582f697a308e90dad49d280" translate="yes" xml:space="preserve">
          <source>Creates a new record in the store given a &lt;code&gt;dataID&lt;/code&gt; and the &lt;code&gt;typeName&lt;/code&gt; as defined by the GraphQL schema. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the newly created record.</source>
          <target state="translated">根据GraphQL架构定义的给定 &lt;code&gt;dataID&lt;/code&gt; 和 &lt;code&gt;typeName&lt;/code&gt; 在存储中创建新记录。返回一个&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;，它用作对新创建的记录进行突变的接口。</target>
        </trans-unit>
        <trans-unit id="21efb0843ee16f4a18b237b51a057d09100b1064" translate="yes" xml:space="preserve">
          <source>Creates an edge given a &lt;a href=&quot;#recordsourceselectorproxy&quot;&gt;&lt;code&gt;store&lt;/code&gt;&lt;/a&gt;, a connection, the edge type, and a record that holds that connection.</source>
          <target state="translated">在给定&lt;a href=&quot;#recordsourceselectorproxy&quot;&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt;，连接，边缘类型和保存该连接的记录的情况下创建边缘。</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">当前最简单的创建网络层的方法是通过 &lt;code&gt;relay-runtime&lt;/code&gt; 包中的帮助程序：</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">可以通过提供 &lt;code&gt;headers&lt;/code&gt; 对象来配置自定义HTTP标头：</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">自定义网络层</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">自定义路由和更多</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">自定义网络层必须符合以下&lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;接口。尽管默认网络层是接受某些配置的可实例化类，但这不是注入网络层的要求。</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">必须符合 &lt;code&gt;RelayNetworkLayer&lt;/code&gt; 接口的自定义网络层。</target>
        </trans-unit>
        <trans-unit id="8e195dc960c4de2f5938ab244ca476e61a3b512b" translate="yes" xml:space="preserve">
          <source>Custom open-source implementations</source>
          <target state="translated">定制的开放源码实施方案</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">数据组件又称容器</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">使用GraphQL的数据依赖性</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="translated">数据流</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">数据屏蔽</target>
        </trans-unit>
        <trans-unit id="9f570bdcfd6b031f335934a6700ab99601783168" translate="yes" xml:space="preserve">
          <source>Data Model</source>
          <target state="translated">数据模型</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="translated">数据类型</target>
        </trans-unit>
        <trans-unit id="f1e75bbe26916d6856acc894895802461b7a14ea" translate="yes" xml:space="preserve">
          <source>Data Types &amp;amp; Modules</source>
          <target state="translated">数据类型和模块</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">由于 &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 配置而获取的数据未写入客户端存储，但是您可以在传递给 &lt;code&gt;commitUpdate()&lt;/code&gt; 的 &lt;code&gt;onSuccess&lt;/code&gt; 回调中添加处理该数据的代码：</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">数据获取API</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">数据/视图一致性</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">程序化调试</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">视觉调试</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">默认网络层</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer(静态属性</target>
        </trans-unit>
        <trans-unit id="cc401fba47cbe2915424897d3b03537f262c5e09" translate="yes" xml:space="preserve">
          <source>Defining Containers</source>
          <target state="translated">定义容器</target>
        </trans-unit>
        <trans-unit id="c761cb3b3af168784bb525eb6cc8bdda8deb1143" translate="yes" xml:space="preserve">
          <source>Deletes a record from the store given its &lt;code&gt;dataID&lt;/code&gt;.</source>
          <target state="translated">给定其 &lt;code&gt;dataID&lt;/code&gt; 从存储中删除记录。</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">设计一个胖子查询,覆盖每一个可能改变的字段。</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">在此迁移期间，请使用&lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt;工具和API与Relay Classic和Relay Modern一起使用。</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">每个 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 都有检查突变状态的方法，并提供了根据需要回滚或重新发送突变的方法。</target>
        </trans-unit>
        <trans-unit id="fbce231c1e8a474ca4ecbc6efb0b7e9a89704719" translate="yes" xml:space="preserve">
          <source>Edge creation and insertion</source>
          <target state="translated">边缘创建和插入</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">任一实例 &lt;code&gt;Relay.Route&lt;/code&gt; 或与对象 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;queries&lt;/code&gt; ，以及任选的 &lt;code&gt;params&lt;/code&gt; 性质。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">即使我们可以访问 &lt;code&gt;renderFetched&lt;/code&gt; 中的 &lt;code&gt;data&lt;/code&gt; 对象，实际的数据还是故意不透明的。这样可以防止 &lt;code&gt;renderFetched&lt;/code&gt; 对 &lt;code&gt;Component&lt;/code&gt; 声明的片段创建隐式依赖。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="ee6ee8c5dded943d0aabd760c567c92f2ee1cb72" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Fetching Query Data</source>
          <target state="translated">示例数据流:获取查询数据</target>
        </trans-unit>
        <trans-unit id="54a85f686c00fd7f5967d3cbaebf03180ef14d5b" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Reading and Observing the Store</source>
          <target state="translated">示例数据流。读取和观察商店</target>
        </trans-unit>
        <trans-unit id="0b92abde2e68af5a3c565dacca8e8cfd97caced5" translate="yes" xml:space="preserve">
          <source>Example of a simple mutation:</source>
          <target state="translated">简单突变的例子。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">有关如何从旧API 迁移 &lt;code&gt;this.props.setVariables&lt;/code&gt; 调用的示例。</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">可扩展核心</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">获取数据</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">为一个视图获取数据</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">从服务器获取数据</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">获取一个视图层次结构的所有数据。</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">围绕路由的要求更少</target>
        </trans-unit>
        <trans-unit id="90c0db66830e63b9ba0686e057e6915aaf66921d" translate="yes" xml:space="preserve">
          <source>Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated.</source>
          <target state="translated">最后,GraphQL会被打印出来(如打印到文件,保存到数据库等),并生成任何工件。</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">最后，让我们在 &lt;code&gt;./js/components/App.js&lt;/code&gt; 中将它们捆绑在一起：</target>
        </trans-unit>
        <trans-unit id="81320abd4244f533456ecdb31fa9235954b4c027" translate="yes" xml:space="preserve">
          <source>Finally, subscriptions whose data actually changed are notified via their callback.</source>
          <target state="translated">最后,通过其回调通知数据实际发生变化的订阅。</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">最后,我们构建我们的模式(其起始查询类型是我们在上面定义的查询类型)并将其导出。</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">查找或创建与可变记录关联的单个记录。如果关联记录不存在，这是使用 &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; 到 &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">首先，安装插件（通常是 &lt;code&gt;devDependency&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="37434c70c94c9bba372cffd8d1a31c930d66efb8" translate="yes" xml:space="preserve">
          <source>First, let's take a look at a plain connection:</source>
          <target state="translated">首先,我们来看看一个普通的连接。</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">首先，让我们看一下 &lt;code&gt;environment&lt;/code&gt; 输入。为了使用相关数据在正确的 &lt;code&gt;environment&lt;/code&gt; 执行变异，最好使用用于渲染组件的 &lt;code&gt;environment&lt;/code&gt; 。可从组件的 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 访问它。</target>
        </trans-unit>
        <trans-unit id="c30bc0a2078d4d797890b53dd71501499ca6f601" translate="yes" xml:space="preserve">
          <source>First, the list of data IDs that have changed since the last &lt;code&gt;notify()&lt;/code&gt; is compared against data IDs listed in the subscription's latest &lt;code&gt;Snapshot&lt;/code&gt;. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.</source>
          <target state="translated">首先，将自上次 &lt;code&gt;notify()&lt;/code&gt; 之后发生更改的数据ID列表与订阅的最新 &lt;code&gt;Snapshot&lt;/code&gt; 中列出的数据ID进行比较。如果没有重叠，则预订的结果可能不会更改（如果您直观地想象该图，则该图的已更改部分与所选部分之间不会有任何重叠）。在这种情况下，订阅将被忽略，否则处理将继续。</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">首先，您需要安装&lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;守卫&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">平路</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">流量类型生成</target>
        </trans-unit>
        <trans-unit id="6d01829e4505f8d6171af1d3b3cae8dab5a6ee84" translate="yes" xml:space="preserve">
          <source>Following our &lt;code&gt;TodoList_list&lt;/code&gt; example, we would pass arguments to the fragment like so:</source>
          <target state="translated">按照我们的 &lt;code&gt;TodoList_list&lt;/code&gt; 示例，我们将像这样将参数传递给片段：</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">有关如何加载 &lt;code&gt;schema.js&lt;/code&gt; 文件，运行自省查询以获取模式信息并将其保存到JSON文件的完整示例，请查看&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;入门工具包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">对于一个简单的应用来说,这已经是一个不错的进步了。</target>
        </trans-unit>
        <trans-unit id="c72ede783eff4e07fb8b68b24df1f1f2ee6802eb" translate="yes" xml:space="preserve">
          <source>For connections like the above, &lt;code&gt;ConnectionHandler&lt;/code&gt; helps us find the record:</source>
          <target state="translated">对于上述 &lt;code&gt;ConnectionHandler&lt;/code&gt; ，ConnectionHandler可以帮助我们找到记录：</target>
        </trans-unit>
        <trans-unit id="889156520813e19bcd7a5e0e8e569875e2029955" translate="yes" xml:space="preserve">
          <source>For details on how to interact with the Relay Store, please refer to our Relay Store &lt;a href=&quot;relay-store&quot;&gt;docs&lt;/a&gt;.</source>
          <target state="translated">有关如何与中继商店进行交互的详细信息，请参阅我们的中继商店&lt;a href=&quot;relay-store&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">例如， &lt;code&gt;rangeBehaviors&lt;/code&gt; 可以这样写：</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">例如,网络层可以是一个符合接口的简单对象。</target>
        </trans-unit>
        <trans-unit id="2aa5827894bb94d499f20a1d29faefe22d07cad1" translate="yes" xml:space="preserve">
          <source>For example, a user and their address might be represented as follows:</source>
          <target state="translated">例如,一个用户和他们的地址可以用以下方式表示:</target>
        </trans-unit>
        <trans-unit id="5650972e3a1efbfc7e79658033f2f192552c13cb" translate="yes" xml:space="preserve">
          <source>For example, assuming the server schema &lt;code&gt;./schema.graphql&lt;/code&gt;:</source>
          <target state="translated">例如，假设服务器模式 &lt;code&gt;./schema.graphql&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">例如,给定两个文件。</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">例如，如果在 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; 设置了 &lt;code&gt;currentDate&lt;/code&gt; ，则$ currentDate可以在 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 包括的任何片段中引用。</target>
        </trans-unit>
        <trans-unit id="384dd94e051eb1541d94fe85b1aa65cfc4b8720e" translate="yes" xml:space="preserve">
          <source>For example, let's redefine our &lt;code&gt;TodoList_list&lt;/code&gt; fragment to take some arguments using &lt;code&gt;@argumentDefinitions&lt;/code&gt;:</source>
          <target state="translated">例如，让我们重新定义我们的 &lt;code&gt;TodoList_list&lt;/code&gt; 片段，以使用 &lt;code&gt;@argumentDefinitions&lt;/code&gt; 接受一些参数：</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">有关更复杂的乐观更新（包括从列表中添加和删除）的&lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;示例&lt;/a&gt;，请参见Relay Modern Todo示例应用程序。</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">对于更复杂的用例，您可能希望执行自定义逻辑以在收到每个订阅响应时更新Relay的内存中缓存。为此，请传递一个 &lt;code&gt;updater&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">对于更复杂的突变， &lt;code&gt;optimisticUpdater&lt;/code&gt; 和 &lt;code&gt;updater&lt;/code&gt; 可以是相同的功能。</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">有关创建网络的更多详细信息，请参见&lt;a href=&quot;network-layer&quot;&gt;NetworkLayer指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a8624a85744c6bfa958d4ffba2ebcba068cf3d0" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;local-state-management&quot;&gt;Local state management section&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&amp;ldquo;&lt;a href=&quot;local-state-management&quot;&gt;本地状态管理&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1d4a5435c3cb6cdfd5a8c58ab671072ab888ff3" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;persisted-queries&quot;&gt;Persisted Queries section&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&amp;ldquo;&lt;a href=&quot;persisted-queries&quot;&gt;持久查询&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">对于新的Relay应用或已经完全转换为Compat API的现有应用,可以启用Relay Modern运行时来激活更多的功能。除上述功能外,还包括:1:</target>
        </trans-unit>
        <trans-unit id="d800dc29a67ae0f7e1c89e3fa88acf537112a2a4" translate="yes" xml:space="preserve">
          <source>For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;id&lt;/code&gt; field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.</source>
          <target state="translated">对于经典中继的用户，请注意，运行时对GraphQL的假设尽可能少。与早期版本的Relay相比，没有路由的概念，对突变输入参数或副作用，任意根字段都起作用等没有任何限制。目前，经典Relay的主要限制仍然是使用 &lt;code&gt;Node&lt;/code&gt; 接口和用于标识对象的 &lt;code&gt;id&lt;/code&gt; 字段。但是，没有根本的理由不能放宽此限制（在代码库中只有一个地方确定了对象标识），我们欢迎社区提供有关在不对性能造成负面影响的情况下支持可自定义对象标识的反馈。</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">强制取件</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">强制从客户端获取数据</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found通过&lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;提供与Relay Modern和Relay Classic的集成。找到的中继并行运行查询匹配的路由，并支持并行获取中继数据，并在使用Relay Modern时从代码拆分中下载异步包。</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">片段构成</target>
        </trans-unit>
        <trans-unit id="44548256a4fe02219452b999f31774df4d7788f3" translate="yes" xml:space="preserve">
          <source>Fragment Container</source>
          <target state="translated">片段集装箱</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">片段组成是通过ES6模板字符串插值和 &lt;code&gt;getFragment&lt;/code&gt; 实现的：</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">片段组成的工作原理相似-父容器的片段组成了每个子容器的片段。在这种情况下， &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 需要获取 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 所需的有关 &lt;code&gt;User&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="c2f68d40663d52153573dd0abe042e691b281b53" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">片段组成的工作原理相似-父容器的片段组成了每个子容器的片段。在这种情况下， &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; 需要获取关于信息的 &lt;code&gt;Todo&lt;/code&gt; 是由所需的小号 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">片段组成的工作原理相似-父容器的片段组成了每个子容器的片段。在这种情况下， &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 需要获取有关信息的 &lt;code&gt;Todo&lt;/code&gt; 是由所需的小号 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">片段变量</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">碎片可以用两种方式组成。</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">片段可以嵌入其他片段或查询中。例如，以上片段可用于获取用户 &lt;code&gt;123&lt;/code&gt; 的个人资料照片：</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">片段也可以组成其他片段,这些片段被分配给局部变量。</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="202728ddee5584ce607f4aab869a3630ba743b82" translate="yes" xml:space="preserve">
          <source>Garbage collection to evict entries from the cache when they can no longer be referenced by any view.</source>
          <target state="translated">垃圾收集,当条目不能再被任何视图引用时,将其从缓存中驱逐。</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">使用JavaScript构建GraphQL模式的通用工具。</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">获取一个片段引用,用于父的查询片段。</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">获取对子容器片段的引用,以便包含在父片段中。</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">获取一个字符串名称,用来指代这个打印调试输出的请求。</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">获取GraphQL突变的字符串表示。</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">获取GraphQL查询的字符串表示。</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">获取此突变的唯一标识符。这些标识符对于在单个GraphQL请求中发送时将响应有效载荷分配给相应的突变非常有用。</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">获取此查询的唯一标识符。这些标识符对于在单个GraphQL请求中发送响应有效载荷时,将响应有效载荷分配给相应的查询非常有用。</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">获取从名字到文件对象的可选映射。</target>
        </trans-unit>
        <trans-unit id="1daf2e35612607247d326239b96ef7bd4c0deb13" translate="yes" xml:space="preserve">
          <source>Gets the type of the current record, as defined by the GraphQL schema.</source>
          <target state="translated">获取当前记录的类型,由GraphQL模式定义。</target>
        </trans-unit>
        <trans-unit id="0ee3ecb0267703f60ff46d5ccfae9291bc39b826" translate="yes" xml:space="preserve">
          <source>Gets the value of a field in the current record given the field name.</source>
          <target state="translated">获取当前记录中给定字段名的字段值。</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">获取突变所使用的变量。这些变量应该被序列化并在GraphQL请求中发送。</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">获取查询使用的变量。这些变量应该被序列化并在GraphQL请求中发送。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="c50a651b10d01a7deafc80b4e09d60a50246f2f1" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;deletedIDFieldName&lt;/code&gt;, Relay will remove the node(s) from the store.</source>
          <target state="translated">给定一个 &lt;code&gt;deletedIDFieldName&lt;/code&gt; ，Relay将从存储中删除该节点。</target>
        </trans-unit>
        <trans-unit id="d609f05a6d3bf2ce92708edc4808c22e3566e07f" translate="yes" xml:space="preserve">
          <source>Given a connection, deletes any edges whose id matches the given id.</source>
          <target state="translated">给定一个连接,删除任何id与给定id匹配的边。</target>
        </trans-unit>
        <trans-unit id="d379af210d311a7a256db3fa6fe039dcbf2cbd54" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the beginning of the connection, or before the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="translated">给定一个连接，将边插入到连接的开始处或指定的 &lt;code&gt;cursor&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="4bffc05ebf924c05ffda3d323c9605a38ad10f80" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the end of the connection, or after the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="translated">给定一个连接，将边插入到连接的末尾，或在指定的 &lt;code&gt;cursor&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">给定一个连接、响应有效载荷中的一个或多个DataID以及父连接和连接之间的路径,Relay将从连接中移除节点,但在存储中保留相关记录。</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">给定删除的IDFieldName,Relay将从连接中移除节点。</target>
        </trans-unit>
        <trans-unit id="720b1124168e2fcea493421f01efb6519477f619" translate="yes" xml:space="preserve">
          <source>Given a parent, &lt;code&gt;connectionKeys&lt;/code&gt;, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">给定父级， &lt;code&gt;connectionKeys&lt;/code&gt; ，响应有效负载中的一个或多个DataID以及父级与连接之间的路径，Relay将从连接中删除该节点，但将相关记录保留在存储中。</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">给定一个父节点、一个连接和响应有效载荷中的一个或多个DataID,Relay将从连接中移除节点,并从存储中删除相关记录。</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">给定一个父节点、一个连接和响应有效载荷中新创建的边缘的名称,Relay将把节点添加到存储中,并根据指定的范围行为将其附加到连接上。</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">给定一个父节点、连接键、响应有效载荷中的一个或多个DataID以及父节点和连接之间的路径,Relay将从连接中移除节点,但在存储中保留相关记录。</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">给定父节点、连接信息和响应有效载荷中新创建的边缘的名称,Relay 将根据 connectionInfo 中指定的范围行为将节点添加到存储中,并将其附加到连接上。</target>
        </trans-unit>
        <trans-unit id="a9b1b0a91341253151fdb0d5e41db14af5ba2ef3" translate="yes" xml:space="preserve">
          <source>Given a record and a connection key, and optionally a set of filters, &lt;code&gt;getConnection&lt;/code&gt; retrieves a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; that represents a connection that was annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">给定一条记录和一个连接键，以及可选的一组过滤器， &lt;code&gt;getConnection&lt;/code&gt; 检索一个&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;，该RecordProxy表示一个用 &lt;code&gt;@connection&lt;/code&gt; 指令注释的连接。</target>
        </trans-unit>
        <trans-unit id="5933a7dc46c436f13a884a4a3f5f844894c6ee04" translate="yes" xml:space="preserve">
          <source>Given the GraphQL document:</source>
          <target state="translated">鉴于GraphQL文档。</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">给定普通的React组件和GraphQL片段，我们现在可以定义一个 &lt;code&gt;Container&lt;/code&gt; 来向Relay告知该组件的数据要求。让我们先看一下代码，然后看看发生了什么：</target>
        </trans-unit>
        <trans-unit id="78d8c89827c5602fc6d1d40331d005ddbc42de59" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">给定了普通的React组件和一个GraphQL片段,我们现在可以定义一个Fragment Container来指定这个组件的数据需求。让我们先看看代码,然后再看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">考虑到这些现实世界的限制，GraphQL中的方法是让客户查询在突变后可能发生变化的事物。但是，我们到底要输入什么呢？在Relay的开发过程中，我们探索了几种想法-让我们简要地看一下它们，以了解为什么Relay使用它所采用的方法：</target>
        </trans-unit>
        <trans-unit id="5c41e44eb6db12a7dd58862cf6f3cc1584c314eb" translate="yes" xml:space="preserve">
          <source>Globally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="translated">全局使中继存储无效。这将导致在发生无效之前写入存储的任何数据都被认为是陈旧的，并在下次使用 &lt;code&gt;environment.check()&lt;/code&gt; 检查查询时被认为需要重新获取。</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">GraphQL中继规范</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">图形QL方案</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">GraphQL订阅和实时查询</target>
        </trans-unit>
        <trans-unit id="55705029d139bf2fb4343a8dd5d01c514bb24b08" translate="yes" xml:space="preserve">
          <source>GraphQL in Relay</source>
          <target state="translated">继电器中的GraphQL</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL旨在支持广泛的数据访问模式。为了了解应用程序数据的结构，Relay要求您在定义架构时遵循某些约定。这些在&lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL继电器规范中有说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL通过关注产品开发者和客户端应用的需求,为客户端获取数据提供了新的方式。它为开发人员提供了一种方法,可以指定视图所需的精确数据,并使客户端能够在一次网络请求中获取这些数据。与传统的方法(如REST)相比,GraphQL帮助应用程序更有效地获取数据(与面向资源的REST方法相比),并避免服务器逻辑的重复(自定义端点可能会发生)。此外,GraphQL还能帮助开发人员将产品代码和服务器逻辑解耦。例如,一个产品可以获取更多或更少的信息,而不需要改变每个相关的服务器端点。这是一种很好的数据获取方式。</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL提供了一个功能强大的工具，可用于构建高效的，解耦的客户端应用程序。中继基于此功能提供&lt;strong&gt;声明式数据获取&lt;/strong&gt;的框架。通过分离&lt;em&gt;哪些&lt;/em&gt;数据从获取&lt;em&gt;如何&lt;/em&gt;是牵强，接力帮助开发人员构建是强大的，透明的和高性能的应用程序默认。这是对React倡导的以组件为中心的思维方式的巨大补充。虽然上述每种技术（React，Relay和GraphQL）都具有强大的功能，但两者的结合是一个&lt;strong&gt;UI平台&lt;/strong&gt;，使我们能够&lt;em&gt;快速移动&lt;/em&gt;并&lt;em&gt;大规模&lt;/em&gt;交付&lt;em&gt;高质量的应用程序&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fe79f455fe739b1f1e04461fc0dc38be9fbb5f79" translate="yes" xml:space="preserve">
          <source>GraphQL text is extracted from source files and &quot;parsed&quot; into an intermediate representation (IR) using information from the schema.</source>
          <target state="translated">GraphQL文本从源文件中提取,并使用模式中的信息 &quot;解析 &quot;成中间表示(IR)。</target>
        </trans-unit>
        <trans-unit id="e541828d19d4a8e98d359b78f14f53ce50019b3d" translate="yes" xml:space="preserve">
          <source>Here are a few examples of some of the included transforms:</source>
          <target state="translated">下面是一些包含的变换的例子。</target>
        </trans-unit>
        <trans-unit id="4de18940b97877b6ff77ae9e81b1c868cf154cdc" translate="yes" xml:space="preserve">
          <source>Here are a quick example of adding a todo item to a Todo list using this &lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;example schema&lt;/a&gt;:</source>
          <target state="translated">这是一个使用此&lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;示例模式&lt;/a&gt;将待办事项添加到待办事项列表的快速示例：</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">这是 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 的基本实现，该实现忽略样式以突出显示功能：</target>
        </trans-unit>
        <trans-unit id="622275495084316cce6011efe3c5533f0b505dd1" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">这是 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 的基本实现，该实现忽略样式以突出功能：</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">这是 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 的基本实现，该实现忽略样式以突出功能：</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">这是 &lt;code&gt;LikeButton&lt;/code&gt; 组件正在使用的这种变异的示例：</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">下面是一个查询的例子,可以获取一个故事的文本和作者的名字。</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">下面是呈现容器时的情况。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">从历史上看,Relay最初在Facebook内部是一个路由框架。然而,Relay不再对路由进行任何假设,而是与各种路由选项一起工作。</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">嗯 没有更多的船了。猜想叛军中只有五个人。很高兴知道我们已经到达连接的末端，而不必进行另一次往返来验证这一点。连接模型使用称为 &lt;code&gt;PageInfo&lt;/code&gt; 的类型来公开此功能。因此，让我们发出使我们再次发货的两个查询，但是这次要求 &lt;code&gt;hasNextPage&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">但是，使用Relay Modern API（ &lt;code&gt;'react-relay'&lt;/code&gt; ）和Relay Classic API（ &lt;code&gt;'react-relay/classic'&lt;/code&gt; ）的组件不能相互使用。</target>
        </trans-unit>
        <trans-unit id="502eeb0d2871522e994df777d19577771dfe2094" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates &lt;a href=&quot;https://flow.org&quot;&gt;Flow&lt;/a&gt; types as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. For example, you can import the generated Flow types like so:</source>
          <target state="translated">但是，Relay Compiler也会自动将&lt;a href=&quot;https://flow.org&quot;&gt;Flow&lt;/a&gt;类型生成为&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;类型注释&lt;/a&gt;。例如，您可以像这样导入生成的流类型：</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">但是，Relay Compiler也会自动生成流类型，作为&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;类型注释&lt;/a&gt;。导入类型：</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">但是，Relay Modern希望定义现代JavaScript全局类型（ &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Promise&lt;/code&gt; ， &lt;code&gt;Object.assign&lt;/code&gt; ）。如果您支持可能还没有原生提供这些功能的旧版浏览器和设备，请考虑在捆绑的应用程序中包括全局polyfill，例如&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e508d49142051371922e56dda4689dd05e8567d5" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to request waterfalls if used unnecessarily.</source>
          <target state="translated">但是， &lt;code&gt;QueryRenderer&lt;/code&gt; 在挂载之前不会开始加载其数据，因此，如果不必要地使用嵌套的 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件，可能会导致请求瀑布。</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">但是，该片段也可以获取用户 &lt;code&gt;123&lt;/code&gt; 的每个朋友的个人资料照片：</target>
        </trans-unit>
        <trans-unit id="a72518acd301cccb79e4d618aa2b5df43d443663" translate="yes" xml:space="preserve">
          <source>However, when &lt;a href=&quot;#createpaginationcontainer&quot;&gt;specifying connection fragments&lt;/a&gt; for a Pagination Container, it is expected that at least one of the fragments contains a &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL connection&lt;/a&gt; to paginate over, and that the connection field is annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">但是，在为分页容器&lt;a href=&quot;#createpaginationcontainer&quot;&gt;指定连接片段&lt;/a&gt;时，期望至少一个片段包含要分页的&lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL连接&lt;/a&gt;，并且连接字段使用 &lt;code&gt;@connection&lt;/code&gt; 指令注释。</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="0daab153956ffb0745c3d2cf4823ed87bf8cdc9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticResponse&lt;/code&gt; is provided, Relay will use it to update the fields under the records as specified by the ids in the &lt;code&gt;optimisticResponse&lt;/code&gt;.</source>
          <target state="translated">如果提供了 &lt;code&gt;optimisticResponse&lt;/code&gt; ，则Relay将使用它来更新由 &lt;code&gt;optimisticResponse&lt;/code&gt; 中的id指定的记录下的字段。</target>
        </trans-unit>
        <trans-unit id="1e63eef54ae07ad9832be86ae57e57b86e1543dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticUpdater&lt;/code&gt; is provided, Relay will execute it and update the store accordingly.</source>
          <target state="translated">如果提供了 &lt;code&gt;optimisticUpdater&lt;/code&gt; ，则Relay将执行它并相应地更新存储。</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">如果发生&amp;ldquo;强制获取&amp;rdquo;并且客户端上没有足够的数据，则可以预期&lt;strong&gt;与从服务器获取数据&lt;/strong&gt;相同的行为。但是，如果出现一个&amp;ldquo;力取&amp;rdquo;有&lt;em&gt;是&lt;/em&gt;在客户端上足够的数据来呈现，我们可以预期以下行为：</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">如果片段使用在运行时确定的变量，&lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;请参见下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">如果服务器请求导致加载数据失败,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="c11a40394f41454ad18de679c37d7363316ff63c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;updater&lt;/code&gt; was provided, Relay will execute it and update the store accordingly. The server payload will be available to the &lt;code&gt;updater&lt;/code&gt; as a root field in the store.</source>
          <target state="translated">如果提供了 &lt;code&gt;updater&lt;/code&gt; ，则Relay将执行该更新程序并相应地更新存储。服务器有效负载将作为商店中的根字段提供给 &lt;code&gt;updater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">如果发生错误，导致&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;无法获取呈现 &lt;code&gt;Component&lt;/code&gt; 所需的数据，则默认情况下不会呈现任何内容。可以通过为 &lt;code&gt;renderFailure&lt;/code&gt; 属性提供回调来配置错误处理行为：</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">如果 &lt;code&gt;Component&lt;/code&gt; 或 &lt;code&gt;route&lt;/code&gt; 发生更改，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将立即开始尝试满足新数据要求。</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">如果客户端数据不足,导致Relay发送服务器请求获取更多数据,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有任何请求在进行中，则Patricks为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">如果没有提供,则会推导出一个唯一的碰撞键(意味着所创建的突变将是独立的,不会与任何其他突变发生碰撞)。</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">如果客户端有足够的数据,Relay不需要发送服务器请求,我们可以期待以下行为。</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">如果提供并设置为 &quot;true&quot;,则无论客户端的数据是否已经可用,都会向服务器发出数据请求。</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">如果提供并设置为 &quot;true&quot;,则无论客户机上的数据是否可以立即满足数据要求,都会向服务器发出数据请求。</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">如果应用程序的&amp;ldquo;中继&amp;rdquo;部分是某个窗口小部件或作为较大应用程序的一部分的单个视图，则不需要任何路由。您可以仅在页面上的某个位置呈现 &lt;code&gt;QueryRenderer&lt;/code&gt; ，以在那里获取和呈现所需的数据。此选项很简单，应在足够时使用。</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">如果回调返回 &lt;code&gt;undefined&lt;/code&gt; ，则呈现先前呈现的视图（如果没有先前的视图则不呈现）（例如，从一个 &lt;code&gt;queryConfig&lt;/code&gt; 转换到另一个queryConfig时）。</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">如果组件实际上不使用 &lt;code&gt;setVariables()&lt;/code&gt; ，而仅使用 &lt;code&gt;initialVariables&lt;/code&gt; 在JS和GraphQL之间共享值，则有两种替代方法：</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">如果突变定义了一个乐观的有效载荷--在等待服务器响应时在本地应用的一组数据,Relay就会应用这个变化,并更新任何受影响的React组件(注意,乐观的更新不会覆盖缓存中的已知服务器数据)。</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">如果该突变不会与其他未决突变发生&amp;ldquo;冲突&amp;rdquo;（重叠）（如其 &lt;code&gt;getCollisionKey&lt;/code&gt; 实现所指定的那样），则会将其发送到服务器。如果发生冲突，则将其排队直到冲突的突变完成。</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">如果没有提供render回调,那么默认的行为是在数据可用的情况下渲染容器,在现有视图存在的情况下渲染现有视图,或者什么都不渲染。</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">如果没有 &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 后缀，则将使用 &lt;code&gt;data&lt;/code&gt; prop名称：</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">如果我们对帝国做同样的事情,我们会发现它返回的ID不同,我们也可以重新获取它。</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">如果我们为突变提供了一种符合上述签名的方法，则将有机会根据先前的变量（如果不存在先前的 &lt;code&gt;initialVariables&lt;/code&gt; 则为initialVariables），片段路径，修改片段生成器的变量，和运行时环境。该方法返回的任何变量都可用于此突变的片段构建器。</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">如果将 &lt;code&gt;2&lt;/code&gt; 替换为新的不可变记录，我们还将获得缓存对象的新的不可变实例。但是，记录 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 保持不变。因为数据是规范化的，所以仅查看 &lt;code&gt;story&lt;/code&gt; 记录就无法判断 &lt;code&gt;story&lt;/code&gt; 的内容已更改。</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">如果要为任意用户创建此路由的实例，则可以将 &lt;code&gt;Relay.Route&lt;/code&gt; 抽象类作为子类。 &lt;code&gt;Relay.Route&lt;/code&gt; 可以轻松定义一组查询和所需的参数，以供多次重用：</target>
        </trans-unit>
        <trans-unit id="1e290d52905763c30ab6c18d70c7f5a099e17ab8" translate="yes" xml:space="preserve">
          <source>If you do decide to use an &lt;code&gt;optimisticUpdater&lt;/code&gt;, often times it can be the same function as &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">如果您决定使用 &lt;code&gt;optimisticUpdater&lt;/code&gt; ，通常它可以与 &lt;code&gt;updater&lt;/code&gt; 具有相同的功能。</target>
        </trans-unit>
        <trans-unit id="bf233e85c6ba7e3a45e4100d4c2cae37e5ec06e0" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">如果你发现你需要做一些独特的东西（如生成符合旧版本的流量类型，或解析非JavaScript源文件），你可以在自己的交换建立自己的编译器版本 &lt;code&gt;FileWriter&lt;/code&gt; 和 &lt;code&gt;ASTCache&lt;/code&gt; ，或通过添加其他 &lt;code&gt;IRTransform&lt;/code&gt; 。请注意， &lt;code&gt;RelayCompiler&lt;/code&gt; 的内部API处于不断的迭代中，因此滚动您自己的版本可能会导致与将来的发行版不兼容。</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">如果你发现你需要做一些独特的东西（如生成符合旧版本的流类型，或解析非JavaScript源文件），你可以在自己的交换建立自己的编译器版本 &lt;code&gt;FileWriter&lt;/code&gt; 和 &lt;code&gt;ASTCache&lt;/code&gt; ，或通过添加其他 &lt;code&gt;IRTransform&lt;/code&gt; 。请注意， &lt;code&gt;RelayCompiler&lt;/code&gt; 的内部API 处于不断的迭代中，因此滚动您自己的版本可能会导致与将来的发行版不兼容。</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">如果您希望提供自己的 &lt;code&gt;handlerProvider&lt;/code&gt; ，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">如果使用 &lt;code&gt;createRefetchContainer&lt;/code&gt; ,则您的 &lt;code&gt;refetch&lt;/code&gt; 方法也可能会更新这些变量以使用新值进行渲染。</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">如果您使用的是不同的GraphQL服务器实现,我们建议调整上面的例子,从您的GraphQL服务器加载模式(例如通过HTTP请求),然后将结果保存为JSON。</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">想象一下,我们有一个简单的应用程序,可以获取一个故事列表,以及每个故事的一些细节。下面是在面向资源的REST中的样子。</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">在处理乐观响应所需的突变器配置需要与处理服务器响应的配置不同的情况下,实现该方法。</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">实现这个方法来制作一个乐观的响应,其形状与服务器响应有效载荷相同。这个乐观的响应将被用来在服务器返回之前先发制人地更新客户端缓存,给人一种突变瞬间完成的感觉。</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">实现这个方法来返回一个碰撞键。Relay将把具有相同碰撞键的任何突变按顺序串行地发送到服务器。</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">实现此方法以返回 &lt;code&gt;File&lt;/code&gt; 对象的映射，以作为突变的一部分上载。</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">当提供的选项被该网络层支持时,实现该方法返回true。这用来声明网络层支持哪些功能。</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">实现此方法以将变异发送到服务器。当获得了服务器的响应，该方法要么必须调用 &lt;code&gt;mutationRequest.resolve&lt;/code&gt; 与响应数据，或 &lt;code&gt;mutationRequest.reject&lt;/code&gt; 与 &lt;code&gt;Error&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">实现此方法以将查询发送到服务器。对于每个查询请求，当收到服务器响应时，此方法必须使用响应数据调用 &lt;code&gt;resolve&lt;/code&gt; 或使用 &lt;code&gt;Error&lt;/code&gt; 对象 &lt;code&gt;reject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">实施此必需的方法来设计&amp;ldquo;胖查询&amp;rdquo;，该查询表示数据模型中可能由于此突变而发生变化的每个字段。</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">实现这个所需的方法,给Relay指示如何使用每次突变的响应有效载荷来更新客户端存储。</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">实现这个所需的方法来准备变量作为突变的输入。</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">实现这个所需的方法,以返回一个表示要进行突变的GraphQL突变操作。</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">导入生成的定义</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">在GraphQL中，&lt;strong&gt;查询&lt;/strong&gt;声明根查询类型上存在的字段。例如，以下查询可能会获取 &lt;code&gt;id&lt;/code&gt; 为 &lt;code&gt;123&lt;/code&gt; 的用户名：</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">在React Native中,我们可以安排Relay处理,以避免中断触摸手势,具体如下。</target>
        </trans-unit>
        <trans-unit id="8ebfcf2d8faf5ad639fc9d0514f8f7159330d866" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; for this purpose. The &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; define what data to fetch and &lt;code&gt;render&lt;/code&gt; defines what to render. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在React中，渲染视图需要两个输入：要渲染的&lt;em&gt;组件&lt;/em&gt;和要渲染到的&lt;em&gt;根&lt;/em&gt;DOM（UI）节点。渲染中继容器与之类似：我们需要一个&lt;em&gt;容器&lt;/em&gt;进行渲染，并需要从图中的&lt;em&gt;根&lt;/em&gt;开始查询。我们还必须确保对容器的查询已执行，并且可能希望在获取数据时显示加载指示符。与 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; 类似，Relay &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; 提供了&amp;lt;QueryRenderer query = {...}变量= {...} render = {...}&amp;gt;。该 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; 定义哪些数据获取和 &lt;code&gt;render&lt;/code&gt; 定义要渲染的内容。这是我们渲染 &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在React中，渲染视图需要两个输入：要渲染的&lt;em&gt;组件&lt;/em&gt;和要渲染到的&lt;em&gt;根&lt;/em&gt; DOM（UI）节点。渲染中继容器类似：我们需要一个&lt;em&gt;容器&lt;/em&gt;进行渲染，并需要从图中的&lt;em&gt;根&lt;/em&gt;开始查询。我们还必须确保执行了对容器的查询，并且可能希望在获取数据时显示加载指示符。与 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; 相似，Relay &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; 提供了&amp;lt;Relay.Renderer Container = {...} queryConfig = {...}&amp;gt;。该容器呈现项目，以及queryConfig提供了指定查询&lt;em&gt;其&lt;/em&gt;获取项目。这是我们可能的渲染方式 &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">在Relay中，使用&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;描述数据依赖关系。对于 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; ，依赖性可以表示如下。请注意，这与组件用于 &lt;code&gt;user&lt;/code&gt; 道具的形状完全匹配。</target>
        </trans-unit>
        <trans-unit id="eba544839f5e404d357e1b726ac9db4aa7980297" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">在Relay中，使用&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;描述数据依赖关系。对于 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; ，依赖性可以表示如下。请注意，这正是形状的部件预期的匹配 &lt;code&gt;item&lt;/code&gt; 道具。</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">在Relay中，使用&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;描述数据依赖关系。对于 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; ，依赖性可以表示如下。请注意，这正是形状的部件预期的匹配 &lt;code&gt;item&lt;/code&gt; 道具。</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">在Relay中，查询的&lt;strong&gt;根由QueryRenderer&lt;/strong&gt;定义，因此请查看该部分以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">在Relay中，查询的根由&lt;strong&gt;Route&lt;/strong&gt;定义。继续了解中继路线。</target>
        </trans-unit>
        <trans-unit id="8403870f1b9487ea70facda9683cbaadf51f154c" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;pagination-container&quot;&gt;pagination container&lt;/a&gt;, we usually annotate the actual connection field with &lt;code&gt;@connection&lt;/code&gt; to tell Relay which part needs to be paginated:</source>
          <target state="translated">在&lt;a href=&quot;pagination-container&quot;&gt;分页容器中&lt;/a&gt;，我们通常使用 &lt;code&gt;@connection&lt;/code&gt; 注释实际的连接字段，以告诉Relay需要分页的部分：</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">在面向资源的REST系统中，我们可以维护基于URI 的&lt;strong&gt;响应缓存&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">在简单的突变中，您只需要 &lt;code&gt;mutation&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">在简单的订阅中，只需要 &lt;code&gt;subscription&lt;/code&gt; 和 &lt;code&gt;variables&lt;/code&gt; 。当您仅更改可以由其 &lt;code&gt;id&lt;/code&gt; 标识的现有记录的属性时，这是适当的：</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">除bin脚本外， &lt;code&gt;relay-compiler&lt;/code&gt; 软件包还&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;导出库代码&lt;/a&gt;，您可以使用这些库代码为编译器创建更复杂的配置，或使用您自己的自定义输出扩展编译器。</target>
        </trans-unit>
        <trans-unit id="d61a016e90e92a84f22e5f4a46d1a7c70ba615d3" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">除bin脚本外， &lt;code&gt;relay-compiler&lt;/code&gt; 软件包还&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;导出库代码&lt;/a&gt;，您可以使用这些库代码为编译器创建更复杂的配置，或使用您自己的自定义输出扩展编译器。</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">为了增量转换现有的代码库,我们需要使用Relay Modern API,同时继续使用Relay Classic运行时,直到所有组件转换完毕。</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">为了了解如何访问GraphQL服务器，Relay Modern要求开发人员在创建&lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;的实例时提供实现 &lt;code&gt;NetworkLayer&lt;/code&gt; 接口的对象。该环境使用此网络层执行查询，变异和（如果您的服务器支持）订阅。这使开发人员可以使用最适合其应用程序的任何传输方式（HTTP，WebSockets等）和身份验证，从而将环境与每个应用程序的网络配置的细节脱钩。</target>
        </trans-unit>
        <trans-unit id="9751687b059f090db3539850209951869b6090c4" translate="yes" xml:space="preserve">
          <source>In order to pass arguments to a fragment that has &lt;code&gt;@argumentDefinitions&lt;/code&gt;, you need to use the &lt;a href=&quot;graphql-in-relay#arguments&quot;&gt;&lt;code&gt;@arguments&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">为了将参数传递给具有 &lt;code&gt;@argumentDefinitions&lt;/code&gt; 的片段，您需要使用&lt;a href=&quot;graphql-in-relay#arguments&quot;&gt; &lt;code&gt;@arguments&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">为了将片段解析为对象数组，您必须使用 &lt;code&gt;@relay(plural: true)&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">根据我们的经验，绝大多数产品都希望一种特定的行为：在显示加载指示器的同时获取视图层次结构的&lt;em&gt;所有&lt;/em&gt;数据，然后在数据准备好后呈现&lt;em&gt;整个&lt;/em&gt;视图。</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">在最后一个示例中，将 &lt;code&gt;$format&lt;/code&gt; 和 &lt;code&gt;variables.format&lt;/code&gt; 视为相同的值。</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">在上图中。</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;user&lt;/code&gt; 属性将在包含 &lt;code&gt;...Component_internUser&lt;/code&gt; 的所有位置包括 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 字段的数据，而不是Relay屏蔽这些字段的常规行为。</target>
        </trans-unit>
        <trans-unit id="ec241670d9655070dff253ce613242b187214f42" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;user&lt;/code&gt; 属性将在包含 &lt;code&gt;...Component_internUser&lt;/code&gt; 的任何位置包括 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 字段的数据，而不是Relay屏蔽这些字段的正常行为：</target>
        </trans-unit>
        <trans-unit id="d4294ed53c4279bdd7158ab4d044dda1b52e51b3" translate="yes" xml:space="preserve">
          <source>In the example below, the function &lt;code&gt;processItemData&lt;/code&gt; is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the &lt;code&gt;processItemData_item&lt;/code&gt; fragment to ensure all of the correct item data is loaded for this function.</source>
          <target state="translated">在下面的示例中，从React组件调用函数 &lt;code&gt;processItemData&lt;/code&gt; 。它需要一个具有一组特定字段的项目对象。使用此功能的所有React组件都应散布 &lt;code&gt;processItemData_item&lt;/code&gt; 片段，以确保为此功能加载了所有正确的项目数据。</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">未来,Relay中的高级功能可能取决于网络层是否能够支持某些功能。</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">在本文中，我们将探讨构建GraphQL客户端框架的含义以及与传统REST系统的客户端相比如何。在此过程中，我们将研究Relay背后的设计决策，并发现它不仅是GraphQL客户端，还是&lt;em&gt;声明式数据获取&lt;/em&gt;的框架。让我们从头开始，获取一些数据！</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">在此示例中，应使用传递给查询的 &lt;code&gt;userID&lt;/code&gt; 来初始化Route 。该 &lt;code&gt;userID&lt;/code&gt; 变量将自动向下传递到顶级容器，并在需要时可以在此处使用。此外，顶级RelayContainer应该具有一个 &lt;code&gt;user&lt;/code&gt; 片段，其中包含要查询的字段。</target>
        </trans-unit>
        <trans-unit id="fc3d9a2430b8dd6fdd1855b01aae967a1a86922c" translate="yes" xml:space="preserve">
          <source>In this example we are using a Refetch Container to fetch more stories in a story feed component.</source>
          <target state="translated">在这个例子中,我们使用Refetch Container来获取故事feed组件中的更多故事。</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">在此示例中，将为初始渲染获取 &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">在此示例中，基于传递到您的&lt;a href=&quot;relay-environment&quot;&gt;Relay Environment中&lt;/a&gt;的相同源创建检查器对象。以后，您可以使用此检查器对象检查记录。Inspector仅在开发版本中可用。</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">在此示例中，渲染图像的 &lt;code&gt;width&lt;/code&gt; 将始终与用于获取 &lt;code&gt;profilePicture.uri&lt;/code&gt; 当前版本的 &lt;code&gt;$size&lt;/code&gt; 变量相对应。</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">在此示例中，将在 &lt;code&gt;this.props.ship&lt;/code&gt; 上提供与 &lt;code&gt;ship&lt;/code&gt; 片段关联的字段。</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">在此示例中，每当提取 &lt;code&gt;Parent&lt;/code&gt; 时，还将提取 &lt;code&gt;Child&lt;/code&gt; 的片段。渲染时， &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; 将只能访问 &lt;code&gt;props.foo.id&lt;/code&gt; 字段；来自子片段的数据将被&lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;屏蔽&lt;/em&gt;&lt;/a&gt;。默认情况下， &lt;code&gt;childFragment&lt;/code&gt; 将使用其相应的初始变量。中继将获取 &lt;code&gt;photo(size: 64)&lt;/code&gt; 。当 &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; 被呈现它也将提供作为初始变量 &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">在这个例子中,每当加载一个新尺寸的图片时,就会显示一个微调器来代替图片。</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">在此特定示例中， &lt;code&gt;LikeButton&lt;/code&gt; 关心的唯一字段是 &lt;code&gt;viewerDoesLike&lt;/code&gt; 。该字段将构成跟踪查询的一部分，Relay将与该跟踪查询与 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 的胖查询相交，以确定要请求哪些字段作为服务器响应突变的一部分。应用程序中其他位置的另一个组件可能会对&amp;ldquo;关注者人数&amp;rdquo;或&amp;ldquo;喜欢的句子&amp;rdquo;感兴趣。由于这些字段将自动添加到Relay的跟踪查询中，因此 &lt;code&gt;LikeButton&lt;/code&gt; 不必担心显式请求它们。</target>
        </trans-unit>
        <trans-unit id="73de0e214eb1fe6fc2a92866867bd0a77a34d53e" translate="yes" xml:space="preserve">
          <source>In this simple example, let's assume we want to fetch the latest data for a &lt;code&gt;TodoItem&lt;/code&gt; from the server:</source>
          <target state="translated">在这个简单的示例中，假设我们要从服务器获取 &lt;code&gt;TodoItem&lt;/code&gt; 的最新数据：</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">在本教程中，我们将使用GraphQL突变构建游戏。游戏的目标是在9个正方形的网格中找到隐藏的宝藏。我们将给玩家三种尝试来寻找宝藏。这应该使我们对中继进行端到端的研究-从服务器上的GraphQL模式到客户端上的React应用程序。</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">通过以下步骤对您的Relay Classic应用进行升级。</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">可注入式自定义字段处理程序</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">内联片段</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">内联在GraphQL查询的价值，用GraphQL评论潜在的注释（即 &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;relay-modern&quot;&gt;入门指南中&lt;/a&gt;安装最新版本的Relay 。</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">集成选项可用于开源路由库,而是可以并行地获取嵌套路由的数据。在许多这样的情况下,使用批处理网络层可以带来额外的好处,避免发送多个HTTP请求。</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">可通过&lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt;与React Classic v2或v3的Relay Classic集成，这将聚合对匹配路由的查询，并并行请求所有路由的数据。</target>
        </trans-unit>
        <trans-unit id="5681686d7dd00f9ec2ed83d86065fe5a9aa47328" translate="yes" xml:space="preserve">
          <source>Introduction to Relay</source>
          <target state="translated">继电器介绍</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">现代继电器简介</target>
        </trans-unit>
        <trans-unit id="ede0b81585211d6b9897a8c1877bb4add0712d66" translate="yes" xml:space="preserve">
          <source>Invalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="translated">使记录无效。这将导致所有引用该记录的查询被认为是过时的，直到下一次重新检索该记录为止，并且在下次使用 &lt;code&gt;environment.check()&lt;/code&gt; 检查此类查询时，将被视为需要重新记录。</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">还假定读者已经熟悉&lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;&amp;ldquo;星球大战&amp;rdquo;&lt;/a&gt; ; 如果不是的话，1977年版的《星球大战》是一个很好的起点，尽管1997年特别版将用于本文档。</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">假定读者已经熟悉GraphQL；如果不是，那么&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt;的README 是一个不错的起点。</target>
        </trans-unit>
        <trans-unit id="1c307b4b2396ebcfc67f090b9356192c30ee3e15" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;@relay(mask: false)&lt;/code&gt;. Please instead consider using the &lt;code&gt;@inline&lt;/code&gt; fragment.</source>
          <target state="translated">不建议使用 &lt;code&gt;@relay(mask: false)&lt;/code&gt; 。请改为考虑使用 &lt;code&gt;@inline&lt;/code&gt; 片段。</target>
        </trans-unit>
        <trans-unit id="00f22d6b7169a71e14f872d1e3e6975d4ba68fa7" translate="yes" xml:space="preserve">
          <source>It is usually preferable to just pass an &lt;code&gt;optimisticResponse&lt;/code&gt; option instead of an &lt;code&gt;optimisticUpdater&lt;/code&gt;, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).</source>
          <target state="translated">通常最好只传递一个 &lt;code&gt;optimisticResponse&lt;/code&gt; 选项而不是 &lt;code&gt;optimisticUpdater&lt;/code&gt; ，除非您需要对本地记录执行更新，而不仅仅是更新字段（例如，删除记录或向集合中添加项目）更复杂。</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">它返回一个 &lt;code&gt;Disposable&lt;/code&gt; ，您可以在其上调用 &lt;code&gt;dispose()&lt;/code&gt; 来取消刷新。</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">JavaScript环境要求</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">用于定义数据之间的连接和突变的JavaScript助手,与Relay平滑集成。</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">请记住，创建在多个容器之间共享的单个片段通常被视为&lt;strong&gt;反模式&lt;/strong&gt;。滥用此指令可能会导致应用程序过度获取。</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">在我们的下一个指南&lt;a href=&quot;guides-ready-state&quot;&gt;Ready State中&lt;/a&gt;学习如何使用 &lt;code&gt;onReadyStateChange&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">让我们把刚才创建的突变与根突变类型联系起来。</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">让我们对上面的 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 示例做出乐观的回应：</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">让我们通过一个由上方组成 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 组件来探索其工作原理。</target>
        </trans-unit>
        <trans-unit id="25a086b22a4ba22a2ce589d6573f5857d3b2c109" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; we defined above.</source>
          <target state="translated">让我们通过组成上面定义的 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; 组件来探索其工作原理。</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">让我们通过上面组成 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 组件来探索它的工作原理。</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">让我们看看一些产品用例,了解我们是如何将这些想法融入到Relay中的。我们将假设对React有基本的熟悉。</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">让我们打开启动包的模式,用我们刚刚创建的数据库导入替换。</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">我们来看看这个操作,查询叛军的ID。</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">让我们以&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;为基础开始一个项目。</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">我们带着叛军,向他们要第一艘船。</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">让我们调整文件 &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; ，将我们的游戏锚定到架构的 &lt;code&gt;game&lt;/code&gt; 根字段：</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">采用BSD授权许可。</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">像 &lt;code&gt;updater&lt;/code&gt; 一样，不需要为简单的突变（字段更改）提供 &lt;code&gt;optimisticUpdater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">就像可以使用&lt;a href=&quot;guides-containers&quot;&gt;Relay容器一样&lt;/a&gt;，我们可以基于先前的变量和运行时环境，准备供变量的片段生成器使用的变量。</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">像大多数中继API一样，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;尝试在将请求发送到服务器之前使用客户端存储解析数据。如果相反，即使客户端上有可用数据，我们也想强制服务器请求，则可以使用 &lt;code&gt;forceFetch&lt;/code&gt; 布尔属性。</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">像GraphQL URI一样,超时和重试行为可以被配置。</target>
        </trans-unit>
        <trans-unit id="4bcca57dadd610f8dfd235a855de5feef290f38a" translate="yes" xml:space="preserve">
          <source>Loading more data</source>
          <target state="translated">加载更多数据</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">管理异步状态转换和协调并发请求。</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">管理错误;</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">将Relay Classic应用迁移到Relay Modern,不需要从头开始重新编写。相反,每次只需将一个组件转换为Relay Modern API,同时继续保持应用程序的正常运行。一旦所有组件都转换完毕,就可以使用更小更快的Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">将Relay Classic应用迁移到Relay Modern,不需要从头开始重新编写。相反,您可以一次将一个组件转换为Relay Modern API,同时继续保持应用程序的正常运行。一旦所有组件都转换完毕,就可以使用更小更快的Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">迁移到现代继电器</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">现代 &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">分页容器中的现代 &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">现代组件</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">现代突变</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">现代运行时</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">现代： &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">现代： &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; 在Refetch容器中</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">现代：分页容器中的 &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">大多数应用程序将创建一个环境实例并在整个过程中使用它。然而,在特定情况下,您可能希望为不同的目的创建多个环境。例如,每当用户登录或退出时,您可能会创建一个新的环境实例,以防止不同用户的数据被一起缓存。同样,一个服务器渲染的应用程序可能会在每个请求中创建一个新的环境实例,这样每个请求都会得到自己的缓存,用户数据不会重叠。另外,你可能在一个大的应用中拥有多个产品或功能,你希望每个产品都有特定的网络处理或缓存。</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">必须是有效的 &lt;code&gt;RelayContainer&lt;/code&gt; 。中继将在呈现数据之前尝试满足其数据要求。</target>
        </trans-unit>
        <trans-unit id="7b7385bcbd1923e030dad3540db44e565ab25b47" translate="yes" xml:space="preserve">
          <source>Mutates the current record by copying the fields over from the passed in record &lt;code&gt;sourceRecord&lt;/code&gt;.</source>
          <target state="translated">通过复制传入的记录 &lt;code&gt;sourceRecord&lt;/code&gt; 中的字段来对当前记录进行突变。</target>
        </trans-unit>
        <trans-unit id="b750075e624836051694833f9672b6324629ee12" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new linked record on the given the field name.</source>
          <target state="translated">通过在给定的字段名上设置一个新的链接记录来改变当前记录。</target>
        </trans-unit>
        <trans-unit id="eadad1577753ee37f1c2b694617c261c6134b034" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new set of linked records on the given the field name.</source>
          <target state="translated">通过在给定的字段名上设置一组新的链接记录来改变当前记录。</target>
        </trans-unit>
        <trans-unit id="e494f6c0a48343de5c18f2dbf8649d300cc34c93" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new value on the specified field. Returns the mutated record.</source>
          <target state="translated">通过在指定字段上设置一个新的值来改变当前记录。返回变异后的记录。</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">突变道具</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="9d2e9b27d80bdf1627930a58bb10705ab9b7d295" translate="yes" xml:space="preserve">
          <source>Mutations with optimistic updates and the ability to update the cache with arbitrary logic.</source>
          <target state="translated">具有乐观更新的突变,并能以任意逻辑更新缓存。</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">突变器配置</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">嵌套路线</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">具有中继数据依赖性的嵌套路由会带来额外的复杂性。尽管可以为每个路由呈现 &lt;code&gt;QueryRenderer&lt;/code&gt; ，但在通常情况下，父路由只有在可用父路由的数据可用之前才呈现其子路由，这样会导致请求瀑布。通常，这会导致为页面加载数据带来不必要的额外延迟，但对于小型应用程序或浅层路由树的应用程序可能是可接受的。</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">网络层</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">网络层</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">切勿直接 &lt;code&gt;this.props.relay.variables&lt;/code&gt; ，因为它不会触发正确获取数据。像对待 &lt;code&gt;this.props.relay.variables&lt;/code&gt; 一样，将this.props.relay.variables视为不可变的。</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">现代继电器的新产品</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">接下来，安装编译器（通常是 &lt;code&gt;devDependency&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0a3100d6aa2ad29924f0f56bdda1c226229ea566" translate="yes" xml:space="preserve">
          <source>Next, it will &lt;code&gt;subscribe()&lt;/code&gt; using this snapshot in order to be notified of any changes - see the above diagram for &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt;.</source>
          <target state="translated">接下来，它将使用此快照来 &lt;code&gt;subscribe()&lt;/code&gt; 以通知任何更改-请参见上图中的 &lt;code&gt;publish()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">接下来，让我们在 &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; 中创建一个文件，并创建 &lt;code&gt;Relay.Mutation&lt;/code&gt; 的子类，称为 &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; ,以保存我们的突变实现：</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">接下来,让我们定义一个节点接口和类型。我们只需要提供一种方式,让Relay从一个对象映射到与该对象相关联的GraphQL类型,以及从一个全局ID映射到它所指向的对象。</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">接下来,让我们定义一下我们的游戏和隐藏点类型,以及每个类型上可用的字段。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">无路由</target>
        </trans-unit>
        <trans-unit id="2daa1a58378d3c4f7ceb9d6531c197c5be4d948b" translate="yes" xml:space="preserve">
          <source>Non-React functions can also take advantage of data masking. A fragment can be defined with the &lt;code&gt;@inline&lt;/code&gt; directive and stored in a local variable. The non-React function can then &quot;unmask&quot; the data using the &lt;code&gt;readInlineData&lt;/code&gt; function.</source>
          <target state="translated">非反应功能也可以利用数据屏蔽。可以使用 &lt;code&gt;@inline&lt;/code&gt; 指令定义一个片段，并将其存储在局部变量中。然后，non-React函数可以使用 &lt;code&gt;readInlineData&lt;/code&gt; 函数&amp;ldquo;取消屏蔽&amp;rdquo;数据。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="8591e7ed2e6e97908da94c56b629b41aa4eb0746" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;graphql&lt;/code&gt; template tags are &lt;strong&gt;never executed at runtime&lt;/strong&gt;. Instead, they are compiled ahead of time by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="translated">请注意， &lt;code&gt;graphql&lt;/code&gt; 模板标记&lt;strong&gt;永远不会在运行时执行&lt;/strong&gt;。相反，它们由&lt;a href=&quot;#relay-compiler&quot;&gt;Relay编译器&lt;/a&gt;提前编译为生成的工件，这些工件与源代码一起存在，并且Relay需要在运行时进行操作。然后，&lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel插件&lt;/a&gt;会将代码中的 &lt;code&gt;graphql&lt;/code&gt; 文字转换为对生成的文件的 &lt;code&gt;require()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">请注意， &lt;code&gt;ready&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 将继续为假。</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">请注意，&lt;em&gt;强烈&lt;/em&gt;建议 &lt;code&gt;Relay.Container&lt;/code&gt; 定义自己的片段，并避免在容器或文件之间共享内联 &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; 值。如果您发现自己想要共享内联片段，则可能表明该是重构和引入新容器的时候了。</target>
        </trans-unit>
        <trans-unit id="0e023c69475bbeb6872432af3864e74233382b71" translate="yes" xml:space="preserve">
          <source>Note that these modules are &lt;em&gt;loosely coupled&lt;/em&gt;. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the &quot;Concrete&quot; node interfaces in &lt;code&gt;RelayConcreteNode&lt;/code&gt;), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.</source>
          <target state="translated">请注意，这些模块是&lt;em&gt;松散耦合的&lt;/em&gt;。例如，编译器以运行时使用的明确定义的格式发出查询的表示形式（ &lt;code&gt;RelayConcreteNode&lt;/code&gt; 中的&amp;ldquo; Concrete&amp;rdquo;节点接口），以便可以根据需要换出编译器实现。 React / Relay仅依赖于运行时记录良好的公共接口，以便可以替换实际的实现（实际上，我们已经升级了经典的Relay核心，以实现同样的API）。我们希望这种松散的耦合将使社区能够探索新的用例，例如使用Relay运行时开发专用产品API或将运行时与除React之外的视图库进行集成。</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">请注意，此方法需要对服务器的&lt;em&gt;n + 1个&lt;/em&gt;请求：1提取列表，&lt;em&gt;n&lt;/em&gt;提取每个项目。使用GraphQL，我们可以在对服务器的单个网络请求中获取相同的数据（而无需创建随后必须维护的自定义端点）：</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">请注意，这是一个帮助您入门的基本示例。该示例可以使用其他功能扩展，例如请求/响应缓存（例如，在 &lt;code&gt;cacheConfig.force&lt;/code&gt; 为false 时启用）以及上载表单数据以进行变异（ &lt;code&gt;uploadables&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">请注意,这种归一化的缓存结构允许重叠的结果被缓存而不重复。每条记录无论如何获取,都只存储一次。让我们回到前面那个数据不一致的例子,看看这个缓存在这种情况下有什么帮助。</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">请注意，该解决方案也适用于&lt;em&gt;写入&lt;/em&gt;：对缓存的任何更新都会通知受影响的视图，而写入只是更新缓存的另一件事。</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">请注意，组成片段时，组成的片段的类型必须与嵌入片段的父对象上的字段匹配。例如，将 &lt;code&gt;Story&lt;/code&gt; 类型的片段嵌入到 &lt;code&gt;User&lt;/code&gt; 类型的父级字段中是没有意义的。如果您弄错了，Relay和GraphQL将提供有用的错误消息（如果它们没有帮助，请告诉我们！）。</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">注意:在运行时确定变量值</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">注意：在大多数情况下，有可能依赖于默认的环境单例实例，该实例显示为 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">注意:本方法每个实例只能调用一次。</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">注意,它立即执行下一个任务。Relay管理任务的顺序,以确保正确的操作顺序--调度器不能跳过或重新排序任务,只能决定何时执行下一个任务。</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">请注意，游标是base64字符串。这就是之前的模式：服务器提醒我们这是一个不透明的字符串。我们可以将此字符串作为 &lt;code&gt;after&lt;/code&gt; 参数传递回服务器到 &lt;code&gt;ships&lt;/code&gt; 字段，这将让我们要求在上一个结果中的最后一个之后的下三艘船：</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">注意，我们正在查询的数据&lt;em&gt;可能&lt;/em&gt;由于突变而发生了变化。一个明显的问题是：服务器为什么不能只告诉我们发生了什么变化？答案是：很复杂。GraphQL在&lt;em&gt;任何&lt;/em&gt;数据存储层（或多个源的聚合）上进行抽象，并与任何编程语言一起使用。此外，GraphQL的目标是以对产品开发人员构建视图有用的形式提供数据。</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">现在，Relay将同时获取较大的照片尺寸&lt;em&gt;，&lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; 将知道要渲染它。</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">现在Relay将获取大小为128的照片-但是 &lt;code&gt;Child&lt;/code&gt; 容器不会神奇地知道此变量。我们必须通过传递变量值作为道具来告诉它：</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">现在让我们将这些类型与根查询类型关联起来。</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">现在，让我们仔细看一下 &lt;code&gt;config&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">现在我们已经通过这个教程,让我们深入了解一下构建GraphQL客户端框架的意义,以及这与更传统的REST系统的客户端相比有何不同。</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">现在，我们可以实例化一个 &lt;code&gt;ProfileRoute&lt;/code&gt; 来获取用户 &lt;code&gt;123&lt;/code&gt; 的数据：</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">现在,对以前缓存数据的请求可以立即得到响应,而无需进行网络请求。这是一种提高应用程序感知性能的实用方法。但是,这种缓存方法会造成数据一致性的问题。</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">对象识别</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">在中继容器上， &lt;code&gt;bars&lt;/code&gt; 将是数组而不是对象。</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">另一方面，GraphQL &lt;strong&gt;片段&lt;/strong&gt;声明存在于任何任意类型上的字段。例如，以下片段为&lt;em&gt;某个&lt;/em&gt; &lt;code&gt;User&lt;/code&gt; 获取个人资料图片URI 。</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">一旦你的观点的几个或全部使用 &lt;code&gt;QueryRenderer&lt;/code&gt; ， &lt;code&gt;Store&lt;/code&gt; 从 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 可以与被替换 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 。请记住， &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 和 &lt;code&gt;Store&lt;/code&gt; 不共享任何数据。您可能要推迟此步骤，直到可以同时切换具有大量数据重叠的视图。这一步可以为您的应用解锁性能优势。使用 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 的应用程序可以将持久查询ID而不是完整的查询字符串发送到服务器，以及更优化的数据规范化和处理。</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">一旦将所有组件和变体都转换为可以使用Relay Modern API，就可以转换为 &lt;code&gt;QueryRenderer&lt;/code&gt; 而不是 &lt;code&gt;Relay.Renderer&lt;/code&gt; 或 &lt;code&gt;Relay.RootContainer&lt;/code&gt; 。在大多数情况下，您可以从 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 提供 &lt;code&gt;Store&lt;/code&gt; 作为 &lt;code&gt;environment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">一次将 &lt;code&gt;error&lt;/code&gt; 设置为 &lt;code&gt;Error&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; 设置为true，但是将 &lt;code&gt;stale&lt;/code&gt; 设置为false。</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">一旦与 &lt;code&gt;ready&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 设置为true。</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; 设置为false。</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">一旦将 &lt;code&gt;ready&lt;/code&gt; ， &lt;code&gt;done&lt;/code&gt; 和 &lt;code&gt;stale&lt;/code&gt; 设置为true。</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">一旦有了环境，就可以将其传递到&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;实例，或通过 &lt;code&gt;commitUpdate&lt;/code&gt; 函数传递给变异（请参见&amp;ldquo; &lt;a href=&quot;mutations&quot;&gt;变异&lt;/a&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">新API背后的主要思想之一是，通过提前进行工作（从应用程序的运行时到构建时），可以提高执行效率。这样，对GraphQL片段的更改需要一个构建步骤来重新生成一组工件。有关&lt;a href=&quot;relay-compiler&quot;&gt;中继编译器的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="e9e3088ad7030f31124174e1ea72f79d6e9860c5" translate="yes" xml:space="preserve">
          <source>One of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.</source>
          <target state="translated">编译器的主要目标之一是为编写转换或优化GraphQL的工具提供一个一致的平台。这包括通过在编译时将新指令转换掉来实验新指令的能力。变换函数通常应该执行单一类型的修改--预计一个应用程序将在编译器实例中配置多个变换。</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">一种解决方案是让根组件获取其所有子代的数据。但是，这会引入耦合：对组件的每次更改都将需要更改可能呈现该组件的&lt;em&gt;任何&lt;/em&gt;根组件，并且经常更改它与根之间的某些组件。这种耦合可能意味着更大的错误机会并减慢了开发速度。最终，这种方法没有利用React的组件模型。指定数据依赖关系的自然位置是&lt;em&gt;components&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">上面的示例中剩下一件事&amp;ndash;实现 &lt;code&gt;setSize()&lt;/code&gt; ，当滑块值更改时，应该更改照片的大小。除了将每个查询的结果传递给组件之外，Relay还提供了一个具有中继特定方法和元数据的 &lt;code&gt;relay&lt;/code&gt; 道具。其中包括 &lt;code&gt;variables&lt;/code&gt; （用于获取当前 &lt;code&gt;props&lt;/code&gt; 的活动变量 &lt;code&gt;setVariables()&lt;/code&gt; 和setVariables（）（可用于请求不同变量值的数据的回调）。</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">呈现组件时， &lt;code&gt;this.props&lt;/code&gt; 在this.props中填充这些片段指定的字段。这确保了组件在其父组件或任何子组件上都没有隐式依赖性。</target>
        </trans-unit>
        <trans-unit id="cda4387bc6920d739a4c52a2c0a31c33103f5562" translate="yes" xml:space="preserve">
          <source>Optimistic Updates</source>
          <target state="translated">乐观的更新</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">乐观的更新</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">在等待服务器响应突变的同时,优化更新UI。</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">选项1：重新获取应用程序曾经查询过的所有内容。即使这些数据的一小部分实际上会发生变化，我们仍然必须等待服务器执行&lt;em&gt;整个&lt;/em&gt;查询，等待下载结果，然后再次处理它们。这是非常低效的。</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">选项2：仅重新获取主动呈现的视图所需的查询。这是对的选择。然而，该缓存数据略有好转&lt;em&gt;不是&lt;/em&gt;当前正在查看将不会被更新。除非将此数据以某种方式标记为过期或从缓存中清除，否则后续查询将读取过时的信息。</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">选项3：重新获取固定的字段列表，这些字段在突变后&lt;em&gt;可能会&lt;/em&gt;发生变化。我们将此列表称为&lt;strong&gt;繁琐的查询&lt;/strong&gt;。我们发现这也是低效的，因为典型的应用程序仅呈现胖查询的子集，但是这种方法将需要获取所有这些字段。</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">选项4（中继）：重新获取可能发生变化的内容（繁琐的查询）与缓存中的数据的交集。除了缓存数据外，Relay还记得用于提取每个项目的查询。这些称为&lt;strong&gt;跟踪查询&lt;/strong&gt;。通过与跟踪查询和胖查询相交，Relay可以准确查询应用程序需要更新的信息集，仅此而已。</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">可选择在全球范围内安装</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">（可选）跟进对 &lt;code&gt;commit()&lt;/code&gt; 的调用，以将突变发送到服务器。</target>
        </trans-unit>
        <trans-unit id="2495cf5d8b7fcd84a593bb8a6590867f01c41c54" translate="yes" xml:space="preserve">
          <source>Optionally, if the field takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">（可选）如果该字段接受参数，则可以传递一袋 &lt;code&gt;variables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59edbb8c9de82b3a53b356bdf14020ccb99fbd8d" translate="yes" xml:space="preserve">
          <source>Optionally, if the linked record takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt; as well.</source>
          <target state="translated">（可选）如果链接记录带有参数，则也可以传递一袋 &lt;code&gt;variables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">（可选）在调用 &lt;code&gt;applyOptimistic()&lt;/code&gt; 之前，将更新乐观地应用于商店。</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">或者这样,结果一样。</target>
        </trans-unit>
        <trans-unit id="fb12379af7dcaf01e91c059811ab5e2548a2134c" translate="yes" xml:space="preserve">
          <source>Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">或者，该函数接收用于查询数据的先前变量集，并在从服务器获取数据时返回一组新变量，以传递给 &lt;code&gt;refetchQuery&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">重写&lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">覆盖片段变量</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">分页容器</target>
        </trans-unit>
        <trans-unit id="0ca043a41b0b3d0ddc8649acdd7e8b58bdcfa73a" translate="yes" xml:space="preserve">
          <source>Pagination Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt;, similar to a &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, that is designed to simplify the workflow of loading more items in a list &amp;mdash; in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">分页容器也是一个&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;高阶组件&lt;/a&gt;，类似于&lt;a href=&quot;fragment-container&quot;&gt;片段容器&lt;/a&gt;，旨在简化加载列表中更多项目的工作流-在许多情况下，我们不想一次获取所有数据，而是延迟加载更多数据。它依靠GraphQL服务器以标准化的方式公开连接。有关详细规格，请查看&lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;此页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b747c351b01284c892ae1864f74451400f8ded9b" translate="yes" xml:space="preserve">
          <source>Pagination Container works in a very similar way to the &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt; in that you also specify the data requirements for a component via GraphQL fragments in the &lt;code&gt;fragmentSpec&lt;/code&gt;.</source>
          <target state="translated">分页容器在工作方式非常相似的&lt;a href=&quot;fragment-container&quot;&gt;片段容器&lt;/a&gt;中，你还可以通过在GraphQL片段指定组件的数据要求 &lt;code&gt;fragmentSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41bdd858e1fe37bddb1f310d8bfca6222b7c844d" translate="yes" xml:space="preserve">
          <source>Pagination Example</source>
          <target state="translated">分页示例</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="aede896343f70495123a4970ce699b9a49ceb28f" translate="yes" xml:space="preserve">
          <source>Passing Arguments to a Fragment</source>
          <target state="translated">将参数传递给一个片段</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="1037cd9d1a4502e08db2f7acc00d0bfad2fb05f5" translate="yes" xml:space="preserve">
          <source>Persisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the &lt;code&gt;--persist-output&lt;/code&gt; flag to the compiler:</source>
          <target state="translated">可以通过指示Relay Compiler发出有关每个查询，变异和订阅到JSON文件的元数据来启用持久查询。生成的文件将包含查询标识符到查询文本的映射，然后可以将其保存到服务器。要启用持久查询，请对编译器使用 &lt;code&gt;--persist-output&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="c55665b87f33041af7083942a79f605ac2526995" translate="yes" xml:space="preserve">
          <source>Persisting queries</source>
          <target state="translated">持续查询</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 插件应在其他插件或预设之前运行，以确保正确转换 &lt;code&gt;graphql&lt;/code&gt; 模板文字。请参阅&lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;有关此主题的&lt;/a&gt; Babel 文档。</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">请注意，这将替换&lt;a href=&quot;guides-babel-plugin&quot;&gt;旧的Babel Relay插件&lt;/a&gt;。不必同时包含两个插件。</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">填充缓存</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">填充缓存涉及遍历分层的GraphQL响应以及创建或更新规范化的缓存记录。乍一看来，仅响应就足以处理响应，但是实际上，这仅适用于非常简单的查询。考虑 &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash;我们应该如何存储 &lt;code&gt;photo&lt;/code&gt; ？将 &lt;code&gt;photo&lt;/code&gt; 用作缓存中的字段名称将不起作用，因为不同的查询可能会获取相同的字段但参数值不同（例如 &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ）。分页也会发生类似的问题。如果我们获取包含 &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; 的第11到第20个故事，则这些新结果应&lt;em&gt;附加&lt;/em&gt;到现有列表中。</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">处理模式</target>
        </trans-unit>
        <trans-unit id="2765c8e15a74b74082d61d103e52529812b42ae8" translate="yes" xml:space="preserve">
          <source>Products access the store primarily via &lt;code&gt;lookup()&lt;/code&gt; and &lt;code&gt;subscribe()&lt;/code&gt;. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of &lt;code&gt;lookup()&lt;/code&gt; - a &lt;code&gt;Snapshot&lt;/code&gt; - is the input to &lt;code&gt;subscribe()&lt;/code&gt;. This is important because the snapshot contains important information that can be used to optimize the subscription - if &lt;code&gt;subscribe()&lt;/code&gt; accepted only a &lt;code&gt;Selector&lt;/code&gt;, it would have to re-read the results in order to know what to subscribe to, which is less efficient.</source>
          <target state="translated">产品主要通过 &lt;code&gt;lookup()&lt;/code&gt; 和 &lt;code&gt;subscribe()&lt;/code&gt; 进入商店。查找将读取片段的初始结果，然后订阅观察该结果是否有任何更改。请注意， &lt;code&gt;lookup()&lt;/code&gt; 的输出（即 &lt;code&gt;Snapshot&lt;/code&gt; ）是 &lt;code&gt;subscribe()&lt;/code&gt; 的输入。这一点很重要，因为快照包含可用于优化订阅的重要信息-如果 &lt;code&gt;subscribe()&lt;/code&gt; 仅接受 &lt;code&gt;Selector&lt;/code&gt; ，则它必须重新读取结果才能知道要订阅的内容，这效率较低。</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">属性和方法</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="f626c322addc21ad81e099b4b257742e4b44fa03" translate="yes" xml:space="preserve">
          <source>Publishing the results updates the store but does &lt;em&gt;not&lt;/em&gt; immediately notify any subscribers. This is accomplished by calling &lt;code&gt;notify()&lt;/code&gt;...</source>
          <target state="translated">公布结果更新店内但&lt;em&gt;不会&lt;/em&gt;立即通知任何用户。这是通过调用 &lt;code&gt;notify()&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">查询与片段</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">查询命名惯例</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">查询渲染器</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">排队突变,避免竞赛条件。</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">快速入门</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="dd3cac660da0ea89c0136a235305fc5bdb24dcc3" translate="yes" xml:space="preserve">
          <source>React Component</source>
          <target state="translated">React组件</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">React Native配置</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">React Router</target>
        </trans-unit>
        <trans-unit id="0d4f22b3a7ca96ed45a6ce530b418585fac69067" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications.</source>
          <target state="translated">React和Relay支持通过&lt;em&gt;合成来&lt;/em&gt;创建任意复杂的应用程序。可以通过组合较小的组件来创建较大的组件，从而帮助我们创建模块化，强大的应用程序。</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React和Relay支持通过&lt;em&gt;合成来&lt;/em&gt;创建任意复杂的应用程序。可以通过组合较小的组件来创建较大的组件，从而帮助我们创建模块化，强大的应用程序。在Relay中组成组件有两个方面：</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">React组件类可能具有通常通过&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;访问的方法。由于Relay将这些组件实例组成一个容器，因此您需要使用 &lt;code&gt;componentRef&lt;/code&gt; 属性来访问它们：</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">从高速缓存读取</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">通过字段名和代表预定义参数值的对象读取记录上的属性值。</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">准备状态</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">准备状态变化</target>
        </trans-unit>
        <trans-unit id="e61f9d2b516c40c24af8003c73bb3ff7c6a828c5" translate="yes" xml:space="preserve">
          <source>RecordProxy</source>
          <target state="translated">RecordProxy</target>
        </trans-unit>
        <trans-unit id="240b0ea75b5e63f3dae5e35c084b7cb6df230fd2" translate="yes" xml:space="preserve">
          <source>RecordSourceSelectorProxy</source>
          <target state="translated">RecordSourceSelectorProxy</target>
        </trans-unit>
        <trans-unit id="8d339e7dedea41faa4ebfe2fcdc6d599b8f484b5" translate="yes" xml:space="preserve">
          <source>Records that are null in the published source are deleted (set to null) in the store.</source>
          <target state="translated">在发布源中为空的记录在存储中被删除(设置为空)。</target>
        </trans-unit>
        <trans-unit id="4b363b61849ee47f18ae2be0f0d65a8808b2dfa9" translate="yes" xml:space="preserve">
          <source>Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.</source>
          <target state="translated">两者中存在的记录合并成一条新记录(输入不变),结果添加到存储中。</target>
        </trans-unit>
        <trans-unit id="48b512c3d477cc494940cbc3511367f3bc8c1733" translate="yes" xml:space="preserve">
          <source>Records that exist only in the published source are added to the store.</source>
          <target state="translated">只存在于发布源中的记录会被添加到商店中。</target>
        </trans-unit>
        <trans-unit id="2ff3c14aded3e6ad067ba4f314fd7efd64ebd5df" translate="yes" xml:space="preserve">
          <source>Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.</source>
          <target state="translated">具有特殊哨兵值的记录会从存储中删除。这支持取消发布优化创建的记录。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5e8ed94444d1cf7d3d3d0307cd8aaf8c3d6040fc" translate="yes" xml:space="preserve">
          <source>Refetch Container</source>
          <target state="translated">重取容器</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">重取数据(也就是 &quot;查看更多&quot;)。</target>
        </trans-unit>
        <trans-unit id="c9bb21f0d54fefc21f3fe3cd21ff7bc0b0847f63" translate="yes" xml:space="preserve">
          <source>Refetching latest data</source>
          <target state="translated">重取最新数据</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">相关API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">中继经典API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">接力经典指南</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">中继经典接口</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">继电器兼容性</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat是 &lt;code&gt;'react-relay'&lt;/code&gt; 一部分，它使您能够做到这一点，为Relay Modern提供相同的API，同时允许与两个运行时互操作。</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">继电器编译器</target>
        </trans-unit>
        <trans-unit id="9e9a58b9be4e5093877d58bb37e46ff2f5998988" translate="yes" xml:space="preserve">
          <source>Relay Compiler supports the use of &lt;strong&gt;persisted queries&lt;/strong&gt;, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables &lt;em&gt;whitelisting&lt;/em&gt; of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).</source>
          <target state="translated">Relay Compiler支持使用&lt;strong&gt;持久查询&lt;/strong&gt;，其中&lt;strong&gt;查询的&lt;/strong&gt;每个版本都与服务器上的唯一ID关联，并且运行时仅上载持久ID而不是完整的查询文本。这有几个好处：它可以大大减少发送查询（和上传字节）的时间，并使查询&lt;em&gt;列入白名单&lt;/em&gt;。例如，您可以选择禁止以文本形式进行查询，而只允许持久化的查询（大概已经通过了内部代码检查过程的查询）。</target>
        </trans-unit>
        <trans-unit id="3c34dd9f9f2001d5f2a7c52af35f1be4b138b177" translate="yes" xml:space="preserve">
          <source>Relay Compiler will then create the id =&amp;gt; query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.</source>
          <target state="translated">然后，Relay Compiler将在您指定的路径中创建id =&amp;gt;查询文本映射。然后，您可以在服务器端使用此完整的json文件将查询ID映射到操作文本。</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">中继容器</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools是一款旨在帮助开发人员检查他们的Relay状态并了解商店如何随时间变化的工具。Relay DevTools以两种方式发布。</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">中继文件</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">中继环境</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">现代中继</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern附带了基于GraphQL模式为中继容器中使用的片段自动生成流类型的功能。通过确保考虑所有可能的 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 情况（即使它们不经常发生），使用这些Flow类型可以帮助降低应用程序的错误率。</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Relay Modern容器将标准React组件与其数据要求的描述结合在一起，以一个或多个GraphQL片段表示。每个容器本身就是一个标准的React组件，可以使用标准的React API来呈现（例如 &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ）。呈现后，容器将从中继缓存中读取其片段的数据。随着片段数据的变化（例如，由于突变，订阅或更新的查询响应），容器将自动重新呈现组件。</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern支持多种新功能。有些可以通过Compat API获得，而另一些则需要完全升级到Modern运行时。有关更多详细信息，请参见&lt;a href=&quot;new-in-relay-modern&quot;&gt;Relay Modern中的新增功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern是Relay的新版本,它的设计从头开始,更容易使用,更可扩展,而且最重要的是,能够提高移动设备的性能。Relay Modern通过静态查询和超前的代码生成实现了这一点。</target>
        </trans-unit>
        <trans-unit id="45d888a1b92fa795f57aa8cf7b25c2d182f14c5c" translate="yes" xml:space="preserve">
          <source>Relay Modern is composed of three core modules:</source>
          <target state="translated">Relay Modern由三个核心模块组成。</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern需要一个Babel插件来将GraphQL转换为运行时工件。</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern支持GraphQL订阅,使用必要的更新API,允许在收到有效载荷时对存储进行修改。它还具有通过轮询对GraphQL实时查询的实验性支持。</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modern支持以下指令</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern使用Relay编译器将 &lt;code&gt;graphql&lt;/code&gt; 文字转换为与源文件一起存在的生成文件。</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Relay Modern的超前编译需要新的Relay编译器。</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Relay Modern的核心本质上是一个GraphQL数据的非opinionated存储。它可以独立于使用React渲染视图,并可以扩展到与其他框架一起使用。</target>
        </trans-unit>
        <trans-unit id="e31b26fed868774cce2fc303006fb272761f29e5" translate="yes" xml:space="preserve">
          <source>Relay Runtime is designed for use with GraphQL schemas that describe &lt;strong&gt;object graphs&lt;/strong&gt; in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph [1]. To distinguish from JavaScript &lt;code&gt;Object&lt;/code&gt;s, these units of data are referred to as &lt;code&gt;Record&lt;/code&gt;s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of &lt;strong&gt;data ID&lt;/strong&gt;s to &lt;strong&gt;records&lt;/strong&gt;. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual &lt;code&gt;id&lt;/code&gt; field or based on the path to the record from the nearest object with an &lt;code&gt;id&lt;/code&gt; (such path-based ids are called &lt;strong&gt;client ids&lt;/strong&gt;). Each &lt;code&gt;Record&lt;/code&gt; stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a &lt;code&gt;RecordSource&lt;/code&gt;: a mapping of data IDs to &lt;code&gt;Record&lt;/code&gt; instances.</source>
          <target state="translated">中继运行时设计用于GraphQL模式，该模式描述&lt;strong&gt;对象图&lt;/strong&gt;，其中对象具有类型，标识和具有值的字段集。对象可以互相引用，这些对象由其值是图形[1]中一个或多个其他对象的字段表示。为了区别于JavaScript &lt;code&gt;Object&lt;/code&gt; ，这些数据单元称为 &lt;code&gt;Record&lt;/code&gt; 。中继将其内部缓存以及查询/变异/等结果表示为&lt;strong&gt;数据ID&lt;/strong&gt;到&lt;strong&gt;记录&lt;/strong&gt;的映射。数据ID是记录的唯一（相对于缓存而言）标识符-它可以是实际 &lt;code&gt;id&lt;/code&gt; 字段的值，也可以基于从最近的对象到记录的路径（带有 &lt;code&gt;id&lt;/code&gt; （此类基于路径的id称为&lt;strong&gt;客户端id&lt;/strong&gt;）。每个 &lt;code&gt;Record&lt;/code&gt; 存储其数据ID，类型以及已获取的所有字段。多个记录作为 &lt;code&gt;RecordSource&lt;/code&gt; 存储在一起：数据ID到 &lt;code&gt;Record&lt;/code&gt; 实例的映射。</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">继电器规格</target>
        </trans-unit>
        <trans-unit id="5d0eda024fc816c22ea59a24e3cd5865e39cffa0" translate="yes" xml:space="preserve">
          <source>Relay Store</source>
          <target state="translated">中继店</target>
        </trans-unit>
        <trans-unit id="fd195ecee5d7e7a6df1ecbbf4a909cee95b601b9" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">中继允许开发人员通过创建&lt;strong&gt;容器&lt;/strong&gt;来注释其React组件的数据依赖关系。这些是包装原始文档的常规React组件。一个关键的设计约束是React组件具有可重用性，因此Relay容器也必须是可重用的。例如， &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; 组件可能实现用于呈现任何 &lt;code&gt;Story&lt;/code&gt; 项的视图。要呈现的实际故事将由传递给组件的数据确定： &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; 。 GraphQL中的等效项是&lt;strong&gt;片段&lt;/strong&gt;：命名查询片段，用于指定要&lt;em&gt;为给定类型的对象&lt;/em&gt;获取哪些数据。我们可以如下描述 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 所需的数据：</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">中继允许开发人员通过创建&lt;strong&gt;容器&lt;/strong&gt;来注释其React组件与数据的依赖关系。这些是包装原始文档的常规React组件。一个关键的设计约束是React组件可以重用，因此Relay容器也必须是可重用的。例如， &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 组件可能实现用于呈现任何 &lt;code&gt;Story&lt;/code&gt; 项目的视图。要呈现的实际故事将由传递给组件的数据确定： &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; 。 GraphQL中的等效项是&lt;strong&gt;片段&lt;/strong&gt;：命名查询片段，用于指定要&lt;em&gt;为给定类型的对象&lt;/em&gt;获取哪些数据。我们可以如下描述 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 所需的数据：</target>
        </trans-unit>
        <trans-unit id="76c99c886cf994dd48c328f17b234bd016edf810" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">中继也走得更远：它在 &lt;code&gt;props&lt;/code&gt; 上使用不透明标识符，以验证我们在呈现组件之前已明确获取了该组件的数据。如果 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; 呈现了 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; ,但忘记包含其片段，Relay将警告 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; 的数据丢失。实际上，&lt;em&gt;即使&lt;/em&gt;某些其他组件碰巧获取了 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; 所需的相同数据，Relay也会发出警告。这个警告告诉我们，尽管事情现在&lt;em&gt;可能会&lt;/em&gt;奏效，但以后很有可能会崩溃。</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">中继也走得更远：它在 &lt;code&gt;props&lt;/code&gt; 上使用不透明标识符，以验证我们在呈现组件之前已明确获取了组件的数据。如果 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 呈现了 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; ,但忘记了包含其片段，Relay将警告 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 的数据丢失。实际上，&lt;em&gt;即使&lt;/em&gt;某些其他组件碰巧获取了 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 所需的相同数据，Relay也会发出警告。这个警告告诉我们，尽管事情现在&lt;em&gt;可能会&lt;/em&gt;奏效，但以后很有可能会崩溃。</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">Relay还可以让我们完全取代默认的网络层。</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">Relay可以被认为是两个共同工作的部分:一个是用于构建数据驱动组件的API,另一个是用于从GraphQL中获取和存储数据以填充您的应用程序的运行时。Relay Modern同时带来了新的API和新的运行时。</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">中继容器是使用 &lt;code&gt;Relay.createContainer&lt;/code&gt; 创建的。</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">中继容器是高阶组件&amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; 是一个函数，该函数将React组件作为输入，并返回一个新组件作为输出。这意味着容器可以管理数据获取和解析逻辑，而不会干扰内部组件的 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">中继容器提供了静态的 &lt;code&gt;getFragment()&lt;/code&gt; 方法，该方法返回对该组件片段的引用：</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">Relay将React与GraphQL结合起来,并进一步发展了封装的思想。它允许组件指定它们需要的数据,而Relay框架提供数据。这使得内部组件的数据需求变得不透明,并允许对这些需求进行组合。思考一个应用需要什么数据变得本地化到组件上,使得推理哪些字段需要或不再需要变得更容易。</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">Relay确保这些数据在组件渲染之前就可以使用。</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">Relay提供以下API来创建订阅。</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Relay公开了以下API来执行突变。</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">中继片段，突变和查询必须使用带有 &lt;code&gt;Relay.QL&lt;/code&gt; 标签的ES6模板文字来指定。例如：</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">Relay有一个网络层的抽象,它将突变和查询从向GraphQL服务器发送请求的实际机器中分离出来。这让我们可以灵活地配置甚至通过注入完全取代默认的网络层。</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">中继实现了&lt;strong&gt;查询遍历的&lt;/strong&gt;几种变体：将查询与其他数据（如缓存或响应有效负载）一起&lt;strong&gt;遍历的&lt;/strong&gt;操作。例如，当获取查询时，Relay执行&amp;ldquo; diff&amp;rdquo;遍历以确定缺少哪些字段（非常类似于React diffs虚拟DOM树）。在许多常见情况下，这可以减少获取的数据量，甚至在完全缓存查询时甚至允许Relay完全避免网络请求。</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay引入了两类新的对象： &lt;code&gt;RelayContainer&lt;/code&gt; 和 &lt;code&gt;Relay.Route&lt;/code&gt; 。 &lt;code&gt;Relay.PropTypes&lt;/code&gt; 提供了道具验证器，用于断言道具属于这些类型。</target>
        </trans-unit>
        <trans-unit id="2948c3c748b1764a34a269ea9919759693eaf027" translate="yes" xml:space="preserve">
          <source>Relay is a JavaScript framework for building data-driven React applications powered by GraphQL, designed from the ground up to be easy to use, extensible and, most of all, performant. Relay accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay是一个JavaScript框架,用于构建由GraphQL驱动的数据驱动的React应用,它从底层设计开始就具有易用性、可扩展性以及最重要的性能。Relay通过静态查询和超前的代码生成实现了这一点。</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">中继已预先配置为使用与&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;一起使用的默认网络层。此默认网络层通过 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 公开。</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">中继利用GraphQL突变；使我们能够更改客户端和服务器上的数据的操作。要创建在我们的应用中使用的变体，我们将 &lt;code&gt;Relay.Mutation&lt;/code&gt; 子类化，并至少实现下面列出的四个抽象方法。</target>
        </trans-unit>
        <trans-unit id="973d2e671c894478b465827d5c3826264541eadd" translate="yes" xml:space="preserve">
          <source>Relay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.</source>
          <target state="translated">Relay modern对缓存的内容不做任何假设,会对不再引用的数据进行垃圾收集。</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">Relay routes并没有真正实现任何URL路由的特定逻辑,也没有与History API一起工作。在未来,我们也许会将RelayRoute改名为更像RelayQueryRoots或RelayQueryConfig的东西。</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">中继路由实际上并没有实现任何URL路由特定的逻辑，也没有使用History API。将来，我们可能会将RelayRoute重命名为更像RelayQueryRoots或RelayQueryConfig。有关中继为什么不提供URL路由功能的更多信息，以及有关此类解决方案的建议，请参阅&lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">中继通过网络层与GraphQL服务器对话。Relay随附的&lt;a href=&quot;guides-network-layer&quot;&gt;网络层&lt;/a&gt;与现成的express-graphql兼容，并且会随着我们向传输中添加新功能而继续发展。</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">每当基础数据发生变化时,继电器就会更新组件。</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay使用&lt;strong&gt;Babel&lt;/strong&gt;插件将 &lt;code&gt;graphql&lt;/code&gt; 文字转换为对Relay Compiler生成的代码的需求。</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay使用&lt;strong&gt;babel&lt;/strong&gt;插件将 &lt;code&gt;Relay.QL&lt;/code&gt; 字符串模板转换为描述每个查询并包含GraphQL模式数据的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">中继对突变使用一种通用模式，其中它们是具有单个参数 &lt;code&gt;input&lt;/code&gt; 的突变类型的根字段，并且其中输入和输出均包含用于协调请求和响应的客户端突变标识符。</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relay使用所有这些功能来构建围绕连接的抽象,使这些连接易于高效工作,而无需在客户端手动管理游标。</target>
        </trans-unit>
        <trans-unit id="3dc783e9ac2c6bb867e37e0f714a2ddf7651506d" translate="yes" xml:space="preserve">
          <source>Relay uses directives to add additional information to GraphQL documents, which are used by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.</source>
          <target state="translated">Relay使用指令将其他信息添加到GraphQL文档，&lt;a href=&quot;#relay-compiler&quot;&gt;Relay编译器&lt;/a&gt;使用这些指令来生成适当的运行时工件。这些指令仅出现在您的应用程序代码中，并从发送到GraphQL服务器的请求中删除。</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relay使用路由来定义进入Relay应用的入口点。</target>
        </trans-unit>
        <trans-unit id="c47cadca2b04900115d6a0cc7ce416c63eeb2c11" translate="yes" xml:space="preserve">
          <source>Relay uses the Relay Compiler to convert &lt;a href=&quot;#graphql&quot;&gt;&lt;code&gt;graphql&lt;/code&gt;&lt;/a&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">中继使用中继编译器将&lt;a href=&quot;#graphql&quot;&gt; &lt;code&gt;graphql&lt;/code&gt; &lt;/a&gt;文字转换为与源文件一起存在的生成文件。</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0引入了Relay Modern API。</target>
        </trans-unit>
        <trans-unit id="59061b6874678f961da16dff064bafb7cf4ff327" translate="yes" xml:space="preserve">
          <source>Relay will then automatically update the fields under the record corresponding to the ids in the response payload.</source>
          <target state="translated">然后,Relay会自动更新记录下对应响应有效载荷中id的字段。</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">中继将其核心处理功能包装在轻量级任务中，这些任务默认情况下会立即执行（即同步执行）。为了定制&lt;em&gt;当&lt;/em&gt;这些任务运行-例如，以避免触摸手势期间中断的动画-应用程序可以提供自定义调度功能。</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">Relay的数据获取方法在很大程度上得益于我们在React方面的经验。特别是，React将复杂的接口分解为可重用的&lt;strong&gt;组件&lt;/strong&gt;，从而使开发人员可以独立地考虑应用程序的离散单元，并减少应用程序不同部分之间的耦合。更重要的是，这些组件&lt;strong&gt;的声明&lt;/strong&gt;：它们允许开发者指定&lt;em&gt;哪些&lt;/em&gt;用户界面应该看起来像一个给定的状态，而不必操心&lt;em&gt;如何&lt;/em&gt;证明UI。与以前使用命令式命令来处理本地视图（例如DOM）的方法不同，React使用UI描述来自动确定必要的命令。</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relay.PropTypes.QueryConfig:ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer实现一个保守的默认 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ，如果没有片段道具改变并且所有其他道具都是相同的标量值，则返回 &lt;code&gt;false&lt;/code&gt; 。这可能会阻止对通过上下文接收数据的组件的更新。为了确保在这种情况下进行更新，可以通过指定 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 函数来覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">渲染回调</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">渲染容器</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">反复从服务器重新获取信息会变得很慢。例如，从故事列表导航到列表项，然后返回故事列表意味着我们必须重新获取整个列表。我们将使用标准解决方案来解决此问题：&lt;em&gt;缓存&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">申请不同的数据</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">需要从 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 使用Relay Compat API，并像使用Relay Modern一样使用它。使用Relay Compat的组件可以被其他Relay Modern和Relay Classic组件引用。</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">从客户端解析数据</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">响应缓存也可以应用于GraphQL。一个基本的方法与REST版本的工作原理类似。查询本身的文本可以被用作缓存键。</target>
        </trans-unit>
        <trans-unit id="1daed2e622c367b716a7da87b2e2edd04d8d8e79" translate="yes" xml:space="preserve">
          <source>Retrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="translated">根据GraphQL文档的定义，在给定字段名称的情况下检索与当前记录关联的记录。返回一个 &lt;code&gt;RecordProxy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a06b7b5f5bbad1dc68e21eaac11574c07de428a8" translate="yes" xml:space="preserve">
          <source>Retrieves a record from the store given its &lt;code&gt;dataID&lt;/code&gt;. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="translated">给定其 &lt;code&gt;dataID&lt;/code&gt; 从存储中检索记录。返回一个&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;，它用作对记录进行突变的接口。</target>
        </trans-unit>
        <trans-unit id="12402592aaf37a5d3ace23c3d09e0cda3355dad6" translate="yes" xml:space="preserve">
          <source>Retrieves a root field from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="translated">根据GraphQL文档的定义，从给定 &lt;code&gt;fieldName&lt;/code&gt; 的商店中检索根字段。返回一个&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;，它用作对记录进行突变的接口。</target>
        </trans-unit>
        <trans-unit id="17061c12897cde333bc27d9d3b5b4885efbba0b0" translate="yes" xml:space="preserve">
          <source>Retrieves a root field that represents a collection from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns an array of &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据GraphQL文档的定义，在给定 &lt;code&gt;fieldName&lt;/code&gt; 的情况下检索表示商店中集合的根字段。返回一个&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxies&lt;/code&gt; &lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">检索与给定记录相关联的记录,通过字段名和一个代表预定义参数值的对象来横向检索源。</target>
        </trans-unit>
        <trans-unit id="0df40cacc16f0f75e7289c7b00fb27121dcf4af7" translate="yes" xml:space="preserve">
          <source>Retrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="translated">根据GraphQL文档的定义，在给定字段名称的情况下检索与当前记录关联的一条记录。如果链接记录不存在，则将使用给定的类型名称创建该记录。返回一个 &lt;code&gt;RecordProxy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="379be92d54161c2f80dceac4cdce0230264cb208" translate="yes" xml:space="preserve">
          <source>Retrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of &lt;code&gt;RecordProxies&lt;/code&gt;.</source>
          <target state="translated">根据GraphQL文档的定义，在给定字段名称的情况下检索与当前记录关联的记录集。返回一个 &lt;code&gt;RecordProxies&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">重试失败的请求。</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="translated">返回值</target>
        </trans-unit>
        <trans-unit id="6e358acbbc41f30837ea01e45fb712ceb42c930a" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">返回一个 &lt;code&gt;Disposable&lt;/code&gt; ，可以在其上调用 &lt;code&gt;dispose()&lt;/code&gt; 来取消重新提取。</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">Returns a proxy class for manipulating records from a record source,example a query,mutation,or store.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">返回保存所有记录的商店内部RecordSource的只读视图。</target>
        </trans-unit>
        <trans-unit id="ddc37b98bab248dd41f22f1276390ce274609bd3" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; representing the root of the GraphQL document.</source>
          <target state="translated">返回代表GraphQL文档根目录的&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">返回给定记录的GraphQL类型名称。</target>
        </trans-unit>
        <trans-unit id="d43e7555e127344d4f989c546065e0799ff790bb" translate="yes" xml:space="preserve">
          <source>Returns the dataID of the current record.</source>
          <target state="translated">返回当前记录的dataID。</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">返回一个记录的全局唯一标识符字符串。</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">在上述用例中组成可重复使用的碎片。</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">滚回乐观的的变异。</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">根部容器</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">Route在提供渲染组件所处的上下文时很有用。它包含有关当前路由的 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;params&lt;/code&gt; 和 &lt;code&gt;queries&lt;/code&gt; 的信息。</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">路由和查询</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">路由现在是可选的：可以在不定义路由的情况下使用 &lt;code&gt;QueryRenderer&lt;/code&gt; 。&lt;a href=&quot;routing&quot;&gt;路由指南中有&lt;/a&gt;更多内容。</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">路由是定义一组根查询和输入参数的对象。这是一条简单的路线，可用于呈现用户 &lt;code&gt;123&lt;/code&gt; 的个人资料：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
