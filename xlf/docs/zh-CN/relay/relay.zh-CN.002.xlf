<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">路由负责定义进入Relay应用的入口点。但是为了理解为什么需要路由,我们必须先了解GraphQL查询和片段之间的区别。</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">路由可以声明一组需要提供给构造函数的参数名称。这也是一个记录有效参数集的方便地方。</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">路由可以使用 &lt;code&gt;prepareParams&lt;/code&gt; 提供默认参数，或者通过，转换或抑制传入的参数。</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">路由必须使用 &lt;code&gt;Relay.QL&lt;/code&gt; 声明一组查询根。这些查询将在&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;上与该路由一起使用的Relay容器上自动组成一个名为 &lt;code&gt;queryName&lt;/code&gt; 的匹配片段。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">路由必须定义一个字符串名称。</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">路由不再需要了解Relay Modern中的查询根。中继组件可以呈现在 &lt;code&gt;QueryRenderer&lt;/code&gt; 中的任何位置。这将为选择路由框架带来更多的灵活性。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">在您的Relay应用程序中对任何GraphQL进行更改后，运行Relay Compiler。将其添加为 &lt;code&gt;yarn script&lt;/code&gt; 可能会有所帮助。在package.json文件中的 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 中添加一个条目。</target>
        </trans-unit>
        <trans-unit id="3c5a064ba8a60e5ab65def399ab519978d73b564" translate="yes" xml:space="preserve">
          <source>Runtime Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">Schema JSON</target>
        </trans-unit>
        <trans-unit id="114b03b7a51c1001385ac516c6fa621d46453f66" translate="yes" xml:space="preserve">
          <source>Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">有关参数对象上可用的方法，请参见&lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">有关参数对象上可用的方法，请参见&lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt;构造函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;容器&amp;gt;中继容器&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;容器&amp;gt;请求其他数据&lt;/a&gt;，&lt;a href=&quot;guides-ready-state&quot;&gt;就绪状态&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;变异&amp;gt;片段变量&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;变异&amp;gt;片段变量&lt;/a&gt;和&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;突变&amp;gt;突变体配置&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;变异&amp;gt;乐观更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;变异&amp;gt;胖查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-ready-state&quot;&gt;就绪状态&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;根容器&amp;gt;组件和路由&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;根容器&amp;gt;强制提取&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;根容器&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;根容器&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;根容器&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;guides-routes&quot;&gt;路线&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ebcb2b8f4a703f0b6653cd4eb5e389d3a9e4f41" translate="yes" xml:space="preserve">
          <source>See our relay-compiler section in our &lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;Installation and Setup guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e868bde5bb210d570e0bf68dfd4f714decc2503" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container docs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅《&lt;a href=&quot;guides-mutations&quot;&gt;变异指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;guides-network-layer&quot;&gt;网络层指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅《&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;guides-routes&quot;&gt;路线指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">服务器错误</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">设置babel-plugin-relay。</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">设置继电器编译器</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">设置继电器编译器</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">设置babel-plugin-relay。</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">显示更多</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">与React组件的 &lt;code&gt;render&lt;/code&gt; 方法不直接修改本机视图的方式类似，Relay容器也不直接获取数据。相反，容器声明了呈现所需数据的&lt;em&gt;规范&lt;/em&gt;。中继可确保&lt;em&gt;在&lt;/em&gt;渲染&lt;em&gt;之前&lt;/em&gt;此数据可用。</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">更简单的突变API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">由于Relay容器定义的是片段而非查询,因此它们可以轻松地嵌入到多个上下文中。和React组件一样,Relay容器也是高度可重用的。</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">由于一个游戏可以有很多隐藏点,我们需要创建一个连接,我们可以用它把它们连接起来。</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">小包装尺寸</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">到目前为止,我们看了数据提取的低层次方面,并看到了各种熟悉的概念如何转化为GraphQL。接下来,让我们回过头来看看产品开发人员经常面对的一些围绕数据提取的更高层次的问题。</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">到目前为止,我们只是将GraphQL作为典型的REST方法的一个更有效的版本。请注意GraphQL版本中的两个重要好处。</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">到目前为止，我们已经研究了查询数据和保持视图最新的过程，但是还没有研究写入。在GraphQL中，写入称为&lt;strong&gt;突变&lt;/strong&gt;。我们可以将它们视为具有副作用的查询。这是一个调用变异的示例，该变异可能会将给定故事标记为当前用户喜欢的故事：</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">到目前为止,我们已经介绍了两块各自有助于声明数据的内容。</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">因此，对于我们的 &lt;code&gt;introduceShip&lt;/code&gt; 突变，我们创建两种类型： &lt;code&gt;IntroduceShipInput&lt;/code&gt; 和 &lt;code&gt;IntroduceShipPayload&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">那么我们如何使用这个缓存呢？让我们看一下两个操作：接收到响应时写入缓存，以及从缓存中读取以确定查询是否可以在本地实现（与上面的 &lt;code&gt;_cache.has(key)&lt;/code&gt; 等效，但用于图形）。</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">所以现在我们知道了系统中叛军的ID。我们现在可以重新获取他们。</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">所以在第一次查询船舶的时候,GraphQL告诉我们有下一个页面,但是在下一个页面上,它告诉我们已经到了连接的终点。</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">有些字段--尤其是分页数据的字段--可能需要在客户端进行后处理,以便将之前获取的数据与新的信息合并。Relay Modern支持自定义字段处理程序,可用于处理这些字段,以适应各种分页模式和其他用例。</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">有时，父级需要覆盖子级组件的默认变量。想象一下，我们想以128张照片而不是默认的64张照片渲染 &lt;code&gt;Child&lt;/code&gt; ，为此，我们必须确保片段&lt;em&gt;和&lt;/em&gt;容器都知道自定义变量。要在&lt;em&gt;查询中&lt;/em&gt;设置自定义变量，请对 &lt;code&gt;getFragment&lt;/code&gt; 使用第二个参数：</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">源文件</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">将`Relay.Container`的数据依赖关系指定为GraphQL片段。</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">在`Relay.Mutation`中指定突变领域。</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">指定`Relay.Route`的查询。</target>
        </trans-unit>
        <trans-unit id="82c2f41708c8462a6d94834b8d39a6c652c2ac2b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066b54007a4c37add5703334fe870041528f5a58" translate="yes" xml:space="preserve">
          <source>Specifying just the &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">从 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 模块（ &lt;code&gt;createFragmentContainer&lt;/code&gt; ， &lt;code&gt;createRefetchContainer&lt;/code&gt; ， &lt;code&gt;createPaginationContainer&lt;/code&gt; ， &lt;code&gt;commitMutation&lt;/code&gt; ）开始转换组件和变体以使用Relay Modern API 。从叶组件开始向上比较容易。该&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;转换脚本&lt;/a&gt;应该走这一步不那么单调乏味。</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">静态方法</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">步骤0:安装Relay v1.0</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">步骤1:逐步转换为继电器兼容性</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">步骤2：介绍&amp;lt;QueryRenderer&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">第三步:引入Relay Modern运行时。</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">第四步:清理,将Relay Compat更换为Relay Modern。</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="aec0a8c625d33f2410286cd7972018e4c401dd0d" translate="yes" xml:space="preserve">
          <source>Store Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">围绕突变的结构,使其可预测。</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="501433bf93135f5b327aa2f2f9a8b9652febd9e8" translate="yes" xml:space="preserve">
          <source>Support for live queries where supported by the network/server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在兼容和现代模式下均受支持。使用分页容器时，Relay希望使用 &lt;code&gt;@connection&lt;/code&gt; 指令注释连接字段，有关更多详细信息和示例，请转到&lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在经典，兼容和现代模式下受支持。详细用法在&lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; 中进行了&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">真棒!让我们继续前进,并得到下一个四!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">将应用中的 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 引用切换为 &lt;code&gt;'react-relay'&lt;/code&gt; 。这更多是一个清理步骤，可防止您的应用提取不必要的 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="c64e9942fb642977fbd70ec197abeadd198f3103" translate="yes" xml:space="preserve">
          <source>Table of Contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">该输入参数应包含（字符串）&amp;ldquo; clientMutationId&amp;rdquo;属性，以协调请求和响应（由 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API 自动添加）。</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">所使用的 &lt;code&gt;first&lt;/code&gt; 参数 &lt;code&gt;ships&lt;/code&gt; 切片结果集到的第一个。但是，如果我们想分页怎么办？在每个边缘上，将显示一个游标，可用于分页。这次让我们询问前两个，并获取光标：</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Node&lt;/code&gt; 接口和&amp;ldquo; &lt;code&gt;node&lt;/code&gt; 字段为此重新假定使用全局唯一的ID。没有全局唯一ID的系统通常可以通过将类型与特定于类型的ID相结合来合成它们，这就是本例中所做的。</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">该 &lt;code&gt;Node&lt;/code&gt; 接口只包含一个领域， &lt;code&gt;id&lt;/code&gt; ，这是一个 &lt;code&gt;ID!&lt;/code&gt; 。的 &lt;code&gt;node&lt;/code&gt; 根字段接受一个参数，一个 &lt;code&gt;ID!&lt;/code&gt; ，并返回一个 &lt;code&gt;Node&lt;/code&gt; 。这两个协同工作以允许重新引用；如果我们将在该字段中返回的 &lt;code&gt;id&lt;/code&gt; 传递给 &lt;code&gt;node&lt;/code&gt; 字段，我们将获得该对象。</target>
        </trans-unit>
        <trans-unit id="de66ff0a79b624dd454deb3e772e5fb7a040eb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordProxy&lt;/code&gt; serves as an interface to mutate records:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b179aabf77ea5e811ea7880878bfdfa6368ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; is the type of the &lt;code&gt;store&lt;/code&gt; that &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt; receive as an argument. The following is the &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858f5c2de227f30eaba7fc1f9d4f04ab2b8c2484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RelayCompiler&lt;/code&gt; module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a164901ca79b8b4a2a0866d3bc8b9028a8a90acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Store&lt;/code&gt; is the source of truth for application data and provides the following core operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">该 &lt;code&gt;applyUpdate&lt;/code&gt; 增加了一个突变就像 &lt;code&gt;update&lt;/code&gt; ，但没有提交。它返回可以提交或回滚的 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 必须运行之前 &lt;code&gt;react-native&lt;/code&gt; 通天预设。因此，在 &lt;code&gt;.babelrc&lt;/code&gt; 中, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 必须在 &lt;code&gt;babelRelayPlugin&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">该 &lt;code&gt;commitUpdate&lt;/code&gt; 方法类似于在调度磁通的动作。中继对突变的处理如下：</target>
        </trans-unit>
        <trans-unit id="1e1d2e828d0bd7ad1f6ddc74cb042c491b6885f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;graphql&lt;/code&gt; template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt; language. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">该 &lt;code&gt;react-relay&lt;/code&gt; NPM模块包括 &lt;code&gt;react&lt;/code&gt; 作为&lt;em&gt;对等体依赖性&lt;/em&gt;。您的应用程序应明确指定React作为依赖项。</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">该 &lt;code&gt;relay-compiler&lt;/code&gt; 脚本既需要保持你的源文件，以及作为一个通道，你GraphQL模式在任何一个以.json或.graphql架构文件的目录。</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;renderFailure&lt;/code&gt; 回调调用与两个参数：一个 &lt;code&gt;Error&lt;/code&gt; 对象和重试请求的功能。如果错误是服务器响应中传达的服务器错误的结果，则可以在 &lt;code&gt;error.source&lt;/code&gt; 上检查响应有效负载。</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;renderFetched&lt;/code&gt; 回调总是调用一个 &lt;code&gt;data&lt;/code&gt; 参数，它是一个对象映射从 &lt;code&gt;propName&lt;/code&gt; 到查询数据。期望 &lt;code&gt;renderFetched&lt;/code&gt; 回调使用它们来渲染提供的 &lt;code&gt;Component&lt;/code&gt; （例如，使用&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX传播属性功能&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">API整体上更简单,更可预测。</target>
        </trans-unit>
        <trans-unit id="8e85966b9eda2ce8d0b649695a0687a896efc918" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createFragmentContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf72a96b855224dd8974796498f53a592b116371" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createPaginationContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8ac825308dd36be82a845d481fc8dfdffbd9f" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createRefetchContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">包含连接的父节点的DataID。这个参数是可选的。</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">我们返回的ID是base64字符串。ID被设计为不透明的（应该传递给 &lt;code&gt;node&lt;/code&gt; 上 &lt;code&gt;id&lt;/code&gt; 参数的唯一事情是查询系统中某个对象的 &lt;code&gt;id&lt;/code&gt; 的不变结果），并且在GraphQL中base64字符串是一个有用的约定，以提醒查看者字符串是不透明的标识符。</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">接力赛 &quot;环境&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relay &quot;环境 &quot;将Relay运行所需的配置、缓存存储和网络处理捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">接力&amp;ldquo;环境&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">中继 &lt;code&gt;Store&lt;/code&gt; 提供了一个API，用于将变异发送到服务器。</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay Classic和Relay Compat模式可在线生成内容,并可捕获和记录任何检测到的GraphQL验证错误,让这些错误在运行时被抛出。</target>
        </trans-unit>
        <trans-unit id="77da780670013088b3893d46cce4bc75359e000f" translate="yes" xml:space="preserve">
          <source>The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your &lt;code&gt;--src&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c019c5395f2cd9ca47232f5e8ed64fa398b7ada0" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">Relay编译器负责生成代码,作为构建步骤的一部分,在运行时可以静态使用。通过提前构建查询,客户端的JS运行时不需要负责生成查询字符串,而且在构建步骤中可以合并查询中重复的字段,以提高解析效率。如果你有能力将查询持久化到服务器上,编译器的代码生成过程提供了一个方便的时间,将查询或突变的文本转换为唯一的标识符,这大大减少了上传所需的字节数。</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Core增加了对客户端模式扩展的支持。这些扩展允许Relay方便地将一些额外的信息与从服务器获取的数据一起存储,并像其他从服务器获取的字段一样进行渲染。这应该能够取代一些以前需要在侧面存储Flux/Redux的用例。</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPM上发布的Relay Modern包使用了广泛支持的ES5版本的JavaScript,以支持尽可能多的浏览器环境。</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">中继网络层</target>
        </trans-unit>
        <trans-unit id="6ac0bfad74e5d02ff492fbabe1206cbc172f8a94" translate="yes" xml:space="preserve">
          <source>The Relay Store can be used to programmatically update client-side data inside &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt;. The following is a reference of the Relay Store interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">Relay运行时捆绑的规模大约是Relay Classic的20%。</target>
        </trans-unit>
        <trans-unit id="d69ab39bff551c52cbb39536496919006e7104d5" translate="yes" xml:space="preserve">
          <source>The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">在高级边缘情况下,当优化更新需要更精细的控制时,可以对Relay存储进行程序化突变。以下API方法对突变您的连接和碎片很有用。</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">这个故事的作者也对此进行了评论-很常见。现在，假设其他视图正在获取有关作者的新信息，并且她的个人资料照片已更改为新的URI。这里是&lt;em&gt;唯一&lt;/em&gt;改变我们的缓存数据的一部分：</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">现在最好的入门方法是看一下这三个部分是如何结合在一起形成一个有效的示例的。下一页的教程将使用&lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;引导您完成一个示例应用程序，以使您了解如何开始在自己的继电器上使用Relay。</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">客户端和服务器是分离的：客户端指定所需的数据，而不是&lt;em&gt;依靠&lt;/em&gt;服务器端点返回正确的数据。</target>
        </trans-unit>
        <trans-unit id="859e2dd0a260c19654088e28b4f5cf103b3156ab" translate="yes" xml:space="preserve">
          <source>The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42964754dbecedd42dff5df9fe665b9c4e7306" translate="yes" xml:space="preserve">
          <source>The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4的基于组件的方法无法轻松地汇总嵌套路由的数据需求，因此，也无法轻易地避免避免嵌套 &lt;code&gt;QueryRenderer&lt;/code&gt; 组件的请求瀑布的方法。</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">名为 &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; 进行调试的容器将从本地存储中检索每个GraphQL片段的响应。</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">容器将每个片段的结果（以及其他属性）传递到 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">默认的实现方式如下:</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">我们在这里指定的默认值将对我们的片段构建器可用。</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">目前，最简单的入门方法是使用&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;中继入门工具包&lt;/a&gt; -该工具包包括一个示例架构文件，并将&lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npm模块配置为可转换查询。</target>
        </trans-unit>
        <trans-unit id="0041bb913fb29f03cef5bab2b320b6add29c71a8" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">上面的示例没有配置 &lt;code&gt;handlerProvider&lt;/code&gt; ，这意味着将提供默认值。 Relay Modern附带了一些内置的处理程序，这些处理程序通过用于处理连接的特殊功能扩展了内核（这不是标准的GraphQL功能，而是Facebook使用的一组分页约定，详细信息在&lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification中&lt;/a&gt;，并由Relay本身很好地支持）和 &lt;code&gt;viewer&lt;/code&gt; 字段（同样，不是标准的GraphQL模式功能，而是Facebook内部常规使用的功能）。</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">上面的示例与经典容器API非常相似，但是在现代API中，我们可以直接将 &lt;code&gt;graphql&lt;/code&gt; 模板文字作为第二个参数直接传递。中继将根据片段命名约定 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 从片段名称推断prop名称。下面的示例与上面的示例等效：</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">脂肪查询</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">响应中包含被删除节点的DataID的字段名。</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">响应中的字段名,包含被移除节点的DataID,或从连接中移除的节点的路径。</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">响应中代表连接的字段名。</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">响应中代表新创建的边缘的字段名。</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">响应中代表连接父体的字段名。</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">最后的数据声明相当于下面的普通GraphQL。</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">第一次查询的是一个故事清单。</target>
        </trans-unit>
        <trans-unit id="097faf4942075ea29d235eddd8bf227710e8b427" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74925f12cc72e89c1f9fb2151f85c26276ebca60" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with an object containing data obtained from the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ecd22bdcea1bdfd0329a697bfab6ff7e6e06a6" translate="yes" xml:space="preserve">
          <source>The high-level flow of data through the compiler is represented in the following diagram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">该组件的片段可用的初始变量值集。</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">最常用的函数是&lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt;，它使用数据声明包装组件。</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">突变应该接受一个名为 &quot;输入 &quot;的单一参数。</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">新的Relay Modern核心比之前的版本更加轻量级,速度也明显加快。它经过重新设计,可与静态查询配合使用,使我们能够将更多的工作推向构建/编译时间。由于去掉了很多动态查询所需的复杂功能,Modern core的体积更小。新的内核在处理响应时也快了一个数量级,它采用了在构建时生成的优化解析指令集。我们不再将动态查询生成所需的跟踪信息保留在周围,这大大降低了使用Relay的内存开销。这意味着有更多的内存可以用来制作UI的响应速度。Relay Modern还支持持久化查询,将请求的上传大小从完整的查询文本减少到一个简单的id。</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">下一个逻辑方法是使用 &lt;code&gt;render()&lt;/code&gt; 作为启动数据获取的方式。我们可以只对应用程序进行一次渲染，查看它需要什么数据，获取该数据，然后再次渲染。这听起来不错，但问题在于&lt;em&gt;组件使用数据来找出要渲染的内容！&lt;/em&gt;换句话说，这将强制进行数据获取：首先渲染根并查看其需要什么数据，然后渲染其子节点并查看它们到底需要什么，一直到树下。如果每个阶段都引发网络请求，则渲染将需要缓慢的串行往返。我们需要一种方法来预先确定或&lt;em&gt;静态&lt;/em&gt;确定所有数据需求。</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">根据 &lt;code&gt;Relay.Mutation&lt;/code&gt; API ，可选的 &lt;code&gt;config&lt;/code&gt; 参数可用于配置 &lt;code&gt;RANGE_ADD&lt;/code&gt; 或其他类型的突变。这告诉中继如何处理响应。</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">可选的 &lt;code&gt;config&lt;/code&gt; 参数可用于配置 &lt;code&gt;RANGE_ADD&lt;/code&gt; 或其他类型的突变，类似于 &lt;code&gt;Relay.Mutation&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">上面列出的选项并不详尽。如果您知道其他适用于Relay Modern的路由解决方案，&lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;请告知我们&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">分页容器希望使用 &lt;code&gt;@connection(key: ...)&lt;/code&gt; 指令对连接字段进行注释，其中该 &lt;code&gt;key&lt;/code&gt; 是父字段类型 &lt;code&gt;User&lt;/code&gt; 下的唯一标识符。一个好的做法是 &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。默认情况下，Relay根据用户提供的 &lt;code&gt;key&lt;/code&gt; 和该字段的所有非过滤器变量生成存储密钥。中继还提供了一个高级功能 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; ，可让您明确指定应使用哪些变量来生成存储密钥。特别是，如果您编写 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; ，Relay将忽略所有变量。</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">插件需要了解您的架构- 以上代码段中的 &lt;code&gt;schemaData&lt;/code&gt; 。有两种获取此信息的方法，具体取决于GraphQL的实现。</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">这个例子的前提是,我们要使用GraphQL来查询《星球大战》原版三部曲中的舰船和派系信息。</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">声明数据需求的主要方式是通过 &lt;code&gt;Relay.Container&lt;/code&gt; -一种高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">声明数据需求的主要方法是通过 &lt;code&gt;createFragmentContainer&lt;/code&gt; -一种高阶React组件，它使React组件可以编码其数据需求。</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">可以从包装 &lt;code&gt;this.props.relay&lt;/code&gt; React组件的this.props.relay访问以下列出的属性和方法。</target>
        </trans-unit>
        <trans-unit id="e0742e86024158a29e56877db07e441903db2b90" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;@connection&lt;/code&gt; directive is to allow Relay to uniquely identify different connections under a parent type. The &lt;code&gt;@connection&lt;/code&gt; directive takes 2 arguments that help identify the connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c7cfc24fbe1b8654256e17573b27f7600de24e" translate="yes" xml:space="preserve">
          <source>The query and response are traversed together, extracting the results into &lt;code&gt;Record&lt;/code&gt; objects which are added to a fresh &lt;code&gt;RecordSource&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb555f6bd692507da566c1e62919372415cf8fc" translate="yes" xml:space="preserve">
          <source>The query is fetched from the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">查询应该要求 &quot;clientMutationId &quot;作为一个子选择。</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">原因是，如果 &lt;code&gt;babel-plugin-relay&lt;/code&gt; 在 &lt;code&gt;es2015-template-literals&lt;/code&gt; 转换之前未运行，则不会正确转换Relay.QL模板文字。同样在Babel 6中，您无法控制插件顺序。因此，在React Native中， &lt;code&gt;.babelrc&lt;/code&gt; 中的插件在项目 &lt;code&gt;.babelrc&lt;/code&gt; 之前加载。要使用Babel Relay插件，就必须覆盖整个转换列表。</target>
        </trans-unit>
        <trans-unit id="e29f8bf44ff95dd21005f2f7bb6eccf4ec45e350" translate="yes" xml:space="preserve">
          <source>The result of using the &lt;code&gt;graphql&lt;/code&gt; template tag is a &lt;code&gt;GraphQLTaggedNode&lt;/code&gt;; a runtime representation of the GraphQL document which can be used to define &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt;, &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt;, &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt;, &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">运行时自动删除不再引用的缓存数据,有助于减少内存使用。</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下面描述的模式将用于演示Relay使用的GraphQL服务器应实现的功能。这两个核心类型是派系和&amp;ldquo;星球大战&amp;rdquo;宇宙中的一艘船，派系中有许多与之相关的船。下面的模式是GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt;的输出。</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">第二个查询则是重新检索其中一个故事的信息。</target>
        </trans-unit>
        <trans-unit id="c7be7ec56f48de687831bf1d2b8ec095a4494b09" translate="yes" xml:space="preserve">
          <source>The set of IR documents forms a CompilerContext, which is then transformed and optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">缓存GraphQL的解决方案是将层次响应标准化为平坦的&lt;strong&gt;记录&lt;/strong&gt;集合。中继将此缓存实现为从ID到记录的映射。每个记录都是从字段名称到字段值的映射。记录也可以链接到其他记录（允许它描述循环图），并且这些链接被存储为引用回顶级映射的特殊值类型。通过这种方法，每个服务器记录都存储&lt;em&gt;一次，&lt;/em&gt;无论如何获取。</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">此处的&amp;ldquo;变量&amp;rdquo;一词是指服务器端突变的输入，&lt;strong&gt;而不是&lt;/strong&gt;指可用于此突变的片段构建器的变量。</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Relay对GraphQL服务器的三个核心假设是,它提供。</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">两种方法的不同之处在于， &lt;code&gt;forceFetch&lt;/code&gt; 不会发送仅包含客户端缺少的字段的查询，而是发送请求以重新获取每个片段。这样可以确保从服务器中新获取组件的道具。</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; 场的值已更改；因此，记录 &lt;code&gt;2&lt;/code&gt; 也已更改。就是这样。&lt;em&gt;缓存中的&lt;/em&gt;其他内容均不受影响。但是很明显，我们的&lt;em&gt;观点&lt;/em&gt;需要反映更新：UI中的两个作者实例（分别是故事作者和评论作者）都需要显示新照片。</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">然后，在对应用程序文件进行编辑后，只需运行 &lt;code&gt;yarn run relay&lt;/code&gt; 以生成新文件，或 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; 作为长期存在的进程来运行编译器，该进程将在您保存时自动生成新文件。</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">然后，在对您的应用程序文件进行编辑之后，运行 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; 生成新文件，或者运行 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; 将编译器作为一个长期运行的进程运行，只要您保存，它就会自动生成新文件。</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">然后按照之前的步骤运行 &lt;code&gt;yarn run relay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">然后，在您的.babelrc文件中的插件列表中添加 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">有多种解决方案可通过平缓的缓存使视图保持最新状态。 Relay采取的方法是维护从每个UI视图到其引用的ID集的映射。在这种情况下，故事视图将订阅故事（ &lt;code&gt;1&lt;/code&gt; ），作者（ &lt;code&gt;2&lt;/code&gt; ）和评论（ &lt;code&gt;3&lt;/code&gt; 和其他任何内容）的更新。将数据写入缓存时，中继会跟踪受影响的ID，并&lt;em&gt;仅&lt;/em&gt;通知已订阅这些ID的视图。受影响的视图会重新渲染，而未受影响的视图会选择退出重新渲染以获取更好的性能（Relay提供了一个安全但有效的默认值 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ）。没有这种策略，即使是最小的更改，每个视图都会重新呈现。</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">目前只有一个动态地设置一个变量的初始值支持的方法：使用在包括该片段（或通过查询中定义的全局变量 &lt;code&gt;variables&lt;/code&gt; 上的 &lt;code&gt;QueryRenderer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9d42709663369aca59bb9f2ca4e4c05e806c0bb6" translate="yes" xml:space="preserve">
          <source>Therefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">因此，用于GraphQL的规范化响应缓存需要并行处理有效负载和查询。例如，上面的 &lt;code&gt;photo&lt;/code&gt; 字段可能会与生成的字段名称（例如 &lt;code&gt;photo_size(32)&lt;/code&gt; )一起缓存，以便唯一地标识该字段及其参数值。</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">这些是容器将在普通React组件中作为 &lt;code&gt;this.props.relay&lt;/code&gt; 提供的方法和属性。</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">这些功能可以用在几个常见的场景中:记录客户端状态以便以后检查,或者从浏览器的调试器中交互式地探查商店。</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">思考接力</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">用GraphQL思考</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">当数据解析的各种事件发生时,这个回调道具被调用。</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">这个回调道具在数据解析的各种事件发生时被调用。</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">可以通过有条件地呈现&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;进行升级，该QueryRenderer将在呈现数据后加载数据。新的API大大减少了这样做的代码开销。</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">可以使用&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; 对其&lt;/a&gt;进行升级，该RefetchContainer允许您指定用于获取新数据的确切查询。</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">这将导致生成的文件出现在 &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; ，同时具有运行时工件（有助于从中继存储读取和写入）和&lt;a href=&quot;https://flow.org/&quot;&gt;Flow类型&lt;/a&gt;以帮助您编写类型安全的代码。</target>
        </trans-unit>
        <trans-unit id="a9ea7bef6484a7c1cbe254ffda535079f7700daf" translate="yes" xml:space="preserve">
          <source>This document, together with &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; and &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler Architecture&lt;/a&gt;, describes the high-level architecture of Relay &quot;Modern&quot;. The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about &lt;em&gt;using&lt;/em&gt; Relay to build products, the other sections might be more helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">这个例子展示了所有这三个假设。</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">这个例子并不全面,但它的目的是为了快速介绍这些核心假设,在深入研究更详细的库规范之前提供一些背景。</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">此胖查询看起来与任何其他GraphQL查询一样，但有一个重要区别。我们知道其中一些字段是非标量的（例如 &lt;code&gt;friendEdge&lt;/code&gt; 和 &lt;code&gt;friends&lt;/code&gt; ），但是请注意，我们还没有通过子查询来命名它们的任何子级。这样，我们向中继指示，由于这种突变，那些非标量字段下的&lt;em&gt;任何内容都&lt;/em&gt;可能发生变化。</target>
        </trans-unit>
        <trans-unit id="81b1261e20f66bafeb445251ddc3d3efb2158432" translate="yes" xml:space="preserve">
          <source>This fresh &lt;code&gt;RecordSource&lt;/code&gt; would then be published to the store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">这将被转换成一个生成文件的 &quot;懒惰 &quot;需求。</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">这就会被转换成一个立即调用的函数。</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">这会将bin脚本 &lt;code&gt;relay-compiler&lt;/code&gt; 安装在node_modules文件夹中。建议从yarn / npm脚本运行此脚本，方法是将脚本添加到 &lt;code&gt;package.json&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">这是通用重新获取容器的一种特殊化，它针对通过依次获取更多页面的数据来对项目集合进行分页的常见情况而量身定制。有关详细信息，请参见&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">这是到目前为止接收到的事件的数组（请参见下面的 &lt;code&gt;ReadyStateEvent&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果失败，这是 &lt;code&gt;Error&lt;/code&gt; 的一个实例。否则，为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">这只是一个简单的例子:在现实中,缓存必须处理一对多的关联和分页(除此之外)。</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">这是用于创建带有可选 &lt;code&gt;files&lt;/code&gt; ， &lt;code&gt;callbacks&lt;/code&gt; 和 &lt;code&gt;collisionKey&lt;/code&gt; 参数的 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 实例的常规构造函数。</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">这是产品代码可以处理Relay中的突变的最低抽象级别，它对应于&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL规范中&lt;/a&gt;描述的突变操作（&amp;ldquo;先写后取&amp;rdquo;）。您可以指定突变，输入和查询。</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">当&lt;em&gt;所有&lt;/em&gt;数据需求均已准备好呈现时，这是正确的。</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">当渲染所需的数据子集准备就绪时,这是真的。</target>
        </trans-unit>
        <trans-unit id="12c08d7a8f7eb77071004758dca7ab969bb7d7cb" translate="yes" xml:space="preserve">
          <source>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">当处理单个组件内的嵌套或递归数据时,这可能有助于减少冗余片段。</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">这个方法可以选择返回一个承诺,以方便正确的错误传播。</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">在应用了 &lt;code&gt;setVariables&lt;/code&gt; 中的部分变量集之后，也会调用此方法。返回的变量用于填充片段。</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">该方法接收一个数组的查询(而不是单个查询),以便于批量查询,提高网络效率。</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">应该将其升级为使用&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">此代码段将&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;配置为在数据准备就绪后立即在 &lt;code&gt;ScrollView&lt;/code&gt; 组件中呈现 &lt;code&gt;ProfilePicture&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">此代码段配置&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;在需要获取数据时呈现&amp;ldquo; Loading ...&amp;rdquo;文本。</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">这将创建一系列 &lt;code&gt;__generated__&lt;/code&gt; 目录，这些目录与包含 &lt;code&gt;graphql&lt;/code&gt; 标签的相应文件位于同一位置。</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">这将通知 &lt;code&gt;Relay.QL&lt;/code&gt; 此特定字段是一个数组。这也将允许您为片段使用复数名称（即， &lt;code&gt;bars&lt;/code&gt; 而不是 &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">这将产生三个生成的文件，以及两个 &lt;code&gt;__generated__&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">要添加一个新的分页继电器容器</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">要添加一个新的继电器容器</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">要添加一个新的中继容器,有变化的数据要求。</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">要为继电器组件添加新的根</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">要在基础组件上调用此方法，请首先向Relay容器提供 &lt;code&gt;componentRef&lt;/code&gt; 函数。这不同于提供&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;函数的功能，后者将提供对Relay容器本身的引用，而不是对底层React组件的引用。</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">要进行一次突变</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">要在Relay Modern中创建环境实例，请使用 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">要启用&lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt;， &lt;code&gt;relay-compiler&lt;/code&gt; 将为查询强制执行简单的命名约定。查询必须命名为 &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; ，其中&amp;ldquo; &amp;lt;OperationType&amp;gt;&amp;rdquo;是&amp;ldquo;查询&amp;rdquo;，&amp;ldquo;更改&amp;rdquo;或&amp;ldquo;订阅&amp;rdquo;之一。上面的查询名为 &lt;code&gt;ExampleQuery&lt;/code&gt; ,因此应放置在 &lt;code&gt;Example.js&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">要执行此代码，Relay需要访问架构-该架构可能太大而无法捆绑在应用程序内部。而是将这些 &lt;code&gt;Relay.QL&lt;/code&gt; 模板表达式通过 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 转换为JavaScript描述。此架构信息使Relay可以了解诸如字段参数的类型，哪些字段是连接或列表以及如何从服务器有效地重新获取记录之类的内容。</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">强制取回一个组件</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">要开始构建Relay应用,你需要三样东西。</target>
        </trans-unit>
        <trans-unit id="45fa77bbc0446347a81f6d5b23fa090e9c9d6856" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">为了提高感知到的响应速度，您可能希望执行&amp;ldquo;乐观更新&amp;rdquo;，在该更新中，即使在服务器响应返回之前，客户端也会立即更新以反映预期的新值。为此，我们提供了一个 &lt;code&gt;optimisticResponse&lt;/code&gt; 并将其添加到我们传递给 &lt;code&gt;commitMutation&lt;/code&gt; 的 &lt;code&gt;config&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">通过连接进行分页</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">要从缓存中读取信息，我们可以查询并解析每个字段。但是，等等：这听起来与GraphQL服务器处理查询时的操作&lt;em&gt;完全&lt;/em&gt;一样。是的！从缓存读取是执行程序的一种特殊情况，其中a）不需要用户定义的字段函数，因为所有结果都来自固定的数据结构，并且b）结果始终是同步的-我们要么缓存了数据，要么不缓存数据。 t。</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">首先，让我们构建 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 组件的普通React版本，该组件显示用户的个人资料照片和用于调整照片大小的滑块。</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">首先，让我们构建一个 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 组件的普通React版本，该组件显示 &lt;code&gt;Todo&lt;/code&gt; 的文本和完成状态。</target>
        </trans-unit>
        <trans-unit id="2ac483e211ecf7cd1ac9ea59c0478cde75088452" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a hypothetical &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">为我的组件更新一个变量</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">要使用中继编译器，您需要一个.graphql或.json GraphQL模式文件，以描述GraphQL服务器的API。通常，这些文件是服务器真实来源的本地表示，并且不直接编辑。例如，我们可能有一个 &lt;code&gt;schema.graphql&lt;/code&gt; 像这样：</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">为了使用这些片段来构建可以发送到服务器以获取数据的成熟的GraphQL查询，我们需要使用&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="7634bede4230d278e0e78179b1dcae8473d4d33a" translate="yes" xml:space="preserve">
          <source>Types for working with queries and their results include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">典型的Relay Classic代码。</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">典型的旧代码。</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">通常，您将不需要导入生成的定义。该&lt;a href=&quot;babel-plugin-relay&quot;&gt;继电器巴贝尔插件&lt;/a&gt;会转换 &lt;code&gt;graphql&lt;/code&gt; 文字到 &lt;code&gt;require()&lt;/code&gt; 生成的文件。</target>
        </trans-unit>
        <trans-unit id="fe82c32a588b217dd555d86acd7cd881dee1801f" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">在引擎盖下，默认网络层使用 &lt;code&gt;fetch&lt;/code&gt; （&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;）。 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 的构造函数采用一个可选的第二个参数，该参数接受 &lt;code&gt;fetch&lt;/code&gt; 接受的任何有效初始化属性。</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">与查询不同,失败的突变请求不会自动重试。</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">到目前为止，我们仅与GraphQL端点进行交互以执行获取数据的查询。在本指南中，您将学习如何使用中继执行突变-这些操作包括对数据存储的写操作，然后是对任何已更改字段的获取。</target>
        </trans-unit>
        <trans-unit id="706a52f4ea94115123954122a8c78690d8a63036" translate="yes" xml:space="preserve">
          <source>Updater Configs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">更新与可变记录相关联的记录,通过字段名和代表预定义参数值的对象横向更新源。</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">更新由字段名和代表预定义参数值的对象给出的可变记录的属性值。</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">在每次响应时更新客户端</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">乐观地更新客户端</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">接收到查询/变异响应后更新本地缓存。</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">以程序方式更新商店(高级</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">升级到 react-relay v1.0.0。</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">升级setVariables</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="64cfd0b3a8ed6125a106524eb46cf6330e091d8e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitLocalUpdate&lt;/code&gt; when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay &lt;code&gt;environment&lt;/code&gt; and an &lt;code&gt;updater&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443a1d180d1993141d5ed99d3c993a96f971b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitMutation&lt;/code&gt; to create and execute mutations. &lt;code&gt;commitMutation&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">使用 &lt;code&gt;introspectionQuery&lt;/code&gt; 为Babel中继插件生成Schema JSON，并使用 &lt;code&gt;printSchema&lt;/code&gt; 生成用户可读类型的系统速记：</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;graphql&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">使用其他GraphQL实现</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">使用缓存</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;relay-compat&quot;&gt;兼容模式&lt;/a&gt; &amp;rdquo; 下转换期间使用</target>
        </trans-unit>
        <trans-unit id="410e9ae9e9ce0fe0fb15689548590810d66caa99" translate="yes" xml:space="preserve">
          <source>Using updater and optimisticUpdater</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">与Relay Classic一起使用</target>
        </trans-unit>
        <trans-unit id="9ea691c61eebccf391fb8820180c4ca2beda5321" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are just standard React components. Here's the &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">视图构图&lt;em&gt;正是&lt;/em&gt;您习惯的-中继容器是标准的React组件。这是 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">视图合成&lt;em&gt;正是&lt;/em&gt;您所习惯的-中继容器是标准的React组件。这是 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">热身</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">我们构建了一些脚本来帮助您完成转换过程。在&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod上&lt;/a&gt;查看它们。</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">我们可以通过提供 &lt;code&gt;renderLoading&lt;/code&gt; 道具来更改此行为：</target>
        </trans-unit>
        <trans-unit id="99418ef7bda442472813dd7c77c28063f221dc1b" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; and define a new type called &lt;code&gt;Setting&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09384c922b7bcbae85b63823d4facb25583f0ebf" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a &lt;code&gt;configs&lt;/code&gt; array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">我们可以以配置数组的形式给Relay下达指令,说明如何使用每个突变的响应来更新客户端的存储。我们通过用以下一种或多种突变类型配置突变来实现。</target>
        </trans-unit>
        <trans-unit id="8b225a6bc0d167f8b54e806d442a842dc3c15baa" translate="yes" xml:space="preserve">
          <source>We can then extend existing server types in the client schema &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; with our new &lt;code&gt;Setting&lt;/code&gt; type, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">我们在这里声明我们的突变的数据依赖性,就像在容器中一样。这对于确保我们可能想在这个突变的乐观响应中使用的一组字段已经被获取特别有用。</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">我们需要一个藏宝的地方,一个检查藏宝地点的方法,以及一个跟踪我们剩余回合的方法。在本教程中,我们将把这些数据隐藏在内存中。</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">我们需要给Relay下达指令,说明如何使用每个突变的响应有效载荷来更新客户端存储。我们通过将突变配置为以下一种或多种突变类型来实现。</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">我们最终选择了静态方法。组件将有效地返回与视图树分离的查询树，以描述其数据依赖性。然后，Relay可以使用此查询树来获取单个阶段所需的所有信息，并使用它来呈现组件。问题在于找到一种描述查询树的适当机制，以及一种从服务器（即在单个网络请求中）有效获取查询树的方法。这是GraphQL的完美用例，因为它提供了一种语法，用于&lt;em&gt;将数据依赖关系描述为data&lt;/em&gt;，而无需指定任何特定的API。请注意，通常建议将Promises和Observables作为替代方案，但它们表示&lt;em&gt;不透明的命令，&lt;/em&gt;并且会排除各种优化方法，例如查询批处理。</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">现在，根据访问故事的方式，我们将看到不同的 &lt;code&gt;likeCount&lt;/code&gt; 。使用第一个查询的视图将看到过期的计数，而使用第二个查询的视图将看到更新的计数。</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">我们几乎准备好让Relay满足这些组件的数据要求并进行渲染。但是，有一个问题。为了使用GraphQL实际获取数据，我们需要一个查询根。例如，我们需要将 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 片段置于 &lt;code&gt;User&lt;/code&gt; 类型的具体节点中。</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">我们发现，GraphQL模式与磁盘上存储数据的形式略有不同甚至根本不同的情况很常见。简而言之：基础&lt;em&gt;数据存储&lt;/em&gt;（磁盘）中的数据更改与&lt;em&gt;产品可视化架构&lt;/em&gt;（GraphQL）中的数据更改之间并不总是存在1：1的对应关系。完美的例子就是隐私：返回 &lt;code&gt;age&lt;/code&gt; 等面向用户的字段可能需要访问我们的数据存储层中的许多记录，以确定是否甚至允许活动用户&lt;em&gt;看到&lt;/em&gt;该 &lt;code&gt;age&lt;/code&gt; （我们是朋友吗？我的年龄是否共享？ ？我阻止了您吗？等。</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">我们发现，使用命令性API进行数据提取的典型方法迫使开发人员处理过多的这种不必要的复杂性。例如，考虑&lt;em&gt;乐观的UI更新&lt;/em&gt;。这是在等待服务器响应时向用户提供反馈的一种方式。的逻辑&lt;em&gt;是什么&lt;/em&gt;做的可以说是相当清楚的：当用户点击&amp;ldquo;喜欢&amp;rdquo;，纪念的故事，被人喜欢和发送请求到服务器。但是实现通常要复杂得多。命令式方法要求我们执行所有这些步骤：进入UI并切换按钮，发起网络请求，在必要时重试，在失败时显示错误（并取消切换按钮）等。数据也是如此-获取：指定我们通常需要指示&lt;em&gt;哪些&lt;/em&gt;数据&lt;em&gt;如何&lt;/em&gt;以及&lt;em&gt;何时&lt;/em&gt;获取。接下来，我们将探索使用&lt;strong&gt;Relay&lt;/strong&gt;解决这些问题的方法。</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">我们已经看到，中继容器确保&lt;em&gt;在&lt;/em&gt;呈现组件&lt;em&gt;之前&lt;/em&gt;获取GraphQL片段。但是容器还提供了另一个尚不立即显而易见的好处：&lt;strong&gt;数据屏蔽&lt;/strong&gt;。中继仅允许组件访问其专门要求的数据 &lt;code&gt;fragments&lt;/code&gt; ，仅此而已。因此，如果一个故事的一个组成部分的查询 &lt;code&gt;text&lt;/code&gt; ，另一个是它的 &lt;code&gt;author&lt;/code&gt; ，每个人都可以看到&lt;em&gt;只有&lt;/em&gt;他们要求的领域。实际上，组件甚至看不到其&lt;em&gt;子级&lt;/em&gt;请求的数据：这也会破坏封装。</target>
        </trans-unit>
        <trans-unit id="e1d701dcb15b88a66be26dfbe21cdfc47c48bde8" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in GraphQL fragments &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">我们在这里写的是一个模拟的数据库接口。我们可以想象将它连接到一个真实的数据库,但现在让我们继续前进。</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">有什么用？中继兼容性（ &lt;code&gt;'react-relay/compat'&lt;/code&gt; ）是最灵活的。兼容组件和变异可以被任何事物使用。兼容组件也可以具有任何子代。</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">当&amp;ldquo;强制获取&amp;rdquo;时，如果由于服务器请求完成之前客户端上的数据可用而导致 &lt;code&gt;ready&lt;/code&gt; 为true，则为true。</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">当 &lt;code&gt;forceFetch&lt;/code&gt; 是真实的， &lt;code&gt;renderFetched&lt;/code&gt; 被称为可用的客户端数据的结果， &lt;code&gt;renderFetched&lt;/code&gt; 被调用，具有第二个参数 &lt;code&gt;stale&lt;/code&gt; 布尔属性。该 &lt;code&gt;stale&lt;/code&gt; ，如果属性为true &lt;code&gt;renderFetched&lt;/code&gt; 被强制要求服务器完成之前调用。</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">当 &lt;code&gt;forceFetch&lt;/code&gt; 为true时，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将始终向服务器发送请求。但是，如果渲染所需的所有数据在客户端上也都可用，则在服务器请求完成之前仍可以调用 &lt;code&gt;renderFetched&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">当Relay完成数据时，将使用描述当前&amp;ldquo;就绪状态&amp;rdquo;的对象一次或多次调用 &lt;code&gt;onReadyStateChange&lt;/code&gt; 回调。该对象具有以下属性：</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">当渲染所需的所有数据可用时，&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;将默认渲染提供的 &lt;code&gt;Component&lt;/code&gt; 。但是，我们可以通过为 &lt;code&gt;renderFetched&lt;/code&gt; 属性提供回调来更改此行为：</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">当满足所有数据要求时，将调用 &lt;code&gt;renderFetched&lt;/code&gt; 呈现视图。渲染时，预期此回调会将 &lt;code&gt;data&lt;/code&gt; 传播到提供的 &lt;code&gt;Container&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">在编译代码进行生产部署时,插件可以配置为遇到验证问题时立即抛出。该插件可以通过以下选项针对不同环境进一步定制。</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">当无法满足数据要求时，将调用 &lt;code&gt;renderFailure&lt;/code&gt; 呈现视图。</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">当尚未满足数据要求时，将调用 &lt;code&gt;renderLoading&lt;/code&gt; 呈现视图。如果返回 &lt;code&gt;undefined&lt;/code&gt; ，则呈现先前呈现的视图（如果没有先前的视图则不呈现）。</target>
        </trans-unit>
        <trans-unit id="9fd4594d265309e3ea2f8851c4e096213978657c" translate="yes" xml:space="preserve">
          <source>When defining a fragment for use with a Fragment container, you can use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a &lt;code&gt;@relay(plural: true)&lt;/code&gt; fragment should do so within a plural field (ie a field backed by a &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL list&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619aba17233daa1e1d7ee5e3869b79e1331126b3" translate="yes" xml:space="preserve">
          <source>When defining a fragment, you can use the &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt; directive to specify any arguments, with potentially default values, that the fragment expects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">设计胖查询时，请考虑由于变异而可能更改的&lt;em&gt;所有&lt;/em&gt;数据，而不仅仅是应用程序当前正在使用的数据。我们不必担心超量获取；在未与应用程序实际需要的数据的&amp;ldquo;跟踪查询&amp;rdquo;相交之前，绝不会执行此查询。如果在胖查询中省略字段，则将来在添加具有新数据依赖项的视图或向现有视图添加新数据依赖项时，我们可能会观察到数据不一致的情况。</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">当将Relay Classic应用程序逐步转换为Relay Modern 时，如果配置为使用兼容模式， &lt;code&gt;graphql&lt;/code&gt; 文字可以转换为&lt;em&gt;两个&lt;/em&gt;运行时&lt;em&gt;都&lt;/em&gt;可以使用：</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">当它发送查询时,会在超时15秒后自动失败请求。同时,失败的请求会自动重试两次,分别延迟1秒和3秒。</target>
        </trans-unit>
        <trans-unit id="c328250268c48757d266a5578f320e2cd118ae4e" translate="yes" xml:space="preserve">
          <source>When not nesting routes with Relay data dependencies, such as when using flat routes, it is sufficient to just render a &lt;code&gt;QueryRenderer&lt;/code&gt; for the parts of your application that require Relay data. You can also use the options below that integrate your routes with their data dependencies.</source>
          <target state="translated">当不嵌套具有中继数据依赖性的路由时（例如使用平面路由时），只需为需要中继数据的应用程序部分呈现 &lt;code&gt;QueryRenderer&lt;/code&gt; 就足够了。您还可以使用下面的选项，这些选项将您的路由与其数据依赖项集成在一起。</target>
        </trans-unit>
        <trans-unit id="c958feb46013f0ddcda8fd3772356651d46f8e8a" translate="yes" xml:space="preserve">
          <source>When problems arise developers would need an insight into Relay's store. Relay provides a couple of tools to inspect the store and its records programmatically and visually.</source>
          <target state="translated">当出现问题时,开发人员需要对Relay的商店进行深入了解。Relay提供了几个工具,可以通过编程和可视化的方式检查商店及其记录。</target>
        </trans-unit>
        <trans-unit id="5d9ce00224dd61a4d32a2854970285a45cfbec29" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, &lt;code&gt;ProfilePicture&lt;/code&gt; will be rendered. Props with fragments will contain data that was fetched from the server.</source>
          <target state="translated">当上面的&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;呈现时，Relay将构造一个查询并将其发送到GraphQL服务器。一旦获取了所有必需的数据， &lt;code&gt;ProfilePicture&lt;/code&gt; 将被渲染。带有片段的道具将包含从服务器获取的数据。</target>
        </trans-unit>
        <trans-unit id="c67a5c120de0df00997c004e146051bbad946df1" translate="yes" xml:space="preserve">
          <source>When the server response is received, one of the callbacks is invoked:</source>
          <target state="translated">当收到服务器响应时,其中一个回调被调用。</target>
        </trans-unit>
        <trans-unit id="cea8475e3aa555845df5b9bb69835f08e0fe8ca8" translate="yes" xml:space="preserve">
          <source>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - &lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded. - &lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">提交事务并从服务器收到响应后，将调用以下回调之一：- &lt;code&gt;onSuccess&lt;/code&gt; 如果成功完成了突变， onSuccess。- 如果突变失败，则调用 &lt;code&gt;onFailure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15eef2fb6be75cc68d0e3ddb99ea3d827fbcd3d5" translate="yes" xml:space="preserve">
          <source>When this response is normalized, Relay can detect that this result overlaps with existing data based on its &lt;code&gt;id&lt;/code&gt;. Rather than create a new record, Relay will update the existing &lt;code&gt;123&lt;/code&gt; record. The new &lt;code&gt;likeCount&lt;/code&gt; is therefore available to &lt;em&gt;both&lt;/em&gt; queries, as well as any other query that might reference this story.</source>
          <target state="translated">将此响应标准化后，Relay可以根据其 &lt;code&gt;id&lt;/code&gt; 检测到该结果与现有数据重叠。Relay不会创建新记录，而是会更新现有的 &lt;code&gt;123&lt;/code&gt; 条记录。新的 &lt;code&gt;likeCount&lt;/code&gt; 可用于&lt;em&gt;两个&lt;/em&gt;查询以及可能引用此故事的任何其他查询。</target>
        </trans-unit>
        <trans-unit id="30790e3c432f6503a40e8e00ea839d4b3685867b" translate="yes" xml:space="preserve">
          <source>When upgrading an existing Relay app, replace all &lt;code&gt;require('react-relay')&lt;/code&gt; with &lt;code&gt;require('react-relay/classic')&lt;/code&gt; to continue to import the Relay Classic API.</source>
          <target state="translated">升级现有的中继应用程序时，请替换所有 &lt;code&gt;require('react-relay')&lt;/code&gt; 替换为 &lt;code&gt;require('react-relay/classic')&lt;/code&gt; ,以继续导入Relay Classic API。</target>
        </trans-unit>
        <trans-unit id="880864fa4e14c5e5caab7b10626e640aee6def2a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, the restrictions on queries from Relay Classic are removed: queries may contain multiple root fields that use arbitrary arguments and return singular or plural values. The &lt;code&gt;viewer&lt;/code&gt; root field is now optional.</source>
          <target state="translated">使用&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; 时&lt;/a&gt;，将消除对Relay Classic中查询的限制：查询可能包含多个使用任意参数并返回单数或复数值的根字段。的 &lt;code&gt;viewer&lt;/code&gt; 根场现在是可选的。</target>
        </trans-unit>
        <trans-unit id="eec48adcf595a6ca86caad379b181d97a2f010ca" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;, Relay expects connection fields to be annotated with a &lt;code&gt;@connection&lt;/code&gt; directive. For more detailed information and an example, check out the &lt;a href=&quot;pagination-container#connection&quot;&gt;docs on using &lt;code&gt;@connection&lt;/code&gt; inside a Pagination Container&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdabb7b5c56a4bc287f21143e07d2eb721a2af6c" translate="yes" xml:space="preserve">
          <source>When you provide these functions, this is roughly what happens during the mutation request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384e273feee00773d8ac2cb8c10110ccc823425a" translate="yes" xml:space="preserve">
          <source>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback.</source>
          <target state="translated">每当Relay满足数据要求时，了解何时发生某些事件会很有用。例如，我们可能想记录数据可用的时间，或者我们想将错误记录到服务器。这些事件可通过 &lt;code&gt;onReadyStateChange&lt;/code&gt; 回调在大多数Relay API上使用。</target>
        </trans-unit>
        <trans-unit id="e8cd144d9041c40f96f66e2aa651ea3465a4503f" translate="yes" xml:space="preserve">
          <source>Wherever the inverse grammar serves you better, you can use &lt;code&gt;@skip(if: ...)&lt;/code&gt; instead of &lt;code&gt;@include(if: ...)&lt;/code&gt;.</source>
          <target state="translated">无论逆语法如何为您提供更好的服务，都可以使用 &lt;code&gt;@skip(if: ...)&lt;/code&gt; 代替 &lt;code&gt;@include(if: ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f3e2838c0630aa2c4914a0c2d4e6ea23e0c95ac" translate="yes" xml:space="preserve">
          <source>Whether the request was aborted.</source>
          <target state="translated">请求是否被中止。</target>
        </trans-unit>
        <trans-unit id="422efd22184fb3e6c495b98266ee159c3842165d" translate="yes" xml:space="preserve">
          <source>While typically Relay only provides the data for fields explicitly requested by a component's fragment, &lt;code&gt;@relay(mask: false)&lt;/code&gt; can be added to a fragment spread to not mask that data, recursively including the data from the fields of the referenced fragment.</source>
          <target state="translated">虽然通常Relay只为组件片段明确请求的字段提供数据，但 &lt;code&gt;@relay(mask: false)&lt;/code&gt; 可以添加到片段扩展中以不掩盖该数据，从而递归地包含来自引用片段字段的数据。</target>
        </trans-unit>
        <trans-unit id="ff506c81a21b554c2790ef2e5a963a42aff57850" translate="yes" xml:space="preserve">
          <source>While you type queries as follows:</source>
          <target state="translated">当你键入查询如下。</target>
        </trans-unit>
        <trans-unit id="0b57cc238bcb966947c54d303e25a36f527aba7b" translate="yes" xml:space="preserve">
          <source>While you type queries as:</source>
          <target state="translated">当你输入查询为。</target>
        </trans-unit>
        <trans-unit id="223f6c68b8dfddbadc2aa76589625320726b0252" translate="yes" xml:space="preserve">
          <source>Will cause a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d32def387eb6db627a1048487211194f68d2887" translate="yes" xml:space="preserve">
          <source>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap &amp;mdash; it caches based on distinct queries. For example, if we issue a query to fetch stories:</source>
          <target state="translated">使用GraphQL，重叠多个查询的结果非常普遍。但是，上一节中的响应缓存并没有考虑到这种重叠-它基于不同的查询进行缓存。例如，如果我们发出查询以获取故事：</target>
        </trans-unit>
        <trans-unit id="326b4ac13e70484638c8e2c275bb7155ff73eafd" translate="yes" xml:space="preserve">
          <source>With a normalized response cache, a record would be created for each story in the list. The &lt;code&gt;stories&lt;/code&gt; field would store links to each of these records.</source>
          <target state="translated">使用规范化的响应缓存，将为列表中的每个故事创建一条记录。该 &lt;code&gt;stories&lt;/code&gt; 字段将存储链接到每个这些记录。</target>
        </trans-unit>
        <trans-unit id="9443a9eb3d5ff45b05255468c9ca88197b385e42" translate="yes" xml:space="preserve">
          <source>With some additional configuration, the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel plugin can also translate Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; literals. Most importantly, include a reference to your GraphQL Schema as either a json file or graphql schema file.</source>
          <target state="translated">通过一些附加配置， &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel插件还可以转换Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; 文字。最重要的是，以json文件或graphql模式文件包含对GraphQL模式的引用。</target>
        </trans-unit>
        <trans-unit id="b4fdf6745c6472ea632228aac1bf14006ef03d88" translate="yes" xml:space="preserve">
          <source>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</source>
          <target state="translated">查询完毕后,让我们开始进行唯一的突变:通过检查一个地点是否有宝藏来度过一个回合。在这里,我们定义了突变的输入(要检查宝藏的地点的id),以及在突变发生后客户端可能想要更新的所有可能的字段的列表。最后,我们实现一个执行底层突变的方法。</target>
        </trans-unit>
        <trans-unit id="7ddd9cfe22f7c960a4c67535583b19ffb8497a42" translate="yes" xml:space="preserve">
          <source>With this input and payload, we can issue the following mutation:</source>
          <target state="translated">有了这个输入和有效载荷,我们就可以发出以下突变。</target>
        </trans-unit>
        <trans-unit id="dce3644542cd9fbd082b44d7cadd316ad1975d62" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e36e32aeb9398daa0c7117970d61b1237b724a3" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">通过典型的数据获取方法，我们发现两个组件具有&lt;em&gt;隐式依赖关系&lt;/em&gt;是很常见的。例如， &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 可能会使用某些数据而没有直接确保已获取数据。该数据通常会被系统的其他某些部分（例如 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; )获取。然后，当我们更改 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 并删除该数据获取逻辑时， &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 会突然莫名其妙地中断。这些类型的错误并不总是立即可见，尤其是在较大的团队开发的较大应用程序中。手动和自动测试只能提供很多帮助：这正是框架可以更好地解决的系统性问题。</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="5c338a274513fe1f278459839f0c78f7e6b91728" translate="yes" xml:space="preserve">
          <source>Writing the game</source>
          <target state="translated">编写游戏</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1696149c59259541ba3a1d3a3c3c107fc68c94e9" translate="yes" xml:space="preserve">
          <source>Yes*</source>
          <target state="translated">Yes*</target>
        </trans-unit>
        <trans-unit id="d38ce88b105c03a9bcdfa9b0ae57cef87a38afbe" translate="yes" xml:space="preserve">
          <source>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</source>
          <target state="translated">你也可以从包含它的外部片段向突变的片段构建器传递变量。</target>
        </trans-unit>
        <trans-unit id="2a3a0a2cf926b5e31314761fde4d2b924ad01e95" translate="yes" xml:space="preserve">
          <source>You can conditionally include or skip a field based on the value of a boolean variable.</source>
          <target state="translated">您可以根据布尔变量的值有条件地包含或跳过一个字段。</target>
        </trans-unit>
        <trans-unit id="e39e4e019fcddf87d5963ed450c0a585f3ac5a5c" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;InteractionManager&lt;/code&gt; on the &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API docs&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API文档&lt;/a&gt;上阅读有关 &lt;code&gt;InteractionManager&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="1db4f1b561c182f757185de947874831706c7c3d" translate="yes" xml:space="preserve">
          <source>You can read more about the API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface.</source>
          <target state="translated">您可以阅读有关API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;接口的更多信息。</target>
        </trans-unit>
        <trans-unit id="d3732e8bd7b74351797baa672d29727cc8e4b2f3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;fetchQuery&lt;/code&gt; function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ec8ab0bbfcf6ce2aa1efbd2295912061dec672" translate="yes" xml:space="preserve">
          <source>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</source>
          <target state="translated">你不必模仿整个响应有效载荷。在这里,我们已经打消了像句,因为它很难在客户端本地化。当服务器响应时,Relay会把它的payload当作真相的来源,但与此同时,乐观的响应会被立即应用,让使用我们产品的人在采取了行动后享受即时反馈。</target>
        </trans-unit>
        <trans-unit id="db948a53ed55bdbbd4fa17526586780dad70f601" translate="yes" xml:space="preserve">
          <source>You have to implement your own cache strategy. A simple solution is to use &lt;code&gt;QueryResponseCache&lt;/code&gt; (an in-memory cache):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ae915d1a8b7fa12f92488b10423d30b2ad84e5" translate="yes" xml:space="preserve">
          <source>You will need to Configure your &lt;a href=&quot;networklayer&quot;&gt;Network&lt;/a&gt; to handle subscriptions. The below example uses &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb998680ecc627ba04d1e2c348b212888c8f5b" translate="yes" xml:space="preserve">
          <source>[1] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd3288de30464c56940d838b494bb246d25a587" translate="yes" xml:space="preserve">
          <source>an edge representing the new friend will be added to the viewer's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">代表新朋友的边将添加到查看者的 &lt;code&gt;friends&lt;/code&gt; 连接中</target>
        </trans-unit>
        <trans-unit id="33f0663df214f396a65e31c63ea1758c4a24ba18" translate="yes" xml:space="preserve">
          <source>an edge representing the viewer will be added to the new friend's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">代表观看者的边缘将添加到新朋友的 &lt;code&gt;friends&lt;/code&gt; 连接中</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6a5703deebcf0535c19b19c1b0a27e8341e2ab4d" translate="yes" xml:space="preserve">
          <source>and then later refetch one of the stories whose &lt;code&gt;likeCount&lt;/code&gt; has since been incremented:</source>
          <target state="translated">然后稍后重新 &lt;code&gt;likeCount&lt;/code&gt; 其likeCount已增加的故事之一：</target>
        </trans-unit>
        <trans-unit id="6abe6d9392071037cb6a695b9da8b68f203db531" translate="yes" xml:space="preserve">
          <source>and we get back</source>
          <target state="translated">而我们回到</target>
        </trans-unit>
        <trans-unit id="b74745ac136841f9501637f3fac7d913abeecf5d" translate="yes" xml:space="preserve">
          <source>and we'll get this result:</source>
          <target state="translated">我们就会得到这个结果。</target>
        </trans-unit>
        <trans-unit id="f30392ad1d35a35355bcc5ff5b7ab1c4aa4b6b4d" translate="yes" xml:space="preserve">
          <source>applyOptimistic</source>
          <target state="translated">applyOptimistic</target>
        </trans-unit>
        <trans-unit id="481baa434ed8570c01e3d78b4a058c1cea4ffea5" translate="yes" xml:space="preserve">
          <source>applyUpdate (static method)</source>
          <target state="translated">应用更新(静态方法)</target>
        </trans-unit>
        <trans-unit id="e0d9b66d001ce91f916cb04de6514301d4191e1e" translate="yes" xml:space="preserve">
          <source>babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay</target>
        </trans-unit>
        <trans-unit id="804dd7a640e28824ae34b133455831c85cafaa66" translate="yes" xml:space="preserve">
          <source>both people's friend count will increment</source>
          <target state="translated">两人的好友数都会增加</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="ef1bbfb7f634722c33aa4d7f3c325a4a29ea88d1" translate="yes" xml:space="preserve">
          <source>commitUpdate (static method)</source>
          <target state="translated">提交更新(静态方法</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="4b45c519aa27393b323501edc492900dac1e0a96" translate="yes" xml:space="preserve">
          <source>create (static method)</source>
          <target state="translated">创立</target>
        </trans-unit>
        <trans-unit id="db646ca2b7d259a49537f70fff30ff3c2c3c18c5" translate="yes" xml:space="preserve">
          <source>createContainer (static method)</source>
          <target state="translated">createContainer (静态方法)</target>
        </trans-unit>
        <trans-unit id="2b28d0e79db5f9b1637a6d02fd886e0beb0a2a87" translate="yes" xml:space="preserve">
          <source>createWithFiles (static method)</source>
          <target state="translated">createWithFiles (静态方法)</target>
        </trans-unit>
        <trans-unit id="42cdc1d74453884d8861396360329db1f2583a19" translate="yes" xml:space="preserve">
          <source>fetchQuery</source>
          <target state="translated">fetchQuery</target>
        </trans-unit>
        <trans-unit id="da32c19d5a974ead91be2f8fa59b4a9c03db9888" translate="yes" xml:space="preserve">
          <source>forceFetch</source>
          <target state="translated">forceFetch</target>
        </trans-unit>
        <trans-unit id="446ce95fe1412056ff2efb4a2eddeb9b14b5b57b" translate="yes" xml:space="preserve">
          <source>fragments</source>
          <target state="translated">fragments</target>
        </trans-unit>
        <trans-unit id="348bf71ffb0d4407dbcecd15dd012e9ca4e50ec6" translate="yes" xml:space="preserve">
          <source>fragments (static property)</source>
          <target state="translated">碎片</target>
        </trans-unit>
        <trans-unit id="c7051a4ed355bcc5e03ff249da8ad3c8d98795de" translate="yes" xml:space="preserve">
          <source>getCollisionKey</source>
          <target state="translated">getCollisionKey</target>
        </trans-unit>
        <trans-unit id="9b9964fe7f200e2d2d723f2ce25c45e685f31c1a" translate="yes" xml:space="preserve">
          <source>getConfigs (abstract method)</source>
          <target state="translated">getConfigs (抽象方法)</target>
        </trans-unit>
        <trans-unit id="1af4f339fc74cdc2a2f63e9dec4d5c78820395ab" translate="yes" xml:space="preserve">
          <source>getDataID(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</source>
          <target state="translated">getDataID（）：&lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0405ea062abe8cd4a0d287f9154a09079dc4bb4d" translate="yes" xml:space="preserve">
          <source>getDebugName</source>
          <target state="translated">getDebugName</target>
        </trans-unit>
        <trans-unit id="327b4db9411eb5735cd4d613988bd27603d51f28" translate="yes" xml:space="preserve">
          <source>getFatQuery (abstract method)</source>
          <target state="translated">getFatQuery (抽象方法)</target>
        </trans-unit>
        <trans-unit id="97f9623a23d5717ffebb67278d55b1afd1ffd725" translate="yes" xml:space="preserve">
          <source>getFiles</source>
          <target state="translated">getFiles</target>
        </trans-unit>
        <trans-unit id="1778700a36f50cd423696eb753bb860799ac9b24" translate="yes" xml:space="preserve">
          <source>getFragment</source>
          <target state="translated">getFragment</target>
        </trans-unit>
        <trans-unit id="d7c3b79969b5a91a9a376dcbffb251e4515b3ce9" translate="yes" xml:space="preserve">
          <source>getFragment (static method)</source>
          <target state="translated">getFragment (静态方法)</target>
        </trans-unit>
        <trans-unit id="e8166bd4ce0d5f8fe076afeb9c45240cc7d5f2b5" translate="yes" xml:space="preserve">
          <source>getID</source>
          <target state="translated">getID</target>
        </trans-unit>
        <trans-unit id="a73db9be39fc73bb1d8a15f030515c436d5a3453" translate="yes" xml:space="preserve">
          <source>getLinkedRecord(name: string, args?: ?Variables): ?RecordProxy</source>
          <target state="translated">getLinkedRecord(name:string,args?:?Variables):?RecordProxy。</target>
        </trans-unit>
        <trans-unit id="88377de01a531764c854a5d87458832e26bb6d7d" translate="yes" xml:space="preserve">
          <source>getLinkedRecords(name: string, args?: ?Variables): ?Array&amp;lt;?RecordProxy&amp;gt;</source>
          <target state="translated">getLinkedRecords（name：string，args ?:？Variables）：？Array &amp;lt;？RecordProxy&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7fde427ab020029d422a06dc9a3f3cf60a0f286" translate="yes" xml:space="preserve">
          <source>getMutation (abstract method)</source>
          <target state="translated">getMutation(抽象方法)</target>
        </trans-unit>
        <trans-unit id="c3d4160e6945293e656522a92a11fe8535c041eb" translate="yes" xml:space="preserve">
          <source>getOptimisticConfigs</source>
          <target state="translated">getOptimisticConfigs</target>
        </trans-unit>
        <trans-unit id="e35ed410633190979352fe6ee6d4d885c8a18598" translate="yes" xml:space="preserve">
          <source>getOptimisticResponse</source>
          <target state="translated">getOptimisticResponse</target>
        </trans-unit>
        <trans-unit id="6bd679f8ef0f8733bd010559ff42cbedeb5983bf" translate="yes" xml:space="preserve">
          <source>getOrCreateLinkedRecord(name: string, typeName: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">getOrCreateLinkedRecord(name:string,typeName:string,args?:?Variables)。RecordProxy</target>
        </trans-unit>
        <trans-unit id="759956d4899d707dd6a33742489f969212a28756" translate="yes" xml:space="preserve">
          <source>getPendingTransactions</source>
          <target state="translated">getPendingTransactions</target>
        </trans-unit>
        <trans-unit id="5531a9db2f3b83555a0eff0afe4a7b4598c8f0de" translate="yes" xml:space="preserve">
          <source>getQueryString</source>
          <target state="translated">getQueryString</target>
        </trans-unit>
        <trans-unit id="5b70bfc75fe69a0ac1b8cf3046235fbb64e40599" translate="yes" xml:space="preserve">
          <source>getRootField(fieldName: string): ?RecordProxy</source>
          <target state="translated">getRootField(fieldName:string):?</target>
        </trans-unit>
        <trans-unit id="ab14bf198ad6c14dda7ba6cd7afe5b74fddbdc2e" translate="yes" xml:space="preserve">
          <source>getSource(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</source>
          <target state="translated">getSource（）：&lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="264cb99bbdb88c3a503a7cd09445ab43ad54af52" translate="yes" xml:space="preserve">
          <source>getType(): RelayQLType</source>
          <target state="translated">getType():RelayQLType</target>
        </trans-unit>
        <trans-unit id="f5807036ab312a725491c64183d61cf7b9babe1d" translate="yes" xml:space="preserve">
          <source>getValue(name: string, args?: ?Variables): mixed</source>
          <target state="translated">getValue(name:string,args?:?Variables):mixed</target>
        </trans-unit>
        <trans-unit id="43f55a80a8e191422ce37e5ebd8264867fc6316d" translate="yes" xml:space="preserve">
          <source>getVariables</source>
          <target state="translated">getVariables</target>
        </trans-unit>
        <trans-unit id="4349f8288befeff38404853658acf2b002ad2746" translate="yes" xml:space="preserve">
          <source>getVariables (abstract method)</source>
          <target state="translated">getVariables (抽象方法)</target>
        </trans-unit>
        <trans-unit id="3cfab35ae11b2420cf0d4e4900fa11d44d7f4976" translate="yes" xml:space="preserve">
          <source>gives us</source>
          <target state="translated">给我们</target>
        </trans-unit>
        <trans-unit id="9fdcc7f29c59e6f9abaaab32c0a1a15b1b78226b" translate="yes" xml:space="preserve">
          <source>graphql</source>
          <target state="translated">graphql</target>
        </trans-unit>
        <trans-unit id="dde2cfc8d1d2de804008dfc4836831a0eccb8444" translate="yes" xml:space="preserve">
          <source>hasOptimisticUpdate</source>
          <target state="translated">hasOptimisticUpdate</target>
        </trans-unit>
        <trans-unit id="a205cb3bee524195c2fdce6610a417b6853a4c32" translate="yes" xml:space="preserve">
          <source>initialVariables</source>
          <target state="translated">initialVariables</target>
        </trans-unit>
        <trans-unit id="4bfbc265fe484eac76b0500e386617d6cf0e573e" translate="yes" xml:space="preserve">
          <source>initialVariables (static property)</source>
          <target state="translated">InitialVariables (static property)</target>
        </trans-unit>
        <trans-unit id="04dcd4fb3277dbb1127599ff7d32d5684b6a02dc" translate="yes" xml:space="preserve">
          <source>injectNetworkLayer (static method)</source>
          <target state="translated">injectNetworkLayer (静态方法)</target>
        </trans-unit>
        <trans-unit id="0a776c5ca0800d03ca78f47f75e9eb834365d304" translate="yes" xml:space="preserve">
          <source>injectTaskScheduler (static method)</source>
          <target state="translated">injectTaskScheduler(静态方法)</target>
        </trans-unit>
        <trans-unit id="bc813ae20708b8a347a4d53fb6e91311ea7bb33d" translate="yes" xml:space="preserve">
          <source>isContainer (static method)</source>
          <target state="translated">isContainer (静态方法)</target>
        </trans-unit>
        <trans-unit id="c53397edd355fc4e2d006653db94583eef513e6f" translate="yes" xml:space="preserve">
          <source>onReadyStateChange</source>
          <target state="translated">onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="fb05074bc118e549bee00caf3b25aeedd2a23fb9" translate="yes" xml:space="preserve">
          <source>or: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">或： &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; 在重新访存容器</target>
        </trans-unit>
        <trans-unit id="00525d7718b6def384814a704d781fd95161b685" translate="yes" xml:space="preserve">
          <source>paramDefinitions (static property)</source>
          <target state="translated">paramDefinitions (静态属性)</target>
        </trans-unit>
        <trans-unit id="ab47b8a712d90d33736ca95a21ffd78e2edcbc43" translate="yes" xml:space="preserve">
          <source>pendingVariables</source>
          <target state="translated">pendingVariables</target>
        </trans-unit>
        <trans-unit id="46070ca5b7bac4a677b32597aa968e6707fb2947" translate="yes" xml:space="preserve">
          <source>prepareParams (static property)</source>
          <target state="translated">准备参数(静态属性</target>
        </trans-unit>
        <trans-unit id="4c8dd8321c7f8e03d9a33e3aac495748a5310da1" translate="yes" xml:space="preserve">
          <source>prepareVariables</source>
          <target state="translated">prepareVariables</target>
        </trans-unit>
        <trans-unit id="6399eda44b9a365d9ef2884378c34b3d150ac371" translate="yes" xml:space="preserve">
          <source>prepareVariables (static property)</source>
          <target state="translated">准备变量(静态属性</target>
        </trans-unit>
        <trans-unit id="d32d93402de4dcb749f059cba43572aa23bd03dc" translate="yes" xml:space="preserve">
          <source>queries (static property)</source>
          <target state="translated">查询</target>
        </trans-unit>
        <trans-unit id="9dc632a4888b695f2a771b203d0887d10714caef" translate="yes" xml:space="preserve">
          <source>react-relay/classic</source>
          <target state="translated">react-relay/classic</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="62f23262fcec4cdc5eb17faabb63e059d6950930" translate="yes" xml:space="preserve">
          <source>renderFailure</source>
          <target state="translated">renderFailure</target>
        </trans-unit>
        <trans-unit id="2afd39a75e88681d175b8553ff1dce06613384a5" translate="yes" xml:space="preserve">
          <source>renderFetched</source>
          <target state="translated">renderFetched</target>
        </trans-unit>
        <trans-unit id="5e3932629379610ab259e44527d32162c9392f0b" translate="yes" xml:space="preserve">
          <source>renderLoading</source>
          <target state="translated">renderLoading</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="ff3a6f3b41f1c1e00b77429034bc912cfa7dd364" translate="yes" xml:space="preserve">
          <source>rollback</source>
          <target state="translated">rollback</target>
        </trans-unit>
        <trans-unit id="fc166eb81361ff31179cd3c83da3bfe088b851d3" translate="yes" xml:space="preserve">
          <source>route</source>
          <target state="translated">route</target>
        </trans-unit>
        <trans-unit id="e1d71ee40db65de4abc60e598cad15a41923e787" translate="yes" xml:space="preserve">
          <source>routeName (static property)</source>
          <target state="translated">路由名称(静态属性</target>
        </trans-unit>
        <trans-unit id="9f1125a04ebb1449bdd323a60a2950db5accfb80" translate="yes" xml:space="preserve">
          <source>sendMutation</source>
          <target state="translated">sendMutation</target>
        </trans-unit>
        <trans-unit id="435568d9e02408d6788ecdc6be513d72ccc6cb61" translate="yes" xml:space="preserve">
          <source>sendQueries</source>
          <target state="translated">sendQueries</target>
        </trans-unit>
        <trans-unit id="2880123c67d1aaedb821f0f247cd4c6c4345aab8" translate="yes" xml:space="preserve">
          <source>setLinkedRecord(record: RecordProxy, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setLinkedRecord(record:RecordProxy,name:string,args?:?Variables)。RecordProxy</target>
        </trans-unit>
        <trans-unit id="7dc0722d5b1e977d588c3edf8515b019e788c174" translate="yes" xml:space="preserve">
          <source>setLinkedRecords(records: Array&amp;lt;?RecordProxy&amp;gt;, name: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">setLinkedRecords（记录：Array &amp;lt;？RecordProxy&amp;gt;，名称：字符串，args ?:？Variables）：RecordProxy</target>
        </trans-unit>
        <trans-unit id="9a58f84fd8486e41fd7dcfc4d34aa90c06019e22" translate="yes" xml:space="preserve">
          <source>setValue(value: mixed, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setValue(value:mixed,name:string,args?:?Variables)。RecordProxy</target>
        </trans-unit>
        <trans-unit id="5548ee17e1e709bc17eb0b6bc474907bee14447b" translate="yes" xml:space="preserve">
          <source>setVariables</source>
          <target state="translated">setVariables</target>
        </trans-unit>
        <trans-unit id="ae2633f3722560d2ad1ff74c21f50ef81ea6b153" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate</source>
          <target state="translated">shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="8a14711da8b864c0b88fb3fe7e873c0b2894566e" translate="yes" xml:space="preserve">
          <source>supports</source>
          <target state="translated">supports</target>
        </trans-unit>
        <trans-unit id="09e391d372ecf222949d736538e76db78674604a" translate="yes" xml:space="preserve">
          <source>the viewer's friendship status with the requester will change</source>
          <target state="translated">浏览者与请求者的友情状态将发生变化</target>
        </trans-unit>
        <trans-unit id="bc5af2310c7f15770a4ed0028648ce367e3e2ec0" translate="yes" xml:space="preserve">
          <source>variables</source>
          <target state="translated">variables</target>
        </trans-unit>
        <trans-unit id="87a0de569c57d54d8721ab12b504cc0797b8a57b" translate="yes" xml:space="preserve">
          <source>with these params:</source>
          <target state="translated">与这些参数。</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
