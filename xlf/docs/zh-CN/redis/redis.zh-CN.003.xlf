<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">注意：此行为的重要部分是，无论运行Redis的系统体系结构如何，Redis都实现为 &lt;code&gt;math.random&lt;/code&gt; 和 &lt;code&gt;math.randomseed&lt;/code&gt; 的PRNG 保证具有相同的输出。32位，64位，大端和小端系统将产生相同的输出。</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">注意：作为调用此函数的副作用，可能修改了HyperLogLog，因为后8个字节对用于缓存目的的最新计算基数进行编码。因此&lt;a href=&quot;pfcount&quot;&gt;从&lt;/a&gt;技术上讲PFCOUNT是写命令。</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">注意:正如你所看到的那样,Lua数组是以Redis多批量回复的方式返回的,这是一种Redis返回类型,你的客户端库很可能会在你的编程语言中转换为Array类型。</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">注意：当然，通常不能保证错误文本保持不变，但是错误代码将保持 &lt;code&gt;-UNBLOCKED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">注意：该命令的复杂度仅为O（log（N）），因为它使用元素等级（请参阅&lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;）来了解范围。因此，无需进行与范围大小成比例的工作。</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">注意：在示例中，我们使用&lt;strong&gt;COUNT&lt;/strong&gt;选项，因此对于每个流，调用将在每个流中最多返回两个元素。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">关于发布的配置周期的说明</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">处理的命令数量</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">收到的连接数</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">每次SCAN调用时返回的元素数量</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">过期钥匙的数量</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">被拒绝的连接数</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECT子命令[参数[参数...]]检查Redis对象的内部结构</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">对象可以用不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">获取当前慢速日志的长度</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">当然也可以使用任何其他有效的ID。如果指定的使用者组已经存在，该命令将返回 &lt;code&gt;-BUSYGROUP&lt;/code&gt; 错误。否则，将执行操作并返回OK。可以与给定流关联的消费者组的数量没有硬性限制。</target>
        </trans-unit>
        <trans-unit id="fdc97913b5ee5e2b94550a726affb680e5e4737b" translate="yes" xml:space="preserve">
          <source>Of course the &quot;5&quot; above is an example. Each LOLWUT version takes a different set of arguments in order to change the output. The user is encouraged to play with it to discover how the output changes adding more numerical arguments.</source>
          <target state="translated">当然上面的 &quot;5 &quot;是个例子。每一个LOLWUT版本都需要一组不同的参数来改变输出。我们鼓励用户去玩它,去发现增加更多的数字参数后输出是如何变化的。</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">当然这还不够,因为有一些过期的密钥将永远不会再被访问。这些键无论如何都应该是过期的,所以Redis定期在有过期集的键中随机测试几个键。所有已经过期的键都会从键空间中删除。</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">另一方面，由于一些原因，使用特殊命令或通过 &lt;code&gt;redis.conf&lt;/code&gt; 定义命令将是一个问题：</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">使用者&lt;em&gt;成功&lt;/em&gt;处理一条消息后，应调用&lt;a href=&quot;xack&quot;&gt;XACK，&lt;/a&gt;以使该消息不再得到处理，并且副作用是，与此消息相关的PEL条目也被清除，从而从Redis服务器释放内存。</target>
        </trans-unit>
        <trans-unit id="b17fd51767d49ce5f7f1a0550bff325504d720d8" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;successfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">使用方一旦&lt;em&gt;成功&lt;/em&gt;处理了一条消息，就应该调用&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;，这样就不会再次处理该消息，并且副作用是，与此消息有关的PEL条目也会被清除，从而从Redis服务器释放内存。</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">一旦一个节点变成了另一个主节点的副本,就不需要将这一变化通知其他集群节点:节点之间交换的心跳包会自动传播新的配置。</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">一旦其中一个列表中出现了新的数据,客户端就会返回解封的键名和弹出的值。</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">一旦客户端进入订阅状态，就不应发出任何其他命令，除了其他&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;和&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="7a78727304122280256c3edfc937460559a439ea" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;, &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; and &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; commands.</source>
          <target state="translated">一旦客户端进入订阅状态，就不应发出任何其他命令，除了其他&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;，&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;和&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">一旦我们得到一些回复,下一个电话会是这样的。</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">每行一个客户端连接(用LF隔开)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">消费者组的保证之一是，给定的消费者只能看到传递给它的邮件的历史记录，因此邮件只有一个所有者。但是，有一个称为&lt;em&gt;消息声明&lt;/em&gt;的特殊功能，如果某些使用者发生不可恢复的故障，则允许其他使用者声明消息。为了实现这种语义，消费者组需要通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令明确确认消费者成功处理的消息。这是必需的，因为流将针对每个消费者组跟踪谁在处理什么消息。</target>
        </trans-unit>
        <trans-unit id="19ce1ec3b2311a2d98754806626a6daf14da6b47" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgment of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">消费者组的保证之一是，给定的消费者只能看到传递给它的消息的历史记录，因此消息只有一个所有者。但是，有一个称为&lt;em&gt;消息声明&lt;/em&gt;的特殊功能，在某些使用者发生不可恢复的故障时，它允许其他使用者声明消息。为了实现这种语义，使用者组需要通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令明确确认由使用者成功处理的消息。这是必需的，因为流将针对每个消费者组跟踪谁在处理什么消息。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">位的顺序</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">其他使用者可以使用&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令检查过时的未决消息列表。为了继续处理此类消息，他们使用&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;获取消息的所有权并继续。</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">我们前面的示例仅返回排序后的ID。在某些情况下，获取实际对象而不是其ID（ &lt;code&gt;object_1&lt;/code&gt; ， &lt;code&gt;object_2&lt;/code&gt; 和 &lt;code&gt;object_3&lt;/code&gt; ）更为有用。可以使用以下命令基于列表，集合或排序集合中的元素检索外部键：</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">超出范围的索引不会产生错误。如果 &lt;code&gt;start&lt;/code&gt; 大于列表的末尾，则返回一个空列表。如果 &lt;code&gt;stop&lt;/code&gt; 大于列表的实际结尾，则Redis会将其视为列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">超出范围的索引不会产生错误。如果 &lt;code&gt;start&lt;/code&gt; 大于排序集中的最大索引，或者 &lt;code&gt;start &amp;gt; stop&lt;/code&gt; ，则返回一个空列表。如果 &lt;code&gt;stop&lt;/code&gt; 大于排序集的末尾，则Redis会将其视为排序集中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">超出范围的索引不会产生错误：如果 &lt;code&gt;start&lt;/code&gt; 大于列表的末尾或 &lt;code&gt;start &amp;gt; end&lt;/code&gt; ，则结果将是一个空列表（这将导致 &lt;code&gt;key&lt;/code&gt; 被删除）。如果 &lt;code&gt;end&lt;/code&gt; 大于列表的末尾，则Redis会将其视为列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">范围外指数</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">输出格式</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">关于副本的命令输出</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">溢出控制</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">从&lt;em&gt;value&lt;/em&gt;的整个长度开始，从指定的偏移量覆盖&lt;em&gt;key&lt;/em&gt;处存储的一部分字符串。如果偏移量大于&lt;em&gt;key处&lt;/em&gt;字符串的当前长度，则该字符串将填充零字节以使&lt;em&gt;偏移量&lt;/em&gt;适合。不存在的键被视为空字符串，因此此命令将确保它包含足够大的字符串以能够将&lt;em&gt;值&lt;/em&gt;设置为&lt;em&gt;offset&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST键 移除密钥的到期时间。</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE key milliseconds 以毫秒为单位设置钥匙的存活时间。</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT key milliseconds-timestamp 将密钥的到期时间设置为以毫秒为单位的 UNIX 时间戳。</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD 关键元素 [元素...]将指定的元素添加到指定的 HyperLog 中。</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT key [key ...]返回HyperLogic在key(s)处观察到的集合的近似卡数。</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...]将N个不同的HyperLogs合并成一个。</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [消息]Ping服务器</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">PSETEX 密钥毫秒值 设置密钥的值和到期时间(毫秒)。</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE pattern [pattern ...]监听与给定模式相匹配的频道发布的消息。</target>
        </trans-unit>
        <trans-unit id="2c633ee880363a76906d0e48643fc6fd3afe6539" translate="yes" xml:space="preserve">
          <source>PSYNC</source>
          <target state="translated">PSYNC</target>
        </trans-unit>
        <trans-unit id="5d448b1760960854b1253a3a2cad23abdcfdac61" translate="yes" xml:space="preserve">
          <source>PSYNC  replicationid offset   Internal command used for replication</source>
          <target state="translated">PSYNC replicationid offset 复制时使用的内部命令。</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL键 以毫秒为单位获取键的存活时间。</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH 频道消息 向频道发布消息。</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUB子命令[参数[参数...]]。检查Pub/Sub子系统的状态。</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB CHANNELS [模式]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [模式 [模式...]]停止监听与给定模式相匹配的频道发布的消息</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">在这种情况下，将键和参数作为附加的&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;参数传递也是非常有用的，因为脚本字符串保持恒定并且可以被Redis有效地缓存。</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">模式:循环列表</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">样式。柜台</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">模式。事件通知</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">模式。导航会议</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">模式:速率限制器</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">样式。速率限制器1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">样式。速率限制器2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">模式。可靠的队列</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">模式。时间序列</target>
        </trans-unit>
        <trans-unit id="aaa32185c003a60c49d4fa1de6cdca30261f99bd" translate="yes" xml:space="preserve">
          <source>Pattern: accessing the entire bitmap</source>
          <target state="translated">模式:访问整个位图</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">模式:使用位图进行实时度量。</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">模式:使用位图进行实时度量</target>
        </trans-unit>
        <trans-unit id="4fd48af62eda73b71f46321f27a6f38fb4751056" translate="yes" xml:space="preserve">
          <source>Pattern: setting multiple bits</source>
          <target state="translated">模式:设置多个位</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">模式:加权随机选择一个元素</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;暂停客户端</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">在多个键(包含字符串值)之间进行位运算,并将结果存储在目标键中。</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">如果配置了至少一个&lt;strong&gt;保存点，&lt;/strong&gt;则执行阻止保存。</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">断线后执行部分重新同步。</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">对输入的字符串进行SHA1运算。</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">性能方面的考虑</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">请检查以下示例和&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;文档，以获取有关该命令及其选项的更多信息。</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">有关命令的具体语义，请参阅&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">请注意,根据Redis的版本,有些字段已经被添加或删除。因此,一个强大的客户端应用程序应该通过跳过未知属性来解析该命令的结果,并优雅地处理丢失的字段。</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">请注意，在阅读此页面之前，如果您不熟悉流，建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;有关Redis Streams的介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">请参阅&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;文档以获取有关Redis Lua脚本的详细信息。</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;持久性文档&lt;/a&gt;以获取详细信息。</target>
        </trans-unit>
        <trans-unit id="13eff9f035082f1c14cd73067127e19e708dd746" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;文档中的模式说明。</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;文档中的模式说明。</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">向指定的频道发送消息。</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">实际上，对于客户端来说，最好简单地假设在给定连接的上下文中，除非管理员明确调用&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;命令，否则可以确保缓存的脚本在那里。</target>
        </trans-unit>
        <trans-unit id="9d8c495de1a9098dd3bc4b934ccc859d56035029" translate="yes" xml:space="preserve">
          <source>Produces an ASCII-art style graph for the specified event.</source>
          <target state="translated">为指定的事件生成一个ASCII风格的图表。</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">通过返回实例当前是 &lt;code&gt;master&lt;/code&gt; ， &lt;code&gt;slave&lt;/code&gt; 或 &lt;code&gt;sentinel&lt;/code&gt; ，提供有关Redis实例在复制上下文中的角色的信息。该命令还返回有关复制状态的其他信息（如果角色是主服务器或从服务器）或受监视的主机名列表（如果角色是哨兵）。</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT 关闭连接</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">退出服务器。</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 从键空间中返回一个随机的密钥。</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY 启用对集群复制节点连接的读取查询。</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE 禁止对群集复制节点的连接进行读取查询。</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">重命名键 newkey 重命名一个键</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey 重命名一个键,只有在新键不存在的情况下才可以。</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF主机端口 使服务器成为另一个实例的副本,或者将其升级为主控。</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="1b3151a71b95e8cdeb31ff88835e69beefec4ac4" translate="yes" xml:space="preserve">
          <source>RESET   Reset the connection</source>
          <target state="translated">RESET 重置连接</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE]使用提供的序列化值创建一个键,该值是之前使用DUMP获得的。</target>
        </trans-unit>
        <trans-unit id="e604e0070c2d8dbd159ab393d370ee42dc12812f" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE][ABSTTL][IDLETIME seconds][FREQ frequency]使用提供的序列化值创建一个键,之前使用DUMP获得。</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE 返回实例在复制上下文中的角色。</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOP键 删除并获取列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="153bcead99c65ede929618b160dd530ec6817223" translate="yes" xml:space="preserve">
          <source>RPOP  key [count]   Remove and get the last elements in a list</source>
          <target state="translated">RPOP key [count]删除并获取列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH source destination 移除一个列表中的最后一个元素,将其前缀到另一个列表中,并将其返回。</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="3c855c64755366500528d84baa161e66c153eb2f" translate="yes" xml:space="preserve">
          <source>RPUSH  key element [element ...]   Append one or multiple elements to a list</source>
          <target state="translated">RPUSH 关键元素 [元素...]将一个或多个元素添加到列表中。</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH 键值 [value ...]将一个或多个值添加到列表中。</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="9ca949029559acfa6521e4bf6649e713de5742b1" translate="yes" xml:space="preserve">
          <source>RPUSHX  key element [element ...]   Append an element to a list, only if the list exists</source>
          <target state="translated">RPUSHX 关键元素 [元素...]只有在列表存在的情况下,才会将一个元素添加到列表中。</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX键值 只有在列表存在的情况下,才会将一个值添加到列表中。</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">可以精确表达的整数分数范围。</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">范围:3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">从一个或多个流中读取数据，仅返回ID大于调用者最后一次收到的ID的条目。此命令具有一个选项，可以阻止项目不可用，其方式类似于&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;或&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">只读变体</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">默认情况下，对Redis Cluster从属节点的读取查询是禁用的，但是您可以使用&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令逐个连接地更改此行为。的&lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt;命令重置的连接回为读写的只读模式标志。</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">阅读应用程序代码,可能不清楚完整的语义,因为应用程序调用服务器端定义的命令。</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">强烈建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams简介&lt;/a&gt;，以更多地了解Streams的整体行为和语义。</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">阅读慢速日志</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Redis Sentinel的最新版本(Redis 2.8.12或更高版本)使用CLIENT KILL来在实例重新配置时杀死客户端,以迫使客户端再次与一个Sentinel执行握手并更新其配置。</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">重新配置客户端与新的主站连接。</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2引入了一个可选的 &lt;code&gt;count&lt;/code&gt; 参数，可以将其传递给&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;以便在单个调用中检索多个元素。</target>
        </trans-unit>
        <trans-unit id="ff9622e92b582b377cd9d107f3253f8a189b7cf9" translate="yes" xml:space="preserve">
          <source>Redis 6 connections starts in RESP2 mode, so clients implementing RESP2 do not need to change (nor there are short term plans to drop support for RESP2). Clients that want to handshake the RESP3 mode need to call the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command, using &quot;3&quot; as first argument.</source>
          <target state="translated">Redis 6连接以RESP2模式启动，因此实现RESP2的客户端无需更改（也没有短期计划放弃对RESP2的支持）。想要握手RESP3模式的客户端需要使用&amp;ldquo; 3&amp;rdquo;作为第一个参数来调用&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redis集群实时重arding解释</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogs用双重表示形式表示：适用于HHL计数少量元素的&lt;em&gt;稀疏&lt;/em&gt;表示形式（导致将少量寄存器设置为非零值），以及适合较高基数的&lt;em&gt;密集&lt;/em&gt;表示形式。需要时，Redis会自动从稀疏表示转换为密集表示。</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil批量回复和Nil多批量回复-&amp;gt; Lua false boolean type</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis批量回复-&amp;gt; Lua字符串</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">从Lua调用时，可能以随机顺序返回元素的Redis命令（例如&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（因为Redis集是&lt;em&gt;无序的&lt;/em&gt;））具有不同的行为，并且在将数据返回到Lua脚本之前经过静默词典编排过滤器。因此 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 将始终以相同顺序返回Set元素，而从普通客户端调用的同一命令可能会返回不同的结果，即使键包含的元素完全相同。</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redis命令通常接受一个键、两个键或无限个键。</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redis不同的可选数据库是命名空间的一种形式：所有数据库都始终存储在同一RDB / AOF文件中。但是，不同的数据库可以具有相同名称的密钥，并且存在适用于特定数据库的可用命令，例如&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;，&lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt;或&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e3076b9d3288c97597280422f53f06eb0450c13" translate="yes" xml:space="preserve">
          <source>Redis double reply -&amp;gt; Lua table with a single &lt;code&gt;score&lt;/code&gt; field containing a Lua number representing the double value.</source>
          <target state="translated">Redis双答复-&amp;gt; Lua表，其中包含一个 &lt;code&gt;score&lt;/code&gt; 字段，该分数字段包含一个表示双精度值的Lua编号。</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redis错误回复-&amp;gt; Lua表，其中包含错误的单个 &lt;code&gt;err&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="26c2d6e6bcc8ce21554bdf0baf74815e6f8c13dd" translate="yes" xml:space="preserve">
          <source>Redis false reply -&amp;gt; Lua false boolean value.</source>
          <target state="translated">Redis错误回复-&amp;gt; Lua错误的布尔值。</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis整数回复-&amp;gt; Lua号码</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">假设您正确设置 &lt;code&gt;!LC_COLLATE&lt;/code&gt; 环境变量，Redis可以识别UTF-8 。</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">现在，Redis可以删除其他线程中的后台密钥，而不会阻塞服务器。一个 &lt;code&gt;ASYNC&lt;/code&gt; 选项被添加到&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;和&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;为了让整个数据集或一个单一的数据库中异步释放。</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis通常用作消息传递服务器，以实现对后台作业或其他类型的消息传递任务的处理。往往获得队列的简单形式推值代入在生产者侧的列表，并使用等待在消费侧此值&lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt;（使用轮询），或&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;如果客户端更好通过阻塞操作提供服务。</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redis密钥过期有两种方式:一种是被动方式,一种是主动方式。</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis记录脚本运行时间过长。</target>
        </trans-unit>
        <trans-unit id="07c6c60386c8d0b1cb8c0291d6e6212cf17c794b" translate="yes" xml:space="preserve">
          <source>Redis map reply -&amp;gt; Lua table with a single &lt;code&gt;map&lt;/code&gt; field containing a Lua table representing the fields and values of the map.</source>
          <target state="translated">Redis映射回复-&amp;gt; Lua表，其中包含一个包含 &lt;code&gt;map&lt;/code&gt; 表域和值的Lua表的单个映射字段。</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redis多批量回复-&amp;gt; Lua表（可能嵌套了其他Redis数据类型）</target>
        </trans-unit>
        <trans-unit id="6afefff72418c96bb7166299d904551e6e4c186a" translate="yes" xml:space="preserve">
          <source>Redis new RESP3 single null value -&amp;gt; Lua nil.</source>
          <target state="translated">Redis新的RESP3单个null值-&amp;gt; Lua nil。</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis提供了一个SCRIPT命令,可以用来控制脚本子系统。SCRIPT目前接受三种不同的命令。</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">当Lua使用 &lt;code&gt;call()&lt;/code&gt; 或 &lt;code&gt;pcall()&lt;/code&gt; 调用Redis命令时，Redis返回值将转换为Lua数据类型。同样，在调用Redis命令以及Lua脚本返回值时，Lua数据类型将转换为Redis协议，以便脚本可以控制将&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;返回给客户端的内容。</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redis脚本不允许创建全局变量,以避免数据泄露到Lua状态。如果一个脚本需要在调用之间保持状态(这是一个很不常见的需求),它应该使用Redis键来代替。</target>
        </trans-unit>
        <trans-unit id="62adbd77b4f8fad448a651b5f523abd0f146da57" translate="yes" xml:space="preserve">
          <source>Redis set reply -&amp;gt; Lua table with a single &lt;code&gt;set&lt;/code&gt; field containing a Lua table representing the elements of the set as fields, having as value just &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Redis设置回复-&amp;gt; Lua表，其中包含一个 &lt;code&gt;set&lt;/code&gt; 字段，其中包含一个Lua表，表示该集合的元素为字段，其值仅为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redis慢速日志概述</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redis排序集使用&lt;em&gt;双64位浮点数&lt;/em&gt;表示分数。在我们支持的所有体系结构中，这都表示为&lt;strong&gt;IEEE 754浮点数&lt;/strong&gt;，它能够精确表示介于 &lt;code&gt;-(2^53)&lt;/code&gt; 和 &lt;code&gt;+(2^53)&lt;/code&gt; 之间的整数。用更实际的术语来说，-9007199254740992和9007199254740992之间的所有整数都是可以完美表示的。较大的整数或小数在内部以指数形式表示，因此有可能仅获得十进制数字的近似值或设置为得分的非常大的整数。</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redis状态回复-&amp;gt; Lua表，带有包含状态的单个 &lt;code&gt;ok&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis以整数表示方式存储整数,所以对于实际持有整数的字符串值,不存在存储整数的字符串表示方式的开销。</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redis流以提高内存效率的方式表示：使用基数树来索引线性打包数十个流条目的宏节点。通常，从流中删除条目时会发生的情况是该条目并未&lt;em&gt;真正&lt;/em&gt;被逐出，只是被标记为已删除。</target>
        </trans-unit>
        <trans-unit id="5d32a14fd1723b346b2a3b7e8ab15af43e61bb43" translate="yes" xml:space="preserve">
          <source>Redis true reply -&amp;gt; Lua true boolean value.</source>
          <target state="translated">Redis true回复-&amp;gt; Lua true布尔值。</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis使用相同的Lua解释器来运行所有命令。另外，Redis保证以原子方式执行脚本：执行脚本时不会执行其他脚本或Redis命令。这种语义类似于&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC中的一种&lt;/a&gt;。从所有其他客户端的角度来看，脚本的效果还是不可见或已经完成。</target>
        </trans-unit>
        <trans-unit id="358fd429e373e6f088abb4b934d2faf8511ecbc9" translate="yes" xml:space="preserve">
          <source>Redis versions prior of Redis 6 were only able to understand the one argument version of the command:</source>
          <target state="translated">Redis 6之前的Redis版本只能理解该命令的一个参数版本。</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">如果脚本&lt;strong&gt;在&lt;/strong&gt; Redis &lt;em&gt;随机&lt;/em&gt;命令（例如&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;，&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;，&lt;a href=&quot;time&quot;&gt;TIME）&lt;/a&gt;&lt;strong&gt;之后&lt;/strong&gt;调用能够更改数据集的Redis命令，则Redis将使用错误阻止脚本。这意味着，如果脚本是只读的并且不修改数据集，则可以自由调用这些命令。请注意，&lt;em&gt;随机命令&lt;/em&gt;不一定表示使用随机数的命令：任何不确定的命令均被视为随机命令（这方面的最佳示例是&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">刷新过期</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">可靠的尾部</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">将某一特定消费者从消费者群体中删除。</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">删除现有的 &lt;code&gt;key&lt;/code&gt; 超时，将其从&lt;em&gt;volatile&lt;/em&gt;（设置了过期设置的键）更改为&lt;em&gt;持久&lt;/em&gt;（&lt;em&gt;持久化&lt;/em&gt;（因为没有关联超时的键））。</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 中存储的集合中删除指定的成员。不是该集合成员的指定成员将被忽略。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其视为空集，并且此命令返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">删除 &lt;code&gt;key&lt;/code&gt; 存储在键中的排序集中的所有元素，其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; （含）之间。</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">删除存储在 &lt;code&gt;key&lt;/code&gt; 中，其排序在 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 之间的排序集中的所有元素。双方 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt; 与基于索引 &lt;code&gt;0&lt;/code&gt; 是得分最低的元素。这些索引可以是负数，它们表示从得分最高的元素开始的偏移量。例如： &lt;code&gt;-1&lt;/code&gt; 是得分最高的元素， &lt;code&gt;-2&lt;/code&gt; 是得分第二高的元素，依此类推。</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 的设置值存储中删除并返回一个或多个随机元素。</target>
        </trans-unit>
        <trans-unit id="cbdedbfa9e258d96431019af8d58bcfa65137941" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random members from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 的设置值存储中删除并返回一个或多个随机成员。</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="abb0c00334891c9a62b73bcc7669016da3f5a06d" translate="yes" xml:space="preserve">
          <source>Removes and returns the first elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的前几个元素。</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="068c1fcc92f924f323a2866cd513ee38912fea94" translate="yes" xml:space="preserve">
          <source>Removes and returns the last elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">移除并返回多达 &lt;code&gt;count&lt;/code&gt; 与存储在有序集合中得分最高的成员 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">移除并返回多达 &lt;code&gt;count&lt;/code&gt; 得分最低的存储在有序集合成员 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f36f141768a197b4276a61d3b54c8f396195cafb" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;element&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 处存储的列表中删除等于 &lt;code&gt;element&lt;/code&gt; 的元素的第一次 &lt;code&gt;count&lt;/code&gt; 出现。该 &lt;code&gt;count&lt;/code&gt; 参数影响在以下几个方面的工作：</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 处存储的列表中删除等于 &lt;code&gt;value&lt;/code&gt; 的元素的第一个 &lt;code&gt;count&lt;/code&gt; 出现。该 &lt;code&gt;count&lt;/code&gt; 参数影响在以下几个方面的工作：</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">从流中删除指定的条目,并返回被删除的条目数,在某些ID不存在的情况下,该数可能与传递给命令的ID数不同。</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 处存储的哈希中删除指定的字段。此哈希中不存在的指定字段将被忽略。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其视为空哈希，并且此命令返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">删除指定的键。如果键不存在,则忽略该键。</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">从存储在 &lt;code&gt;key&lt;/code&gt; 的排序集中删除指定的成员。不存在的成员将被忽略。</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">重命名 &lt;code&gt;key&lt;/code&gt; 来 &lt;code&gt;newkey&lt;/code&gt; 如果 &lt;code&gt;newkey&lt;/code&gt; 不存在。当 &lt;code&gt;key&lt;/code&gt; 不存在时，它将返回错误。</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 重命名为 &lt;code&gt;newkey&lt;/code&gt; 。当 &lt;code&gt;key&lt;/code&gt; 不存在时，它将返回错误。如果 &lt;code&gt;newkey&lt;/code&gt; 已经存在，它将被覆盖，这时&lt;a href=&quot;rename&quot;&gt;RENAME将&lt;/a&gt;执行隐式&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作，因此，即使&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;本身通常是恒定时间操作，如果删除的键包含很大的值，也可能导致高延迟。</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">副本广播其主服务器的配置时期（如果发现陈旧，则获得 &lt;code&gt;UPDATE&lt;/code&gt; 消息），因此副本的真实配置时期（或多或少是没有意义的，因为它们不提供哈希槽）仅获得检查标记为 &lt;code&gt;myself&lt;/code&gt; 的节点的信息，这是我们要求生成&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出的节点的条目。其他副本时期反映了它们在心跳数据包中发布的内容，即它们当前正在复制的母版的配置时期。</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">复制命令而不是脚本</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">在受密码保护的Redis服务器中请求身份验证。可以指示Redis在允许客户端执行命令之前要求输入密码。这是使用配置文件中的 &lt;code&gt;requirepass&lt;/code&gt; 指令完成的。</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">根据重置类型，或多或少剧烈地重置Redis群集节点，该节点可以是&lt;strong&gt;hard&lt;/strong&gt;或&lt;strong&gt;soft&lt;/strong&gt;。请注意，&lt;strong&gt;如果&lt;/strong&gt;主节点&lt;strong&gt;拥有一个或多个密钥&lt;/strong&gt;，&lt;strong&gt;则&lt;/strong&gt;该命令&lt;strong&gt;不适用于&lt;/strong&gt;主节点，在这种情况下，要完全重置主节点密钥，必须首先移除密钥，例如，首先使用&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;，然后再使用&lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令重置Redis报告的统计信息。</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">重新设置慢速日志。</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">将所有的哈希槽从D重新hard到节点A、B、C。</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">检索外部钥匙</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">从当前选择的数据库中返回一个随机密钥。</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">返回成功执行的最后一个数据库保存的UNIX TIME。客户端可以检查&lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt;命令是否成功读取了&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;值，然后发出&lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt;命令并每隔N秒定期检查&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE是否&lt;/a&gt;更改。</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">返回排序集所代表的地理空间索引中两个成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="da507356e98e4d51d3b0a5e69a99468bdb6da16d" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified by a given shape. This command extends the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; command, so in addition to searching within circular areas, it supports searching within rectangular areas.</source>
          <target state="translated">使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;返回填充有地理空间信息的排序集中的成员，这些成员在给定形状指定的区域的边界内。此命令扩展了&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;命令，因此，除了在圆形区域内搜索外，它还支持在矩形区域内搜索。</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;返回填充有地理空间信息的排序集中的成员，这些成员位于以中心位置和距中心的最大距离（半径）指定的区域的边界内。</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">返回当前选择的数据库中的键数。</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">返回字符串中第一个设置为1或0的位的位置。</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">返回由&lt;em&gt;key&lt;/em&gt;的排序集表示的地理空间索引的所有指定成员的位置（经度，纬度）。</target>
        </trans-unit>
        <trans-unit id="38c82e40bf5034793c00ae747edeb8cd30dfe3ef" translate="yes" xml:space="preserve">
          <source>Return the username the current connection is authenticated with. New connections are authenticated with the &quot;default&quot; user. They can change user using &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="translated">返回当前连接经过身份验证的用户名。新连接将使用&amp;ldquo;默认&amp;rdquo;用户进行身份验证。他们可以使用&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;更改用户。</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">返回有效的&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;字符串，该字符串表示一个或多个元素在代表地理空间索引的排序后的集合值中的位置（使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;添加元素）。</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">返回值</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">返回最大条目数</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">在特定时间范围内退货。这是可能的，因为流ID &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;与时间有关&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">返回有关所有Redis命令的详细信息的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">返回有关多个Redis命令的详细信息的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">从完整的Redis命令返回键的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">返回此Redis服务器中命令总数的&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数回复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">如果未提供任何参数，则返回 &lt;code&gt;PONG&lt;/code&gt; ；否则，以批量形式返回该参数的副本。此命令通常用于测试连接是否仍处于活动状态或测量延迟。</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的所有字段名称。</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希的所有字段和值。在返回的值中，每个字段名后面都跟着它的值，因此答复的长度是哈希值的两倍。</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">返回所有匹配 &lt;code&gt;pattern&lt;/code&gt; 的键。</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的所有元素，其得分在 &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; 之间（包括得分等于 &lt;code&gt;max&lt;/code&gt; 或 &lt;code&gt;min&lt;/code&gt; 的元素）。与排序集的默认排序相反，对于此命令，将元素视为从高分到低分排序。</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的所有元素，且其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 之间（包括分数等于 &lt;code&gt;min&lt;/code&gt; 或 &lt;code&gt;max&lt;/code&gt; 的元素）。这些元素被认为是从低到高排序。</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的设置值的所有成员。</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希值。</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">返回一个整数,标识指定的密钥散列到的散列槽。这条命令主要用于调试和测试,因为它通过API公开了哈希算法的底层Redis实现。此命令的使用实例。</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;field&lt;/code&gt; 是否是存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的现有字段。</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 存在。</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回是否 &lt;code&gt;member&lt;/code&gt; 是存储在 &lt;code&gt;key&lt;/code&gt; 处的集合的成员。</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">返回关于脚本缓存中脚本存在的信息。</target>
        </trans-unit>
        <trans-unit id="820ae40f339c061fc09ac87d928788d5e7ea006a" translate="yes" xml:space="preserve">
          <source>Returns information about the modules loaded to the server.</source>
          <target state="translated">返回加载到服务器的模块信息。</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">返回或存储包含在元素&lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;列表&lt;/a&gt;，&lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;集&lt;/a&gt;或&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;排序集合&lt;/a&gt;的 &lt;code&gt;key&lt;/code&gt; 。默认情况下，排序是数字形式的，并且将元素的值进行比较以解释为双精度浮点数。这是最简单形式的&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">返回&lt;em&gt;key处&lt;/em&gt;存储的字符串值中&lt;em&gt;offset&lt;/em&gt;处的位值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表中index &lt;code&gt;index&lt;/code&gt; 处的元素。索引从零开始，因此 &lt;code&gt;0&lt;/code&gt; 表示第一个元素， &lt;code&gt;1&lt;/code&gt; 表示第二个元素，依此类推。负索引可用于指定从列表末尾开始的元素。在这里， &lt;code&gt;-1&lt;/code&gt; 表示最后一个元素， &lt;code&gt;-2&lt;/code&gt; 表示倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的长度。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其解释为空列表并返回 &lt;code&gt;0&lt;/code&gt; 。当 &lt;code&gt;key&lt;/code&gt; 处存储的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的字符串值的长度。当 &lt;code&gt;key&lt;/code&gt; 包含非字符串值时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">返回第一个集合和所有连续集合之间的差值所产生的集合成员。</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">返回所有给定集合的交集的成员。</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">返回所有给定集合的结合所产生的集合的成员。</target>
        </trans-unit>
        <trans-unit id="5f50e5f3ee257d3917e04c66ed0f097e9a6cbcd0" translate="yes" xml:space="preserve">
          <source>Returns the node's id.</source>
          <target state="translated">返回节点的id。</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的元素数，其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">返回流中的条目数。如果指定的键不存在，则命令返回零，就像流为空一样。但是请注意，与其他Redis类型不同，零长度流是可能的，因此应调用&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt;或&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;来检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中包含的字段数。</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">返回指定 Redis Cluster 哈希槽中的键数。该命令只查询本地数据集,因此,联系一个不为指定哈希槽服务的节点将始终导致返回零的计数。</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">返回指定频道的订阅者数量(不包括订阅模式的客户)。</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">返回模式的预订数量（使用&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;命令执行）。请注意，这不仅是已订阅模式的客户端数，而且是所有客户端已订阅的模式总数。</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 中的排序集中的 &lt;code&gt;member&lt;/code&gt; 的排名，其得分从高到低排序。等级（或索引）是从0开始的，这意味着得分最高的成员的等级是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 中的排序集中的 &lt;code&gt;member&lt;/code&gt; 的排名，其得分从低到高排序。等级（或索引）是基于0的，这意味着得分最低的成员的等级为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">返回已超时的key的剩余生存时间。这个自省功能允许Redis客户端检查一个给定的key将继续成为数据集的一部分的时间。</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的 &lt;code&gt;member&lt;/code&gt; 得分。</target>
        </trans-unit>
        <trans-unit id="4bb764cd364e3749541c7692eea4d198b1e88fce" translate="yes" xml:space="preserve">
          <source>Returns the scores associated with the specified &lt;code&gt;members&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 中存储的排序集中的指定 &lt;code&gt;members&lt;/code&gt; 相关联的分数。</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的集合的集合基数（元素数）。</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集合的排序集合基数（元素数）。</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的指定元素。偏移量 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 是从零开始的索引， &lt;code&gt;0&lt;/code&gt; 是列表的第一个元素（列表的开头）， &lt;code&gt;1&lt;/code&gt; 是下一个元素，依此类推。</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集中的元素的指定范围。这些元素被认为是从最高得分到最低得分排序的。降序字典顺序用于分数相等的元素。</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集中的元素的指定范围。元素被认为是从最低得分到最高得分排序的。字典顺序用于分数相等的元素。</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 处存储的哈希中的 &lt;code&gt;field&lt;/code&gt; 关联的值的字符串长度。如果 &lt;code&gt;key&lt;/code&gt; 或 &lt;code&gt;field&lt;/code&gt; 不存在，则返回0。</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的值的类型的字符串表示形式。可以返回的不同类型是： &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;zset&lt;/code&gt; 和 &lt;code&gt;hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9feb2d475967dd13f03c72121d597fd1520318c" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的值的类型的字符串表示形式。可以返回的不同类型是： &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;zset&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的字符串值的子字符串，该字符串由偏移量 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; （包括两端）确定。可以使用负偏移量来提供从字符串末尾开始的偏移量。因此-1表示最后一个字符，-2表示倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 中存储的哈希中的 &lt;code&gt;field&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 中存储的哈希中的指定 &lt;code&gt;fields&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">返回所有指定键的值。对于每个不包含字符串值或不存在的键，将返回特殊值 &lt;code&gt;nil&lt;/code&gt; 。因此，操作永远不会失败。</target>
        </trans-unit>
        <trans-unit id="0b14b8f8217819a1f6163396383d48d4cd2d94d9" translate="yes" xml:space="preserve">
          <source>Returns whether each &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回每个 &lt;code&gt;member&lt;/code&gt; 是否是存储在 &lt;code&gt;key&lt;/code&gt; 处的集合的成员。</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">使用&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT &lt;/a&gt;&lt;em&gt;开始&lt;/em&gt;和&lt;em&gt;结束&lt;/em&gt;可选参数递增地运行位图，在客户端累积结果，并可选地将结果缓存到密钥中。</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD key member [member ...]将一个或多个成员添加到一组中。</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE 同步将数据集保存到磁盘。</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">SAVE和NOSAVE修改器</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN光标[MATCH模式][COUNT计数]递增迭代键空间。</target>
        </trans-unit>
        <trans-unit id="72556acd6ec7fd4188e74406d411c51d45f1c442" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count] [TYPE type]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN光标[MATCH模式][COUNT计数][TYPE类型]递增迭代键空间。</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN基本用法</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN是一个基于游标的迭代器。这意味着在每次调用命令时,服务器都会返回一个更新的游标,用户需要在下一次调用中使用这个游标作为参数。</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD key 获取集合中的成员数。</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO 设置执行脚本的调试模式。</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]检查脚本缓存中是否存在脚本。</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">稿件冲洗</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH 从脚本缓存中删除所有脚本。</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">SCRIPT KILL</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 杀死当前正在执行的脚本。</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD 脚本 将指定的 Lua 脚本加载到脚本缓存中。</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF键[键...]减去多组。</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 目标键 [键...]减去多个集合,并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT index 更改当前连接的选定数据库。</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="b2f1db45c77eaf2c94d566bc200555c564e53670" translate="yes" xml:space="preserve">
          <source>SET  key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]   Set the string value of a key</source>
          <target state="translated">SET key value [EX seconds|PX milliseconds|KEEPTTL][NX|XX][GET]设置一个键的字符串值。</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET 键值 [过期 EX 秒|PX 毫秒][NX|XX]设置键的字符串值。</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT 键偏移值 设置或清除存储在键的字符串值中偏移的位。</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX 键秒值 设置键的值和到期时间。</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX 键值 设置键值,只有当键不存在时才设置。</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE 键偏移值 覆盖指定偏移量开始的键的部分字符串。</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]同步保存数据集到磁盘,然后关闭服务器。</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER键[键...]多组相交。</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE 目的键 [key ...]交叉多个集合,并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER 关键成员 确定一个给定的值是否是一个集合的成员。</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF 主机端口 使服务器成为另一个实例的副本,或将其升级为主服务器。从Redis 5开始已经废弃,使用REPLICAOF代替。</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOG子命令[参数]管理Redis慢速查询日志。</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS键 获取一个集合中的所有成员。</target>
        </trans-unit>
        <trans-unit id="3a5a30822e064f7dd03cefac6d437e4654f3aca9" translate="yes" xml:space="preserve">
          <source>SMISMEMBER</source>
          <target state="translated">SMISMEMBER</target>
        </trans-unit>
        <trans-unit id="aaa0292e655dd3747fc97cd25825a806d4aa708b" translate="yes" xml:space="preserve">
          <source>SMISMEMBER  key member [member ...]   Returns the membership associated with the given elements for a set</source>
          <target state="translated">SMISMEMBER key member [member ...]返回与给定元素相关联的集合成员资格。</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE源目标成员 将一个成员从一个集合移动到另一个集合。</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORT键 [BY pattern][LIMIT offset count][GET pattern [GET pattern ...]]。[ASC|DESC][ALPHA][STORE destination]对列表、集合或排序集合中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP键[count]从一个集合中删除并返回一个或多个随机成员。</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER key [count]从一个集合中获取一个或多个随机成员。</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM关键成员 [成员...]从一组成员中删除一个或多个成员。</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN键光标[MATCH模式][COUNT计数]递增迭代 设置元素。</target>
        </trans-unit>
        <trans-unit id="746fc78a74ffba46a591afc21fe85ad08b00b6da" translate="yes" xml:space="preserve">
          <source>STRALGO</source>
          <target state="translated">STRALGO</target>
        </trans-unit>
        <trans-unit id="3faaaa804aaa356ec8a33bd42d375f1bc189c7e7" translate="yes" xml:space="preserve">
          <source>STRALGO  LCS algo-specific-argument [algo-specific-argument ...]   Run algorithms (currently LCS) against strings</source>
          <target state="translated">STRALGO LCS algo-specific-argument [algo-specific-argument ...]对着字符串运行算法(目前是LCS)</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN 键 获取存储在键中的值的长度。</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE channel [channel ...]听取发布到给定频道的消息。</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION键[键......]添加多组。</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 目标键 [键...]添加多个集并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB索引索引交换两个Redis数据库。</target>
        </trans-unit>
        <trans-unit id="77754660ca2a32513ded08ad488bd2a9af650258" translate="yes" xml:space="preserve">
          <source>SWAPDB  index1 index2   Swaps two Redis databases</source>
          <target state="translated">SWAPDB index1 index2 交换两个Redis数据库。</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC 用于复制的内部命令</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">结果格式与&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt;相同，但您可以指定要返回的命令。</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">样本输出(新版本,包括IDs</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">样本输出(旧版</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">沙盒和最大执行时间</target>
        </trans-unit>
        <trans-unit id="c660854037806380c25fadc61428fa995d1aa015" translate="yes" xml:space="preserve">
          <source>Save the DB in background.</source>
          <target state="translated">在后台保存DB。</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">将数据库保存在后台。OK代码将立即返回。Redis分叉，父级继续为客户端提供服务，子级将DB保存在磁盘上，然后退出。客户端可以使用&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;命令检查操作是否成功。</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">扫描保证</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">脚本缓存语义</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">脚本也受到最大执行时间的限制(默认为5秒)。这个默认的超时时间是巨大的,因为一个脚本通常应该在一毫秒内运行。这个限制主要是为了处理开发过程中意外产生的无限循环。</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">脚本作为纯函数</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">脚本永远不应该尝试访问外部系统,比如文件系统或任何其他系统调用。脚本应该只对Redis数据和传递的参数进行操作。</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">第二个副本</target>
        </trans-unit>
        <trans-unit id="3eb4e043552c7873cf099793db5b7d1e5db95809" translate="yes" xml:space="preserve">
          <source>Security notice</source>
          <target state="translated">安全通知</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">有关文档，请参见&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">有关递增/递减操作的更多信息，请参见&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b864667dcad5904883861ad9695e349acea56ad8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;以获取&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;以获取&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">见&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;为&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">当您需要元素从最高到最低排序（对于具有相同得分的元素按字典顺序降序排列）时，请参见&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">另请参阅以毫秒为单位的分辨率返回相同信息的&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;命令（仅在Redis 2.6或更高版本中可用）。</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">有关确切的语义，请参阅&lt;a href=&quot;blpop&quot;&gt;BLPOP文档&lt;/a&gt;，因为&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;与BLPOP相同，唯一的不同是&lt;a href=&quot;blpop&quot;&gt;BRPOP&lt;/a&gt;从列表的尾部弹出元素而不是从头部弹出。</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">有关确切的语义，请参阅&lt;a href=&quot;blpop&quot;&gt;BLPOP文档&lt;/a&gt;，因为&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;与&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;相同，唯一的区别是要从中弹出数据结构。</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">见&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN文档&lt;/a&gt;的确切语义，因为&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt;是相同的&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;唯一的区别是它弹出得分最高的，而不是弹出得分最低的那些成员。</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">有关有趣的用例，请参见名为&amp;ldquo; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;使用Redis位图的快速便捷实时度量&lt;/a&gt; &amp;rdquo;的文章。</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">选择具有指定的基于零的数字索引的Redis逻辑数据库。新连接总是使用数据库0。</target>
        </trans-unit>
        <trans-unit id="5e585c2b51baeb7604c1d696f4c6be82b1e7c611" translate="yes" xml:space="preserve">
          <source>Selectable Redis databases are a form of namespacing: all databases are still persisted in the same RDB / AOF file. However different databases can have keys with the same name, and commands like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; work on specific databases.</source>
          <target state="translated">可选的Redis数据库是命名间隔的一种形式：所有数据库仍保留在同一RDB / AOF文件中。但是，不同的数据库可以具有相同名称的密钥，并且诸如&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;，&lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt;或&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY之&lt;/a&gt;类的命令可在特定数据库上使用。</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">有选择地复制命令</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">哨兵输出</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">序列化格式</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">以Redis特定的格式序列化存储在key处的值，并将其返回给用户。可以使用&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;命令将返回的值合成回Redis密钥。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 来保存字符串 &lt;code&gt;value&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 不存在。在这种情况下，它等于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;。当 &lt;code&gt;key&lt;/code&gt; 已经具有值时，将不执行任何操作。&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;是短期的&amp;ldquo; &lt;strong&gt;SET&lt;/strong&gt;如果&lt;strong&gt;&amp;ntilde;&lt;/strong&gt; OT&amp;Euml; &lt;strong&gt;X&lt;/strong&gt;派&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 以保留字符串 &lt;code&gt;value&lt;/code&gt; ，并将 &lt;code&gt;key&lt;/code&gt; 设置为在给定的秒数后超时。此命令等效于执行以下命令：</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 以保存字符串 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 已经包含一个值，则无论其类型如何，它都会被覆盖。成功进行&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作后，与密钥关联的任何先前生存时间都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">在 &lt;code&gt;key&lt;/code&gt; 上设置超时。超时到期后，密钥将自动删除。在Redis术语中，通常将具有相关超时的键称为&lt;em&gt;可变&lt;/em&gt;键。</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">将使用者组&lt;em&gt;上次交付的ID设置&lt;/em&gt;为其他名称。</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">为使用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;执行的后续脚本设置调试模式。Redis包含一个完整的Lua调试器，代号LDB，可用于简化编写复杂脚本的任务。在调试模式下，Redis充当远程调试服务器，并且客户端（例如 &lt;code&gt;redis-cli&lt;/code&gt; ）可以逐步执行脚本，设置断点，检查变量等-有关LDB的其他信息，请参阅&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua调试器&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; 将目标节点插槽设置为&lt;em&gt;导入&lt;/em&gt;状态。</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; 将源节点插槽设置为&lt;em&gt;迁移&lt;/em&gt;状态。</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">仅当 &lt;code&gt;field&lt;/code&gt; 尚不存在时，才将存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的 &lt;code&gt;field&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果 &lt;code&gt;field&lt;/code&gt; 已经存在，则此操作无效。</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">将存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的 &lt;code&gt;field&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果哈希中已经存在该 &lt;code&gt;field&lt;/code&gt; ，则将其覆盖。</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">集可以编码为 &lt;code&gt;intset&lt;/code&gt; 或 &lt;code&gt;hashtable&lt;/code&gt; 。该 &lt;code&gt;intset&lt;/code&gt; 是用于单纯的整数组成的小集的特殊编码。</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">设置或清除&lt;em&gt;key处&lt;/em&gt;存储的字符串值中&lt;em&gt;offset&lt;/em&gt;处的位。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">将给定的键设置为其各自的值。与常规&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;一样，&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;用新值替换现有值。如果您不想覆盖现有值，请参见&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">将给定的键设置为其各自的值。即使仅存在一个密钥，&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;也不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="97465787360d692779d220c22de863eac3b87265" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;index&lt;/code&gt; 处的list元素设置为 &lt;code&gt;element&lt;/code&gt; 。有关 &lt;code&gt;index&lt;/code&gt; 参数的更多信息，请参见&lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;index&lt;/code&gt; 处的list元素设置为 &lt;code&gt;value&lt;/code&gt; 。有关 &lt;code&gt;index&lt;/code&gt; 参数的更多信息，请参见&lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">将指定字段设置为存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的相应值。该命令将覆盖哈希中已经存在的所有指定字段。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">同理,要想得到只是添加到流中的最后一个元素,只需发送。</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">简单的字符串回复</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">由于&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;和&lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt;具有 &lt;code&gt;STORE&lt;/code&gt; 和 &lt;code&gt;STOREDIST&lt;/code&gt; 选项，因此从技术上讲，它们在Redis命令表中标记为正在写入命令。因此，只读副本将对其进行标记，即使连接处于只读模式，Redis Cluster副本也会将其重定向到主实例（请参阅Redis Cluster 的&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">由于&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;返回在失败和成功情况下都达到的副本数，因此客户端应检查返回的值等于或大于其所需的复制级别。</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">从Redis 2.4开始，AOF重写是由Redis自动触发的，但是&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;命令可随时用于触发重写。</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">从Redis 2.6开始,过期误差从0到1毫秒。</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">从Redis 3.0.3开始,可以指定多个键而不是一个键。在这种情况下,它返回的是现有键的总数。需要注意的是,对单个键返回1或0只是变量用法的一种特殊情况,所以该命令完全向后兼容。</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">自Redis 3.0.3以来,该命令接受的键数是可变的,返回值是通用的。</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">从Redis 3.2.10/4.0.0开始,这个命令还可以防止在客户端暂停的时间内键被驱逐或过期。这样一来,不仅从客户机无法写入的角度,而且从内部操作的角度,都能保证数据集的静态。</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">由于在第二次调用中返回的游标为0，因此服务器向调用者发出信号，告知迭代已完成，并且已完全浏览了该集合。从游标值0开始迭代，然后调用&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;直到返回的游标再次为0称为&lt;strong&gt;完整迭代&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">由于 &lt;code&gt;increment&lt;/code&gt; 参数是带符号的，因此可以执行递增和递减操作：</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">由于当前选择的数据库是连接的属性，因此客户端应跟踪当前选择的数据库并在重新连接时重新选择它。虽然没有命令可以查询当前连接中的选定数据库，但是&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;输出为每个客户端显示了当前选定的数据库。</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">自从引入了与副本的部分重新同步(PSYNC特性),Redis副本就会用它们在复制流中已经处理过的偏移量异步ping它们的主站。这有多种方式使用。</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">由于没有状态服务器端,但完整的状态被游标捕获,调用者可以自由地中途终止迭代,而不以任何方式向服务器发出信号。可以启动无限次的迭代,而且永远不会终止,不会出现任何问题。</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">由于这些命令允许增量迭代，每次调用仅返回少量元素，因此可以在生产中使用它们，而不会受到诸如&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;或&lt;a href=&quot;smembers&quot;&gt;SMEMBERS之&lt;/a&gt;类的命令的不利影响，这些命令在被调用时可能会长时间（甚至几秒钟）阻塞服务器键或元素的大集合。</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">由于这涉及到近似,为了避免C被设置为,比如,0.998而不是1,我们只需修改上面的算法,以确保最后的分数是1(留给读者作为练习......)。</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">从版本2.1.6开始，遵循&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;的语法， &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 可以是排他的。</target>
        </trans-unit>
        <trans-unit id="62c6108c3b6b3ae8ea558c2fa3e4a664136371f3" translate="yes" xml:space="preserve">
          <source>Since version 6.2 it is possible to filter entries by their idle-time, given in milliseconds (useful for &lt;code&gt;XCLAIM&lt;/code&gt;ing entries that have not been processed for some time):</source>
          <target state="translated">从6.2版开始，可以按空闲时间过滤条目（以毫秒为单位）（适用于 &lt;code&gt;XCLAIM&lt;/code&gt; 时间未处理的XCLAIM ing条目）：</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">单一号码:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">跳过对元素的排序</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">因此，例如，命令 &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; 将以以下方式返回每个项目：</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">因此,例如,要从较高ID到较低ID的所有元素可以使用。</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">所以,为了让一个给定的节点接受另一个节点进入组成Redis Cluster的节点列表,只有两种方式。</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">因此，我们从键列表开始，然后继续所有相关的ID，代表&lt;em&gt;我们为该流接收的最后一个ID&lt;/em&gt;，以便该调用仅向我们提供来自同一流的更大的ID。</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">所以这个命令真正的作用是:</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">因此，如果我们通过&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;将节点A与节点B链接起来，而将B与C链接起来，则A和C将找到握手和创建链接的方式。</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">因此，使用 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; 时，在创建新集群时，我们可以在将集群连接在一起之前为每个节点分配不同的渐进配置时代。</target>
        </trans-unit>
        <trans-unit id="f4318ce82f602a680da3fd3d1f1b92cbeae45d01" translate="yes" xml:space="preserve">
          <source>So, we want to say, give me the first element starting from the tail of the list:</source>
          <target state="translated">所以,我们想说,给我从列表尾部开始的第一个元素。</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">某些Redis命令没有预定的键位置。对于这些命令，将标志 &lt;code&gt;movablekeys&lt;/code&gt; 添加到命令标志&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;。您的Redis Cluster客户端需要解析标记为可 &lt;code&gt;movablekeys&lt;/code&gt; 键的命令以找到所有相关键的位置。</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">一些使用者A 在该使用者组的上下文中通过&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;从流中读取消息。</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">有时,对于客户端来说,完全禁用Redis服务器的回复是很有用的。例如,当客户端发送fire and forget命令或执行大量数据加载时,或者在新数据不断流的缓存环境中。在这样的情况下,为了给客户端发送回复而使用服务器的时间和带宽,而这些回复是会被忽略的,这被认为是浪费。</target>
        </trans-unit>
        <trans-unit id="a1fbf7ca3941093b616976378d4450adc4f2adb7" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">有时,删除旧的消费者可能是有用的,因为他们已经不再使用了。此表返回该消费者在被删除前的待处理信息数量。</target>
        </trans-unit>
        <trans-unit id="295b7c77aec21f1ec78f8bb6debbc23501dae53f" translate="yes" xml:space="preserve">
          <source>Sometimes we need just the length of the match:</source>
          <target state="translated">有时候我们需要的只是比赛的长度。</target>
        </trans-unit>
        <trans-unit id="0a212e08b7709fdef0e43a6ae14d5840bfa05846" translate="yes" xml:space="preserve">
          <source>Sometimes we want to return not just the Nth matching element, but the position of all the first N matching elements. This can be achieved using the &lt;code&gt;COUNT&lt;/code&gt; option.</source>
          <target state="translated">有时我们不仅要返回第N个匹配元素，还要返回所有前N个匹配元素的位置。这可以使用 &lt;code&gt;COUNT&lt;/code&gt; 选项来实现。</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">有时，您想使用外部键作为权重对元素进行排序，以进行比较，而不是比较列表，集合或排序集中的实际元素。比方说，清单 &lt;code&gt;mylist&lt;/code&gt; 包含的元素 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 表示存储在对象的唯一ID &lt;code&gt;object_1&lt;/code&gt; ， &lt;code&gt;object_2&lt;/code&gt; 和 &lt;code&gt;object_3&lt;/code&gt; 。当这些对象具有关联的权重存储在 &lt;code&gt;weight_1&lt;/code&gt; ， &lt;code&gt;weight_2&lt;/code&gt; 和 &lt;code&gt;weight_3&lt;/code&gt; 中时，可以通过以下语句指示&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;使用这些权重对 &lt;code&gt;mylist&lt;/code&gt; 进行排序：</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">排序集</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">排序集可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;skiplist&lt;/code&gt; 格式。至于列表类型小的有序集合可使用特殊编码 &lt;code&gt;ziplist&lt;/code&gt; ，而 &lt;code&gt;skiplist&lt;/code&gt; 编码是一个与有序集合任何大小的作品。</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">排序套路 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">已排序的集合按其得分以升序排序。同一元素仅存在一次，不允许重复元素。既可以通过将更新元素得分的&lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt;以及作为副作用的得分来修改得分，也可以通过ZINCRBY对其进行修改，而&lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt;可以用来相对于其先前值更新得分。</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">按外部键排序</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">不允许执行命令的特殊情况</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">特殊时段条目</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">具体来说,如果一个给定的写被传输到一个或多个副本,那么如果主控失败,我们更有可能(但不能保证)在故障转移期间,能够推广收到写的副本:Sentinel和Redis Cluster都会尽最大努力尝试在一组可用的副本中推广最好的副本。</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">具体来说就是Redis每秒做10次。</target>
        </trans-unit>
        <trans-unit id="2fa9940f1d66c2c57fbda5e1ef12bce097cf18d3" translate="yes" xml:space="preserve">
          <source>Specifically, it lists the user's ACL flags, password hashes and key name patterns. Note that command rules are returned as a string in the same format used with the &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; command. This description of command rules reflects the user's effective permissions, so while it may not be identical to the set of rules used to configure the user, it is still functionally identical.</source>
          <target state="translated">具体来说，它列出了用户的ACL标志，密码散列和密钥名模式。请注意，命令规则以字符串形式返回，与&lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;命令使用的格式相同。该命令规则描述反映了用户的有效权限，因此尽管它可能与用于配置用户的规则集不同，但在功能上仍然相同。</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">指定通过count时的行为</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">指定一个流ID作为参数</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">起始槽范围</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">从Redis版本2.6开始，当使用额外的 &lt;code&gt;count&lt;/code&gt; 参数调用时，如果 &lt;code&gt;count&lt;/code&gt; 为正，则返回由 &lt;code&gt;count&lt;/code&gt; 个&lt;strong&gt;不同元素组成&lt;/strong&gt;的数组。如果调用的 &lt;code&gt;count&lt;/code&gt; 为负，则行为会更改，并且命令可以&lt;strong&gt;多次&lt;/strong&gt;返回&lt;strong&gt;同一元素&lt;/strong&gt;。在这种情况下，返回的元素数是指定 &lt;code&gt;count&lt;/code&gt; 的绝对值。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">从Redis 2.6.12开始，&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;支持一组用于修改其行为的选项：</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">从Redis 2.8开始,出错时的返回值发生了变化。</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">从Redis 3.0.6开始，&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;支持一种新的批量迁移模式，该模式使用流水线操作，以便在实例之间迁移多个密钥，而不会产生往返时间延迟以及使用单个&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;调用移动每个密钥时的其他开销。</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">从Redis 3.2开始，Redis支持本地Lua调试。Redis Lua调试器是一个远程调试器，由服务器（即Redis本身）和客户端（默认情况下为 &lt;code&gt;redis-cli&lt;/code&gt; )组成。</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">从Redis 3.2开始，可以选择其他复制方法。除了复制整个脚本，我们还可以复制脚本生成的单个写入命令。我们将此&lt;strong&gt;脚本&lt;/strong&gt;称为&lt;strong&gt;复制效果&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2b5108a4d347209131d9cdaa00d48ad36bea64af" translate="yes" xml:space="preserve">
          <source>Starting with Redis version 6, the server supports two different protocols. One is called RESP2, and is the old protocol: all the new connections to the server start in this mode. However clients are able to negotiate the new protocol using the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command: this way the connection is put in RESP3 mode. In this mode certain commands, like for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;, reply with a new data type (the Map data type in this specific case). The RESP3 protocol is semantically more powerful, however most scripts are OK with using just RESP2.</source>
          <target state="translated">从Redis版本6开始，服务器支持两种不同的协议。一个称为RESP2，它是旧协议：与服务器的所有新连接都以这种模式启动。但是，客户端可以使用&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;命令协商新协议：这样，将连接置于RESP3模式。在这种模式下，某些命令（例如&lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;）以新的数据类型（在这种情况下为Map数据类型）回复。 RESP3协议在语义上更强大，但是大多数脚本只使用RESP2就可以了。</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">从技术上讲，步骤4不需要在 &lt;code&gt;SETSLOT&lt;/code&gt; 不涉及的节点中使用SETSLOT，因为配置最终会自行传播，但是这样做是一个好主意，以阻止节点指向哈希槽的错误节点尽快移动，从而减少了找到正确节点的重定向。</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">步数</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">停止所有的客户。</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">存储SORT操作的结果</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">流ID由两部分组成：Unix毫秒时间戳和在同一毫秒中插入的条目的序列号。可以使用&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;仅指定ID的第一部分（毫秒），如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="e577b53fb1794580c0560fa9502cf28744dcd504" translate="yes" xml:space="preserve">
          <source>Stream entries are returned, including fields and values.</source>
          <target state="translated">流条目被返回,包括字段和值。</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">一旦流中没有任何条目（例如，在&lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt;调用之后），流就不会被自动删除，因为该流可能具有与之关联的使用者组。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">字符串以二进制字节数组的形式进行比较。由于ASCII字符集是如何被指定的,这意味着通常这也有一个明显的字典方式比较普通ASCII字符的效果。然而,如果使用非纯ASCII字符串(例如utf8字符串),则不是这样。</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">字符串可以编码为 &lt;code&gt;raw&lt;/code&gt; （常规字符串编码）或 &lt;code&gt;int&lt;/code&gt; （以64位有符号间隔表示整数的字符串以这种方式编码，以节省空间）。</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">前缀相近的字符串就在附近,反之则不然,有可能不同前缀的字符串也在附近。</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">子命令 &lt;code&gt;encoding&lt;/code&gt; 返回批量答复。</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">子命令 &lt;code&gt;refcount&lt;/code&gt; 和 &lt;code&gt;idletime&lt;/code&gt; 返回整数。</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">将客户端订阅给定模式。</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">将客户端订阅到指定的频道。</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDING汇总表</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">支持的球型图案。</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">支持的子命令和整数类型</target>
        </trans-unit>
        <trans-unit id="108e22a5749de8f07b0272d8029eeb2811ea28dd" translate="yes" xml:space="preserve">
          <source>Switch the connection to a different protocol. Redis version 6 or greater are able to support two protocols, the old protocol, RESP2, and a new one introduced with Redis 6, RESP3. RESP3 has certain advantages since when the connection is in this mode, Redis is able to reply with more semantical replies: for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt; will return a &lt;em&gt;map type&lt;/em&gt;, so a client library implementation no longer requires to know in advance to translate the array into a hash before returning it to the caller. For a full coverage of RESP3 please &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;check this repository&lt;/a&gt;.</source>
          <target state="translated">将连接切换到其他协议。 Redis 6或更高版本能够支持两种协议，即旧协议RESP2和随Redis 6 RESP3引入的新协议。 RESP3具有某些优点，因为当连接处于此模式时，Redis可以使用更多语义上的答复：例如&lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;将返回一个&lt;em&gt;map类型&lt;/em&gt;，因此客户端库实现不再需要事先知道将数组转换为散列，然后再将其返回给调用方。有关RESP3的完整介绍，请&lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;检查此存储库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">TAKEOVER选项:在没有群集共识的情况下进行手动故障切换。</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 返回当前服务器时间</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH key [key ...]改变一个或多个钥匙的最后访问时间。返回指定的现有钥匙的数量。</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL键 获取键的生存时间。</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE键 确定存储在键的类型。</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">取一个分离的键,每次修改位图时都会递增。使用一个小的Redis Lua脚本,这可以是非常高效和原子的。</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">终止中间的迭代</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">从具有关联过期的密钥集中随机测试20个密钥。</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">感谢&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;和类似的&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;命令，您可以将Redis字符串用作具有O（1）随机访问的线性数组。在许多实际使用案例中，这是一种非常快速高效的存储。</target>
        </trans-unit>
        <trans-unit id="8026b8ed5921c819cac7c44288be64954a1b0af5" translate="yes" xml:space="preserve">
          <source>That is, the second occurrence of &quot;c&quot; is at position 6. A negative &quot;rank&quot; as the &lt;code&gt;RANK&lt;/code&gt; argument tells &lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt; to invert the search direction, starting from the tail to the head.</source>
          <target state="translated">也就是说，第二个出现的&amp;ldquo; c&amp;rdquo;在位置6。负数&amp;ldquo; rank&amp;rdquo;作为 &lt;code&gt;RANK&lt;/code&gt; 参数告诉&lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt;从尾到头反转搜索方向。</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">就是说，&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;可以用作锁定原语，并且在过去一直被用作锁定原语。例如，要获取键 &lt;code&gt;foo&lt;/code&gt; 的锁，客户端可以尝试以下操作：</target>
        </trans-unit>
        <trans-unit id="b0aa14a2afe89147b651f01c25f18c35b9adb8d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">该&lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt;命令返回描述不同子一个有用的文本。</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">的&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt;命令可以用来创建固定大小的示例的列表的一个非常紧凑的表示中，通常被称为&lt;em&gt;时间序列&lt;/em&gt;。每次有新样品到达时，我们可以使用以下命令将其存储</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">该&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt;命令支持四个位运算：&lt;strong&gt;AND&lt;/strong&gt;，&lt;strong&gt;OR&lt;/strong&gt;，&lt;strong&gt;XOR&lt;/strong&gt;和&lt;strong&gt;NOT&lt;/strong&gt;，从而有效形式调用命令是：</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">该&lt;a href=&quot;client-getname&quot;&gt;客户端的GetName&lt;/a&gt;返回当前连接作为集的名称&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;。由于每个新连接都在没有关联名称的情况下开始，因此，如果未分配名称，则返回空批量答复。</target>
        </trans-unit>
        <trans-unit id="1660d56ff9988d9b97b8e4b556121bfa1958f2dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. This command support two formats, the old format:</source>
          <target state="translated">该&lt;a href=&quot;client-kill&quot;&gt;客户端KILL&lt;/a&gt;命令关闭一个给定的客户端连接。此命令支持两种格式，即旧格式：</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">该&lt;a href=&quot;client-kill&quot;&gt;客户端KILL&lt;/a&gt;命令关闭一个给定的客户端连接。在Redis 2.8.11之前，可以使用以下格式仅通过客户端地址关闭连接：</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">该&lt;a href=&quot;client-list&quot;&gt;客户名单&lt;/a&gt;命令返回的信息和统计信息的大多是人类可读的格式的客户端连接服务器。</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">该&lt;a href=&quot;client-reply&quot;&gt;客户端REPLY&lt;/a&gt;命令控制服务器是否会回复客户端的命令。可以使用以下模式：</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">该&lt;a href=&quot;client-setname&quot;&gt;客户端SETNAME&lt;/a&gt;命令指定一个名称为当前连接。</target>
        </trans-unit>
        <trans-unit id="43f3ab9bcc1ea0150ec08bf3548ed1a84c95f9e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; command triggers an increment to the cluster's config epoch from the connected node. The epoch will be incremented if the node's config epoch is zero, or if it is less than the cluster's greatest epoch.</source>
          <target state="translated">的&lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt;命令触发的增量，以从所连接的节点群集的配置时代。如果节点的配置时期为零，或者小于群集的最大时期，则该时期将增加。</target>
        </trans-unit>
        <trans-unit id="7c5540561e37398d0ed7b865d91ceff7a71f6377" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt; deletes all information about slots from the connected node. It can only be called when the database is empty.</source>
          <target state="translated">所述&lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt;删除关于从所连接的节点槽的所有信息。只有在数据库为空时才可以调用它。</target>
        </trans-unit>
        <trans-unit id="1ca5f595e917e610d79a666d6599f3f325569dcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt; command returns the unique, auto-generated identifier that is associated with the connected cluster node.</source>
          <target state="translated">的&lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt;命令返回一个与所连接的群集节点相关联的唯一的，自动生成标识符。</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">的&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt;命令是为了使用Redis的群集迁移所有包含在一个哈希位置从一个节点到另一个的钥匙的一个重要部件。这也是在其他命令的帮助下协调迁移的方式。我们将拥有哈希槽当前所有权的节点称为 &lt;code&gt;source&lt;/code&gt; 节点，并将我们要迁移 &lt;code&gt;destination&lt;/code&gt; 节点的节点称为&amp;ldquo; 源&amp;rdquo;节点。</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">在&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt;命令用于读取一个运行Redis的服务器的配置参数。Redis 2.4并不支持所有配置参数，而Redis 2.6可以使用此命令读取服务器的整个配置。</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">该&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt;命令重写 &lt;code&gt;redis.conf&lt;/code&gt; 服务器启动时使用的文件，应用，使其反映当前使用的服务器配置所需的最小的变化，相对于因为使用的原来这可能是不同的&lt;a href=&quot;config-set&quot;&gt;配置集&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">该&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;命令，以重新配置在运行时服务器，而不需要重启Redis的使用。您可以使用此命令更改这两个琐碎的参数或从一个持久性选项切换到另一个持久性选项。</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">该&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;命令迫使你一次又一次地发送脚本主体。Redis不需要每次都重新编译脚本，因为它使用内部缓存机制，但是在许多情况下，支付额外带宽的成本可能不是最优的。</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">该&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;命令的家庭能够联想到的到期给定的关键，在通过按键使用了一些额外的内存成本。当密钥设置了过期时，Redis将确保在经过指定的时间后删除密钥。</target>
        </trans-unit>
        <trans-unit id="9537af381c721635428a198bca98f65d00f50bfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command has a useful reply that will state a number of facts about the server: the exact version, the set of modules loaded, the client ID, the replication role and so forth. Because of that, and given that the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command also works with &quot;2&quot; as argument, both in order to downgrade the protocol back to version 2, or just to get the reply from the server without switching the protocol, client library authors may consider using this command instead of the canonical &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; when setting up the connection.</source>
          <target state="translated">该&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;命令有会说明一些有关服务器事实的有用的答案：确切的版本，加载的模块组，客户端ID，复制的作用等等。因此，考虑到&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;命令也以&amp;ldquo; 2&amp;rdquo;作为参数，为了将协议降级至版本2，或者只是为了从服务器获取答复而无需切换协议，客户端库作者可能会考虑建立连接时使用此命令而不是规范的&lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">该&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令返回的信息和统计信息的格式很简单通过计算机来分析和容易被人读取服务器。</target>
        </trans-unit>
        <trans-unit id="a72bec6083e79854302b4e9ff14a0e8f3e859562" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTOR&lt;/a&gt; command reports about different latency-related issues and advises about possible remedies.</source>
          <target state="translated">在&lt;a href=&quot;latency-doctor&quot;&gt;潜伏期医生&lt;/a&gt;对不同的延迟相关的问题命令报告，并建议有关可能的补救措施。</target>
        </trans-unit>
        <trans-unit id="1066b09a9b25b6b6ed879ca10e517428a219419a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-help&quot;&gt;LATENCY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">在&lt;a href=&quot;latency-help&quot;&gt;潜伏期HELP&lt;/a&gt;命令返回描述不同子一个有用的文本。</target>
        </trans-unit>
        <trans-unit id="50807ff2bf2c847fd5988e426fdf8c05c9a36546" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; command returns the raw data of the &lt;code&gt;event&lt;/code&gt;'s latency spikes time series.</source>
          <target state="translated">的&lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt;命令返回的原始数据 &lt;code&gt;event&lt;/code&gt; 的延迟高峰的时间序列。</target>
        </trans-unit>
        <trans-unit id="52c78093ad61fe69ebb2499c714e0f2256697635" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt; command reports the latest latency events logged.</source>
          <target state="translated">在&lt;a href=&quot;latency-latest&quot;&gt;潜伏期最新&lt;/a&gt;命令报告最新的时延事件记录。</target>
        </trans-unit>
        <trans-unit id="147880a1d1ea91581373c0559cd3dfedfc864e5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt; command resets the latency spikes time series of all, or only some, events.</source>
          <target state="translated">在&lt;a href=&quot;latency-reset&quot;&gt;潜伏期RESET&lt;/a&gt;命令重置等待时间尖峰时间序列的全部或仅一些事件。</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">该&lt;a href=&quot;memory-doctor&quot;&gt;内存神医&lt;/a&gt;约不同的内存相关的问题命令报告Redis的服务器的经验，并建议对可能的补救措施。</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">的&lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt;命令返回描述不同子一个有用的文本。</target>
        </trans-unit>
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">的&lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt;命令提供了一个内部统计从存储器分配器报告。</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">的&lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt;命令尝试清除脏页所以这些可通过分配器被回收。</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">的&lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt;命令返回一个&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;阵列答复&lt;/a&gt;有关服务器的存储器使用量。</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">的&lt;a href=&quot;memory-usage&quot;&gt;存储器使用&lt;/a&gt;命令报告的字节数，一个密钥和它的值需要被存储在RAM中。</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">的&lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt;命令允许检查与密钥相关联的Redis对象的内部结构。这对于调试或了解您的密钥是否使用特殊编码的数据类型以节省空间很有用。在将Redis用作缓存时，您的应用程序还可以使用&lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt;命令报告的信息来实现应用程序级密钥收回策略。</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">的&lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt;命令支持的多个子命令：</target>
        </trans-unit>
        <trans-unit id="ca3cc9ef5973b2b3ef21bdff9c9e13b41c03044f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master.</source>
          <target state="translated">该&lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;命令由Redis的称为复制品，用于从主发起复制流。</target>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">该&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;命令可以动态改变一个副本的复制设置。</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">该&lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt;命令仅当键已经存在推动因素。</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">在&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt;命令执行一个&lt;strong&gt;同步&lt;/strong&gt;保存数据集产生的&lt;em&gt;时间点&lt;/em&gt;的所有Redis的实例中的数据的快照，在RDB文件的形式。</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">该&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;算法是保证终止仅在迭代集合保持一定到给定的最大尺寸的大小，否则迭代的集合，总是增长可能导致到&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;永远不会终止一个完整的迭代。</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">使用&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;命令和与之密切相关的命令&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;，&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;和&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;以便逐步迭代元素集合。</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">在&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;命令，并在其他命令&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;家庭，能够提供给用户的一组相关联的全迭代保证。</target>
        </trans-unit>
        <trans-unit id="1745a85b233cd9864512e1af6c727c0eb8686c05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command supports a set of options that modify its behavior:</source>
          <target state="translated">在&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令支持一组修改其行为的选项：</target>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">该&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;命令可以动态改变一个副本的复制设置。如果Redis服务器已经充当副本，则命令&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE将关闭复制，从而将Redis服务器变成MASTER。以适当的形式，&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;主机名端口将使服务器成为侦听指定主机名和端口的另一台服务器的副本。</target>
        </trans-unit>
        <trans-unit id="0ff4cdfae050eccc9a56820c72e2716bcf7a7f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master. It has been replaced in newer versions of Redis by &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt;命令由Redis的称为复制品，用于从主发起复制流。&lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;已在较新版本的Redis中将其替换。</target>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">该&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;命令返回当前服务器时间为两个项目的列表：Unix时间戳和微秒的当前秒已经逝去的量。基本上，该接口与 &lt;code&gt;gettimeofday&lt;/code&gt; 系统调用之一非常相似。</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">所述&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令删除从所述一个或多个消息&lt;em&gt;未决条目列表&lt;/em&gt;流消费群（PEL）。当消息传递给某些使用者时，通常是调用&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP的副作用&lt;/a&gt;，或者当使用者拥有调用&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;的消息的所有权时，消息将挂起，并因此存储在PEL中。待处理的消息已传递给某些使用者，但服务器仍不确定它是否已至少处理一次。因此，新调用&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;来获取使用者的消息历史记录（例如，使用ID为0）将返回此类消息。同样，待检查的消息将由检查PEL 的&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令列出。</target>
        </trans-unit>
        <trans-unit id="7dd37542831e217f80423791c1758b898b47cbcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command allows iterating over the pending entries just like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; and &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; allow for the stream's entries. You can do this by prefixing the ID of the last-read pending entry with the &lt;code&gt;(&lt;/code&gt; character that denotes an open (exclusive) range, and proving it to the subsequent call to the command.</source>
          <target state="translated">该&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令允许遍历待定参赛就像&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;和&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;允许流的条目。您可以通过在最后读取的未决条目的ID前面加上 &lt;code&gt;(&lt;/code&gt; 表示开放（独占）范围的字符）的前缀，并将其证明给随后的命令调用来实现。</target>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">该&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令检查待处理的邮件列表界面，并且是作为这样一个非常重要的命令，以观察和了解与流的消费群体发生了：什么客户是主动的，有什么消息待被消耗，或查看是否有空闲消息。此外，此命令与&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;一起用于实现对长期失败的使用者的恢复，结果某些消息未得到处理：另一个使用者可以声明该消息并继续。在&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;流介绍&lt;/a&gt;和&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;命令页面中对此进行了更好的解释，此处不再赘述。</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">该&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;命令有许多应用程序：</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">该&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;命令是一个特殊版本&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;命令与消费群体的支持。在阅读本页之前，您可能必须了解&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">的 &lt;code&gt;-&lt;/code&gt; ID是有效地只是恰好为指定 &lt;code&gt;0-0&lt;/code&gt; ，而 &lt;code&gt;+&lt;/code&gt; 相当于 &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; ，然而，它们是更好键入。</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">的 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 特殊的ID分别指最低ID可能和流内的最高ID可能的，因此下面的命令将只返回流中的每个条目：</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">该 &lt;code&gt;BY&lt;/code&gt; 选项也可以采取一个不存在的关键，这将导致&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;跳过排序操作。如果要检索外部键（请参阅下面的 &lt;code&gt;GET&lt;/code&gt; 选项）而没有排序的开销，这将很有用。</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">在 &lt;code&gt;BY&lt;/code&gt; 选项接受一个图案（等于 &lt;code&gt;weight_*&lt;/code&gt; 在该示例中），其用于产生被用于排序的密钥。获得代的第一次出现这些键名 &lt;code&gt;*&lt;/code&gt; 与元件的列表中（实际值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 在这个例子中）。</target>
        </trans-unit>
        <trans-unit id="bd7cf93ba7657f4f2966769280d74bac3ba29a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COUNT&lt;/code&gt; option is used to limit the amount of stream/PEL entries that are returned (The first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; entries are returned). The default &lt;code&gt;COUNT&lt;/code&gt; is 10 and a &lt;code&gt;COUNT&lt;/code&gt; of 0 means that all entries will be returned (Execution time may be long if the stream has a lot of entries)</source>
          <target state="translated">该 &lt;code&gt;COUNT&lt;/code&gt; 选项用于限制返回流/ PEL条目的数量（第一 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 返回的条目）。默认 &lt;code&gt;COUNT&lt;/code&gt; 为10， &lt;code&gt;COUNT&lt;/code&gt; 为0表示将返回所有条目（如果流中有很多条目，则执行时间可能会很长）</target>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">所述 &lt;code&gt;DELSLOTS&lt;/code&gt; 命令要求一个特定的Redis群集节点到忘了哪个主正在服务指定作为自变量的散列时隙。</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">该 &lt;code&gt;GET&lt;/code&gt; 选项，以获得更多的密钥的原始清单，集或排序集的每一个元素被多次使用。</target>
        </trans-unit>
        <trans-unit id="d2200d7bc7ff4797c7f7c14add0d36376defba47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ID&lt;/code&gt; filter only returns entries for clients with IDs matching the &lt;code&gt;client-id&lt;/code&gt; arguments.</source>
          <target state="translated">该 &lt;code&gt;ID&lt;/code&gt; 过滤器只返回客户机的项相匹配的ID &lt;code&gt;client-id&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">的 &lt;code&gt;NOACK&lt;/code&gt; 子命令可用于避免增加该消息的情况下的PEL其中可靠性不是要求和偶尔的消息丢失是可以接受的。这等效于在读取消息时确认消息。</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">该 &lt;code&gt;NODE&lt;/code&gt; 子是一个最复杂的语义。它将哈希插槽与指定的节点相关联，但是该命令仅在特定情况下有效，并且根据插槽状态具有不同的副作用。以下是该命令的一组前提条件和副作用：</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">该 &lt;code&gt;aof_delayed_fsync&lt;/code&gt; 计数器</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">从3.2版开始， &lt;code&gt;count&lt;/code&gt; 参数可用。</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">的 &lt;code&gt;ip:port&lt;/code&gt; 应该匹配由返回的线&lt;a href=&quot;client-list&quot;&gt;客户端列表&lt;/a&gt;命令（ &lt;code&gt;addr&lt;/code&gt; 字段）。</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">该 &lt;code&gt;message&lt;/code&gt; 的说法只是一个字符串。例：</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 参数具有如对所描述的相同的含义&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 参数具有相同的语义作为用于描述&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">所述 &lt;code&gt;score&lt;/code&gt; 值应该是一个数字值的字符串表示，并接受双精度浮点数。可以提供一个负值来降低分数。</target>
        </trans-unit>
        <trans-unit id="4192359597f0ce567f180b8ce4e1911ba0a4fee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as a double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">的 &lt;code&gt;timeout&lt;/code&gt; 参数被解释为一个双值，指定的秒到块的最大数量。零超时可以无限期地阻塞。</target>
        </trans-unit>
        <trans-unit id="e7f5712887288aace7cb25c9ca1f98dbdf6c03f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">的 &lt;code&gt;timeout&lt;/code&gt; 参数被解释为一个双值，指定的秒到块的最大数量。零超时可以无限期地阻塞。</target>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">的 &lt;code&gt;timeout&lt;/code&gt; 参数被解释为一个整数值指定的秒到块的最大数量。零超时可以无限期地阻塞。</target>
        </trans-unit>
        <trans-unit id="1ad755fb1756745bfb0855cce9d6737683c771bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument is the same string name that the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; command returns. Note a quirk where some Redis types, such as GeoHashes, HyperLogLogs, Bitmaps, and Bitfields, may internally be implemented using other Redis types, such as a string or zset, so can't be distinguished from other keys of that same type by &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;. For example, a ZSET and GEOHASH:</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 参数是相同的字符串名称的&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt;命令返回。请注意一个怪癖，其中某些Redis类型（例如GeoHashes，HyperLogLogs，Bitmap和Bitfields）可以在内部使用其他Redis类型（例如字符串或zset）来实现，因此&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;不能将其与相同类型的其他键区分开。例如，ZSET和GEOHASH：</target>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">在 &lt;code&gt;~&lt;/code&gt; 之间争论&lt;strong&gt;MAXLEN&lt;/strong&gt;选项和实际计数意味着用户是不是真的请求流的长度正好是1000个项目，而是它可能是个条目的几十个，但从来没有少于1000个项目。使用此选项修饰符时，仅当Redis能够删除整个宏节点时才执行修剪。这使其效率更高，通常就是您想要的。</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">的&lt;strong&gt;STREAMS&lt;/strong&gt;选项是强制性的，因为这样的选项得到以下面的格式参数的可变长度必须是最后一个选项：</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">该&lt;strong&gt;TAKEOVER&lt;/strong&gt;选项意味着一切&lt;strong&gt;FORCE&lt;/strong&gt;意味着，但也没有任何使用授权集群，以故障转移。接收 &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; 的副本将改为：</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">该&lt;strong&gt;集群&lt;/strong&gt;节目前只包含一个独特的领域：</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">所述&lt;strong&gt;commandstats&lt;/strong&gt;部分提供基于该命令类型的统计信息，包括呼叫的数量，这些命令所消耗的总的CPU时间，和每命令执行所消耗的平均CPU。</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">该&lt;strong&gt;密钥空间&lt;/strong&gt;部分提供了每个数据库的主词典的统计数据。统计信息是键的数量，以及带有到期时间的键的数量。</target>
        </trans-unit>
        <trans-unit id="3a0202270041736b1216ba5baa1f54459be4f741" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;modules&lt;/strong&gt; section contains additional information about loaded modules if the modules provide it. The field part of properties lines in this section is always prefixed with the module's name.</source>
          <target state="translated">所述&lt;strong&gt;模块&lt;/strong&gt;部分包含有关加载的模块，如果模块提供它的附加信息。本节中属性行的字段部分始终以模块名称为前缀。</target>
        </trans-unit>
        <trans-unit id="3ac8492c1e70ee526ecccc4abef734bddc537815" translate="yes" xml:space="preserve">
          <source>The AUTH command authenticates the current connection in two cases:</source>
          <target state="translated">AUTH命令在两种情况下对当前连接进行认证。</target>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">CJSON库在Lua中提供了极快的JSON操作。</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">COUNT选项</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">可以使用HyperLogLog数据结构，以便仅使用少量恒定的内存就可以对集合中的&lt;strong&gt;唯一&lt;/strong&gt;元素进行计数，特别是每个HyperLogLog的大小为12k字节（对于密钥本身为几个字节）。</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">HyperLogLog是Redis字符串，可以使用&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;检索并使用&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;还原。使用损坏的HyperLogLog 调用&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;，&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;或&lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt;命令绝不是问题，它可以返回随机值，但不会影响服务器的稳定性。在大多数情况下，破坏稀疏表示时，服务器会识别出破坏并返回错误。</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">ID是单调递增的。如果一个连接的ID大于另一个连接的ID,则保证第二个连接是在后来与服务器建立的。</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">在Redis服务器执行的过程中,这个ID永远不会被重置,只有服务器重启才会重置它。</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">最后一个条目的ID是 &lt;code&gt;1526985685298-0&lt;/code&gt; ，因此我们只需在序列中加1即可获得 &lt;code&gt;1526985685298-1&lt;/code&gt; ，然后继续进行迭代：</target>
        </trans-unit>
        <trans-unit id="7eefbc13fad88639889dfca1eea5bd903a412b2f" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just prefix it with a '(', and continue our iteration:</source>
          <target state="translated">最后一个条目的ID是 &lt;code&gt;1526985685298-0&lt;/code&gt; ，所以我们只给它加上'（'前缀，然后继续我们的迭代：</target>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">信息的ID。</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">使用&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;时在&lt;strong&gt;STREAMS&lt;/strong&gt;选项中指定的ID 可以是以下两个之一：</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">主的IP。</target>
        </trans-unit>
        <trans-unit id="5bcb92df23fdb05d8a0140fd9087b6b631c09793" translate="yes" xml:space="preserve">
          <source>The LCS subcommand implements the longest common subsequence algorithm. Note that this is different than the longest common string algorithm, since matching characters in the string does not need to be contiguous.</source>
          <target state="translated">LCS 子命令实现了最长公共子序列算法。请注意,这与最长公共字符串算法不同,因为字符串中的匹配字符不需要是连续的。</target>
        </trans-unit>
        <trans-unit id="e326a0ab79090e9945701455a9f67576780adbaf" translate="yes" xml:space="preserve">
          <source>The LOLWUT command displays the Redis version: however as a side effect of doing so, it also creates a piece of generative computer art that is different with each version of Redis. The command was introduced in Redis 5 and announced with this &lt;a href=&quot;http://antirez.com/news/123&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">LOLWUT命令显示Redis版本：但是，这样做的副作用是，它还会生成一段生成性的计算机艺术作品，该艺术作品与每个Redis版本都不同。该命令在Redis 5中引入，并在此&lt;a href=&quot;http://antirez.com/news/123&quot;&gt;博客文章中&lt;/a&gt;宣布。</target>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">Lua位操作模块增加了对数字的位操作。从2.8.18版本开始,它就可以在Redis中使用脚本了。</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">该模式下的Lua PRNG在每次调用时都是随机播种的。</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">Redis文档的&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua脚本调试&lt;/a&gt;部分中介绍了Lua调试器。</target>
        </trans-unit>
        <trans-unit id="4515a3f12b04929b3987b1647823726616d895eb" translate="yes" xml:space="preserve">
          <source>The Lua engine always assumes to run in RESP2 mode when talking with Redis, so whatever the connection that is invoking the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; or &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command is in RESP2 or RESP3 mode, Lua scripts will, by default, still see the same kind of replies they used to see in the past from Redis, when calling commands using the &lt;code&gt;redis.call()&lt;/code&gt; built-in function.</source>
          <target state="translated">Lua引擎在与Redis通话时始终假定以RESP2模式运行，因此无论调用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;或&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;命令的连接处于RESP2还是RESP3模式，Lua脚本在默认情况下仍会看到与它们相同的答复。使用 &lt;code&gt;redis.call()&lt;/code&gt; 内置函数调用命令时，可以从Redis中查看过去。</target>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">匹配选项</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">PUBSUB命令是一个自省命令,可以检查Pub/Sub子系统的状态。它由子命令组成,这些子命令将被单独记录。一般的形式是:</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">Redis Lua解释器会加载以下Lua库。</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">Redis慢速日志是一个记录超过指定执行时间的查询的系统。执行时间不包括与客户端对话、发送回复等I/O操作,只是实际执行命令所需的时间(这是命令执行的唯一阶段,在此期间线程被阻塞,不能为其他请求服务)。</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">SCRIPT命令</target>
        </trans-unit>
        <trans-unit id="7b0199097175bc8f260d469794e2e96bed7dab06" translate="yes" xml:space="preserve">
          <source>The STRALGO implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future. The goal of this command is to provide to Redis users algorithms that need fast implementations and are normally not provided in the standard library of most programming languages.</source>
          <target state="translated">STRALGO实现了对字符串操作的复杂算法。目前唯一实现的算法是LCS算法(最长公共子串)。然而未来可能会实现新的算法。这个命令的目标是为Redis用户提供需要快速实现的算法,这些算法通常在大多数编程语言的标准库中没有提供。</target>
        </trans-unit>
        <trans-unit id="a04ad115145f4340fd6a7e75d3c008104af8a7d2" translate="yes" xml:space="preserve">
          <source>The TYPE option</source>
          <target state="translated">类型选项</target>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">在使用Redis作为数据库和分布式缓存系统时,查看服务器处理的所有请求的能力对于发现应用程序中的错误非常有用。</target>
        </trans-unit>
        <trans-unit id="a9a4c4b85d74e390cf97f77d86569a9c392136a7" translate="yes" xml:space="preserve">
          <source>The above command will create a user called &lt;code&gt;virginia&lt;/code&gt; that is active (the on rule), can access any key (allkeys rule), and can call the set command (+set rule). Then another SETUSER call can modify the user rules:</source>
          <target state="translated">上面的命令将创建一个名为 &lt;code&gt;virginia&lt;/code&gt; 的用户，该用户处于活动状态（on规则），可以访问任何键（allkeys规则），并且可以调用set命令（+ set规则）。然后另一个SETUSER调用可以修改用户规则：</target>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">上述内容使得实现一个系统非常简单,在这个系统中,一组项目必须由N个工作者以尽可能快的速度连续处理。一个例子是一个监控系统,它必须使用一些并行工作者,以尽可能小的延迟来检查一组网站是否可以到达。</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">上述模式即使在以下两个条件下也是可行的。</target>
        </trans-unit>
        <trans-unit id="27a55611f4365743e826db0b0f9378c4a66a4f67" translate="yes" xml:space="preserve">
          <source>The above rule will not apply the new rule to the user virginia, so other than &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, the user virginia will now be able to also use the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; command.</source>
          <target state="translated">上面的规则不会将新规则应用于用户弗吉尼亚州，因此，除了&lt;a href=&quot;set&quot;&gt;SET之外&lt;/a&gt;，用户弗吉尼亚州现在还可以使用&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">上面的脚本将键 &lt;code&gt;foo&lt;/code&gt; 设置为字符串 &lt;code&gt;bar&lt;/code&gt; 。但是，它违反了&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;命令的语义，因为脚本使用的所有键都应使用 &lt;code&gt;KEYS&lt;/code&gt; 数组传递：</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">数组的附加元素取决于角色。</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">所使用的算法是在dict.c中实现的,它对哈希表桶进行采样以找到一个非空的桶。一旦找到一个非空的桶,因为我们在哈希表的实现中使用了链式,所以会检查桶内的元素数量,并随机选择一个元素。</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">到目前为止,从副本收到的数据量,以主复制偏移量计算。</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">其执行所需的时间,以微秒为单位。</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;观察到的唯一元素的近似数量。</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">所述的参数 &lt;code&gt;redis.call()&lt;/code&gt; 和 &lt;code&gt;redis.pcall()&lt;/code&gt; 函数都是形成的阱Redis的命令的参数：</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">组成命令参数的数组。</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">分配的名称显示在&amp;ldquo; &lt;a href=&quot;client-list&quot;&gt;客户端列表&amp;rdquo;&lt;/a&gt;的输出中，以便可以识别执行给定连接的客户端。</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">基本思路是,默认情况下,节点之间互不信任,被认为是未知的,因此,不同的集群节点不可能因为系统管理错误或网络地址修改而混为一体。</target>
        </trans-unit>
        <trans-unit id="d3155ed9386ade27ef1929683ef41081fb15be86" translate="yes" xml:space="preserve">
          <source>The basic usage is the following:</source>
          <target state="translated">基本用法如下:</target>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">Redis 2.4的行为在将数据复制或持久化到AOF文件中时,会产生很多问题,所以在Redis 2.6中引入了更通用、语义更简单的行为来防止问题的发生。</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">比较的二进制性质允许使用排序集作为通用索引,例如元素的第一部分可以是64位大恩迪数:由于大恩迪数的初始位置有最重要的字节,所以二进制比较将匹配数字的数值比较。这可以用来实现对64位值的范围查询。如下面的例子,在前8个字节之后,我们可以存储我们实际索引的元素的值。</target>
        </trans-unit>
        <trans-unit id="f19a05fbdb75f958bfa6f09541362b1de2c7798d" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1.</source>
          <target state="translated">该位可以根据&lt;em&gt;value&lt;/em&gt;设置或清除，该&lt;em&gt;值&lt;/em&gt;可以为0或1。</target>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">根据&lt;em&gt;value&lt;/em&gt;可以设置或清除该位，该&lt;em&gt;值&lt;/em&gt;可以为0或1。当&lt;em&gt;键&lt;/em&gt;不存在时，将创建一个新的字符串值。字符串经过增长以确保可以在&lt;em&gt;offset&lt;/em&gt;处保留一点。所述&lt;em&gt;偏移&lt;/em&gt;参数是必需的，以大于或等于0，且小于2 &lt;sup&gt;32&lt;/sup&gt;（这限制位图512MB）。当&lt;em&gt;键&lt;/em&gt;处的字符串增长时，添加的位将设置为0。</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">客户端显式检查&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令中的 &lt;code&gt;runid&lt;/code&gt; 字段，以确保服务器没有重新启动并且仍然是同一进程。</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">客户端标志可以是以下几种组合:</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">即使客户端实际调用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;，客户端库实现也始终可以乐观地发送&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;，以希望脚本已被服务器看到。如果返回了 &lt;code&gt;NOSCRIPT&lt;/code&gt; 错误，则将使用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">客户端库的实现应采取以下方式之一:</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">客户端发送了一个关于哈希槽的命令,这个副本的主控从未服务过。</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">客户端将必须使用&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;确认消息处理，以便将待处理条目从PEL中删除。可以使用&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令检查PEL 。</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">群集被重新配置(例如重新设置),副本不再能够为给定的哈希槽提供命令。</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">cmsgpack库在Lua中提供了简单和快速的MessagePack操作。</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;命令还能够迭代该流。命令&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;可以将流反向迭代，从较高的ID（或时间）到较低的ID（或时间）。</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">命令 &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; 是使用Redis实现锁定系统的简单方法。</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">在达到指定的副本数或达到超时的情况下，该命令&lt;strong&gt;将始终返回&lt;/strong&gt;确认在&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;命令之前发送的写命令的副本数。</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">该命令还有一个相互的命令，以相反的顺序返回项目，称为&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;，否则该命令相同。</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">可以通过两个选项来修改命令行为：&lt;strong&gt;FORCE&lt;/strong&gt;和&lt;strong&gt;TAKEOVER&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">该命令行为如下。</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">该命令可以接受可变数量的参数,因此即使指定了单个元素,它也总是返回一个位置数组。</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">该命令可以用四个不同的参数来调用。</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">命令的默认值是返回未排序的项目。可以使用以下两个选项调用两种不同的排序方法。</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">在下列情况下,该命令不成功,并返回错误。</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">如果多次指定同一槽位,则命令失败。</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">该命令具有多个选项，但是大多数选项主要供内部使用，以便将&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;或其他命令的效果传输到AOF文件并将相同的效果传播到从属设备，并且对于普通用户不太可能有用：</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">该命令在内部使用&lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;生成键值的序列化版本，并使用&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;以便在目标实例中合成键。源实例充当目标实例的客户端。如果目标实例对&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;命令返回OK ，则源实例使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;删除密钥。</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">该命令始终作为&lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt;操作在复制链接和&amp;ldquo;仅追加文件&amp;rdquo;中传播，因此基础浮点数学实现中的差异不会成为不一致的根源。</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">该命令始终在复制链接和&amp;ldquo;仅附加文件&amp;rdquo;中作为&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作传播，因此基础浮点数学实现中的差异不会成为不一致的根源。</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">该命令是原子的，并且在转移密钥所需的时间内阻止了这两个实例，在任何给定时间，该密钥似乎都将存在于给定实例或另一个实例中，除非发生超时错误。在3.2及更高版本中，可以通过传递空字符串（&amp;ldquo;&amp;rdquo;）作为键并添加&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;子句，在一次调用&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;的过程中通过管道传递多个键。</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">使用该命令是为了从接收命令的Redis Cluster节点的&lt;em&gt;已知节点&lt;/em&gt;集中删除通过其节点ID指定的节点。换句话说，将从接收命令的节点的&lt;em&gt;节点表&lt;/em&gt;中删除指定的节点。</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">该命令只是返回当前连接的ID。每个连接ID都有一定的保证。</target>
        </trans-unit>
        <trans-unit id="1e36a1bc65a56400c52d66e29f9ce1757bbf2e26" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.</source>
          <target state="translated">该命令可能会因错误而失败,原因有几个:如果文件无法写入,或者服务器没有配置为使用外部ACL文件。</target>
        </trans-unit>
        <trans-unit id="344468f4b5f6d51949f0a2c14063fc0a3b852987" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such case the error will be reported to the user in the error. Finally the command will fail if the server is not configured to use an external ACL file.</source>
          <target state="translated">该命令可能会因为以下几种原因而失败:如果文件不可读,如果文件内部有错误,在这种情况下,将在错误中向用户报告。最后,如果服务器没有配置为使用外部ACL文件,该命令将失败。</target>
        </trans-unit>
        <trans-unit id="4aa2b5549f1c670208cc851a7701050140450874" translate="yes" xml:space="preserve">
          <source>The command may reply with an error in certain cases, as documented above.</source>
          <target state="translated">如上文所述,在某些情况下,该命令可能会回复错误。</target>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">只有当所有指定的插槽都已经与某个节点相关联时,该命令才会生效。</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">从接收命令的节点的角度来看,只有当所有指定的槽位目前都没有分配时,该命令才会生效。节点将拒绝接受已经属于其他节点(包括自己)的槽位的所有权。</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">该命令还可使用以下选项返回附加信息:</target>
        </trans-unit>
        <trans-unit id="94c796162b217920f7fda542eef1c135d9fe60f2" translate="yes" xml:space="preserve">
          <source>The command output is an hexadecimal representation of a binary string. By default it emits 256 bits (so 64 hex characters). The user can provide an argument in form of number of bits to emit from 1 to 1024 to change the output length. Note that the number of bits provided is always rounded to the next multiple of 4. So for instance asking for just 1 bit password will result in 4 bits to be emitted, in the form of a single hex character.</source>
          <target state="translated">该命令的输出是一个二进制字符串的十六进制表示。默认情况下,输出256位(所以是64个十六进制字符),用户可以提供1到1024位的参数来改变输出长度。用户可以提供一个参数,从1到1024的比特数来改变输出长度。请注意,所提供的位数总是四舍五入到4的下一个倍数,因此,例如,只要求1位的密码,将导致4位以单个十六进制字符的形式被发出。</target>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">该命令将执行以下操作:</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">该命令提供了从指定主节点复制的副本节点的列表。该列表以&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;使用的相同格式提供（有关格式的说明，请参阅其文档）。</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">该命令将节点重新配置为指定主节点的副本。如果接收到该命令的节点是一个&lt;em&gt;空的master&lt;/em&gt;，则作为命令的副作用，该节点角色将从master更改为副本。</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">该命令返回11个字符的Geohash字符串,因此与Redis内部52位表示法相比,没有任何精度损失。返回的Geohash具有以下属性。</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">如果密钥存在但没有关联的过期时间，则命令返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">如果密钥不存在，则命令返回 &lt;code&gt;-2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="263f04bc6090861d15e393e44fe1a4d42bd2408e" translate="yes" xml:space="preserve">
          <source>The command returns a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; when used with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option and the key doesn't exist.</source>
          <target state="translated">与 &lt;code&gt;NOMKSTREAM&lt;/code&gt; 选项一起使用且该键不存在时，该命令将返回&lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">该命令以&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;的相同格式返回所有已成功声明的消息。但是，如果指定了 &lt;code&gt;JUSTID&lt;/code&gt; 选项，则仅报告消息ID，而不包括实际消息。</target>
        </trans-unit>
        <trans-unit id="d91929db6b639c8bbfadd32a8fc0bdbaccdfc27a" translate="yes" xml:space="preserve">
          <source>The command returns all the rules defined for an existing ACL user.</source>
          <target state="translated">该命令返回所有为现有ACL用户定义的规则。</target>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">该命令返回一个元素数组。第一个元素是实例的角色,是以下三个字符串之一。</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">该命令返回存储在联系节点中并散列到指定散列槽的键名称数组。通过 &lt;code&gt;count&lt;/code&gt; 参数指定要返回的最大密钥数，以便该API的用户可以批量处理密钥。</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">该命令返回一个结果数组：返回的数组的每个元素都是一个由两个元素组成的数组，其中两个元素包含键名和为该键报告的条目。报告的条目是完整流条目，具有ID以及所有字段和值的列表。保证以&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;添加字段和值的顺序来报告字段和值。</target>
        </trans-unit>
        <trans-unit id="59dca4232b984a49106f20180ccd68dd85cde434" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.</source>
          <target state="translated">该命令返回一个数组,其中每个元素是一个四元素数组,分别代表事件的名称、时间戳、最新和所有时间的延迟测量值。</target>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">该命令返回一个数组,其中每个元素是一个两元素数组,代表作为参数传递给命令的每个成员名称的经度和纬度(x,y)。</target>
        </trans-unit>
        <trans-unit id="c2da6177dc0df5d03aa7780c4ae1b3e2b3b664b6" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing the timestamp and the latency of the event.</source>
          <target state="translated">该命令返回一个数组,其中每个元素都是代表事件的时间戳和延迟的两个元素数组。</target>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">该命令返回一个数组,数组中的每个元素是作为参数传递给命令的每个成员名对应的Geohash。</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">该命令返回一个数组，每个条目是在同一位置给出的子命令的相应结果。 &lt;code&gt;OVERFLOW&lt;/code&gt; 子命令不算作产生答复。</target>
        </trans-unit>
        <trans-unit id="0d3fdeb1c470e8f290735d9f570986e08dde9291" translate="yes" xml:space="preserve">
          <source>The command returns an error when the &lt;code&gt;destination&lt;/code&gt; key already exists. The &lt;code&gt;REPLACE&lt;/code&gt; option removes the &lt;code&gt;destination&lt;/code&gt; key before copying the value to it.</source>
          <target state="translated">当 &lt;code&gt;destination&lt;/code&gt; 密钥已经存在时，该命令将返回错误。该 &lt;code&gt;REPLACE&lt;/code&gt; 选项删除 &lt;code&gt;destination&lt;/code&gt; 值复制到它之前的关键。</target>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">该命令根据不同的调用方式,以不同的格式返回数据,这一点在前面已经解释过。然而,回复总是一个项目数组。</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">该命令以与&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;相同的格式返回数据。</target>
        </trans-unit>
        <trans-unit id="f11ff6c087b294c263c888936947fb519a703574" translate="yes" xml:space="preserve">
          <source>The command returns information about the current client connection's use of the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt; feature.</source>
          <target state="translated">该命令返回有关当前客户端连接使用&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;服务器辅助客户端缓存&lt;/a&gt;功能的信息。</target>
        </trans-unit>
        <trans-unit id="a84d7525c4b51e3bbe67ae31259831e14b15be40" translate="yes" xml:space="preserve">
          <source>The command returns information and statistics about the current client connection in a mostly human readable format.</source>
          <target state="translated">该命令以大多数人可读的格式返回有关当前客户端连接的信息和统计数据。</target>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">该命令返回添加条目的ID。如果将 &lt;code&gt;*&lt;/code&gt; 作为ID参数传递给ID，则ID是自动生成的ID，否则该命令仅返回用户在插入过程中指定的ID。</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">该命令以双数(以字符串表示)形式返回指定单位的距离,如果缺少一个或两个元素,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">该命令返回ID匹配指定范围（从高ID到低ID）的条目。返回的条目是完整的，这意味着将返回ID及其组成的所有字段。此外，返回的条目及其字段和值的顺序与&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;添加它们的顺序完全相同。</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">该命令返回ID与指定范围匹配的条目。返回的条目是完整的，这意味着将返回ID及其组成的所有字段。此外，返回的条目及其字段和值的顺序与&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;添加它们的顺序完全相同。</target>
        </trans-unit>
        <trans-unit id="62939248d8e32365e6957d42055f2de89814a292" translate="yes" xml:space="preserve">
          <source>The command returns the index of matching elements inside a Redis list. By default, when no options are given, it will scan the list from head to tail, looking for the first match of &quot;element&quot;. If the element is found, its index (the zero-based position in the list) is returned. Otherwise, if no match is found, NULL is returned.</source>
          <target state="translated">该命令返回Redis列表中匹配元素的索引。默认情况下,当没有给定选项时,它将从头到尾扫描列表,寻找第一个匹配的 &quot;元素&quot;。如果找到了元素,就返回它的索引(列表中基于零的位置)。否则,如果没有找到匹配的元素,将返回NULL。</target>
        </trans-unit>
        <trans-unit id="f216246f788da7553b72042887561f848de4e55c" translate="yes" xml:space="preserve">
          <source>The command returns the integer representing the matching element, or null if there is no match. However, if the &lt;code&gt;COUNT&lt;/code&gt; option is given the command returns an array (empty if there are no matches).</source>
          <target state="translated">该命令返回表示匹配元素的整数；如果不匹配，则返回null。但是，如果指定了 &lt;code&gt;COUNT&lt;/code&gt; 选项，则该命令将返回一个数组（如果没有匹配项，则为空）。</target>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">该命令返回指定节点的&lt;em&gt;故障报告&lt;/em&gt;数。故障报告是Redis群集用于将 &lt;code&gt;PFAIL&lt;/code&gt; 状态（即节点不可访问）提升为 &lt;code&gt;FAIL&lt;/code&gt; 状态的方式，这意味着群集中的大多数主节点在一个时间窗内同意该节点未达到状态可达的。</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">该命令返回从流中删除的条目数。</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">该命令返回成功确认的报文数量。某些报文ID可能不再是PEL的一部分(例如,因为它们已经被确认了),XACK将不把它们算作成功确认。</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">该命令根据请求返回第一个位的位置,设置为1或0。</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">该命令将返回与给定 ID 范围相匹配的流条目。该范围由最小和最大ID指定。返回所有ID介于指定的两个ID之间的条目,或者正好是指定的两个ID中的一个(封闭区间)。</target>
        </trans-unit>
        <trans-unit id="383ccd477dc944e0c3ebd47dbea4b6b2017eb35b" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">该命令将返回与给定 ID 范围相匹配的流条目。该范围由最小和最大ID指定。返回所有ID介于指定的两个ID之间的条目,或者正好是指定的两个ID中的一个(封闭区间)。</target>
        </trans-unit>
        <trans-unit id="9be8f3674812a7bb5d9fb3101b17c38b3646405b" translate="yes" xml:space="preserve">
          <source>The command shows a list of all the usernames of the currently configured users in the Redis ACL system.</source>
          <target state="translated">该命令显示了Redis ACL系统中当前配置的所有用户的用户名列表。</target>
        </trans-unit>
        <trans-unit id="13c06047a0b602e177d71981a4d9e29349f77a37" translate="yes" xml:space="preserve">
          <source>The command shows a list of recent ACL security events:</source>
          <target state="translated">该命令显示最近的ACL安全事件列表。</target>
        </trans-unit>
        <trans-unit id="2382a9cd868ca3bdb3953efcef5f79ded0789a3c" translate="yes" xml:space="preserve">
          <source>The command shows the available ACL categories if called without arguments. If a category name is given, the command shows all the Redis commands in the specified category.</source>
          <target state="translated">如果调用该命令时没有参数,则显示可用的ACL类别。如果给定了类别名称,命令将显示指定类别中的所有Redis命令。</target>
        </trans-unit>
        <trans-unit id="724b74eeaa692174c50661ecd1cc035a30521473" translate="yes" xml:space="preserve">
          <source>The command shows the currently active ACL rules in the Redis server. Each line in the returned array defines a different user, and the format is the same used in the redis.conf file or the external ACL file, so you can cut and paste what is returned by the ACL LIST command directly inside a configuration file if you wish (but make sure to check &lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;).</source>
          <target state="translated">该命令显示Redis服务器中当前活动的ACL规则。返回数组中的每一行定义了一个不同的用户，并且格式与redis.conf文件或外部ACL文件中使用的格式相同，因此，如果出现以下情况，则可以将ACL LIST命令返回的内容直接剪切并粘贴到配置文件中：您希望的（但请确保选中&lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">该命令使用标准格式 x,y 作为参数,因此必须在纬度之前指定经度。可以索引的坐标有一定的限制:非常靠近两极的区域不能索引。EPSG:900913/EPSG:3785/OSGEO:41001 规定的确切限制如下:1:</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">这条命令将Redis字符串视为一个比特数组,能够处理不同位宽和任意非(必要)对齐偏移的特定整数字段。在实际操作中,使用这条命令可以将位偏移量为1234的5位有符号整数设置为一个特定的值,从偏移量4567中检索一个31位无符号整数。同样,该命令还可以处理指定整数的增量和减量,提供用户可以配置的有保证的、指定好的溢出和下溢行为。</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">如果指定的节点不知道,或者根据接收命令的节点表,它不是主节点,该命令将失败。</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">当用户试图在指定范围外编制坐标索引时,该命令将报告一个错误。</target>
        </trans-unit>
        <trans-unit id="c3184d09a508b5c6fdb922b8b826ae4f98d9a67a" translate="yes" xml:space="preserve">
          <source>The command will return up to 160 timestamp-latency pairs for the &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">该命令将为该 &lt;code&gt;event&lt;/code&gt; 返回多达160个时间戳-延迟对。</target>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">该命令及其子命令集的作用是为了启动和结束集群活态重arding操作,通过在源节点中设置迁移状态的哈希槽,以及在目的节点中导入状态来完成。</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">即使脚本已经存在于脚本缓存中,该命令也以同样的方式工作。</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">该命令的常见用例是检索指定点附近不超过给定米数(或其他单位)的地理空间项目。例如,这允许向应用程序的移动用户推荐附近的地方。</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">计算合并后的HyperLog被设置为目的变量,如果不存在,则创建目的变量(默认为空HyperLog)。</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">可以通过编辑 &lt;code&gt;redis.conf&lt;/code&gt; 或在服务器运行时使用&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt;和&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;命令来完成配置。</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;检查连接名称。</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">我们与服务器的连接是持久的,至今没有关闭过。</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">即使有活跃的消费者和待处理的消息,消费者组也会被销毁,所以一定要在真正需要的时候才调用这个命令。</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">消费者会做。</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">坐标为两个项目的x,y数组(经度,纬度)。</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">计数器的创建方式是,从当前秒内执行的第一个请求开始,它只能存活一秒。如果在同一秒内有超过10个请求,计数器将达到一个大于10的值,否则它将过期并从0开始。</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">计数器模式是您可以对Redis原子增量操作执行的最明显的操作。这个想法只是在每次操作发生时将&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;命令发送到Redis。例如，在Web应用程序中，我们可能想知道该用户一年中每天的浏览量。</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">崩溃的客户端C3仍然保留它，因此Redis将以 &lt;code&gt;0&lt;/code&gt; 答复C4。</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">当前字段内容或指定的增量不能解析为双精度浮点数。</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">当前键的内容或指定的增量不能解析为双精度浮点数。</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">当前主站复制偏移量,这个偏移量是主站和复制机共享的,在部分重新同步中,可以了解复制机需要取回复制流的哪一部分才能继续。</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">可以使用&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;命令检索元素的当前分数，该分数也可以用于验证元素是否已经存在。</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">前次调用SCAN返回的游标,以便继续迭代。</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">开始迭代时光标值为0。</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">默认的COUNT值是10。</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">交货计数器，即阵列中的第四元件，当一些其他消费递增&lt;em&gt;声称&lt;/em&gt;与消息&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;时，或者当消息通过再次递送&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;，在消费者组访问消费者的历史时（见&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;页面以获取更多信息）。</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">此命令与&lt;a href=&quot;xread&quot;&gt;原始XREAD&lt;/a&gt;之间的区别在于，该命令支持使用者组。</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">离中心的距离是一个浮点数,单位与半径相同。</target>
        </trans-unit>
        <trans-unit id="e1121b0e8297b7fecce16b935b4718ce15930933" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the shape.</source>
          <target state="translated">形状中指定的单位,以浮点数形式表示与中心的距离。</target>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">计算距离时假设地球是一个完美的球体,所以在边缘情况下,误差可能达到0.5%。</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">当集合中的元素数量较少时,返回元素的分布远非完美,这是由于我们使用了一个近似的随机元素函数,并不能真正保证良好的分布。</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">与使用 &lt;code&gt;memcmp()&lt;/code&gt; C函数逐字节比较相比，这些元素被认为是从低到高的字符串排序。如果公共部分相同，则较长的字符串被认为大于较短的字符串。</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">具有相同分数的元素按词法顺序返回(这源于Redis中排序集实现的一个属性,不涉及进一步计算)。</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">具有相同分数的元素按词法顺序反向返回。</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">为了避免多次处理慢速日志条目,可以使用条目的唯一ID(例如,您可能有一个脚本为每个新的慢速日志条目发送电子邮件提醒)。</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">此命令的确切行为与&lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt;命令之一相同，请参阅&lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt;的文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">事实上,用户可以指望Redis不删除脚本,这在管道化的语义上是有用的。</target>
        </trans-unit>
        <trans-unit id="a0c00c319cfd875c00a2280921682c92066dd97a" translate="yes" xml:space="preserve">
          <source>The feature will remain active in the current connection for all its life, unless tracking is turned on with &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; at some point.</source>
          <target state="translated">除非在某些时候 &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; 了CLIENT TRACKING的情况下打开了跟踪功能，否则该功能将在当前连接中一直保持活动状态。</target>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">该字段包含一个错误类型的值(不是字符串)。</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">文件描述符事件可以是:</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;的第一个参数是Lua 5.1脚本。该脚本不需要定义Lua函数（也应该没有）。它只是一个Lua程序，将在Redis服务器的上下文中运行。</target>
        </trans-unit>
        <trans-unit id="46870f99efa0c3b2959dcb93e1e13013212f023d" translate="yes" xml:space="preserve">
          <source>The first argument of the command selects the algorithm to use, right now the argument must be &quot;LCS&quot;, since this is the only implemented one.</source>
          <target state="translated">命令的第一个参数选择要使用的算法,现在这个参数必须是 &quot;LCS&quot;,因为这是唯一实现的算法。</target>
        </trans-unit>
        <trans-unit id="647fb34e5b11b941bb5e49ce5d7abfd78a858447" translate="yes" xml:space="preserve">
          <source>The first case will return the first 10 (or less) PEL entries of the entire group that are idle for over 9 seconds, whereas in the second case only those of &lt;code&gt;consumer-123&lt;/code&gt;.</source>
          <target state="translated">第一种情况将返回整个组中闲置超过9秒的前10个（或更少）PEL条目，而第二种情况仅返回 &lt;code&gt;consumer-123&lt;/code&gt; 的那些条目。</target>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">以下是几个导入和迁移槽的例子。</target>
        </trans-unit>
        <trans-unit id="6c3d5dc29a069636be48f90bb368850ce3fda788" translate="yes" xml:space="preserve">
          <source>The following are the list of options that modify the behavior of the command when enabling tracking:</source>
          <target state="translated">以下是启用跟踪时修改命令行为的选项列表。</target>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">以下命令从接收命令的节点中删除插槽5000和5001的关联。</target>
        </trans-unit>
        <trans-unit id="784815ebd70c0fe925bcd60bddc497d55949fa3a" translate="yes" xml:space="preserve">
          <source>The following documentation is a reference manual about the capabilities of this command, however our &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL tutorial&lt;/a&gt; may be a more gentle introduction to how the ACL system works in general.</source>
          <target state="translated">以下文档是有关此命令功能的参考手册，但是，我们的&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL教程&lt;/a&gt;可能更全面地介绍了ACL系统的工作方式。</target>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">下面的例子应该能说明上面所说的问题。</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">以下使用 &lt;code&gt;WITHSCORES&lt;/code&gt; 的示例显示了命令如何始终返回数组，但是这次填充了&lt;em&gt;element_1&lt;/em&gt;，&lt;em&gt;score_1&lt;/em&gt;，&lt;em&gt;element_2&lt;/em&gt;，&lt;em&gt;score_2&lt;/em&gt;，...，&lt;em&gt;element_N&lt;/em&gt;，&lt;em&gt;score_N&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">始终提供以下字段:</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">以下是 &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; 返回NULL 的示例。</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">以下是支持的命令列表。</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">不鼓励使用以下模式来支持&lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;Redlock算法&lt;/a&gt;，该算法实现起来稍微复杂一些，但是提供了更好的保证，并且具有容错能力。</target>
        </trans-unit>
        <trans-unit id="8e9fc798f24c122b5b0b23c06739d7c4c95610dd" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">不鼓励使用以下模式来支持&lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;Redlock算法&lt;/a&gt;，该算法实现起来稍微复杂一些，但是提供了更好的保证，并且具有容错能力。</target>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE 形式将停止复制，将服务器转变为MASTER，但不会放弃复制。因此，如果旧的母版停止工作，则可以将副本变成母版，并将应用程序设置为以读/写方式使用新的母版。稍后在修复其他Redis服务器后，可以将其重新配置为副本服务器。</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE 形式将停止复制，将服务器转变为MASTER，但不会放弃复制。因此，如果旧的母版停止工作，则可以将副本变成母版，并将应用程序设置为以读/写方式使用新的母版。稍后在修复其他Redis服务器后，可以将其重新配置为副本服务器。</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">该函数通过将结果的范围限制为字符串的实际长度来处理超出范围的请求。</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">如果启用了脚本效果复制,该函数返回true,否则如果在脚本已经调用了某个写命令之后调用该函数,则返回false,使用正常的整个脚本复制。</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">的gehash整数。</target>
        </trans-unit>
        <trans-unit id="a74105f90399289d271dac87ebbc775e37f16a9d" translate="yes" xml:space="preserve">
          <source>The graph is normalized in the min-max scale so that the zero (the underscore in the lower row) is the minimum, and a # in the higher row is the maximum.</source>
          <target state="translated">该图在最小-最大的范围内进行了归一化处理,因此0(下行的下划线)是最小值,而高行的#是最大值。</target>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">组名称只是与该流关联的使用者组的名称。该组是使用&lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt;命令创建的。使用者名称是客户端在组内用来标识自身的字符串。第一次看到消费者时，将在消费者组内部自动创建该消费者。不同的客户应选择不同的消费者名称。</target>
        </trans-unit>
        <trans-unit id="9501214421f828fe1bcfe6cfb269ae7881da1706" translate="yes" xml:space="preserve">
          <source>The id of the client.</source>
          <target state="translated">客户的ID。</target>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">有关内存使用情况的信息以指标及其各自的数值提供。报告的指标如下:</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">该键包含一个错误类型的值(不是字符串)。</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">钥匙可能在两个实例上。</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">钥匙可能只在源实例中。</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">可以使用&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;和&lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt;命令（或其他严格相关的命令）来更新或完全删除关键的生存时间。</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">返回的最后一个ID是 &lt;code&gt;1526985712947-0&lt;/code&gt; ，因为序列号已经为零，所以我将代替 &lt;code&gt;+&lt;/code&gt; 特殊ID 使用的下一个ID将是 &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; 或 &lt;code&gt;18446744073709551615&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">最后一个参数是流中最后一个项目的ID,认为已经交付。在上面的例子中,我们使用了特殊的ID'$'(这意味着:流中最后一个项目的ID)。在这种情况下,从该消费者组中获取数据的消费者将只看到流中到达的新元素。</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">最后一个示例显示了如何从Lua 接收 &lt;code&gt;redis.call()&lt;/code&gt; 或 &lt;code&gt;redis.pcall()&lt;/code&gt; 的确切返回值，如果直接调用该命令将返回该值。</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">所使用的词法排序是二进制的,它将字符串作为字节数组进行比较。</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">这种模式的局限性在于,我们被迫进入了只进行追加的操作模式,没有办法轻松地将时间序列切割成给定的大小,因为Redis目前缺乏一个能够修剪字符串对象的命令。然而以这种方式存储的时间序列的空间效率是非常显著的。</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">可以通过发出 &lt;code&gt;CONFIG GET *&lt;/code&gt; 命令来获取&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;支持的配置参数列表，该命令是用于获取有关正在运行的Redis实例的配置信息的对称命令。</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">达到过期时间后,锁会自动解除。</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">&lt;em&gt;整个脚本复制&lt;/em&gt;方法的主要缺点是要求脚本具有以下属性：</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">该命令的主要用法是在将群集插槽从一个节点重新哈希到另一个节点的过程中。重做的方式在Redis Cluster规范中公开，或者以更简单的摘要形式作为&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt;命令文档的附录公开。</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">主输出由下列部分组成:</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">主服务器以当前&lt;em&gt;复制偏移量&lt;/em&gt;回复副本。</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 的含义与&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;命令相同。同样，此命令实际上返回与&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;使用相同的 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 参数调用时将返回的元素相同的元素。</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">各个档案的含义如下:</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">Redis规范中解释了这两种状态的含义,然而这两种状态的要点如下。</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">这种模式更简单直接的实现方式是以下。</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">这个命令的动机是,能够将许多小的整数存储为一个大的位图(或者在几个键上进行分割,以避免拥有巨大的键),这对内存的效率是非常高的,并且为Redis开辟了新的应用用例,特别是在实时分析领域。这种用例通过以可控的方式指定溢出的能力得到了支持。</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">提取消息并仍要确认的消费者的姓名。我们称其为邮件的当前&lt;em&gt;所有者&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">新的配置会被持久化在磁盘上的节点集群配置文件中。</target>
        </trans-unit>
        <trans-unit id="ce3fd26b48bfdbc550ce60034f680213e04e3fa5" translate="yes" xml:space="preserve">
          <source>The new format:</source>
          <target state="translated">新格式。</target>
        </trans-unit>
        <trans-unit id="69cbd0fd1035f94debad3eb8086987173fc0e180" translate="yes" xml:space="preserve">
          <source>The new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number) represented as string, or &lt;code&gt;nil&lt;/code&gt; if the operation was aborted (when called with either the &lt;code&gt;XX&lt;/code&gt; or the &lt;code&gt;NX&lt;/code&gt; option).</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; 的新分数（双精度浮点数）表示为字符串，如果操作中止（使用 &lt;code&gt;XX&lt;/code&gt; 或 &lt;code&gt;NX&lt;/code&gt; 选项调用时），则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">节点ID标识了我们要发送命令的同一个节点。</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">被删除的节点ID会被添加到禁止列表中,持续1分钟。</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">节点当前&lt;em&gt;配置时期&lt;/em&gt;为零。</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">节点为空,键空间中根本没有存储键。</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">该节点没有为任何哈希槽服务。</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">接收该命令的节点是一个副本,指定的节点ID标识其当前的主节点。</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">节点在处理从其他节点接收到的心跳包中的八卦部分时,将跳过ban-list中列出的所有节点ID。</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">节点的节点表为空。</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">设置为1的位数。</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">添加到排序集的元素数量,不包括更新分数的已有元素。</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">添加到排序集合中的元素数量,不包括更新分数的已有元素。</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">作为参数指定的键的数量。多次提到的钥匙和现有的钥匙被多次计算。</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">从排序集合中删除的成员数,不包括非现有成员。</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">自上次向该消费者发送此信息后所经过的毫秒数。</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">可以使用 &lt;code&gt;LIMIT&lt;/code&gt; 修饰符限制返回元素的数量。此修饰符采用 &lt;code&gt;offset&lt;/code&gt; 参数，指定要跳过的元素数，以及 &lt;code&gt;count&lt;/code&gt; 参数，指定要从 &lt;code&gt;offset&lt;/code&gt; 开始返回的元素数。以下示例将返回 &lt;code&gt;mylist&lt;/code&gt; 排序版本的10个元素，从元素0开始（ &lt;code&gt;offset&lt;/code&gt; 从零开始）：</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">此信息的发送次数。</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">老主站收到配置更新:解锁其客户端,并开始回复重定向消息,这样他们就会继续和新主站聊天。</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">唯一有效使用的光标是:</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">刷新脚本缓存的唯一方法是显式调用&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;命令，该命令将&lt;em&gt;完全刷新&lt;/em&gt;脚本缓存，从而删除到目前为止已执行的所有脚本。</target>
        </trans-unit>
        <trans-unit id="851a4dff1ddadeea08eb160100034cb226114c6d" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). A negative &lt;code&gt;count&lt;/code&gt; returns all elements from the &lt;code&gt;offset&lt;/code&gt;. Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">可选的 &lt;code&gt;LIMIT&lt;/code&gt; 参数只能用于获取匹配元素的范围（类似于&lt;em&gt;SELECT LIMIT偏移量，&lt;/em&gt;在SQL中为&lt;em&gt;count&lt;/em&gt;）。负 &lt;code&gt;count&lt;/code&gt; 将返回 &lt;code&gt;offset&lt;/code&gt; 中的所有元素。请记住，如果 &lt;code&gt;offset&lt;/code&gt; 很大，则在遍历 &lt;code&gt;offset&lt;/code&gt; 元素之前需要遍历排序后的集合，然后再返回元素，这可能会增加O（N）的时间复杂度。</target>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">可选的 &lt;code&gt;LIMIT&lt;/code&gt; 参数只能用于获取一定范围的匹配元素（类似于&lt;em&gt;SELECT LIMIT偏移量，&lt;/em&gt;在SQL中为&lt;em&gt;count&lt;/em&gt;）。请记住，如果 &lt;code&gt;offset&lt;/code&gt; 很大，则在遍历 &lt;code&gt;offset&lt;/code&gt; 元素之前需要遍历排序集，然后再返回元素，这可能会增加O（N）的时间复杂度。</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">可选的 &lt;code&gt;WITHSCORES&lt;/code&gt; 参数使命令返回元素及其分数，而不是单独返回元素。从Redis 2.0开始，此选项可用。</target>
        </trans-unit>
        <trans-unit id="0f54b06c2148c9b6919787651cb0104f905c8131" translate="yes" xml:space="preserve">
          <source>The optional argument specifies how many entries to show. By default up to ten failures are returned. The special &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; argument clears the log. Entries are displayed starting from the most recent.</source>
          <target state="translated">可选参数指定要显示的条目数。默认情况下，最多返回十个故障。特殊的&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;参数清除日志。从最近开始显示条目。</target>
        </trans-unit>
        <trans-unit id="50b302b8ebe5d4f766a30687aa495211b0a41cc8" translate="yes" xml:space="preserve">
          <source>The optional arguments and options can modify the command's behavior. The &lt;code&gt;RANK&lt;/code&gt; option specifies the &quot;rank&quot; of the first element to return, in case there are multiple matches. A rank of 1 means to return the first match, 2 to return the second match, and so forth.</source>
          <target state="translated">可选参数和选项可以修改命令的行为。该 &lt;code&gt;RANK&lt;/code&gt; 选项指定的第一个元素的&amp;ldquo;等级&amp;rdquo;，以回报，如果有多个匹配。等级1表示返回第一个比赛，等级2表示返回第二个比赛，依此类推。</target>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">该可选参数可用于选择特定的信息部分。</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">步骤1和2的顺序很重要。当源节点配置为重定向时，我们希望目标节点准备好接受 &lt;code&gt;ASK&lt;/code&gt; 重定向。</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">该命令的输出只是一个以空格分隔的CSV字符串,其中每一行代表集群中的一个节点。下面是一个输出的例子。</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">主站的端口号。</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">返回位置,将字符串视为一个从左到右的比特数组,其中第一个字节的最重要的位在0位,第二个字节的最重要的位在8位,以此类推。</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">指定成员的位置作为查询的中心。</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">无论实际的内部计算精度如何,输出的精度都固定为小数点后17位。</target>
        </trans-unit>
        <trans-unit id="77e23fa703efecfb1c5bf352cb4f0529fa3a9d39" translate="yes" xml:space="preserve">
          <source>The query's center point is provided by one of these mandatory options:</source>
          <target state="translated">查询的中心点由这些强制选项之一提供。</target>
        </trans-unit>
        <trans-unit id="b1e2a1f42bcb6a5e4c6e642aa88cfced9dff68d3" translate="yes" xml:space="preserve">
          <source>The query's shape is provided by one of these mandatory options:</source>
          <target state="translated">查询的形状由这些强制选项之一提供。</target>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">半径以下列单位之一指定:</target>
        </trans-unit>
        <trans-unit id="5d69c6f303471181769a8ce1e67050c18c180806" translate="yes" xml:space="preserve">
          <source>The range is close (inclusive) by default, meaning that the reply can include entries with IDs matching the query's start and end intervals. It is possible to specify an open interval (exclusive) by prefixing the ID with the character &lt;code&gt;(&lt;/code&gt;. This is useful for iterating the stream, as explained below.</source>
          <target state="translated">默认情况下，范围是紧密的（包括），这意味着答复中可以包含ID与查询的开始和结束间隔匹配的条目。可以通过在ID前面加上字符 &lt;code&gt;(&lt;/code&gt; 。来指定打开间隔（不包括）。这对于迭代流很有用，如下所述。</target>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt;支持的值范围限制为64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">速率限制器模式是一个特殊的计数器,用于限制操作的执行速率。这种模式的经典具体化涉及限制对公共 API 的请求数量。</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">原因是发送一个脚本到另一个Redis实例往往比发送脚本产生的多个命令要快得多,所以如果客户端向主站发送许多脚本,将脚本转换为复制本/AOF的单个命令会导致复制链路或Append Only File的带宽过高(同时也会导致CPU过高,因为对Redis来说,调度一个通过网络接收的命令与调度一个由Lua脚本调用的命令相比,工作量更大)。</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">脚本之所以可以长期缓存,是因为一个写得很好的应用程序不可能有足够多的不同脚本来导致内存问题。每一个脚本在概念上就像一个新命令的实现,即使是一个大型的应用程序,也可能只有几百个脚本。即使应用程序被修改了很多次,脚本也会发生变化,所使用的内存也可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">副本输出由以下几部分组成。</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">复制器启动故障切换,从大多数主站获取新的配置时间,并广播新配置。</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">复制品告诉主站停止处理客户端的查询。</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">副本等待复制偏移量在其一侧匹配,以确保它处理了来自主站的所有数据,然后才继续。</target>
        </trans-unit>
        <trans-unit id="71f9285cf89c4539aedf2939b67fe3ee74695f78" translate="yes" xml:space="preserve">
          <source>The reply format is identical to that of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;, and the content consists only of information about the current client.</source>
          <target state="translated">答复格式与&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;相同，并且内容仅包含有关当前客户端的信息。</target>
        </trans-unit>
        <trans-unit id="7c6d847d0bceaf13a4c9effd31564050074fa753" translate="yes" xml:space="preserve">
          <source>The reported information contains all of the fields reported by the simple form of &lt;code&gt;XINFO STREAM&lt;/code&gt;, with some additional information:</source>
          <target state="translated">报告的信息包含 &lt;code&gt;XINFO STREAM&lt;/code&gt; 的简单形式报告的所有字段，以及一些其他信息：</target>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">报告的使用量是一个键及其值所需的数据和管理开销的内存分配总量。</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">从处理器字的大小和endianness的角度来看,这种表示方式是中性的,所以32位和64位处理器使用的表示方式是一样的,大endian或小endian。</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">&lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt;使用的表示将位图视为具有第0个字节的最高位，依此类推，因此，例如，将5位无符号整数设置为偏移量7处的值23，将其设置为先前设置为全零，将产生以下表示：</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">操作结果始终存储在 &lt;code&gt;destkey&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">命令的返回类型是&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">返回的观察集的cardinality不是精确的,而是近似的,标准误差为0.81%。</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">改写的方式是非常保守的。</target>
        </trans-unit>
        <trans-unit id="3d4aef252f6710693b627be68f7b05c7734609ba" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence.</source>
          <target state="translated">只有当没有一个后台进程在做持久化的时候,Redis才会触发重写。</target>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">只有在还没有后台进程做持久化的情况下,重写才会被Redis触发。具体来说。</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt;和&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;遵循相同的位位置约定。</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">对于不存在的密钥也是如此,它被认为是一个零字节的流,长度不超过最长的字符串。</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">保存参数是一串以空格分隔的整数。每一对整数代表一个秒/修改阈值。</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">得分值应为双精度浮点数的字符串表示形式。 &lt;code&gt;+inf&lt;/code&gt; 和 &lt;code&gt;-inf&lt;/code&gt; 值也是有效值。</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">保证脚本永远保留在脚本缓存中（除非调用了 &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">在给定相同输入数据集的情况下，脚本必须始终使用相同的参数评估相同的Redis &lt;em&gt;写入&lt;/em&gt;命令。脚本执行的操作不能依赖于任何隐藏的（非显式）信息或状态，这些信息或状态可能随着脚本执行的进行或脚本的不同执行之间的变化而改变，也不能依赖于I / O设备的任何外部输入。</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">该脚本应使用 &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt; 来调用</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;的第二个参数是表示Redis键名的脚本后的参数数量（从第三个参数开始）。Lua可以使用 &lt;code&gt;KEYS&lt;/code&gt; 全局变量以基于一个的数组形式访问参数（因此 &lt;code&gt;KEYS[1]&lt;/code&gt; ， &lt;code&gt;KEYS[2]&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">补丁级版本之间的语义变化是需要的,因为旧的行为本身就与Redis复制层不兼容,而且是导致bug的原因。</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">哨兵输出由以下部分组成。</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">序列化格式是不透明的、非标准的,然而它有一些语义特征。</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">序列化的值不包含过期信息。为了捕获当前值的生存时间，应使用&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">存储在目标键中的字符串的大小,等于最长的输入字符串的大小。</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">慢速日志存储在内存中，因此不会写入有关慢速命令执行信息的文件。这样一来，慢速日志就非常快了，因为您可以启用所有命令的日志记录（将&lt;em&gt;slowlog-log-slower-than-&lt;/em&gt; config参数设置为零），而对性能的影响不大。</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">稀疏表示法使用一个运行长度的编码,优化后可以有效地存储大量设置为零的寄存器。密集表示是一个12288字节的Redis字符串,以便存储16384个6位计数器。双表示法的必要性来自于使用12k(这是密集表示法的内存要求)来对较小卡数的几个寄存器进行编码是极其次优的。</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">特殊的 &lt;code&gt;$&lt;/code&gt; ID。</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">特殊 &lt;code&gt;&amp;gt;&lt;/code&gt; ID，这意味着使用者只想接收&lt;em&gt;从未传递给任何其他使用者的消息&lt;/em&gt;。这只是意味着，给我新消息。</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">指定的节点ID并不能识别我们要发送命令的实例。</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">指定的节点ID存在于其节点表中。</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">指定的节点ID是一个主节点。</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">在节点表中找不到指定的节点ID。</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">指定的节点会从节点表中删除。</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">从主服务器的角度来看，复制状态可以 &lt;code&gt;connect&lt;/code&gt; （实例需要连接到其主服务器），正在 &lt;code&gt;connecting&lt;/code&gt; （主副本服务器正在进行中）， &lt;code&gt;sync&lt;/code&gt; （主服务器和副本正在尝试进行复制）执行同步），已 &lt;code&gt;connected&lt;/code&gt; （副本在线）。</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">字符串 &lt;code&gt;-&amp;gt;&lt;/code&gt; 用于将键名与哈希字段名分开。如上文所述替换键，并访问存储在结果键处的哈希以检索指定的哈希字段。</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;sentinel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">字符串 &lt;code&gt;slave&lt;/code&gt; ，因为具有向后兼容性（请参阅本页尾的注释）。</target>
        </trans-unit>
        <trans-unit id="6831b1a65326ef3cc261059e475703f978f1b6bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatibility (see note at the end of this page).</source>
          <target state="translated">字符串 &lt;code&gt;slave&lt;/code&gt; ，因为向后兼容（请参阅本页尾的注释）。</target>
        </trans-unit>
        <trans-unit id="a409de83f682db65c898664c9dbb138b1160b8f1" translate="yes" xml:space="preserve">
          <source>The summary provides a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">该摘要提供了很好的概述，但有时我们对这些细节感兴趣。为了查看所有具有更多相关信息的待处理消息，我们还需要传递一个ID范围，以类似的方式，我们使用&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;和一个非可选的&lt;em&gt;count&lt;/em&gt;参数来完成此操作，以限制每次调用返回的消息数：</target>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">支持的类型是有符号整数最多64位,无符号整数最多63位。对无符号整数的限制是由于目前Redis协议无法返回64位无符号整数作为回复。</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">用于在运行时更改配置的对称命令为 &lt;code&gt;CONFIG SET&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">系统管理员发送&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;命令来强制一个节点与另一个节点相遇。</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">第三次嵌套回复保证是该槽位范围的主控实例的IP/端口对。第三次嵌套回复之后的所有IP/端口对都是主控实例的复制。</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">该操作的时间复杂度为O(N),N为所有现有数据库中的键数。</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">该操作的时间复杂度为O(N),N为数据库中键的数量。</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">也可以使用&lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt;命令清除超时，将密钥变回永久密钥。</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">超时指定与目标实例通信的任何时刻的最大空闲时间,单位为毫秒。这意味着操作不需要在指定的毫秒内完成,但传输应在不阻塞超过指定毫秒的情况下进行。</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">只有删除或覆盖键内容的命令（包括&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;，&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;，&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;和所有 &lt;code&gt;*STORE&lt;/code&gt; 命令）才能清除超时。这意味着所有在概念上&lt;em&gt;更改&lt;/em&gt;键中存储的值而不用新键替换的操作都将保持超时不变。举例来说，增加一键的值&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;，推新值的列表，包括&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;，或改变了哈希的字段值&lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt;是将离开超时不变的所有操作。</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">单位必须是以下之一,默认为米。</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">处理日志命令的unix时间戳。</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">用户刚刚开启了AOF,服务器为了创建初始AOF文件,触发了第一次AOF重写。在这种情况下,停止将导致数据集完全丢失:一旦重新启动,服务器将有可能在没有任何AOF文件的情况下启用AOF。</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">用户应注意，如果在参数中多次提及相同的现有密钥，则会对其进行多次计数。因此，如果 &lt;code&gt;somekey&lt;/code&gt; 存在，则 &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; 将返回2。</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">用户应注意,该命令的单键和多键执行在语义上是不同的,性能也不同。</target>
        </trans-unit>
        <trans-unit id="aee2053c45b6ced184922e49824bb87ce4f26e87" translate="yes" xml:space="preserve">
          <source>The vertical labels under each graph column represent the amount of seconds, minutes, hours or days ago the event happened. For example &quot;15s&quot; means that the first graphed event happened 15 seconds ago.</source>
          <target state="translated">每个图表列下的垂直标签代表事件发生的秒、分、小时或天数。例如,&quot;15s &quot;表示第一个图表事件发生在15秒前。</target>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">排序集的填充方法是使用称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;的技术。纬度和经度位交织在一起，以形成唯一的52位整数。我们知道排序的双精度得分可以代表52位整数而不会丢失精度。</target>
        </trans-unit>
        <trans-unit id="7b31bb2e561758eaef35a12c00599f8b3a9ccbe4" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call as an exclusive interval.</source>
          <target state="translated">然后，我们不再使用 &lt;code&gt;-&lt;/code&gt; 来重新开始迭代，而是使用&lt;em&gt;上&lt;/em&gt;一个&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;调用返回的&lt;em&gt;最后一个&lt;/em&gt;条目的条目ID作为范围的开始，作为范围的开始。</target>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">然后，我们不再使用 &lt;code&gt;-&lt;/code&gt; 来重新开始迭代，而是使用&lt;em&gt;上&lt;/em&gt;一个&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;调用返回的&lt;em&gt;最后一个&lt;/em&gt;条目的条目ID作为范围的起点，将ID 的序列部分加1。</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">然后突然间,这个消费者就永远失败了。</target>
        </trans-unit>
        <trans-unit id="c54ead856d23cc39661d8102bdb6330ddb30ed3d" translate="yes" xml:space="preserve">
          <source>Then we may want to know what commands are part of a given category:</source>
          <target state="translated">那么我们可能想知道哪些命令属于某个类别。</target>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">还有一些可选的字段只有Redis 4.0或更高版本才会发出。</target>
        </trans-unit>
        <trans-unit id="a381e0a250a57263ea1da7d6465921f290bc2868" translate="yes" xml:space="preserve">
          <source>There are cases when you need to set all the bits of single bitmap at once, for example when initializing it to a default non-zero value. It is possible to do this with multiple calls to the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command, one for each bit that needs to be set. However, so as an optimization you can use a single &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to set the entire bitmap.</source>
          <target state="translated">在某些情况下，您需要一次设置单个位图的所有位，例如，将其初始化为默认的非零值时。可以通过多次调用&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;命令来做到这一点，每个需要设置的位一次。但是，作为一种优化，您可以使用单个&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令来设置整个位图。</target>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">在某些情况下，我们只想尽快终止Redis实例，无论其内容是什么。在这种情况下，正确的命令组合是发送&lt;strong&gt;CONFIG appendonly no，&lt;/strong&gt;然后发送&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;。如果需要，第一个命令将关闭AOF，如果有一个活动的，它将终止AOF重写子级。由于不再启用AOF，因此第二个命令将不会有任何执行问题。</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">有多个客户端轮换列表:它们会获取不同的元素,直到列表中的所有元素都被访问,然后重新启动这个过程。</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">在有些情况下,这还不够,我们希望一个副本能够在不与集群的其他部分达成任何协议的情况下进行故障转移。现实世界中的一个用例是,当所有的主站都宕机或分区时,为了执行数据中心切换,将不同数据中心的复制体大规模推广到主站。</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">有的时候,一个列表可以在同一个概念命令的上下文中接收多个元素。</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">有两个辅助函数可以从Lua中返回Redis类型。</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">有两种方法可以在bitfield命令中指定偏移量。如果指定了一个没有任何前缀的数字,它就会被用作字符串中基于零的位偏移。</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">有&lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;没有简单的方法有lua阵内尼尔斯&lt;/a&gt;，这是的Lua表语义的结果，所以当Redis的一个Lua阵列转换成Redis的协议如果遇到零的转换停止。</target>
        </trans-unit>
        <trans-unit id="b1c93389b4b0093ccfd4821330160b8a97df2879" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;https://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">有&lt;a href=&quot;https://www.lua.org/pil/19.1.html&quot;&gt;没有简单的方法有lua阵内尼尔斯&lt;/a&gt;，这是的Lua表语义的结果，所以当Redis的一个Lua阵列转换成Redis的协议如果遇到零的转换停止。</target>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">有一种不同的方法来解决这个问题,而不使用脚本,但使用Redis列表而不是计数器。这种实现比较复杂,使用的功能也比较先进,但它的优点是可以记住当前执行API调用的客户端的IP地址,根据应用的不同,这种方法可能有用,也可能没用。</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">有一个流,有一个相关的消费群体。</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">还有一个额外的Lua到Redis的转换规则,没有对应的Redis到Lua的转换规则。</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">还有另一个子命令只能通过设置溢出行为来更改连续&lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt;子命令调用的行为：</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">使用帮助函数或直接返回指定格式的表没有区别,所以下面两种形式是等价的。</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">无法保证它实际上是较高的配置时期，因为例如，我们可以在少数群体中使用&lt;strong&gt;TAKEOVER&lt;/strong&gt;选项，也不执行任何消息交换来生成新的配置时期。</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">如果不是Redis字符串类型的常规限制（512 MB），则可以分配的名称长度没有限制。但是，在连接名称中不能使用空格，因为这会违反&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;答复的格式。</target>
        </trans-unit>
        <trans-unit id="939fac74be0ef5905e18fc0965563dbdb047a83f" translate="yes" xml:space="preserve">
          <source>There is one key thing to understand: in case Lua replies with RESP3 types, but the connection calling Lua is in RESP2 mode, Redis will automatically convert the RESP3 protocol to RESP2 compatible protocol, as it happens for normal commands. For instance returning a map type to a connection in RESP2 mode will have the effect of returning a flat array of fields and values.</source>
          <target state="translated">有一个关键的事情需要理解:如果Lua用RESP3类型回复,但调用Lua的连接处于RESP2模式,Redis会自动将RESP3协议转换为RESP2兼容协议,就像普通命令一样。例如向RESP2模式下的连接返回一个map类型,效果是返回一个字段和值的平面数组。</target>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">这些都是重置的计数器。</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">这些字节目前是纯粹的开销,因为没有存储实际数据,用于维护服务器的内部数据结构。较长的键和值呈现渐进线性使用。</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">这些偏移量也可以是负数，表示从列表末尾开始的偏移量。例如， &lt;code&gt;-1&lt;/code&gt; 是列表的最后一个元素， &lt;code&gt;-2&lt;/code&gt; 是倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">这些前提条件是需要的,因为通常情况下,手动改变一个节点的配置纪元是不安全的,我们要确保配置纪元值较高的节点(也就是最后一个失败的节点)在申请哈希槽所有权时胜过其他节点。</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">它们可以被缩短,从右边删除字符。这将失去精确性,但仍将指向同一区域。</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">它们直接对应于正常的Redis日志级别。只有使用等于或大于当前配置的Redis实例日志级别的脚本发出的日志才会被发出。</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">诸如使用系统时间，调用Redis随机命令（例如&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;）或使用Lua随机数生成器之类的事情，都可能导致脚本生成的结果并不总是相同。</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">在Lua脚本中,我们执行两个集合之间的交集。选取五个随机元素,然后用这五个随机元素创建一个新的集合。最后我们删除代表两个原始集合之间交集的临时键。我们要复制的只是用这五个元素创建新的集合。同时复制创建临时键的命令是没有用的。</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">这就避免了客户端在过期后试图释放锁,删除另一个客户端创建的钥匙,后来获得的锁。</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">对于某些我们需要更可靠的消息传递系统的应用程序来说，这可能是个问题。在这种情况下，请检查&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;命令，它是&lt;a href=&quot;blpop&quot;&gt;BLPOP的&lt;/a&gt;一种变体，在将返回的元素返回到客户端之前，将其添加到目标列表中。</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">可以轻松解决此问题，将带有可选&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;的&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;转换为使用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;命令发送的Lua脚本（仅从Redis 2.6版开始可用）。</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">此命令接受一个或多个SHA1摘要，并返回一个1或0的列表，以信号指示脚本是否已在脚本缓存中定义。这在执行流水线操作之前非常有用，以确保加载脚本（如果没有加载脚本，则可以使用&lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;加载脚本），以便仅使用&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;而不是&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;即可执行流水线操作以节省带宽。</target>
        </trans-unit>
        <trans-unit id="dcfeceb3df3a9d1203f8df4602183697ddf7897a" translate="yes" xml:space="preserve">
          <source>This command accepts two non mandatory options:</source>
          <target state="translated">该命令接受两个非强制性选项。</target>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">该命令阻止当前客户机,直到所有之前的写命令被成功传输,并被至少指定数量的副本确认。如果达到以毫秒为单位指定的超时时间,即使尚未达到指定数量的副本,该命令也会返回。</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">如果要从多个键中同时读取，则可以使用多个流调用此命令。这是&lt;a href=&quot;xread&quot;&gt;XREAD的&lt;/a&gt;一项关键功能，因为尤其是在使用&lt;strong&gt;BLOCK&lt;/strong&gt;进行阻止时，能够通过一次连接到多个键进行侦听是至关重要的功能。</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">此命令可以从其他连接中解除阻止在阻止操作（例如&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;或&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;或&lt;a href=&quot;wait&quot;&gt;WAIT）中&lt;/a&gt;被阻止的客户端。</target>
        </trans-unit>
        <trans-unit id="7d6f9176a21b0c3f64b6d59331a54d4112960a8c" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="translated">该命令代替了现在不推荐使用的&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;。做 &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="ae4b7969f891e0631e6b36c849a8182bdc4a8ebc" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="translated">该命令代替了现在不推荐使用的&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;。进行 &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; （左移）是等效的。</target>
        </trans-unit>
        <trans-unit id="7f02c76dc59dbdc13fe5dd0f4a1731c43a14ddd0" translate="yes" xml:space="preserve">
          <source>This command controls the tracking of the keys in the next command executed by the connection, when tracking is enabled in &lt;code&gt;OPTIN&lt;/code&gt; or &lt;code&gt;OPTOUT&lt;/code&gt; mode. Please check the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;client side caching documentation&lt;/a&gt; for background information.</source>
          <target state="translated">当在 &lt;code&gt;OPTIN&lt;/code&gt; 或 &lt;code&gt;OPTOUT&lt;/code&gt; 模式下启用跟踪时，此命令控制在连接执行的下一个命令中对键的跟踪。请查看&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;客户端缓存文档&lt;/a&gt;以获取背景信息。</target>
        </trans-unit>
        <trans-unit id="e2f8b881a98ea2d40bfed754bab550d934301142" translate="yes" xml:space="preserve">
          <source>This command copies the value stored at the &lt;code&gt;source&lt;/code&gt; key to the &lt;code&gt;destination&lt;/code&gt; key.</source>
          <target state="translated">此命令将存储在 &lt;code&gt;source&lt;/code&gt; 键处的值复制到 &lt;code&gt;destination&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="cff095ce217da2e3523c4effed757c97e397dac6" translate="yes" xml:space="preserve">
          <source>This command enables the tracking feature of the Redis server, that is used for &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt;.</source>
          <target state="translated">此命令启用Redis服务器的跟踪功能，该功能用于&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;服务器辅助的客户端缓存&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">当前仅在将&lt;strong&gt;jemalloc&lt;/strong&gt;用作分配器时才实现此命令，并且对所有其他命令评估为良性NOOP。</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">该命令等于&lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;，但不返回结果集，而是存储在 &lt;code&gt;destination&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">该命令等于&lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;，但是不返回结果集，而是存储在 &lt;code&gt;destination&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">此命令等于&lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;，但不返回结果集，而是存储在 &lt;code&gt;destination&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">该命令与&lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt;一起特别有用，而CLIENT UNBLOCK在Redis 5中也与&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;一起引入。在&lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt;命令页面上查看涉及这两个命令的模式。</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">该命令与&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;完全相同，唯一的区别在于，该查询不使用经度和纬度值作为要查询的区域的中心，而是使用已存在于由排序集表示的地理空间索引中的成员的名称。</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">该命令与&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;完全相同，但是有一个显着的区别，即以相反的顺序返回条目，并以相反的顺序获取起始-结束范围：在&lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE中，&lt;/a&gt;您需要声明&lt;em&gt;结束&lt;/em&gt; ID，然后再声明&lt;em&gt;起始&lt;/em&gt; ID，以及该命令从&lt;em&gt;结束&lt;/em&gt;端开始，将产生两个ID之间（或完全相似）的所有元素。</target>
        </trans-unit>
        <trans-unit id="076bd15f23123ea6b78baa94e15f792d2be93592" translate="yes" xml:space="preserve">
          <source>This command is like &lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;, but stores the result in destination key.</source>
          <target state="translated">此命令类似于&lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;，但是将结果存储在目标密钥中。</target>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">该命令主要用于 &lt;code&gt;nodes.conf&lt;/code&gt; 节点状态文件由于某种原因丢失/删除的情况下，我们希望从头开始再次生成它。在通过 &lt;code&gt;CLUSTER&lt;/code&gt; 命令对节点群集配置进行平凡更改的情况下，它也很有用，以确保新配置可以持久保存在磁盘上，但是通常所有命令都应该能够自动调度以在磁盘上持久保存配置这样做对于重新启动系统时的正确性非常重要。</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">这个命令主要用于调试,当Redis Cluster的故障检测器没有按照我们认为应该的方式运行时。</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">这个命令主要是用来杀死一个运行时间过长的脚本(例如因为一个错误而进入无限循环)。脚本将被杀死,而当前阻塞进入EVAL的客户端将看到该命令以错误方式返回。</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">该命令主要用于重新供应Redis Cluster节点,以便在新的、不同的集群中使用。Redis Cluster测试框架也广泛使用该命令,以便在每次执行新的测试单元时重置集群的状态。</target>
        </trans-unit>
        <trans-unit id="fed8489efd023df6aa3b9c8828a92cf9cbe79777" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">该命令类似于&lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;，但是它没有存储结果排序集，而是返回给客户端。</target>
        </trans-unit>
        <trans-unit id="39b570683c8482e1a6ba032781b807f8695533eb" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">此命令与&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;相似，但是它不存储结果排序集，而是返回给客户端。</target>
        </trans-unit>
        <trans-unit id="d880d1fb82050509f79c50bd6fb5ec73f51cf212" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="translated">此命令类似于&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;，但不存储结果排序集，而是将其返回给客户端。</target>
        </trans-unit>
        <trans-unit id="9de9c0357b2f6bf5f5b30bfd602eff2f9c1cbcf1" translate="yes" xml:space="preserve">
          <source>This command is the most powerful analysis tool in the latency monitoring framework, and is able to provide additional statistical data like the average period between latency spikes, the median deviation, and a human-readable analysis of the event. For certain events, like &lt;code&gt;fork&lt;/code&gt;, additional information is provided, like the rate at which the system forks processes.</source>
          <target state="translated">该命令是延迟监视框架中功能最强大的分析工具，并且能够提供其他统计数据，例如延迟尖峰之间的平均时间间隔，中位数偏差以及事件的人类可读分析。对于某些事件（例如 &lt;code&gt;fork&lt;/code&gt; )，将提供其他信息，例如系统fork的处理速率。</target>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">这个命令是强制Redis刷新脚本缓存的唯一方法。它在云环境中最有用,因为在云环境中,同一个实例可以被重新分配给不同的用户。它对于测试客户端库对脚本功能的实现也很有用。</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">该命令是中断一个达到配置的脚本最大执行时间的长期运行脚本的唯一方法。SCRIPT KILL命令只能用于在执行过程中没有修改数据集的脚本(因为停止只读脚本不会违反脚本引擎的保证原子性)。有关长期运行的脚本的更多信息,请参见下一节。</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">使用此命令以便管理与流数据结构关联的使用者组。使用&lt;a href=&quot;xgroup&quot;&gt;XGROUP，&lt;/a&gt;您可以：</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">该命令用于读取和重置Redis慢速查询日志。</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">这条命令很有用,因为它能够以受控的方式将客户端从一个Redis实例切换到另一个实例。例如,在实例升级时,系统管理员可以执行以下操作。</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">当我们正在监视数量有限的连接的许多键时，此命令特别有用。例如，我们可能希望使用&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;监视多个流，而不使用超过N个连接。但是，在某个时候，消费者进程被告知还有一个流密钥需要监视。为了避免使用更多的连接，最好的行为是从池中的连接之一停止阻塞命令，添加新密钥，然后再次发出阻塞命令。</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">这个命令的作用是为了修改节点对群集配置的看法,具体来说,它为接收该命令的节点分配了一组哈希槽。具体来说,它为接收该命令的节点分配一组哈希槽。如果命令成功,节点将把指定的哈希槽映射到自己身上,并开始广播新的配置。</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">此命令与&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;非常相似：它删除指定的密钥。就像&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;一样，如果密钥不存在，则将其忽略。但是，该命令在另一个线程中执行实际的内存回收，因此它不会阻塞，而&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;是。这是命令名称的来源：该命令只是&lt;strong&gt;将&lt;/strong&gt;键与键空间&lt;strong&gt;断开链接&lt;/strong&gt;。实际的删除将稍后异步进行。</target>
        </trans-unit>
        <trans-unit id="8d70f66fb80485b6d531d7d9ab8ad149118bee56" translate="yes" xml:space="preserve">
          <source>This command loads and initializes the Redis module from the dynamic library specified by the &lt;code&gt;path&lt;/code&gt; argument. The &lt;code&gt;path&lt;/code&gt; should be the absolute path of the library, including the full filename. Any additional arguments are passed unmodified to the module.</source>
          <target state="translated">该命令从 &lt;code&gt;path&lt;/code&gt; 参数指定的动态库中加载并初始化Redis模块。该 &lt;code&gt;path&lt;/code&gt; 应该是库的绝对路径，包括完整的文件名。任何其他参数都将原封不动地传递给模块。</target>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">该命令仅在集群模式下工作,在以下Redis集群操作中有用。</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">此命令仅在集群模式下有效，并且在创建新集群时用于调试以及手动编排集群配置时可能很有用。 &lt;code&gt;redis-trib&lt;/code&gt; 当前不使用它，主要是为了API完整性而存在。</target>
        </trans-unit>
        <trans-unit id="b0562f793b35f58a57b7250775581e06cabbe124" translate="yes" xml:space="preserve">
          <source>This command performs a full reset of the connection's server-side context, mimicking the effect of disconnecting and reconnecting again.</source>
          <target state="translated">该命令对连接的服务器端上下文进行完全重设,模拟断开连接后再重新连接的效果。</target>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">此命令在Redis脚本缓存中注册指定的脚本。该命令在所有我们想要确保&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;不会失败（例如在管道或MULTI / EXEC操作期间）的情况下很有用，而无需实际执行脚本。</target>
        </trans-unit>
        <trans-unit id="09806309aef17ea4d51d659e1cc3d714503d0680" translate="yes" xml:space="preserve">
          <source>This command returns the client ID we are redirecting our &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;tracking&lt;/a&gt; notifications to. We set a client to redirect to when using &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; to enable tracking. However in order to avoid forcing client libraries implementations to remember the ID notifications are redirected to, this command exists in order to improve introspection and allow clients to check later if redirection is active and towards which client ID.</source>
          <target state="translated">此命令返回我们要将我们的&lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;跟踪&lt;/a&gt;通知重定向到的客户端ID 。使用&lt;a href=&quot;client-tracking&quot;&gt;客户端跟踪&lt;/a&gt;启用跟踪时，我们将客户端设置为重定向到。但是，为了避免强制客户端库实现记住ID通知被重定向到，存在此命令是为了改善自省，并允许客户端稍后检查重定向是否处于活动状态以及向哪个客户端ID定向。</target>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">该命令返回当前未失效的当前节点的故障报告数（因此在&lt;em&gt;节点超时&lt;/em&gt;时间的两倍之内收到）。该计数不包括我们要查询的节点相信我们作为参数传递的节点ID的数量，该计数&lt;em&gt;仅&lt;/em&gt;包括从其他节点收到的故障报告。</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">此命令在新节点中设置特定的&lt;em&gt;配置时期&lt;/em&gt;。它仅在以下情况下有效：</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">这条命令可以交换两个Redis数据库,这样所有连接到某个数据库的客户端就会立即看到另一个数据库的数据,反之亦然。例子:</target>
        </trans-unit>
        <trans-unit id="75c1ca96e42909a085011b83f917c82db8bdd8f7" translate="yes" xml:space="preserve">
          <source>This command unloads the module specified by &lt;code&gt;name&lt;/code&gt;. Note that the module's name is reported by the &lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt; command, and may differ from the dynamic library's filename.</source>
          <target state="translated">此命令卸载 &lt;code&gt;name&lt;/code&gt; 指定的模块。请注意，模块的名称由&lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt;命令报告，并且可能与动态库的文件名不同。</target>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">这个命令是在Redis稳定版中间引入的,特别是在Redis 2.8.12中。</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">此命令的工作原理与&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;完全相同，但是密钥的生存时间以毫秒为单位而不是秒。</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">这个命令,只能发送到Redis集群复制节点,强制复制体启动其主实例的手动故障转移。</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">这种数据类型之间的转换是这样设计的:如果将Redis类型转换为Lua类型,再将结果转换回Redis类型,其结果与初始值相同。</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream简介文档中&lt;/a&gt;对此动态进行了明确说明。</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">这个例子显示了在Redis流的上下文中的应用,但是这个模式是一个通用的模式,可以应用于其他情况。</target>
        </trans-unit>
        <trans-unit id="7b81b5550c835cb846e3da1e36e1dc058efa8bc9" translate="yes" xml:space="preserve">
          <source>This form just authenticates against the password set with &lt;code&gt;requirepass&lt;/code&gt;. In this configuration Redis will deny any command executed by the just connected clients, unless the connection gets authenticated via &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="translated">该表单仅针对使用 &lt;code&gt;requirepass&lt;/code&gt; 设置的密码进行身份验证。在此配置中，除非通过&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;对连接进行身份验证，否则Redis将拒绝刚刚连接的客户端执行的任何命令。</target>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">这种格式可以通过检查覆盖整个半径所需的1+8区域来进行半径查询,并丢弃半径外的元素。检查区域的方法是计算所覆盖的框的范围,从排序集得分的不太重要的部分中删除足够的位,并计算每个区域在排序集中查询的得分范围。</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">这与使用一个参数 &lt;code&gt;key&lt;/code&gt; 运行&lt;a href=&quot;sinter&quot;&gt;SINTER的&lt;/a&gt;效果相同。</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">这是一个很好的概述，但有时我们会对这些细节感兴趣。为了查看所有具有更多相关信息的待处理消息，我们还需要传递一个ID范围，以类似的方式，我们使用&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;和一个非可选的&lt;em&gt;count&lt;/em&gt;参数来限制每个调用返回的消息数：</target>
        </trans-unit>
        <trans-unit id="90aa8094613e02ff36a67a68b984d933a74e701a" translate="yes" xml:space="preserve">
          <source>This is a list of all the supported Redis ACL rules:</source>
          <target state="translated">这是所有支持的Redis ACL规则的列表。</target>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">这是一个琐碎的概率算法,基本上假设我们的样本是代表整个密钥空间的,我们继续过期,直到可能过期的密钥比例低于25%为止。</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">这是一个阻塞调用的例子,由于超时时间已过,没有新的数据到达,所以命令后来返回一个空的回复。</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">这是使用&lt;strong&gt;MATCH&lt;/strong&gt;进行迭代的示例：</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">这是一个自省命令,用于检索有关流和相关消费群的不同信息。有三种形式可供选择:</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">这很容易直观地看出：如果集合增长了，为了访问所有可能的元素，将会有越来越多的工作要做，而终止迭代的能力取决于对&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;的调用次数及其COUNT选项值与集合的增长率。</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">这是典型的&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;调用在消费者仅愿意消费新条目的第一次迭代中的样子：</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">这就是如何了解你是否要使用消费群体。</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">我们就是用这个命令来装载这样的算法。</target>
        </trans-unit>
        <trans-unit id="c0d3b602529b7dea150254bfa283c67fb2eed932" translate="yes" xml:space="preserve">
          <source>This is the output you should post in the Redis mailing list if you are looking for help about Latency related issues.</source>
          <target state="translated">如果你正在寻找有关延迟相关问题的帮助,这是你应该在Redis邮件列表中发布的输出。</target>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">根据不同的用例,这在几个方面都很有用。</target>
        </trans-unit>
        <trans-unit id="bcf3a4afdd1a41afed7a49db731a6c6ebfa0cc2a" translate="yes" xml:space="preserve">
          <source>This is useful to an application that wants to fetch raw data in order to perform monitoring, display graphs, and so forth.</source>
          <target state="translated">这对于想要获取原始数据以进行监控、显示图表等的应用程序来说非常有用。</target>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">通常只有当实例要在云环境中为其他客户或应用程序实例化时,才需要这样做。</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">本手册页还介绍了 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; 和 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 变体（有关更多信息，请参见下面的部分）。</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">这意味着在任何一个时刻,已经过期的使用内存的密钥的最大数量等于每秒最大写操作量除以4。</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">这意味着,如果你在整个哈希表中有两个非空的桶,其中一个有三个元素,而一个只有一个,那么在其桶中单独存在的元素将以更高的概率被返回。</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">这意味着仅在编排Redis群集的应用程序（如 &lt;code&gt;redis-trib&lt;/code&gt; )时才应谨慎使用此命令，并且该命令（如果在正确的上下文之外使用）可能会使群集处于错误状态或导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">这意味着,你设。</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">此操作类似于&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;，它从集合中返回一个或多个随机元素，但不会将其删除。</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">这对命令将在列表中推送一个新元素，同时确保列表的长度不会超过100个元素。例如，在使用Redis存储日志时，这非常有用。重要的是要注意，当以这种方式使用&lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt;时，它是O（1）运算，因为在通常情况下，列表的尾部仅删除一个元素。</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">可以轻松修改此模式，以使用使用&lt;a href=&quot;incr&quot;&gt;INCR的&lt;/a&gt;计数器代替使用&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;的列表。</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">这个简单的模式可以在很多方面进行扩展。</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">此子命令与 &lt;code&gt;MIGRATING&lt;/code&gt; 相反，并准备目标节点以从指定的源节点导入密钥。仅当节点尚未是指定哈希槽的所有者时，此命令才有效。</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">此子命令仅清除插槽中的迁移/导入状态。它主要用于通过 &lt;code&gt;redis-trib fix&lt;/code&gt; 修复处于错误状态的群集。通常，在迁移结束时，将使用 &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; 子命令自动清除这两种状态，如下一节所述。</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">此子命令将插槽设置​​为&lt;em&gt;迁移&lt;/em&gt;状态。为了在此状态下设置插槽，接收命令的节点必须是哈希插槽所有者，否则将返回错误。</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">这样客户机就会从旧主站原子化地转移到新主站,而且只有当变成新主站的副本处理完旧主站的所有复制流后,才会从旧主站转移到新主站。</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">这样我们就有一个60秒的窗口来通知集群中的所有节点,我们要删除一个节点。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
