<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">独占区间和无穷大</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">确保已执行的脚本永远位于Redis实例的给定执行的脚本缓存中。这意味着，如果对Redis实例执行&lt;a href=&quot;eval&quot;&gt;EVAL，&lt;/a&gt;则所有后续的&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;调用都会成功。</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">执行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务中&lt;/a&gt;所有先前排队的命令，并将连接状态恢复为正常。</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">使用Redis 2.6或更新版本执行Lua脚本。</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">过期准确性</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">过期和持久性</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]删除所有数据库中的所有键。</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]删除当前数据库中的所有键。</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCE选项:当主站故障时,手动故障切换。</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">从一个流中获取一个条目,提供该条目的ID,以获取两次:作为查询间隔的开始和结束。</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">通过使用者组从流中获取数据，而不确认此类数据，具有创建&lt;em&gt;待处理条目的作用&lt;/em&gt;。&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;命令对此进行了很好的解释，甚至在我们&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;对Redis Streams&lt;/a&gt;的介绍中也对此进行了更好的解释。该&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令将立即删除从等待条目列表（PEL）的等待条目，因为一旦消息被成功处理，没有用于消费群体不再需要跟踪它，并记住消息的当前所有者。</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">获取单个项目</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">最后，如果用户忘记了确切的语法，可以通过使用 &lt;code&gt;HELP&lt;/code&gt; 子命令从命令中获得帮助：</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">最后可以得到特定消费群体中每个消费者的名单。</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">最后,可以向命令传递一个额外的参数,以便查看具有特定所有者的消息。</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">最后，可以使用 &lt;code&gt;SETID&lt;/code&gt; 子命令设置要传递的下一条消息。通常，在创建使用者时将下一个ID设置为 &lt;code&gt;XGROUP CREATE&lt;/code&gt; 的最后一个参数。但是，使用此表单可以在以后修改下一个ID，而无需再次删除和创建使用者组。例如，如果您希望使用者组中的使用者重新处理流中的所有消息，则可以将其下一个ID设置为0：</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">最后,如果你不记得语法,可以使用HELP子命令获得一些帮助。</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">论点列表中的第一个键</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">档期范围的第一个主件副本</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">如果启用AOF,则刷新仅附加文件。</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">刷新 Lua 脚本缓存。</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">刷新&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务中&lt;/a&gt;所有先前排队的命令，并将连接状态恢复为正常。</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">刷新所有先前监视的键以进行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">对于Redis 2.6，将执行执行多次推送的命令，并且&lt;em&gt;仅在&lt;/em&gt;执行该命令&lt;em&gt;后才&lt;/em&gt;为阻塞的客户端提供服务。考虑此命令序列。</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">对于的描述 &lt;code&gt;WEIGHTS&lt;/code&gt; 和 &lt;code&gt;AGGREGATE&lt;/code&gt; 选项，请参见&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">有关HyperLogLog数据结构的介绍，请查看&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;命令页面。</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">对于介绍的有序集合，请参阅数据类型页&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;排序集&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">对于每一种命令类型,都会添加以下一行。</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">对于列出的每个消费者组,该命令还显示该组中已知的消费者数量和该组中的待处理信息(已发送但尚未确认)。</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">对于每个数据库,增加以下一行:</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">对于每个副本,都要加上以下一行:</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">对于哈希中不存在的每个 &lt;code&gt;field&lt;/code&gt; ，将返回 &lt;code&gt;nil&lt;/code&gt; 值。由于不存在的键被视为空哈希，&lt;a href=&quot;hmget&quot;&gt;因此&lt;/a&gt;对不存在的 &lt;code&gt;key&lt;/code&gt; 运行HMGET将返回 &lt;code&gt;nil&lt;/code&gt; 值的列表。</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">例如在实现马尔科夫链和其他算法时,一个常见的问题是从一个集合中随机选择一个元素,但不同的元素可能有不同的权重,改变了它们被选中的可能性。</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">例如，为了计算一天中执行的所有唯一搜索查询的次数，每次处理查询时，程序都需要调用&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;。可以随时使用&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;检索估计的唯一查询数。</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">例如,下面的命令将槽位1 2 3分配给接收命令的节点。</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例如,以下命令在位偏移量100处递增一个8位有符号整数,并在位偏移量0处获取4位无符号整数的值。</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">例如,下面的命令将把流精确地修剪成最新的1000个项目。</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; 将删除存储在 &lt;code&gt;list&lt;/code&gt; 处的列表中最后两次出现的 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">例如，如果我有两个流 &lt;code&gt;mystream&lt;/code&gt; 和 &lt;code&gt;writers&lt;/code&gt; ，并且我想从两个流中读取它们都包含的第一个元素开始的数据，则可以像下面的示例一样调用&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">例如： &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; 将修改存储在 &lt;code&gt;foobar&lt;/code&gt; 的列表，以便仅保留列表的前三个元素。</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例如：考虑持有列表 &lt;code&gt;a,b,c&lt;/code&gt; 的 &lt;code&gt;source&lt;/code&gt; 和持有列表 &lt;code&gt;x,y,z&lt;/code&gt; 的 &lt;code&gt;destination&lt;/code&gt; 。执行&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH会&lt;/a&gt;导致 &lt;code&gt;source&lt;/code&gt; 持有 &lt;code&gt;a,b&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 持有 &lt;code&gt;c,x,y,z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">要想让过期的功能发挥得好,计算机的时间必须要稳定。如果你把一个RDB文件从两台计算机上移动过来,而两台计算机的时钟有很大的不同步,那么可能会发生一些有趣的事情(比如所有加载的键在加载时都过期了)。</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">有关Redis流的更多信息，请查看我们&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;对Redis Streams文档的介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">比如一个与Redis有持久连接的应用,可以确定如果一个脚本被发送过一次,它还在内存中,所以可以用EVALSHA来对付管道中的那些脚本,而不会因为未知脚本而产生错误的机会(我们后面会详细看到这个问题)。</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">例如，在上面的示例中，我们为流 &lt;code&gt;mystream&lt;/code&gt; 接收的最后一个项目的ID为 &lt;code&gt;1526999352406-0&lt;/code&gt; ，而对于流 &lt;code&gt;writers&lt;/code&gt; 的ID为 &lt;code&gt;1526985685298-0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">例如， &lt;code&gt;redis.conf&lt;/code&gt; 中的内容如下所示：</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">例如当使用Redis来实现队列时,消息的生产者和消费者可能希望根据他们的角色来设置连接的名称。</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">对于大多数命令,第一个键是位置1。位置0始终是命令名称本身。</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">对于嵌套数据类型，可以提供可选的 &lt;code&gt;SAMPLES&lt;/code&gt; 选项，其中 &lt;code&gt;count&lt;/code&gt; 是采样的嵌套值的数量。默认情况下，此选项设置为 &lt;code&gt;5&lt;/code&gt; 。要采样所有嵌套值，请使用 &lt;code&gt;SAMPLES 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">对于涉及大量输入的实时度量和统计,一个好的方法是使用副本(禁用只读选项),在副本中进行位元操作以避免阻塞主实例。</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">出于安全考虑，某些特殊的管理命令（例如 &lt;code&gt;CONFIG&lt;/code&gt; )未登录到&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;输出中。</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">因此，Redis 3.2引入了一个新命令，该命令仅在启用脚本效果复制后才有效，并且能够控制脚本复制引擎。该命令称为 &lt;code&gt;redis.set_repl()&lt;/code&gt; ，如果在禁用脚本效果复制时调用，则不会引发错误。</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">强制节点将 &lt;code&gt;nodes.conf&lt;/code&gt; 配置保存在磁盘上。返回命令之前，请调用 &lt;code&gt;fsync(2)&lt;/code&gt; 以确保在计算机磁盘上刷新了配置。</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">幸运的是,使用以下算法可以避免这个问题。我们来看看我们的理智客户C4是如何使用好这个算法的。</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">从语法的角度来看，这些命令几乎相同，但是&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;需要&lt;/em&gt;一个特殊的强制性选项：</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">有趣的事实：Reddit的2017年4月愚人项目&lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt;是&lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;使用Redis BITFIELD命令构建的&lt;/a&gt;，目的是获取协作画布的内存表示形式。</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD键经度纬度成员[经度纬度成员......]在使用排序集表示的地理空间索引中添加一个或多个地理空间项目。</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [单位]返回一个地理空间索引的两个成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH key member [member ...]返回地理空间索引的成员,作为标准的geohash字符串。</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS key member [member ...]返回地理空间索引成员的经度和纬度。</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS 键 经度 纬度 半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT 计数][ASC|DESC][STORE 键][STOREDIST 键]查询一个代表地理空间索引的排序集,以获取与给定的最大距离相匹配的成员。</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER 键 成员半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT 计数][ASC|DESC][STORE 键][STOREDIST 键]查询一个代表地理空间索引的排序集,以获取与给定最大距离相匹配的成员。</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET key 获取一个键的值</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT 键偏移 返回存储在键的字符串值中偏移的位值。</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end 获取存储在某个键上的字符串的子串。</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET 键值 设置一个键的字符串值,并返回它的旧值。</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">单方面生成一个新的 &lt;code&gt;configEpoch&lt;/code&gt; ，仅获取当前可用的最大时期，如果其本地配置时期尚未达到最大时期，则将其递增。</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">Geohash字符串属性</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">从源节点获取密钥&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt;命令，并将其移动到使用目的节点&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">获取 &lt;code&gt;key&lt;/code&gt; 的值。如果键不存在，则返回特殊值 &lt;code&gt;nil&lt;/code&gt; 。如果存储在 &lt;code&gt;key&lt;/code&gt; 处的值不是字符串，则返回错误，因为&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;仅处理字符串值。</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">给定一个SHA1摘要列表作为参数,这个命令返回一个1或0的数组,其中1表示特定的SHA1被识别为已经存在于脚本缓存中的脚本,而0表示具有这个SHA1的脚本以前从未见过(或者至少在最近的SCRIPT FLUSH命令之后从未见过)。</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">给定一个使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;命令填充的代表地理空间索引的排序集，通常对获取指定成员的坐标很有用。通过&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;填充地理空间索引时，坐标将转换为52位的geohash，因此返回的坐标可能与用于添加元素的坐标不完全相同，但是可能会引入一些小误差。</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">给定一个使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;命令填充的代表地理空间索引的排序集，该命令返回指定单位中两个指定成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">全局变量保护</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">终止的保证</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL 关键字段 [字段...]删除一个或多个哈希字段。</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS 关键字段 确定一个哈希字段是否存在。</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET 关键字段 获取哈希字段的值。</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL 键 获取哈希值中的所有字段和值。</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY 关键字段增量 将哈希字段的整数值按给定的数目增加。</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT 关键字段增量 将哈希字段的浮动值按给定的数量递增</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS 键 获取哈希中的所有字段。</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">获取哈希值中的字段数。</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET 关键字段 [字段...]获取所有给定哈希字段的值。</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET 关键字段值 [字段值...]将多个哈希字段设置为多个值。</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN 键光标 [MATCH pattern][COUNT count]递增迭代哈希字段和相关值。</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET 键字段值 设置哈希字段的字符串值。</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX 关键字段值 设置哈希字段的值,只有在该字段不存在的情况下才可以设置。</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN 关键字段 获取哈希字段的值的长度。</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS 键 获取哈希中的所有值</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">处理僵局</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">处理不同长度的字符串</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">哈希可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;hashtable&lt;/code&gt; 。该 &lt;code&gt;ziplist&lt;/code&gt; 是用于小哈希一个特殊的编码。</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">返回Redis类型的辅助函数</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">下面是几个转换的例子。</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">这是Redis&amp;gt; = 2.4的字段说明。</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;客户&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;cpu&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;内存&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;持久性&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;复制&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;服务器&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;统计信息&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">这里是田野的意思。</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">提示:可以根据当前的Unix时间切换到不同的key,这样一来,每个key只需要相对较少的样本,避免处理非常大的key,也让这种模式更友好地分布在许多Redis实例中。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redis如何过期密钥</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何工作的?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">如何处理复制链接和AOF文件中的过期问题。</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">单一流上被屏蔽的多个客户端如何服务?</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">如何指定间隔时间</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">但是，由于&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;具有很少的关联状态（仅是游标），因此具有以下缺点：</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">但是，如果偏移量以 &lt;code&gt;#&lt;/code&gt; 字符为前缀，则指定的偏移量将乘以整数类型的width，例如：</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">但是，在这种情况下，所获得的队列不&lt;em&gt;可靠，&lt;/em&gt;因为消息可能丢失，例如在出现网络问题或消费者在收到消息后立即崩溃但仍在处理中的情况下。</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">但是，它会尽快将OK返回给调用者，因此&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;命令本身不会暂停。</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">但是，节点哈希槽可以处于特殊状态，用于在节点重新启动之后传达错误（AOF / RDB文件中的键之间的不匹配以及节点哈希槽配置），或者正在进行分片操作时。这两个国家正在&lt;strong&gt;导入&lt;/strong&gt;和&lt;strong&gt;迁移&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">但是请注意，对于流而言，这不是问题：在为客户端提供服务时，不会从流中删除流条目，因此，只要&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;命令向流提供数据，每个等待的客户端都将得到服务。</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">但请注意:</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">但是，一旦数据结构更大并被提升为使用真实的哈希表，&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;系列命令将诉诸正常行为。请注意，由于这种返回所有元素的特殊行为仅对小型聚合才适用，因此对命令的复杂性或延迟没有影响。但是，要转换为真实哈希表的确切限制是&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;用户可配置的&lt;/a&gt;，因此一次调用中可以看到的最大元素数量取决于聚合数据类型的大小以及仍使用打包表示形式。</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">但从Redis 2.8.12或更高版本开始,该命令接受以下形式。</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">但是，该命令不能简单地从接收该命令的节点的内部节点表中删除该节点，它还实现了禁止列表，不允许再次添加同一节点，这是处理心跳数据包的&lt;em&gt;八卦部分&lt;/em&gt;的副作用从其他节点收到。</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">然而返回的元素数量是合理的,也就是说,在实际工作中,SCAN在迭代一个大型集合时,可能返回的元素数量最多为几十个,或者当迭代的集合小到可以在内部表示为一个编码数据结构时,可能在一次调用中返回集合的所有元素(这种情况发生在小型集合、哈希和排序集合上)。</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">但是用户可以对编码后的字符串进行转换,这样在排序集合中插入的元素的第一部分就会按照用户对具体应用的要求进行比较。例如,如果我想添加的字符串将以不区分大小写的方式进行比较,但我仍然希望在查询时检索真实的大小写,我可以用以下方式添加字符串。</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">然而用户仍然能够使用下面的简单技巧来编写具有随机行为的命令。想象一下,我想写一个Redis脚本,将用N个随机整数填充一个列表。</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">但是，用户可以使用&lt;strong&gt;COUNT&lt;/strong&gt;选项来调整每次调用返回的元素数量的数量级。</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">但是，此规则有一个例外，那就是从头开始创建新集群时。Redis Cluster &lt;em&gt;config epoch冲突解决&lt;/em&gt;算法可以在启动时处理所有配置了相同配置的新节点，但是此过程很慢，应该作为例外，只是为了确保无论发生什么情况，最终都会有两个以上的节点远离状态具有相同配置时代。</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">然而这也意味着执行慢速脚本不是一个好主意。创建快速脚本并不难,因为脚本开销很低,但如果你要使用慢速脚本,你应该注意,当脚本运行时,没有其他客户端可以执行命令。</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">然而,这是一个有用的功能,因为有时,我们需要只在主站中执行某些命令,以创建,例如,中间值。</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">然而这只是一个尽力的尝试,所以仍有可能失去同步复制到多个副本的写。</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">但是,由于插槽已经被分配,所以试图再次执行它的结果是一个错误。</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">但是，使用&lt;strong&gt;FORCE，&lt;/strong&gt;我们仍然需要大多数主服务器可用，以授权故障转移并为将成为主服务器的副本生成新的配置时期。</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">但是，尽管像&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;这样的阻塞命令能够在给定的时间内提供Set中所有元素，但是SCAN系列命令仅对返回的元素提供有限保证，因为我们递增迭代的集合可以在迭代过程中更改。</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">但是，尽管连接到主数据库的副本不会单独使密钥失效（而是等待来自主数据库的&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;），但它们仍将处于数据集中存在的到期的完整状态，因此当选择副本作为主数据库时它将能够独立使密钥失效，从而完全充当主密钥。</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">然而,请注意:</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">但是，如果您要寻找清除位并同时指定&lt;strong&gt;start&lt;/strong&gt;和&lt;strong&gt;end&lt;/strong&gt;的范围，则此行为会更改。如果在指定范围内未找到清除位，则函数将返回-1，因为用户指定了清除范围，并且该范围内没有0位。</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">人类可能会使用这个命令,以检查什么是哈希槽,然后相关的Redis集群节点,负责一个给定的密钥。</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">HyperLogLog代表</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">我可以从这个Ruby小程序开始。</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">保证ID始终是递增的:如果比较刚刚插入的条目的ID,它将大于其他过去的ID,所以条目在流里面是完全有序的。为了保证这个属性,如果流中当前最上面的ID的时间大于实例的当前本地时间,那么将使用最上面的条目时间来代替,并将ID的序列部分递增。例如,当本地时钟向后跳转时,或者在故障切换后,新的主站有不同的绝对时间时,就可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">ID由用 &lt;code&gt;-&lt;/code&gt; 字符分隔的两个数字指定：</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR key 将键的整数值增加一个。</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY key increment 按给定的数量增加键的整数值。</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT 键的增量 按给定的数量增加键的浮点数。</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [部分]获取有关服务器的信息和统计资料。</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">理想情况下， &lt;code&gt;used_memory_rss&lt;/code&gt; 值应仅略高于 &lt;code&gt;used_memory&lt;/code&gt; 。当使用rss &amp;gt;&amp;gt;时，相差很大意味着存在内存碎片（内部或外部），可以通过检查 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 进行评估。当使用&amp;gt;&amp;gt; rss时，这意味着Redis内存的一部分已被操作系统交换掉：预计会有一些显着的延迟。</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">如果&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;失败，则不会丢失任何数据，因为旧的AOF将保持不变。</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">如果&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;返回 &lt;code&gt;0&lt;/code&gt; ,则该密钥已经被其他客户端锁定。如果它是非阻塞锁，则可以返回到调用方，也可以进入一个循环重试以保持该锁，直到成功或某种超时到期为止。</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">如果&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;返回 &lt;code&gt;1&lt;/code&gt; ,则客户端获取了锁，将 &lt;code&gt;lock.foo&lt;/code&gt; 键设置为Unix时间，此时不再应将锁视为有效。客户端稍后将使用 &lt;code&gt;DEL lock.foo&lt;/code&gt; 来释放锁。</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">如果使用了&lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;，&lt;a href=&quot;discard&quot;&gt;DISCARD将&lt;/a&gt;取消监视连接监视的所有键。</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">如果 &lt;code&gt;WITHCOORD&lt;/code&gt; ， &lt;code&gt;WITHDIST&lt;/code&gt; 或 &lt;code&gt;WITHHASH&lt;/code&gt; 选项，该命令将返回一个数组数组，其中每个子数组代表一个项目。</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">如果 &lt;code&gt;destination&lt;/code&gt; 已经存在，它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 已经存在并且是字符串，则此命令将 &lt;code&gt;value&lt;/code&gt; 附加在字符串的末尾。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则会创建它并将其设置为空字符串，因此&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt;在这种特殊情况下将类似于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回nil批量答复。</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将创建一个新的已排序集合，其中指定成员为唯一成员，就像已排序集合为空一样。如果键存在但不包含排序集，则返回错误。</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中或 &lt;code&gt;key&lt;/code&gt; 不存在，则大&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;字符串答复&lt;/a&gt;： &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中，或者 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 存在于排序集中，则&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer答复&lt;/a&gt;： &lt;code&gt;member&lt;/code&gt; 的等级。</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">如果 &lt;code&gt;password&lt;/code&gt; 与配置文件中的密码匹配，则服务器将以 &lt;code&gt;OK&lt;/code&gt; 状态代码进行答复并开始接受命令。否则，将返回错误，并且客户端需要尝试新的密码。</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 不存在，则返回值 &lt;code&gt;nil&lt;/code&gt; 并且不执行任何操作。如果 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 相同，则该操作等效于从列表中删除最后一个元素并将其推入列表的第一个元素，因此可以将其视为列表轮换命令。</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">如果 &lt;code&gt;ttl&lt;/code&gt; 为0，则创建密钥时不会有任何过期，否则将设置指定的过期时间（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">如果启动了AOF,将增加这些附加字段。</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">如果Redis子项正在磁盘上创建快照，则&lt;em&gt;安排&lt;/em&gt; AOF重写，但不会开始AOF重写，直到生成RDB文件的保存子项终止。在这种情况下，&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;仍将返回OK代码，但带有适当的消息。从Redis 2.6起，您可以查看&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令来检查是否计划了AOF重写。</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">如果Redis服务器已经充当副本，则命令&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE将关闭复制，从而将Redis服务器变成MASTER。以适当的格式，&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;主机名端口将使该服务器成为另一台侦听指定主机名和端口的服务器的副本。</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">如果SYNC操作正在进行,则提供这些附加字段。</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">如果一个群集实例有不连续的槽(如1-400,900,1800-6000),那么对于每个顶层槽范围的回复,主站和副本的IP/端口结果将是重复的。</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">如果一个命令接受的键数不限,最后一个键位为-1。</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">如果一个命令接受一个键,第一个键和最后一个键的位置是1。</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">如果命令接受两个键（例如&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;，&lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;，&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;等），则最后一个键的位置就是参数列表中最后一个键的位置。</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">如果收到有关不存在的密钥的命令，则节点发出 &lt;code&gt;ASK&lt;/code&gt; 重定向，要求客户端仅将特定查询重试到 &lt;code&gt;destination-node&lt;/code&gt; 。在这种情况下，客户端不应更新其哈希槽到节点的映射。</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">如果收到关于现有密钥的命令,则按通常的方式处理该命令。</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">如果密钥被&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;覆盖，例如现有密钥 &lt;code&gt;Key_A&lt;/code&gt; 被 &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; 之类的调用覆盖，则原始 &lt;code&gt;Key_A&lt;/code&gt; 是否与超时关联都 &lt;code&gt;Key_A&lt;/code&gt; ，新密钥Key_A将继承所有 &lt;code&gt;Key_B&lt;/code&gt; 的特征。</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">如果使用&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;重命名了密钥，则相关的生存时间将转移到新的密钥名称。</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">如果正在进行加载操作,则会添加这些附加字段。</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">如果一个具有未绑定哈希槽的节点从另一个自称是其中一些哈希槽的所有者的节点接收到心跳数据包,关联就会立即建立。此外,如果收到的心跳或更新消息的配置时长大于节点自身的配置时长,则关联会被重新建立。</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">如果服务器已经是某个主服务器的副本，则&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;主机名端口将停止针对旧服务器的复制，并针对新服务器启动同步，并丢弃旧数据集。</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">如果服务器已经是某个主服务器的副本，则&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;主机名端口将停止针对旧服务器的复制，并针对新服务器启动同步，并丢弃旧数据集。</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">如果AOF重写已经在进行中,该命令将返回一个错误,以后将不会安排AOF重写。</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">如果旧的redis.conf文件中已经存在一个选项,那么它将被重写在相同的位置(行号)。</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">如果一个选项不存在,但它被设置为非默认值,它将被附加在文件的最后。</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">如果一个选项不存在,但它被设置为默认值,则不会被重写过程添加。</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">如果另一个客户端（例如C5）比C4快，并通过&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作获得了锁定，则C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作将返回未过期的时间戳。C4将仅从第一步重新启动。请注意，即使C4在将来几秒钟设置了密钥，这也不是问题。</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">如果在给定的时间某个节点上有另一个标记为 &lt;code&gt;PFAIL&lt;/code&gt; 的节点，并且同时收集了有关该节点的大多数其他主节点&lt;em&gt;故障报告&lt;/em&gt;（如果是主节点，则包括其自身），那么它将提升该节点的故障状态从 &lt;code&gt;PFAIL&lt;/code&gt; 到 &lt;code&gt;FAIL&lt;/code&gt; 并广播一条消息，强制可以到达的所有节点将节点标记为 &lt;code&gt;FAIL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">如果count大于Set内的元素数,命令将只返回整个Set,不包含额外的元素。</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">相反，如果消息已经传递给该使用者，并且它只是再次重新获取同一条消息，则&lt;em&gt;最后一个传递计数器&lt;/em&gt;将更新为当前时间，&lt;em&gt;传递&lt;/em&gt;的&lt;em&gt;数量&lt;/em&gt;增加一个。您可以使用&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令访问那些消息属性。</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">如果你想让消费者获取整个流历史,则使用0作为消费者组的起始ID。</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">如果超过25%的钥匙过期,从步骤1重新开始。</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">如果为同一密钥阻止了多个客户端，则要服务的第一个客户端是等待更多时间的客户端（第一个为密钥阻止的客户端）。解除阻止客​​户端后，它不会保留任何优先级，当再次调用&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;再次阻止该客户端时，将根据已经为同一密钥阻止的客户端数量相应地服务该客户端（从第一个密钥开始）到被阻止的最后一个）。</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">如果未指定任何 &lt;code&gt;pattern&lt;/code&gt; ，则列出所有通道，否则，如果仅指定模式，则仅列出与指定的glob样式模式匹配的通道。</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">如果未指定重置类型，则默认值为&lt;strong&gt;soft&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">如果指定的密钥都不存在，则&lt;a href=&quot;blpop&quot;&gt;BLPOP会&lt;/a&gt;阻止连接，直到另一个客户端对其中一个密钥执行&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;或&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">如果缺少一个或两个成员,命令返回NULL。</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">如果启用了持久性，则此命令确保关闭Redis，而不会丢失任何数据。如果客户端仅使用&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt;然后&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;，则不能保证这样做，因为其他客户端可能会在两个命令之间更改DB数据。</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">如果指定了&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;选项，则返回值为&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">如果不使用&lt;strong&gt;BLOCK&lt;/strong&gt;选项，则该命令是同步的，并且可以认为与&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;有关：它将返回流中的一系列项目，但是，即使我们仅考虑同步用法，它与&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;相比也有两个基本区别：</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">如果指定了&lt;strong&gt;FORCE&lt;/strong&gt;选项，则副本不会与主服务器进行任何握手，这可能无法实现，而只是从第4点开始尽快启动故障转移。当我们要在主服务器上启动手​​动故障转移时，此方法很有用。不再可达。</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果在Redis 2.6或更高版本的服务器上发生上述情况，则客户端&lt;strong&gt;A&lt;/strong&gt;将使用 &lt;code&gt;c&lt;/code&gt; 元素，因为在&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;命令之后，列表包含 &lt;code&gt;c,b,a&lt;/code&gt; ，因此从左侧获取元素意味着返回 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">如果在执行命令后HyperLogLog估计的近似基数发生变化，则&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;返回1，否则返回0。如果指定的键不存在，该命令会自动创建一个空的HyperLogLog结构（即，具有指定长度的Redis字符串，并具有给定的编码）。</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">如果客户端订阅了一个通道或模式,它将代替返回一个在第一个位置有 &quot;pong &quot;的多体,在第二个位置有一个空体,除非提供了一个参数,在这种情况下,它将返回一个参数的副本。</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">如果客户端尝试阻止多个键，但是至少一个键包含元素，则返回的键/元素对是从左到右的第一个具有一个或多个元素的键。在这种情况下，客户端不会被阻止。因此，例如 &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; ，假设 &lt;code&gt;key2&lt;/code&gt; 和 &lt;code&gt;key4&lt;/code&gt; 均为非空，将始终从 &lt;code&gt;key2&lt;/code&gt; 返回一个元素。</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">如果命令包含多个键，如果不存在，则行为与点2相同，如果全部存在，则其行为与点1相同，但是，如果仅存在部分键，则该命令在以下位置发出 &lt;code&gt;TRYAGAIN&lt;/code&gt; 错误：命令将感兴趣的密钥完成迁移到目标节点，以便可以执行multi keys命令。</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">如果命令是作为&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;事务的一部分发送的，则该命令不会阻塞，而只会尽快返回确认先前写入命令的副本数。</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">如果命令成功,新的增量值将被存储为键的新值(替换旧值),并以字符串的形式返回给调用者。</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">如果命令成功,新的副本将立即尝试联系其主站,以便从它那里复制。</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">如果当前哈希槽的所有者是接收命令的节点,但为了使命令生效,该槽将被分配给不同的节点,如果接收命令的节点中仍有该哈希槽的密钥,则该命令将返回错误。</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">如果排序集合中的元素有不同的分数,则返回的元素是不指定的。</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">如果实例是一个副本,则提供这些附加字段。</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">如果主站和副本之间的链接中断,则提供一个额外的字段。</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">如果消息从来没有传递给任何人,也就是说,如果我们谈论的是一个新的消息,那么就会创建一个PEL(Pending Entry List)。</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">如果节点是一个副本,它就会变成一个(空的)主节点。它的数据集会被刷新,所以最后节点会变成一个空的主节点。</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">如果接收到该命令的节点还不是副本,而是主节点,那么只有在满足以下附加条件的情况下,该命令才会成功,该节点才会被转换为副本。</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">如果你试图检查的对象缺失,将返回一个空的批量回复。</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">如果脚本已经调用了write命令，则唯一允许的命令变为 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; ，它将停止服务器而不将当前数据集保存在磁盘上（基本上是服务器被中止）。</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">如果脚本已经执行了写操作，则不能以这种方式终止它，因为它会违反Lua脚本原子性契约。在这种情况下，只有 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 才能杀死该脚本，从而以一种很难的方式杀死Redis进程，从而阻止该脚本以半写信息保留。</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">如果服务器不记得带有此SHA1摘要的脚本，则会返回一个特殊错误，告诉客户端改用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">如果服务器配置有 &lt;code&gt;min-slaves-to-write&lt;/code&gt; 指令（或从Redis 5开始，带有 &lt;code&gt;min-replicas-to-write&lt;/code&gt; 指令），则会提供一个附加字段：</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">如果服务器仍然记得一个具有匹配SHA1摘要的脚本,那么该脚本将被执行。</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">如果插槽处于&lt;em&gt;迁移&lt;/em&gt;状态，则将该插槽分配给另一个节点后，该状态将被清除。</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">如果插槽在接收该命令的节点中处于&lt;em&gt;导入&lt;/em&gt;状态，并且该命令将该插槽分配给该节点（在哈希节点从一个节点到另一个节点的重新分片结束时在目标节点中发生），则该命令具有有以下副作用：A）清除了&lt;em&gt;导入&lt;/em&gt;状态。 B）如果节点配置纪元还不是集群中最大的节点，它将生成一个新的节点并将其分配给自己。这样，其新的哈希插槽所有权将赢得以前的故障转移或插槽迁移创建的任何过去配置。</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">如果源集不存在或不包含指定的元素，则不执行任何操作，并返回 &lt;code&gt;0&lt;/code&gt; 。否则，该元素将从源集中删除，然后添加到目标集中。如果指定的元素已存在于目标集中，则仅将其从源集中删除。</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">如果用户将所有元素插入具有相同分数（例如0）的排序集中，则该排序集中的所有元素均按字典顺序排序，并且可以使用命令&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;对元素进行范围查询（注意：也可以使用&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;按分数范围查询排序的集合。</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">如果用户将闲置时间超过60秒,该键将被删除,只记录后续差值小于60秒的页面浏览。</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">如果源实例中没有要迁移的密钥，则返回 &lt;code&gt;NOKEY&lt;/code&gt; 。因为在正常情况下可能会丢失键，例如从到期起， &lt;code&gt;NOKEY&lt;/code&gt; 并不是错误。</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">如果我们生成的配置时期恰巧与另一个实例发生冲突，那么最终我们的配置时期或具有相同时期的另一个实例中的一个，将使用&lt;em&gt;配置时期冲突解决算法&lt;/em&gt;来移走。</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">如果我们寻找清除位（bit参数为0），并且字符串仅包含设置为1的位，则该函数将返回第一个位，而不是右侧字符串的一部分。因此，如果字符串是设置为值 &lt;code&gt;0xff&lt;/code&gt; 的三个字节，则命令 &lt;code&gt;BITPOS key 0&lt;/code&gt; 将返回24，因为直到第23位，所有位均为1。</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">如果我们寻找设置位(位参数为1),并且字符串为空或仅由零字节组成,则返回-1。</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">如果您致电&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;或&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;，则无需手动致电&lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">如果你有一个流和多个客户端,并且你希望所有的客户端都能收到所有的消息,你就不需要一个消费者组。</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">如果您有一个流和多个客户端，并且希望在客户端之间对流进行&lt;em&gt;分区&lt;/em&gt;或&lt;em&gt;共享&lt;/em&gt;，以使每个客户端都可以收到流中到达的消息的子集，那么您需要一个使用者组。</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">如果您喜欢科幻小说，那么想想时间在&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;块中以无限的速度流动...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">如果您寻找 &lt;code&gt;XGET&lt;/code&gt; 命令，将会感到失望，因为&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;是从流中获取单个条目的有效方法。您要做的就是在XRANGE的参数中两次指定ID：</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">如果你要求提供不存在的命令的详细信息,它们的返回位置将是nil。</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">想象一下，您拥有一个Web服务，并且您对用户&lt;em&gt;最近&lt;/em&gt;访问的最新N页感兴趣，因此每个相邻的页面视图执行的时间都不超过前一个页面的60秒。从概念上讲，您可以将这组页面视图视为用户的&lt;em&gt;导航会话&lt;/em&gt;，其中可能包含有关他或她当前正在寻找哪种产品的有趣信息，以便您可以推荐相关产品。</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">假设你有元素A,B和C,它们的权重分别是1,2和3。你计算权重之和,即1+2+3=6。</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">实施&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">实施细节和说明</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">实施细节。MEET和PING数据包</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">重要提示：&lt;strong&gt;无需&lt;/strong&gt;为每次迭代&lt;strong&gt;使用相同的COUNT值&lt;/strong&gt;。调用者可以根据需要自由地将计数从一个迭代更改为另一个迭代，只要在下一个调用中传递的游标是在上一次对该命令的调用中获得的游标即可。</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">导入和迁移插槽在&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出中发出，如下所示：</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">提供导入和迁移插槽作为&lt;strong&gt;附加信息&lt;/strong&gt;。如果为节点分配了给定的哈希槽，则它在哈希槽列表中也将是一个纯数字，因此不了解哈希槽迁移信息的客户端可以跳过此特殊字段。</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">在Redis 2.4中,过期时间可能不是很精确,可能在零到一秒之间出。</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">在Redis 2.6或更早版本中，如果密钥不存在或密钥存在但没有关联的过期时间，则命令返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">在Redis Cluster中,每个节点都会跟踪哪个主站在为某个哈希槽服务。</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">在Redis版本&lt;strong&gt;2.1.3&lt;/strong&gt;之前的版本中，使用更改其值的命令来更改具有过期集的密钥具有完全删除密钥的作用。由于现在已修复了复制层中的限制，因此需要此语义。</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">在Redis的未来版本中,我们有可能在给定的宏节点达到给定的删除条目数量时,触发节点垃圾收集。目前以我们对这个数据结构的使用预期,增加这样的复杂性不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">通常，您应该知道的是，将 &lt;code&gt;appendonly&lt;/code&gt; 参数设置为 &lt;code&gt;yes&lt;/code&gt; 将启动后台进程以保存初始的仅附加文件（从内存数据集中获取），并将所有后续命令附加在仅附加文件上，从而获得与自启动以来开启AOF的Redis服务器完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">只要有更多可用项，该命令就可以以其同步形式获取新数据。但是，在某些时候，我们将不得不等待数据生产者使用&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;将新条目推入我们正在使用的流中。为了避免以固定或自适应间隔进行轮询，如果命令无法返回任何数据，则可以根据指定的流和ID进行阻止，并在请求的键之一接受数据后自动解除阻止。</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">在已指定的字节或其它数量的选项，这是不可能使用 &lt;code&gt;redis.conf&lt;/code&gt; 缩写形式（ &lt;code&gt;10k&lt;/code&gt; ， &lt;code&gt;2gb&lt;/code&gt; ...等等），一切都应该被指定为形成良好的64位整数，在配置指令的基本单位。但是，由于Redis版本3.0或更高版本，可以将&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;与用于 &lt;code&gt;maxmemory&lt;/code&gt; 内存，客户端输出缓冲区和复制积压大小的内存单元一起使用。</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">为了避免这些问题并避免带宽损失，Redis实现了&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">为了阻止，使用了&lt;strong&gt;BLOCK&lt;/strong&gt;选项，以及在超时之前我们要阻止的毫秒数。通常，Redis阻止命令的超时时间以秒为单位，但是，即使服务器通常具有接近0.1秒的超时分辨率，该命令也会以毫秒为单位超时。这段时间可能会在某些使用情况下将时间缩短，并且如果服务器内部性能会随着时间的推移而改善，则超时的分辨率可能会提高。</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">为了启用脚本效果复制,你需要在脚本进行任何写操作之前发出以下 Lua 命令。</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">为了启用此格式，使用了&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;选项，并且正常的&lt;em&gt;key&lt;/em&gt;参数设置为空字符串。实际的键名称将在&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;参数本身之后提供，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">为了在脚本中强制执行这种行为,Redis做了以下工作。</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">为了修复某些槽位未分配的破碎集群。</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">为了对一个流进行迭代,我们可以进行如下操作。假设我们每次迭代需要两个元素。我们开始获取前两个元素,这是微不足道的。</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">为了使它成为一个纯函数,但仍然确保每次调用脚本都会产生不同的随机元素,我们可以简单地在脚本中添加一个额外的参数,用来给 Lua 伪随机数生成器播种。新脚本如下。</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">为了确保redis.conf文件始终是一致的，也就是说，在发生错误或崩溃时，您总是以旧文件或新文件结尾，重写是通过具有足够内容的单个 &lt;code&gt;write(2)&lt;/code&gt; 调用执行的至少与旧文件一样大。有时以注释的形式添加其他填充，以确保生成的文件足够大，然后该文件被截断以最后删除填充。</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">为了使此锁定算法更健壮，持有锁的客户端应始终检查超时是否过期，然后再使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;解锁密钥，因为客户端失败可能很复杂，不仅会崩溃，而且还会浪费很多时间进行某些操作并在很多时间后尝试发布&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;（当LOCK已被另一个客户端持有时）。</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">为了在不牺牲一致性的情况下获得正确的行为，当密钥过期时，将在AOF文件中合成&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作并获得所有附加的副本节点。这样，到期过程就集中在主实例中，并且不会出现一致性错误。</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">换句话说,Lua和Redis类型之间是一对一的转换。下表显示了所有的转换规则。</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">在实际应用中,Redis数据库主要应该是为了在需要的时候,将属于同一应用的不同键分开,而不是为了将一个Redis实例用于多个不相关的应用。</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">在 &lt;code&gt;COUNT&lt;/code&gt; 选项文档中，我们指出，有时该命令族可能在一次调用中一次返回Set，Hash或Sorted Set的所有元素，而与 &lt;code&gt;COUNT&lt;/code&gt; 选项的值无关。发生这种情况的原因是，仅当我们要扫描的聚合数据类型表示为哈希表时，才可以实现基于游标的迭代器，并且它很有用。但是，Redis使用&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;内存优化&lt;/a&gt;，其中使用紧凑的单分配压缩编码来表示小的聚合数据类型，直到它们达到给定数量的项或给定的单个元素的最大大小为止。在这种情况下，请&lt;a href=&quot;scan&quot;&gt;扫描&lt;/a&gt; 没有有意义的游标要返回，并且必须立即迭代整个数据结构，因此它唯一明智的行为是在调用中返回所有内容。</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">在上述情况下，条目 &lt;code&gt;1526985054069-0&lt;/code&gt; 存在，否则服务器将向我们发送下一个条目。使用 &lt;code&gt;COUNT&lt;/code&gt; 也是将&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;用作迭代器的基础。</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">在上面的计算天数的示例中，即使应用程序已运行10年，我们每个用户仍然只有 &lt;code&gt;365*10&lt;/code&gt; 位数据，每个用户只有456个字节。有了这样的数据量，&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;仍然与任何其他O（1）Redis命令（如&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;或&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;）一样快。</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅当消息闲置至少一小时而原始消费者或某些其他消费者没有进展（确认或声明）时，我们才声明ID为 &lt;code&gt;1526569498055-0&lt;/code&gt; 的消息，并将所有权分配给消费者 &lt;code&gt;Alice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">在上面的例子中,你可以看到报告的信息是流的元素数量,关于代表流的radix树的细节,主要是对优化和调试任务有用,与流相关联的消费者组的数量,最后生成的ID可能与最后的条目ID不一样,以防某些条目被删除。最后显示了流中完整的第一个和最后一个条目,以便对流的内容有一定的了解。</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">在上面的锁定算法中,有一个问题:如果客户机失败、崩溃或者其他原因无法释放锁,会发生什么情况?可以检测到这种情况,因为锁键包含一个UNIX时间戳。如果这样的时间戳等于当前的Unix时间,锁就不再有效。</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">在&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;的情况下，键位于其他位置，因此步长值为2。与上面的&lt;a href=&quot;mget&quot;&gt;MGET（&lt;/a&gt;步长仅为1）进行比较。</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">在已经接收到 &lt;code&gt;DELSLOTS&lt;/code&gt; 命令并因此删除了传递的哈希槽的关联的节点的上下文中，我们说这些哈希槽是&lt;em&gt;未绑定的&lt;/em&gt;。请注意，未绑定哈希槽的存在是自然发生的，这是因为未将节点配置为处理它们（可以使用 &lt;code&gt;ADDSLOTS&lt;/code&gt; 命令完成），并且如果它未收到有关谁拥有那些哈希槽的任何信息（它可以从心跳中学习或更新消息）。</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">在流消费者组的上下文中,这条命令改变了一个待处理消息的所有权,因此新的所有者是作为命令参数指定的消费者。通常情况下,会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">在上面的例子中,第一次调用使用0作为游标,开始迭代。第二次调用使用前一次调用返回的游标作为回复的第一个元素,即17。</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">在扩展表格中,我们不再看到摘要信息,取而代之的是待处理条目列表中每条消息的详细信息。对于每条消息,我们会返回四个属性。</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">在以下示例中，对&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;的首次调用不使用超时，而是要求写入达到1个副本。它以成功返回。相反，在第二次尝试中，我们设置了超时时间，并要求将写入复制到两个副本。由于只有一个副本可用，因此&lt;a href=&quot;wait&quot;&gt;等待&lt;/a&gt;一秒钟后WAIT会解除阻止并返回1，因此副本数量已达到。</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">在下面的例子中,我们可以看到如何处理浮点数和带nils的数组。</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">在下面的例子中,我们将说明为什么该命令不仅要从节点表中删除某个节点,而且还要防止它在一段时间内再次被插入。</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">在下面的例子中,你可以看到一旦Redis不再能够使用节省空间的编码,编码是如何变化的。</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">在&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;实现的特定情况下，Redis会为每个客户端记住在给定客户端的上下文中执行给定写入命令时所产生的复制流的复制偏移。当&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;被称为Redis的检查指定的副本数量已经承认了这一点偏移或更大的一个。</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">在这种情况下，&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;将自动完成 &lt;code&gt;-0&lt;/code&gt; 的开始间隔和 &lt;code&gt;-18446744073709551615&lt;/code&gt; 结束间隔，以返回在给定毫秒与另一个指定毫秒结束之间生成的所有条目。这也意味着重复相同的毫秒两次，我们将获得该毫秒内的所有条目，因为序列号的范围是从零到最大值。</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">在这种形式下,命令返回存储在指定键处的流的一般信息。</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">在这种形式下,我们只是得到与流相关联的所有消费者群体作为输出。</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">在这种形式下,命令输出该消费者组的待处理消息总数,即为1,然后输出待处理消息中最小和最大的ID,再列出该消费者组中每一个至少有一条待处理消息的消费者,以及它的待处理消息数量。</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">在这种特殊情况下，运行单个&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;客户端可以将吞吐量降低50％以上。运行更多的&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;客户端将进一步降低吞吐量。</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">在这种复制模式下,当 Lua 脚本执行时,Redis 会收集 Lua 脚本引擎执行的所有实际修改数据集的命令。当脚本执行结束后,脚本生成的命令序列被包装成一个MULTI/EXEC事务,并被发送到复制体和AOF。</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">这样，示例消费者代码将仅获取新消息，对其进行处理并通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;对其进行确认。但是，上面的示例代码并不完整，因为它无法处理崩溃后的恢复。如果我们在处理消息的过程中崩溃，将发生的事情是消息将保留在待处理条目列表中，因此我们可以通过为&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;最初设置ID为0并执行相同的循环来访问历史记录。一旦提供ID为0的答复，便是一组空消息，我们知道我们已经处理并确认了所有待处理消息：我们可以开始使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为ID，以获取新消息并重新加入正在处理的使用者新事物。</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">这样，当处于迁移状态的节点生成 &lt;code&gt;ASK&lt;/code&gt; 重定向时，客户端联系目标节点，发送 &lt;code&gt;ASKING&lt;/code&gt; ，并在发送命令后立即进行。这样，将在目标节点中执行有关旧节点中不存在的密钥或已迁移到目标节点的密钥的命令，以便：</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">不完整的ID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">递增指定 &lt;code&gt;field&lt;/code&gt; 存储在散列的 &lt;code&gt;key&lt;/code&gt; ，和表示浮点数，由指定的 &lt;code&gt;increment&lt;/code&gt; 。如果增量值为负，则结果将使哈希字段值&lt;strong&gt;递减&lt;/strong&gt;而不是递增。如果该字段不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果发生以下情况之一，则返回错误：</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">增量代表存储在浮点数串 &lt;code&gt;key&lt;/code&gt; 由指定的 &lt;code&gt;increment&lt;/code&gt; 。通过使用负 &lt;code&gt;increment&lt;/code&gt; 值，结果是存储在键上的值减小了（通过明显的加法属性）。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果发生以下情况之一，则返回错误：</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">使存储在号码 &lt;code&gt;field&lt;/code&gt; 中存储在哈希 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;increment&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果该 &lt;code&gt;field&lt;/code&gt; 不存在，则在执行操作之前将该值设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">使存储在数字 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;increment&lt;/code&gt; 。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 存储的数字加1。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">按 &lt;code&gt;increment&lt;/code&gt; 存储在 &lt;code&gt;key&lt;/code&gt; 上的排序集中的 &lt;code&gt;member&lt;/code&gt; 的分数。如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中，则将其添加为 &lt;code&gt;increment&lt;/code&gt; 作为其分数（好像其先前分数为 &lt;code&gt;0.0&lt;/code&gt; ）。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将创建一个以指定 &lt;code&gt;member&lt;/code&gt; 为唯一成员的新排序集。</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">关于槽位传播和警告的信息。</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">将所有指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的开头。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则在执行推入操作之前将其创建为空列表。当 &lt;code&gt;key&lt;/code&gt; 保留的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">将所有指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的末尾。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则在执行推入操作之前将其创建为空列表。当 &lt;code&gt;key&lt;/code&gt; 保留的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅当 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表时，才将 &lt;code&gt;value&lt;/code&gt; 插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的开头。与&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅当 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表时，才将 &lt;code&gt;value&lt;/code&gt; 插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的末尾。与&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 列表中的存储在 &lt;code&gt;key&lt;/code&gt; 之前或参考值后 &lt;code&gt;pivot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">相反的Redis 2.4的作品以不同的方式：客户供应&lt;em&gt;的背景下，&lt;/em&gt;推动工作，所以只要 &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 开始推动的第一个元素到列表中，它将被交付给客户&lt;strong&gt;一个&lt;/strong&gt;，将接收 &lt;code&gt;a&lt;/code&gt; （第一个元素）。</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">而不是使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;释放锁定，而是发送一个仅在值匹配时才删除密钥的脚本。</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">不设置一个固定的字符串,而是设置一个不可猜测的大随机字符串,称为token。</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">相反，如果由于 &lt;code&gt;lock.foo&lt;/code&gt; 上的Unix时间早于当前Unix时间而使锁过期，则C4尝试执行：</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">指示Redis启动&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;仅追加文件&lt;/a&gt;重写过程。重写将创建当前&amp;ldquo;仅附加文件&amp;rdquo;的小型优化版本。</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">整数答复</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">EVAL简介</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">它还可以取以下值:</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">它包含一个64位校验和，用于确保将检测到错误。在&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;命令可以确保使用合成序列化价值的关键前检查校验。</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">这是&lt;strong&gt;非常重要的&lt;/strong&gt;要明白，你应该使用 &lt;code&gt;$&lt;/code&gt; ID仅在第一次调用&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;。以后，该ID应该是流中最后报告的项目之一，否则您可能会错过之间添加的所有条目。</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">也可以使用特殊模式 &lt;code&gt;#&lt;/code&gt; 来 &lt;code&gt;GET&lt;/code&gt; 元素本身：</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">需要注意的是,步骤3是唯一一次Redis集群节点会在没有得到其他节点同意的情况下创建新的配置epoch。只有在操作手动配置时才会发生这种情况。然而这是不可能的,这会造成两个节点拥有相同配置 epoch 的非临时性设置,因为 Redis Cluster 使用配置 epoch 碰撞解决算法。</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">重要的是要注意，&lt;strong&gt;MATCH&lt;/strong&gt;过滤器是在从集合中检索元素之后，即在将数据返回给客户端之前应用的。这意味着，如果模式与集合中的元素很少匹配，则&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;在大多数迭代中可能不返回任何元素。一个例子如下所示：</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">重要的是要理解，此命令将&lt;em&gt;扇出&lt;/em&gt;所有正在等待相同范围ID的客户端，因此每个使用者都将获得数据的副本，这与使用阻止列表弹出操作时发生的情况不同。</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">它永远不会重复，因此，如果&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;返回相同的数字，则调用者可以确保基础客户端没有断开连接并重新连接，但是仍然是相同的连接。</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">在超时的情况下，密钥不可能丢失，但是在发生超时错误的情况下，调用&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;的客户端应检查该密钥是否&lt;em&gt;也&lt;/em&gt;存在于目标实例中并采取相应的措施。</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">由于迭代器的完整状态在游标中,每次调用时都会获得并返回给客户端,所以可以让无限多的客户端同时迭代同一个集合。服务器端完全不获取状态。</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">可以使用已具有现有到期集的密钥作为参数来调用&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;。在这种情况下，密钥的生存时间将&lt;em&gt;更新&lt;/em&gt;为新值。有许多有用的应用程序，下面的&amp;ldquo; &lt;em&gt;导航会话&lt;/em&gt;模式&amp;rdquo;部分记录了一个示例。</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">可以像普通客户端一样在Lua脚本中调用&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;，但是，行为的一个微妙方面在Redis 2.8.11和Redis 2.8.12之间发生了变化。在2.8.12版本之前，由Lua脚本选择的数据库已作为当前数据库&lt;em&gt;转移&lt;/em&gt;到调用脚本。从Redis 2.8.12开始，Lua脚本选择的数据库仅影响脚本本身的执行，而不会修改客户端调用脚本选择的数据库。</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">可以使用两个不同的 Lua 函数从 Lua 脚本中调用 Redis 命令。</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">可以完全删除连接名,将其设置为空字符串,这不是一个有效的连接名,因为它的作用是这个特定的目的。</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">使用命令&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;可以仅获取慢速日志的长度。</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">为了提高工作效率,可以用以下特殊形式下达命令。</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">使用&lt;strong&gt;MAXLEN&lt;/strong&gt;选项可以将流的大小限制为最大元素数。</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">可以对解锁模式进行如下修改,使本系统更加健壮。</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;redis.conf&lt;/code&gt; 或使用CONFIG GET / CONFIG SET命令来修改可以执行毫秒级精度的脚本的最长时间。影响最大执行时间的配置参数称为 &lt;code&gt;lua-time-limit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">可以仅迭代与给定的glob样式的模式匹配的元素，类似于将模式作为唯一参数的&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;命令的行为。</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">可以传递 &lt;code&gt;WITHSCORES&lt;/code&gt; 选项，以便将元素的分数与元素一起返回。返回的列表将包含 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 而不是 &lt;code&gt;value1,...,valueN&lt;/code&gt; 。客户端库可以自由返回更合适的数据类型（建议：具有（值，得分）数组/元组的数组）。</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">可以同时提供多个过滤器。该命令将通过逻辑AND处理多个过滤器。例如:</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">只需在命令末尾指定多个参数，就可以使用单个命令调用来推送多个元素。元素从最左边的元素到最右边的元素一个接一个地插入列表的开头。因此，例如命令 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; 将导致一个包含 &lt;code&gt;c&lt;/code&gt; 作为第一元素， &lt;code&gt;b&lt;/code&gt; 作为第二元素和 &lt;code&gt;a&lt;/code&gt; 作为第三元素的列表。</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">只需在命令末尾指定多个参数，就可以使用单个命令调用来推送多个元素。从最左边的元素到最右边的元素，元素一个接一个地插入到列表的末尾。因此，例如命令 &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 将导致一个列表，其中包含 &lt;code&gt;a&lt;/code&gt; 作为第一元素， &lt;code&gt;b&lt;/code&gt; 作为第二元素， &lt;code&gt;c&lt;/code&gt; 作为第三元素。</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">可以在MULTI / EXEC块中与CLI &lt;code&gt;INFO replication&lt;/code&gt; 命令一起发送&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;，以便在阻止客户端时获得当前的主偏移。这样，可以在副本端等待特定的偏移量，以确保已处理所有复制流。</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">可以指定一个可选的修饰符来改变命令的行为。具体来说就是:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;命令将持久性从RDB快照切换到仅附加文件（以及其他方式）。有关如何执行此操作的更多信息，请检查&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;持久性页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">使用&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;命令可以终止仅执行只读命令的脚本。这不会违反脚本语义，因为脚本尚未将任何数据写入数据集中。</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">可以在每个页面视图中同时使用&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;和&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;，以使计数器仅对最近的N个页面视图进行计数，这些间隔小于指定的秒数。</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">可以通过以下语法对哈希字段使用 &lt;code&gt;BY&lt;/code&gt; 和 &lt;code&gt;GET&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">可以在诸如 &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; 之类的 &lt;code&gt;geohash.org&lt;/code&gt; URL中使用它们。这是&lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;此类URL&lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;redis.log&lt;/code&gt; 函数可以从Lua脚本写入Redis日志文件。</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">这是阻塞版本,因为当没有成员从任何给定的排序集中弹出时,它就会阻塞连接。分数最高的成员从第一个非空的排序集合中弹出,并按照给定的键的顺序进行检查。</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">这是阻塞版本,因为当没有成员从任何给定的排序集中弹出时,它就会阻塞连接。分数最低的成员从第一个非空的排序集合中弹出,并按照给定的键的顺序进行检查。</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">它只是假设地球是一个球体,因为所用的距离公式是哈弗辛公式。这个公式应用于地球时只是一个近似值,因为地球不是一个完美的球体。当用于需要通过半径查询的社交网站和大多数其他应用时,引入的错误不是问题。然而在最坏的情况下,误差可能高达0.5%,所以你可能要考虑其他系统来处理误差关键的应用。</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">它开始再次从其他客户端接受命令，但是将向所有发送常规命令的客户端返回&amp;ldquo;忙&amp;rdquo;错误。在此状态下，仅允许使用的命令是&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;和 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">它停止处理来自普通和pub/sub客户端的所有待处理命令。但与副本的交互将继续正常进行。</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">它还支持其他几个功能： &lt;code&gt;bit.tobit&lt;/code&gt; ， &lt;code&gt;bit.tohex&lt;/code&gt; ， &lt;code&gt;bit.bnot&lt;/code&gt; ， &lt;code&gt;bit.band&lt;/code&gt; ， &lt;code&gt;bit.bor&lt;/code&gt; ， &lt;code&gt;bit.bxor&lt;/code&gt; ， &lt;code&gt;bit.lshift&lt;/code&gt; ， &lt;code&gt;bit.rshift&lt;/code&gt; ， &lt;code&gt;bit.arshift&lt;/code&gt; ， &lt;code&gt;bit.rol&lt;/code&gt; ， &lt;code&gt;bit.ror&lt;/code&gt; ， &lt;code&gt;bit.bswap&lt;/code&gt; 。&lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp文档&lt;/a&gt;中记录了所有可用功能</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">递增地迭代流，每次迭代仅返回一些项。但是，从语义上讲，它比&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;系列功能强大得多。</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">迭代流</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">使用XREVRANGE进行迭代</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">Hash值的迭代。</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">KEYS 模式 查找与给定模式相匹配的所有键。</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">关键的步数，使我们找到类似的命令关键岗位&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;了格式是 &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">按照给定的顺序检查密钥。假设键 &lt;code&gt;list1&lt;/code&gt; 不存在，而 &lt;code&gt;list2&lt;/code&gt; 和 &lt;code&gt;list3&lt;/code&gt; 保存非空列表。考虑以下命令：</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">密钥到期信息以绝对的Unix时间戳(在Redis 2.6或更高版本的情况下以毫秒为单位)存储。这意味着即使在Redis实例不活动时,时间也在流动。</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">不存在的键被认为是空集。</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">不存在的键被认为是空集。当其中一个键是空集时,所得到的集也是空的(因为集与空集相交的结果总是空集)。</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">钥匙的过期时间</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">关键空间点击率</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">关键空间失误</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">杀死当前正在执行的Lua脚本,假设该脚本还没有进行写操作。</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 获取最后一次成功保存到磁盘的UNIX时间戳。</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">可以通过以下两种模式之一启用LDB：异步或同步。在异步模式下，服务器创建一个不会阻塞的分支调试会话，并且在会话结束后会&lt;strong&gt;回滚&lt;/strong&gt;所有对数据的更改，因此可以使用相同的初始状态重新启动调试。当调试会话处于活动状态时，备用同步调试模式将阻止服务器，并在数据集结束后保留​​对数据集的所有更改。</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX键索引 从列表中获取一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT键 BEFORE|AFTER枢轴值 在列表中的另一个元素之前或之后插入一个元素。</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN键 获取列表的长度</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP键 删除并获取列表中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH 键值 [value ...]将一个或多个值预置到列表中。</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX键值 只有在列表存在的情况下,才会将一个值预置到列表中。</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE key start stop 从列表中获取元素的范围。</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM键数值 从列表中删除元素。</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index value 通过元素的索引来设置列表中元素的值。</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM键开始停止 将列表修剪到指定范围。</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">Argument List中的最后一个键</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">以后，仅通过对位图调用&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;命令就可以知道用户访问网站的单日数。</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">最新分叉(2)时间</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">假设我们有A、B、C、D四个节点,为了结束只有A、B、C三个节点的集群,我们可以按照以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">根据知识共享署名-相同方式共享许可协议4.0许可。</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">像&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;一样，此命令返回设置了过期设置的键的剩余生存时间，唯一的区别是&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;以秒为单位返回剩余时间，而&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;以毫秒为单位返回。</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">像&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;一样，可以使用此命令来迭代整个流内容，但是请注意，在这种情况下，下一个命令调用应使用最后一个条目的ID，序列号减1。但是，如果序列号已经为0，则应将ID的时间部分减1，并将序列部分设置为最大可能的序列号，即18446744073709551615，或者可以完全省略，该命令会自动假定它是这样的数字（有关不完整ID的更多信息，请参见&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">像&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;一样，&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;命令可以以阻塞方式使用。在这方面没有区别。</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">像&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;命令一样，开始和结束可以包含负值，以便从字符串的末尾开始索引字节，其中-1是最后一个字节，-2是倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">行可以包含节名（以＃字符开头）或属性。所有属性均以 &lt;code&gt;field:value&lt;/code&gt; 形式，以 &lt;code&gt;\r\n&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">列表可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;linkedlist&lt;/code&gt; 。该 &lt;code&gt;ziplist&lt;/code&gt; 是用来节省空间的小型列出特定表示。</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">列出当前&lt;em&gt;活动的频道&lt;/em&gt;。活动频道是具有一个或多个订阅者（不包括订阅模式的客户端）的发布/订阅频道。</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">将脚本加载到脚本缓存中，而不执行它。将指定的命令加载到脚本缓存后，将可以使用&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;并使用脚本的正确SHA1摘要来调用它，就像在第一次成功调用&lt;a href=&quot;eval&quot;&gt;EVAL之后一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false-&amp;gt; Redis Nil批量回复。</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua布尔值true-&amp;gt; Redis整数回复，值为1。</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua不导出访问系统时间或其他外部状态的命令。</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Lua具有单个数字类型，即Lua数字。整数和浮点数之间没有区别。因此，我们总是将Lua数字转换为整数答复，如果有的话，删除数字的小数部分。&lt;strong&gt;如果要从Lua返回浮点数，则应将其作为字符串返回&lt;/strong&gt;，就像Redis本身一样（请参见例如&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Lua数字-&amp;gt; Redis整数回复（数字转换为整数）</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">修改Lua伪随机数生成函数 &lt;code&gt;math.random&lt;/code&gt; 和 &lt;code&gt;math.randomseed&lt;/code&gt; 以便每次执行新脚本时始终具有相同的种子。这意味着，如果不使用 &lt;code&gt;math.randomseed&lt;/code&gt; ,则每次执行脚本时，调用 &lt;code&gt;math.random&lt;/code&gt; 总是会生成相同的数字序列。</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Lua脚本可以返回一个使用一组转换规则从Lua类型转换到Redis协议的值。</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Lua字符串-&amp;gt; Redis批量回复</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Lua表（数组）-&amp;gt; Redis多批量回复（如果有，则被截断为Lua数组中的第一个nil）</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">带有单个 &lt;code&gt;err&lt;/code&gt; 字段的Lua表-&amp;gt; Redis错误回复</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">带有单个 &lt;code&gt;ok&lt;/code&gt; 字段的Lua表-&amp;gt; Redis状态回复</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">MEMORY DOCTOR 输出内存问题报告。</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 显示有关不同子命令的帮助性文本。</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">MEMORY MALLOC-STATS 显示分配器的内部统计。</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">MEMORY PURGE 要求分配器释放内存。</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">MEMORY STATS 显示内存使用详情</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE key [SAMPLES count]估计一个键的内存使用量。</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET key [key ...]获取所有给定键的值。</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE host port key|&quot;&quot; destination-db timeout [COPY][REPLACE][KEYS key [key ...]]。原子化地将一个key从一个Redis实例传输到另一个实例。</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR 实时监听服务器收到的所有请求。</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db 将一个键移动到另一个数据库。</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET键值 [键值...]将多个键设置为多个值。</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX键值[键值......]将多个键设置为多个值,只有在所有键都不存在的情况下才会设置。</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI 标记一个交易块的开始。</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">手动发出&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;命令以停止通过 &lt;code&gt;telnet&lt;/code&gt; 运行的&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;流。</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">标记给定的键，以观察是否有条件执行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">标记&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;块的开始。随后的命令将使用&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;排队等待原子执行。</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">以嵌套的IP/端口数组表示的槽位范围的主控。</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">主输出</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">旗帜的含义(字段号3);</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">将多个HyperLog值合并成一个唯一的值,该值将近似于源HyperLog结构的观察Sets的联合的cardinality。</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">用一个命令调用迁移多个键</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">迁移和导入插槽仅添加到标记为 &lt;code&gt;myself&lt;/code&gt; 的节点上。该信息对于节点来说是其自身的插槽所在的节点。</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">可以在&lt;a href=&quot;http://antirez.com/news/75&quot;&gt;此博客文章中&lt;/a&gt;找到有关Redis HyperLogLog实现的更多详细信息。 &lt;code&gt;hyperloglog.c&lt;/code&gt; 文件中实现的源代码也易于阅读和理解，并且包括用于稀疏和密集表示的确切编码的完整规范。</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">关于Current Epoch和Config Epoch变量的更多信息可在Redis Cluster规范文档中获得。</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">而且，&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;不必是互惠的。如果我将命令发送到A以便加入B，则也不需要将命令发送到B以便加入A。</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">此外，作为副作用，&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;将增加尝试传递邮件的次数。这样，由于某种原因而无法处理的消息（例如由于使用者崩溃而试图对其进行处理）将开始具有更大的计数器，并且可以在系统内部被检测到。</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">此外，如果您不熟悉流，我们建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams简介&lt;/a&gt;。确保了解介绍中的使用者组的概念，以便遵循此命令的工作方式将更加简单。</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">活动钥匙</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 从当前选定的数据库（请参见&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;）移动到指定的目标数据库。如果目标数据库中已经存在 &lt;code&gt;key&lt;/code&gt; ，或者源数据库中不存在密钥，则它什么都不做。因此，可以将&lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt;用作锁定原语。</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">将 &lt;code&gt;member&lt;/code&gt; 从 &lt;code&gt;source&lt;/code&gt; 集合移到 &lt;code&gt;destination&lt;/code&gt; 集合。此操作是原子的。在每个给定的时刻，该元素将似乎是其他客户端的 &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;或&lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; 的成员。</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">多次并行迭代</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">嵌套结果阵列</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">为了调试的目的,会定期增加新的字段。一些字段可能会在将来被删除。使用此命令的版本安全的Redis客户端应该对输出进行相应的解析(即处理优雅的缺失字段,跳过未知字段)。</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">新键总是在目标节点中创建。在哈希槽迁移过程中,我们只需要移动旧键,而不是新键。</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">不返回重复的元素。</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">心跳数据包的八卦部分中提供了处于 &lt;code&gt;PFAIL&lt;/code&gt; 状态的节点。</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">不存在的元素被报告为数组的NULL元素。</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">未使用的行被空白。例如，如果您曾经有多个 &lt;code&gt;save&lt;/code&gt; 指令，但是当您禁用RDB持久性时当前配置很少或没有，则所有行都将被清空。</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">非阻塞行为</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">非阻塞式使用</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">不存在的键将被视为空字符串,所以命令将返回零。</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">不存在的键将作为空字符串处理。</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">通常，&lt;a href=&quot;zrangebyscore&quot;&gt;仅&lt;/a&gt;简单地使用ZRANGEBYSCORE来获得分数为索引整数键的项的范围，但是可以使用该命令执行不太明显的事情。</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">通常，Redis密钥的创建没有关联的生存时间。除非用户以明确的方式（例如，使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;命令）将其删除，否则密钥将永远存在。</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">通常，Redis使用Geohash技术的变体表示元素的位置，其中使用52位整数对位置进行编码。与标准相比，编码也有所不同，因为在编码和解码过程中使用的初始最小和最大坐标是不同的。但是，此命令以&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia文章中所述&lt;/a&gt;且与&lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt;网站兼容的字符串形式&lt;strong&gt;返回标准Geohash&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">通常,与给定节点相关联的哈希槽采用以下格式之一,上文已经解释过。</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">通常，如果有一个AOF子进程执行AOF重写，则Redis会简单地杀死它并退出。但是，在两种情况下这样做是不安全的，并且将拒绝&lt;strong&gt;SHUTDOWN&lt;/strong&gt;命令并显示错误。这种情况发生在以下情况：</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">通常，副本节点会将客户端重定向到给定命令所涉及的哈希槽的权威主机，但是客户端可以使用副本以使用&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令扩展读取。</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">通常，复制脚本而不是脚本效果是有意义的，但是并非在所有情况下都可以。因此，从Redis 3.2开始，脚本引擎可以复制脚本执行所产生的写入命令序列，而不必复制脚本本身。有关更多信息，请参见下一部分。在本节中，我们假设通过发送整个脚本来复制脚本。我们将此复制模式称为&lt;strong&gt;整个脚本复制&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">通常情况下,你可能会认为Redis流是一个仅有附加的数据结构,然而Redis流是在内存中表示的,所以我们也可以删除条目。这可能很有用,例如,为了遵守某些隐私政策。</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">通常你使用这样的命令是为了获取新的消息并处理它们。在伪代码中。</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Lua新手注意事项：为了避免在脚本中使用全局变量，只需使用&lt;em&gt;local&lt;/em&gt;关键字声明要使用的每个变量。</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">请注意，&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;，&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;，&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;和&lt;a href=&quot;zscan&quot;&gt;ZSCAN的&lt;/a&gt;工作方式都非常相似，因此本文档涵盖了所有四个命令。但是，明显的区别在于，对于&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;，&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;和&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;，第一个参数是保存Set，Hash或Sorted Set值的键的名称。该&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;命令不需要任何按键名称参数，因为它遍历当前数据库的密钥，所以迭代对象是数据库本身。</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">请注意，&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;不会使Redis成为一个高度一致的存储：虽然同步复制是复制状态机的一部分，但并不是唯一需要的东西。但是，在Sentinel或Redis群集故障转移的情况下，&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;可以提高实际数据的安全性。</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">请注意，从Redis 3.2.10和Redis 4.0.0开始， &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 也可用，以便提供可在副本中使用的只读命令。有关更多信息，请参见&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">请注意，&lt;strong&gt;TAKEOVER违反了&lt;/strong&gt; Redis Cluster &lt;strong&gt;的last-failover-wins原则&lt;/strong&gt;，因为副本生成的配置时期在几种方面违反了正常的配置时期：</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">请注意，Redis群集需要形成一个完整的网格（每个节点彼此连接），但是为了创建群集，不需要发送所有形成完整网格所需的&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;命令。重要的是发送足够的&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;消息，以便每个节点都可以通过&lt;em&gt;一系列已知节点&lt;/em&gt;到达另一个&lt;em&gt;节点&lt;/em&gt;。由于心跳数据包中的八卦信息的交换，将创建丢失的链接。</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">请注意，即使使用&lt;em&gt;开始&lt;/em&gt;和&lt;em&gt;结束&lt;/em&gt;来指定范围，也总是从零位开始以绝对值返回位位置。</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">请注意，使用非肯定超时调用&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt;或使用过去某个时间&lt;a href=&quot;expireat&quot;&gt;调用EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt;将导致密钥被&lt;a href=&quot;del&quot;&gt;删除&lt;/a&gt;而不是过期（因此，发出的&lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;密钥事件&lt;/a&gt;将是 &lt;code&gt;del&lt;/code&gt; ，而不是 &lt;code&gt;expired&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">请注意，每个 &lt;code&gt;OVERFLOW&lt;/code&gt; 语句仅影响子命令列表中紧随&lt;a href=&quot;incrby&quot;&gt;其后的INCRBY&lt;/a&gt;命令，直到下一个 &lt;code&gt;OVERFLOW&lt;/code&gt; 语句为止。</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">请注意，要正确实施此模式，请避免多个客户端同时重建缓存，这一点很重要。这里需要某种锁定（例如，使用&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">请注意，出于相同的原因，Lua脚本或 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 块可能会将元素推入列表，然后再&lt;strong&gt;删除列表&lt;/strong&gt;。在这种情况下，只要在执行单个命令，事务或脚本之后列表中没有数据，就完全不会为被阻止的客户端提供服务，并且将继续被阻止。</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">请注意，如果在给定的主节点上添加，移动或删除了副本，并且我们要求&lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;到尚未收到配置更新的节点，则它可能会显示过时的信息。但是最终（如果没有网络分区，将在几秒钟内）所有节点都将同意与给定主节点关联的节点集。</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">请注意，如果在给定的主节点上添加，移动或删除了副本，并且我们向尚未收到配置更新的节点请求&lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt;，则它可能会显示过时的信息。但是最终（如果没有网络分区，将在几秒钟内）所有节点都将同意与给定主节点关联的节点集。</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">请注意，如果您有一个从0到100的数字列表，则 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; 将返回11个元素，即，其中包括最右边的项目。这&lt;strong&gt;可能&lt;/strong&gt;与选择的编程语言中与范围相关的函数的行为一致（&lt;strong&gt;也可能&lt;/strong&gt;不一致）（请考虑Ruby的 &lt;code&gt;Range.new&lt;/code&gt; ， &lt;code&gt;Array#slice&lt;/code&gt; 或Python的 &lt;code&gt;range()&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">请注意,在没有通道的情况下调用此命令是有效的。在这种情况下,它将只返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">注意，不存在的键被视为空列表，因此当 &lt;code&gt;key&lt;/code&gt; 不存在时，该命令将始终返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">请注意，通常，愿意获取&amp;ldquo;群集&amp;rdquo;哈希槽和节点地址之间的映射的客户端应改用&amp;ldquo; &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&amp;rdquo;&lt;/a&gt;。提供更多信息的&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;应该用于管理任务，调试和配置检查。 &lt;code&gt;redis-trib&lt;/code&gt; 也使用它来管理集群。</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">需要注意的是,一旦一个节点给自己分配了一组槽位,它将开始在心跳包头中传播这个信息。然而其他节点只有在它们的槽位还没有与另一个节点绑定时,或者是宣传新的哈希槽位的节点的配置周期,大于表中当前列出的节点时,才会接受该信息。</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">请注意，该命令实现了完整的哈希算法，包括对&lt;strong&gt;hash标签&lt;/strong&gt;（这是Redis Cluster密钥哈希算法的特殊属性）的支持，如果在密钥名称内找到了这样的模式，则仅对 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 之间的内容进行哈希强制多个密钥由同一节点处理。</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">请注意，该格式没有任何空格，因此，即使发出此特殊插槽，&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出格式也是纯CSV，带有空格作为分隔符。但是，格式的完整解析器应该能够处理它们。</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">请注意，您可以设置的最大偏移为2 &lt;sup&gt;29&lt;/sup&gt; -1（536870911），因为Redis字符串限制为512 MB。如果您需要超出此大小，可以使用多个键。</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">请注意，仅当消息的空闲时间大于我们在调用&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;时指定的最小空闲时间时，才声明该消息。因为作为副作用，&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;还将重置空闲时间（因为这是处理消息的新尝试），所以两个尝试同时声明消息的使用者将永远不会成功：只有一个成功声明消息。这样可以避免我们以琐碎的方式多次处理给定的消息（但是在一般情况下还是可以避免多次处理）。</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">注意,当你需要保证返回元素的均匀分布时,这个命令并不适合。关于SPOP使用的算法的更多信息,请查找Knuth采样和Floyd采样算法。</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">请注意,这种worker的实现是微不足道的可扩展性和可靠性,因为即使一个消息丢失了,该项目仍然在队列中,并将在下一次迭代时被处理。</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">请注意，我们在这里有比赛，但这不是问题：&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;可能返回false，但是在我们在&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;块中创建密钥之前，密钥可能是由另一个客户端创建的。但是，这种竞赛在极少数情况下只会错过API调用，因此速率限制仍然可以正常进行。</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">需要注意的是,你需要一个最新版本的redis-cli才能读取慢速日志输出,因为它使用了一些以前在redis-cli中没有实现的协议特性(深度嵌套的多批量回复)。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">请注意&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;和&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;的使用，以确保在每次API调用时我们都将递增并设置到期时间。</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">请注意,不执行此规则是为了给用户提供滥用Redis单例配置的机会,代价是编写与Redis Cluster不兼容的脚本。</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">注意：配置为不持久存储在磁盘上的Redis实例（未配置AOF或&amp;ldquo; save&amp;rdquo;指令）不会将RDB文件转储到&lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN上&lt;/a&gt;，因为通常您不希望Redis实例仅用于缓存时，关闭。</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注意：由于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令选项可以替换&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;，&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;，&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;，因此在Redis的未来版本中，这三个命令可能会被弃用并最终删除。</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">注意：此行为的重要部分是，无论运行Redis的系统体系结构如何，Redis都实现为 &lt;code&gt;math.random&lt;/code&gt; 和 &lt;code&gt;math.randomseed&lt;/code&gt; 的PRNG 保证具有相同的输出。32位，64位，大端和小端系统将产生相同的输出。</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">注意：作为调用此函数的副作用，可能修改了HyperLogLog，因为后8个字节对用于缓存目的的最新计算基数进行编码。因此&lt;a href=&quot;pfcount&quot;&gt;从&lt;/a&gt;技术上讲PFCOUNT是写命令。</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">注意:正如你所看到的那样,Lua数组是以Redis多批量回复的方式返回的,这是一种Redis返回类型,你的客户端库很可能会在你的编程语言中转换为Array类型。</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">注意：当然，通常不能保证错误文本保持不变，但是错误代码将保持 &lt;code&gt;-UNBLOCKED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">注意：该命令的复杂度仅为O（log（N）），因为它使用元素等级（请参阅&lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;）来了解范围。因此，无需进行与范围大小成比例的工作。</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">注意：在示例中，我们使用&lt;strong&gt;COUNT&lt;/strong&gt;选项，因此对于每个流，调用将在每个流中最多返回两个元素。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">关于发布的配置周期的说明</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">处理的命令数量</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">收到的连接数</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">每次SCAN调用时返回的元素数量</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">过期钥匙的数量</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">被拒绝的连接数</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECT子命令[参数[参数...]]检查Redis对象的内部结构</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">对象可以用不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">获取当前慢速日志的长度</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">当然也可以使用任何其他有效的ID。如果指定的使用者组已经存在，该命令将返回 &lt;code&gt;-BUSYGROUP&lt;/code&gt; 错误。否则，将执行操作并返回OK。可以与给定流关联的消费者组的数量没有硬性限制。</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">当然这还不够,因为有一些过期的密钥将永远不会再被访问。这些键无论如何都应该是过期的,所以Redis定期在有过期集的键中随机测试几个键。所有已经过期的键都会从键空间中删除。</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">另一方面，由于一些原因，使用特殊命令或通过 &lt;code&gt;redis.conf&lt;/code&gt; 定义命令将是一个问题：</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">使用者&lt;em&gt;成功&lt;/em&gt;处理一条消息后，应调用&lt;a href=&quot;xack&quot;&gt;XACK，&lt;/a&gt;以使该消息不再得到处理，并且副作用是，与此消息相关的PEL条目也被清除，从而从Redis服务器释放内存。</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">一旦一个节点变成了另一个主节点的副本,就不需要将这一变化通知其他集群节点:节点之间交换的心跳包会自动传播新的配置。</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">一旦其中一个列表中出现了新的数据,客户端就会返回解封的键名和弹出的值。</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">一旦客户端进入订阅状态，就不应发出任何其他命令，除了其他&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;，&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;和&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">一旦我们得到一些回复,下一个电话会是这样的。</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">每行一个客户端连接(用LF隔开)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">消费者组的保证之一是，给定的消费者只能看到传递给它的邮件的历史记录，因此邮件只有一个所有者。但是，有一个称为&lt;em&gt;消息声明&lt;/em&gt;的特殊功能，如果某些使用者发生不可恢复的故障，则允许其他使用者声明消息。为了实现这种语义，消费者组需要通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令明确确认消费者成功处理的消息。这是必需的，因为流将针对每个消费者组跟踪谁在处理什么消息。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">位的顺序</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">其他使用者可以使用&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令检查过时的未决消息列表。为了继续处理此类消息，他们使用&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;获取消息的所有权并继续。</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">我们前面的示例仅返回排序后的ID。在某些情况下，获取实际对象而不是其ID（ &lt;code&gt;object_1&lt;/code&gt; ， &lt;code&gt;object_2&lt;/code&gt; 和 &lt;code&gt;object_3&lt;/code&gt; ）更为有用。可以使用以下命令基于列表，集合或排序集合中的元素检索外部键：</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">超出范围的索引不会产生错误。如果 &lt;code&gt;start&lt;/code&gt; 大于列表的末尾，则返回一个空列表。如果 &lt;code&gt;stop&lt;/code&gt; 大于列表的实际结尾，则Redis会将其视为列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">超出范围的索引不会产生错误。如果 &lt;code&gt;start&lt;/code&gt; 大于排序集中的最大索引，或者 &lt;code&gt;start &amp;gt; stop&lt;/code&gt; ，则返回一个空列表。如果 &lt;code&gt;stop&lt;/code&gt; 大于排序集的末尾，则Redis会将其视为排序集中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">超出范围的索引不会产生错误：如果 &lt;code&gt;start&lt;/code&gt; 大于列表的末尾或 &lt;code&gt;start &amp;gt; end&lt;/code&gt; ，则结果将是一个空列表（这将导致 &lt;code&gt;key&lt;/code&gt; 被删除）。如果 &lt;code&gt;end&lt;/code&gt; 大于列表的末尾，则Redis会将其视为列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">范围外指数</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">输出格式</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">关于副本的命令输出</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">溢出控制</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">从&lt;em&gt;value&lt;/em&gt;的整个长度开始，从指定的偏移量覆盖&lt;em&gt;key&lt;/em&gt;处存储的一部分字符串。如果偏移量大于&lt;em&gt;key处&lt;/em&gt;字符串的当前长度，则该字符串将填充零字节以使&lt;em&gt;偏移量&lt;/em&gt;适合。不存在的键被视为空字符串，因此此命令将确保它包含足够大的字符串以能够将&lt;em&gt;值&lt;/em&gt;设置为&lt;em&gt;offset&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST键 移除密钥的到期时间。</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE key milliseconds 以毫秒为单位设置钥匙的存活时间。</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT key milliseconds-timestamp 将密钥的到期时间设置为以毫秒为单位的 UNIX 时间戳。</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD 关键元素 [元素...]将指定的元素添加到指定的 HyperLog 中。</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT key [key ...]返回HyperLogic在key(s)处观察到的集合的近似卡数。</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...]将N个不同的HyperLogs合并成一个。</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [消息]Ping服务器</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">PSETEX 密钥毫秒值 设置密钥的值和到期时间(毫秒)。</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE pattern [pattern ...]监听与给定模式相匹配的频道发布的消息。</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL键 以毫秒为单位获取键的存活时间。</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH 频道消息 向频道发布消息。</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUB子命令[参数[参数...]]。检查Pub/Sub子系统的状态。</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB CHANNELS [模式]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [模式 [模式...]]停止监听与给定模式相匹配的频道发布的消息</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">在这种情况下，将键和参数作为附加的&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;参数传递也是非常有用的，因为脚本字符串保持恒定并且可以被Redis有效地缓存。</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">模式:循环列表</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">样式。柜台</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">模式。事件通知</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">模式。导航会议</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">模式:速率限制器</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">样式。速率限制器1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">样式。速率限制器2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">模式。可靠的队列</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">模式。时间序列</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">模式:使用位图进行实时度量。</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">模式:使用位图进行实时度量</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">模式:加权随机选择一个元素</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;暂停客户端</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">在多个键(包含字符串值)之间进行位运算,并将结果存储在目标键中。</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">如果配置了至少一个&lt;strong&gt;保存点，&lt;/strong&gt;则执行阻止保存。</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">断线后执行部分重新同步。</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">对输入的字符串进行SHA1运算。</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">性能方面的考虑</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">请检查以下示例和&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;文档，以获取有关该命令及其选项的更多信息。</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">有关命令的具体语义，请参阅&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">请注意,根据Redis的版本,有些字段已经被添加或删除。因此,一个强大的客户端应用程序应该通过跳过未知属性来解析该命令的结果,并优雅地处理丢失的字段。</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">请注意，在阅读此页面之前，如果您不熟悉流，建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;有关Redis Streams的介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">请参阅&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;文档以获取有关Redis Lua脚本的详细信息。</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;持久性文档&lt;/a&gt;以获取详细信息。</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;文档中的模式说明。</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">向指定的频道发送消息。</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">实际上，对于客户端来说，最好简单地假设在给定连接的上下文中，除非管理员明确调用&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;命令，否则可以确保缓存的脚本在那里。</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">通过返回实例当前是 &lt;code&gt;master&lt;/code&gt; ， &lt;code&gt;slave&lt;/code&gt; 或 &lt;code&gt;sentinel&lt;/code&gt; ，提供有关Redis实例在复制上下文中的角色的信息。该命令还返回有关复制状态的其他信息（如果角色是主服务器或从服务器）或受监视的主机名列表（如果角色是哨兵）。</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT 关闭连接</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">退出服务器。</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 从键空间中返回一个随机的密钥。</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY 启用对集群复制节点连接的读取查询。</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE 禁止对群集复制节点的连接进行读取查询。</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">重命名键 newkey 重命名一个键</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey 重命名一个键,只有在新键不存在的情况下才可以。</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF主机端口 使服务器成为另一个实例的副本,或者将其升级为主控。</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE]使用提供的序列化值创建一个键,该值是之前使用DUMP获得的。</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE 返回实例在复制上下文中的角色。</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOP键 删除并获取列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH source destination 移除一个列表中的最后一个元素,将其前缀到另一个列表中,并将其返回。</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH 键值 [value ...]将一个或多个值添加到列表中。</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX键值 只有在列表存在的情况下,才会将一个值添加到列表中。</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">可以精确表达的整数分数范围。</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">范围:3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">从一个或多个流中读取数据，仅返回ID大于调用者最后一次收到的ID的条目。此命令具有一个选项，可以阻止项目不可用，其方式类似于&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;或&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">只读变体</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">默认情况下，对Redis Cluster从属节点的读取查询是禁用的，但是您可以使用&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令逐个连接地更改此行为。的&lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt;命令重置的连接回为读写的只读模式标志。</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">阅读应用程序代码,可能不清楚完整的语义,因为应用程序调用服务器端定义的命令。</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">强烈建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams简介&lt;/a&gt;，以更多地了解Streams的整体行为和语义。</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">阅读慢速日志</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Redis Sentinel的最新版本(Redis 2.8.12或更高版本)使用CLIENT KILL来在实例重新配置时杀死客户端,以迫使客户端再次与一个Sentinel执行握手并更新其配置。</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">重新配置客户端与新的主站连接。</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2引入了一个可选的 &lt;code&gt;count&lt;/code&gt; 参数，可以将其传递给&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;以便在单个调用中检索多个元素。</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redis集群实时重arding解释</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogs用双重表示形式表示：适用于HHL计数少量元素的&lt;em&gt;稀疏&lt;/em&gt;表示形式（导致将少量寄存器设置为非零值），以及适合较高基数的&lt;em&gt;密集&lt;/em&gt;表示形式。需要时，Redis会自动从稀疏表示转换为密集表示。</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil批量回复和Nil多批量回复-&amp;gt; Lua false boolean type</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis批量回复-&amp;gt; Lua字符串</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">从Lua调用时，可能以随机顺序返回元素的Redis命令（例如&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（因为Redis集是&lt;em&gt;无序的&lt;/em&gt;））具有不同的行为，并且在将数据返回到Lua脚本之前经过静默词典编排过滤器。因此 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 将始终以相同顺序返回Set元素，而从普通客户端调用的同一命令可能会返回不同的结果，即使键包含的元素完全相同。</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redis命令通常接受一个键、两个键或无限个键。</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redis不同的可选数据库是命名空间的一种形式：所有数据库都始终存储在同一RDB / AOF文件中。但是，不同的数据库可以具有相同名称的密钥，并且存在适用于特定数据库的可用命令，例如&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;，&lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt;或&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redis错误回复-&amp;gt; Lua表，其中包含错误的单个 &lt;code&gt;err&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis整数回复-&amp;gt; Lua号码</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">假设您正确设置 &lt;code&gt;!LC_COLLATE&lt;/code&gt; 环境变量，Redis可以识别UTF-8 。</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">现在，Redis可以删除其他线程中的后台密钥，而不会阻塞服务器。一个 &lt;code&gt;ASYNC&lt;/code&gt; 选项被添加到&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;和&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;为了让整个数据集或一个单一的数据库中异步释放。</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis通常用作消息传递服务器，以实现对后台作业或其他类型的消息传递任务的处理。往往获得队列的简单形式推值代入在生产者侧的列表，并使用等待在消费侧此值&lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt;（使用轮询），或&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;如果客户端更好通过阻塞操作提供服务。</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redis密钥过期有两种方式:一种是被动方式,一种是主动方式。</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis记录脚本运行时间过长。</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redis多批量回复-&amp;gt; Lua表（可能嵌套了其他Redis数据类型）</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis提供了一个SCRIPT命令,可以用来控制脚本子系统。SCRIPT目前接受三种不同的命令。</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">当Lua使用 &lt;code&gt;call()&lt;/code&gt; 或 &lt;code&gt;pcall()&lt;/code&gt; 调用Redis命令时，Redis返回值将转换为Lua数据类型。同样，在调用Redis命令以及Lua脚本返回值时，Lua数据类型将转换为Redis协议，以便脚本可以控制将&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;返回给客户端的内容。</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redis脚本不允许创建全局变量,以避免数据泄露到Lua状态。如果一个脚本需要在调用之间保持状态(这是一个很不常见的需求),它应该使用Redis键来代替。</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redis慢速日志概述</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redis排序集使用&lt;em&gt;双64位浮点数&lt;/em&gt;表示分数。在我们支持的所有体系结构中，这都表示为&lt;strong&gt;IEEE 754浮点数&lt;/strong&gt;，它能够精确表示介于 &lt;code&gt;-(2^53)&lt;/code&gt; 和 &lt;code&gt;+(2^53)&lt;/code&gt; 之间的整数。用更实际的术语来说，-9007199254740992和9007199254740992之间的所有整数都是可以完美表示的。较大的整数或小数在内部以指数形式表示，因此有可能仅获得十进制数字的近似值或设置为得分的非常大的整数。</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redis状态回复-&amp;gt; Lua表，带有包含状态的单个 &lt;code&gt;ok&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis以整数表示方式存储整数,所以对于实际持有整数的字符串值,不存在存储整数的字符串表示方式的开销。</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redis流以提高内存效率的方式表示：使用基数树来索引线性打包数十个流条目的宏节点。通常，从流中删除条目时会发生的情况是该条目并未&lt;em&gt;真正&lt;/em&gt;被逐出，只是被标记为已删除。</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis使用相同的Lua解释器来运行所有命令。另外，Redis保证以原子方式执行脚本：执行脚本时不会执行其他脚本或Redis命令。这种语义类似于&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC中的一种&lt;/a&gt;。从所有其他客户端的角度来看，脚本的效果还是不可见或已经完成。</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">如果脚本&lt;strong&gt;在&lt;/strong&gt; Redis &lt;em&gt;随机&lt;/em&gt;命令（例如&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;，&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;，&lt;a href=&quot;time&quot;&gt;TIME）&lt;/a&gt;&lt;strong&gt;之后&lt;/strong&gt;调用能够更改数据集的Redis命令，则Redis将使用错误阻止脚本。这意味着，如果脚本是只读的并且不修改数据集，则可以自由调用这些命令。请注意，&lt;em&gt;随机命令&lt;/em&gt;不一定表示使用随机数的命令：任何不确定的命令均被视为随机命令（这方面的最佳示例是&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">刷新过期</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">可靠的尾部</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">将某一特定消费者从消费者群体中删除。</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">删除现有的 &lt;code&gt;key&lt;/code&gt; 超时，将其从&lt;em&gt;volatile&lt;/em&gt;（设置了过期设置的键）更改为&lt;em&gt;持久&lt;/em&gt;（&lt;em&gt;持久化&lt;/em&gt;（因为没有关联超时的键））。</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 中存储的集合中删除指定的成员。不是该集合成员的指定成员将被忽略。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其视为空集，并且此命令返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">删除 &lt;code&gt;key&lt;/code&gt; 存储在键中的排序集中的所有元素，其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; （含）之间。</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">删除存储在 &lt;code&gt;key&lt;/code&gt; 中，其排序在 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 之间的排序集中的所有元素。双方 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt; 与基于索引 &lt;code&gt;0&lt;/code&gt; 是得分最低的元素。这些索引可以是负数，它们表示从得分最高的元素开始的偏移量。例如： &lt;code&gt;-1&lt;/code&gt; 是得分最高的元素， &lt;code&gt;-2&lt;/code&gt; 是得分第二高的元素，依此类推。</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 的设置值存储中删除并返回一个或多个随机元素。</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">移除并返回多达 &lt;code&gt;count&lt;/code&gt; 与存储在有序集合中得分最高的成员 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">移除并返回多达 &lt;code&gt;count&lt;/code&gt; 得分最低的存储在有序集合成员 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 处存储的列表中删除等于 &lt;code&gt;value&lt;/code&gt; 的元素的第一个 &lt;code&gt;count&lt;/code&gt; 出现。该 &lt;code&gt;count&lt;/code&gt; 参数影响在以下几个方面的工作：</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">从流中删除指定的条目,并返回被删除的条目数,在某些ID不存在的情况下,该数可能与传递给命令的ID数不同。</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 处存储的哈希中删除指定的字段。此哈希中不存在的指定字段将被忽略。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其视为空哈希，并且此命令返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">删除指定的键。如果键不存在,则忽略该键。</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">从存储在 &lt;code&gt;key&lt;/code&gt; 的排序集中删除指定的成员。不存在的成员将被忽略。</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">重命名 &lt;code&gt;key&lt;/code&gt; 来 &lt;code&gt;newkey&lt;/code&gt; 如果 &lt;code&gt;newkey&lt;/code&gt; 不存在。当 &lt;code&gt;key&lt;/code&gt; 不存在时，它将返回错误。</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 重命名为 &lt;code&gt;newkey&lt;/code&gt; 。当 &lt;code&gt;key&lt;/code&gt; 不存在时，它将返回错误。如果 &lt;code&gt;newkey&lt;/code&gt; 已经存在，它将被覆盖，这时&lt;a href=&quot;rename&quot;&gt;RENAME将&lt;/a&gt;执行隐式&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作，因此，即使&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;本身通常是恒定时间操作，如果删除的键包含很大的值，也可能导致高延迟。</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">副本广播其主服务器的配置时期（如果发现陈旧，则获得 &lt;code&gt;UPDATE&lt;/code&gt; 消息），因此副本的真实配置时期（或多或少是没有意义的，因为它们不提供哈希槽）仅获得检查标记为 &lt;code&gt;myself&lt;/code&gt; 的节点的信息，这是我们要求生成&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出的节点的条目。其他副本时期反映了它们在心跳数据包中发布的内容，即它们当前正在复制的母版的配置时期。</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">复制命令而不是脚本</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">在受密码保护的Redis服务器中请求身份验证。可以指示Redis在允许客户端执行命令之前要求输入密码。这是使用配置文件中的 &lt;code&gt;requirepass&lt;/code&gt; 指令完成的。</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">根据重置类型，或多或少剧烈地重置Redis群集节点，该节点可以是&lt;strong&gt;hard&lt;/strong&gt;或&lt;strong&gt;soft&lt;/strong&gt;。请注意，&lt;strong&gt;如果&lt;/strong&gt;主节点&lt;strong&gt;拥有一个或多个密钥&lt;/strong&gt;，&lt;strong&gt;则&lt;/strong&gt;该命令&lt;strong&gt;不适用于&lt;/strong&gt;主节点，在这种情况下，要完全重置主节点密钥，必须首先移除密钥，例如，首先使用&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;，然后再使用&lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令重置Redis报告的统计信息。</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">重新设置慢速日志。</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">将所有的哈希槽从D重新hard到节点A、B、C。</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">检索外部钥匙</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">从当前选择的数据库中返回一个随机密钥。</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">返回成功执行的最后一个数据库保存的UNIX TIME。客户端可以检查&lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt;命令是否成功读取了&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;值，然后发出&lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt;命令并每隔N秒定期检查&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE是否&lt;/a&gt;更改。</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">返回排序集所代表的地理空间索引中两个成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;返回填充有地理空间信息的排序集中的成员，这些成员位于以中心位置和距中心的最大距离（半径）指定的区域的边界内。</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">返回当前选择的数据库中的键数。</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">返回字符串中第一个设置为1或0的位的位置。</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">返回由&lt;em&gt;key&lt;/em&gt;的排序集表示的地理空间索引的所有指定成员的位置（经度，纬度）。</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">返回有效的&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;字符串，该字符串表示一个或多个元素在代表地理空间索引的排序后的集合值中的位置（使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;添加元素）。</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">返回值</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">返回最大条目数</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">在特定时间范围内退货。这是可能的，因为流ID &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;与时间有关&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">返回有关所有Redis命令的详细信息的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">返回有关多个Redis命令的详细信息的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">从完整的Redis命令返回键的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组答复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">返回此Redis服务器中命令总数的&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数回复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">如果未提供任何参数，则返回 &lt;code&gt;PONG&lt;/code&gt; ；否则，以批量形式返回该参数的副本。此命令通常用于测试连接是否仍处于活动状态或测量延迟。</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的所有字段名称。</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希的所有字段和值。在返回的值中，每个字段名后面都跟着它的值，因此答复的长度是哈希值的两倍。</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">返回所有匹配 &lt;code&gt;pattern&lt;/code&gt; 的键。</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的所有元素，其得分在 &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; 之间（包括得分等于 &lt;code&gt;max&lt;/code&gt; 或 &lt;code&gt;min&lt;/code&gt; 的元素）。与排序集的默认排序相反，对于此命令，将元素视为从高分到低分排序。</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的所有元素，且其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 之间（包括分数等于 &lt;code&gt;min&lt;/code&gt; 或 &lt;code&gt;max&lt;/code&gt; 的元素）。这些元素被认为是从低到高排序。</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的设置值的所有成员。</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希值。</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">返回一个整数,标识指定的密钥散列到的散列槽。这条命令主要用于调试和测试,因为它通过API公开了哈希算法的底层Redis实现。此命令的使用实例。</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;field&lt;/code&gt; 是否是存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的现有字段。</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 存在。</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回是否 &lt;code&gt;member&lt;/code&gt; 是存储在 &lt;code&gt;key&lt;/code&gt; 处的集合的成员。</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">返回关于脚本缓存中脚本存在的信息。</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">返回或存储包含在元素&lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;列表&lt;/a&gt;，&lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;集&lt;/a&gt;或&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;排序集合&lt;/a&gt;的 &lt;code&gt;key&lt;/code&gt; 。默认情况下，排序是数字形式的，并且将元素的值进行比较以解释为双精度浮点数。这是最简单形式的&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">返回&lt;em&gt;key处&lt;/em&gt;存储的字符串值中&lt;em&gt;offset&lt;/em&gt;处的位值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表中index &lt;code&gt;index&lt;/code&gt; 处的元素。索引从零开始，因此 &lt;code&gt;0&lt;/code&gt; 表示第一个元素， &lt;code&gt;1&lt;/code&gt; 表示第二个元素，依此类推。负索引可用于指定从列表末尾开始的元素。在这里， &lt;code&gt;-1&lt;/code&gt; 表示最后一个元素， &lt;code&gt;-2&lt;/code&gt; 表示倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的长度。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将其解释为空列表并返回 &lt;code&gt;0&lt;/code&gt; 。当 &lt;code&gt;key&lt;/code&gt; 处存储的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的字符串值的长度。当 &lt;code&gt;key&lt;/code&gt; 包含非字符串值时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">返回第一个集合和所有连续集合之间的差值所产生的集合成员。</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">返回所有给定集合的交集的成员。</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">返回所有给定集合的结合所产生的集合的成员。</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的元素数，其分数介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">返回流中的条目数。如果指定的键不存在，则命令返回零，就像流为空一样。但是请注意，与其他Redis类型不同，零长度流是可能的，因此应调用&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt;或&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;来检查密钥是否存在。</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中包含的字段数。</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">返回指定 Redis Cluster 哈希槽中的键数。该命令只查询本地数据集,因此,联系一个不为指定哈希槽服务的节点将始终导致返回零的计数。</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">返回指定频道的订阅者数量(不包括订阅模式的客户)。</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">返回模式的预订数量（使用&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;命令执行）。请注意，这不仅是已订阅模式的客户端数，而且是所有客户端已订阅的模式总数。</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 中的排序集中的 &lt;code&gt;member&lt;/code&gt; 的排名，其得分从高到低排序。等级（或索引）是从0开始的，这意味着得分最高的成员的等级是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 中的排序集中的 &lt;code&gt;member&lt;/code&gt; 的排名，其得分从低到高排序。等级（或索引）是基于0的，这意味着得分最低的成员的等级为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">返回已超时的key的剩余生存时间。这个自省功能允许Redis客户端检查一个给定的key将继续成为数据集的一部分的时间。</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;key&lt;/code&gt; 排序集中的 &lt;code&gt;member&lt;/code&gt; 得分。</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的集合的集合基数（元素数）。</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集合的排序集合基数（元素数）。</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的指定元素。偏移量 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 是从零开始的索引， &lt;code&gt;0&lt;/code&gt; 是列表的第一个元素（列表的开头）， &lt;code&gt;1&lt;/code&gt; 是下一个元素，依此类推。</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集中的元素的指定范围。这些元素被认为是从最高得分到最低得分排序的。降序字典顺序用于分数相等的元素。</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的排序集中的元素的指定范围。元素被认为是从最低得分到最高得分排序的。字典顺序用于分数相等的元素。</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 处存储的哈希中的 &lt;code&gt;field&lt;/code&gt; 关联的值的字符串长度。如果 &lt;code&gt;key&lt;/code&gt; 或 &lt;code&gt;field&lt;/code&gt; 不存在，则返回0。</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的值的类型的字符串表示形式。可以返回的不同类型是： &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;zset&lt;/code&gt; 和 &lt;code&gt;hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">返回存储在 &lt;code&gt;key&lt;/code&gt; 处的字符串值的子字符串，该字符串由偏移量 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; （包括两端）确定。可以使用负偏移量来提供从字符串末尾开始的偏移量。因此-1表示最后一个字符，-2表示倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 中存储的哈希中的 &lt;code&gt;field&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;key&lt;/code&gt; 中存储的哈希中的指定 &lt;code&gt;fields&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">返回所有指定键的值。对于每个不包含字符串值或不存在的键，将返回特殊值 &lt;code&gt;nil&lt;/code&gt; 。因此，操作永远不会失败。</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">使用&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT &lt;/a&gt;&lt;em&gt;开始&lt;/em&gt;和&lt;em&gt;结束&lt;/em&gt;可选参数递增地运行位图，在客户端累积结果，并可选地将结果缓存到密钥中。</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD key member [member ...]将一个或多个成员添加到一组中。</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE 同步将数据集保存到磁盘。</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">SAVE和NOSAVE修改器</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN光标[MATCH模式][COUNT计数]递增迭代键空间。</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN基本用法</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN是一个基于游标的迭代器。这意味着在每次调用命令时,服务器都会返回一个更新的游标,用户需要在下一次调用中使用这个游标作为参数。</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD key 获取集合中的成员数。</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO 设置执行脚本的调试模式。</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]检查脚本缓存中是否存在脚本。</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">稿件冲洗</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH 从脚本缓存中删除所有脚本。</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">SCRIPT KILL</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 杀死当前正在执行的脚本。</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD 脚本 将指定的 Lua 脚本加载到脚本缓存中。</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF键[键...]减去多组。</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 目标键 [键...]减去多个集合,并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT index 更改当前连接的选定数据库。</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET 键值 [过期 EX 秒|PX 毫秒][NX|XX]设置键的字符串值。</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT 键偏移值 设置或清除存储在键的字符串值中偏移的位。</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX 键秒值 设置键的值和到期时间。</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX 键值 设置键值,只有当键不存在时才设置。</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE 键偏移值 覆盖指定偏移量开始的键的部分字符串。</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]同步保存数据集到磁盘,然后关闭服务器。</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER键[键...]多组相交。</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE 目的键 [key ...]交叉多个集合,并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER 关键成员 确定一个给定的值是否是一个集合的成员。</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF 主机端口 使服务器成为另一个实例的副本,或将其升级为主服务器。从Redis 5开始已经废弃,使用REPLICAOF代替。</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOG子命令[参数]管理Redis慢速查询日志。</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS键 获取一个集合中的所有成员。</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE源目标成员 将一个成员从一个集合移动到另一个集合。</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORT键 [BY pattern][LIMIT offset count][GET pattern [GET pattern ...]]。[ASC|DESC][ALPHA][STORE destination]对列表、集合或排序集合中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP键[count]从一个集合中删除并返回一个或多个随机成员。</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER key [count]从一个集合中获取一个或多个随机成员。</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM关键成员 [成员...]从一组成员中删除一个或多个成员。</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN键光标[MATCH模式][COUNT计数]递增迭代 设置元素。</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN 键 获取存储在键中的值的长度。</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE channel [channel ...]听取发布到给定频道的消息。</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION键[键......]添加多组。</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 目标键 [键...]添加多个集并将结果存储在一个键中。</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB索引索引交换两个Redis数据库。</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC 用于复制的内部命令</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">结果格式与&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt;相同，但您可以指定要返回的命令。</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">样本输出(新版本,包括IDs</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">样本输出(旧版</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">沙盒和最大执行时间</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">将数据库保存在后台。OK代码将立即返回。Redis分叉，父级继续为客户端提供服务，子级将DB保存在磁盘上，然后退出。客户端可以使用&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;命令检查操作是否成功。</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">扫描保证</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">脚本缓存语义</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">脚本也受到最大执行时间的限制(默认为5秒)。这个默认的超时时间是巨大的,因为一个脚本通常应该在一毫秒内运行。这个限制主要是为了处理开发过程中意外产生的无限循环。</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">脚本作为纯函数</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">脚本永远不应该尝试访问外部系统,比如文件系统或任何其他系统调用。脚本应该只对Redis数据和传递的参数进行操作。</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">第二个副本</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">有关文档，请参见&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">有关递增/递减操作的更多信息，请参见&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;以获取&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;以获取&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">见&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;为&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">当您需要元素从最高到最低排序（对于具有相同得分的元素按字典顺序降序排列）时，请参见&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">另请参阅以毫秒为单位的分辨率返回相同信息的&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;命令（仅在Redis 2.6或更高版本中可用）。</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">有关确切的语义，请参阅&lt;a href=&quot;blpop&quot;&gt;BLPOP文档&lt;/a&gt;，因为&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;与BLPOP相同，唯一的不同是&lt;a href=&quot;blpop&quot;&gt;BRPOP&lt;/a&gt;从列表的尾部弹出元素而不是从头部弹出。</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">有关确切的语义，请参阅&lt;a href=&quot;blpop&quot;&gt;BLPOP文档&lt;/a&gt;，因为&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;与&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;相同，唯一的区别是要从中弹出数据结构。</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">见&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN文档&lt;/a&gt;的确切语义，因为&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt;是相同的&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;唯一的区别是它弹出得分最高的，而不是弹出得分最低的那些成员。</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">有关有趣的用例，请参见名为&amp;ldquo; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;使用Redis位图的快速便捷实时度量&lt;/a&gt; &amp;rdquo;的文章。</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">选择具有指定的基于零的数字索引的Redis逻辑数据库。新连接总是使用数据库0。</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">有选择地复制命令</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">哨兵输出</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">序列化格式</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">以Redis特定的格式序列化存储在key处的值，并将其返回给用户。可以使用&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;命令将返回的值合成回Redis密钥。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 来保存字符串 &lt;code&gt;value&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 不存在。在这种情况下，它等于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;。当 &lt;code&gt;key&lt;/code&gt; 已经具有值时，将不执行任何操作。&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;是短期的&amp;ldquo; &lt;strong&gt;SET&lt;/strong&gt;如果&lt;strong&gt;&amp;ntilde;&lt;/strong&gt; OT&amp;Euml; &lt;strong&gt;X&lt;/strong&gt;派&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 以保留字符串 &lt;code&gt;value&lt;/code&gt; ，并将 &lt;code&gt;key&lt;/code&gt; 设置为在给定的秒数后超时。此命令等效于执行以下命令：</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">设置 &lt;code&gt;key&lt;/code&gt; 以保存字符串 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 已经包含一个值，则无论其类型如何，它都会被覆盖。成功进行&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作后，与密钥关联的任何先前生存时间都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">在 &lt;code&gt;key&lt;/code&gt; 上设置超时。超时到期后，密钥将自动删除。在Redis术语中，通常将具有相关超时的键称为&lt;em&gt;可变&lt;/em&gt;键。</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">将使用者组&lt;em&gt;上次交付的ID设置&lt;/em&gt;为其他名称。</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">为使用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;执行的后续脚本设置调试模式。Redis包含一个完整的Lua调试器，代号LDB，可用于简化编写复杂脚本的任务。在调试模式下，Redis充当远程调试服务器，并且客户端（例如 &lt;code&gt;redis-cli&lt;/code&gt; ）可以逐步执行脚本，设置断点，检查变量等-有关LDB的其他信息，请参阅&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua调试器&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; 将目标节点插槽设置为&lt;em&gt;导入&lt;/em&gt;状态。</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; 将源节点插槽设置为&lt;em&gt;迁移&lt;/em&gt;状态。</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">仅当 &lt;code&gt;field&lt;/code&gt; 尚不存在时，才将存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的 &lt;code&gt;field&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果 &lt;code&gt;field&lt;/code&gt; 已经存在，则此操作无效。</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">将存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的 &lt;code&gt;field&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果哈希中已经存在该 &lt;code&gt;field&lt;/code&gt; ，则将其覆盖。</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">集可以编码为 &lt;code&gt;intset&lt;/code&gt; 或 &lt;code&gt;hashtable&lt;/code&gt; 。该 &lt;code&gt;intset&lt;/code&gt; 是用于单纯的整数组成的小集的特殊编码。</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">设置或清除&lt;em&gt;key处&lt;/em&gt;存储的字符串值中&lt;em&gt;offset&lt;/em&gt;处的位。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">将给定的键设置为其各自的值。与常规&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;一样，&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;用新值替换现有值。如果您不想覆盖现有值，请参见&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">将给定的键设置为其各自的值。即使仅存在一个密钥，&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;也不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;index&lt;/code&gt; 处的list元素设置为 &lt;code&gt;value&lt;/code&gt; 。有关 &lt;code&gt;index&lt;/code&gt; 参数的更多信息，请参见&lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">将指定字段设置为存储在 &lt;code&gt;key&lt;/code&gt; 处的哈希中的相应值。该命令将覆盖哈希中已经存在的所有指定字段。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">同理,要想得到只是添加到流中的最后一个元素,只需发送。</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">简单的字符串回复</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">由于&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;和&lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt;具有 &lt;code&gt;STORE&lt;/code&gt; 和 &lt;code&gt;STOREDIST&lt;/code&gt; 选项，因此从技术上讲，它们在Redis命令表中标记为正在写入命令。因此，只读副本将对其进行标记，即使连接处于只读模式，Redis Cluster副本也会将其重定向到主实例（请参阅Redis Cluster 的&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">由于&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;返回在失败和成功情况下都达到的副本数，因此客户端应检查返回的值等于或大于其所需的复制级别。</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">从Redis 2.4开始，AOF重写是由Redis自动触发的，但是&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;命令可随时用于触发重写。</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">从Redis 2.6开始,过期误差从0到1毫秒。</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">从Redis 3.0.3开始,可以指定多个键而不是一个键。在这种情况下,它返回的是现有键的总数。需要注意的是,对单个键返回1或0只是变量用法的一种特殊情况,所以该命令完全向后兼容。</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">自Redis 3.0.3以来,该命令接受的键数是可变的,返回值是通用的。</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">从Redis 3.2.10/4.0.0开始,这个命令还可以防止在客户端暂停的时间内键被驱逐或过期。这样一来,不仅从客户机无法写入的角度,而且从内部操作的角度,都能保证数据集的静态。</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">由于在第二次调用中返回的游标为0，因此服务器向调用者发出信号，告知迭代已完成，并且已完全浏览了该集合。从游标值0开始迭代，然后调用&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;直到返回的游标再次为0称为&lt;strong&gt;完整迭代&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">由于 &lt;code&gt;increment&lt;/code&gt; 参数是带符号的，因此可以执行递增和递减操作：</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">由于当前选择的数据库是连接的属性，因此客户端应跟踪当前选择的数据库并在重新连接时重新选择它。虽然没有命令可以查询当前连接中的选定数据库，但是&lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;输出为每个客户端显示了当前选定的数据库。</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">自从引入了与副本的部分重新同步(PSYNC特性),Redis副本就会用它们在复制流中已经处理过的偏移量异步ping它们的主站。这有多种方式使用。</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">由于没有状态服务器端,但完整的状态被游标捕获,调用者可以自由地中途终止迭代,而不以任何方式向服务器发出信号。可以启动无限次的迭代,而且永远不会终止,不会出现任何问题。</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">由于这些命令允许增量迭代，每次调用仅返回少量元素，因此可以在生产中使用它们，而不会受到诸如&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;或&lt;a href=&quot;smembers&quot;&gt;SMEMBERS之&lt;/a&gt;类的命令的不利影响，这些命令在被调用时可能会长时间（甚至几秒钟）阻塞服务器键或元素的大集合。</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">由于这涉及到近似,为了避免C被设置为,比如,0.998而不是1,我们只需修改上面的算法,以确保最后的分数是1(留给读者作为练习......)。</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">从版本2.1.6开始，遵循&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;的语法， &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 可以是排他的。</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">单一号码:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">跳过对元素的排序</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">因此，例如，命令 &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; 将以以下方式返回每个项目：</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">因此,例如,要从较高ID到较低ID的所有元素可以使用。</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">所以,为了让一个给定的节点接受另一个节点进入组成Redis Cluster的节点列表,只有两种方式。</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">因此，我们从键列表开始，然后继续所有相关的ID，代表&lt;em&gt;我们为该流接收的最后一个ID&lt;/em&gt;，以便该调用仅向我们提供来自同一流的更大的ID。</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">所以这个命令真正的作用是:</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">因此，如果我们通过&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;将节点A与节点B链接起来，而将B与C链接起来，则A和C将找到握手和创建链接的方式。</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">因此，使用 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; 时，在创建新集群时，我们可以在将集群连接在一起之前为每个节点分配不同的渐进配置时代。</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">某些Redis命令没有预定的键位置。对于这些命令，将标志 &lt;code&gt;movablekeys&lt;/code&gt; 添加到命令标志&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;。您的Redis Cluster客户端需要解析标记为可 &lt;code&gt;movablekeys&lt;/code&gt; 键的命令以找到所有相关键的位置。</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">一些使用者A 在该使用者组的上下文中通过&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;从流中读取消息。</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">有时,对于客户端来说,完全禁用Redis服务器的回复是很有用的。例如,当客户端发送fire and forget命令或执行大量数据加载时,或者在新数据不断流的缓存环境中。在这样的情况下,为了给客户端发送回复而使用服务器的时间和带宽,而这些回复是会被忽略的,这被认为是浪费。</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">有时，您想使用外部键作为权重对元素进行排序，以进行比较，而不是比较列表，集合或排序集中的实际元素。比方说，清单 &lt;code&gt;mylist&lt;/code&gt; 包含的元素 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 表示存储在对象的唯一ID &lt;code&gt;object_1&lt;/code&gt; ， &lt;code&gt;object_2&lt;/code&gt; 和 &lt;code&gt;object_3&lt;/code&gt; 。当这些对象具有关联的权重存储在 &lt;code&gt;weight_1&lt;/code&gt; ， &lt;code&gt;weight_2&lt;/code&gt; 和 &lt;code&gt;weight_3&lt;/code&gt; 中时，可以通过以下语句指示&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;使用这些权重对 &lt;code&gt;mylist&lt;/code&gt; 进行排序：</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">排序集</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">排序集可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;skiplist&lt;/code&gt; 格式。至于列表类型小的有序集合可使用特殊编码 &lt;code&gt;ziplist&lt;/code&gt; ，而 &lt;code&gt;skiplist&lt;/code&gt; 编码是一个与有序集合任何大小的作品。</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">排序套路 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">已排序的集合按其得分以升序排序。同一元素仅存在一次，不允许重复元素。既可以通过将更新元素得分的&lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt;以及作为副作用的得分来修改得分，也可以通过ZINCRBY对其进行修改，而&lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt;可以用来相对于其先前值更新得分。</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">按外部键排序</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">不允许执行命令的特殊情况</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">特殊时段条目</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">具体来说,如果一个给定的写被传输到一个或多个副本,那么如果主控失败,我们更有可能(但不能保证)在故障转移期间,能够推广收到写的副本:Sentinel和Redis Cluster都会尽最大努力尝试在一组可用的副本中推广最好的副本。</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">具体来说就是Redis每秒做10次。</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">指定通过count时的行为</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">指定一个流ID作为参数</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">起始槽范围</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">从Redis版本2.6开始，当使用额外的 &lt;code&gt;count&lt;/code&gt; 参数调用时，如果 &lt;code&gt;count&lt;/code&gt; 为正，则返回由 &lt;code&gt;count&lt;/code&gt; 个&lt;strong&gt;不同元素组成&lt;/strong&gt;的数组。如果调用的 &lt;code&gt;count&lt;/code&gt; 为负，则行为会更改，并且命令可以&lt;strong&gt;多次&lt;/strong&gt;返回&lt;strong&gt;同一元素&lt;/strong&gt;。在这种情况下，返回的元素数是指定 &lt;code&gt;count&lt;/code&gt; 的绝对值。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">从Redis 2.6.12开始，&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;支持一组用于修改其行为的选项：</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">从Redis 2.8开始,出错时的返回值发生了变化。</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">从Redis 3.0.6开始，&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;支持一种新的批量迁移模式，该模式使用流水线操作，以便在实例之间迁移多个密钥，而不会产生往返时间延迟以及使用单个&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;调用移动每个密钥时的其他开销。</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">从Redis 3.2开始，Redis支持本地Lua调试。Redis Lua调试器是一个远程调试器，由服务器（即Redis本身）和客户端（默认情况下为 &lt;code&gt;redis-cli&lt;/code&gt; )组成。</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">从Redis 3.2开始，可以选择其他复制方法。除了复制整个脚本，我们还可以复制脚本生成的单个写入命令。我们将此&lt;strong&gt;脚本&lt;/strong&gt;称为&lt;strong&gt;复制效果&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">从技术上讲，步骤4不需要在 &lt;code&gt;SETSLOT&lt;/code&gt; 不涉及的节点中使用SETSLOT，因为配置最终会自行传播，但是这样做是一个好主意，以阻止节点指向哈希槽的错误节点尽快移动，从而减少了找到正确节点的重定向。</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">步数</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">停止所有的客户。</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">存储SORT操作的结果</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">流ID由两部分组成：Unix毫秒时间戳和在同一毫秒中插入的条目的序列号。可以使用&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;仅指定ID的第一部分（毫秒），如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">一旦流中没有任何条目（例如，在&lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt;调用之后），流就不会被自动删除，因为该流可能具有与之关联的使用者组。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">字符串以二进制字节数组的形式进行比较。由于ASCII字符集是如何被指定的,这意味着通常这也有一个明显的字典方式比较普通ASCII字符的效果。然而,如果使用非纯ASCII字符串(例如utf8字符串),则不是这样。</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">字符串可以编码为 &lt;code&gt;raw&lt;/code&gt; （常规字符串编码）或 &lt;code&gt;int&lt;/code&gt; （以64位有符号间隔表示整数的字符串以这种方式编码，以节省空间）。</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">前缀相近的字符串就在附近,反之则不然,有可能不同前缀的字符串也在附近。</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">子命令 &lt;code&gt;encoding&lt;/code&gt; 返回批量答复。</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">子命令 &lt;code&gt;refcount&lt;/code&gt; 和 &lt;code&gt;idletime&lt;/code&gt; 返回整数。</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">将客户端订阅给定模式。</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">将客户端订阅到指定的频道。</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDING汇总表</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">支持的球型图案。</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">支持的子命令和整数类型</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">TAKEOVER选项:在没有群集共识的情况下进行手动故障切换。</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 返回当前服务器时间</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH key [key ...]改变一个或多个钥匙的最后访问时间。返回指定的现有钥匙的数量。</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL键 获取键的生存时间。</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE键 确定存储在键的类型。</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">取一个分离的键,每次修改位图时都会递增。使用一个小的Redis Lua脚本,这可以是非常高效和原子的。</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">终止中间的迭代</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">从具有关联过期的密钥集中随机测试20个密钥。</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">感谢&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;和类似的&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;命令，您可以将Redis字符串用作具有O（1）随机访问的线性数组。在许多实际使用案例中，这是一种非常快速高效的存储。</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">就是说，&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;可以用作锁定原语，并且在过去一直被用作锁定原语。例如，要获取键 &lt;code&gt;foo&lt;/code&gt; 的锁，客户端可以尝试以下操作：</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">的&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt;命令可以用来创建固定大小的示例的列表的一个非常紧凑的表示中，通常被称为&lt;em&gt;时间序列&lt;/em&gt;。每次有新样品到达时，我们可以使用以下命令将其存储</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">该&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt;命令支持四个位运算：&lt;strong&gt;AND&lt;/strong&gt;，&lt;strong&gt;OR&lt;/strong&gt;，&lt;strong&gt;XOR&lt;/strong&gt;和&lt;strong&gt;NOT&lt;/strong&gt;，从而有效形式调用命令是：</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">该&lt;a href=&quot;client-getname&quot;&gt;客户端的GetName&lt;/a&gt;返回当前连接作为集的名称&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;。由于每个新连接都在没有关联名称的情况下开始，因此，如果未分配名称，则返回空批量答复。</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">该&lt;a href=&quot;client-kill&quot;&gt;客户端KILL&lt;/a&gt;命令关闭一个给定的客户端连接。在Redis 2.8.11之前，可以使用以下格式仅通过客户端地址关闭连接：</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">该&lt;a href=&quot;client-list&quot;&gt;客户名单&lt;/a&gt;命令返回的信息和统计信息的大多是人类可读的格式的客户端连接服务器。</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">该&lt;a href=&quot;client-reply&quot;&gt;客户端REPLY&lt;/a&gt;命令控制服务器是否会回复客户端的命令。可以使用以下模式：</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">该&lt;a href=&quot;client-setname&quot;&gt;客户端SETNAME&lt;/a&gt;命令指定一个名称为当前连接。</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">的&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt;命令是为了使用Redis的群集迁移所有包含在一个哈希位置从一个节点到另一个的钥匙的一个重要部件。这也是在其他命令的帮助下协调迁移的方式。我们将拥有哈希槽当前所有权的节点称为 &lt;code&gt;source&lt;/code&gt; 节点，并将我们要迁移 &lt;code&gt;destination&lt;/code&gt; 节点的节点称为&amp;ldquo; 源&amp;rdquo;节点。</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">在&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt;命令用于读取一个运行Redis的服务器的配置参数。Redis 2.4并不支持所有配置参数，而Redis 2.6可以使用此命令读取服务器的整个配置。</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">该&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt;命令重写 &lt;code&gt;redis.conf&lt;/code&gt; 服务器启动时使用的文件，应用，使其反映当前使用的服务器配置所需的最小的变化，相对于因为使用的原来这可能是不同的&lt;a href=&quot;config-set&quot;&gt;配置集&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">该&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;命令，以重新配置在运行时服务器，而不需要重启Redis的使用。您可以使用此命令更改这两个琐碎的参数或从一个持久性选项切换到另一个持久性选项。</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">该&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;命令迫使你一次又一次地发送脚本主体。Redis不需要每次都重新编译脚本，因为它使用内部缓存机制，但是在许多情况下，支付额外带宽的成本可能不是最优的。</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">该&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;命令的家庭能够联想到的到期给定的关键，在通过按键使用了一些额外的内存成本。当密钥设置了过期时，Redis将确保在经过指定的时间后删除密钥。</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">该&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令返回的信息和统计信息的格式很简单通过计算机来分析和容易被人读取服务器。</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">该&lt;a href=&quot;memory-doctor&quot;&gt;内存神医&lt;/a&gt;约不同的内存相关的问题命令报告Redis的服务器的经验，并建议对可能的补救措施。</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">的&lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt;命令返回描述不同子一个有用的文本。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
