<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="75d00cd00e1f2b13a890f0d28b95cf6fbe73de9c" translate="yes" xml:space="preserve">
          <source>An error is returned for out of range indexes.</source>
          <target state="translated">对于超出范围的索引会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="e1e52880ba8cd5516094695a791c7cb25bb9cf75" translate="yes" xml:space="preserve">
          <source>An error is returned if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;destination&lt;/code&gt; does not hold a set value.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 或 &lt;code&gt;destination&lt;/code&gt; 不具有设置值，则返回错误。</target>
        </trans-unit>
        <trans-unit id="c6dddcbd9570408a2bf9a7b091594de5d13db0b1" translate="yes" xml:space="preserve">
          <source>An error is returned if there is already a background save running or if there is another non-background-save process running, specifically an in-progress AOF rewrite.</source>
          <target state="translated">如果已经有一个后台保存程序在运行,或者有另一个非后台保存程序在运行,特别是一个正在进行的AOF重写,则会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="f347bee22b5d2cb10d2901659685fcd72a034c77" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists and does not hold a sorted set.</source>
          <target state="translated">当 &lt;code&gt;key&lt;/code&gt; 存在且不包含排序集时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">当 &lt;code&gt;key&lt;/code&gt; 存在但不包含列表值时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">当 &lt;code&gt;key&lt;/code&gt; 存在但不包含排序集时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">如果 &lt;code&gt;seconds&lt;/code&gt; 无效，则返回错误。</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 处存储的值未设置，则返回错误。</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">一个哨兵输出的例子。</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">在主实例中调用&lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt;时的输出示例：</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">在副本实例中调用&lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt;时的输出示例：</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">一个解锁脚本的例子类似于以下。</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">使用固定大小的字符串对传感器的温度进行采样的例子(在实际实现中使用二进制格式更好)。</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">使用 &lt;code&gt;SORT ... STORE&lt;/code&gt; 一种有趣模式在于将&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;超时与结果键相关联，以便在&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;操作的结果可以缓存一段时间的应用程序中使用。其他客户端将使用缓存的列表，而不是为每个请求调用&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;。当密钥超时时，可以通过再次调用 &lt;code&gt;SORT ... STORE&lt;/code&gt; 创建缓存的更新版本。</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">当游标设置为0时开始迭代,当服务器返回的游标为0时结束迭代,下面是一个SCAN迭代的例子。</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">因此，直到迭代完成且没有返回结果。有关更多信息，请参见&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">诸如此类。</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">依此类推。最终，这将允许访问流中的所有条目。显然，通过提供给定的不完整的开始ID，我们可以从任何ID甚至从特定时间开始迭代。此外，我们可以通过提供结束ID或不完整的ID而不是 &lt;code&gt;+&lt;/code&gt; 来将迭代限制为给定的ID或时间。</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">以此类推。最终,调用不会返回任何项目,而只是返回一个空数组,那么我们就知道,从我们的流中已经没有什么可获取的了(我们将不得不重试操作,因此这个命令也支持阻塞模式)。</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">另一个例子:如果我们想象一个由以下四个节点组成的集群,分别称为A、B、C和D,我们可以只向A发送以下一组命令。</target>
        </trans-unit>
        <trans-unit id="852a8d39c81588746b082fd9f4167b5bb251bb69" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command with IDs greater than the one provided. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: messages delivered to it, but not yet acknowledged. Note that in this case, both &lt;code&gt;BLOCK&lt;/code&gt; and &lt;code&gt;NOACK&lt;/code&gt; are ignored.</source>
          <target state="translated">任何其他ID（即0或任何其他有效ID或不完整的ID（仅毫秒时间部分））将具有以下作用：返回正在发送给消费者的条目，这些条目正在等待用户发送比所提供的ID更大的ID的命令。因此，基本上，如果ID不是 &lt;code&gt;&amp;gt;&lt;/code&gt; ，那么该命令将只允许客户端访问其挂起的条目：传递给它的消息，但尚未确认。请注意，在这种情况下， &lt;code&gt;BLOCK&lt;/code&gt; 和 &lt;code&gt;NOACK&lt;/code&gt; 都将被忽略。</target>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">任何其他ID，即0或任何其他有效ID或不完整的ID（仅毫秒时间部分），将具有返回正在等待发送该命令的使用者的条目的作用。因此，基本上，如果ID不是 &lt;code&gt;&amp;gt;&lt;/code&gt; ，那么该命令将只允许客户端访问其未决条目：已交付给它，但尚未确认。</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">无论如何，即使假设一个单实例锁定原语（从2.6.12开始），也可以使用&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令获取该锁定，并使用一个简单的Lua脚本来释放一个简单得多的锁定原语（等效于此处讨论的锁定原语）。锁。该模式记录在&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令页面中。</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">除了相反的顺序外，&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt;与&lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;相似。</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">除了相反的顺序外，&lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt;与&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;相似。</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">除了相反的顺序外，&lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt;与&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;相似。</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">附录。Redis过期</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">将指定的流条目添加到指定的键处的流中。如果key不存在,作为运行此命令的副作用,key将被创建为一个流值。</target>
        </trans-unit>
        <trans-unit id="32f650d6228cf15fb1f6755ed7de0b1329f744eb" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="translated">将指定的流条目附加到指定键处的流。如果键不存在，则作为运行此命令的副作用，将使用流值创建键。可以使用 &lt;code&gt;NOMKSTREAM&lt;/code&gt; 选项禁用流密钥的创建。</target>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">副作用是，在使用者组的未决条目列表（PEL）中创建了未决消息条目：这意味着消息已传递给给定的使用者，但尚未通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;确认。</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">作为 &lt;code&gt;A&lt;/code&gt; 知道并为所有其他节点所知的副作用，它将在心跳数据包中发送八卦节，这将允许彼此之间的节点彼此建立链接，并在几秒钟内形成一个完整的网格，即使群集很大。</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">作为命令执行的副作用，如果将指定为参数的插槽中的一个插槽设置为 &lt;code&gt;importing&lt;/code&gt; ，则一旦节点为其自身分配了（以前未绑定的）插槽，该状态就会被清除。</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">作为命令执行的副作用，由于未覆盖所有哈希槽，因此节点可能进入&lt;em&gt;关闭&lt;/em&gt;状态。</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">作为该命令的副作用,HyperLogLog内部可能会被更新,以反映到目前为止所添加的独特项目数量的不同估计(集合的基数)。</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">如前所述，对 &lt;code&gt;redis.call()&lt;/code&gt; 的调用会导致Redis命令错误，这将停止脚本的执行并返回错误，从而使错误很明显是由脚本生成的：</target>
        </trans-unit>
        <trans-unit id="09ac6956fbf7cebafd273a67f1e1e0cc18c9d7d7" translate="yes" xml:space="preserve">
          <source>As of Redis 4.0.0, HSET is variadic and allows for multiple &lt;code&gt;field&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">从Redis 4.0.0开始，HSET是可变的，并且允许多个 &lt;code&gt;field&lt;/code&gt; / &lt;code&gt;value&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">从v5.0开始，可选的 &lt;code&gt;TYPE type&lt;/code&gt; 子命令可用于按客户端类型过滤列表，其中&lt;em&gt;type&lt;/em&gt;是 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;master&lt;/code&gt; ， &lt;code&gt;replica&lt;/code&gt; 和 &lt;code&gt;pubsub&lt;/code&gt; 之一。请注意，被阻塞在&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;命令中的客户端被认为属于 &lt;code&gt;normal&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="f7fd0e1ced5f80a8c1942174a609b55088d136aa" translate="yes" xml:space="preserve">
          <source>As of version 6.0 you can use this option to ask &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to only return objects that match a given &lt;code&gt;type&lt;/code&gt;, allowing you to iterate through the database looking for keys of a specific type. The &lt;strong&gt;TYPE&lt;/strong&gt; option is only available on the whole-database &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, not &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; or &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; etc.</source>
          <target state="translated">从6.0版开始，您可以使用此选项要求&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;仅返回与给定 &lt;code&gt;type&lt;/code&gt; 匹配的对象，从而允许您遍历数据库以查找特定类型的键。该&lt;strong&gt;类型&lt;/strong&gt;选项只是整个数据库上可用&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;，不&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;或&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="1f512cd2f467fc007a16339b78f3f8bd4aa4ddc3" translate="yes" xml:space="preserve">
          <source>As per Redis 4.0.0, HMSET is considered deprecated. Please use &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; in new code.</source>
          <target state="translated">根据Redis 4.0.0，HMSET被视为已弃用。请在新代码中使用&lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52e2ff1f75cd0a86ae75552c78ee5cbb2c5d2636" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2, GETSET is considered deprecated. Please use &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; parameter in new code.</source>
          <target state="translated">根据Redis 6.2，GETSET被视为已弃用。请在新代码中将&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;与&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;参数一起使用。</target>
        </trans-unit>
        <trans-unit id="eca69203d6944d9aedfa83b1745a14df6f143d34" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, BRPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">根据Redis 6.2.0，BRPOPLPUSH被视为已弃用。请在新代码中使用&lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50625700b094276571780430ad92d3906e72fb6e" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, RPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">根据Redis 6.2.0，RPOPLPUSH被视为已弃用。请在新代码中使用&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cf598b1b6e40341f8808136a0a46e1f4d5d8d97" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, &lt;em&gt;somekey&lt;/em&gt; is excluded, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">如您所见，将3.333转换为3，排除了&lt;em&gt;somekey&lt;/em&gt;，并且从不返回&lt;em&gt;bar&lt;/em&gt;字符串，因为之前没有nil。</target>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">如您所见，将3.333转换为3，并且由于之前没有nil，所以永远不会返回&lt;em&gt;bar&lt;/em&gt;字符串。</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">如您所见，&lt;strong&gt;NOT&lt;/strong&gt;是特殊的，因为它只需要一个输入键，因为它执行位的反转，因此仅作为一元运算符才有意义。</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">如您所见，以这种方式删除节点很脆弱，我们需要尽快向所有节点发送&lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt;命令，以希望在此期间不进行任何闲聊部分的处理。由于这个问题，该命令为每个条目实现了一个带有过期时间的禁止列表。</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">正如你所看到的,大部分的调用都返回了零元素,但最后一次调用中使用了count 1000,以迫使命令对该迭代进行更多的扫描。</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">如您所见，&lt;strong&gt;SCAN返回值&lt;/strong&gt;是两个值的数组：第一个值是在下一个调用中使用的新游标，第二个值是元素的数组。</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">要求服务器关闭连接。一旦所有待定的回复被写入客户端,该连接就会被关闭。</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">给自己分配其主站的所有哈希槽,并将新的配置传播给ASAP可到达的每个节点,最终传播给其他每个节点。</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">假设 &lt;code&gt;mylist&lt;/code&gt; 是一个数字列表，此命令将返回相同的列表，其元素从小到大排序。为了将数字从大到小排序，请使用 &lt;code&gt;DESC&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="010bc7ebc048785c84f0ef161a24878d38afdc74" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; commands only delete keys that were present at the time the command was invoked. Keys created during an asynchronous flush will be unaffected.</source>
          <target state="translated">异步&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;和&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;命令仅删除调用该命令时存在的键。在异步刷新期间创建的密钥将不受影响。</target>
        </trans-unit>
        <trans-unit id="917fb2b280881b904605b028a37696fbc08e07d1" translate="yes" xml:space="preserve">
          <source>At this point the new conversions are available, specifically:</source>
          <target state="translated">在这一点上,新的转换是可用的,具体。</target>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">这时你用这个算法把所有的元素加到一个排序集合中。</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">此时，每次您想要获得加权随机元素时，只需计算0到1之间的随机数即可（这就像在大多数语言中调用 &lt;code&gt;rand()&lt;/code&gt; 一样），因此您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">原子重写过程</target>
        </trans-unit>
        <trans-unit id="9081c20623d6921cb283f837b5ab328f068f4ee0" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the first/last element (head/tail depending on the &lt;code&gt;wherefrom&lt;/code&gt; argument) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first/last element (head/tail depending on the &lt;code&gt;whereto&lt;/code&gt; argument) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">以原子方式返回并删除存储在 &lt;code&gt;source&lt;/code&gt; 上的列表的第一个/最后一个元素（头/尾，取决于 &lt;code&gt;wherefrom&lt;/code&gt; 参数），并将该元素推到存储的列表的第一个/最后一个元素（头/尾，取决于 &lt;code&gt;whereto&lt;/code&gt; 参数）在 &lt;code&gt;destination&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">以原子方式返回并删除存储在 &lt;code&gt;source&lt;/code&gt; 处的列表的最后一个元素（尾部），并将该元素推入存储在 &lt;code&gt;destination&lt;/code&gt; 处的列表的第一个元素（头）。</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">以原子方式将 &lt;code&gt;key&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; 并返回存储在 &lt;code&gt;key&lt;/code&gt; 处的旧值。当 &lt;code&gt;key&lt;/code&gt; 存在但不包含字符串值时，返回错误。</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">原子化地将一个key从源Redis实例转移到目标Redis实例。成功后,密钥将从原始实例中删除,并保证在目标实例中存在。</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">脚本的原子性</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">现有图书馆</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">B向节点A发送心跳包,其中节点D在列。</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF 异步重写只附加文件。</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE 异步将数据集保存到磁盘上。</target>
        </trans-unit>
        <trans-unit id="ab695def32445abd5af69c89b4fc9a578a6be30c" translate="yes" xml:space="preserve">
          <source>BGSAVE  [SCHEDULE]   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE [SCHEDULE]异步将数据集保存到磁盘上。</target>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">BITCOUNT key [start end]对字符串中的设置位进行计数。</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">BITFIELD键[GET类型偏移][SET类型偏移值][INCRBY类型偏移增量][OVERFLOW WRAP|SAT|FAIL]对字符串进行任意的位场整数运算。</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">BITOP操作 destkey key [key ...]在字符串之间执行位操作。</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">BITPOS 键位 [start][end]查找字符串中第一个被设置或清除的位。</target>
        </trans-unit>
        <trans-unit id="fc2dfb0c3d9a6c59a7ce67610ea5adaf29a615be" translate="yes" xml:space="preserve">
          <source>BLMOVE</source>
          <target state="translated">BLMOVE</target>
        </trans-unit>
        <trans-unit id="db9a7aeda5f34e5b6dc6bfc16ff9ad89a6ecbdee" translate="yes" xml:space="preserve">
          <source>BLMOVE  source destination LEFT|RIGHT LEFT|RIGHT timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout 从一个列表中弹出一个元素,把它推到另一个列表中,然后返回;或者阻塞,直到有一个元素可用为止。</target>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">BLPOP键[键...]超时 移除并获取列表中的第一个元素,或阻塞,直到有一个元素可用。</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">BRPOP key [key ...]超时 删除并获取列表中的最后一个元素,或块,直到有一个元素可用为止。</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH 源地 目标地 超时 从一个列表中弹出一个值,将其推送到另一个列表中并返回;或者阻塞,直到有一个可用的列表。</target>
        </trans-unit>
        <trans-unit id="06a6c1ed02823440cc121edde6eb065e5de27fb8" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH 源目的地超时 从一个列表中弹出一个元素,将其推到另一个列表中,然后返回;或者阻塞,直到有一个可用的元素。</target>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMAX键[键...]超时 从一个或多个排序集中删除并返回得分最高的成员,或阻止直到有成员可用为止。</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMIN键[键...]超时 从一个或多个排序集中删除并返回得分最低的成员,或阻止直到有成员可用为止。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">带宽和EVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">基本用途。</target>
        </trans-unit>
        <trans-unit id="7df3c519fe73f3ffe3f8fb928955ded445b7f85e" translate="yes" xml:space="preserve">
          <source>Basically the command sets a state in the connection, that is valid only for the next command execution, that will modify the behavior of client tracking.</source>
          <target state="translated">基本上,该命令在连接中设置了一个状态,该状态仅在下一次执行命令时有效,它将修改客户端跟踪的行为。</target>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">基本上,我们为每一个IP,每一个不同的秒数都有一个计数器。但是这个计数器总是递增的,设置了一个10秒的过期时间,所以当当前的秒数是不同的秒数时,Redis会自动删除它们。</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">基本上，如果您寻找空白位并且不指定范围或&lt;strong&gt;仅&lt;/strong&gt;指定&lt;em&gt;start&lt;/em&gt;参数，则该函数会将字符串的右边视为零填充。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">由于&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;流回&lt;strong&gt;所有&lt;/strong&gt;命令，因此其使用成本很高。以下（完全不科学的）基准数字说明了运行&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;的成本。</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">由于Redis无法控制如何将其分配映射到内存页面，因此 &lt;code&gt;used_memory_rss&lt;/code&gt; 高通常是内存使用量激增的结果。</target>
        </trans-unit>
        <trans-unit id="9157dfb92d6b10926d702b4d13ee089e71af6988" translate="yes" xml:space="preserve">
          <source>Because Redis' strings are binary-safe, a bitmap is trivially encoded as a bytes stream. The first byte of the string corresponds to offsets 0..7 of the bitmap, the second byte to the 8..15 range, and so forth.</source>
          <target state="translated">因为Redis的字符串是二进制安全的,一个位图被简单地编码为一个字节流,字符串的第一个字节对应位图的偏移量0...7,第二个字节对应8...15范围,以此类推。字符串的第一个字节对应于位图的偏移量0...7,第二个字节对应于8...15范围,以此类推。</target>
        </trans-unit>
        <trans-unit id="ba14992feb507791cf455ac84d4bc0c1654fa142" translate="yes" xml:space="preserve">
          <source>Because of security concerns, all administrative commands are not logged by &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;'s output.</source>
          <target state="translated">出于安全考虑，&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;的输出未记录所有管理命令。</target>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">由于&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;语义，C4可以检查存储在 &lt;code&gt;key&lt;/code&gt; 上的旧值是否仍然是过期的时间戳。如果是，则已获取锁。</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">由于每个元素的第一个&lt;em&gt;标准化&lt;/em&gt;部分（在冒号之前），我们强制进行给定的比较，但是在使用&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;查询范围之后，应用程序可以向用户显示字符串的第二部分，即冒号之后。</target>
        </trans-unit>
        <trans-unit id="7d59e94adcd8272e3572e2454feb728deea07f9f" translate="yes" xml:space="preserve">
          <source>Because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible. A good way to generate strong passwords is via the &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command.</source>
          <target state="translated">由于Redis的高性能，可以在很短的时间内并行尝试许多密码，因此请确保生成一个强度很高且很长的密码，这样才能避免这种攻击。生成强密码的一种好方法是通过&lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">由于这种语义，可以使用&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;来设置表示唯一逻辑对象的不同字段的不同键，以确保所有字段都设置或根本不设置。</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">因此，应谨慎使用&lt;strong&gt;TAKEOVER&lt;/strong&gt;选项。</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">因为当给定节点是群集的一部分时，参与群集的所有其他节点都知道该节点，为了将节点从群集中完全删除，必须将&lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt;命令发送到所有其余节点，无论它们是母版或副本的事实。</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">将多个元素推入列表时， &lt;code&gt;BLPOP&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">基准测试结果&lt;strong&gt;与&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;运行（ &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">&lt;strong&gt;未&lt;/strong&gt;运行&lt;a href=&quot;monitor&quot;&gt;MONITOR的&lt;/a&gt;基准测试结果：</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">比特图是一种非常节省空间的某些信息的表示方法。一个例子是,一个网络应用需要用户的访问历史,这样就可以确定哪些用户是测试版功能的好目标。</target>
        </trans-unit>
        <trans-unit id="927448b58910f0636586793360308442afd14b22" translate="yes" xml:space="preserve">
          <source>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type (for more information refer to the &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;Bitmaps section of the Data Types Introduction page&lt;/a&gt;). This means that bitmaps can be used with string commands, and most importantly with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;.</source>
          <target state="translated">位图不是实际的数据类型，而是在String类型上定义的一组面向位的操作（有关更多信息，请参见&lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;&amp;ldquo;数据类型简介&amp;rdquo;页面&lt;/a&gt;的&amp;ldquo;位图&amp;rdquo;部分）。这意味着位图可以与字符串命令一起使用，最重要的是可以与&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;和&lt;a href=&quot;get&quot;&gt;GET一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">位数和位置偏移</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">阻止行为</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">屏蔽数据</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">对列表或排序集的阻止列表操作具有&lt;em&gt;弹出&lt;/em&gt;行为。基本上，该元素将从列表或排序集中删除，以便返回给客户端。在这种情况下，您希望以公平的方式消费商品，具体取决于客户端在给定密钥上被阻止的时间。通常，在这种用例中，Redis使用FIFO语义。</target>
        </trans-unit>
        <trans-unit id="c7b48b477a47bc528502abd2750eaf8176a42526" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Basically, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">阻止列表或排序集上的列表操作具有&lt;em&gt;弹出&lt;/em&gt;行为。基本上，该元素将从列表或排序集中删除，以便返回给客户端。在这种情况下，您希望以公平的方式消费商品，具体取决于客户端在给定密钥上被阻止的时间。通常，在这种用例中，Redis使用FIFO语义。</target>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">两个 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 是从零开始的索引，其中 &lt;code&gt;0&lt;/code&gt; 是第一个元素， &lt;code&gt;1&lt;/code&gt; 是下一个元素等。它们也可以是负数，指示相对于已排序集合的末尾的偏移量，其中 &lt;code&gt;-1&lt;/code&gt; 是已排序集合的最后一个元素， &lt;code&gt;-2&lt;/code&gt; 是倒数第二个元素，依此类推。</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">这两个命令分别在Redis 3.2.10和Redis 4.0.0中引入。</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">两个数量都是64位的数字。当自动生成ID时,第一部分是生成ID的Redis实例的Unix时间,单位是毫秒。第二部分只是一个序列号,用于区分在同一毫秒内生成的ID。</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">两种表示方式都有一个16字节的前缀,包括一个魔术、一个编码/版本字段和计算出的缓存基数估计值,以小恩迪安格式存储(如果估计值无效,最重要的位是1,因为HyperLogic在计算出基数后更新过)。</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">字符串键中已经包含的值和增量参数都可以选择以指数符号提供,但是增量后计算出的值始终以相同的格式存储,即一个整数,后面跟着一个点(如果需要),以及代表数字小数部分的可变位数。始终去掉尾部的零。</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">考虑到破坏与过去的兼容性，但至少对于Redis 4.0而言，拒绝了，因此，添加了命令的两个只读变体。它们与原始命令完全一样，但是拒绝 &lt;code&gt;STORE&lt;/code&gt; 和 &lt;code&gt;STOREDIST&lt;/code&gt; 选项。这两个变体称为 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; 和 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; ，可以安全地在副本中使用。</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">批量字符串回复</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">但是在上面的情况下,输出是一样的,因为我们只有一个消费者的待处理消息。然而需要注意的是,这种按特定消费者过滤的操作,即使在有许多消费者的待处理消息时,也不是没有效率的:我们有一个全局的待处理条目列表数据结构,也有每个消费者的待处理条目列表数据结构,所以我们可以非常有效地只显示单个消费者的待处理消息。</target>
        </trans-unit>
        <trans-unit id="9fb6518aff837e3fbb56cbdada4b700f62c1931e" translate="yes" xml:space="preserve">
          <source>By default (if /dev/urandom is available) the password is strong and can be used for other uses in the context of a Redis application, for instance in order to create unique session identifiers or other kind of unguessable and not colliding IDs. The password generation is also very cheap because we don't really ask /dev/urandom for bits at every execution. At startup Redis creates a seed using /dev/urandom, then it will use SHA256 in counter mode, with HMAC-SHA256(seed,counter) as primitive, in order to create more random bytes as needed. This means that the application developer should be feel free to abuse &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; to create as many secure pseudorandom strings as needed.</source>
          <target state="translated">默认情况下（如果/ dev / urandom可用），密码是强密码，并且可以在Redis应用程序的上下文中用于其他用途，例如，以便创建唯一的会话标识符或其他种类的不可猜测且不冲突的ID。密码生成也非常便宜，因为我们并不真正在每次执行时都向/ dev / urandom要求位。在启动时，Redis使用/ dev / urandom创建一个种子，然后它将在计数器模式下使用SHA256，并将HMAC-SHA256（seed，counter）作为基元，以便根据需要创建更多随机字节。这意味着应用程序开发人员应该随意使用&lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt;来创建所需数量的安全伪随机字符串。</target>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">默认情况下，将检查字符串中包含的所有字节。可以仅在传递附加参数&lt;em&gt;start&lt;/em&gt;和&lt;em&gt;end&lt;/em&gt;的间隔中指定计数操作。</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">默认情况下，将返回所有匹配项。通过使用&lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt;选项，可以将结果限制为前N个匹配项。但是请注意，命令内部需要执行与指定区域匹配的项数成比例的工作量，因此，即使返回的结果很少，使用非常小的 &lt;code&gt;COUNT&lt;/code&gt; 选项查询非常大的区域也可能很慢。另一方面，如果通常仅使用第一个结果，则 &lt;code&gt;COUNT&lt;/code&gt; 是减少带宽使用的非常有效的方法。</target>
        </trans-unit>
        <trans-unit id="38a3d7ce77609a064a8c66435e5a2ddef01589e2" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; command will display the piece corresponding to the current Redis version, however it is possible to display a specific version using the following form:</source>
          <target state="translated">默认情况下，&lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt;命令将显示与当前Redis版本相对应的段，但是可以使用以下格式显示特定版本：</target>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">默认情况下，客户端将被解除阻止，就像到达命令超时一样；但是，如果传递了其他（和可选）参数，则可以指定解除阻止行为，可以是&lt;strong&gt;TIMEOUT&lt;/strong&gt;（默认）或&lt;strong&gt;ERROR&lt;/strong&gt;。如果指定了&lt;strong&gt;ERROR&lt;/strong&gt;，则行为是取消阻止客户端，并以错误方式返回客户端被强制解除阻止的事实。具体来说，客户端将收到以下错误：</target>
        </trans-unit>
        <trans-unit id="876aa0f6c00a7c0060c29d93b8e069bbd151098c" translate="yes" xml:space="preserve">
          <source>By default the command returns the items to the client. It is possible to store the results with one of these options:</source>
          <target state="translated">默认情况下,该命令会将项目返回给客户端。也可以用其中一个选项来存储结果。</target>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">默认情况下，脚本引擎始终设置为 &lt;code&gt;REPL_ALL&lt;/code&gt; 。通过调用此功能，用户可以打开/关闭AOF和/或副本传播，并在以后按自己的意愿将其重新打开。</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;将排序后的元素返回给客户端。使用 &lt;code&gt;STORE&lt;/code&gt; 选项，结果将作为列表存储在指定键处，而不是返回给客户端。</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">默认情况下，如果未另行指定，则使用&lt;strong&gt;WRAP&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">默认情况下，将检查字符串中包含的所有字节。可以仅在指定间隔内通过附加参数&lt;em&gt;start&lt;/em&gt;和&lt;em&gt;end&lt;/em&gt;查找位（可以仅传递&lt;em&gt;start&lt;/em&gt;，该操作将假定end是字符串的最后一个字节。但是，语义上存在差异，如所解释后来）。该范围被解释为字节范围而不是位范围，因此 &lt;code&gt;start=0&lt;/code&gt; 和 &lt;code&gt;end=2&lt;/code&gt; 表示查看前三个字节。</target>
        </trans-unit>
        <trans-unit id="ac56e3917c99c4ddfa64494c6e26b8240c053966" translate="yes" xml:space="preserve">
          <source>By default, all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">默认情况下，将返回所有匹配项。通过使用&lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt;选项，可以将结果限制为前N个匹配项。但是请注意，命令内部需要执行与指定区域匹配的项数成比例的工作量，因此即使返回的结果很少，使用非常小的 &lt;code&gt;COUNT&lt;/code&gt; 选项查询非常大的区域也可能很慢。另一方面，如果通常仅使用第一个结果，则 &lt;code&gt;COUNT&lt;/code&gt; 可能是减少带宽使用的非常有效的方法。</target>
        </trans-unit>
        <trans-unit id="f97c897415a76335a4f3d3db770776a7a0ccedc3" translate="yes" xml:space="preserve">
          <source>By default, it stores the results in the &lt;code&gt;destintion&lt;/code&gt; sorted set with their geospatial information.</source>
          <target state="translated">默认情况下，它将结果与地理空间信息一起存储在 &lt;code&gt;destintion&lt;/code&gt; 排序集中。</target>
        </trans-unit>
        <trans-unit id="5bcfb1fa8d4e16c5703f601d9b874b8021ef089f" translate="yes" xml:space="preserve">
          <source>By default, or when provided with the optional &lt;code&gt;=&lt;/code&gt; argument, the command performs exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">默认情况下，或者在提供了可选的 &lt;code&gt;=&lt;/code&gt; 参数时，该命令将执行精确的修整。这意味着修剪后的流的长度将恰好是其原始长度和指定的最大长度之间的最小值。</target>
        </trans-unit>
        <trans-unit id="3dfdd218a8c7dcfad82b579c16fc98a90e0423ca" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;destination&lt;/code&gt; key is created in the logical database used by the connection. The &lt;code&gt;DB&lt;/code&gt; option allows specifying an alternative logical database index for the destination key.</source>
          <target state="translated">默认情况下， &lt;code&gt;destination&lt;/code&gt; 密钥是在连接使用的逻辑数据库中创建的。的 &lt;code&gt;DB&lt;/code&gt; 选项允许指定所述目的地密钥的替换逻辑数据库索引。</target>
        </trans-unit>
        <trans-unit id="ecf8d58c1f5391dbccf4f7678d43b4f133487bae" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the beginning of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">默认情况下，该命令从列表的开头弹出一个元素。如果提供了可选的 &lt;code&gt;count&lt;/code&gt; 参数，则回复将由最多 &lt;code&gt;count&lt;/code&gt; 个元素组成，具体取决于列表的长度。</target>
        </trans-unit>
        <trans-unit id="6fecef221e5ae822414f939e112035853e985bf7" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the end of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">默认情况下，该命令从列表末尾弹出一个元素。如果提供了可选的 &lt;code&gt;count&lt;/code&gt; 参数，则回复将由最多 &lt;code&gt;count&lt;/code&gt; 个元素组成，具体取决于列表的长度。</target>
        </trans-unit>
        <trans-unit id="3b7bd3b6d4bf2d2679ef9988f3c531b70e60e21c" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single member from the set. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; members, depending on the set's cardinality.</source>
          <target state="translated">默认情况下，该命令从集合中弹出一个成员。当提供可选的 &lt;code&gt;count&lt;/code&gt; 参数时，答复将由最多 &lt;code&gt;count&lt;/code&gt; 个成员组成，具体取决于集合的基数。</target>
        </trans-unit>
        <trans-unit id="877bdcad724a6306efbd3a664f11efc0ec0b6fe6" translate="yes" xml:space="preserve">
          <source>By default, the command returns unsorted items. Two different sorting methods can be invoked using one of the following two options:</source>
          <target state="translated">默认情况下,该命令返回未排序的项目。可以使用以下两个选项之一调用两种不同的排序方法。</target>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">默认情况下，由 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 指定的间隔是关闭的（包括）。可以通过在分数前面加上字符 &lt;code&gt;(&lt;/code&gt; 。）来指定一个开放间隔（不包括）。例如：</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">默认情况下,一个元素的得分是它存在的排序集合中的得分之和。</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">默认情况下,一个元素的结果得分是它存在的排序集中的得分之和。因为交集要求一个元素是每一个给定排序集的成员,这就导致结果排序集中每个元素的得分等于输入排序集的数量。</target>
        </trans-unit>
        <trans-unit id="9bd72014f313a48aa376a2f9743fd29947ddbfa2" translate="yes" xml:space="preserve">
          <source>By getting the string representation of a bitmap, the client can then parse the response's bytes by extracting the bit values using native bit operations in its native programming language. Symmetrically, it is also possible to set an entire bitmap by performing the bits-to-bytes encoding in the client and calling &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with the resultant string.</source>
          <target state="translated">通过获取位图的字符串表示形式，客户端可以通过使用其本机编程语言中的本机位操作提取位值来解析响应的字节。对称地，也可以通过在客户端中执行位到字节的编码并使用结果字符串调用&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;来设置整个位图。</target>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1和C2读取 &lt;code&gt;lock.foo&lt;/code&gt; 来检查时间戳，因为它们在执行&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;后都收到 &lt;code&gt;0&lt;/code&gt; ，因为C3仍然持有该锁，而C3在持有该锁之后崩溃了。</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1发送 &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1发送 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 并成功</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2发送 &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2发送 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 并成功</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4发送 &lt;code&gt;GET lock.foo&lt;/code&gt; 以检查锁是否过期。如果不是，它将休眠一段时间并从头开始重试。</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4发送 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 以获取锁</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="63a953234a4a4b23595b8f5c3d66ad8e228bb360" translate="yes" xml:space="preserve">
          <source>CLIENT CACHING  YES|NO   Instruct the server about tracking or not keys in the next request</source>
          <target state="translated">CLIENT CACHING YES|NO 指示服务器在下一个请求中跟踪或不跟踪密钥。</target>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">CLIENT GETNAME 获取当前连接名。</target>
        </trans-unit>
        <trans-unit id="4c39ac03d0deadf47c0778e94147170cfe5cc290" translate="yes" xml:space="preserve">
          <source>CLIENT GETREDIR   Get tracking notifications redirection client ID if any</source>
          <target state="translated">CLIENT GETREDIR 获取跟踪通知重定向客户端ID(如有)。</target>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">CLIENT ID 返回当前连接的客户端ID。</target>
        </trans-unit>
        <trans-unit id="2cc6c98e277f7b4b6dd7682b2772443f1b2745eb" translate="yes" xml:space="preserve">
          <source>CLIENT INFO   Returns information about the current client connection.</source>
          <target state="translated">CLIENT INFO 返回当前客户端连接的信息。</target>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip:port][ID client-id][TYPE normal|master|slave|pubsub][ADDR ip:port][SKIPME yes/no]杀掉一个客户端的连接。</target>
        </trans-unit>
        <trans-unit id="0962c4ff7046d5e0349aa07792ed564b6ac58b3e" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [USER username] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip:port][ID client-id][TYPE normal|master|slave|pubsub][USER username][ADDR ip:port][SKIPME yes/no]杀掉一个客户端的连接。</target>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">CLIENT KILL和Redis Sentinel。</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">CLIENT LIST [TYPE normal|master|replica|pubsub]获取客户端连接列表。</target>
        </trans-unit>
        <trans-unit id="0f9e74e993d542e852824191d195f334f18cdbad" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub] [ID client-id [client-id ...]]   Get the list of client connections</source>
          <target state="translated">客户端列表 [TYPE normal|master|replica|pubsub][ID client-id [client-id ...]]。获取客户端连接列表</target>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">CLIENT PAUSE 超时 停止处理客户端的命令一段时间。</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">CLIENT REPLY ON|OFF|SKIP 指示服务器是否回复命令。</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">CLIENT SETNAME connection-name 设置当前的连接名。</target>
        </trans-unit>
        <trans-unit id="95279f3b4d86b3dc0268ddf4db1feb274847cc8c" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKING  ON|OFF [REDIRECT client-id] [PREFIX prefix [PREFIX prefix ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]   Enable or disable server assisted client side caching support</source>
          <target state="translated">客户端跟踪开启|关闭 [REDIRECT client-id][PREFIX prefix [PREFIX prefix ...]]。[BCAST][OPTIN][OPTOUT][NOLOOP]启用或禁用服务器辅助的客户端缓存支持。</target>
        </trans-unit>
        <trans-unit id="bd550a8d7b9512156ea1471fdd3b700157d0ab6e" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKINGINFO   Return information about server assisted client side caching for the current connection</source>
          <target state="translated">CLIENT TRACKINGINFO 返回当前连接的服务器辅助客户端缓存信息。</target>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">CLIENT UNBLOCK client-id [TIMEOUT|ERROR]从不同的连接上解除阻断命令中被阻断的客户端。</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">CLUSTER ADDSLOTS slot [slot ...]将新的哈希槽分配给接收节点。</target>
        </trans-unit>
        <trans-unit id="00fb8c41d977c173c87d67428daf985f10049f97" translate="yes" xml:space="preserve">
          <source>CLUSTER BUMPEPOCH   Advance the cluster config epoch</source>
          <target state="translated">CLUSTER BUMPEPOCH 提前群集配置周期</target>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">CLUSTER COUNT-FAILURE-REPORTS node-id 返回给定节点的活动故障报告数量。</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">CLUSTER COUNTKEYSINSLOT 槽 返回指定哈希槽中的本地键的数量。</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">CLUSTER DELSLOTS slot [slot ...]在接收节点中设置哈希槽为未绑定。</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">CLUSTER FAILOVER [FORCE|TAKEOVER]强制副本对其主站进行手动故障切换。</target>
        </trans-unit>
        <trans-unit id="94cefd9c3cfc8c0aca11125b97d7b0fd362d0d4a" translate="yes" xml:space="preserve">
          <source>CLUSTER FLUSHSLOTS   Delete a node's own slots information</source>
          <target state="translated">CLUSTER FLUSHSLOTS 删除节点自身的槽位信息。</target>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">CLUSTER FORGET node-id 从节点表中删除一个节点。</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT 槽位数 返回指定哈希槽位中的本地密钥名称。</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO 提供 Redis Cluster 节点的状态信息。</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">CLUSTER KEYSLOT 键 返回指定键的哈希槽。</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port 强制一个节点集群与另一个节点握手。</target>
        </trans-unit>
        <trans-unit id="4c0ca20cada3909d25d2d4e2035e56d2e9daba1b" translate="yes" xml:space="preserve">
          <source>CLUSTER MYID   Return the node id</source>
          <target state="translated">CLUSTER MYID 返回节点的ID。</target>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">CLUSTER NODES 获取节点的集群配置。</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS node-id 列出指定主节点的复制节点。</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE node-id 重新配置一个节点作为指定主节点的副本。</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">CLUSTER RESET [HARD|SOFT]重置Redis集群节点。</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG 强制节点在磁盘上保存群集状态。</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch 在新节点中设置配置epoch。</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">CLUSTER SETSLOT slot IMPORTING|MIGRATING|STABLE|NODE [node-id]将一个哈希槽绑定到一个特定的节点。</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">集群SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 导入 &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 迁移 &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">集群SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 节点 &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">集群设置 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 稳定</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id 列出指定主节点的复制节点。</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">获取簇槽到节点映射的数组。</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">COMMAND 获取Redis命令详情数组</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">COMMAND COUNT 获取Redis命令的总数。</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">COMMAND GETKEYS 提取给定的完整Redis命令的键。</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">COMMAND INFO command-name [command-name ...]获取特定Redis命令的详细信息数组。</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET参数 获取配置参数的值。</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSTAT 重置INFO返回的统计数据。</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE 用内存中的配置重写配置文件。</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITE也能够从头开始重写配置文件,如果原来的配置文件由于某种原因不再存在。但是如果服务器在启动时根本没有配置文件,CONFIG REWRITE只会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIG SET 参数值 将配置参数设置为给定值。</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="b3729b7bb933c36d809f0e8ba9d3228341d27148" translate="yes" xml:space="preserve">
          <source>COPY  source destination [DB destination-db] [REPLACE]   Copy a key</source>
          <target state="translated">COPY source destination [DB destination-db][REPLACE]复制密钥</target>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">使用损坏的，否定的，超出范围的游标或其他无效的游标来调用&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;，将导致不确定的行为，但绝不会导致崩溃。未定义的是，&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;实现将不再确保有关返回元素的保证。</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">在光标损坏的情况下调用SCAN。</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">皑皑溪流</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">在流水线请求的上下文中执行&lt;a href=&quot;evalsha&quot;&gt;EVALSHA时应格外小心&lt;/a&gt;，因为即使在管道中，也必须确保命令的执行顺序。如果&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;将返回 &lt;code&gt;NOSCRIPT&lt;/code&gt; 错误，则该命令以后将无法重新发出，否则将违反执行顺序。</target>
        </trans-unit>
        <trans-unit id="3c95b0aba9bde834d03663b5e6a82abbc6926a9f" translate="yes" xml:space="preserve">
          <source>Checking for all the available categories is as simple as:</source>
          <target state="translated">检查所有可用的类别就这么简单。</target>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">客户端IP地址和端口(仅限4.0)。</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">客户端库可以使用Redis来测试其自己的哈希算法，生成随机密钥并使用其本地实现和Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt;命令对其进行哈希，然后检查结果是否相同。</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">客户端名称（如果通过&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;命令设置）（仅4.0）。</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">集群客户端必须知道命令中的键位,这样命令才能进入匹配的实例,但Redis命令在接受一个键、多个键,甚至是被其他数据隔开的多个键之间存在差异。</target>
        </trans-unit>
        <trans-unit id="13fb8a1716343d8d81faf3b82f500e80a846e807" translate="yes" xml:space="preserve">
          <source>Cluster note: in a Redis Cluster clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed. That said, &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;'s replies in a cluster only report information from the node's Pub/Sub context, rather than the entire cluster.</source>
          <target state="translated">群集注意事项：在Redis群集中，客户端可以订阅每个节点，也可以发布到每个其他节点。群集将确保已发布的消息根据需要进行转发。也就是说，&lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;在群集中的答复仅报告来自节点的Pub / Sub上下文的信息，而不是整个群集中的信息。</target>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">指挥权</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">命令名称</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">命令arity &lt;em&gt;包括&lt;/em&gt;对命令名称本身进行计数。</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">命令数位遵循一个简单的模式。</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">命令标志是包含一个或多个状态回复的&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;数组&lt;/a&gt;回复：</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">命令名是指返回的命令为小写的字符串。</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">命令选项</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">关于已经迁移的密钥的命令,为了保证一致性,在迁移的目标节点,即新的哈希槽所有者的上下文中正确处理。</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">通常，有关该哈希槽的命令将被拒绝，并会生成 &lt;code&gt;MOVED&lt;/code&gt; 重定向，但是在命令跟随 &lt;code&gt;ASKING&lt;/code&gt; 命令的情况下，将执行该命令。</target>
        </trans-unit>
        <trans-unit id="aa013f0386471baba0b09b24b999134de43d82e4" translate="yes" xml:space="preserve">
          <source>Commands denied because accessing keys not allowed in the current ACL rules.</source>
          <target state="translated">由于当前ACL规则不允许访问密钥,所以拒绝命令。</target>
        </trans-unit>
        <trans-unit id="3aef01612894a7eb8b7ac8feeb71f973dac67ca6" translate="yes" xml:space="preserve">
          <source>Commands denied because against the current ACL rules.</source>
          <target state="translated">因为违反了当前的ACL规则而拒绝命令。</target>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">MONITOR没有记录的命令</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">尽量保留原redis.conf的注释和整体结构。</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">目前需要进行键位解析的命令的完整列表。</target>
        </trans-unit>
        <trans-unit id="85cf1af73ea4830e4844b1efcacdc1968badce3f" translate="yes" xml:space="preserve">
          <source>Computes the difference between the first and all successive input sorted sets and stores the result in &lt;code&gt;destination&lt;/code&gt;. The total number of input keys is specified by &lt;code&gt;numkeys&lt;/code&gt;.</source>
          <target state="translated">计算第一个和所有连续输入排序集之间的差，并将结果存储在 &lt;code&gt;destination&lt;/code&gt; 中。输入键的总数由 &lt;code&gt;numkeys&lt;/code&gt; 指定。</target>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">计算指定键给定的 &lt;code&gt;numkeys&lt;/code&gt; 排序集的交集，并将结果存储在 &lt;code&gt;destination&lt;/code&gt; 中。在传递输入键和其他（可选）参数之前，必须提供输入键（ &lt;code&gt;numkeys&lt;/code&gt; ）的数量。</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">计算指定键给定的 &lt;code&gt;numkeys&lt;/code&gt; 排序集的并集，并将结果存储在 &lt;code&gt;destination&lt;/code&gt; 中。在传递输入键和其他（可选）参数之前，必须提供输入键（ &lt;code&gt;numkeys&lt;/code&gt; ）的数量。</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">SHUTDOWN失败的情况</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">一致性和等待</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">与各种编程语言中的范围函数保持一致。</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">30秒内的消费群体</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">每当某个命令提到一个新的消费者名称时,消费者组中的消费者就会自动创建。然而,有时删除旧的消费者可能是有用的,因为他们不再被使用。此表格返回该消费者在被删除前的待处理信息数量。</target>
        </trans-unit>
        <trans-unit id="93fee3ae260963d2ed888e760affe7075d85b781" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can also be explicitly created by using the following form:</source>
          <target state="translated">每当某个命令提到一个新的消费者名称时,消费者组中的消费者就会自动创建。也可以使用以下表格明确地创建消费者组。</target>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">Lua和Redis数据类型之间的转换</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">运行&lt;a href=&quot;monitor&quot;&gt;MONITOR的&lt;/a&gt;成本</target>
        </trans-unit>
        <trans-unit id="f43fec16935ea429ca6c4332ec8b80a51c3b6c5e" translate="yes" xml:space="preserve">
          <source>Cost of running MONITOR</source>
          <target state="translated">运行联刚特派团的费用</target>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">计数参数扩展</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">计算一个字符串中的集合位数(人口计数)。</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">创建与通过反序列化提供的序列化值（通过&lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;获得）而获得的值关联的键。</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">创建一个与流相关联的新消费者组。</target>
        </trans-unit>
        <trans-unit id="5c0f29bb78fb88abe065ad6df1e2bc2b5123eed8" translate="yes" xml:space="preserve">
          <source>Create an ACL user with the specified rules or modify the rules of an existing user. This is the main interface in order to manipulate Redis ACL users interactively: if the username does not exist, the command creates the username without any privilege, then reads from left to right all the rules provided as successive arguments, setting the user ACL rules as specified.</source>
          <target state="translated">用指定的规则创建一个ACL用户或修改现有用户的规则。这是交互式操作Redis ACL用户的主界面:如果用户名不存在,命令在没有任何权限的情况下创建用户名,然后从左到右读取所有作为连续参数提供的规则,按照指定的规则设置用户ACL规则。</target>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">D端在A的节点表中重新添加。</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">D现在是空的,但仍列在A、B、C的节点表中。</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE 返回所选数据库中键的数量。</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT键 获取键的调试信息。</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">DEBUG SEGFAULT 使服务器崩溃。</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">DECR键 将键的整数值减一。</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">DECRBY key decrement 将一个键的整数值按给定的数字递减。</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">DEL键 [键...]删除一个键。</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">DISCARD 丢弃所有在 MULTI 之后发出的命令。</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">DUMP键 返回存储在指定键上的值的序列化版本。</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">调试Lua脚本</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">递减存储在数字 &lt;code&gt;key&lt;/code&gt; 按 &lt;code&gt;decrement&lt;/code&gt; 。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 存储的数字减一。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于&lt;strong&gt;64位带符号整数&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">删除所有发现过期的钥匙。</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">删除所有现有数据库的所有键,而不仅仅是当前选定的数据库。这个命令永远不会失败。</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">删除当前所选数据库的所有键。这个命令永远不会失败。</target>
        </trans-unit>
        <trans-unit id="26c0e71676fb555cdd0bb73d03160139913dfe07" translate="yes" xml:space="preserve">
          <source>Delete all the specified ACL users and terminate all the connections that are authenticated with such users. Note: the special &lt;code&gt;default&lt;/code&gt; user cannot be removed from the system, this is the default user that every new connection is authenticated with. The list of users may include usernames that do not exist, in such case no operation is performed for the non existing users.</source>
          <target state="translated">删除所有指定的ACL用户，并终止用这些用户验证的所有连接。注意：无法从系统中删除特殊的 &lt;code&gt;default&lt;/code&gt; 用户，这是每个新连接都通过身份验证的默认用户。用户列表可以包括不存在的用户名，在这种情况下，不对不存在的用户执行任何操作。</target>
        </trans-unit>
        <trans-unit id="5165f9fa25a0905a85123f97b0428c87e1a5bb61" translate="yes" xml:space="preserve">
          <source>Deletes all slots from a node.</source>
          <target state="translated">删除一个节点的所有插槽。</target>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">如果我们必须确保所有实例都包含一个给定的命令,那么部署是很困难的,尤其是在分布式环境中。</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">设计模式</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">设计模式：使用 &lt;code&gt;SETNX&lt;/code&gt; 锁定</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">摧毁一个消费群体。</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">弦比较的细节</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">关于为什么需要列入禁止名单的细节</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">检测超时的复制件。</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">XREAD和XREADGROUP的区别</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">Redis 2.1.3之前的区别</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">不同的实例可能有不同的命令实现。</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">不同的子命令使用不同的返回值。</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">禁止对连接到Redis Cluster从属节点的读取查询。</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">返回内容的分布</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">由于Redis的单线程特性,不可能在客户端连接执行命令的时候杀死它。从客户端的角度来看,连接永远不可能在执行命令的过程中被关闭。但是,只有在发送下一条命令时,客户端才会注意到连接已经被关闭(并导致网络错误)。</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">ECHO消息 回应给定的字符串</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL 脚本 numkeys key [key ...]arg [arg ...]执行一个 Lua 脚本服务器端。</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys key [key ...]arg [arg ...]执行一个Lua脚本服务器端。</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">EVALSHA在管道中的应用</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EXEC 执行 MULTI 之后发出的所有命令。</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTS key [key ...]确定一个键是否存在。</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">EXPIRE key seconds 设置键的存活时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">EXPIREAT key timestamp 将密钥的到期时间设置为 UNIX 时间戳。</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">每个故障报告的生存时间是&lt;em&gt;节点超时&lt;/em&gt;时间的两倍。</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">每行由一系列由空格分隔的 &lt;code&gt;property=value&lt;/code&gt; 字段组成。</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">每一行由以下字段组成:</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">每个嵌套的结果是:</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Redis集群中的每个节点都有它对当前集群配置的看法,由已知节点集、我们与这些节点的连接状态、它们的标志、属性和分配的槽位等给出。</target>
        </trans-unit>
        <trans-unit id="ebe29cd1a064ec2dc6312d2e8c8e3c40f46f1f35" translate="yes" xml:space="preserve">
          <source>Each reported event has the following fields:</source>
          <target state="translated">每个报告的事件都有以下字段:</target>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">每个结果都包括所列槽位范围的主实例的所有活动副本。失败的副本不会返回。</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">下面将对每个子命令进行说明。最后,您将看到关于如何使用此命令和其他相关命令进行实时重装的描述。</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">每个顶层结果包含六个嵌套结果。每个嵌套结果是:</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">对节点的影响。</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">在一个完整的迭代过程中,集合中没有持续存在的元素,可以返回,也可以不返回:它是未定义的。</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">相同分数的元素</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">从脚本中发送Redis日志。</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">启用对连接到Redis Cluster复制节点的读取查询。</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">终点槽范围</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">通过SHA1摘要评估在服务器端缓存的脚本。使用&lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;命令将脚本缓存在服务器端。该命令在其他方面与&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">即使其他客户在列表最后积极推送新项目。</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">即使是正在运行的实例也会一直检查电脑时钟,所以比如你设置了一个活期时间为1000秒的键,然后在未来设置电脑时间为2000秒,那么这个键就会立即失效,而不是持续1000秒。</target>
        </trans-unit>
        <trans-unit id="d27fcdec12658758c11ddcfe5132a9543098333e" translate="yes" xml:space="preserve">
          <source>Event name.</source>
          <target state="translated">活动名称:</target>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">最终,如果一个宏节点中的所有条目都被标记为删除,整个节点就会被销毁,内存被回收。这意味着,如果你从一个流中删除了大量的条目,例如超过50%的条目附加到流中,每个条目的内存使用量可能会增加,因为发生的情况是流将开始被碎片化。然而,流的性能将保持不变。</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">&lt;em&gt;确保&lt;/em&gt;每个Redis实例都具有上述所有库，因此您可以确保Redis脚本的环境始终相同。</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">每个条目都由四个(或从Redis 4.0开始的六个)字段组成。</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">每一个新的连接开始时都没有指定的名称。</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">每当一个节点处理来自其他节点的八卦数据包时，它都会创建（并在需要时刷新TTL）&lt;strong&gt;故障报告&lt;/strong&gt;，并记住给定节点表示另一个给定节点处于 &lt;code&gt;PFAIL&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">每次用户执行页面浏览时，应用程序都可以使用&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;命令将当日访问该网站的日期设置为SETBIT命令。</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">每次执行这个脚本,产生的列表都会有以下元素。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">零填充的例子。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">独占区间和无穷大</target>
        </trans-unit>
        <trans-unit id="114f30848cb8a83d62c97a5a6476b435a78150bd" translate="yes" xml:space="preserve">
          <source>Exclusive ranges</source>
          <target state="translated">独家系列</target>
        </trans-unit>
        <trans-unit id="55912897a10d768ac59806e69e2501c331778457" translate="yes" xml:space="preserve">
          <source>Exclusive ranges and iterating the PEL</source>
          <target state="translated">独占范围和迭代PEL</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">确保已执行的脚本永远位于Redis实例的给定执行的脚本缓存中。这意味着，如果对Redis实例执行&lt;a href=&quot;eval&quot;&gt;EVAL，&lt;/a&gt;则所有后续的&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;调用都会成功。</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">执行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务中&lt;/a&gt;所有先前排队的命令，并将连接状态恢复为正常。</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">使用Redis 2.6或更新版本执行Lua脚本。</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">过期准确性</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">过期和持久性</target>
        </trans-unit>
        <trans-unit id="a4432b0943d588c17ab5d7e63d136bb9786a862c" translate="yes" xml:space="preserve">
          <source>Extended form of XPENDING</source>
          <target state="translated">XPENDING的扩展形式</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]删除所有数据库中的所有键。</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]删除当前数据库中的所有键。</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCE选项:当主站故障时,手动故障切换。</target>
        </trans-unit>
        <trans-unit id="f9c28b26fa472599864dea91ca5f8cd92a5475d7" translate="yes" xml:space="preserve">
          <source>Failures to authenticate their connections with &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; or &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;.</source>
          <target state="translated">无法通过&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;或&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;验证其连接。</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">从一个流中获取一个条目,提供该条目的ID,以获取两次:作为查询间隔的开始和结束。</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">通过使用者组从流中获取数据，而不确认此类数据，具有创建&lt;em&gt;待处理条目的作用&lt;/em&gt;。&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;命令对此进行了很好的解释，甚至在我们&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;对Redis Streams&lt;/a&gt;的介绍中也对此进行了更好的解释。该&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;命令将立即删除从等待条目列表（PEL）的等待条目，因为一旦消息被成功处理，没有用于消费群体不再需要跟踪它，并记住消息的当前所有者。</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">获取单个项目</target>
        </trans-unit>
        <trans-unit id="894f8f81f5445488b186c9a058eccf6bacfbb0db" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommand:</source>
          <target state="translated">最后，如果用户忘记了确切的语法，可以通过使用 &lt;code&gt;HELP&lt;/code&gt; 子命令从命令中获得帮助：</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">最后，如果用户忘记了确切的语法，可以通过使用 &lt;code&gt;HELP&lt;/code&gt; 子命令从命令中获得帮助：</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">最后可以得到特定消费群体中每个消费者的名单。</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">最后,可以向命令传递一个额外的参数,以便查看具有特定所有者的消息。</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">最后，可以使用 &lt;code&gt;SETID&lt;/code&gt; 子命令设置要传递的下一条消息。通常，在创建使用者时将下一个ID设置为 &lt;code&gt;XGROUP CREATE&lt;/code&gt; 的最后一个参数。但是，使用此表单可以在以后修改下一个ID，而无需再次删除和创建使用者组。例如，如果您希望使用者组中的使用者重新处理流中的所有消息，则可以将其下一个ID设置为0：</target>
        </trans-unit>
        <trans-unit id="53e0098dbba7db3bdb2ae206e024574f2dd74ced" translate="yes" xml:space="preserve">
          <source>Finally to also have the match len:</source>
          <target state="translated">最后要也有匹配的里恩。</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">最后,如果你不记得语法,可以使用HELP子命令获得一些帮助。</target>
        </trans-unit>
        <trans-unit id="4827d8054bd5c8af82f3e09e291390e27412f49f" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;MAXLEN&lt;/code&gt; option tells the command to compare the provided element only with a given maximum number of list items. So for instance specifying &lt;code&gt;MAXLEN 1000&lt;/code&gt; will make sure that the command performs only 1000 comparisons, effectively running the algorithm on a subset of the list (the first part or the last part depending on the fact we use a positive or negative rank). This is useful to limit the maximum complexity of the command. It is also useful when we expect the match to be found very early, but want to be sure that in case this is not true, the command does not take too much time to run.</source>
          <target state="translated">最后， &lt;code&gt;MAXLEN&lt;/code&gt; 选项告诉命令仅将提供的元素与给定的最大列表项数进行比较。因此，例如，指定 &lt;code&gt;MAXLEN 1000&lt;/code&gt; 将确保该命令仅执行1000次比较，从而在列表的子集（第一部分或最后部分，取决于我们使用正数还是负数的事实）上有效地运行算法。这对于限制命令的最大复杂度很有用。当我们希望很快找到匹配项，但又要确保在不正确的情况下运行该命令时，该命令也很有用。</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">论点列表中的第一个键</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">档期范围的第一个主件副本</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">如果启用AOF,则刷新仅附加文件。</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">刷新 Lua 脚本缓存。</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">刷新&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务中&lt;/a&gt;所有先前排队的命令，并将连接状态恢复为正常。</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">刷新所有先前监视的键以进行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">对于Redis 2.6，将执行执行多次推送的命令，并且&lt;em&gt;仅在&lt;/em&gt;执行该命令&lt;em&gt;后才&lt;/em&gt;为阻塞的客户端提供服务。考虑此命令序列。</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">对于的描述 &lt;code&gt;WEIGHTS&lt;/code&gt; 和 &lt;code&gt;AGGREGATE&lt;/code&gt; 选项，请参见&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">有关HyperLogLog数据结构的介绍，请查看&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;命令页面。</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">对于介绍的有序集合，请参阅数据类型页&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;排序集&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">对于每一种命令类型,都会添加以下一行。</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">对于列出的每个消费者组,该命令还显示该组中已知的消费者数量和该组中的待处理信息(已发送但尚未确认)。</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">对于每个数据库,增加以下一行:</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">对于每个副本,都要加上以下一行:</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">对于哈希中不存在的每个 &lt;code&gt;field&lt;/code&gt; ，将返回 &lt;code&gt;nil&lt;/code&gt; 值。由于不存在的键被视为空哈希，&lt;a href=&quot;hmget&quot;&gt;因此&lt;/a&gt;对不存在的 &lt;code&gt;key&lt;/code&gt; 运行HMGET将返回 &lt;code&gt;nil&lt;/code&gt; 值的列表。</target>
        </trans-unit>
        <trans-unit id="ebdc0b5372eb98dde6f0761af59221e15f0a9f9e" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt; that does not exist in the sorted set, a &lt;code&gt;nil&lt;/code&gt; value is returned.</source>
          <target state="translated">对于排序集中不存在的每个 &lt;code&gt;member&lt;/code&gt; ，将返回 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="4313528e119e8db789aa6be23b8a03a247c203b4" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is returned if the value is a member of the set, or &lt;code&gt;0&lt;/code&gt; if the element is not a member of the set or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">对于每个 &lt;code&gt;member&lt;/code&gt; ，如果值是集合的成员，则返回 &lt;code&gt;1&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 如果元素不是集合的成员或 &lt;code&gt;key&lt;/code&gt; 不存在，则返回0。</target>
        </trans-unit>
        <trans-unit id="b69fc5b2026538496f23b6b8fb03889d7e1936d3" translate="yes" xml:space="preserve">
          <source>For eviction purposes, you may use the &lt;code&gt;IDLETIME&lt;/code&gt; or &lt;code&gt;FREQ&lt;/code&gt; modifiers. See &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; for more information (Redis 5.0 or greater).</source>
          <target state="translated">出于驱逐目的，您可以使用 &lt;code&gt;IDLETIME&lt;/code&gt; 或 &lt;code&gt;FREQ&lt;/code&gt; 修饰符。有关更多信息，请参见&amp;ldquo;&lt;a href=&quot;object&quot;&gt;对象&lt;/a&gt;&amp;rdquo;（Redis 5.0或更高版本）。</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">例如在实现马尔科夫链和其他算法时,一个常见的问题是从一个集合中随机选择一个元素,但不同的元素可能有不同的权重,改变了它们被选中的可能性。</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">例如，为了计算一天中执行的所有唯一搜索查询的次数，每次处理查询时，程序都需要调用&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;。可以随时使用&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;检索估计的唯一查询数。</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">例如,下面的命令将槽位1 2 3分配给接收命令的节点。</target>
        </trans-unit>
        <trans-unit id="49606e7b6de7a4d4946192e9ed0aa5fb1d49ac0b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例如,下面的命令在位偏移量100处递增一个5位有符号整数,并在位偏移量0处获取4位无符号整数的值。</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例如,以下命令在位偏移量100处递增一个8位有符号整数,并在位偏移量0处获取4位无符号整数的值。</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">例如,下面的命令将把流精确地修剪成最新的1000个项目。</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; 将删除存储在 &lt;code&gt;list&lt;/code&gt; 处的列表中最后两次出现的 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="806b6380a574787b8a29a883731b6c80cdcdcc0d" translate="yes" xml:space="preserve">
          <source>For example, after setting a few bits, getting the string value of the bitmap would look like this:</source>
          <target state="translated">例如,在设置了几个位后,获取位图的字符串值会是这样的。</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">例如，如果我有两个流 &lt;code&gt;mystream&lt;/code&gt; 和 &lt;code&gt;writers&lt;/code&gt; ，并且我想从两个流中读取它们都包含的第一个元素开始的数据，则可以像下面的示例一样调用&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd44de0983e01c60e504cf2bf01e0f7c36d85e53" translate="yes" xml:space="preserve">
          <source>For example, the example above could be replaced by:</source>
          <target state="translated">例如,上面的例子可以替换为:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">例如： &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; 将修改存储在 &lt;code&gt;foobar&lt;/code&gt; 的列表，以便仅保留列表的前三个元素。</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例如：考虑持有列表 &lt;code&gt;a,b,c&lt;/code&gt; 的 &lt;code&gt;source&lt;/code&gt; 和持有列表 &lt;code&gt;x,y,z&lt;/code&gt; 的 &lt;code&gt;destination&lt;/code&gt; 。执行&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH会&lt;/a&gt;导致 &lt;code&gt;source&lt;/code&gt; 持有 &lt;code&gt;a,b&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 持有 &lt;code&gt;c,x,y,z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58bac03f69d7fb418a6dae21d7a1d10de406cdc5" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例如：考虑持有列表 &lt;code&gt;a,b,c&lt;/code&gt; 的 &lt;code&gt;source&lt;/code&gt; 和持有列表 &lt;code&gt;x,y,z&lt;/code&gt; 的 &lt;code&gt;destination&lt;/code&gt; 。执行 &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; 导致 &lt;code&gt;source&lt;/code&gt; 持有 &lt;code&gt;a,b&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 持有 &lt;code&gt;c,x,y,z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">要想让过期的功能发挥得好,计算机的时间必须要稳定。如果你把一个RDB文件从两台计算机上移动过来,而两台计算机的时钟有很大的不同步,那么可能会发生一些有趣的事情(比如所有加载的键在加载时都过期了)。</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">有关Redis流的更多信息，请查看我们&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;对Redis Streams文档的介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">比如一个与Redis有持久连接的应用,可以确定如果一个脚本被发送过一次,它还在内存中,所以可以用EVALSHA来对付管道中的那些脚本,而不会因为未知脚本而产生错误的机会(我们后面会详细看到这个问题)。</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">例如，在上面的示例中，我们为流 &lt;code&gt;mystream&lt;/code&gt; 接收的最后一个项目的ID为 &lt;code&gt;1526999352406-0&lt;/code&gt; ，而对于流 &lt;code&gt;writers&lt;/code&gt; 的ID为 &lt;code&gt;1526985685298-0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e98a029b908a48582debab0c6f730b78e90807" translate="yes" xml:space="preserve">
          <source>For instance the LCS between &quot;foo&quot; and &quot;fao&quot; is &quot;fo&quot;, since scanning the two strings from left to right, the longest common set of characters is composed of the first &quot;f&quot; and then the &quot;o&quot;.</source>
          <target state="translated">例如 &quot;foo &quot;和 &quot;fao &quot;之间的LCS是 &quot;fo&quot;,因为从左到右扫描这两个字符串,最长的共同字符集是由第一个 &quot;f&quot;,然后是 &quot;o &quot;组成。</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">例如， &lt;code&gt;redis.conf&lt;/code&gt; 中的内容如下所示：</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">例如当使用Redis来实现队列时,消息的生产者和消费者可能希望根据他们的角色来设置连接的名称。</target>
        </trans-unit>
        <trans-unit id="de61480f11e8a3010955bfd7cae332ac3deef0b2" translate="yes" xml:space="preserve">
          <source>For instance, in the above example the element &quot;c&quot; is present multiple times, if I want the index of the second match, I'll write:</source>
          <target state="translated">例如,在上面的例子中,元素 &quot;c &quot;是多次出现的,如果我想知道第二次匹配的索引,我就写。</target>
        </trans-unit>
        <trans-unit id="42fe68157034ba62944abb2ee31fe519ec8ceb83" translate="yes" xml:space="preserve">
          <source>For more information about replication in Redis please check the &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;replication page&lt;/a&gt;.</source>
          <target state="translated">有关Redis中复制的更多信息，请检查&lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;复制页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f14c631da3e9eabaf78a7f5c398db9fc1eb1c9a2" translate="yes" xml:space="preserve">
          <source>For more information refer to the &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;Latency Monitoring Framework page&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅&amp;ldquo;&lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;延迟监视框架&amp;rdquo;页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">对于大多数命令,第一个键是位置1。位置0始终是命令名称本身。</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">对于嵌套数据类型，可以提供可选的 &lt;code&gt;SAMPLES&lt;/code&gt; 选项，其中 &lt;code&gt;count&lt;/code&gt; 是采样的嵌套值的数量。默认情况下，此选项设置为 &lt;code&gt;5&lt;/code&gt; 。要采样所有嵌套值，请使用 &lt;code&gt;SAMPLES 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">对于涉及大量输入的实时度量和统计,一个好的方法是使用副本(禁用只读选项),在副本中进行位元操作以避免阻塞主实例。</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">出于安全考虑，某些特殊的管理命令（例如 &lt;code&gt;CONFIG&lt;/code&gt; )未登录到&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;输出中。</target>
        </trans-unit>
        <trans-unit id="906c5a5f8c50388c930df8c6fdc394c6fc2a805e" translate="yes" xml:space="preserve">
          <source>For the LCS algorithm:</source>
          <target state="translated">对于LCS算法:</target>
        </trans-unit>
        <trans-unit id="68c60647d6f0b610c394981eaeb8a9621bab7be5" translate="yes" xml:space="preserve">
          <source>For the subsequent calls, you'll need to programmatically advance the last entry's ID returned. Most Redis client should abstract this detail, but the implementation can also be in the application if needed. In the example above, this means incrementing the sequence of &lt;code&gt;1526985685298-0&lt;/code&gt; by one, from 0 to 1. The second call would, therefore, be:</source>
          <target state="translated">对于后续调用，您需要以编程方式提前返回最后一个条目的ID。大多数Redis客户端都应该抽象此细节，但是如果需要的话，也可以在应用程序中实现。在上面的示例中，这意味着将 &lt;code&gt;1526985685298-0&lt;/code&gt; 的序列从0递增到1。因此，第二个调用是：</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">因此，Redis 3.2引入了一个新命令，该命令仅在启用脚本效果复制后才有效，并且能够控制脚本复制引擎。该命令称为 &lt;code&gt;redis.set_repl()&lt;/code&gt; ，如果在禁用脚本效果复制时调用，则不会引发错误。</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">强制节点将 &lt;code&gt;nodes.conf&lt;/code&gt; 配置保存在磁盘上。返回命令之前，请调用 &lt;code&gt;fsync(2)&lt;/code&gt; 以确保在计算机磁盘上刷新了配置。</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">幸运的是,使用以下算法可以避免这个问题。我们来看看我们的理智客户C4是如何使用好这个算法的。</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">从语法的角度来看，这些命令几乎相同，但是&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;需要&lt;/em&gt;一个特殊的强制性选项：</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">有趣的事实：Reddit的2017年4月愚人项目&lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt;是&lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;使用Redis BITFIELD命令构建的&lt;/a&gt;，目的是获取协作画布的内存表示形式。</target>
        </trans-unit>
        <trans-unit id="53eb3603814482cd94f53dcb8dd480c97fb7a365" translate="yes" xml:space="preserve">
          <source>Furthermore, the following commands are also not logged:</source>
          <target state="translated">此外,以下命令也未被记录。</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD键经度纬度成员[经度纬度成员......]在使用排序集表示的地理空间索引中添加一个或多个地理空间项目。</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="d87009d6893410d7c22a72e0781ff862c94b8508" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [m|km|ft|mi]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [m|km|ft|mi]返回一个地理空间索引的两个成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [单位]返回一个地理空间索引的两个成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH key member [member ...]返回地理空间索引的成员,作为标准的geohash字符串。</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS key member [member ...]返回地理空间索引成员的经度和纬度。</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS 键 经度 纬度 半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT 计数][ASC|DESC][STORE 键][STOREDIST 键]查询一个代表地理空间索引的排序集,以获取与给定的最大距离相匹配的成员。</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER 键 成员半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT 计数][ASC|DESC][STORE 键][STOREDIST 键]查询一个代表地理空间索引的排序集,以获取与给定最大距离相匹配的成员。</target>
        </trans-unit>
        <trans-unit id="8c656e42e400e0e0513de5eb5312afe50a9bf1f5" translate="yes" xml:space="preserve">
          <source>GEOSEARCH</source>
          <target state="translated">GEOSEARCH</target>
        </trans-unit>
        <trans-unit id="3f9c1bdbc9920ba8577c53041094c05d6b105844" translate="yes" xml:space="preserve">
          <source>GEOSEARCH  key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.</source>
          <target state="translated">GEOSEARCH key [FROMMEMBER member][FROMLONLAT longitude latitude][BYRADIUS radius m|km|ft|mi][BYBOX width height m|km|ft|mi][ASC|DESC][COUNT count][WITHCOORD][WITHDIST][WITHHASH]查询一个代表地理空间索引的排序集,以获取一个盒子或圆的区域内的成员。</target>
        </trans-unit>
        <trans-unit id="6b6122a14306dc58653c28237fae16723377d12d" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE</source>
          <target state="translated">GEOSEARCHSTORE</target>
        </trans-unit>
        <trans-unit id="8ad42c0130aa6e2dd8ebab61f847d23ba5e52254" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE  destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.</source>
          <target state="translated">GEOSEARCHSTORE目的源 [FROMMEMBER成员][FROMLONLAT经度纬度][BYRADIUS半径m|km|ft|mi][BYBOX宽度高度m|km|ft|mi][ASC|DESC][COUNT计数][WITHCOORD][WITHDIST][WITHHASH][STOREDIST]查询一个代表地理空间索引的排序集,以获取一个盒子或一个圆的区域内的成员。并将结果存储在另一个键中。</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET key 获取一个键的值</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT 键偏移 返回存储在键的字符串值中偏移的位值。</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end 获取存储在某个键上的字符串的子串。</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET 键值 设置一个键的字符串值,并返回它的旧值。</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">单方面生成一个新的 &lt;code&gt;configEpoch&lt;/code&gt; ，仅获取当前可用的最大时期，如果其本地配置时期尚未达到最大时期，则将其递增。</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">Geohash字符串属性</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">从源节点获取密钥&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt;命令，并将其移动到使用目的节点&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">获取 &lt;code&gt;key&lt;/code&gt; 的值。如果键不存在，则返回特殊值 &lt;code&gt;nil&lt;/code&gt; 。如果存储在 &lt;code&gt;key&lt;/code&gt; 处的值不是字符串，则返回错误，因为&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;仅处理字符串值。</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">给定一个SHA1摘要列表作为参数,这个命令返回一个1或0的数组,其中1表示特定的SHA1被识别为已经存在于脚本缓存中的脚本,而0表示具有这个SHA1的脚本以前从未见过(或者至少在最近的SCRIPT FLUSH命令之后从未见过)。</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">给定一个使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;命令填充的代表地理空间索引的排序集，通常对获取指定成员的坐标很有用。通过&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;填充地理空间索引时，坐标将转换为52位的geohash，因此返回的坐标可能与用于添加元素的坐标不完全相同，但是可能会引入一些小误差。</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">给定一个使用&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;命令填充的代表地理空间索引的排序集，该命令返回指定单位中两个指定成员之间的距离。</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">全局变量保护</target>
        </trans-unit>
        <trans-unit id="107625e2c3bcf140428d9df7e4e1066049947d81" translate="yes" xml:space="preserve">
          <source>Groups, consumers and PELs are returned.</source>
          <target state="translated">群体、消费者和PEL被退回。</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">终止的保证</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL 关键字段 [字段...]删除一个或多个哈希字段。</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="194f965f233e82e8b705df8610029d9234df6a34" translate="yes" xml:space="preserve">
          <source>HELLO  protover [AUTH username password] [SETNAME clientname]   switch Redis protocol</source>
          <target state="translated">HELLO protover [AUTH username password][SETNAME clientname]切换 Redis 协议。</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS 关键字段 确定一个哈希字段是否存在。</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET 关键字段 获取哈希字段的值。</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL 键 获取哈希值中的所有字段和值。</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY 关键字段增量 将哈希字段的整数值按给定的数目增加。</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT 关键字段增量 将哈希字段的浮动值按给定的数量递增</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS 键 获取哈希中的所有字段。</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">获取哈希值中的字段数。</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET 关键字段 [字段...]获取所有给定哈希字段的值。</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET 关键字段值 [字段值...]将多个哈希字段设置为多个值。</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN 键光标 [MATCH pattern][COUNT count]递增迭代哈希字段和相关值。</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET 键字段值 设置哈希字段的字符串值。</target>
        </trans-unit>
        <trans-unit id="bc6fdaa755b1bfae0ec78315f5fb3674c528f4e4" translate="yes" xml:space="preserve">
          <source>HSET  key field value [field value ...]   Set the string value of a hash field</source>
          <target state="translated">HSET 关键字段值 [字段值...]设置一个哈希字段的字符串值。</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX 关键字段值 设置哈希字段的值,只有在该字段不存在的情况下才可以设置。</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN 关键字段 获取哈希字段的值的长度。</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS 键 获取哈希中的所有值</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">处理僵局</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">处理不同长度的字符串</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">哈希可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;hashtable&lt;/code&gt; 。该 &lt;code&gt;ziplist&lt;/code&gt; 是用于小哈希一个特殊的编码。</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">返回Redis类型的辅助函数</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">下面是几个转换的例子。</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">这是Redis&amp;gt; = 2.4的字段说明。</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;客户&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;cpu&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;内存&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;持久性&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;复制&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">这是&lt;strong&gt;服务器&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">这是&amp;ldquo; &lt;strong&gt;统计信息&amp;rdquo;&lt;/strong&gt;部分中所有字段的含义：</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">这里是田野的意思。</target>
        </trans-unit>
        <trans-unit id="e97f41ad39a769cdba126aa050e98bd0bf28b8b9" translate="yes" xml:space="preserve">
          <source>Here's the default configuration for the default user:</source>
          <target state="translated">这是默认用户的默认配置。</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">提示:可以根据当前的Unix时间切换到不同的key,这样一来,每个key只需要相对较少的样本,避免处理非常大的key,也让这种模式更友好地分布在许多Redis实例中。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redis如何过期密钥</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何工作的?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">如何处理复制链接和AOF文件中的过期问题。</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">单一流上被屏蔽的多个客户端如何服务?</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">如何指定间隔时间</target>
        </trans-unit>
        <trans-unit id="d7cd6ea4777d91cd4768a12501593a68c032c01e" translate="yes" xml:space="preserve">
          <source>However Lua scripts running in Redis 6 or greater, are able to switch to RESP3 mode, and get the replies using the new available types. Similarly Lua scripts are able to reply to clients using the new types. Please make sure to understand &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;the capabilities for RESP3&lt;/a&gt; before continuing reading this section.</source>
          <target state="translated">但是，在Redis 6或更高版本中运行的Lua脚本可以切换到RESP3模式，并使用新的可用类型获取答复。同样，Lua脚本能够使用新类型来回复客户端。在继续阅读本节之前，请确保了解&lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;RESP3的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">但是，由于&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;具有很少的关联状态（仅是游标），因此具有以下缺点：</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">但是，如果偏移量以 &lt;code&gt;#&lt;/code&gt; 字符为前缀，则指定的偏移量将乘以整数类型的width，例如：</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">但是，在这种情况下，所获得的队列不&lt;em&gt;可靠，&lt;/em&gt;因为消息可能丢失，例如在出现网络问题或消费者在收到消息后立即崩溃但仍在处理中的情况下。</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">但是，它会尽快将OK返回给调用者，因此&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;命令本身不会暂停。</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">但是，节点哈希槽可以处于特殊状态，用于在节点重新启动之后传达错误（AOF / RDB文件中的键之间的不匹配以及节点哈希槽配置），或者正在进行分片操作时。这两个国家正在&lt;strong&gt;导入&lt;/strong&gt;和&lt;strong&gt;迁移&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">但是请注意，对于流而言，这不是问题：在为客户端提供服务时，不会从流中删除流条目，因此，只要&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;命令向流提供数据，每个等待的客户端都将得到服务。</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">但请注意:</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">但是，一旦数据结构更大并被提升为使用真实的哈希表，&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;系列命令将诉诸正常行为。请注意，由于这种返回所有元素的特殊行为仅对小型聚合才适用，因此对命令的复杂性或延迟没有影响。但是，要转换为真实哈希表的确切限制是&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;用户可配置的&lt;/a&gt;，因此一次调用中可以看到的最大元素数量取决于聚合数据类型的大小以及仍使用打包表示形式。</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">但从Redis 2.8.12或更高版本开始,该命令接受以下形式。</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">但是，该命令不能简单地从接收该命令的节点的内部节点表中删除该节点，它还实现了禁止列表，不允许再次添加同一节点，这是处理心跳数据包的&lt;em&gt;八卦部分&lt;/em&gt;的副作用从其他节点收到。</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">然而返回的元素数量是合理的,也就是说,在实际工作中,SCAN在迭代一个大型集合时,可能返回的元素数量最多为几十个,或者当迭代的集合小到可以在内部表示为一个编码数据结构时,可能在一次调用中返回集合的所有元素(这种情况发生在小型集合、哈希和排序集合上)。</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">但是用户可以对编码后的字符串进行转换,这样在排序集合中插入的元素的第一部分就会按照用户对具体应用的要求进行比较。例如,如果我想添加的字符串将以不区分大小写的方式进行比较,但我仍然希望在查询时检索真实的大小写,我可以用以下方式添加字符串。</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">然而用户仍然能够使用下面的简单技巧来编写具有随机行为的命令。想象一下,我想写一个Redis脚本,将用N个随机整数填充一个列表。</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">但是，用户可以使用&lt;strong&gt;COUNT&lt;/strong&gt;选项来调整每次调用返回的元素数量的数量级。</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">但是，此规则有一个例外，那就是从头开始创建新集群时。Redis Cluster &lt;em&gt;config epoch冲突解决&lt;/em&gt;算法可以在启动时处理所有配置了相同配置的新节点，但是此过程很慢，应该作为例外，只是为了确保无论发生什么情况，最终都会有两个以上的节点远离状态具有相同配置时代。</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">然而这也意味着执行慢速脚本不是一个好主意。创建快速脚本并不难,因为脚本开销很低,但如果你要使用慢速脚本,你应该注意,当脚本运行时,没有其他客户端可以执行命令。</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">然而,这是一个有用的功能,因为有时,我们需要只在主站中执行某些命令,以创建,例如,中间值。</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">然而这只是一个尽力的尝试,所以仍有可能失去同步复制到多个副本的写。</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">但是,由于插槽已经被分配,所以试图再次执行它的结果是一个错误。</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">但是，使用&lt;strong&gt;FORCE，&lt;/strong&gt;我们仍然需要大多数主服务器可用，以授权故障转移并为将成为主服务器的副本生成新的配置时期。</target>
        </trans-unit>
        <trans-unit id="c681766630e9b93da85df642b31ac53297dab87b" translate="yes" xml:space="preserve">
          <source>However what is often very useful, is to know the match position in each strings:</source>
          <target state="translated">然而,通常非常有用的是,知道每个字符串的匹配位置。</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">但是，尽管像&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;这样的阻塞命令能够在给定的时间内提供Set中所有元素，但是SCAN系列命令仅对返回的元素提供有限保证，因为我们递增迭代的集合可以在迭代过程中更改。</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">但是，尽管连接到主数据库的副本不会单独使密钥失效（而是等待来自主数据库的&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;），但它们仍将处于数据集中存在的到期的完整状态，因此当选择副本作为主数据库时它将能够独立使密钥失效，从而完全充当主密钥。</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">然而,请注意:</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">但是，如果您要寻找清除位并同时指定&lt;strong&gt;start&lt;/strong&gt;和&lt;strong&gt;end&lt;/strong&gt;的范围，则此行为会更改。如果在指定范围内未找到清除位，则函数将返回-1，因为用户指定了清除范围，并且该范围内没有0位。</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">人类可能会使用这个命令,以检查什么是哈希槽,然后相关的Redis集群节点,负责一个给定的密钥。</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">HyperLogLog代表</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">我可以从这个Ruby小程序开始。</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">保证ID始终是递增的:如果比较刚刚插入的条目的ID,它将大于其他过去的ID,所以条目在流里面是完全有序的。为了保证这个属性,如果流中当前最上面的ID的时间大于实例的当前本地时间,那么将使用最上面的条目时间来代替,并将ID的序列部分递增。例如,当本地时钟向后跳转时,或者在故障切换后,新的主站有不同的绝对时间时,就可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">ID由用 &lt;code&gt;-&lt;/code&gt; 字符分隔的两个数字指定：</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR key 将键的整数值增加一个。</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY key increment 按给定的数量增加键的整数值。</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT 键的增量 按给定的数量增加键的浮点数。</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [部分]获取有关服务器的信息和统计资料。</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">理想情况下， &lt;code&gt;used_memory_rss&lt;/code&gt; 值应仅略高于 &lt;code&gt;used_memory&lt;/code&gt; 。当使用rss &amp;gt;&amp;gt;时，相差很大意味着存在内存碎片（内部或外部），可以通过检查 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 进行评估。当使用&amp;gt;&amp;gt; rss时，这意味着Redis内存的一部分已被操作系统交换掉：预计会有一些显着的延迟。</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">如果&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;失败，则不会丢失任何数据，因为旧的AOF将保持不变。</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">如果&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;返回 &lt;code&gt;0&lt;/code&gt; ,则该密钥已经被其他客户端锁定。如果它是非阻塞锁，则可以返回到调用方，也可以进入一个循环重试以保持该锁，直到成功或某种超时到期为止。</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">如果&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;返回 &lt;code&gt;1&lt;/code&gt; ,则客户端获取了锁，将 &lt;code&gt;lock.foo&lt;/code&gt; 键设置为Unix时间，此时不再应将锁视为有效。客户端稍后将使用 &lt;code&gt;DEL lock.foo&lt;/code&gt; 来释放锁。</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">如果使用了&lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;，&lt;a href=&quot;discard&quot;&gt;DISCARD将&lt;/a&gt;取消监视连接监视的所有键。</target>
        </trans-unit>
        <trans-unit id="db30f622717bd53f660e926c446f65281d373325" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; is used, the command will immediately return &lt;code&gt;OK&lt;/code&gt; when an AOF rewrite is in progress and schedule the background save to run at the next opportunity.</source>
          <target state="translated">如果使用了 &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; ，则正在进行AOF重写时，该命令将立即返回 &lt;code&gt;OK&lt;/code&gt; ，并计划在下一次机会运行后台保存。</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">如果 &lt;code&gt;WITHCOORD&lt;/code&gt; ， &lt;code&gt;WITHDIST&lt;/code&gt; 或 &lt;code&gt;WITHHASH&lt;/code&gt; 选项，该命令将返回一个数组数组，其中每个子数组代表一个项目。</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">如果 &lt;code&gt;destination&lt;/code&gt; 已经存在，它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 已经存在并且是字符串，则此命令将 &lt;code&gt;value&lt;/code&gt; 附加在字符串的末尾。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则会创建它并将其设置为空字符串，因此&lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt;在这种特殊情况下将类似于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回nil批量答复。</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将创建一个新的已排序集合，其中指定成员为唯一成员，就像已排序集合为空一样。如果键存在但不包含排序集，则返回错误。</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中或 &lt;code&gt;key&lt;/code&gt; 不存在，则大&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;字符串答复&lt;/a&gt;： &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中，或者 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 存在于排序集中，则&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer答复&lt;/a&gt;： &lt;code&gt;member&lt;/code&gt; 的等级。</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">如果 &lt;code&gt;password&lt;/code&gt; 与配置文件中的密码匹配，则服务器将以 &lt;code&gt;OK&lt;/code&gt; 状态代码进行答复并开始接受命令。否则，将返回错误，并且客户端需要尝试新的密码。</target>
        </trans-unit>
        <trans-unit id="25efaee0f3cfe5471248ed210126224686506e29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if &lt;code&gt;wherefrom&lt;/code&gt; is the same as &lt;code&gt;whereto&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 不存在，则返回值 &lt;code&gt;nil&lt;/code&gt; 并且不执行任何操作。如果 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 相同，则该操作等效于从列表中删除第一个/最后一个元素并将其作为列表的第一个/最后一个元素推送，因此可以将其视为列表轮换命令（或无操作）如果 &lt;code&gt;wherefrom&lt;/code&gt; 与 &lt;code&gt;whereto&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 不存在，则返回值 &lt;code&gt;nil&lt;/code&gt; 并且不执行任何操作。如果 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 相同，则该操作等效于从列表中删除最后一个元素并将其推入列表的第一个元素，因此可以将其视为列表轮换命令。</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">如果 &lt;code&gt;ttl&lt;/code&gt; 为0，则创建密钥时不会有任何过期，否则将设置指定的过期时间（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">如果启动了AOF,将增加这些附加字段。</target>
        </trans-unit>
        <trans-unit id="3a074c9af49d118ca170e19c962a9318fe91cfe4" translate="yes" xml:space="preserve">
          <source>If a Redis 6.0 instance, or greater, is using the &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL system&lt;/a&gt;.</source>
          <target state="translated">如果Redis 6.0实例或更高版本正在使用&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">如果Redis子项正在磁盘上创建快照，则&lt;em&gt;安排&lt;/em&gt; AOF重写，但不会开始AOF重写，直到生成RDB文件的保存子项终止。在这种情况下，&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;仍将返回OK代码，但带有适当的消息。从Redis 2.6起，您可以查看&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令来检查是否计划了AOF重写。</target>
        </trans-unit>
        <trans-unit id="a26aac34716b82962d62dd7eb321e26db471b019" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an positive status reply, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6 or successive versions.</source>
          <target state="translated">如果Redis子项正在磁盘上创建快照，则将&lt;em&gt;安排&lt;/em&gt;AOF重写，但不会开始AOF重写，直到生成RDB文件的保存子项终止。在这种情况下，&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;仍将返回肯定的状态回复，但带有适当的消息。从Redis 2.6或后续版本开始，您可以查看&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;命令来检查是否计划进行AOF重写。</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">如果Redis服务器已经充当副本，则命令&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE将关闭复制，从而将Redis服务器变成MASTER。以适当的格式，&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;主机名端口将使该服务器成为另一台侦听指定主机名和端口的服务器的副本。</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">如果SYNC操作正在进行,则提供这些附加字段。</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">如果一个群集实例有不连续的槽(如1-400,900,1800-6000),那么对于每个顶层槽范围的回复,主站和副本的IP/端口结果将是重复的。</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">如果一个命令接受的键数不限,最后一个键位为-1。</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">如果一个命令接受一个键,第一个键和最后一个键的位置是1。</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">如果命令接受两个键（例如&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;，&lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;，&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;等），则最后一个键的位置就是参数列表中最后一个键的位置。</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">如果收到有关不存在的密钥的命令，则节点发出 &lt;code&gt;ASK&lt;/code&gt; 重定向，要求客户端仅将特定查询重试到 &lt;code&gt;destination-node&lt;/code&gt; 。在这种情况下，客户端不应更新其哈希槽到节点的映射。</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">如果收到关于现有密钥的命令,则按通常的方式处理该命令。</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">如果密钥被&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;覆盖，例如现有密钥 &lt;code&gt;Key_A&lt;/code&gt; 被 &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; 之类的调用覆盖，则原始 &lt;code&gt;Key_A&lt;/code&gt; 是否与超时关联都 &lt;code&gt;Key_A&lt;/code&gt; ，新密钥Key_A将继承所有 &lt;code&gt;Key_B&lt;/code&gt; 的特征。</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">如果使用&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;重命名了密钥，则相关的生存时间将转移到新的密钥名称。</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">如果正在进行加载操作,则会添加这些附加字段。</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">如果一个具有未绑定哈希槽的节点从另一个自称是其中一些哈希槽的所有者的节点接收到心跳数据包,关联就会立即建立。此外,如果收到的心跳或更新消息的配置时长大于节点自身的配置时长,则关联会被重新建立。</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">如果服务器已经是某个主服务器的副本，则&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;主机名端口将停止针对旧服务器的复制，并针对新服务器启动同步，并丢弃旧数据集。</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">如果服务器已经是某个主服务器的副本，则&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;主机名端口将停止针对旧服务器的复制，并针对新服务器启动同步，并丢弃旧数据集。</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">如果AOF重写已经在进行中,该命令将返回一个错误,以后将不会安排AOF重写。</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">如果旧的redis.conf文件中已经存在一个选项,那么它将被重写在相同的位置(行号)。</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">如果一个选项不存在,但它被设置为非默认值,它将被附加在文件的最后。</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">如果一个选项不存在,但它被设置为默认值,则不会被重写过程添加。</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">如果另一个客户端（例如C5）比C4快，并通过&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作获得了锁定，则C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作将返回未过期的时间戳。C4将仅从第一步重新启动。请注意，即使C4在将来几秒钟设置了密钥，这也不是问题。</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">如果在给定的时间某个节点上有另一个标记为 &lt;code&gt;PFAIL&lt;/code&gt; 的节点，并且同时收集了有关该节点的大多数其他主节点&lt;em&gt;故障报告&lt;/em&gt;（如果是主节点，则包括其自身），那么它将提升该节点的故障状态从 &lt;code&gt;PFAIL&lt;/code&gt; 到 &lt;code&gt;FAIL&lt;/code&gt; 并广播一条消息，强制可以到达的所有节点将节点标记为 &lt;code&gt;FAIL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">如果count大于Set内的元素数,命令将只返回整个Set,不包含额外的元素。</target>
        </trans-unit>
        <trans-unit id="b7b84ded8883c2f1d689aced4377969210247451" translate="yes" xml:space="preserve">
          <source>If every line in the file is valid, all the ACLs are loaded.</source>
          <target state="translated">如果文件中的每一行都是有效的,所有的ACL都会被加载。</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">相反，如果消息已经传递给该使用者，并且它只是再次重新获取同一条消息，则&lt;em&gt;最后一个传递计数器&lt;/em&gt;将更新为当前时间，&lt;em&gt;传递&lt;/em&gt;的&lt;em&gt;数量&lt;/em&gt;增加一个。您可以使用&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;命令访问那些消息属性。</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">如果你想让消费者获取整个流历史,则使用0作为消费者组的起始ID。</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">如果超过25%的钥匙过期,从步骤1重新开始。</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">如果为同一密钥阻止了多个客户端，则要服务的第一个客户端是等待更多时间的客户端（第一个为密钥阻止的客户端）。解除阻止客​​户端后，它不会保留任何优先级，当再次调用&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;再次阻止该客户端时，将根据已经为同一密钥阻止的客户端数量相应地服务该客户端（从第一个密钥开始）到被阻止的最后一个）。</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">如果未指定任何 &lt;code&gt;pattern&lt;/code&gt; ，则列出所有通道，否则，如果仅指定模式，则仅列出与指定的glob样式模式匹配的通道。</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">如果未指定重置类型，则默认值为&lt;strong&gt;soft&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">如果指定的密钥都不存在，则&lt;a href=&quot;blpop&quot;&gt;BLPOP会&lt;/a&gt;阻止连接，直到另一个客户端对其中一个密钥执行&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;或&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">如果缺少一个或两个成员,命令返回NULL。</target>
        </trans-unit>
        <trans-unit id="65c7882ecd3026e90538dbca3412ed2c9efa54bf" translate="yes" xml:space="preserve">
          <source>If one or more line in the file is not valid, nothing is loaded, and the old ACL rules defined in the server memory continue to be used.</source>
          <target state="translated">如果文件中的一行或多行无效,则不加载任何内容,继续使用服务器内存中定义的旧ACL规则。</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">如果启用了持久性，则此命令确保关闭Redis，而不会丢失任何数据。如果客户端仅使用&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt;然后&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;，则不能保证这样做，因为其他客户端可能会在两个命令之间更改DB数据。</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">如果指定了&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;选项，则返回值为&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5342c7f917832f9f61b997cae89d595cc203017d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="translated">如果使用了 &lt;code&gt;ABSTTL&lt;/code&gt; 修饰符，则 &lt;code&gt;ttl&lt;/code&gt; 应该表示密钥将在其中终止的绝对&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix时间戳&lt;/a&gt;（以毫秒为单位）。（Redis 5.0或更高版本）。</target>
        </trans-unit>
        <trans-unit id="aa0a958c78e44fc13ec8f13707e023532ae594ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="translated">如果使用了 &lt;code&gt;ABSTTL&lt;/code&gt; 修饰符，则 &lt;code&gt;ttl&lt;/code&gt; 应该表示密钥将在其中终止的绝对&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix时间戳&lt;/a&gt;（以毫秒为单位）。（Redis 5.0或更高版本）。</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">如果不使用&lt;strong&gt;BLOCK&lt;/strong&gt;选项，则该命令是同步的，并且可以认为与&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;有关：它将返回流中的一系列项目，但是，即使我们仅考虑同步用法，它与&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;相比也有两个基本区别：</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">如果指定了&lt;strong&gt;FORCE&lt;/strong&gt;选项，则副本不会与主服务器进行任何握手，这可能无法实现，而只是从第4点开始尽快启动故障转移。当我们要在主服务器上启动手​​动故障转移时，此方法很有用。不再可达。</target>
        </trans-unit>
        <trans-unit id="41e165a8913dade3e9bd91924016ff8d6cab273f" translate="yes" xml:space="preserve">
          <source>If the AOF rewrite could start, but the attempt at starting it fails (for instance because of an error in creating the child process), an error is returned to the caller.</source>
          <target state="translated">如果AOF重写可以启动,但启动的尝试失败了(例如因为创建子进程时出错),将向调用者返回一个错误。</target>
        </trans-unit>
        <trans-unit id="32dde384b66bbd79b525259d52aa9797e8b17bb3" translate="yes" xml:space="preserve">
          <source>If the Redis server is password protected via the &lt;code&gt;requirepass&lt;/code&gt; option.</source>
          <target state="translated">如果Redis服务器通过 &lt;code&gt;requirepass&lt;/code&gt; 选项受密码保护。</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果在Redis 2.6或更高版本的服务器上发生上述情况，则客户端&lt;strong&gt;A&lt;/strong&gt;将使用 &lt;code&gt;c&lt;/code&gt; 元素，因为在&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;命令之后，列表包含 &lt;code&gt;c,b,a&lt;/code&gt; ，因此从左侧获取元素意味着返回 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">如果在执行命令后HyperLogLog估计的近似基数发生变化，则&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;返回1，否则返回0。如果指定的键不存在，该命令会自动创建一个空的HyperLogLog结构（即，具有指定长度的Redis字符串，并具有给定的编码）。</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">如果客户端订阅了一个通道或模式,它将代替返回一个在第一个位置有 &quot;pong &quot;的多体,在第二个位置有一个空体,除非提供了一个参数,在这种情况下,它将返回一个参数的副本。</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">如果客户端尝试阻止多个键，但是至少一个键包含元素，则返回的键/元素对是从左到右的第一个具有一个或多个元素的键。在这种情况下，客户端不会被阻止。因此，例如 &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; ，假设 &lt;code&gt;key2&lt;/code&gt; 和 &lt;code&gt;key4&lt;/code&gt; 均为非空，将始终从 &lt;code&gt;key2&lt;/code&gt; 返回一个元素。</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">如果命令包含多个键，如果不存在，则行为与点2相同，如果全部存在，则其行为与点1相同，但是，如果仅存在部分键，则该命令在以下位置发出 &lt;code&gt;TRYAGAIN&lt;/code&gt; 错误：命令将感兴趣的密钥完成迁移到目标节点，以便可以执行multi keys命令。</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">如果命令是作为&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;事务的一部分发送的，则该命令不会阻塞，而只会尽快返回确认先前写入命令的副本数。</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">如果命令成功,新的增量值将被存储为键的新值(替换旧值),并以字符串的形式返回给调用者。</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">如果命令成功,新的副本将立即尝试联系其主站,以便从它那里复制。</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">如果当前哈希槽的所有者是接收命令的节点,但为了使命令生效,该槽将被分配给不同的节点,如果接收命令的节点中仍有该哈希槽的密钥,则该命令将返回错误。</target>
        </trans-unit>
        <trans-unit id="8bdc0729f7e8e3e8d69c4bf5f17ea02031eef1ea" translate="yes" xml:space="preserve">
          <source>If the destination variable exists, it is treated as one of the source sets and its cardinality will be included in the cardinality of the computed HyperLogLog.</source>
          <target state="translated">如果目标变量存在,它将被视为源集之一,它的cardinality将包含在计算的HyperLog的cardinality中。</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">如果排序集合中的元素有不同的分数,则返回的元素是不指定的。</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">如果实例是一个副本,则提供这些附加字段。</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">如果主站和副本之间的链接中断,则提供一个额外的字段。</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">如果消息从来没有传递给任何人,也就是说,如果我们谈论的是一个新的消息,那么就会创建一个PEL(Pending Entry List)。</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">如果节点是一个副本,它就会变成一个(空的)主节点。它的数据集会被刷新,所以最后节点会变成一个空的主节点。</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">如果接收到该命令的节点还不是副本,而是主节点,那么只有在满足以下附加条件的情况下,该命令才会成功,该节点才会被转换为副本。</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">如果你试图检查的对象缺失,将返回一个空的批量回复。</target>
        </trans-unit>
        <trans-unit id="502f345996f0414bbb8039bdf0ba7a24bdfc3f8f" translate="yes" xml:space="preserve">
          <source>If the password provided via AUTH matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">如果通过AUTH提供的密码与配置文件中的密码匹配，则服务器将以 &lt;code&gt;OK&lt;/code&gt; 状态代码答复并开始接受命令。否则，将返回错误，并且客户端需要尝试新的密码。</target>
        </trans-unit>
        <trans-unit id="8069378ad909326b9b791fda111aafbf70922eb2" translate="yes" xml:space="preserve">
          <source>If the rules contain errors, the error is returned.</source>
          <target state="translated">如果规则包含错误,则返回错误。</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">如果脚本已经调用了write命令，则唯一允许的命令变为 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; ，它将停止服务器而不将当前数据集保存在磁盘上（基本上是服务器被中止）。</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">如果脚本已经执行了写操作，则不能以这种方式终止它，因为它会违反Lua脚本原子性契约。在这种情况下，只有 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 才能杀死该脚本，从而以一种很难的方式杀死Redis进程，从而阻止该脚本以半写信息保留。</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">如果服务器不记得带有此SHA1摘要的脚本，则会返回一个特殊错误，告诉客户端改用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">如果服务器配置有 &lt;code&gt;min-slaves-to-write&lt;/code&gt; 指令（或从Redis 5开始，带有 &lt;code&gt;min-replicas-to-write&lt;/code&gt; 指令），则会提供一个附加字段：</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">如果服务器仍然记得一个具有匹配SHA1摘要的脚本,那么该脚本将被执行。</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">如果插槽处于&lt;em&gt;迁移&lt;/em&gt;状态，则将该插槽分配给另一个节点后，该状态将被清除。</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">如果插槽在接收该命令的节点中处于&lt;em&gt;导入&lt;/em&gt;状态，并且该命令将该插槽分配给该节点（在哈希节点从一个节点到另一个节点的重新分片结束时在目标节点中发生），则该命令具有有以下副作用：A）清除了&lt;em&gt;导入&lt;/em&gt;状态。 B）如果节点配置纪元还不是集群中最大的节点，它将生成一个新的节点并将其分配给自己。这样，其新的哈希插槽所有权将赢得以前的故障转移或插槽迁移创建的任何过去配置。</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">如果源集不存在或不包含指定的元素，则不执行任何操作，并返回 &lt;code&gt;0&lt;/code&gt; 。否则，该元素将从源集中删除，然后添加到目标集中。如果指定的元素已存在于目标集中，则仅将其从源集中删除。</target>
        </trans-unit>
        <trans-unit id="3ca48297ca2c9df85be826386d88391801b54916" translate="yes" xml:space="preserve">
          <source>If the specified stream doesn't exist when creating a group, an error will be returned. You can use the optional &lt;code&gt;MKSTREAM&lt;/code&gt; subcommand as the last argument after the &lt;code&gt;ID&lt;/code&gt; to automatically create the stream, if it doesn't exist. Note that if the stream is created in this way it will have a length of 0:</source>
          <target state="translated">如果创建组时指定的流不存在，将返回错误。您可以使用可选的 &lt;code&gt;MKSTREAM&lt;/code&gt; 子命令作为 &lt;code&gt;ID&lt;/code&gt; 后的最后一个参数，以自动创建流（如果不存在）。请注意，如果以这种方式创建流，则其长度将为0：</target>
        </trans-unit>
        <trans-unit id="b2a65b6aeeded425b23af7e95965a0f641dbdc37" translate="yes" xml:space="preserve">
          <source>If the user already exists, the provided ACL rules are simply applied &lt;em&gt;in addition&lt;/em&gt; to the rules already set. For example:</source>
          <target state="translated">如果用户已经存在，则&lt;em&gt;除了&lt;/em&gt;已设置的规则&lt;em&gt;外&lt;/em&gt;，还仅应用提供的ACL规则。例如：</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">如果用户将所有元素插入具有相同分数（例如0）的排序集中，则该排序集中的所有元素均按字典顺序排序，并且可以使用命令&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;对元素进行范围查询（注意：也可以使用&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;按分数范围查询排序的集合。</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">如果用户将闲置时间超过60秒,该键将被删除,只记录后续差值小于60秒的页面浏览。</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">如果源实例中没有要迁移的密钥，则返回 &lt;code&gt;NOKEY&lt;/code&gt; 。因为在正常情况下可能会丢失键，例如从到期起， &lt;code&gt;NOKEY&lt;/code&gt; 并不是错误。</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">如果我们生成的配置时期恰巧与另一个实例发生冲突，那么最终我们的配置时期或具有相同时期的另一个实例中的一个，将使用&lt;em&gt;配置时期冲突解决算法&lt;/em&gt;来移走。</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">如果我们寻找清除位（bit参数为0），并且字符串仅包含设置为1的位，则该函数将返回第一个位，而不是右侧字符串的一部分。因此，如果字符串是设置为值 &lt;code&gt;0xff&lt;/code&gt; 的三个字节，则命令 &lt;code&gt;BITPOS key 0&lt;/code&gt; 将返回24，因为直到第23位，所有位均为1。</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">如果我们寻找设置位(位参数为1),并且字符串为空或仅由零字节组成,则返回-1。</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">如果您致电&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;或&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;，则无需手动致电&lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">如果你有一个流和多个客户端,并且你希望所有的客户端都能收到所有的消息,你就不需要一个消费者组。</target>
        </trans-unit>
        <trans-unit id="7914b0ae2e05e8d2f74a0d7390601ab548d893de" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;sharded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">如果你有一个流和多个客户端，并且希望流进行&lt;em&gt;分区&lt;/em&gt;或&lt;em&gt;分片&lt;/em&gt;在你的客户，让每一个客户将获得一个子集流到达的消息，你需要一个消费群体。</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">如果您有一个流和多个客户端，并且希望在客户端之间对流进行&lt;em&gt;分区&lt;/em&gt;或&lt;em&gt;共享&lt;/em&gt;，以使每个客户端都可以收到流中到达的消息的子集，那么您需要一个使用者组。</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">如果您喜欢科幻小说，那么想想时间在&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;块中以无限的速度流动...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">如果您寻找 &lt;code&gt;XGET&lt;/code&gt; 命令，将会感到失望，因为&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;是从流中获取单个条目的有效方法。您要做的就是在XRANGE的参数中两次指定ID：</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">如果你要求提供不存在的命令的详细信息,它们的返回位置将是nil。</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">想象一下，您拥有一个Web服务，并且您对用户&lt;em&gt;最近&lt;/em&gt;访问的最新N页感兴趣，因此每个相邻的页面视图执行的时间都不超过前一个页面的60秒。从概念上讲，您可以将这组页面视图视为用户的&lt;em&gt;导航会话&lt;/em&gt;，其中可能包含有关他或她当前正在寻找哪种产品的有趣信息，以便您可以推荐相关产品。</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">假设你有元素A,B和C,它们的权重分别是1,2和3。你计算权重之和,即1+2+3=6。</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">实施&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">实施细节和说明</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">实施细节。MEET和PING数据包</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">重要提示：&lt;strong&gt;无需&lt;/strong&gt;为每次迭代&lt;strong&gt;使用相同的COUNT值&lt;/strong&gt;。调用者可以根据需要自由地将计数从一个迭代更改为另一个迭代，只要在下一个调用中传递的游标是在上一次对该命令的调用中获得的游标即可。</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">导入和迁移插槽在&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出中发出，如下所示：</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">提供导入和迁移插槽作为&lt;strong&gt;附加信息&lt;/strong&gt;。如果为节点分配了给定的哈希槽，则它在哈希槽列表中也将是一个纯数字，因此不了解哈希槽迁移信息的客户端可以跳过此特殊字段。</target>
        </trans-unit>
        <trans-unit id="779e3f1f46c82af5ed6e618104fadfbd8c5eb506" translate="yes" xml:space="preserve">
          <source>In Cluster mode, both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;newkey&lt;/code&gt; must be in the same &lt;strong&gt;hash slot&lt;/strong&gt;, meaning that in practice only keys that have the same hash tag can be reliably renamed in cluster.</source>
          <target state="translated">在集群模式下， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;newkey&lt;/code&gt; 必须都在同一&lt;strong&gt;哈希槽中&lt;/strong&gt;，这意味着实际上只有具有相同hash标签的密钥才能在集群中可靠地重命名。</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">在Redis 2.4中,过期时间可能不是很精确,可能在零到一秒之间出。</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">在Redis 2.6或更早版本中，如果密钥不存在或密钥存在但没有关联的过期时间，则命令返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">在Redis Cluster中,每个节点都会跟踪哪个主站在为某个哈希槽服务。</target>
        </trans-unit>
        <trans-unit id="d172f4fd77faed8def89fa030ed71bc01d833ea7" translate="yes" xml:space="preserve">
          <source>In Redis version 4, commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements. However starting with Redis 5 there is no longer such ordering step, because Redis 5 replicates scripts in a way that no longer needs non-deterministic commands to be converted into deterministic ones. In general, even when developing for Redis 4, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</source>
          <target state="translated">在Redis版本4中，可能会以随机顺序返回元素的命令，例如&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（因为Redis集是&lt;em&gt;无序的&lt;/em&gt;），当从Lua调用时，它们具有不同的行为，并且在将数据返回到Lua脚本之前经过静默词典编排过滤器。所以 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 将始终以相同的顺序返回Set元素，而从普通客户端调用的相同命令可能会返回不同的结果，即使键包含的元素完全相同。但是从Redis 5开始，不再需要这种排序步骤，因为Redis 5以不再需要将非确定性命令转换为确定性命令的方式来复制脚本。通常，即使在为Redis 4开发时，也不要以为Lua中的某些命令将被排序，而是依靠您调用的原始命令的文档来查看其提供的属性。</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">在Redis版本&lt;strong&gt;2.1.3&lt;/strong&gt;之前的版本中，使用更改其值的命令来更改具有过期集的密钥具有完全删除密钥的作用。由于现在已修复了复制层中的限制，因此需要此语义。</target>
        </trans-unit>
        <trans-unit id="532b5a4c8c089bdea2a3dcd755e5c2d0a78f31ac" translate="yes" xml:space="preserve">
          <source>In a Redis Cluster clients can publish to every node. The cluster makes sure that published messages are forwarded as needed, so clients can subscribe to any channel by connecting to any one of the nodes.</source>
          <target state="translated">在Redis集群中,客户端可以向每个节点发布消息。集群会确保发布的消息根据需要进行转发,因此客户端可以通过连接到任何一个节点来订阅任何通道。</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">在Redis的未来版本中,我们有可能在给定的宏节点达到给定的删除条目数量时,触发节点垃圾收集。目前以我们对这个数据结构的使用预期,增加这样的复杂性不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">通常，您应该知道的是，将 &lt;code&gt;appendonly&lt;/code&gt; 参数设置为 &lt;code&gt;yes&lt;/code&gt; 将启动后台进程以保存初始的仅附加文件（从内存数据集中获取），并将所有后续命令附加在仅附加文件上，从而获得与自启动以来开启AOF的Redis服务器完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">只要有更多可用项，该命令就可以以其同步形式获取新数据。但是，在某些时候，我们将不得不等待数据生产者使用&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;将新条目推入我们正在使用的流中。为了避免以固定或自适应间隔进行轮询，如果命令无法返回任何数据，则可以根据指定的流和ID进行阻止，并在请求的键之一接受数据后自动解除阻止。</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">在已指定的字节或其它数量的选项，这是不可能使用 &lt;code&gt;redis.conf&lt;/code&gt; 缩写形式（ &lt;code&gt;10k&lt;/code&gt; ， &lt;code&gt;2gb&lt;/code&gt; ...等等），一切都应该被指定为形成良好的64位整数，在配置指令的基本单位。但是，由于Redis版本3.0或更高版本，可以将&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;与用于 &lt;code&gt;maxmemory&lt;/code&gt; 内存，客户端输出缓冲区和复制积压大小的内存单元一起使用。</target>
        </trans-unit>
        <trans-unit id="a7b5d3135e15286cfdbe38c07d4aa01f9fe0988a" translate="yes" xml:space="preserve">
          <source>In order to authenticate the current connection with one of the connections defined in the ACL list (see &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;) and the official &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL guide&lt;/a&gt; for more information.</source>
          <target state="translated">为了使用ACL列表（请参阅&lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;）和官方&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL指南中&lt;/a&gt;定义的连接之一对当前连接进行身份验证，以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">为了避免这些问题并避免带宽损失，Redis实现了&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">为了阻止，使用了&lt;strong&gt;BLOCK&lt;/strong&gt;选项，以及在超时之前我们要阻止的毫秒数。通常，Redis阻止命令的超时时间以秒为单位，但是，即使服务器通常具有接近0.1秒的超时分辨率，该命令也会以毫秒为单位超时。这段时间可能会在某些使用情况下将时间缩短，并且如果服务器内部性能会随着时间的推移而改善，则超时的分辨率可能会提高。</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">为了启用脚本效果复制,你需要在脚本进行任何写操作之前发出以下 Lua 命令。</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">为了启用此格式，使用了&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;选项，并且正常的&lt;em&gt;key&lt;/em&gt;参数设置为空字符串。实际的键名称将在&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;参数本身之后提供，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="ae1f75fb4769a06b17ea6f198ef59cd43ba00d55" translate="yes" xml:space="preserve">
          <source>In order to enable tracking, use:</source>
          <target state="translated">为了启用跟踪,请使用:</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">为了在脚本中强制执行这种行为,Redis做了以下工作。</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">为了修复某些槽位未分配的破碎集群。</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">为了对一个流进行迭代,我们可以进行如下操作。假设我们每次迭代需要两个元素。我们开始获取前两个元素,这是微不足道的。</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">为了使它成为一个纯函数,但仍然确保每次调用脚本都会产生不同的随机元素,我们可以简单地在脚本中添加一个额外的参数,用来给 Lua 伪随机数生成器播种。新脚本如下。</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">为了确保redis.conf文件始终是一致的，也就是说，在发生错误或崩溃时，您总是以旧文件或新文件结尾，重写是通过具有足够内容的单个 &lt;code&gt;write(2)&lt;/code&gt; 调用执行的至少与旧文件一样大。有时以注释的形式添加其他填充，以确保生成的文件足够大，然后该文件被截断以最后删除填充。</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">为了使此锁定算法更健壮，持有锁的客户端应始终检查超时是否过期，然后再使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;解锁密钥，因为客户端失败可能很复杂，不仅会崩溃，而且还会浪费很多时间进行某些操作并在很多时间后尝试发布&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;（当LOCK已被另一个客户端持有时）。</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">为了在不牺牲一致性的情况下获得正确的行为，当密钥过期时，将在AOF文件中合成&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作并获得所有附加的副本节点。这样，到期过程就集中在主实例中，并且不会出现一致性错误。</target>
        </trans-unit>
        <trans-unit id="a4d1c1dcdd2afe763b414a4824111916d472be49" translate="yes" xml:space="preserve">
          <source>In order to switch to RESP3 a script should call this function:</source>
          <target state="translated">为了切换到RESP3,脚本应该调用这个函数。</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">换句话说,Lua和Redis类型之间是一对一的转换。下表显示了所有的转换规则。</target>
        </trans-unit>
        <trans-unit id="b63d884600898ba55bb1960529b41996e05a6f02" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should be used to separate different keys belonging to the same application (if needed), and not to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">在实际应用中,Redis数据库应该用于分离属于同一应用的不同键(如果需要的话),而不是将一个Redis实例用于多个不相关的应用。</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">在实际应用中,Redis数据库主要应该是为了在需要的时候,将属于同一应用的不同键分开,而不是为了将一个Redis实例用于多个不相关的应用。</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">在 &lt;code&gt;COUNT&lt;/code&gt; 选项文档中，我们指出，有时该命令族可能在一次调用中一次返回Set，Hash或Sorted Set的所有元素，而与 &lt;code&gt;COUNT&lt;/code&gt; 选项的值无关。发生这种情况的原因是，仅当我们要扫描的聚合数据类型表示为哈希表时，才可以实现基于游标的迭代器，并且它很有用。但是，Redis使用&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;内存优化&lt;/a&gt;，其中使用紧凑的单分配压缩编码来表示小的聚合数据类型，直到它们达到给定数量的项或给定的单个元素的最大大小为止。在这种情况下，请&lt;a href=&quot;scan&quot;&gt;扫描&lt;/a&gt; 没有有意义的游标要返回，并且必须立即迭代整个数据结构，因此它唯一明智的行为是在调用中返回所有内容。</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">在上述情况下，条目 &lt;code&gt;1526985054069-0&lt;/code&gt; 存在，否则服务器将向我们发送下一个条目。使用 &lt;code&gt;COUNT&lt;/code&gt; 也是将&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;用作迭代器的基础。</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">在上面的计算天数的示例中，即使应用程序已运行10年，我们每个用户仍然只有 &lt;code&gt;365*10&lt;/code&gt; 位数据，每个用户只有456个字节。有了这样的数据量，&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;仍然与任何其他O（1）Redis命令（如&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;或&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;）一样快。</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅当消息闲置至少一小时而原始消费者或某些其他消费者没有进展（确认或声明）时，我们才声明ID为 &lt;code&gt;1526569498055-0&lt;/code&gt; 的消息，并将所有权分配给消费者 &lt;code&gt;Alice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">在上面的例子中,你可以看到报告的信息是流的元素数量,关于代表流的radix树的细节,主要是对优化和调试任务有用,与流相关联的消费者组的数量,最后生成的ID可能与最后的条目ID不一样,以防某些条目被删除。最后显示了流中完整的第一个和最后一个条目,以便对流的内容有一定的了解。</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">在上面的锁定算法中,有一个问题:如果客户机失败、崩溃或者其他原因无法释放锁,会发生什么情况?可以检测到这种情况,因为锁键包含一个UNIX时间戳。如果这样的时间戳等于当前的Unix时间,锁就不再有效。</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">在&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;的情况下，键位于其他位置，因此步长值为2。与上面的&lt;a href=&quot;mget&quot;&gt;MGET（&lt;/a&gt;步长仅为1）进行比较。</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">在已经接收到 &lt;code&gt;DELSLOTS&lt;/code&gt; 命令并因此删除了传递的哈希槽的关联的节点的上下文中，我们说这些哈希槽是&lt;em&gt;未绑定的&lt;/em&gt;。请注意，未绑定哈希槽的存在是自然发生的，这是因为未将节点配置为处理它们（可以使用 &lt;code&gt;ADDSLOTS&lt;/code&gt; 命令完成），并且如果它未收到有关谁拥有那些哈希槽的任何信息（它可以从心跳中学习或更新消息）。</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">在流消费者组的上下文中,这条命令改变了一个待处理消息的所有权,因此新的所有者是作为命令参数指定的消费者。通常情况下,会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">在上面的例子中,第一次调用使用0作为游标,开始迭代。第二次调用使用前一次调用返回的游标作为回复的第一个元素,即17。</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">在扩展表格中,我们不再看到摘要信息,取而代之的是待处理条目列表中每条消息的详细信息。对于每条消息,我们会返回四个属性。</target>
        </trans-unit>
        <trans-unit id="611f148b8dfb6f6978d2aeb35216b9ff55929cae" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there is detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">在扩展表格中,我们不再看到摘要信息,取而代之的是待处理条目列表中每条消息的详细信息。对于每条消息,我们会返回四个属性。</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">在以下示例中，对&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;的首次调用不使用超时，而是要求写入达到1个副本。它以成功返回。相反，在第二次尝试中，我们设置了超时时间，并要求将写入复制到两个副本。由于只有一个副本可用，因此&lt;a href=&quot;wait&quot;&gt;等待&lt;/a&gt;一秒钟后WAIT会解除阻止并返回1，因此副本数量已达到。</target>
        </trans-unit>
        <trans-unit id="8e23d6a61281506fa3e98f414bcf348728e15107" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays containing nils and keys are handled:</source>
          <target state="translated">在下面的例子中,我们可以看到如何处理包含nils和key的floats和数组。</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">在下面的例子中,我们可以看到如何处理浮点数和带nils的数组。</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">在下面的例子中,我们将说明为什么该命令不仅要从节点表中删除某个节点,而且还要防止它在一段时间内再次被插入。</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">在下面的例子中,你可以看到一旦Redis不再能够使用节省空间的编码,编码是如何变化的。</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">在&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;实现的特定情况下，Redis会为每个客户端记住在给定客户端的上下文中执行给定写入命令时所产生的复制流的复制偏移。当&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;被称为Redis的检查指定的副本数量已经承认了这一点偏移或更大的一个。</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">在这种情况下，&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;将自动完成 &lt;code&gt;-0&lt;/code&gt; 的开始间隔和 &lt;code&gt;-18446744073709551615&lt;/code&gt; 结束间隔，以返回在给定毫秒与另一个指定毫秒结束之间生成的所有条目。这也意味着重复相同的毫秒两次，我们将获得该毫秒内的所有条目，因为序列号的范围是从零到最大值。</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">在这种形式下,命令返回存储在指定键处的流的一般信息。</target>
        </trans-unit>
        <trans-unit id="fb6df0247f8ef1848f5f3284e1802dec98219082" translate="yes" xml:space="preserve">
          <source>In this form the command returns the entire state of the stream, including entries, groups, consumers and PELs. This form is available since Redis 6.0.</source>
          <target state="translated">在这种形式下,命令返回流的整个状态,包括条目、组、消费者和PEL。这种形式从Redis 6.0开始可用。</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">在这种形式下,我们只是得到与流相关联的所有消费者群体作为输出。</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">在这种形式下,命令输出该消费者组的待处理消息总数,即为1,然后输出待处理消息中最小和最大的ID,再列出该消费者组中每一个至少有一条待处理消息的消费者,以及它的待处理消息数量。</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">在这种特殊情况下，运行单个&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;客户端可以将吞吐量降低50％以上。运行更多的&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;客户端将进一步降低吞吐量。</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">在这种复制模式下,当 Lua 脚本执行时,Redis 会收集 Lua 脚本引擎执行的所有实际修改数据集的命令。当脚本执行结束后,脚本生成的命令序列被包装成一个MULTI/EXEC事务,并被发送到复制体和AOF。</target>
        </trans-unit>
        <trans-unit id="9c59d992fdad2d2103f7862e5997a95c45fa8f53" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing an ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">这样，示例消费者代码将仅获取新消息，对其进行处理并通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;对其进行确认。但是，上面的示例代码并不完整，因为它无法处理崩溃后的恢复。如果我们在处理消息的过程中崩溃，将发生的事情是消息将保留在待处理的条目列表中，因此我们可以通过为&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;最初设置ID为0并执行相同的循环来访问历史记录。一旦提供ID为0，答复就是一组空消息，我们知道我们已经处理并确认了所有待处理消息：我们可以开始使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为ID，以获取新消息并重新加入正在处理的使用者新事物。</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">这样，示例消费者代码将仅获取新消息，对其进行处理并通过&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;对其进行确认。但是，上面的示例代码并不完整，因为它无法处理崩溃后的恢复。如果我们在处理消息的过程中崩溃，将发生的事情是消息将保留在待处理条目列表中，因此我们可以通过为&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;最初设置ID为0并执行相同的循环来访问历史记录。一旦提供ID为0的答复，便是一组空消息，我们知道我们已经处理并确认了所有待处理消息：我们可以开始使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为ID，以获取新消息并重新加入正在处理的使用者新事物。</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">这样，当处于迁移状态的节点生成 &lt;code&gt;ASK&lt;/code&gt; 重定向时，客户端联系目标节点，发送 &lt;code&gt;ASKING&lt;/code&gt; ，并在发送命令后立即进行。这样，将在目标节点中执行有关旧节点中不存在的密钥或已迁移到目标节点的密钥的命令，以便：</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">不完整的ID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">递增指定 &lt;code&gt;field&lt;/code&gt; 存储在散列的 &lt;code&gt;key&lt;/code&gt; ，和表示浮点数，由指定的 &lt;code&gt;increment&lt;/code&gt; 。如果增量值为负，则结果将使哈希字段值&lt;strong&gt;递减&lt;/strong&gt;而不是递增。如果该字段不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果发生以下情况之一，则返回错误：</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">增量代表存储在浮点数串 &lt;code&gt;key&lt;/code&gt; 由指定的 &lt;code&gt;increment&lt;/code&gt; 。通过使用负 &lt;code&gt;increment&lt;/code&gt; 值，结果是存储在键上的值减小了（通过明显的加法属性）。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果发生以下情况之一，则返回错误：</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">使存储在号码 &lt;code&gt;field&lt;/code&gt; 中存储在哈希 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;increment&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则创建一个包含哈希的新密钥。如果该 &lt;code&gt;field&lt;/code&gt; 不存在，则在执行操作之前将该值设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">使存储在数字 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;increment&lt;/code&gt; 。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 存储的数字加1。如果密钥不存在，则在执行操作之前将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果键包含错误类型的值或包含不能表示为整数的字符串，则返回错误。此操作仅限于64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">按 &lt;code&gt;increment&lt;/code&gt; 存储在 &lt;code&gt;key&lt;/code&gt; 上的排序集中的 &lt;code&gt;member&lt;/code&gt; 的分数。如果 &lt;code&gt;member&lt;/code&gt; 不存在于排序集中，则将其添加为 &lt;code&gt;increment&lt;/code&gt; 作为其分数（好像其先前分数为 &lt;code&gt;0.0&lt;/code&gt; ）。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则将创建一个以指定 &lt;code&gt;member&lt;/code&gt; 为唯一成员的新排序集。</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">关于槽位传播和警告的信息。</target>
        </trans-unit>
        <trans-unit id="2adcb9298d658f855997a0893baf52120d4879fe" translate="yes" xml:space="preserve">
          <source>Initiates a replication stream from the master.</source>
          <target state="translated">从主站启动复制流。</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">将所有指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的开头。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则在执行推入操作之前将其创建为空列表。当 &lt;code&gt;key&lt;/code&gt; 保留的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">将所有指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的末尾。如果 &lt;code&gt;key&lt;/code&gt; 不存在，则在执行推入操作之前将其创建为空列表。当 &lt;code&gt;key&lt;/code&gt; 保留的值不是列表时，将返回错误。</target>
        </trans-unit>
        <trans-unit id="76405c7e5205b84962c7bcad1e955500c9c01bf2" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;element&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">在参考值 &lt;code&gt;pivot&lt;/code&gt; 之前或之后，将 &lt;code&gt;element&lt;/code&gt; 插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表中。</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅当 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表时，才将 &lt;code&gt;value&lt;/code&gt; 插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的开头。与&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅当 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表时，才将 &lt;code&gt;value&lt;/code&gt; 插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的末尾。与&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 列表中的存储在 &lt;code&gt;key&lt;/code&gt; 之前或参考值后 &lt;code&gt;pivot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5796a562198c08a1669595d2cc6b1a7851ecca7f" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅在 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表的情况下，将指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的开头。与&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 尚不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="ea8b02564feb5003f96c3e70699d8d56ef9971fc" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">仅在 &lt;code&gt;key&lt;/code&gt; 已经存在并保存列表的情况下，将指定的值插入存储在 &lt;code&gt;key&lt;/code&gt; 处的列表的末尾。与&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;相反，当 &lt;code&gt;key&lt;/code&gt; 不存在时将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">相反的Redis 2.4的作品以不同的方式：客户供应&lt;em&gt;的背景下，&lt;/em&gt;推动工作，所以只要 &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 开始推动的第一个元素到列表中，它将被交付给客户&lt;strong&gt;一个&lt;/strong&gt;，将接收 &lt;code&gt;a&lt;/code&gt; （第一个元素）。</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">而不是使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;释放锁定，而是发送一个仅在值匹配时才删除密钥的脚本。</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">不设置一个固定的字符串,而是设置一个不可猜测的大随机字符串,称为token。</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">相反，如果由于 &lt;code&gt;lock.foo&lt;/code&gt; 上的Unix时间早于当前Unix时间而使锁过期，则C4尝试执行：</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">指示Redis启动&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;仅追加文件&lt;/a&gt;重写过程。重写将创建当前&amp;ldquo;仅附加文件&amp;rdquo;的小型优化版本。</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">整数答复</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">EVAL简介</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">它还可以取以下值:</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">它包含一个64位校验和，用于确保将检测到错误。在&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;命令可以确保使用合成序列化价值的关键前检查校验。</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">这是&lt;strong&gt;非常重要的&lt;/strong&gt;要明白，你应该使用 &lt;code&gt;$&lt;/code&gt; ID仅在第一次调用&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;。以后，该ID应该是流中最后报告的项目之一，否则您可能会错过之间添加的所有条目。</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">也可以使用特殊模式 &lt;code&gt;#&lt;/code&gt; 来 &lt;code&gt;GET&lt;/code&gt; 元素本身：</target>
        </trans-unit>
        <trans-unit id="98ad7fac6612120c355f6682c4b1a531c848bd30" translate="yes" xml:space="preserve">
          <source>It is also possible to compute the LCS between the content of two keys:</source>
          <target state="translated">也可以计算两个键的内容之间的LCS。</target>
        </trans-unit>
        <trans-unit id="b33a1c4c42a6d6feaa0bef4f81f6ace9278b22e9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; and &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; string commands to efficiently access a range of bit offsets in a bitmap. Below is a sample implementation in idiomatic Redis Lua scripting that can be run with the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command:</source>
          <target state="translated">也可以使用&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;和&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;字符串命令来有效地访问位图中的一定范围的位偏移。以下是可以使用&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;命令运行的惯用Redis Lua脚本中的示例实现：</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">需要注意的是,步骤3是唯一一次Redis集群节点会在没有得到其他节点同意的情况下创建新的配置epoch。只有在操作手动配置时才会发生这种情况。然而这是不可能的,这会造成两个节点拥有相同配置 epoch 的非临时性设置,因为 Redis Cluster 使用配置 epoch 碰撞解决算法。</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">重要的是要注意，&lt;strong&gt;MATCH&lt;/strong&gt;过滤器是在从集合中检索元素之后，即在将数据返回给客户端之前应用的。这意味着，如果模式与集合中的元素很少匹配，则&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;在大多数迭代中可能不返回任何元素。一个例子如下所示：</target>
        </trans-unit>
        <trans-unit id="05004148ae7826284b52ac4960264eb06c78f9cd" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;TYPE&lt;/strong&gt; filter is also applied after elements are retrieved from the database, so the option does not reduce the amount of work the server has to do to complete a full iteration, and for rare types you may receive no elements in many iterations.</source>
          <target state="translated">重要的是要注意，在从数据库中检索元素之后也将应用&lt;strong&gt;TYPE&lt;/strong&gt;过滤器，因此该选项不会减少服务器完成完整迭代所需的工作量，对于稀有类型，您可能不会收到任何元素在许多次迭代中。</target>
        </trans-unit>
        <trans-unit id="6a489978b872ba9db6fad974b8d4112fa3f8ddea" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">重要的是要理解，此命令将&lt;em&gt;扇出&lt;/em&gt;所有正在等待相同范围ID的客户端，因此每个使用者都将获得数据的副本，这与使用阻止列表弹出操作时发生的情况不同。</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">重要的是要理解，此命令将&lt;em&gt;扇出&lt;/em&gt;所有正在等待相同范围ID的客户端，因此每个使用者都将获得数据的副本，这与使用阻止列表弹出操作时发生的情况不同。</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">它永远不会重复，因此，如果&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;返回相同的数字，则调用者可以确保基础客户端没有断开连接并重新连接，但是仍然是相同的连接。</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">在超时的情况下，密钥不可能丢失，但是在发生超时错误的情况下，调用&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;的客户端应检查该密钥是否&lt;em&gt;也&lt;/em&gt;存在于目标实例中并采取相应的措施。</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">由于迭代器的完整状态在游标中,每次调用时都会获得并返回给客户端,所以可以让无限多的客户端同时迭代同一个集合。服务器端完全不获取状态。</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">可以使用已具有现有到期集的密钥作为参数来调用&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;。在这种情况下，密钥的生存时间将&lt;em&gt;更新&lt;/em&gt;为新值。有许多有用的应用程序，下面的&amp;ldquo; &lt;em&gt;导航会话&lt;/em&gt;模式&amp;rdquo;部分记录了一个示例。</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">可以像普通客户端一样在Lua脚本中调用&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;，但是，行为的一个微妙方面在Redis 2.8.11和Redis 2.8.12之间发生了变化。在2.8.12版本之前，由Lua脚本选择的数据库已作为当前数据库&lt;em&gt;转移&lt;/em&gt;到调用脚本。从Redis 2.8.12开始，Lua脚本选择的数据库仅影响脚本本身的执行，而不会修改客户端调用脚本选择的数据库。</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">可以使用两个不同的 Lua 函数从 Lua 脚本中调用 Redis 命令。</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">可以完全删除连接名,将其设置为空字符串,这不是一个有效的连接名,因为它的作用是这个特定的目的。</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">使用命令&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;可以仅获取慢速日志的长度。</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">为了提高工作效率,可以用以下特殊形式下达命令。</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">使用&lt;strong&gt;MAXLEN&lt;/strong&gt;选项可以将流的大小限制为最大元素数。</target>
        </trans-unit>
        <trans-unit id="712b25407c86c3da9193a8517aa1f28826626087" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option. By default, or when used with the &lt;code&gt;=&lt;/code&gt; argument, the &lt;strong&gt;MAXLEN&lt;/strong&gt; option performs an exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">使用&lt;strong&gt;MAXLEN&lt;/strong&gt;选项可以将流的大小限制为最大元素数。默认情况下，或与 &lt;code&gt;=&lt;/code&gt; 参数一起使用时，&lt;strong&gt;MAXLEN&lt;/strong&gt;选项将执行精确的修整。这意味着修剪后的流的长度将恰好是其原始长度和指定的最大长度之间的最小值。</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">可以对解锁模式进行如下修改,使本系统更加健壮。</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;redis.conf&lt;/code&gt; 或使用CONFIG GET / CONFIG SET命令来修改可以执行毫秒级精度的脚本的最长时间。影响最大执行时间的配置参数称为 &lt;code&gt;lua-time-limit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">可以仅迭代与给定的glob样式的模式匹配的元素，类似于将模式作为唯一参数的&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;命令的行为。</target>
        </trans-unit>
        <trans-unit id="1b6a2609bc05ff6f008c837f6095456b47106ecb" translate="yes" xml:space="preserve">
          <source>It is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">可以向命令传递一个附加参数,以便查看有特定所有者的消息。</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">可以传递 &lt;code&gt;WITHSCORES&lt;/code&gt; 选项，以便将元素的分数与元素一起返回。返回的列表将包含 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 而不是 &lt;code&gt;value1,...,valueN&lt;/code&gt; 。客户端库可以自由返回更合适的数据类型（建议：具有（值，得分）数组/元组的数组）。</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">可以同时提供多个过滤器。该命令将通过逻辑AND处理多个过滤器。例如:</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">只需在命令末尾指定多个参数，就可以使用单个命令调用来推送多个元素。元素从最左边的元素到最右边的元素一个接一个地插入列表的开头。因此，例如命令 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; 将导致一个包含 &lt;code&gt;c&lt;/code&gt; 作为第一元素， &lt;code&gt;b&lt;/code&gt; 作为第二元素和 &lt;code&gt;a&lt;/code&gt; 作为第三元素的列表。</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">只需在命令末尾指定多个参数，就可以使用单个命令调用来推送多个元素。从最左边的元素到最右边的元素，元素一个接一个地插入到列表的末尾。因此，例如命令 &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 将导致一个列表，其中包含 &lt;code&gt;a&lt;/code&gt; 作为第一元素， &lt;code&gt;b&lt;/code&gt; 作为第二元素， &lt;code&gt;c&lt;/code&gt; 作为第三元素。</target>
        </trans-unit>
        <trans-unit id="6156ba53b9a2d5fcb6563a933eb7f9a8915352ac" translate="yes" xml:space="preserve">
          <source>It is possible to reset only specific events by providing the &lt;code&gt;event&lt;/code&gt; names as arguments.</source>
          <target state="translated">通过提供 &lt;code&gt;event&lt;/code&gt; 名称作为参数，可以仅重置特定事件。</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">可以在MULTI / EXEC块中与CLI &lt;code&gt;INFO replication&lt;/code&gt; 命令一起发送&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;，以便在阻止客户端时获得当前的主偏移。这样，可以在副本端等待特定的偏移量，以确保已处理所有复制流。</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">可以指定一个可选的修饰符来改变命令的行为。具体来说就是:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;命令将持久性从RDB快照切换到仅附加文件（以及其他方式）。有关如何执行此操作的更多信息，请检查&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;持久性页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">使用&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;命令可以终止仅执行只读命令的脚本。这不会违反脚本语义，因为脚本尚未将任何数据写入数据集中。</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">可以在每个页面视图中同时使用&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;和&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;，以使计数器仅对最近的N个页面视图进行计数，这些间隔小于指定的秒数。</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">可以通过以下语法对哈希字段使用 &lt;code&gt;BY&lt;/code&gt; 和 &lt;code&gt;GET&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">可以在诸如 &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; 之类的 &lt;code&gt;geohash.org&lt;/code&gt; URL中使用它们。这是&lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;此类URL&lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;redis.log&lt;/code&gt; 函数可以从Lua脚本写入Redis日志文件。</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">这是阻塞版本,因为当没有成员从任何给定的排序集中弹出时,它就会阻塞连接。分数最高的成员从第一个非空的排序集合中弹出,并按照给定的键的顺序进行检查。</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">这是阻塞版本,因为当没有成员从任何给定的排序集中弹出时,它就会阻塞连接。分数最低的成员从第一个非空的排序集合中弹出,并按照给定的键的顺序进行检查。</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">它只是假设地球是一个球体,因为所用的距离公式是哈弗辛公式。这个公式应用于地球时只是一个近似值,因为地球不是一个完美的球体。当用于需要通过半径查询的社交网站和大多数其他应用时,引入的错误不是问题。然而在最坏的情况下,误差可能高达0.5%,所以你可能要考虑其他系统来处理误差关键的应用。</target>
        </trans-unit>
        <trans-unit id="78cca099dcd0e67e0e370e606d28021ee24c5299" translate="yes" xml:space="preserve">
          <source>It should display some computer art. There are no limits as long as the output works well in a normal terminal display. However the output should not be limited to graphics (like LOLWUT 5 and 6 actually do), but can be generative poetry and other non graphical things.</source>
          <target state="translated">它应该显示一些电脑艺术。没有限制,只要在正常的终端显示中输出效果好就可以了。不过输出的内容不应该局限于图形(就像LOLWUT 5和6实际做的那样),可以是生成性的诗歌和其他非图形的东西。</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">它开始再次从其他客户端接受命令，但是将向所有发送常规命令的客户端返回&amp;ldquo;忙&amp;rdquo;错误。在此状态下，仅允许使用的命令是&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;和 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">它停止处理来自普通和pub/sub客户端的所有待处理命令。但与副本的交互将继续正常进行。</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">它还支持其他几个功能： &lt;code&gt;bit.tobit&lt;/code&gt; ， &lt;code&gt;bit.tohex&lt;/code&gt; ， &lt;code&gt;bit.bnot&lt;/code&gt; ， &lt;code&gt;bit.band&lt;/code&gt; ， &lt;code&gt;bit.bor&lt;/code&gt; ， &lt;code&gt;bit.bxor&lt;/code&gt; ， &lt;code&gt;bit.lshift&lt;/code&gt; ， &lt;code&gt;bit.rshift&lt;/code&gt; ， &lt;code&gt;bit.arshift&lt;/code&gt; ， &lt;code&gt;bit.rol&lt;/code&gt; ， &lt;code&gt;bit.ror&lt;/code&gt; ， &lt;code&gt;bit.bswap&lt;/code&gt; 。&lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp文档&lt;/a&gt;中记录了所有可用功能</target>
        </trans-unit>
        <trans-unit id="49c10040c2d176504fa4270533a1f6d22770dff5" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;https://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">它还支持其他几个功能： &lt;code&gt;bit.tobit&lt;/code&gt; ， &lt;code&gt;bit.tohex&lt;/code&gt; ， &lt;code&gt;bit.bnot&lt;/code&gt; ， &lt;code&gt;bit.band&lt;/code&gt; ， &lt;code&gt;bit.bor&lt;/code&gt; ， &lt;code&gt;bit.bxor&lt;/code&gt; ， &lt;code&gt;bit.lshift&lt;/code&gt; ， &lt;code&gt;bit.rshift&lt;/code&gt; ， &lt;code&gt;bit.arshift&lt;/code&gt; ， &lt;code&gt;bit.rol&lt;/code&gt; ， &lt;code&gt;bit.ror&lt;/code&gt; ， &lt;code&gt;bit.bswap&lt;/code&gt; 。&lt;a href=&quot;https://bitop.luajit.org/api.html&quot;&gt;Lua BitOp文档&lt;/a&gt;中记录了所有可用功能</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">递增地迭代流，每次迭代仅返回一些项。但是，从语义上讲，它比&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;系列功能强大得多。</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">迭代流</target>
        </trans-unit>
        <trans-unit id="51c1f7544778c11ca5b79e2c5f951971fc09700a" translate="yes" xml:space="preserve">
          <source>Iterating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">递增地迭代流，每次迭代仅返回一些项。但是，从语义上讲，它比&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;系列功能更强大。</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">使用XREVRANGE进行迭代</target>
        </trans-unit>
        <trans-unit id="ac745b350ec3c8d6357a81e49fd4c8b3f51fac37" translate="yes" xml:space="preserve">
          <source>Iterating with earlier versions of Redis</source>
          <target state="translated">迭代早期版本的Redis</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">Hash值的迭代。</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">KEYS 模式 查找与给定模式相匹配的所有键。</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">关键的步数，使我们找到类似的命令关键岗位&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;了格式是 &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">按照给定的顺序检查密钥。假设键 &lt;code&gt;list1&lt;/code&gt; 不存在，而 &lt;code&gt;list2&lt;/code&gt; 和 &lt;code&gt;list3&lt;/code&gt; 保存非空列表。考虑以下命令：</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">密钥到期信息以绝对的Unix时间戳(在Redis 2.6或更高版本的情况下以毫秒为单位)存储。这意味着即使在Redis实例不活动时,时间也在流动。</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">不存在的键被认为是空集。</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">不存在的键被认为是空集。当其中一个键是空集时,所得到的集也是空的(因为集与空集相交的结果总是空集)。</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">钥匙的过期时间</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">关键空间点击率</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">关键空间失误</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">杀死当前正在执行的Lua脚本,假设该脚本还没有进行写操作。</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">已知的局限性。</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 获取最后一次成功保存到磁盘的UNIX时间戳。</target>
        </trans-unit>
        <trans-unit id="49d6c10ecea9234f6d1697a89998efd2571a5a9d" translate="yes" xml:space="preserve">
          <source>LATENCY</source>
          <target state="translated">LATENCY</target>
        </trans-unit>
        <trans-unit id="0501d335a5299cb1743cbb10c7b8477444d0a1c2" translate="yes" xml:space="preserve">
          <source>LATENCY DOCTOR   Return a human readable latency analysis report.</source>
          <target state="translated">LATENCY DOCTOR 返回一个人类可读的延迟分析报告。</target>
        </trans-unit>
        <trans-unit id="186301f764b22cd2877e1aabbbb1538d6d5f7100" translate="yes" xml:space="preserve">
          <source>LATENCY GRAPH  event   Return a latency graph for the event.</source>
          <target state="translated">LATENCY GRAPH 事件 返回事件的延迟图。</target>
        </trans-unit>
        <trans-unit id="4bd2b2b9b61f8de610b1da572e4c2d464408238b" translate="yes" xml:space="preserve">
          <source>LATENCY HELP   Show helpful text about the different subcommands.</source>
          <target state="translated">LATENCY HELP 显示关于不同子命令的有用文本。</target>
        </trans-unit>
        <trans-unit id="d4448a36c961ebd2847369404270a681d688d37d" translate="yes" xml:space="preserve">
          <source>LATENCY HISTORY  event   Return timestamp-latency samples for the event.</source>
          <target state="translated">LATENCY HISTORY 事件 返回事件的时间戳-延迟样本。</target>
        </trans-unit>
        <trans-unit id="40376256cb5363f7be31b5131fdde6f208ad798b" translate="yes" xml:space="preserve">
          <source>LATENCY LATEST   Return the latest latency samples for all events.</source>
          <target state="translated">LATENCY LATEST 返回所有事件的最新延迟样本。</target>
        </trans-unit>
        <trans-unit id="a46ae60e5ee406730f6e4d649edcf9436c10620d" translate="yes" xml:space="preserve">
          <source>LATENCY RESET  [event [event ...]]   Reset latency data for one or more events.</source>
          <target state="translated">LATENCY RESET [event [event ...]]重置一个或多个事件的延迟数据。重置一个或多个事件的延迟数据。</target>
        </trans-unit>
        <trans-unit id="c6fdb30d112715d0c3b5d8a01834e5fa3472abec" translate="yes" xml:space="preserve">
          <source>LCS algorithm</source>
          <target state="translated">LCS算法</target>
        </trans-unit>
        <trans-unit id="89288dff0eca7e3500efaf0b7acd0c70cae1edc4" translate="yes" xml:space="preserve">
          <source>LCS is very useful in order to evaluate how similar two strings are. Strings can represent many things. For instance if two strings are DNA sequences, the LCS will provide a measure of similarity between the two DNA sequences. If the strings represent some text edited by some user, the LCS could represent how different the new text is compared to the old one, and so forth.</source>
          <target state="translated">为了评估两个字符串的相似度,LCS非常有用。字符串可以代表很多东西。例如,如果两个字符串是DNA序列,LCS将提供两个DNA序列之间相似度的测量。如果字符串代表一些用户编辑过的文本,LCS可以代表新文本与旧文本相比有多大的不同,等等。</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">可以通过以下两种模式之一启用LDB：异步或同步。在异步模式下，服务器创建一个不会阻塞的分支调试会话，并且在会话结束后会&lt;strong&gt;回滚&lt;/strong&gt;所有对数据的更改，因此可以使用相同的初始状态重新启动调试。当调试会话处于活动状态时，备用同步调试模式将阻止服务器，并在数据集结束后保留​​对数据集的所有更改。</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX键索引 从列表中获取一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="b2f2247f94ae9fe4fba40fd22b1b94acb748b154" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot element   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT键 BEFORE|AFTER 枢轴元素 在列表中的另一个元素之前或之后插入一个元素。</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT键 BEFORE|AFTER枢轴值 在列表中的另一个元素之前或之后插入一个元素。</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN键 获取列表的长度</target>
        </trans-unit>
        <trans-unit id="cb98d0989512bc7d03fd0083653a3d72b76da663" translate="yes" xml:space="preserve">
          <source>LMOVE</source>
          <target state="translated">LMOVE</target>
        </trans-unit>
        <trans-unit id="78baeb2f5149c1548b47f47678b64129f94c3043" translate="yes" xml:space="preserve">
          <source>LMOVE  source destination LEFT|RIGHT LEFT|RIGHT   Pop an element from a list, push it to another list and return it</source>
          <target state="translated">LMOVE source destination LEFT|RIGHT LEFT|RIGHT 从一个列表中弹出一个元素,把它推到另一个列表中,然后返回它。</target>
        </trans-unit>
        <trans-unit id="9cd49a9c6357f14037353e324dbbd426c30c77ff" translate="yes" xml:space="preserve">
          <source>LOLWUT</source>
          <target state="translated">LOLWUT</target>
        </trans-unit>
        <trans-unit id="91989e8620d79bb9a73795ebf9495785796e20eb" translate="yes" xml:space="preserve">
          <source>LOLWUT  [VERSION version]   Display some computer art and the Redis version</source>
          <target state="translated">LOLWUT[版本]显示一些电脑艺术和Redis版本。</target>
        </trans-unit>
        <trans-unit id="b8e5b9325998311e1bd0cdebf30f7c4698bea549" translate="yes" xml:space="preserve">
          <source>LOLWUT implementations should be safe and carefully checked for security, and resist to untrusted inputs if they take arguments.</source>
          <target state="translated">LOLWUT的实现应该是安全的,并仔细检查安全性,如果采取参数,则要抵制不受信任的输入。</target>
        </trans-unit>
        <trans-unit id="8b789d56cc69b68e8cc9454d61b8f6bcb54c00bd" translate="yes" xml:space="preserve">
          <source>LOLWUT must always display the Redis version at the end.</source>
          <target state="translated">LOLWUT必须始终在最后显示Redis版本。</target>
        </trans-unit>
        <trans-unit id="b7fd4a8e75c582938a820d5ac113cfb69399cf55" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be completely useless. Displaying some useful Redis internal metrics does not count as a valid LOLWUT.</source>
          <target state="translated">LOLWUT的输出应该是完全无用的。显示一些有用的Redis内部指标并不能算作有效的LOLWUT。</target>
        </trans-unit>
        <trans-unit id="b93af8b70d5c9191d5ace878da62d412c38ce8b2" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be fast to generate so that the command can be called in production instances without issues. It should remain fast even when the user experiments with odd parameters.</source>
          <target state="translated">LOLWUT的输出应该快速生成,以便在生产实例中调用该命令时不会出现问题。即使当用户使用奇数参数进行实验时,它也应该保持快速。</target>
        </trans-unit>
        <trans-unit id="0f982fb7857c5b2bb4e69ef661e4d5d07a8ccdf1" translate="yes" xml:space="preserve">
          <source>LOLWUT wants to be a reminder that there is more in programming than just putting some code together in order to create something useful. Every LOLWUT version should have the following properties:</source>
          <target state="translated">LOLWUT希望提醒大家,在编程中,有更多的东西,而不仅仅是为了创造一些有用的东西而把一些代码放在一起。每一个LOLWUT版本都应该具有以下属性。</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP键 删除并获取列表中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="75ee742440d0263541b4bf6b56f59ba72ebbd18e" translate="yes" xml:space="preserve">
          <source>LPOP  key [count]   Remove and get the first elements in a list</source>
          <target state="translated">LPOP key [count]删除并获取列表中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="8692b4b41c5b80f3fc1b6efeb4604f7278100aec" translate="yes" xml:space="preserve">
          <source>LPOS</source>
          <target state="translated">LPOS</target>
        </trans-unit>
        <trans-unit id="2f8be8617cbb634559fc59c4d3862bfd42f75d83" translate="yes" xml:space="preserve">
          <source>LPOS  key element [RANK rank] [COUNT num-matches] [MAXLEN len]   Return the index of matching elements on a list</source>
          <target state="translated">LPOS 关键元素 [RANK rank][COUNT num-matches][MAXLEN len]返回列表中匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="5005b933581b136ea08ec907be2cf03efef61621" translate="yes" xml:space="preserve">
          <source>LPUSH  key element [element ...]   Prepend one or multiple elements to a list</source>
          <target state="translated">LPUSH键元素[元素...]将一个或多个元素加入到列表中。</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH 键值 [value ...]将一个或多个值预置到列表中。</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="ed89f101b9e76dd34f817063ee39924d1d879b9e" translate="yes" xml:space="preserve">
          <source>LPUSHX  key element [element ...]   Prepend an element to a list, only if the list exists</source>
          <target state="translated">LPUSHX 关键元素 [元素...]只有在列表存在的情况下,才会将元素预置到列表中。</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX键值 只有在列表存在的情况下,才会将一个值预置到列表中。</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE key start stop 从列表中获取元素的范围。</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="254b612ba99c38d18c49c669440c641123e2f3a7" translate="yes" xml:space="preserve">
          <source>LREM  key count element   Remove elements from a list</source>
          <target state="translated">LREM键数元素 从列表中删除元素。</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM键数值 从列表中删除元素。</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="67b8e37be9910fff9bc7142f035eae99cc3cc4f5" translate="yes" xml:space="preserve">
          <source>LSET  key index element   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index element 通过元素的索引来设置列表中元素的值。</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index value 通过元素的索引来设置列表中元素的值。</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM键开始停止 将列表修剪到指定范围。</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">Argument List中的最后一个键</target>
        </trans-unit>
        <trans-unit id="65fe7d4d518c0668f04d8585ccfbc20334e6fd38" translate="yes" xml:space="preserve">
          <source>Lastly, there are three important rules to note:</source>
          <target state="translated">最后,有三个重要的规则需要注意。</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">以后，仅通过对位图调用&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;命令就可以知道用户访问网站的单日数。</target>
        </trans-unit>
        <trans-unit id="78d7ed93f503a940a73a89268b71f5daa31c6b65" translate="yes" xml:space="preserve">
          <source>Latest event latency in millisecond.</source>
          <target state="translated">最新事件延迟,单位为毫秒。</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">最新分叉(2)时间</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">假设我们有A、B、C、D四个节点,为了结束只有A、B、C三个节点的集群,我们可以按照以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">根据知识共享署名-相同方式共享许可协议4.0许可。</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">像&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;一样，此命令返回设置了过期设置的键的剩余生存时间，唯一的区别是&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;以秒为单位返回剩余时间，而&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;以毫秒为单位返回。</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">像&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;一样，可以使用此命令来迭代整个流内容，但是请注意，在这种情况下，下一个命令调用应使用最后一个条目的ID，序列号减1。但是，如果序列号已经为0，则应将ID的时间部分减1，并将序列部分设置为最大可能的序列号，即18446744073709551615，或者可以完全省略，该命令会自动假定它是这样的数字（有关不完整ID的更多信息，请参见&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">像&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;一样，&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;命令可以以阻塞方式使用。在这方面没有区别。</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">像&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;命令一样，开始和结束可以包含负值，以便从字符串的末尾开始索引字节，其中-1是最后一个字节，-2是倒数第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">行可以包含节名（以＃字符开头）或属性。所有属性均以 &lt;code&gt;field:value&lt;/code&gt; 形式，以 &lt;code&gt;\r\n&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="39de9fe457bd2e361245f87b008646c82403b58e" translate="yes" xml:space="preserve">
          <source>List of rules</source>
          <target state="translated">规则清单</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">列表可以编码为 &lt;code&gt;ziplist&lt;/code&gt; 或 &lt;code&gt;linkedlist&lt;/code&gt; 。该 &lt;code&gt;ziplist&lt;/code&gt; 是用来节省空间的小型列出特定表示。</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">列出当前&lt;em&gt;活动的频道&lt;/em&gt;。活动频道是具有一个或多个订阅者（不包括订阅模式的客户端）的发布/订阅频道。</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">将脚本加载到脚本缓存中，而不执行它。将指定的命令加载到脚本缓存后，将可以使用&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;并使用脚本的正确SHA1摘要来调用它，就像在第一次成功调用&lt;a href=&quot;eval&quot;&gt;EVAL之后一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="735c2e48480d01f1dceaeb55af3cf36dcdd6249a" translate="yes" xml:space="preserve">
          <source>Loads a module from a dynamic library at runtime.</source>
          <target state="translated">在运行时从动态库中加载一个模块。</target>
        </trans-unit>
        <trans-unit id="694b70e7b053ef29ce888020d6a15ef0d17437e5" translate="yes" xml:space="preserve">
          <source>Lua boolean -&amp;gt; Redis boolean true or false. &lt;strong&gt;Note that this is a change compared to the RESP2 mode&lt;/strong&gt;, where returning true from Lua returned the number 1 to the Redis client, and returning false used to return NULL.</source>
          <target state="translated">Lua boolean-&amp;gt; Redis布尔值true或false。&lt;strong&gt;请注意，与RESP2模式相比，这是一个更改，在RESP2模式下&lt;/strong&gt;，从Lua返回true&lt;strong&gt;会将&lt;/strong&gt;数字1返回给Redis客户端，而返回false则用于返回NULL。</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false-&amp;gt; Redis Nil批量回复。</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua布尔值true-&amp;gt; Redis整数回复，值为1。</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua不导出访问系统时间或其他外部状态的命令。</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Lua具有单个数字类型，即Lua数字。整数和浮点数之间没有区别。因此，我们总是将Lua数字转换为整数答复，如果有的话，删除数字的小数部分。&lt;strong&gt;如果要从Lua返回浮点数，则应将其作为字符串返回&lt;/strong&gt;，就像Redis本身一样（请参见例如&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;命令）。</target>
        </trans-unit>
        <trans-unit id="8a5d229484ee19b076e60e7fc0d0b8345579dcc1" translate="yes" xml:space="preserve">
          <source>Lua null -&amp;gt; Redis RESP3 new null reply (protocol &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt;).</source>
          <target state="translated">Lua null-&amp;gt; Redis RESP3新的null答复（协议 &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Lua数字-&amp;gt; Redis整数回复（数字转换为整数）</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">修改Lua伪随机数生成函数 &lt;code&gt;math.random&lt;/code&gt; 和 &lt;code&gt;math.randomseed&lt;/code&gt; 以便每次执行新脚本时始终具有相同的种子。这意味着，如果不使用 &lt;code&gt;math.randomseed&lt;/code&gt; ,则每次执行脚本时，调用 &lt;code&gt;math.random&lt;/code&gt; 总是会生成相同的数字序列。</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Lua脚本可以返回一个使用一组转换规则从Lua类型转换到Redis协议的值。</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Lua字符串-&amp;gt; Redis批量回复</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Lua表（数组）-&amp;gt; Redis多批量回复（如果有，则被截断为Lua数组中的第一个nil）</target>
        </trans-unit>
        <trans-unit id="011559d094bdd466ae90420b82cf3259960bb378" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;double&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis double reply.</source>
          <target state="translated">将单个 &lt;code&gt;double&lt;/code&gt; 字段设置为字段值Lua表-&amp;gt; Redis双答复的Lua表。</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">带有单个 &lt;code&gt;err&lt;/code&gt; 字段的Lua表-&amp;gt; Redis错误回复</target>
        </trans-unit>
        <trans-unit id="31b3bac91c4fbeb254b85ca62a253ad709c8a47f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;map&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis map reply.</source>
          <target state="translated">将单个 &lt;code&gt;map&lt;/code&gt; 字段设置为字段值Lua表-&amp;gt; Redis地图回复的Lua表。</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">带有单个 &lt;code&gt;ok&lt;/code&gt; 字段的Lua表-&amp;gt; Redis状态回复</target>
        </trans-unit>
        <trans-unit id="c86e8370e8448b07f033d118ba308f34fc561150" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;set&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis set reply, the values are discarded and can be anything.</source>
          <target state="translated">Lua表将单个 &lt;code&gt;set&lt;/code&gt; 字段设置为字段值Lua table-&amp;gt; Redis set回复，这些值将被丢弃，并且可以是任何值。</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">MEMORY DOCTOR 输出内存问题报告。</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 显示有关不同子命令的帮助性文本。</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">MEMORY MALLOC-STATS 显示分配器的内部统计。</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">MEMORY PURGE 要求分配器释放内存。</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">MEMORY STATS 显示内存使用详情</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE key [SAMPLES count]估计一个键的内存使用量。</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET key [key ...]获取所有给定键的值。</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="c26be640f072695430c6befbdaab1be7da9a4af0" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE host port key|&quot;&quot; destination-db timeout [COPY][REPLACE][AUTH password][AUTH2 username password][KEYS key [key ...]]。原子化地将一个key从一个Redis实例转移到另一个实例。</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE host port key|&quot;&quot; destination-db timeout [COPY][REPLACE][KEYS key [key ...]]。原子化地将一个key从一个Redis实例传输到另一个实例。</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="43ac8ce01de13f2da2af292daa0522a8dce0815f" translate="yes" xml:space="preserve">
          <source>MODULE LIST   List all modules loaded by the server</source>
          <target state="translated">MODULE LIST 列出服务器加载的所有模块。</target>
        </trans-unit>
        <trans-unit id="ead5dec077ff0d8c33078bffc3edb3a161d0c8b1" translate="yes" xml:space="preserve">
          <source>MODULE LOAD  path [ arg [arg ...]]   Load a module</source>
          <target state="translated">MODULE LOAD path[arg [arg ...]]。加载一个模块</target>
        </trans-unit>
        <trans-unit id="c8d0e227668f65977f974daf28058d755a01a58f" translate="yes" xml:space="preserve">
          <source>MODULE UNLOAD  name   Unload a module</source>
          <target state="translated">MODULE UNLOAD 名称 卸载一个模块</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR 实时监听服务器收到的所有请求。</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db 将一个键移动到另一个数据库。</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET键值 [键值...]将多个键设置为多个值。</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX键值[键值......]将多个键设置为多个值,只有在所有键都不存在的情况下才会设置。</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI 标记一个交易块的开始。</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">手动发出&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;命令以停止通过 &lt;code&gt;telnet&lt;/code&gt; 运行的&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;流。</target>
        </trans-unit>
        <trans-unit id="1ab2b333d1a4eb7dc9f5b2c393ae0acfe6aa0aa8" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; commands to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">手动发出&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;命令以停止通过 &lt;code&gt;telnet&lt;/code&gt; 运行的&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;流。</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">标记给定的键，以观察是否有条件执行&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">标记&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;事务&lt;/a&gt;块的开始。随后的命令将使用&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;排队等待原子执行。</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">以嵌套的IP/端口数组表示的槽位范围的主控。</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">主输出</target>
        </trans-unit>
        <trans-unit id="221cc49f520f042d2c8db1934cf7365d8019893a" translate="yes" xml:space="preserve">
          <source>Matches are produced from the last one to the first one, since this is how the algorithm works, and it more efficient to emit things in the same order. The above array means that the first match (second element of the array) is between positions 2-3 of the first string and 0-1 of the second. Then there is another match between 4-7 and 5-8.</source>
          <target state="translated">匹配是由最后一个到第一个产生的,因为这就是算法的工作方式,而且以同样的顺序发出东西会更有效率。上面的数组意味着第一个匹配(数组的第二个元素)是在第一个字符串的2-3位和第二个字符串的0-1位之间。然后在4-7和5-8之间还有一个匹配。</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">旗帜的含义(字段号3);</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">将多个HyperLog值合并成一个唯一的值,该值将近似于源HyperLog结构的观察Sets的联合的cardinality。</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">用一个命令调用迁移多个键</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">迁移和导入插槽仅添加到标记为 &lt;code&gt;myself&lt;/code&gt; 的节点上。该信息对于节点来说是其自身的插槽所在的节点。</target>
        </trans-unit>
        <trans-unit id="b39875ef4297a449c400e22ef1b7f5a9df1b0b1a" translate="yes" xml:space="preserve">
          <source>Modules that register custom data types can not be unloaded.</source>
          <target state="translated">注册自定义数据类型的模块不能被卸载。</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">可以在&lt;a href=&quot;http://antirez.com/news/75&quot;&gt;此博客文章中&lt;/a&gt;找到有关Redis HyperLogLog实现的更多详细信息。 &lt;code&gt;hyperloglog.c&lt;/code&gt; 文件中实现的源代码也易于阅读和理解，并且包括用于稀疏和密集表示的确切编码的完整规范。</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">关于Current Epoch和Config Epoch变量的更多信息可在Redis Cluster规范文档中获得。</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">而且，&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;不必是互惠的。如果我将命令发送到A以便加入B，则也不需要将命令发送到B以便加入A。</target>
        </trans-unit>
        <trans-unit id="9e46ae1b67b3a95c0efb340b998c24643ca486fb" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message unless the &lt;code&gt;JUSTID&lt;/code&gt; option has been specified (which only delivers the message ID, not the message itself). In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">此外，作为副作用，除非指定了 &lt;code&gt;JUSTID&lt;/code&gt; 选项（仅传递消息ID，而不传递消息本身），否则&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;将增加尝试传递消息的次数。这样，由于某种原因而无法处理的消息（例如，由于使用者崩溃而试图对其进行处理）将开始具有更大的计数器，并且可以在系统内部被检测到。</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">此外，作为副作用，&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;将增加尝试传递邮件的次数。这样，由于某种原因而无法处理的消息（例如由于使用者崩溃而试图对其进行处理）将开始具有更大的计数器，并且可以在系统内部被检测到。</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">此外，如果您不熟悉流，我们建议阅读&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams简介&lt;/a&gt;。确保了解介绍中的使用者组的概念，以便遵循此命令的工作方式将更加简单。</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">活动钥匙</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">将 &lt;code&gt;key&lt;/code&gt; 从当前选定的数据库（请参见&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;）移动到指定的目标数据库。如果目标数据库中已经存在 &lt;code&gt;key&lt;/code&gt; ，或者源数据库中不存在密钥，则它什么都不做。因此，可以将&lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt;用作锁定原语。</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">将 &lt;code&gt;member&lt;/code&gt; 从 &lt;code&gt;source&lt;/code&gt; 集合移到 &lt;code&gt;destination&lt;/code&gt; 集合。此操作是原子的。在每个给定的时刻，该元素将似乎是其他客户端的 &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;或&lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; 的成员。</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">多次并行迭代</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">嵌套结果阵列</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">为了调试的目的,会定期增加新的字段。一些字段可能会在将来被删除。使用此命令的版本安全的Redis客户端应该对输出进行相应的解析(即处理优雅的缺失字段,跳过未知字段)。</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">新键总是在目标节点中创建。在哈希槽迁移过程中,我们只需要移动旧键,而不是新键。</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">不返回重复的元素。</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">心跳数据包的八卦部分中提供了处于 &lt;code&gt;PFAIL&lt;/code&gt; 状态的节点。</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">不存在的元素被报告为数组的NULL元素。</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">未使用的行被空白。例如，如果您曾经有多个 &lt;code&gt;save&lt;/code&gt; 指令，但是当您禁用RDB持久性时当前配置很少或没有，则所有行都将被清空。</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">非阻塞行为</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">非阻塞式使用</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">不存在的键将被视为空字符串,所以命令将返回零。</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">不存在的键将作为空字符串处理。</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">通常，&lt;a href=&quot;zrangebyscore&quot;&gt;仅&lt;/a&gt;简单地使用ZRANGEBYSCORE来获得分数为索引整数键的项的范围，但是可以使用该命令执行不太明显的事情。</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">通常，Redis密钥的创建没有关联的生存时间。除非用户以明确的方式（例如，使用&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;命令）将其删除，否则密钥将永远存在。</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">通常，Redis使用Geohash技术的变体表示元素的位置，其中使用52位整数对位置进行编码。与标准相比，编码也有所不同，因为在编码和解码过程中使用的初始最小和最大坐标是不同的。但是，此命令以&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia文章中所述&lt;/a&gt;且与&lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt;网站兼容的字符串形式&lt;strong&gt;返回标准Geohash&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">通常,与给定节点相关联的哈希槽采用以下格式之一,上文已经解释过。</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">通常，如果有一个AOF子进程执行AOF重写，则Redis会简单地杀死它并退出。但是，在两种情况下这样做是不安全的，并且将拒绝&lt;strong&gt;SHUTDOWN&lt;/strong&gt;命令并显示错误。这种情况发生在以下情况：</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">通常，副本节点会将客户端重定向到给定命令所涉及的哈希槽的权威主机，但是客户端可以使用副本以使用&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;命令扩展读取。</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">通常，复制脚本而不是脚本效果是有意义的，但是并非在所有情况下都可以。因此，从Redis 3.2开始，脚本引擎可以复制脚本执行所产生的写入命令序列，而不必复制脚本本身。有关更多信息，请参见下一部分。在本节中，我们假设通过发送整个脚本来复制脚本。我们将此复制模式称为&lt;strong&gt;整个脚本复制&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="632bc7f3cbfc39c1e051fc94bc2f5127d08b095a" translate="yes" xml:space="preserve">
          <source>Normally the OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</source>
          <target state="translated">一般情况下,会立即返回OK代码。Redis分叉,父代继续为客户端服务,子代将DB保存在磁盘上然后退出。</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">通常情况下,你可能会认为Redis流是一个仅有附加的数据结构,然而Redis流是在内存中表示的,所以我们也可以删除条目。这可能很有用,例如,为了遵守某些隐私政策。</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">通常你使用这样的命令是为了获取新的消息并处理它们。在伪代码中。</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Lua新手注意事项：为了避免在脚本中使用全局变量，只需使用&lt;em&gt;local&lt;/em&gt;关键字声明要使用的每个变量。</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">请注意，&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;，&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;，&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;和&lt;a href=&quot;zscan&quot;&gt;ZSCAN的&lt;/a&gt;工作方式都非常相似，因此本文档涵盖了所有四个命令。但是，明显的区别在于，对于&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;，&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;和&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;，第一个参数是保存Set，Hash或Sorted Set值的键的名称。该&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;命令不需要任何按键名称参数，因为它遍历当前数据库的密钥，所以迭代对象是数据库本身。</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">请注意，&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;不会使Redis成为一个高度一致的存储：虽然同步复制是复制状态机的一部分，但并不是唯一需要的东西。但是，在Sentinel或Redis群集故障转移的情况下，&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;可以提高实际数据的安全性。</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">请注意，从Redis 3.2.10和Redis 4.0.0开始， &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 也可用，以便提供可在副本中使用的只读命令。有关更多信息，请参见&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">请注意，&lt;strong&gt;TAKEOVER违反了&lt;/strong&gt; Redis Cluster &lt;strong&gt;的last-failover-wins原则&lt;/strong&gt;，因为副本生成的配置时期在几种方面违反了正常的配置时期：</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">请注意，Redis群集需要形成一个完整的网格（每个节点彼此连接），但是为了创建群集，不需要发送所有形成完整网格所需的&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;命令。重要的是发送足够的&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;消息，以便每个节点都可以通过&lt;em&gt;一系列已知节点&lt;/em&gt;到达另一个&lt;em&gt;节点&lt;/em&gt;。由于心跳数据包中的八卦信息的交换，将创建丢失的链接。</target>
        </trans-unit>
        <trans-unit id="2d97296cb1d6030b84b67b56dc33de3881c08256" translate="yes" xml:space="preserve">
          <source>Note that a script can switch back and forth from RESP3 and RESP2 by calling the function with the argument '3' or '2'.</source>
          <target state="translated">请注意,脚本可以通过调用参数'3'或'2'的函数在RESP3和RESP2之间来回切换。</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">请注意，即使使用&lt;em&gt;开始&lt;/em&gt;和&lt;em&gt;结束&lt;/em&gt;来指定范围，也总是从零位开始以绝对值返回位位置。</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">请注意，使用非肯定超时调用&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt;或使用过去某个时间&lt;a href=&quot;expireat&quot;&gt;调用EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt;将导致密钥被&lt;a href=&quot;del&quot;&gt;删除&lt;/a&gt;而不是过期（因此，发出的&lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;密钥事件&lt;/a&gt;将是 &lt;code&gt;del&lt;/code&gt; ，而不是 &lt;code&gt;expired&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">请注意，每个 &lt;code&gt;OVERFLOW&lt;/code&gt; 语句仅影响子命令列表中紧随&lt;a href=&quot;incrby&quot;&gt;其后的INCRBY&lt;/a&gt;命令，直到下一个 &lt;code&gt;OVERFLOW&lt;/code&gt; 语句为止。</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">请注意，要正确实施此模式，请避免多个客户端同时重建缓存，这一点很重要。这里需要某种锁定（例如，使用&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">请注意，出于相同的原因，Lua脚本或 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 块可能会将元素推入列表，然后再&lt;strong&gt;删除列表&lt;/strong&gt;。在这种情况下，只要在执行单个命令，事务或脚本之后列表中没有数据，就完全不会为被阻止的客户端提供服务，并且将继续被阻止。</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">请注意，如果在给定的主节点上添加，移动或删除了副本，并且我们要求&lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;到尚未收到配置更新的节点，则它可能会显示过时的信息。但是最终（如果没有网络分区，将在几秒钟内）所有节点都将同意与给定主节点关联的节点集。</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">请注意，如果在给定的主节点上添加，移动或删除了副本，并且我们向尚未收到配置更新的节点请求&lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt;，则它可能会显示过时的信息。但是最终（如果没有网络分区，将在几秒钟内）所有节点都将同意与给定主节点关联的节点集。</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">请注意，如果您有一个从0到100的数字列表，则 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; 将返回11个元素，即，其中包括最右边的项目。这&lt;strong&gt;可能&lt;/strong&gt;与选择的编程语言中与范围相关的函数的行为一致（&lt;strong&gt;也可能&lt;/strong&gt;不一致）（请考虑Ruby的 &lt;code&gt;Range.new&lt;/code&gt; ， &lt;code&gt;Array#slice&lt;/code&gt; 或Python的 &lt;code&gt;range()&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">请注意,在没有通道的情况下调用此命令是有效的。在这种情况下,它将只返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">注意，不存在的键被视为空列表，因此当 &lt;code&gt;key&lt;/code&gt; 不存在时，该命令将始终返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">请注意，通常，愿意获取&amp;ldquo;群集&amp;rdquo;哈希槽和节点地址之间的映射的客户端应改用&amp;ldquo; &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&amp;rdquo;&lt;/a&gt;。提供更多信息的&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;应该用于管理任务，调试和配置检查。 &lt;code&gt;redis-trib&lt;/code&gt; 也使用它来管理集群。</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">需要注意的是,一旦一个节点给自己分配了一组槽位,它将开始在心跳包头中传播这个信息。然而其他节点只有在它们的槽位还没有与另一个节点绑定时,或者是宣传新的哈希槽位的节点的配置周期,大于表中当前列出的节点时,才会接受该信息。</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">请注意，该命令实现了完整的哈希算法，包括对&lt;strong&gt;hash标签&lt;/strong&gt;（这是Redis Cluster密钥哈希算法的特殊属性）的支持，如果在密钥名称内找到了这样的模式，则仅对 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 之间的内容进行哈希强制多个密钥由同一节点处理。</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">请注意，该格式没有任何空格，因此，即使发出此特殊插槽，&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;输出格式也是纯CSV，带有空格作为分隔符。但是，格式的完整解析器应该能够处理它们。</target>
        </trans-unit>
        <trans-unit id="277c523b6a84e71c0289aa21eae881f107096f52" translate="yes" xml:space="preserve">
          <source>Note that the indexes are still reported in the &quot;natural&quot; way, that is, considering the first element starting from the head of the list at index 0, the next element at index 1, and so forth. This basically means that the returned indexes are stable whatever the rank is positive or negative.</source>
          <target state="translated">请注意,索引仍然以 &quot;自然 &quot;的方式报告,即考虑从列表头开始的第一个元素在索引0,下一个元素在索引1,以此类推。这基本上意味着,无论排名是正还是负,返回的索引都是稳定的。</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">请注意，您可以设置的最大偏移为2 &lt;sup&gt;29&lt;/sup&gt; -1（536870911），因为Redis字符串限制为512 MB。如果您需要超出此大小，可以使用多个键。</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">请注意，仅当消息的空闲时间大于我们在调用&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;时指定的最小空闲时间时，才声明该消息。因为作为副作用，&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;还将重置空闲时间（因为这是处理消息的新尝试），所以两个尝试同时声明消息的使用者将永远不会成功：只有一个成功声明消息。这样可以避免我们以琐碎的方式多次处理给定的消息（但是在一般情况下还是可以避免多次处理）。</target>
        </trans-unit>
        <trans-unit id="dbbe3c8e1b4fe3c7e220f023943635e1ebf82c17" translate="yes" xml:space="preserve">
          <source>Note that this algorithm runs in &lt;code&gt;O(N*M)&lt;/code&gt; time, where N is the length of the first string and M is the length of the second string. So either spin a different Redis instance in order to run this algorithm, or make sure to run it against very small strings.</source>
          <target state="translated">请注意，此算法运行时间为 &lt;code&gt;O(N*M)&lt;/code&gt; ，其中N是第一个字符串的长度，M是第二个字符串的长度。因此，要么旋转不同的Redis实例以运行此算法，要么确保针对很小的字符串运行它。</target>
        </trans-unit>
        <trans-unit id="900544e94991ba5defea5df80a0dccc1aa474e00" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">请注意，当您需要保证返回元素的均匀分布时，此命令不适用。有关用于&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;的算法的更多信息，请查找Knuth采样和Floyd采样算法。</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">注意,当你需要保证返回元素的均匀分布时,这个命令并不适合。关于SPOP使用的算法的更多信息,请查找Knuth采样和Floyd采样算法。</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">请注意,这种worker的实现是微不足道的可扩展性和可靠性,因为即使一个消息丢失了,该项目仍然在队列中,并将在下一次迭代时被处理。</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">请注意，我们在这里有比赛，但这不是问题：&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;可能返回false，但是在我们在&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;块中创建密钥之前，密钥可能是由另一个客户端创建的。但是，这种竞赛在极少数情况下只会错过API调用，因此速率限制仍然可以正常进行。</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">需要注意的是,你需要一个最新版本的redis-cli才能读取慢速日志输出,因为它使用了一些以前在redis-cli中没有实现的协议特性(深度嵌套的多批量回复)。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">请注意&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;和&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;的使用，以确保在每次API调用时我们都将递增并设置到期时间。</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">请注意,不执行此规则是为了给用户提供滥用Redis单例配置的机会,代价是编写与Redis Cluster不兼容的脚本。</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">注意：配置为不持久存储在磁盘上的Redis实例（未配置AOF或&amp;ldquo; save&amp;rdquo;指令）不会将RDB文件转储到&lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN上&lt;/a&gt;，因为通常您不希望Redis实例仅用于缓存时，关闭。</target>
        </trans-unit>
        <trans-unit id="4ffe4a3dcb4982dba6203770d54b7b49b3ebdb4a" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注意：由于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令选项可以替换&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;，&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;，&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;，&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;，因此在Redis的未来版本中，这三个命令可能会被弃用并最终被删除。</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注意：由于&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;命令选项可以替换&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;，&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;，&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;，因此在Redis的未来版本中，这三个命令可能会被弃用并最终删除。</target>
        </trans-unit>
        <trans-unit id="81129f6603906deb00ee7e872ec230ada40b4ee1" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;GT&lt;/strong&gt;, &lt;strong&gt;LT&lt;/strong&gt; and &lt;strong&gt;NX&lt;/strong&gt; options are mutually exclusive.</source>
          <target state="translated">注意：&lt;strong&gt;GT&lt;/strong&gt;，&lt;strong&gt;LT&lt;/strong&gt;和&lt;strong&gt;NX&lt;/strong&gt;选项是互斥的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
