<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="bottle">
    <body>
      <group id="bottle">
        <trans-unit id="8e690695380afda6a7af5d9625bf5fdc539104af" translate="yes" xml:space="preserve">
          <source>The built-in default server is based on &lt;a href=&quot;https://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server&quot;&gt;wsgiref WSGIServer&lt;/a&gt;. This non-threading HTTP server is perfectly fine for development and early production, but may become a performance bottleneck when server load increases. There are three ways to eliminate this bottleneck:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13dc82707871570d92261f24fdcc6c59c14e422" translate="yes" xml:space="preserve">
          <source>The child process will have &lt;code&gt;os.environ['BOTTLE_CHILD']&lt;/code&gt; set to &lt;code&gt;True&lt;/code&gt; and start as a normal non-reloading app server. As soon as any of the loaded modules changes, the child process is terminated and re-spawned by the main process. Changes in template files will not trigger a reload. Please use debug mode to deactivate template caching.</source>
          <target state="translated">子进程将 &lt;code&gt;os.environ['BOTTLE_CHILD']&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; ,并作为普通的非重新加载应用程序服务器启动。一旦任何已加载的模块发生更改，子进程就会终止，并由主进程重新生成。模板文件中的更改不会触发重新加载。请使用调试模式停用模板缓存。</target>
        </trans-unit>
        <trans-unit id="802f619a9f7b91df14864ed5bd755baef78b29ad" translate="yes" xml:space="preserve">
          <source>The client IP as a string. Note that this information can be forged by malicious clients.</source>
          <target state="translated">客户端IP为字符串。请注意,此信息可能被恶意客户端伪造。</target>
        </trans-unit>
        <trans-unit id="dd97d050e6b811a3abb7d66eae6d3a4148dcaf5d" translate="yes" xml:space="preserve">
          <source>The client-site JavaScript API is really straight forward, too:</source>
          <target state="translated">客户端网站的JavaScript API也真的很直接。</target>
        </trans-unit>
        <trans-unit id="cb1e500c477033706f033ec7ae9962e2bb183f97" translate="yes" xml:space="preserve">
          <source>The code looks like this:</source>
          <target state="translated">代码是这样的。</target>
        </trans-unit>
        <trans-unit id="5e5c783e934aa6f68ace0c06559e4313c625baef" translate="yes" xml:space="preserve">
          <source>The code needs to be extended to:</source>
          <target state="translated">该代码需要扩展到:</target>
        </trans-unit>
        <trans-unit id="df2897f61e451946671f9cab10cb8d328d5ae146" translate="yes" xml:space="preserve">
          <source>The contained python expression is executed at render-time and has access to all keyword arguments passed to the &lt;a href=&quot;#bottle.SimpleTemplate.render&quot;&gt;&lt;code&gt;SimpleTemplate.render()&lt;/code&gt;&lt;/a&gt; method. HTML special characters are escaped automatically to prevent &lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-Site_Scripting&quot;&gt;XSS&lt;/a&gt; attacks. You can start the expression with an exclamation mark to disable escaping for that expression:</source>
          <target state="translated">包含的python表达式在渲染时执行，并且可以访问传递给&lt;a href=&quot;#bottle.SimpleTemplate.render&quot;&gt; &lt;code&gt;SimpleTemplate.render()&lt;/code&gt; &lt;/a&gt;方法的所有关键字参数。HTML特殊字符会自动转义以防止&lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-Site_Scripting&quot;&gt;XSS&lt;/a&gt;攻击。您可以以感叹号开头的表达式来禁用对该表达式的转义：</target>
        </trans-unit>
        <trans-unit id="9ca352daf934640d1261575460d24fb51d5ad385" translate="yes" xml:space="preserve">
          <source>The contained python expression is executed at render-time and has access to all keyword arguments passed to the &lt;a href=&quot;#bottle.SimpleTemplate.render&quot;&gt;&lt;code&gt;SimpleTemplate.render()&lt;/code&gt;&lt;/a&gt; method. HTML special characters are escaped automatically to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-Site_Scripting&quot;&gt;XSS&lt;/a&gt; attacks. You can start the expression with an exclamation mark to disable escaping for that expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18693f727021608dce9ebbf06d4103a52b6a3af" translate="yes" xml:space="preserve">
          <source>The decorator API is quite limited, though. You don&amp;rsquo;t know anything about the route being decorated or the associated application object and have no way to efficiently store data that is shared among all routes. But fear not! Plugins are not limited to just decorator functions. Bottle accepts anything as a plugin as long as it is callable or implements an extended API. This API is described below and gives you a lot of control over the whole process.</source>
          <target state="translated">装饰器API相当有限。您对正在装饰的路由或关联的应用程序对象一无所知，并且无法有效存储所有路由之间共享的数据。但是不要害怕！插件不仅限于装饰器功能。瓶子可以接受任何形式的插件，只要它是可调用的或实现扩展的API。该API如下所述，可让您对整个过程进行大量控制。</target>
        </trans-unit>
        <trans-unit id="e03e664e2a828d4a86da270d75c5df9250a87310" translate="yes" xml:space="preserve">
          <source>The default error page shows a traceback.</source>
          <target state="translated">默认的错误页面会显示回溯。</target>
        </trans-unit>
        <trans-unit id="127bc5abb10993664fe4c0b79234995ee85401bb" translate="yes" xml:space="preserve">
          <source>The directory which, including its subdirectories, contains all source files for one Sphinx project.</source>
          <target state="translated">该目录包括其子目录,包含一个Sphinx项目的所有源文件。</target>
        </trans-unit>
        <trans-unit id="76efd509a7716fdcb489384b17d954e8467d9b0a" translate="yes" xml:space="preserve">
          <source>The easiest way to increase performance is to install a multi-threaded server library like &lt;a href=&quot;http://pythonpaste.org/&quot;&gt;paste&lt;/a&gt; or &lt;a href=&quot;http://www.cherrypy.org/&quot;&gt;cherrypy&lt;/a&gt; and tell Bottle to use that instead of the single-threaded server:</source>
          <target state="translated">提高性能的最简单方法是安装一个多线程服务器库（例如&lt;a href=&quot;http://pythonpaste.org/&quot;&gt;粘贴&lt;/a&gt;或&lt;a href=&quot;http://www.cherrypy.org/&quot;&gt;cherrypy），&lt;/a&gt;并告诉Bottle使用它而不是单线程服务器：</target>
        </trans-unit>
        <trans-unit id="21cc0531a3dd5492815afa34195f9c604a4199c6" translate="yes" xml:space="preserve">
          <source>The effects and APIs of plugins are manifold and depend on the specific plugin. The &lt;code&gt;SQLitePlugin&lt;/code&gt; plugin for example detects callbacks that require a &lt;code&gt;db&lt;/code&gt; keyword argument and creates a fresh database connection object every time the callback is called. This makes it very convenient to use a database:</source>
          <target state="translated">插件的效果和API多种多样，并取决于特定的插件。例如， &lt;code&gt;SQLitePlugin&lt;/code&gt; 插件检测需要 &lt;code&gt;db&lt;/code&gt; 关键字参数的回调，并在每次调用该回调时创建一个新的数据库连接对象。这使得使用数据库非常方便：</target>
        </trans-unit>
        <trans-unit id="dfe928c77544e064e11f2c89dba7946b07ba0f74" translate="yes" xml:space="preserve">
          <source>The first line is important. It causes gevent to monkey-patch most of Python&amp;rsquo;s blocking APIs to not block the current thread, but pass the CPU to the next greenlet instead. It actually replaces Python&amp;rsquo;s threading with gevent-based pseudo-threads. This is why you can still use &lt;code&gt;time.sleep()&lt;/code&gt; which would normally block the whole thread. If you don&amp;rsquo;t feel comfortable with monkey-patching python built-ins, you can use the corresponding gevent functions (&lt;code&gt;gevent.sleep()&lt;/code&gt; in this case).</source>
          <target state="translated">第一行很重要。它使gevent猴子修补大多数Python的阻塞API，而不是阻塞当前线程，而是将CPU传递给下一个greenlet。它实际上用基于gevent的伪线程代替了Python的线程。这就是为什么您仍然可以使用通常会阻塞整个线程的 &lt;code&gt;time.sleep()&lt;/code&gt; 的原因。如果您对使用猴子修补Python内置函数感到不满意，可以使用相应的gevent函数（在这种情况下为 &lt;code&gt;gevent.sleep()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3ffd9106f941291891b3797a85b7b5b1b45dc65" translate="yes" xml:space="preserve">
          <source>The first route needs a database connection and tells the plugin to create a handle by requesting a &lt;code&gt;db&lt;/code&gt; keyword argument. The second route does not need a database and is therefore ignored by the plugin. The third route does expect a &amp;lsquo;db&amp;rsquo; keyword argument, but explicitly skips the sqlite plugin. This way the argument is not overruled by the plugin and still contains the value of the same-named url argument.</source>
          <target state="translated">第一条路由需要数据库连接，并通过请求 &lt;code&gt;db&lt;/code&gt; 关键字参数来告诉插件创建句柄。第二条路线不需要数据库，因此被插件忽略。第三条路线确实需要'db'关键字参数，但是显式跳过了sqlite插件。这样，参数不会被插件否决，并且仍然包含同名url参数的值。</target>
        </trans-unit>
        <trans-unit id="2645366d771f7e27de9dc97880133b2c81117b57" translate="yes" xml:space="preserve">
          <source>The following chapter give a short introduction how to adapt Bottle for larger projects. Furthermore, we will show how to operate Bottle with web servers which perform better on a higher load / more web traffic than the one we used so far.</source>
          <target state="translated">下一章将简要介绍如何在大型项目中使用Bottle。此外,我们将展示如何在更高负载/更多网络流量的情况下使用比我们目前使用的服务器更好的Web服务器来操作Bottle。</target>
        </trans-unit>
        <trans-unit id="44f343131cf69dba3da725150e8c20ddffb8f662" translate="yes" xml:space="preserve">
          <source>The following filters are implemented by default and more may be added:</source>
          <target state="translated">以下是默认实施的过滤器,可以添加更多的过滤器。</target>
        </trans-unit>
        <trans-unit id="d86a697a26934fa7694a6a9f5aaef169ea35710c" translate="yes" xml:space="preserve">
          <source>The following standard filters are implemented:</source>
          <target state="translated">实施了以下标准过滤器。</target>
        </trans-unit>
        <trans-unit id="895b05b40554f1f16b58609920b627abf77358dc" translate="yes" xml:space="preserve">
          <source>The following two classes can be raised as an exception. The most noticeable difference is that bottle invokes error handlers for &lt;a href=&quot;#bottle.HTTPError&quot;&gt;&lt;code&gt;HTTPError&lt;/code&gt;&lt;/a&gt;, but not for &lt;a href=&quot;#bottle.HTTPResponse&quot;&gt;&lt;code&gt;HTTPResponse&lt;/code&gt;&lt;/a&gt; or other response types.</source>
          <target state="translated">作为例外，可以提出以下两个类。最明显的区别是bottle为&lt;a href=&quot;#bottle.HTTPError&quot;&gt; &lt;code&gt;HTTPError&lt;/code&gt; &lt;/a&gt;调用错误处理程序，但没有为&lt;a href=&quot;#bottle.HTTPResponse&quot;&gt; &lt;code&gt;HTTPResponse&lt;/code&gt; &lt;/a&gt;或其他响应类型调用错误处理程序。</target>
        </trans-unit>
        <trans-unit id="d43a09c7b1595ee6b2ddddb7524a2a690fbabc82" translate="yes" xml:space="preserve">
          <source>The full list is available through &lt;code&gt;server_names&lt;/code&gt;.</source>
          <target state="translated">完整列表可通过 &lt;code&gt;server_names&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="735ab1177d98ac79a8d54bd002a2b3845c584827" translate="yes" xml:space="preserve">
          <source>The full request URI including hostname and scheme. If your app lives behind a reverse proxy or load balancer and you get confusing results, make sure that the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is set correctly.</source>
          <target state="translated">完整的请求URI，包括主机名和方案。如果您的应用程序位于反向代理或负载均衡器后面，并且您得到令人困惑的结果，请确保正确设置了 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="41c739ec61dd7cc4641bd2e821da6cf10a879d05" translate="yes" xml:space="preserve">
          <source>The hook callbacks cannot &lt;em&gt;change&lt;/em&gt; the value that is to be stored to the dictionary. That is what filters are for.</source>
          <target state="translated">钩子回调不能&lt;em&gt;更改&lt;/em&gt;要存储到字典中的值。那就是过滤器的目的。</target>
        </trans-unit>
        <trans-unit id="b859929661e2625db3b18af8830252771a30de0e" translate="yes" xml:space="preserve">
          <source>The initial portion of the URL&amp;rsquo;s &lt;code&gt;path&lt;/code&gt; that was removed by a higher level (server or routing middleware) before the application was called. This script path is returned with leading and tailing slashes.</source>
          <target state="translated">URL &lt;code&gt;path&lt;/code&gt; 的初始部分，在调用应用程序之前已由更高级别（服务器或路由中间件）删除。该脚本路径以反斜杠开头和结尾。</target>
        </trans-unit>
        <trans-unit id="bdc2f9c29ef84a3e96a9fe8d02599ade38482741" translate="yes" xml:space="preserve">
          <source>The key point here is the colon. This tells Bottle to accept for &lt;code&gt;:something&lt;/code&gt; any string up to the next slash. Furthermore, the value of &lt;code&gt;something&lt;/code&gt; will be passed to the function assigned to that route, so the data can be processed within the function.</source>
          <target state="translated">这里的关键是冒号。这告诉Bottle接受 &lt;code&gt;:something&lt;/code&gt; 直到下一个斜杠的任何字符串。此外， &lt;code&gt;something&lt;/code&gt; 值将传递给分配给该路由的函数，因此可以在函数中处理数据。</target>
        </trans-unit>
        <trans-unit id="5f6f6832c78752adab3d8a4f0ba21d69691192a9" translate="yes" xml:space="preserve">
          <source>The last form accepts not only function calls, but any type of expression. Keyword arguments passed to this function are available as local variables. Example: &lt;code&gt;import_string('re:compile(x)', x='[a-z]')&lt;/code&gt;</source>
          <target state="translated">最后一种形式不仅接受函数调用，还接受任何类型的表达式。传递给此函数的关键字参数可用作局部变量。示例： &lt;code&gt;import_string('re:compile(x)', x='[a-z]')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f05bd815bc64ab3bc3175ce56a60867db2d7871" translate="yes" xml:space="preserve">
          <source>The last line tells Bottle to install the plugin to the default application. This causes the plugin to be automatically applied to all routes of that application. In other words, &lt;code&gt;stopwatch()&lt;/code&gt; is called once for each route callback and the return value is used as a replacement for the original callback.</source>
          <target state="translated">最后一行告诉Bottle将插件安装到默认应用程序。这将导致插件自动应用于该应用程序的所有路由。换句话说，对于每个路由回调，都将一次调用 &lt;code&gt;stopwatch()&lt;/code&gt; ，并将返回值用作原始回调的替代。</target>
        </trans-unit>
        <trans-unit id="2d04873114709ee4836cabf076a18fff17fe06b7" translate="yes" xml:space="preserve">
          <source>The last point to do is to enable editing of existing items.</source>
          <target state="translated">最后一点要做的是实现对现有项目的编辑。</target>
        </trans-unit>
        <trans-unit id="472e2a57e19d59c4eddec46af306e99bad844af3" translate="yes" xml:space="preserve">
          <source>The main benefit is that the request handler terminates early. The handling thread can move on and accept new requests while the callbacks continue to write to sockets of previous requests. This is how these frameworks manage to process a lot of concurrent requests with only a small number of OS threads.</source>
          <target state="translated">主要的好处是,请求处理程序提前终止。处理线程可以继续前进,接受新的请求,同时回调继续向之前请求的套接字写入。这就是这些框架如何在仅有少量操作系统线程的情况下处理大量并发请求的方法。</target>
        </trans-unit>
        <trans-unit id="4bb22fedb53acb8311f23676f1430630c03378e0" translate="yes" xml:space="preserve">
          <source>The modified paths.</source>
          <target state="translated">修改后的路径。</target>
        </trans-unit>
        <trans-unit id="b55d5283becd2036045412ab850e0018a9305198" translate="yes" xml:space="preserve">
          <source>The module defines several functions, constants, and an exception.</source>
          <target state="translated">该模块定义了几个函数、常量和一个异常。</target>
        </trans-unit>
        <trans-unit id="1ff613b353a32c9f833645bc313695851c21d793" translate="yes" xml:space="preserve">
          <source>The module-level &lt;a href=&quot;#bottle.request&quot;&gt;&lt;code&gt;bottle.request&lt;/code&gt;&lt;/a&gt; is a proxy object (implemented in &lt;a href=&quot;#bottle.LocalRequest&quot;&gt;&lt;code&gt;LocalRequest&lt;/code&gt;&lt;/a&gt;) and always refers to the &lt;code&gt;current&lt;/code&gt; request, or in other words, the request that is currently processed by the request handler in the current thread. This &lt;code&gt;thread locality&lt;/code&gt; ensures that you can safely use a global instance in a multi-threaded environment.</source>
          <target state="translated">模块级&lt;a href=&quot;#bottle.request&quot;&gt; &lt;code&gt;bottle.request&lt;/code&gt; &lt;/a&gt;是一个代理对象（在&lt;a href=&quot;#bottle.LocalRequest&quot;&gt; &lt;code&gt;LocalRequest&lt;/code&gt; 中&lt;/a&gt;实现），并且始终引用 &lt;code&gt;current&lt;/code&gt; 请求，或者换句话说，当前线程中请求处理程序当前正在处理的请求。此 &lt;code&gt;thread locality&lt;/code&gt; 确保您可以在多线程环境中安全地使用全局实例。</target>
        </trans-unit>
        <trans-unit id="bf71505a1047b5862ac2bc94cee226019a10f0b7" translate="yes" xml:space="preserve">
          <source>The module-level &lt;code&gt;install()&lt;/code&gt; and &lt;code&gt;uninstall()&lt;/code&gt; functions affect the &lt;a href=&quot;#default-app&quot;&gt;Default Application&lt;/a&gt;. To manage plugins for a specific application, use the corresponding methods on the &lt;a href=&quot;api#bottle.Bottle&quot;&gt;&lt;code&gt;Bottle&lt;/code&gt;&lt;/a&gt; application object.</source>
          <target state="translated">模块级别的 &lt;code&gt;install()&lt;/code&gt; 和 &lt;code&gt;uninstall()&lt;/code&gt; 函数会影响&lt;a href=&quot;#default-app&quot;&gt;Default Application&lt;/a&gt;。要管理特定应用程序的插件，请在&lt;a href=&quot;api#bottle.Bottle&quot;&gt; &lt;code&gt;Bottle&lt;/code&gt; &lt;/a&gt;应用程序对象上使用相应的方法。</target>
        </trans-unit>
        <trans-unit id="64c3d9d45899ed40133caac7e336415289947247" translate="yes" xml:space="preserve">
          <source>The name of the route (if specified) or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">路线名称（如果指定）或 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58ce54e400f38f30e234a999baf1f5b9732a230e" translate="yes" xml:space="preserve">
          <source>The new rule syntax was introduce in &lt;strong&gt;Bottle 0.10&lt;/strong&gt; to simplify some common use cases, but the old syntax still works and you can find lot code examples still using it. The differences are best described by example:</source>
          <target state="translated">在&lt;strong&gt;Bottle 0.10&lt;/strong&gt;中引入了新的规则语法，以简化一些常见的用例，但是旧的语法仍然有效，您可以找到仍在使用它的很多代码示例。最好用示例来描述这些差异：</target>
        </trans-unit>
        <trans-unit id="5391f56f8d4dd34274fc2b5065327514438c87e3" translate="yes" xml:space="preserve">
          <source>The new rule syntax was introduced in &lt;strong&gt;Bottle 0.10&lt;/strong&gt; to simplify some common use cases, but the old syntax still works and you can find a lot of code examples still using it. The differences are best described by example:</source>
          <target state="translated">在&lt;strong&gt;Bottle 0.10&lt;/strong&gt;中引入了新的规则语法，以简化一些常见的用例，但是旧的语法仍然有效，您可以找到许多仍在使用它的代码示例。最好用示例来描述这些差异：</target>
        </trans-unit>
        <trans-unit id="0e8f1a18da97ec1fdc1f4207bf72c9e4590bd543" translate="yes" xml:space="preserve">
          <source>The next step may is to catch the error with Bottle itself, to keep away any type of error message from the user of your application. To do that, Bottle has an &amp;ldquo;error-route&amp;rdquo;, which can be a assigned to a HTML-error.</source>
          <target state="translated">下一步可能是使用Bottle本身捕获错误，以免与应用程序用户发生任何类型的错误消息。为此，Bottle具有&amp;ldquo;错误路由&amp;rdquo;，可以将其分配给HTML错误。</target>
        </trans-unit>
        <trans-unit id="cf675bce88de61640c2304b391973c2e50cb227f" translate="yes" xml:space="preserve">
          <source>The object-oriented approach is further described in the &lt;a href=&quot;#default-app&quot;&gt;Default Application&lt;/a&gt; section. Just keep in mind that you have a choice.</source>
          <target state="translated">面向对象的方法将在&amp;ldquo; &lt;a href=&quot;#default-app&quot;&gt;默认应用程序&amp;rdquo;&lt;/a&gt;部分中进一步描述。请记住，您可以选择。</target>
        </trans-unit>
        <trans-unit id="140a1beb006443e6f28ad70e5632a27e7f4733cd" translate="yes" xml:space="preserve">
          <source>The ordering of this list is significant. You may for example return a subclass of &lt;a href=&quot;http://docs.python.org/library/functions.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;read()&lt;/code&gt; method. It is still treated as a string instead of a file, because strings are handled first.</source>
          <target state="translated">该列表的顺序很重要。例如，您可以使用 &lt;code&gt;read()&lt;/code&gt; 方法返回&lt;a href=&quot;http://docs.python.org/library/functions.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的子类。它仍然被视为字符串而不是文件，因为首先处理字符串。</target>
        </trans-unit>
        <trans-unit id="9e26ff3489035d1eb6056b8709e0c0f37c7f7050" translate="yes" xml:space="preserve">
          <source>The ordering of this list is significant. You may for example return a subclass of &lt;a href=&quot;https://docs.python.org/library/functions.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;read()&lt;/code&gt; method. It is still treated as a string instead of a file, because strings are handled first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b911afe909021e27d14a63554527b72bef6c37" translate="yes" xml:space="preserve">
          <source>The original callback with no plugins applied. Useful for introspection.</source>
          <target state="translated">原始回调,没有应用任何插件。对反省有用。</target>
        </trans-unit>
        <trans-unit id="01c84aa73d0316262e1481b896427469bed0cf76" translate="yes" xml:space="preserve">
          <source>The path-rule string (e.g. &lt;code&gt;/wiki/:page&lt;/code&gt;).</source>
          <target state="translated">路径规则字符串（例如 &lt;code&gt;/wiki/:page&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a3557fd48c227d0085b25dccb57912d2bfcd7ed" translate="yes" xml:space="preserve">
          <source>The plugin API builds on the concept of &lt;a href=&quot;http://docs.python.org/glossary.html#term-decorator&quot;&gt;decorators&lt;/a&gt;. To put it briefly, a plugin is a decorator applied to every single route callback of an application.</source>
          <target state="translated">插件API建立在&lt;a href=&quot;http://docs.python.org/glossary.html#term-decorator&quot;&gt;装饰器&lt;/a&gt;的概念上。简而言之，插件是应用于应用程序的每个路由回调的装饰器。</target>
        </trans-unit>
        <trans-unit id="68502a7d1fd90599225cc33226d26739c06e9c31" translate="yes" xml:space="preserve">
          <source>The plugin API builds on the concept of &lt;a href=&quot;https://docs.python.org/glossary.html#term-decorator&quot;&gt;decorators&lt;/a&gt;. To put it briefly, a plugin is a decorator applied to every single route callback of an application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7893c29e7145788924f9ffb3180a3f97e672fe5" translate="yes" xml:space="preserve">
          <source>The plugin is not applied to the route callbacks yet. This is delayed to make sure no routes are missed. You can install plugins first and add routes later, if you want to. The order of installed plugins is significant, though. If a plugin requires a database connection, you need to install the database plugin first.</source>
          <target state="translated">该插件尚未应用于路由回调。这是为了确保不漏掉任何路由而延迟的。如果你想的话,可以先安装插件,然后再添加路由。不过,安装插件的顺序很重要。如果一个插件需要连接数据库,你需要先安装数据库插件。</target>
        </trans-unit>
        <trans-unit id="b791ad877511dca238a4ca3a07cdf898fca0ccab" translate="yes" xml:space="preserve">
          <source>The query string (as in &lt;code&gt;/forum?id=1&amp;amp;page=5&lt;/code&gt;) is commonly used to transmit a small number of key/value pairs to the server. You can use the &lt;a href=&quot;api#bottle.BaseRequest.query&quot;&gt;&lt;code&gt;BaseRequest.query&lt;/code&gt;&lt;/a&gt; attribute (a &lt;a href=&quot;api#bottle.FormsDict&quot;&gt;&lt;code&gt;FormsDict&lt;/code&gt;&lt;/a&gt;) to access these values and the &lt;a href=&quot;api#bottle.BaseRequest.query_string&quot;&gt;&lt;code&gt;BaseRequest.query_string&lt;/code&gt;&lt;/a&gt; attribute to get the whole string.</source>
          <target state="translated">查询字符串（如 &lt;code&gt;/forum?id=1&amp;amp;page=5&lt;/code&gt; ）通常用于将少量键/值对传输到服务器。您可以使用&lt;a href=&quot;api#bottle.BaseRequest.query&quot;&gt; &lt;code&gt;BaseRequest.query&lt;/code&gt; &lt;/a&gt;属性（&lt;a href=&quot;api#bottle.FormsDict&quot;&gt; &lt;code&gt;FormsDict&lt;/code&gt; &lt;/a&gt;）访问这些值，并使用&lt;a href=&quot;api#bottle.BaseRequest.query_string&quot;&gt; &lt;code&gt;BaseRequest.query_string&lt;/code&gt; &lt;/a&gt;属性获取整个字符串。</target>
        </trans-unit>
        <trans-unit id="569e5ec99938d698ef97ccd68edd5f7a9ec23a77" translate="yes" xml:space="preserve">
          <source>The raw &lt;a href=&quot;#bottle.BaseRequest.query&quot;&gt;&lt;code&gt;query&lt;/code&gt;&lt;/a&gt; part of the URL (everything in between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;#&lt;/code&gt;) as a string.</source>
          <target state="translated">URL 的原始&lt;a href=&quot;#bottle.BaseRequest.query&quot;&gt; &lt;code&gt;query&lt;/code&gt; &lt;/a&gt;部分（介于 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;#&lt;/code&gt; 之间的所有内容）为字符串。</target>
        </trans-unit>
        <trans-unit id="bdab35d5c042b2721ca5089917ad2c80eee98a6f" translate="yes" xml:space="preserve">
          <source>The raw request body</source>
          <target state="translated">原始请求体</target>
        </trans-unit>
        <trans-unit id="013e6b9ce1f809f8e768f7b8c94458fa77762a62" translate="yes" xml:space="preserve">
          <source>The reloading depends on the ability to stop the child process. If you are running on Windows or any other operating system not supporting &lt;code&gt;signal.SIGINT&lt;/code&gt; (which raises &lt;code&gt;KeyboardInterrupt&lt;/code&gt; in Python), &lt;code&gt;signal.SIGTERM&lt;/code&gt; is used to kill the child. Note that exit handlers and finally clauses, etc., are not executed after a &lt;code&gt;SIGTERM&lt;/code&gt;.</source>
          <target state="translated">重新加载取决于停止子进程的能力。如果您在Windows或任何其他不支持 &lt;code&gt;signal.SIGINT&lt;/code&gt; 的操作系统上运行（在Python 中会引发 &lt;code&gt;KeyboardInterrupt&lt;/code&gt; ），则使用 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 杀死该孩子。请注意，退出处理程序和finally子句等不在 &lt;code&gt;SIGTERM&lt;/code&gt; 之后执行。</target>
        </trans-unit>
        <trans-unit id="037ed18ba8506d9791f1b7f12de97f68e8192be6" translate="yes" xml:space="preserve">
          <source>The request body length as an integer. The client is responsible to set this header. Otherwise, the real length of the body is unknown and -1 is returned. In this case, &lt;a href=&quot;#bottle.BaseRequest.body&quot;&gt;&lt;code&gt;body&lt;/code&gt;&lt;/a&gt; will be empty.</source>
          <target state="translated">请求正文长度（整数）。客户端负责设置此标头。否则，主体的实际长度未知，并且返回-1。在这种情况下，&lt;a href=&quot;#bottle.BaseRequest.body&quot;&gt; &lt;code&gt;body&lt;/code&gt; &lt;/a&gt;将为空。</target>
        </trans-unit>
        <trans-unit id="5dea0cf5e78f99c7d9e0478ac0434afc61fb973e" translate="yes" xml:space="preserve">
          <source>The rest of this piece of code is just processing of the gained data: writing to the database, retrieve the corresponding id from the database and generate the output.</source>
          <target state="translated">剩下的这段代码只是对获得的数据进行处理:写入数据库,从数据库中检索出相应的id并生成输出。</target>
        </trans-unit>
        <trans-unit id="bba5523edeec11c3cbcbb26248f0be2c861ff36b" translate="yes" xml:space="preserve">
          <source>The route callback with all plugins applied. This property is created on demand and then cached to speed up subsequent requests.</source>
          <target state="translated">应用了所有插件的路由回调。这个属性是按需创建的,然后缓存起来,以加快后续请求的速度。</target>
        </trans-unit>
        <trans-unit id="0ba7b4352dbc6eb908bceae990425115c36a5e77" translate="yes" xml:space="preserve">
          <source>The rule &lt;code&gt;/&amp;lt;action&amp;gt;/&amp;lt;item&amp;gt;&lt;/code&gt; matches as follows:</source>
          <target state="translated">规则 &lt;code&gt;/&amp;lt;action&amp;gt;/&amp;lt;item&amp;gt;&lt;/code&gt; 匹配如下：</target>
        </trans-unit>
        <trans-unit id="b01d8c58b9c49391308d4b60922ebf4c3d305442" translate="yes" xml:space="preserve">
          <source>The rule string (e.g. &lt;code&gt;/wiki/:page&lt;/code&gt;).</source>
          <target state="translated">规则字符串（例如 &lt;code&gt;/wiki/:page&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21b547f5fc81fb460d3468dfce1ea82e0f971970" translate="yes" xml:space="preserve">
          <source>The simplest form of a wildcard consists of a name enclosed in angle brackets (e.g. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;). The name should be unique for a given route and form a valid python identifier (alphanumeric, starting with a letter). This is because wildcards are used as keyword arguments for the request callback later.</source>
          <target state="translated">通配符的最简单形式是用尖括号括起来的名称（例如 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ）。名称对于给定的路由应该是唯一的，并形成有效的python标识符（字母数字，以字母开头）。这是因为通配符在以后用作请求回调的关键字参数。</target>
        </trans-unit>
        <trans-unit id="d9ebe38a75163c600360dd074411e309a808b156" translate="yes" xml:space="preserve">
          <source>The template &lt;code&gt;edit_task.tpl&lt;/code&gt; called within the function looks like this:</source>
          <target state="translated">函数中调用的模板 &lt;code&gt;edit_task.tpl&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="e6e6442fd08b84c38e4ed5b27ac005aa7413597b" translate="yes" xml:space="preserve">
          <source>The template engine allows you to embed lines or blocks of python code within your template. Code lines start with &lt;code&gt;%&lt;/code&gt; and code blocks are surrounded by &lt;code&gt;&amp;lt;%&lt;/code&gt; and &lt;code&gt;%&amp;gt;&lt;/code&gt; tokens:</source>
          <target state="translated">模板引擎允许您在模板中嵌入python代码行或块。代码行以 &lt;code&gt;%&lt;/code&gt; 开头，代码块被 &lt;code&gt;&amp;lt;%&lt;/code&gt; 和 &lt;code&gt;%&amp;gt;&lt;/code&gt; 标记包围：</target>
        </trans-unit>
        <trans-unit id="ccd613dd169948dcad0704ae1aaafe52ec3d98ef" translate="yes" xml:space="preserve">
          <source>The template syntax is a very thin layer around the Python language. Its main purpose is to ensure correct indentation of blocks, so you can format your template without worrying about indentation. Follow the link for a full syntax description: &lt;a href=&quot;stpl&quot;&gt;SimpleTemplate Engine&lt;/a&gt;</source>
          <target state="translated">模板语法是围绕Python语言的非常薄的一层。它的主要目的是确保正确的块缩进，因此您可以设置模板格式而不必担心缩进。单击链接获取完整的语法说明：&lt;a href=&quot;stpl&quot;&gt;SimpleTemplate Engine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67c266a45e6151935f3d15b0af95c2d74e6234a9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;PATH_INFO&lt;/code&gt; with exactly one prefixed slash (to fix broken clients and avoid the &amp;ldquo;empty path&amp;rdquo; edge case).</source>
          <target state="translated">&lt;code&gt;PATH_INFO&lt;/code&gt; 的值带有一个正斜杠（以修复损坏的客户端并避免出现&amp;ldquo;空路径&amp;rdquo;边缘情况）。</target>
        </trans-unit>
        <trans-unit id="d85847bfa329fb1171939f8d6e73d32e1e6b7cf5" translate="yes" xml:space="preserve">
          <source>The values of &lt;a href=&quot;#bottle.BaseRequest.forms&quot;&gt;&lt;code&gt;forms&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bottle.BaseRequest.files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt; combined into a single &lt;a href=&quot;#bottle.FormsDict&quot;&gt;&lt;code&gt;FormsDict&lt;/code&gt;&lt;/a&gt;. Values are either strings (form values) or instances of &lt;code&gt;cgi.FieldStorage&lt;/code&gt; (file uploads).</source>
          <target state="translated">&lt;a href=&quot;#bottle.BaseRequest.forms&quot;&gt; &lt;code&gt;forms&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#bottle.BaseRequest.files&quot;&gt; &lt;code&gt;files&lt;/code&gt; &lt;/a&gt;的值合并到一个&lt;a href=&quot;#bottle.FormsDict&quot;&gt; &lt;code&gt;FormsDict&lt;/code&gt; 中&lt;/a&gt;。值可以是字符串（表单值）或 &lt;code&gt;cgi.FieldStorage&lt;/code&gt; 的实例（文件上传）。</target>
        </trans-unit>
        <trans-unit id="e432e283133b97f7dafc36dd2ce0583548446b6c" translate="yes" xml:space="preserve">
          <source>The while-loop runs until the client closes the connection. You get the idea :)</source>
          <target state="translated">while-loop一直运行到客户端关闭连接。你懂的 :)</target>
        </trans-unit>
        <trans-unit id="c9e41b041f206a620f1d48de0ac0344d24d5689e" translate="yes" xml:space="preserve">
          <source>The wrapped WSGI environ dictionary. This is the only real attribute. All other attributes actually are read-only properties.</source>
          <target state="translated">封装的WSGI环境字典。这是唯一真正的属性。其他所有属性实际上都是只读属性。</target>
        </trans-unit>
        <trans-unit id="73895ddb7c0e24078906486bf0fe5e27091bee2f" translate="yes" xml:space="preserve">
          <source>There are several other attributes used to access form data. Some of them combine values from different sources for easier access. The following table should give you a decent overview.</source>
          <target state="translated">还有一些其他属性用于访问表格数据。其中一些属性结合了不同来源的值,以便于访问。下表应该能给你一个不错的概述。</target>
        </trans-unit>
        <trans-unit id="0ade61b49a3005ebb6d5cb55657afe2410536678" translate="yes" xml:space="preserve">
          <source>There is no built-in support for sessions because there is no &lt;em&gt;right&lt;/em&gt; way to do it (in a micro framework). Depending on requirements and environment you could use &lt;a href=&quot;http://beaker.groovie.org/&quot;&gt;beaker&lt;/a&gt; middleware with a fitting backend or implement it yourself. Here is an example for beaker sessions with a file-based backend:</source>
          <target state="translated">没有对会话的内置支持，因为没有&lt;em&gt;正确的&lt;/em&gt;方法（在微型框架中）。根据需求和环境，您可以使用带有合适后端的&lt;a href=&quot;http://beaker.groovie.org/&quot;&gt;烧杯&lt;/a&gt;中间件，也可以自己实现。这是带有基于文件的后端的烧杯会话的示例：</target>
        </trans-unit>
        <trans-unit id="0fbd5950bc5482c12e75dbd1987af3aa741226bb" translate="yes" xml:space="preserve">
          <source>There may be cases where you do not want your application to generate the output directly, but return data to be processed further on, e.g. by JavaScript. For those cases, Bottle offers the possibility to return JSON objects, which is sort of standard for exchanging data between web applications. Furthermore, JSON can be processed by many programming languages, including Python</source>
          <target state="translated">在某些情况下,您可能不希望您的应用程序直接生成输出,而是返回数据以便进一步处理,例如通过JavaScript。对于这些情况,Bottle提供了返回JSON对象的可能性,这算是Web应用程序之间交换数据的标准。此外,JSON 可以被许多编程语言处理,包括 Python</target>
        </trans-unit>
        <trans-unit id="47383ea7070398b48e42cf5344b94c14f6c29622" translate="yes" xml:space="preserve">
          <source>These chapters are intended for developers interested in the bottle development and release workflow.</source>
          <target state="translated">这些章节是为对瓶子开发和发布工作流程感兴趣的开发人员准备的。</target>
        </trans-unit>
        <trans-unit id="ef1efa715a19a76767e23be32cfc82fa6f8c8fc8" translate="yes" xml:space="preserve">
          <source>These produce an empty output with the &lt;code&gt;Content-Length&lt;/code&gt; header set to 0.</source>
          <target state="translated">这些将产生一个空输出，并且 &lt;code&gt;Content-Length&lt;/code&gt; 标头设置为0。</target>
        </trans-unit>
        <trans-unit id="97a499fc6489e4c1608ebef2e34e9b8cd021f993" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bottle.MultiDict&quot;&gt;&lt;code&gt;MultiDict&lt;/code&gt;&lt;/a&gt; subclass is used to store request form data. Additionally to the normal dict-like item access methods (which return unmodified data as native strings), this container also supports attribute-like access to its values. Attributes are automatically de- or recoded to match &lt;a href=&quot;#bottle.FormsDict.input_encoding&quot;&gt;&lt;code&gt;input_encoding&lt;/code&gt;&lt;/a&gt; (default: &amp;lsquo;utf8&amp;rsquo;). Missing attributes default to an empty string.</source>
          <target state="translated">该&lt;a href=&quot;#bottle.MultiDict&quot;&gt; &lt;code&gt;MultiDict&lt;/code&gt; &lt;/a&gt;子类用于存储请求表单数据。除了普通的类似dict的项访问方法（将未修改的数据作为本机字符串返回）之外，此容器还支持对其值进行类似属性的访问。属性会自动&lt;a href=&quot;#bottle.FormsDict.input_encoding&quot;&gt; &lt;code&gt;input_encoding&lt;/code&gt; &lt;/a&gt;或重新编码以匹配input_encoding（默认值：'utf8'）。缺少的属性默认为空字符串。</target>
        </trans-unit>
        <trans-unit id="229c668abb46d0b0b35ed873fa0ecedaa262a500" translate="yes" xml:space="preserve">
          <source>This behavior is intended as a sane default, but can be overridden. The following example re-activates all plugins for a specific proxy-route:</source>
          <target state="translated">这个行为是作为一个合理的默认值,但可以被重写。下面的例子会重新激活特定代理路由的所有插件。</target>
        </trans-unit>
        <trans-unit id="467341e0bb3ad77c6471df22a1ee5e9babbc50f7" translate="yes" xml:space="preserve">
          <source>This can be combined with the following &lt;code&gt;base.tpl&lt;/code&gt;:</source>
          <target state="translated">可以将其与以下 &lt;code&gt;base.tpl&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="f4b2c15a0cbe42537675e5dbee488d899ce66159" translate="yes" xml:space="preserve">
          <source>This class does support dict-like case-insensitive item-access to headers, but is NOT a dict. Most notably, iterating over a response yields parts of the body and not the headers.</source>
          <target state="translated">这个类确实支持类似于dict的大小写不敏感的头项访问,但不是dict。最值得注意的是,在响应上迭代会产生部分主体,而不是头文件。</target>
        </trans-unit>
        <trans-unit id="3acb1048764709323551b9c22da312378d54e7cb" translate="yes" xml:space="preserve">
          <source>This class manages a list of search paths and helps to find and open application-bound resources (files).</source>
          <target state="translated">该类管理搜索路径列表,并帮助查找和打开与应用程序相关的资源(文件)。</target>
        </trans-unit>
        <trans-unit id="84a780d032a9e93da4444e897d54d742f4f40cab" translate="yes" xml:space="preserve">
          <source>This class wraps a route callback along with route specific metadata and configuration and applies Plugins on demand. It is also responsible for turing an URL path rule into a regular expression usable by the Router.</source>
          <target state="translated">该类将路由回调与特定的路由元数据和配置一起包装起来,并根据需要应用Plugins。它还负责将URL路径规则转化为Router可以使用的正则表达式。</target>
        </trans-unit>
        <trans-unit id="10d4c8ab3d5158ae411d0f55447da9167fa127a4" translate="yes" xml:space="preserve">
          <source>This dict stores multiple values per key, but behaves exactly like a normal dict in that it returns only the newest value for any given key. There are special methods available to access the full list of values.</source>
          <target state="translated">这个 dict 为每个键存储了多个值,但其行为与普通 dict 完全相同,因为它只返回任何给定键的最新值。有一些特殊的方法可以访问完整的值列表。</target>
        </trans-unit>
        <trans-unit id="26ff263b26858e1c316a6221fb954538ec930899" translate="yes" xml:space="preserve">
          <source>This dict-like class wraps a WSGI environ dict and provides convenient access to HTTP_* fields. Keys and values are native strings (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI environment contains non-native string values, these are de- or encoded using a lossless &amp;lsquo;latin1&amp;rsquo; character set.</source>
          <target state="translated">类似于dict的类包装了WSGI环境dict，并提供对HTTP_ *字段的方便访问。键和值是本地字符串（2.x字节或3.x unicode），键不区分大小写。如果WSGI环境包含非本地字符串值，则使用无损的&amp;ldquo; latin1&amp;rdquo;字符集对其进行解码或编码。</target>
        </trans-unit>
        <trans-unit id="9adce9e9e3799ab801af538b6db0796adefe44a2" translate="yes" xml:space="preserve">
          <source>This example demonstrates two things: You can bind more than one route to a single callback, and you can add wildcards to URLs and access them via keyword arguments.</source>
          <target state="translated">这个例子演示了两件事。你可以在一个回调中绑定多个路由,还可以在URL中添加通配符,并通过关键字参数访问它们。</target>
        </trans-unit>
        <trans-unit id="82ba09ec5fc1df86ee18b723972d0b4c44e20b73" translate="yes" xml:space="preserve">
          <source>This feature is most useful for plugins. They can validate their config parameters or trigger side effects using filters and document their configuration via &lt;code&gt;help&lt;/code&gt; fields:</source>
          <target state="translated">此功能对插件最有用。他们可以使用过滤器验证其配置参数或触发副作用，并通过 &lt;code&gt;help&lt;/code&gt; 字段记录其配置：</target>
        </trans-unit>
        <trans-unit id="2c83db15c1a14b1c1dee34f2ba638234b4698425" translate="yes" xml:space="preserve">
          <source>This generates a database-file &lt;code&gt;todo.db&lt;/code&gt; with tables called &lt;code&gt;todo&lt;/code&gt; and three columns &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;task&lt;/code&gt;, and &lt;code&gt;status&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is a unique id for each row, which is used later on to reference the rows. The column &lt;code&gt;task&lt;/code&gt; holds the text which describes the task, it can be max 100 characters long. Finally, the column &lt;code&gt;status&lt;/code&gt; is used to mark a task as open (value 1) or closed (value 0).</source>
          <target state="translated">这将生成一个数据库文件 &lt;code&gt;todo.db&lt;/code&gt; ,其中包含名为 &lt;code&gt;todo&lt;/code&gt; 的表和三列 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;task&lt;/code&gt; 和 &lt;code&gt;status&lt;/code&gt; 。 &lt;code&gt;id&lt;/code&gt; 是每行的唯一ID，以后将用于引用行。列 &lt;code&gt;task&lt;/code&gt; 包含描述任务的文本，最长不能超过100个字符。最后，列 &lt;code&gt;status&lt;/code&gt; 用于将任务标记为打开（值1）或关闭（值0）。</target>
        </trans-unit>
        <trans-unit id="6666d67facaf5ea7f9090332164ce6d445c3d350" translate="yes" xml:space="preserve">
          <source>This guide explains the plugin API and how to write custom plugins. I suggest reading &lt;a href=&quot;tutorial#plugins&quot;&gt;Plugins&lt;/a&gt; first if you have not done that already. You might also want to have a look at the &lt;a href=&quot;plugins/index&quot;&gt;List of available Plugins&lt;/a&gt; for some practical examples.</source>
          <target state="translated">本指南介绍了插件API以及如何编写自定义插件。如果您尚未阅读&lt;a href=&quot;tutorial#plugins&quot;&gt;插件，&lt;/a&gt;建议您先阅读。您可能还希望查看一些&lt;a href=&quot;plugins/index&quot;&gt;可用&lt;/a&gt;示例的可用插件列表。</target>
        </trans-unit>
        <trans-unit id="f913e5afca1ecc5e78c7fca61b35ff0fe6bffc61" translate="yes" xml:space="preserve">
          <source>This is a collection of code snippets and examples for common use cases.</source>
          <target state="translated">这是一个常见用例的代码片段和示例的集合。</target>
        </trans-unit>
        <trans-unit id="10f43a0a774c92b0d60343a2e1eb2fc098d2238a" translate="yes" xml:space="preserve">
          <source>This is a draft. If you see any errors or find that a specific part is not explained clear enough, please tell the &lt;a href=&quot;mailto:bottlepy%40googlegroups.com&quot;&gt;mailing-list&lt;/a&gt; or file a &lt;a href=&quot;https://github.com/defnull/bottle/issues&quot;&gt;bug report&lt;/a&gt;.</source>
          <target state="translated">这是草稿。如果您发现任何错误或发现对特定部分的解释不够清楚，请告知&lt;a href=&quot;mailto:bottlepy%40googlegroups.com&quot;&gt;邮件列表&lt;/a&gt;或提交&lt;a href=&quot;https://github.com/defnull/bottle/issues&quot;&gt;错误报告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09306d1e9c880512e51b859943f0c35107fa79a7" translate="yes" xml:space="preserve">
          <source>This is a list of third-party plugins that add extend Bottles core functionality or integrate other libraries with the Bottle framework.</source>
          <target state="translated">这是一个第三方插件的列表,这些插件添加扩展了Bottomles的核心功能,或将其他库与Bottle框架集成在一起。</target>
        </trans-unit>
        <trans-unit id="77df5f1a0b185f51635ced2e0870f3e079bd7866" translate="yes" xml:space="preserve">
          <source>This is a mostly auto-generated API. If you are new to bottle, you might find the narrative &lt;a href=&quot;tutorial&quot;&gt;Tutorial&lt;/a&gt; more helpful.</source>
          <target state="translated">这是一个主要自动生成的API。如果您不熟悉瓶子，则可能会觉得叙事&lt;a href=&quot;tutorial&quot;&gt;教程&lt;/a&gt;更有用。</target>
        </trans-unit>
        <trans-unit id="7734a7b6fa68e867eb4674dcafab86aae989b14a" translate="yes" xml:space="preserve">
          <source>This is it. Run this script, visit &lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt; and you will see &amp;ldquo;Hello World!&amp;rdquo; in your browser. Here is how it works:</source>
          <target state="translated">就是这个。运行此脚本，访问&lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http：// localhost：8080 / hello&lt;/a&gt;，您将看到&amp;ldquo; Hello World！&amp;rdquo;。在您的浏览器中。下面是它的工作原理：</target>
        </trans-unit>
        <trans-unit id="a1287db8157257f274f2e23031e9ec6c12fbb2d7" translate="yes" xml:space="preserve">
          <source>This is not the recommend way (you should use a middleware in front of bottle to do this) but you can call other WSGI applications from within your bottle app and let bottle act as a pseudo-middleware. Here is an example:</source>
          <target state="translated">这不是推荐的方式(你应该在bottle前面使用一个中间件来做这件事),但是你可以在你的bottle应用中调用其他WSGI应用,让bottle作为一个伪中间件。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="33649850ed75d74b71421a0f14b67cf3920d30cf" translate="yes" xml:space="preserve">
          <source>This is very convenient for small applications and saves you some typing, but also means that, as soon as your module is imported, routes are installed to the global application. To avoid this kind of import side-effects, Bottle offers a second, more explicit way to build applications:</source>
          <target state="translated">这对于小型应用来说非常方便,可以节省一些打字,但也意味着,只要你的模块被导入,路由就会被安装到全局应用中。为了避免这种导入的副作用,Bottle提供了第二种更明确的构建应用的方式。</target>
        </trans-unit>
        <trans-unit id="b16d512b0abe04daf10c11555647905de7e9d1d0" translate="yes" xml:space="preserve">
          <source>This makes creating asynchronous applications incredibly easy, because they look and feel like synchronous applications. A gevent-based server is actually not asynchronous, but massively multi-threaded. Here is an example:</source>
          <target state="translated">这使得创建异步应用程序变得非常容易,因为它们看起来和感觉都像同步应用程序。基于gevent的服务器实际上不是异步的,而是大规模的多线程。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="1be7a8274ebcbd4a7c4171c9ebdcd3a2027af51f" translate="yes" xml:space="preserve">
          <source>This only works directly in front of code segments. In all other places you can control the whitespace yourself and don&amp;rsquo;t need any special syntax.</source>
          <target state="translated">这仅在代码段前面直接起作用。在所有其他地方，您可以自己控制空格，不需要任何特殊语法。</target>
        </trans-unit>
        <trans-unit id="f27962dc481e90978ae9591fa6de076700c08f55" translate="yes" xml:space="preserve">
          <source>This plugin is actually useful and very similar to the version bundled with Bottle. Not bad for less than 60 lines of code, don&amp;rsquo;t you think? Here is a usage example:</source>
          <target state="translated">该插件实际上非常有用，并且与Bottle捆绑在一起的版本非常相似。少于60行代码还不错，不是吗？这是一个用法示例：</target>
        </trans-unit>
        <trans-unit id="63f57e6debbf5d425ff86ec84b2c5806be97011c" translate="yes" xml:space="preserve">
          <source>This plugin measures the execution time for each request and adds an appropriate &lt;code&gt;X-Exec-Time&lt;/code&gt; header to the response. As you can see, the plugin returns a wrapper and the wrapper calls the original callback recursively. This is how decorators usually work.</source>
          <target state="translated">该插件测量每个请求的执行时间，并在响应中添加适当的 &lt;code&gt;X-Exec-Time&lt;/code&gt; 标头。如您所见，插件返回一个包装器，包装器递归地调用原始回调。这是装饰器通常的工作方式。</target>
        </trans-unit>
        <trans-unit id="05c93fb7f6f9f5c17417b0a80b5173f36d43f2c9" translate="yes" xml:space="preserve">
          <source>This plugin provides an sqlite3 database connection handle as an additional keyword argument to wrapped callbacks, but only if the callback expects it. If not, the route is ignored and no overhead is added. The wrapper does not affect the return value, but handles plugin-related exceptions properly. &lt;a href=&quot;#bottle.Plugin.setup&quot;&gt;&lt;code&gt;Plugin.setup()&lt;/code&gt;&lt;/a&gt; is used to inspect the application and search for conflicting plugins.</source>
          <target state="translated">此插件提供sqlite3数据库连接句柄作为包装的回调的附加关键字参数，但前提是回调需要它。如果不是，则忽略该路由，并且不添加任何开销。包装器不影响返回值，但可以正确处理与插件相关的异常。&lt;a href=&quot;#bottle.Plugin.setup&quot;&gt; &lt;code&gt;Plugin.setup()&lt;/code&gt; &lt;/a&gt;用于检查应用程序并搜索有冲突的插件。</target>
        </trans-unit>
        <trans-unit id="0bff7c8ab44e435fb549f3bc3764fce0df946ee1" translate="yes" xml:space="preserve">
          <source>This reads or sets the global settings stored in class.settings.</source>
          <target state="translated">读取或设置存储在class.settings中的全局设置。</target>
        </trans-unit>
        <trans-unit id="736c9455dfca6f294c0be54bd0ed37440e974ba9" translate="yes" xml:space="preserve">
          <source>This recipe is based upon the &lt;a href=&quot;http://devcenter.heroku.com/articles/quickstart&quot;&gt;Heroku Quickstart&lt;/a&gt;, with Bottle specific code replacing the &lt;a href=&quot;http://devcenter.heroku.com/articles/python#write_your_app&quot;&gt;Write Your App&lt;/a&gt; section of the &lt;a href=&quot;http://devcenter.heroku.com/articles/python&quot;&gt;Getting Started with Python on Heroku/Cedar&lt;/a&gt; guide:</source>
          <target state="translated">此食谱基于&lt;a href=&quot;http://devcenter.heroku.com/articles/quickstart&quot;&gt;Heroku快速入门&lt;/a&gt;，其中特定于Bottle的代码替代了&lt;a href=&quot;http://devcenter.heroku.com/articles/python&quot;&gt;Heroku / Cedar上的Python入门指南中&lt;/a&gt;的&lt;a href=&quot;http://devcenter.heroku.com/articles/python#write_your_app&quot;&gt;Write Your App&lt;/a&gt;部分：</target>
        </trans-unit>
        <trans-unit id="c7f8ccafb78dac79b02c79188fe656b67520cd7b" translate="yes" xml:space="preserve">
          <source>This recipe is based upon the &lt;a href=&quot;https://devcenter.heroku.com/articles/quickstart&quot;&gt;Heroku Quickstart&lt;/a&gt;, with Bottle specific code replacing the &lt;a href=&quot;https://devcenter.heroku.com/articles/python#write_your_app&quot;&gt;Write Your App&lt;/a&gt; section of the &lt;a href=&quot;https://devcenter.heroku.com/articles/python&quot;&gt;Getting Started with Python on Heroku/Cedar&lt;/a&gt; guide:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f533332cb7158e256c604446c2005098f843b887" translate="yes" xml:space="preserve">
          <source>This snippet renders to clean and compact html:</source>
          <target state="translated">这段代码会渲染成干净和紧凑的html。</target>
        </trans-unit>
        <trans-unit id="0bb08f0074789a553fe9220dec84236cec8d2c1c" translate="yes" xml:space="preserve">
          <source>This storage is optimized for fast read access. Retrieving a key or using non-altering dict methods (e.g. &lt;code&gt;dict.get()&lt;/code&gt;) has no overhead compared to a native dict.</source>
          <target state="translated">该存储针对快速读取访问进行了优化。与本机dict相比，检索密钥或使用 &lt;code&gt;dict.get()&lt;/code&gt; dict方法（例如dict.get（））没有开销。</target>
        </trans-unit>
        <trans-unit id="e96b25984df1681ec9e989ceeff26a3b9c2202d2" translate="yes" xml:space="preserve">
          <source>This tutorial assumes you have Bottle either &lt;a href=&quot;#installation&quot;&gt;installed&lt;/a&gt; or copied into your project directory. Let&amp;rsquo;s start with a very basic &amp;ldquo;Hello World&amp;rdquo; example:</source>
          <target state="translated">本教程假定您已&lt;a href=&quot;#installation&quot;&gt;安装&lt;/a&gt; Bottle 或将其复制到项目目录中。让我们从一个非常基本的&amp;ldquo; Hello World&amp;rdquo;示例开始：</target>
        </trans-unit>
        <trans-unit id="83237e6b5e4b708ba53384485d742a06d445214f" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to the concepts and features of the Bottle web framework and covers basic and advanced topics alike. You can read it from start to end, or use it as a reference later on. The automatically generated &lt;a href=&quot;api&quot;&gt;API Reference&lt;/a&gt; may be interesting for you, too. It covers more details, but explains less than this tutorial. Solutions for the most common questions can be found in our &lt;a href=&quot;recipes&quot;&gt;Recipes&lt;/a&gt; collection or on the &lt;a href=&quot;faq&quot;&gt;Frequently Asked Questions&lt;/a&gt; page. If you need any help, join our &lt;a href=&quot;mailto:bottlepy%40googlegroups.com&quot;&gt;mailing list&lt;/a&gt; or visit us in our &lt;a href=&quot;http://webchat.freenode.net/?channels=bottlepy&quot;&gt;IRC channel&lt;/a&gt;.</source>
          <target state="translated">本教程向您介绍Bottle Web框架的概念和功能，并涵盖基本和高级主题。您可以从头到尾阅读它，或者稍后将其用作参考。自动生成的&lt;a href=&quot;api&quot;&gt;API参考&lt;/a&gt;可能对您也很有趣。它涵盖了更多详细信息，但解释不到本教程。有关最常见问题的解决方案，请参见我们的&lt;a href=&quot;recipes&quot;&gt;食谱&lt;/a&gt;集或&amp;ldquo; &lt;a href=&quot;faq&quot;&gt;常见问题&amp;rdquo;&lt;/a&gt;页面。如果您需要任何帮助，请加入我们的&lt;a href=&quot;mailto:bottlepy%40googlegroups.com&quot;&gt;邮件列表&lt;/a&gt;或通过我们的&lt;a href=&quot;http://webchat.freenode.net/?channels=bottlepy&quot;&gt;IRC频道&lt;/a&gt;访问我们。</target>
        </trans-unit>
        <trans-unit id="f715df9e9821b4b111b562fd77071dd8b52f1d4a" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to the concepts and features of the Bottle web framework and covers basic and advanced topics alike. You can read it from start to end, or use it as a reference later on. The automatically generated &lt;a href=&quot;api&quot;&gt;API Reference&lt;/a&gt; may be interesting for you, too. It covers more details, but explains less than this tutorial. Solutions for the most common questions can be found in our &lt;a href=&quot;recipes&quot;&gt;Recipes&lt;/a&gt; collection or on the &lt;a href=&quot;faq&quot;&gt;Frequently Asked Questions&lt;/a&gt; page. If you need any help, join our &lt;a href=&quot;mailto:bottlepy%40googlegroups.com&quot;&gt;mailing list&lt;/a&gt; or visit us in our &lt;a href=&quot;https://webchat.freenode.net/?channels=bottlepy&quot;&gt;IRC channel&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992fd0ea8df12df0efd5d056c180c9ed8c9a2370" translate="yes" xml:space="preserve">
          <source>This tutorial is a work in progess and written by &lt;a href=&quot;http://github.com/noisefloor&quot;&gt;noisefloor&lt;/a&gt;.</source>
          <target state="translated">本教程是一部进行中的作品，由&lt;a href=&quot;http://github.com/noisefloor&quot;&gt;noisefloor&lt;/a&gt;编写。</target>
        </trans-unit>
        <trans-unit id="65e4112208b200f4062e07585a816495449eeca6" translate="yes" xml:space="preserve">
          <source>This tutorial is a work in progess and written by &lt;a href=&quot;https://github.com/noisefloor&quot;&gt;noisefloor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251c5415dcc555a965c16c8a456e1ad791d86805" translate="yes" xml:space="preserve">
          <source>This tutorial should give a brief introduction to the &lt;a href=&quot;http://bottle.paws.org&quot;&gt;Bottle&lt;/a&gt; WSGI Framework. The main goal is to be able, after reading through this tutorial, to create a project using Bottle. Within this document, not all abilities will be shown, but at least the main and important ones like routing, utilizing the Bottle template abilities to format output and handling GET / POST parameters.</source>
          <target state="translated">本教程应简要介绍&lt;a href=&quot;http://bottle.paws.org&quot;&gt;Bottle&lt;/a&gt; WSGI框架。主要目标是在阅读完本教程之后，能够使用Bottle创建一个项目。在本文档中，将不会显示所有功能，但至少会显示主要和重要功能，例如路由，利用Bottle模板功能来格式化输出并处理GET / POST参数。</target>
        </trans-unit>
        <trans-unit id="a7b07ca8c8e9b94b7e950a34d914459277e1df7a" translate="yes" xml:space="preserve">
          <source>This will automatically detect changes to the script and reload the new version once it is called again, without the need to stop and start the server.</source>
          <target state="translated">这将自动检测到脚本的变化,一旦再次调用,就会重新加载新版本,而不需要停止和启动服务器。</target>
        </trans-unit>
        <trans-unit id="db0843478a02b0e3f282ed437b82b2e18d2854ba" translate="yes" xml:space="preserve">
          <source>This will get you the latest development snapshot that includes all the new features. If you prefer a more stable environment, you should stick with the stable releases. These are available on &lt;a href=&quot;http://pypi.python.org/pypi/bottle&quot;&gt;PyPI&lt;/a&gt; and can be installed via &lt;strong&gt;pip&lt;/strong&gt; (recommended), &lt;strong&gt;easy_install&lt;/strong&gt; or your package manager:</source>
          <target state="translated">这将为您提供包括所有新功能的最新开发快照。如果您希望使用更稳定的环境，则应该坚持使用稳定的发行版。这些在&lt;a href=&quot;http://pypi.python.org/pypi/bottle&quot;&gt;PyPI&lt;/a&gt;上可用，并且可以通过&lt;strong&gt;pip&lt;/strong&gt;（推荐），&lt;strong&gt;easy_install&lt;/strong&gt;或您的软件包管理器进行安装：</target>
        </trans-unit>
        <trans-unit id="d037731615a72a28fb378336c6aaeb57d60d69fc" translate="yes" xml:space="preserve">
          <source>This will get you the latest development snapshot that includes all the new features. If you prefer a more stable environment, you should stick with the stable releases. These are available on &lt;a href=&quot;https://pypi.python.org/pypi/bottle&quot;&gt;PyPI&lt;/a&gt; and can be installed via &lt;strong&gt;pip&lt;/strong&gt; (recommended), &lt;strong&gt;easy_install&lt;/strong&gt; or your package manager:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3075673514d3d5df60c9e8fb9a0b64ab162893" translate="yes" xml:space="preserve">
          <source>This will load the template file &lt;code&gt;hello_template.tpl&lt;/code&gt; and render it with the &lt;code&gt;name&lt;/code&gt; variable set. Bottle will look for templates in the &lt;code&gt;./views/&lt;/code&gt; folder or any folder specified in the &lt;code&gt;bottle.TEMPLATE_PATH&lt;/code&gt; list.</source>
          <target state="translated">这将加载模板文件 &lt;code&gt;hello_template.tpl&lt;/code&gt; 并使用 &lt;code&gt;name&lt;/code&gt; 变量集对其进行呈现。Bottle将在 &lt;code&gt;./views/&lt;/code&gt; 文件夹或 &lt;code&gt;bottle.TEMPLATE_PATH&lt;/code&gt; 列表中指定的任何文件夹中查找模板。</target>
        </trans-unit>
        <trans-unit id="e7c08cbe101b55ec65833d12f7c389f438055705" translate="yes" xml:space="preserve">
          <source>This works exactly the same way with &lt;code&gt;FlupServer&lt;/code&gt;, &lt;code&gt;CherryPyServer&lt;/code&gt; and &lt;code&gt;FapwsServer&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;FlupServer&lt;/code&gt; ， &lt;code&gt;CherryPyServer&lt;/code&gt; 和 &lt;code&gt;FapwsServer&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="c106a16a3dcf99d5b2d8e09eba5949f4491fb0f8" translate="yes" xml:space="preserve">
          <source>This, and many other deployment options are described in a separate article: &lt;a href=&quot;deployment&quot;&gt;Deployment&lt;/a&gt;</source>
          <target state="translated">单独的文章中介绍了此方法以及许多其他部署选项：&lt;a href=&quot;deployment&quot;&gt;部署&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49ea3f930b5a01227a9157742ce3867f286c34f2" translate="yes" xml:space="preserve">
          <source>Thread-local property</source>
          <target state="translated">线程本地属性</target>
        </trans-unit>
        <trans-unit id="e5112d7184f06128cb7587d4e585b7b282fdda5c" translate="yes" xml:space="preserve">
          <source>To access GET (or POST) data, we need to import &lt;code&gt;request&lt;/code&gt; from Bottle. To assign the actual data to a variable, we use the statement &lt;code&gt;request.GET.get('task','').strip()&lt;/code&gt; statement, where &lt;code&gt;task&lt;/code&gt; is the name of the GET data we want to access. That&amp;rsquo;s all. If your GET data has more than one variable, multiple &lt;code&gt;request.GET.get()&lt;/code&gt; statements can be used and assigned to other variables.</source>
          <target state="translated">要访问GET（或POST）数据，我们需要从Bottle 导入 &lt;code&gt;request&lt;/code&gt; 。要将实际数据分配给变量，我们使用语句 &lt;code&gt;request.GET.get('task','').strip()&lt;/code&gt; 语句，其中 &lt;code&gt;task&lt;/code&gt; 是我们要访问的GET数据的名称。就这样。如果您的GET数据具有多个变量，则可以使用多个 &lt;code&gt;request.GET.get()&lt;/code&gt; 语句并将其分配给其他变量。</target>
        </trans-unit>
        <trans-unit id="15d16c0760a336b781db159f7ed97c5a20943d1e" translate="yes" xml:space="preserve">
          <source>To achieve this, you need control over the callback cache: &lt;a href=&quot;api#bottle.Route.reset&quot;&gt;&lt;code&gt;Route.reset()&lt;/code&gt;&lt;/a&gt; clears the cache for a single route and &lt;a href=&quot;api#bottle.Bottle.reset&quot;&gt;&lt;code&gt;Bottle.reset()&lt;/code&gt;&lt;/a&gt; clears all caches for all routes of an application at once. On the next request, all plugins are re-applied to the route as if it were requested for the first time.</source>
          <target state="translated">为此，您需要控制回调缓存：&lt;a href=&quot;api#bottle.Route.reset&quot;&gt; &lt;code&gt;Route.reset()&lt;/code&gt; &lt;/a&gt;清除单个路由的缓存，而&lt;a href=&quot;api#bottle.Bottle.reset&quot;&gt; &lt;code&gt;Bottle.reset()&lt;/code&gt; 一次&lt;/a&gt;清除应用程序所有路由的所有缓存。在下一个请求时，所有插件都将重新应用到该路由，就像第一次请求时一样。</target>
        </trans-unit>
        <trans-unit id="f3ffd7e3e8f974df12423679e4074bea307d3c4c" translate="yes" xml:space="preserve">
          <source>To change the IP address where Bottle is listening:</source>
          <target state="translated">要改变Bottle监听的IP地址。</target>
        </trans-unit>
        <trans-unit id="4628b54c19ea8a8c437c9f12d94addbd91e4ac46" translate="yes" xml:space="preserve">
          <source>To change the port, just add &lt;code&gt;port=portnumber&lt;/code&gt; to the run command. So, for example:</source>
          <target state="translated">要更改端口，只需将 &lt;code&gt;port=portnumber&lt;/code&gt; 添加到run命令。因此，例如：</target>
        </trans-unit>
        <trans-unit id="80a53761e11b5bc605b2738abeb45f5463ef5d24" translate="yes" xml:space="preserve">
          <source>To do so, we first add a new route to our script and tell the route that it should get GET data:</source>
          <target state="translated">为此,我们首先在脚本中添加一个新的路由,并告诉该路由应该获取GET数据。</target>
        </trans-unit>
        <trans-unit id="3cf64a2cbd6ff70b2a6500ad8d2675f9f703aef9" translate="yes" xml:space="preserve">
          <source>To get your application available to the outside world, specify the IP of the interface the server should listen to (e.g. &lt;code&gt;run(host='192.168.0.1')&lt;/code&gt;) or let the server listen to all interfaces at once (e.g. &lt;code&gt;run(host='0.0.0.0')&lt;/code&gt;). The listening port can be changed in a similar way, but you need root or admin rights to choose a port below 1024. Port 80 is the standard for HTTP servers:</source>
          <target state="translated">为了使您的应用程序可用于外界，请指定服务器应侦听的接口IP（例如 &lt;code&gt;run(host='192.168.0.1')&lt;/code&gt; ），或让服务器一次侦听所有接口（例如 &lt;code&gt;run(host='0.0.0.0')&lt;/code&gt; ）。侦听端口可以通过类似的方式更改，但是您需要root或admin权限才能选择1024以下的端口。端口80是HTTP服务器的标准配置：</target>
        </trans-unit>
        <trans-unit id="0a52a8f9e73c43af5fe5b116b06602d0985b4387" translate="yes" xml:space="preserve">
          <source>To include the template in our example, just add the following lines:</source>
          <target state="translated">要在我们的例子中加入模板,只需添加以下几行。</target>
        </trans-unit>
        <trans-unit id="166b35740a5470e29948e7fde44c5920f8c32a30" translate="yes" xml:space="preserve">
          <source>To install a plugin, just call &lt;code&gt;install()&lt;/code&gt; with the plugin as first argument:</source>
          <target state="translated">要安装插件，只需将插件作为第一个参数调用 &lt;code&gt;install()&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="3cdd59dc17ceb1c3a2d44d579608a027a98c611b" translate="yes" xml:space="preserve">
          <source>To make life easier, plugins and applications should follow some simple rules when it comes to config parameter names:</source>
          <target state="translated">为了让生活更简单,插件和应用程序在配置参数名称时应该遵循一些简单的规则。</target>
        </trans-unit>
        <trans-unit id="ad3adba67a7baf3672355a6fc3e72c4639f3df84" translate="yes" xml:space="preserve">
          <source>To redirect a client to a different URL, you can send a &lt;code&gt;303 See Other&lt;/code&gt; response with the &lt;code&gt;Location&lt;/code&gt; header set to the new URL. &lt;code&gt;redirect()&lt;/code&gt; does that for you:</source>
          <target state="translated">要将客户端重定向到其他URL，您可以发送 &lt;code&gt;303 See Other&lt;/code&gt; 响应，并将 &lt;code&gt;Location&lt;/code&gt; 标头设置为新URL。 &lt;code&gt;redirect()&lt;/code&gt; 为您做到了：</target>
        </trans-unit>
        <trans-unit id="d196d9cd7d7046cbe7471d5d051ccbb575ea75ed" translate="yes" xml:space="preserve">
          <source>To sum it up: HEAD requests fall back to GET routes and all requests fall back to ANY routes, but only if there is no matching route for the original request method. It&amp;rsquo;s as simple as that.</source>
          <target state="translated">总结一下：HEAD请求回退到GET路由，所有请求回退到ANY路由，但前提是原始请求方法没有匹配的路由。就这么简单。</target>
        </trans-unit>
        <trans-unit id="d2847dfa59b39e2e62d5e3bd448bce30916210d5" translate="yes" xml:space="preserve">
          <source>To support file uploads, we have to change the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag a bit. First, we tell the browser to encode the form data in a different way by adding an &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag. Then, we add &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; tags to allow the user to select a file. Here is an example:</source>
          <target state="translated">为了支持文件上传，我们必须稍微更改 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记。首先，我们告诉浏览器通过在 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记中添加 &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; 属性来以不同的方式对表单数据进行编码。然后，我们添加 &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; 标记以允许用户选择文件。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="2e5f831ee609f8b44a20b60aec308feffe449031" translate="yes" xml:space="preserve">
          <source>To understand the content here, it is not necessary to have a basic knowledge of WSGI, as Bottle tries to keep WSGI away from the user anyway. You should have a fair understanding of the &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt; programming language. Furthermore, the example used in the tutorial retrieves and stores data in a SQL databse, so a basic idea about SQL helps, but is not a must to understand the concepts of Bottle. Right here, &lt;a href=&quot;http://www.sqlite.org&quot;&gt;SQLite&lt;/a&gt; is used. The output of Bottle sent to the browser is formatted in some examples by the help of HTML. Thus, a basic idea about the common HTML tags does help as well.</source>
          <target state="translated">要了解此处的内容，并不需要具有WSGI的基本知识，因为Bottle总是试图使WSGI远离用户。您应该对&lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;编程语言有一定的了解。此外，本教程中使用的示例检索数据并将其存储在SQL数据库中，因此有关SQL的基本思想有所帮助，但不是必须了解Bottle的概念。在这里，使用&lt;a href=&quot;http://www.sqlite.org&quot;&gt;SQLite&lt;/a&gt;。在某些示例中，借助于HTML格式化了发送到浏览器的Bottle的输出格式。因此，有关常见HTML标签的基本思想也有帮助。</target>
        </trans-unit>
        <trans-unit id="4509867b08f4d12c594ac97b30eceb62c062e45f" translate="yes" xml:space="preserve">
          <source>To understand the content here, it is not necessary to have a basic knowledge of WSGI, as Bottle tries to keep WSGI away from the user anyway. You should have a fair understanding of the &lt;a href=&quot;https://www.python.org&quot;&gt;Python&lt;/a&gt; programming language. Furthermore, the example used in the tutorial retrieves and stores data in a SQL databse, so a basic idea about SQL helps, but is not a must to understand the concepts of Bottle. Right here, &lt;a href=&quot;https://www.sqlite.org&quot;&gt;SQLite&lt;/a&gt; is used. The output of Bottle sent to the browser is formatted in some examples by the help of HTML. Thus, a basic idea about the common HTML tags does help as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321fbc66aa248778c3348b79a0b27d4060084437" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;MakoTemplate&lt;/code&gt; as your default template engine, just import its specialised decorator and render function:</source>
          <target state="translated">要将 &lt;code&gt;MakoTemplate&lt;/code&gt; 用作默认模板引擎，只需导入其专门的装饰器和渲染函数：</target>
        </trans-unit>
        <trans-unit id="f84bbc8ca391283a229028f548f1ced8381adf54" translate="yes" xml:space="preserve">
          <source>Trigger a hook and return a list of results.</source>
          <target state="translated">触发一个钩子并返回一个结果列表。</target>
        </trans-unit>
        <trans-unit id="dc8fb6ea62ca72cbe8530c98c6d2589cc76da338" translate="yes" xml:space="preserve">
          <source>True if Chunked transfer encoding was.</source>
          <target state="translated">如果Chunked传输编码为真。</target>
        </trans-unit>
        <trans-unit id="3b6933925666943cc638799d2ddeef6e74a38d20" translate="yes" xml:space="preserve">
          <source>True if the request was triggered by a XMLHttpRequest. This only works with JavaScript libraries that support the &lt;code&gt;X-Requested-With&lt;/code&gt; header (most of the popular libraries do).</source>
          <target state="translated">如果请求是由XMLHttpRequest触发的，则为true。这仅适用于支持 &lt;code&gt;X-Requested-With&lt;/code&gt; 标头的JavaScript库（大多数流行的库都支持）。</target>
        </trans-unit>
        <trans-unit id="aabb2986271672a123f55748f2c7d210453c2e68" translate="yes" xml:space="preserve">
          <source>Try to avoid the old syntax in future projects if you can. It is not currently deprecated, but will be eventually.</source>
          <target state="translated">如果可以的话,在以后的项目中尽量避免使用旧的语法。它目前没有被废弃,但最终会被废弃。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="0d45ad648a14fd7ae4181a413dd8671f1ee1a34d" translate="yes" xml:space="preserve">
          <source>Tutorial: Todo-List Application</source>
          <target state="translated">教程。待办事项列表应用</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="86828104aad480fcc9e1071000ff315afe774e6f" translate="yes" xml:space="preserve">
          <source>Understanding routes</source>
          <target state="translated">了解路线</target>
        </trans-unit>
        <trans-unit id="90ac7bb3b01b32e952ee295aa92163d24d25615d" translate="yes" xml:space="preserve">
          <source>Unicode strings</source>
          <target state="translated">统一码字符串</target>
        </trans-unit>
        <trans-unit id="93ed140ff524e6af0088b4d769964ad53f470a13" translate="yes" xml:space="preserve">
          <source>Unicode strings (or iterables yielding unicode strings) are automatically encoded with the codec specified in the &lt;code&gt;Content-Type&lt;/code&gt; header (utf8 by default) and then treated as normal byte strings (see below).</source>
          <target state="translated">Unicode字符串（或产生unicode字符串的可迭代对象）将使用 &lt;code&gt;Content-Type&lt;/code&gt; 标头中指定的编解码器自动编码（默认情况下为utf8），然后将其视为普通字节字符串（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="26c1f522c9c91190cd5ea339f09a7f3c17459e77" translate="yes" xml:space="preserve">
          <source>Uninstall Plugins</source>
          <target state="translated">卸载插件</target>
        </trans-unit>
        <trans-unit id="94c9ff3ef6f8c57308d7ef2ca875c9512f3ab8a2" translate="yes" xml:space="preserve">
          <source>Uninstall plugins. Pass an instance to remove a specific plugin, a type object to remove all plugins that match that type, a string to remove all plugins with a matching &lt;code&gt;name&lt;/code&gt; attribute or &lt;code&gt;True&lt;/code&gt; to remove all plugins. Return the list of removed plugins.</source>
          <target state="translated">卸载插件。传递一个实例以删除特定的插件，传递一个类型对象以除去与该类型匹配的所有插件，传递一个字符串以除去具有匹配 &lt;code&gt;name&lt;/code&gt; 属性的所有插件，或传递为 &lt;code&gt;True&lt;/code&gt; 以除去所有插件。返回已删除插件的列表。</target>
        </trans-unit>
        <trans-unit id="011dfd8ff83fd3b603bcb11b67f063458b92b30f" translate="yes" xml:space="preserve">
          <source>Unit-Testing Bottle Applications</source>
          <target state="translated">单位测试瓶应用</target>
        </trans-unit>
        <trans-unit id="453e83889f3ae25efaf3919ad4d3710fe70a75d3" translate="yes" xml:space="preserve">
          <source>Unit-testing is usually performed against methods defined in your web application without running a WSGI environment.</source>
          <target state="translated">单元测试通常是在不运行WSGI环境的情况下,针对Web应用程序中定义的方法进行的。</target>
        </trans-unit>
        <trans-unit id="e37405daddda7cc61950cbd550940c6994562619" translate="yes" xml:space="preserve">
          <source>Usage of the template or server adapter classes of course requires the corresponding template or server modules.</source>
          <target state="translated">当然模板或服务器适配器类的使用需要相应的模板或服务器模块。</target>
        </trans-unit>
        <trans-unit id="94fd6d2cf2dbd7512b1df973bdd56e677457cfb2" translate="yes" xml:space="preserve">
          <source>Use a different server that is either multi-threaded or asynchronous.</source>
          <target state="translated">使用不同的服务器,要么是多线程的,要么是异步的。</target>
        </trans-unit>
        <trans-unit id="cdbcc85b59e2fa3bd5873c0d45ca407de2a4f1a5" translate="yes" xml:space="preserve">
          <source>User&amp;rsquo;s Guide</source>
          <target state="translated">用户手册</target>
        </trans-unit>
        <trans-unit id="a32be0a7c841bd73d052c18775a549b30fe2a4f9" translate="yes" xml:space="preserve">
          <source>Using Bottle for a Web-Based ToDo List</source>
          <target state="translated">使用Bottle做一个基于网络的待办事项列表。</target>
        </trans-unit>
        <trans-unit id="9ba476521d0727083abe9910fddbc1927004db86" translate="yes" xml:space="preserve">
          <source>Using Bottle with Heroku</source>
          <target state="translated">使用瓶与Heroku</target>
        </trans-unit>
        <trans-unit id="1daf0ca7563593dec20cd84e90d2714acca466c5" translate="yes" xml:space="preserve">
          <source>Using GET and POST Values</source>
          <target state="translated">使用GET和POST值</target>
        </trans-unit>
        <trans-unit id="578394d3577c461f01185797247e404e77f51916" translate="yes" xml:space="preserve">
          <source>Using dynamic routes is fine, but for many cases it makes sense to validate the dynamic part of the route. For example, we expect an integer number in our route for editing above. But if a float, characters or so are received, the Python interpreter throws an exception, which is not what we want.</source>
          <target state="translated">使用动态路由是没有问题的,但在很多情况下,验证路由的动态部分是有意义的。例如,我们在上面编辑的路由中希望收到一个整数。但如果收到的是浮点数、字符之类的,Python解释器就会抛出一个异常,这不是我们想要的。</target>
        </trans-unit>
        <trans-unit id="ae3d35e93e0f93abec193fb6a6b113d9c89c3e1e" translate="yes" xml:space="preserve">
          <source>Using the hooks plugin</source>
          <target state="translated">使用hooks插件</target>
        </trans-unit>
        <trans-unit id="359936c70836c3ff8ae5f7b70950e95d9ac759dd" translate="yes" xml:space="preserve">
          <source>Validating Dynamic Routes</source>
          <target state="translated">验证动态路由</target>
        </trans-unit>
        <trans-unit id="0b4857e0233b705134724da08c0f952ad4f82560" translate="yes" xml:space="preserve">
          <source>Verify and decode an encoded string. Return an object or None.</source>
          <target state="translated">验证并解码一个已编码的字符串。返回一个对象或None。</target>
        </trans-unit>
        <trans-unit id="8869941c0890a55d337c977ad12476b81575155b" translate="yes" xml:space="preserve">
          <source>WSGI Environment</source>
          <target state="translated">WSGI 环境</target>
        </trans-unit>
        <trans-unit id="254545edde472f6994e2a30171f4c019b39c7a12" translate="yes" xml:space="preserve">
          <source>WSGI and HTTP Utilities</source>
          <target state="translated">WSGI和HTTP实用程序</target>
        </trans-unit>
        <trans-unit id="d685c782bbf23ad3ec40541778d5dceb8bd5ef58" translate="yes" xml:space="preserve">
          <source>WSGI conform list of (header, value) tuples.</source>
          <target state="translated">WSGI符合(header,value)元组的列表。</target>
        </trans-unit>
        <trans-unit id="eaa052f4751a2ff2d5dfdce03a0f7d0d8ab2882e" translate="yes" xml:space="preserve">
          <source>WSGIHeaderDict</source>
          <target state="translated">WSGIHeaderDict</target>
        </trans-unit>
        <trans-unit id="efdf966da6a56eb3353aa9da3bb2bddbfa2c94f4" translate="yes" xml:space="preserve">
          <source>WSGIHeaderDict::raw()</source>
          <target state="translated">WSGIHeaderDict::raw()</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="92d3f163043b51bd940c19975e1032a04d0bcf88" translate="yes" xml:space="preserve">
          <source>Warning: Signed cookies are not encrypted (the client can still see the content) and not copy-protected (the client can restore an old cookie). The main intention is to make pickling and unpickling save, not to store secret information at client side.</source>
          <target state="translated">警告:已签名的cookie不加密(客户端仍然可以看到内容),不受复制保护(客户端可以恢复旧cookie)。签名的cookie没有加密(客户端仍然可以看到内容),也没有复制保护(客户端可以恢复旧cookie)。主要目的是为了让pickling和unpickling保存,而不是在客户端存储秘密信息。</target>
        </trans-unit>
        <trans-unit id="7144c4e3bfcad8ce1d0b580a8543e0dd51687338" translate="yes" xml:space="preserve">
          <source>We assume that your Apache server is up and running and mod_wsgi is working fine as well. On a lot of Linux distributions, mod_wsgi can be easily installed via whatever package management system is in use.</source>
          <target state="translated">我们假设你的Apache服务器已经启动并运行,mod_wsgi也工作正常。在很多Linux发行版上,mod_wsgi可以很容易地通过任何软件包管理系统来安装。</target>
        </trans-unit>
        <trans-unit id="99411abc1fb631f0203a2408d72a43958e8dba28" translate="yes" xml:space="preserve">
          <source>We have a growing &lt;a href=&quot;plugins/index&quot;&gt;List of available Plugins&lt;/a&gt; and most plugins are designed to be portable and re-usable across applications. The chances are high that your problem has already been solved and a ready-to-use plugin exists. If not, the &lt;a href=&quot;plugindev&quot;&gt;Plugin Development Guide&lt;/a&gt; may help you.</source>
          <target state="translated">我们&lt;a href=&quot;plugins/index&quot;&gt;的可用插件列表&lt;/a&gt;越来越多，大多数插件被设计为可移植且可在应用程序之间重复使用。您的问题已经解决并且存在现成的插件的可能性很高。如果没有，《&lt;a href=&quot;plugindev&quot;&gt;插件开发指南》&lt;/a&gt;可能会为您提供帮助。</target>
        </trans-unit>
        <trans-unit id="e840e7e0d94f710da6221b088347efe049efd215" translate="yes" xml:space="preserve">
          <source>We will end up with an application with the following pages and functionality:</source>
          <target state="translated">我们最终会得到一个具有以下页面和功能的应用程序。</target>
        </trans-unit>
        <trans-unit id="4af291ec4e252da4f34ca2e16435e4676a523e3f" translate="yes" xml:space="preserve">
          <source>Web2py Dal integration for Bottle.</source>
          <target state="translated">Web2py Dal集成的Bottle。</target>
        </trans-unit>
        <trans-unit id="9e7e69de18ab90771b235e6616afbd2460e20c65" translate="yes" xml:space="preserve">
          <source>What you will see in the browser is what is returned, thus the value given by the &lt;code&gt;return&lt;/code&gt; statement. In this example, we need to convert &lt;code&gt;result&lt;/code&gt; in to a string by &lt;code&gt;str()&lt;/code&gt;, as Bottle expects a string or a list of strings from the return statement. But here, the result of the database query is a list of tuples, which is the standard defined by the &lt;a href=&quot;http://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB API&lt;/a&gt;.</source>
          <target state="translated">您将在浏览器中看到的是返回的内容，即 &lt;code&gt;return&lt;/code&gt; 语句给出的值。在此示例中，我们需要通过 &lt;code&gt;str()&lt;/code&gt; 将 &lt;code&gt;result&lt;/code&gt; 转换为字符串，因为Bottle期望return语句中的字符串或字符串列表。但是在这里，数据库查询的结果是一个元组列表，这是&lt;a href=&quot;http://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB API&lt;/a&gt;定义的标准。</target>
        </trans-unit>
        <trans-unit id="13a03d51161e081169517d3b27688f20388040ff" translate="yes" xml:space="preserve">
          <source>What you will see in the browser is what is returned, thus the value given by the &lt;code&gt;return&lt;/code&gt; statement. In this example, we need to convert &lt;code&gt;result&lt;/code&gt; in to a string by &lt;code&gt;str()&lt;/code&gt;, as Bottle expects a string or a list of strings from the return statement. But here, the result of the database query is a list of tuples, which is the standard defined by the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c7f931c07ad999c7c48c278bb2ee385c967384" translate="yes" xml:space="preserve">
          <source>When you run your application via mod_wsgi, it is imperative to remove the &lt;code&gt;run()&lt;/code&gt; statement from your code, otherwise it won&amp;rsquo;t work here.</source>
          <target state="translated">当您通过mod_wsgi运行应用程序时，必须从代码中删除 &lt;code&gt;run()&lt;/code&gt; 语句，否则它将无法在此处运行。</target>
        </trans-unit>
        <trans-unit id="a0ec53ff663836ceb52ca8bd3e579774c3397230" translate="yes" xml:space="preserve">
          <source>Whenever you mount an application, Bottle creates a proxy-route on the main-application that forwards all requests to the sub-application. Plugins are disabled for this kind of proxy-route by default. As a result, our (fictional) &lt;code&gt;WTForms&lt;/code&gt; plugin affects the &lt;code&gt;/contact&lt;/code&gt; route, but does not affect the routes of the &lt;code&gt;/blog&lt;/code&gt; sub-application.</source>
          <target state="translated">每次安装应用程序时，Bottle都会在主应用程序上创建一个代理路由，该代理路由会将所有请求转发到子应用程序。默认情况下，此类代理路由的插件处于禁用状态。因此，我们的（虚构的） &lt;code&gt;WTForms&lt;/code&gt; 插件会影响 &lt;code&gt;/contact&lt;/code&gt; 路由，但不会影响 &lt;code&gt;/blog&lt;/code&gt; 子应用程序的路由。</target>
        </trans-unit>
        <trans-unit id="ef9aeacc0e2ffd83d3cf51e3d47fd25cf3e36e25" translate="yes" xml:space="preserve">
          <source>While some &lt;a href=&quot;api#bottle.Route&quot;&gt;&lt;code&gt;Route&lt;/code&gt;&lt;/a&gt; attributes are mutable, changes may have unwanted effects on other plugins. It is most likely a bad idea to monkey-patch a broken route instead of providing a helpful error message and let the user fix the problem.</source>
          <target state="translated">尽管某些&lt;a href=&quot;api#bottle.Route&quot;&gt; &lt;code&gt;Route&lt;/code&gt; &lt;/a&gt;属性是可变的，但更改可能会对其他插件产生不良影响。猴子修补一条损坏的路由而不是提供有用的错误消息并让用户解决问题，这很可能是个坏主意。</target>
        </trans-unit>
        <trans-unit id="8e3fb6b9dddf2cf75633e30c42b159d65aafe736" translate="yes" xml:space="preserve">
          <source>Whitespace Control</source>
          <target state="translated">空白空间控制</target>
        </trans-unit>
        <trans-unit id="96c654391de847a99d71b1f1d8ca75a4700f1815" translate="yes" xml:space="preserve">
          <source>Wildcard Filters</source>
          <target state="translated">通配符过滤器</target>
        </trans-unit>
        <trans-unit id="5be93facb119814bf7d4753472059b971cb20db6" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#bottle.ConfigDict.load_config&quot;&gt;&lt;code&gt;ConfigDict.load_config()&lt;/code&gt;&lt;/a&gt; you can load these &lt;code&gt;*.ini&lt;/code&gt; style configuration files from disk and import their values into your existing configuration:</source>
          <target state="translated">使用&lt;a href=&quot;#bottle.ConfigDict.load_config&quot;&gt; &lt;code&gt;ConfigDict.load_config()&lt;/code&gt; ,&lt;/a&gt;您可以从磁盘加载这些 &lt;code&gt;*.ini&lt;/code&gt; 样式的配置文件，并将其值导入到现有配置中：</target>
        </trans-unit>
        <trans-unit id="1b68a421231f02f64ea3995f211362e5f098b205" translate="yes" xml:space="preserve">
          <source>With Gevent+WSGI, things are different: First, terminating early has no benefit because we have an unlimited pool of (pseudo)threads to accept new connections. Second, we cannot terminate early because that would close the socket (as required by WSGI). Third, we must return an iterable to conform to WSGI.</source>
          <target state="translated">使用Gevent+WSGI,情况就不同了。首先,提前终止没有好处,因为我们有一个无限的(伪)线程池来接受新的连接。第二,我们不能提前终止,因为那会关闭socket(WSGI要求的)。第三,我们必须返回一个符合WSGI的迭代函数。</target>
        </trans-unit>
        <trans-unit id="3567026868379caf3035d64405a47bc5b649b6d6" translate="yes" xml:space="preserve">
          <source>Wrap a WSGI environ dictionary.</source>
          <target state="translated">包裹一个WSGI环境字典。</target>
        </trans-unit>
        <trans-unit id="4d70b7d412b8cb8bf7af25ca8593ff39f1726cc8" translate="yes" xml:space="preserve">
          <source>Yield (header, value) tuples, skipping headers that are not allowed with the current response status code.</source>
          <target state="translated">产生(头,值)元组,跳过当前响应状态码不允许的头。</target>
        </trans-unit>
        <trans-unit id="3367e80231a6eb7d86ebfd1dc465e52ba240cfd5" translate="yes" xml:space="preserve">
          <source>Yield all Plugins affecting this route.</source>
          <target state="translated">交出所有影响该途径的Plugins。</target>
        </trans-unit>
        <trans-unit id="2b45720ee4c6a4a131c422d4bea90646ba0023e7" translate="yes" xml:space="preserve">
          <source>You already learned the use of the &lt;code&gt;{{...}}&lt;/code&gt; syntax from the &amp;ldquo;Hello World!&amp;rdquo; example above, but there is more: any python expression is allowed within the curly brackets as long as it evaluates to a string or something that has a string representation:</source>
          <target state="translated">您已经从&amp;ldquo; Hello World！&amp;rdquo; 中学到了 &lt;code&gt;{{...}}&lt;/code&gt; 语法的用法。上面的示例，但还有更多示例：大括号内允许使用任何python表达式，只要它的计算结果为字符串或具有字符串表示形式的内容即可：</target>
        </trans-unit>
        <trans-unit id="9801f42108830f674bf2a4281daf051be7ef1fe4" translate="yes" xml:space="preserve">
          <source>You are allowed to use &lt;code&gt;yield&lt;/code&gt; within your callbacks or return an iterable, as long as the iterable yields byte strings, unicode strings, &lt;a href=&quot;api#bottle.HTTPError&quot;&gt;&lt;code&gt;HTTPError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;api#bottle.HTTPResponse&quot;&gt;&lt;code&gt;HTTPResponse&lt;/code&gt;&lt;/a&gt; instances. Nested iterables are not supported, sorry. Please note that the HTTP status code and the headers are sent to the browser as soon as the iterable yields its first non-empty value. Changing these later has no effect.</source>
          <target state="translated">您可以在回调中使用 &lt;code&gt;yield&lt;/code&gt; 或返回一个iterable，只要iterable产生字节字符串，unicode字符串，&lt;a href=&quot;api#bottle.HTTPError&quot;&gt; &lt;code&gt;HTTPError&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;api#bottle.HTTPResponse&quot;&gt; &lt;code&gt;HTTPResponse&lt;/code&gt; &lt;/a&gt;实例即可。不支持嵌套的可迭代对象。请注意，一旦迭代器产生其第一个非空值，HTTP状态代码和标头就会立即发送到浏览器。以后更改这些无效。</target>
        </trans-unit>
        <trans-unit id="bb81d8e3897c19115ef1526fbc3e9ef6046f6a7a" translate="yes" xml:space="preserve">
          <source>You can access the raw body data as a file-like object via &lt;a href=&quot;api#bottle.BaseRequest.body&quot;&gt;&lt;code&gt;BaseRequest.body&lt;/code&gt;&lt;/a&gt;. This is a &lt;code&gt;BytesIO&lt;/code&gt; buffer or a temporary file depending on the content length and &lt;a href=&quot;api#bottle.BaseRequest.MEMFILE_MAX&quot;&gt;&lt;code&gt;BaseRequest.MEMFILE_MAX&lt;/code&gt;&lt;/a&gt; setting. In both cases the body is completely buffered before you can access the attribute. If you expect huge amounts of data and want to get direct unbuffered access to the stream, have a look at &lt;code&gt;request['wsgi.input']&lt;/code&gt;.</source>
          <target state="translated">您可以通过&lt;a href=&quot;api#bottle.BaseRequest.body&quot;&gt; &lt;code&gt;BaseRequest.body&lt;/code&gt; &lt;/a&gt;将原始数据作为文件对象访问。这是一个 &lt;code&gt;BytesIO&lt;/code&gt; 缓冲区或一个临时文件，具体取决于内容长度和&lt;a href=&quot;api#bottle.BaseRequest.MEMFILE_MAX&quot;&gt; &lt;code&gt;BaseRequest.MEMFILE_MAX&lt;/code&gt; &lt;/a&gt;设置。在这两种情况下，在访问属性之前，主体都会被完全缓冲。如果您希望获得大量数据，并且想要直接对流进行无缓冲访问，请查看 &lt;code&gt;request['wsgi.input']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b1cac64bf876c603679d4fc2cc26748f650405c" translate="yes" xml:space="preserve">
          <source>You can add your own filters as well. See &lt;code&gt;Routing&lt;/code&gt; for details.</source>
          <target state="translated">您也可以添加自己的过滤器。有关详细信息，请参见 &lt;code&gt;Routing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad06c1635cdfe02d346a1c61ee2258918ebae6b7" translate="yes" xml:space="preserve">
          <source>You can add your own filters to the router. All you need is a function that returns three elements: A regular expression string, a callable to convert the URL fragment to a python value, and a callable that does the opposite. The filter function is called with the configuration string as the only parameter and may parse it as needed:</source>
          <target state="translated">你可以给路由器添加自己的过滤器。你需要的只是一个返回三个元素的函数。一个正则表达式字符串,一个将URL片段转换为python值的可调用函数,以及一个做相反事情的可调用函数。过滤器函数是以配置字符串作为唯一的参数来调用的,并且可以根据需要对其进行解析。</target>
        </trans-unit>
        <trans-unit id="4347683b60abaedf673f246b544449227495891a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;before_request&lt;/code&gt; to take an action before every function gets called.</source>
          <target state="translated">您还可以使用 &lt;code&gt;before_request&lt;/code&gt; 在调用每个函数之前执行操作。</target>
        </trans-unit>
        <trans-unit id="a7331b9ccce1d761e185da5888df1449e4a03cbf" translate="yes" xml:space="preserve">
          <source>You can change the exact behaviour in many ways using filters. This is described in the next section.</source>
          <target state="translated">您可以使用过滤器以多种方式改变确切的行为。这将在下一节介绍。</target>
        </trans-unit>
        <trans-unit id="59a79f8e2d12804b237c84f6d3867dfa949eabd0" translate="yes" xml:space="preserve">
          <source>You can directly return file objects, but &lt;code&gt;static_file()&lt;/code&gt; is the recommended way to serve static files. It automatically guesses a mime-type, adds a &lt;code&gt;Last-Modified&lt;/code&gt; header, restricts paths to a &lt;code&gt;root&lt;/code&gt; directory for security reasons and generates appropriate error responses (403 on permission errors, 404 on missing files). It even supports the &lt;code&gt;If-Modified-Since&lt;/code&gt; header and eventually generates a &lt;code&gt;304 Not Modified&lt;/code&gt; response. You can pass a custom MIME type to disable guessing.</source>
          <target state="translated">您可以直接返回文件对象，但是建议使用 &lt;code&gt;static_file()&lt;/code&gt; 服务静态文件。它会自动猜测一个mime类型，添加一个 &lt;code&gt;Last-Modified&lt;/code&gt; 头，出于安全原因限制到 &lt;code&gt;root&lt;/code&gt; 目录的路径，并生成适当的错误响应（权限错误为403，丢失文件为404）。它甚至支持 &lt;code&gt;If-Modified-Since&lt;/code&gt; 标头，并最终生成 &lt;code&gt;304 Not Modified&lt;/code&gt; 响应。您可以传递自定义MIME类型以禁用猜测。</target>
        </trans-unit>
        <trans-unit id="c87abbf485356c97335ce7ded90804a56604dc1d" translate="yes" xml:space="preserve">
          <source>You can either manually install Bottle or use Python&amp;rsquo;s easy_install: &lt;code&gt;easy_install bottle&lt;/code&gt;</source>
          <target state="translated">您可以手动安装Bottle或使用Python的easy_install： &lt;code&gt;easy_install bottle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd140198c3ad8e63c55de64dd8e05c5c55d74f72" translate="yes" xml:space="preserve">
          <source>You can raise the return value of &lt;code&gt;static_file()&lt;/code&gt; as an exception if you really need to.</source>
          <target state="translated">如果确实需要，可以提高 &lt;code&gt;static_file()&lt;/code&gt; 的返回值作为异常。</target>
        </trans-unit>
        <trans-unit id="f31d442e9367f700b4f4797349e3fe5570785c6c" translate="yes" xml:space="preserve">
          <source>You can use a name, class or instance to &lt;code&gt;uninstall()&lt;/code&gt; a previously installed plugin:</source>
          <target state="translated">您可以使用名称，类或实例来 &lt;code&gt;uninstall()&lt;/code&gt; 先前安装的插件：</target>
        </trans-unit>
        <trans-unit id="062c73cd0144bf9d7e2706aa1715bfc387267986" translate="yes" xml:space="preserve">
          <source>You can write your own adapter for your favourite template engine or use one of the predefined adapters. Currently there are four fully supported template engines:</source>
          <target state="translated">您可以为您喜欢的模板引擎编写自己的适配器,或者使用预定义的适配器之一。目前有四个完全支持的模板引擎。</target>
        </trans-unit>
        <trans-unit id="f7da89368d068ad3a533aa1b1282cfddd2c0242e" translate="yes" xml:space="preserve">
          <source>You may provide a different HTTP status code as a second parameter.</source>
          <target state="translated">你可以提供一个不同的HTTP状态码作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="45bee7cbf3e2fad4e4323fd6e4dce7eefee440f5" translate="yes" xml:space="preserve">
          <source>You may want to explicitly disable a plugin for a number of routes. The &lt;a href=&quot;api#bottle.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator has a &lt;code&gt;skip&lt;/code&gt; parameter for this purpose:</source>
          <target state="translated">您可能想显式地禁用一些路由的插件。为此，&lt;a href=&quot;api#bottle.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器具有 &lt;code&gt;skip&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="113905791e0533eb2c728fff4f1cf5e9721330af" translate="yes" xml:space="preserve">
          <source>Your own application should use a separate namespace (e.g. &lt;code&gt;myapp.*&lt;/code&gt;).</source>
          <target state="translated">您自己的应用程序应使用单独的名称空间（例如 &lt;code&gt;myapp.*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f203d790d7d6f05e71c17b15d47b244124bc4c6b" translate="yes" xml:space="preserve">
          <source>adding new items to the list: &lt;code&gt;http://localhost:8080/new&lt;/code&gt;</source>
          <target state="translated">向列表中添加新项目： &lt;code&gt;http://localhost:8080/new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75daa03402efdd3a94aa815bc9a2a0e00c19e5d5" translate="yes" xml:space="preserve">
          <source>after_request</source>
          <target state="translated">after_request</target>
        </trans-unit>
        <trans-unit id="811dcdf57af401faec9e044488b7bd46dc4d6b3c" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#bottle.BaseRequest&quot;&gt;&lt;code&gt;BaseRequest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#bottle.BaseRequest&quot;&gt; &lt;code&gt;BaseRequest&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="ef649a1e88ec48ce3dcbbf5c7f0ffc24605d9a0f" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#bottle.BaseResponse&quot;&gt;&lt;code&gt;BaseResponse&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#bottle.BaseResponse&quot;&gt; &lt;code&gt;BaseResponse&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="0491df0f215614fe730c68581d199641b1c16eab" translate="yes" xml:space="preserve">
          <source>and save it in the same path, &lt;code&gt;/var/www/todo&lt;/code&gt;. Actually the name of the file can be anything, as long as the extension is &lt;code&gt;.wsgi&lt;/code&gt;. The name is only used to reference the file from your virtual host.</source>
          <target state="translated">并将其保存在同一路径 &lt;code&gt;/var/www/todo&lt;/code&gt; 中。实际上，文件名可以是任何东西，只要扩展名是 &lt;code&gt;.wsgi&lt;/code&gt; 即可。该名称仅用于引用虚拟主机中的文件。</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="c83f1f5829ef91e20b92b78798a2c99b3393b74b" translate="yes" xml:space="preserve">
          <source>app()</source>
          <target state="translated">app()</target>
        </trans-unit>
        <trans-unit id="fe82155bae28116971fc85490bc175257aac7ad6" translate="yes" xml:space="preserve">
          <source>app_reset</source>
          <target state="translated">app_reset</target>
        </trans-unit>
        <trans-unit id="0d612c12d2ac33625bf3e0351b6f5e4f73829fa8" translate="yes" xml:space="preserve">
          <source>auto</source>
          <target state="translated">auto</target>
        </trans-unit>
        <trans-unit id="7aadf8fdfc1ef2331a37f98413e6de9feb8093e8" translate="yes" xml:space="preserve">
          <source>before_request</source>
          <target state="translated">before_request</target>
        </trans-unit>
        <trans-unit id="a31805f6001ab3b535ea95133fbc4db46e97e8d1" translate="yes" xml:space="preserve">
          <source>bjoern</source>
          <target state="translated">bjoern</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="a4acdb3ad6a28f9d09b7623b333da8fa63249da7" translate="yes" xml:space="preserve">
          <source>catching errors</source>
          <target state="translated">抓错</target>
        </trans-unit>
        <trans-unit id="27b4d0f8ee1e61a07904f1afd558aa878973f2d1" translate="yes" xml:space="preserve">
          <source>cgi</source>
          <target state="translated">cgi</target>
        </trans-unit>
        <trans-unit id="57ed5d98cce71967d508cb785aa76d2c23894347" translate="yes" xml:space="preserve">
          <source>cherrypy</source>
          <target state="translated">cherrypy</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="24e8dc3172f56a9e62b2ac2c68ed550fd5db6e93" translate="yes" xml:space="preserve">
          <source>cookie_decode()</source>
          <target state="translated">cookie_decode()</target>
        </trans-unit>
        <trans-unit id="a094e29fa8eac27d40d318b2fc75490bf222c3cd" translate="yes" xml:space="preserve">
          <source>cookie_encode()</source>
          <target state="translated">cookie_encode()</target>
        </trans-unit>
        <trans-unit id="20b325df9fa3c34d9daec04a11f56ed393cb7202" translate="yes" xml:space="preserve">
          <source>cookie_is_encoded()</source>
          <target state="translated">cookie_is_encoded()</target>
        </trans-unit>
        <trans-unit id="7c7594cc6b050fbac7c5b12fa905411430e20a9a" translate="yes" xml:space="preserve">
          <source>debug()</source>
          <target state="translated">debug()</target>
        </trans-unit>
        <trans-unit id="b56ad4352ac64195dfdeec746afce440701027d2" translate="yes" xml:space="preserve">
          <source>defined()</source>
          <target state="translated">defined()</target>
        </trans-unit>
        <trans-unit id="90cf16d678e8c6f00804f1cd5f9f0e7757b13993" translate="yes" xml:space="preserve">
          <source>diesel</source>
          <target state="translated">diesel</target>
        </trans-unit>
        <trans-unit id="aca90d914519fdb9825352bdc0befb59f7c8510f" translate="yes" xml:space="preserve">
          <source>error()</source>
          <target state="translated">error()</target>
        </trans-unit>
        <trans-unit id="3ed8ea22373854abc813c27b8d1f6e7a98520a4e" translate="yes" xml:space="preserve">
          <source>eventlet</source>
          <target state="translated">eventlet</target>
        </trans-unit>
        <trans-unit id="964cf2c901a58b9600a46d04a32803f6773e34c8" translate="yes" xml:space="preserve">
          <source>fapws3</source>
          <target state="translated">fapws3</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="8664b63657e9106f87a107be2e3b45d4b4b6cc3e" translate="yes" xml:space="preserve">
          <source>flash plugin for bottle</source>
          <target state="translated">瓶子的Flash插件</target>
        </trans-unit>
        <trans-unit id="3a54c11c850942da9140a2261750d98fbd429fdc" translate="yes" xml:space="preserve">
          <source>flup</source>
          <target state="translated">flup</target>
        </trans-unit>
        <trans-unit id="b2e27618bb92ea5fd1493f8dd503add0447f61a8" translate="yes" xml:space="preserve">
          <source>gae</source>
          <target state="translated">gae</target>
        </trans-unit>
        <trans-unit id="4a79533a2233d37071096ed5d29c1e9ac6cf66e6" translate="yes" xml:space="preserve">
          <source>get()</source>
          <target state="translated">get()</target>
        </trans-unit>
        <trans-unit id="de9dd9562653655041cf7a809fcfb2178e4ec60e" translate="yes" xml:space="preserve">
          <source>gevent</source>
          <target state="translated">gevent</target>
        </trans-unit>
        <trans-unit id="4dda27ec95a2c51a1bbfd235143a0adc4f51cf60" translate="yes" xml:space="preserve">
          <source>gunicorn</source>
          <target state="translated">gunicorn</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">help</target>
        </trans-unit>
        <trans-unit id="86c2d513f250be3984b3ac5733cf9c5b817cc800" translate="yes" xml:space="preserve">
          <source>include()</source>
          <target state="translated">include()</target>
        </trans-unit>
        <trans-unit id="94ea5f589396df68c37d6c28efac0a817a2fa0ce" translate="yes" xml:space="preserve">
          <source>load()</source>
          <target state="translated">load()</target>
        </trans-unit>
        <trans-unit id="ab6e3f06196d3579bdd29c145de0cdea113a7fd5" translate="yes" xml:space="preserve">
          <source>load_app()</source>
          <target state="translated">load_app()</target>
        </trans-unit>
        <trans-unit id="290ce43e9a82bd37c70bbd6bbb41c5a61d85bb2c" translate="yes" xml:space="preserve">
          <source>meinheld</source>
          <target state="translated">meinheld</target>
        </trans-unit>
        <trans-unit id="bfbaf8b2d1cdf92bf83857fe1748c0f68de03d47" translate="yes" xml:space="preserve">
          <source>method</source>
          <target state="translated">method</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="818d90713dc54fe481a6c0ab7fc2c2a9cb6547c1" translate="yes" xml:space="preserve">
          <source>or add a WSGI middleware that strips trailing slashes from all URLs:</source>
          <target state="translated">或者添加一个WSGI中间件,从所有的URL中去掉尾部的斜杠。</target>
        </trans-unit>
        <trans-unit id="0bd88fa7e3b742c4023df1cc0e90291ee25cbca8" translate="yes" xml:space="preserve">
          <source>page for editing items: &lt;code&gt;http://localhost:8080/edit/:no&lt;/code&gt;</source>
          <target state="translated">用于编辑项目的页面： &lt;code&gt;http://localhost:8080/edit/:no&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deb866148d8d30519a465f3b1d65213af906ce8b" translate="yes" xml:space="preserve">
          <source>parse_auth()</source>
          <target state="translated">parse_auth()</target>
        </trans-unit>
        <trans-unit id="54fdb1a9720f3519a2d2affe6d7a5d3abbef3dad" translate="yes" xml:space="preserve">
          <source>parse_date()</source>
          <target state="translated">parse_date()</target>
        </trans-unit>
        <trans-unit id="43bce7a87dd0e4b8c09b44173613bc95ba77d714" translate="yes" xml:space="preserve">
          <source>paste</source>
          <target state="translated">paste</target>
        </trans-unit>
        <trans-unit id="95c4e181abf64b5e936c498d2c43ab32726b8470" translate="yes" xml:space="preserve">
          <source>path_shift()</source>
          <target state="translated">path_shift()</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="2d6f7ac901e5d04c6371875e27569749eefe8567" translate="yes" xml:space="preserve">
          <source>rebase()</source>
          <target state="translated">rebase()</target>
        </trans-unit>
        <trans-unit id="14bdaf2c878209d944d81a54d773db2719f0113c" translate="yes" xml:space="preserve">
          <source>return a dict of template vars to fill out the template</source>
          <target state="translated">返回一个模板变量的dict,用于填写模板。</target>
        </trans-unit>
        <trans-unit id="6012a6e6d35d6ba43ee41dc4cc717f61b24c45cd" translate="yes" xml:space="preserve">
          <source>return something other than a dict and the view decorator will not process the template, but return the handler result as is. This includes returning a HTTPResponse(dict) to get, for instance, JSON with autojson or other castfilters.</source>
          <target state="translated">返回dict以外的东西,视图装饰器将不会处理模板,而是原样返回处理结果。这包括返回一个HTTPResponse(dict)来获取,例如,带有autojson或其他castfilters的JSON。</target>
        </trans-unit>
        <trans-unit id="ef89a3a842b0384565a210f0122804f411fe51fb" translate="yes" xml:space="preserve">
          <source>rocket</source>
          <target state="translated">rocket</target>
        </trans-unit>
        <trans-unit id="88e8b45994b813eb69a17874d0858982a9387f86" translate="yes" xml:space="preserve">
          <source>route()</source>
          <target state="translated">route()</target>
        </trans-unit>
        <trans-unit id="0f400122e37da3a462df347caac2be31d74be730" translate="yes" xml:space="preserve">
          <source>rule</source>
          <target state="translated">rule</target>
        </trans-unit>
        <trans-unit id="f805aaf52532959faf0be97c80abde3c8ae5e849" translate="yes" xml:space="preserve">
          <source>run()</source>
          <target state="translated">run()</target>
        </trans-unit>
        <trans-unit id="186e7e139d002714805331e77d5e7a3112f55f90" translate="yes" xml:space="preserve">
          <source>setdefault()</source>
          <target state="translated">setdefault()</target>
        </trans-unit>
        <trans-unit id="abd0c274ede56d5c6f17be89ad32e3054098fad0" translate="yes" xml:space="preserve">
          <source>skiplist</source>
          <target state="translated">skiplist</target>
        </trans-unit>
        <trans-unit id="1e5705665c28bfaa038e11d9138cd855a8d25b6b" translate="yes" xml:space="preserve">
          <source>so bottle searches the right paths.</source>
          <target state="translated">所以瓶子搜索正确的路径。</target>
        </trans-unit>
        <trans-unit id="9a4ac62ca9d7db8c777de3e3f6f52a29156cc782" translate="yes" xml:space="preserve">
          <source>start page &lt;code&gt;http://localhost:8080/todo&lt;/code&gt;</source>
          <target state="translated">起始页 &lt;code&gt;http://localhost:8080/todo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bef18596fd84c20a131098dcb6f2778a4db20a7" translate="yes" xml:space="preserve">
          <source>template()</source>
          <target state="translated">template()</target>
        </trans-unit>
        <trans-unit id="474446ad24ee5490f8e879012ee2a855a7c7bf56" translate="yes" xml:space="preserve">
          <source>tornado</source>
          <target state="translated">tornado</target>
        </trans-unit>
        <trans-unit id="986f16f209e651c1a0f22c4010f329b8079f7fa4" translate="yes" xml:space="preserve">
          <source>twisted</source>
          <target state="translated">twisted</target>
        </trans-unit>
        <trans-unit id="e9accc21bb6501091860b4b6959780198f8935f0" translate="yes" xml:space="preserve">
          <source>validating data assigned by dynamic routes with the @validate decorator</source>
          <target state="translated">使用@validate decorator验证动态路由分配的数据。</target>
        </trans-unit>
        <trans-unit id="145313cb43507ac1c8d47fc8da314899ad73fdd3" translate="yes" xml:space="preserve">
          <source>vice versa.</source>
          <target state="translated">反之亦然</target>
        </trans-unit>
        <trans-unit id="2540eae99824b579af30b949d544a727b977425b" translate="yes" xml:space="preserve">
          <source>view()</source>
          <target state="translated">view()</target>
        </trans-unit>
        <trans-unit id="1aed88e4a7e5cd305f613756678093e95c870924" translate="yes" xml:space="preserve">
          <source>waitress</source>
          <target state="translated">waitress</target>
        </trans-unit>
        <trans-unit id="6f29a29af63cb79cb0e113c9d4d7ed052368552d" translate="yes" xml:space="preserve">
          <source>will work fine, too. What will not work is to bind one route to more than one function.</source>
          <target state="translated">也能正常工作。不可行的是将一个路由绑定到多个函数上。</target>
        </trans-unit>
        <trans-unit id="242a44ec7e29dc38038e17cb7f27abfebbb92fc4" translate="yes" xml:space="preserve">
          <source>works fine, the following one as well:</source>
          <target state="translated">工作正常,下面的也是。</target>
        </trans-unit>
        <trans-unit id="d1bb0af006484d47426b8626c8a83e7dec230345" translate="yes" xml:space="preserve">
          <source>would make Bottle listen to port 80.</source>
          <target state="translated">会让Bottle监听80端口。</target>
        </trans-unit>
        <trans-unit id="dc7b0ed7576dd4d42b349ceea389f65b16acabe2" translate="yes" xml:space="preserve">
          <source>wsgiref</source>
          <target state="translated">wsgiref</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="264f54d9f052a761c88f49edbe69d1315ae11ac7" translate="yes" xml:space="preserve">
          <source>yieldroutes()</source>
          <target state="translated">yieldroutes()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
