<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3a21eefa10a38bebd685a041bc883db13a690f78" translate="yes" xml:space="preserve">
          <source>A sparse keymap used by buttons.</source>
          <target state="translated">一个由按钮使用的稀疏键图。</target>
        </trans-unit>
        <trans-unit id="7a6d924c29a314704225148c6f1e8e4dd9598ef6" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for responses in &lt;code&gt;query-replace&lt;/code&gt; and related commands; also for &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;map-y-or-n-p&lt;/code&gt;. The functions that use this map do not support prefix keys; they look up one event at a time. &lt;code&gt;multi-query-replace-map&lt;/code&gt; extends &lt;code&gt;query-replace-map&lt;/code&gt; for multi-buffer replacements. See &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map&lt;/a&gt;.</source>
          <target state="translated">A sparse keymap used for responses in &lt;code&gt;query-replace&lt;/code&gt; and related commands; also for &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;map-y-or-n-p&lt;/code&gt; . The functions that use this map do not support prefix keys; they look up one event at a time. &lt;code&gt;multi-query-replace-map&lt;/code&gt; extends &lt;code&gt;query-replace-map&lt;/code&gt; for multi-buffer replacements. See &lt;a href=&quot;search-and-replace#Search-and-Replace&quot;&gt;query-replace-map&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2273ae4dbb377e2aa911010dd8b2da0b64c40b7c" translate="yes" xml:space="preserve">
          <source>A sparse keymap used for the</source>
          <target state="translated">稀疏键图用于</target>
        </trans-unit>
        <trans-unit id="7144fe372d5198217578856f61ea2cf40f8209ff" translate="yes" xml:space="preserve">
          <source>A sparse keymap used to map certain keys under graphical frames. The function &lt;code&gt;x-setup-function-keys&lt;/code&gt; uses this.</source>
          <target state="translated">A sparse keymap used to map certain keys under graphical frames. The function &lt;code&gt;x-setup-function-keys&lt;/code&gt; uses this.</target>
        </trans-unit>
        <trans-unit id="88e891a88be3fe4e62330f9bb2210843e83520a9" translate="yes" xml:space="preserve">
          <source>A sparse keymap used while processing</source>
          <target state="translated">处理时使用的稀疏键图</target>
        </trans-unit>
        <trans-unit id="765649c4f2ad56ec8ad2f598cca04c9ff7b7da2a" translate="yes" xml:space="preserve">
          <source>A sparse keymap useful for buffers containing buffers. You may want to use this as a parent keymap. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;.</source>
          <target state="translated">A sparse keymap useful for buffers containing buffers. You may want to use this as a parent keymap. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5f4ac56519c11e0fe0577b1cad8ce3bbe4207fc9" translate="yes" xml:space="preserve">
          <source>A special feature allows you to specify expressions to evaluate if and when a file is loaded (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). That feature is not exactly a hook, but does a similar job.</source>
          <target state="translated">A special feature allows you to specify expressions to evaluate if and when a file is loaded (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). That feature is not exactly a hook, but does a similar job.</target>
        </trans-unit>
        <trans-unit id="5be02abf64fa9f6d03c8545ca5b0ef5253cf8321" translate="yes" xml:space="preserve">
          <source>A special kind of key binding can be used to &lt;em&gt;remap&lt;/em&gt; one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event &lt;code&gt;remap&lt;/code&gt;, followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).</source>
          <target state="translated">A special kind of key binding can be used to &lt;em&gt;remap&lt;/em&gt; one command to another, without having to refer to the key sequence(s) bound to the original command. To use this feature, make a key binding for a key sequence that starts with the dummy event &lt;code&gt;remap&lt;/code&gt; , followed by the command name you want to remap; for the binding, specify the new definition (usually a command name, but possibly any other valid definition for a key binding).</target>
        </trans-unit>
        <trans-unit id="b3b13190b49396edf46334298af39e2a2e3045a9" translate="yes" xml:space="preserve">
          <source>A specially constructed list.</source>
          <target state="translated">一个专门构建的清单。</target>
        </trans-unit>
        <trans-unit id="cdeb8b40b772b9f3c7e2c98e3c8b8dec4698471b" translate="yes" xml:space="preserve">
          <source>A specification can have a &lt;em&gt;width&lt;/em&gt;, which is a decimal number that appears after any field number and flags. If the printed representation of the object contains fewer characters than this width, &lt;code&gt;format&lt;/code&gt; extends it with padding. Any padding introduced by the width normally consists of spaces inserted on the left:</source>
          <target state="translated">A specification can have a &lt;em&gt;width&lt;/em&gt;, which is a decimal number that appears after any field number and flags. If the printed representation of the object contains fewer characters than this width, &lt;code&gt;format&lt;/code&gt; extends it with padding. Any padding introduced by the width normally consists of spaces inserted on the left:</target>
        </trans-unit>
        <trans-unit id="fffe787c50a5092035410b47c5d5ac737f027fa9" translate="yes" xml:space="preserve">
          <source>A specification list may contain sublists, which match arguments that are themselves lists, or it may contain vectors used for grouping. Sublists and groups thus subdivide the specification list into a hierarchy of levels. Specification keywords apply only to the remainder of the sublist or group they are contained in.</source>
          <target state="translated">一个规格列表可以包含子列表,这些子列表与本身就是列表的参数相匹配,也可以包含用于分组的向量。因此,子列表和分组将规范列表细分为一个层次结构。规格关键字只适用于它们所包含的子列表或组的其余部分。</target>
        </trans-unit>
        <trans-unit id="9468aabf9aff18dfe4927c4df0cf6ef94a873fcf" translate="yes" xml:space="preserve">
          <source>A string as a mode line construct appears verbatim except for &lt;em&gt;&lt;code&gt;%&lt;/code&gt;-constructs&lt;/em&gt; in it. These stand for substitution of other data; see &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;%-Constructs&lt;/a&gt;.</source>
          <target state="translated">A string as a mode line construct appears verbatim except for &lt;em&gt; &lt;code&gt;%&lt;/code&gt; -constructs&lt;/em&gt; in it. These stand for substitution of other data; see &lt;a href=&quot;_0025_002dconstructs#g_t_0025_002dConstructs&quot;&gt;%-Constructs&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2532fec68eb63f66911855847dedf967f8f81556" translate="yes" xml:space="preserve">
          <source>A string as input will be used directly. It may be modified by the function (unlike most other Emacs Lisp functions) to reduce the chance of exposing sensitive data after the function does its work.</source>
          <target state="translated">将直接使用一个字符串作为输入。它可能会被函数修改(与大多数其他Emacs Lisp函数不同),以减少在函数工作后暴露敏感数据的机会。</target>
        </trans-unit>
        <trans-unit id="a8bebc2f246c21ea650e3cb3ac8fe99ed1f62459" translate="yes" xml:space="preserve">
          <source>A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text&amp;rsquo;s properties with no special effort. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:</source>
          <target state="translated">A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text&amp;rsquo;s properties with no special effort. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:</target>
        </trans-unit>
        <trans-unit id="dfef331cf99173b597cb3a4f9ebbdb7c1f294c0a" translate="yes" xml:space="preserve">
          <source>A string containing the same byte sequence as an XBM file would contain. You must not specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; in this case, because omitting them is what indicates the data has the format of an XBM file. The file contents specify the height and width of the image.</source>
          <target state="translated">A string containing the same byte sequence as an XBM file would contain. You must not specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; in this case, because omitting them is what indicates the data has the format of an XBM file. The file contents specify the height and width of the image.</target>
        </trans-unit>
        <trans-unit id="b80138eb0e7d2ee11a5334072539786172a5e2bd" translate="yes" xml:space="preserve">
          <source>A string displayed by the Emacs tooltip help system; by default, &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt;. Alternatively, a function that returns, or a form that evaluates to, a string to be displayed or &lt;code&gt;nil&lt;/code&gt;. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">A string displayed by the Emacs tooltip help system; by default, &lt;code&gt;&quot;mouse-2, RET: Push this button&quot;&lt;/code&gt; . Alternatively, a function that returns, or a form that evaluates to, a string to be displayed or &lt;code&gt;nil&lt;/code&gt; . For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7e28e179ae46e636da2eca587a2ddde99c5d0cd9" translate="yes" xml:space="preserve">
          <source>A string in Emacs Lisp is an array that contains an ordered sequence of characters. Strings are used as names of symbols, buffers, and files; to send messages to users; to hold text being copied between buffers; and for many other purposes. Because strings are so important, Emacs Lisp has many functions expressly for manipulating them. Emacs Lisp programs use strings more often than individual characters.</source>
          <target state="translated">在Emacs Lisp中,字符串是一个包含有序字符序列的数组。字符串被用来作为符号、缓冲区和文件的名称;用来向用户发送消息;用来保存缓冲区之间复制的文本;以及其他许多用途。由于字符串如此重要,Emacs Lisp有许多函数专门用于操作它们。Emacs Lisp程序使用字符串比使用单个字符更频繁。</target>
        </trans-unit>
        <trans-unit id="97d89176884a6777ab0a93f14e9b3cf203593d01" translate="yes" xml:space="preserve">
          <source>A string is a fixed sequence of characters. It is a type of sequence called a &lt;em&gt;array&lt;/em&gt;, meaning that its length is fixed and cannot be altered once it is created (see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;). Unlike in C, Emacs Lisp strings are &lt;em&gt;not&lt;/em&gt; terminated by a distinguished character code.</source>
          <target state="translated">A string is a fixed sequence of characters. It is a type of sequence called a &lt;em&gt;array&lt;/em&gt;, meaning that its length is fixed and cannot be altered once it is created (see &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;). Unlike in C, Emacs Lisp strings are &lt;em&gt;not&lt;/em&gt; terminated by a distinguished character code.</target>
        </trans-unit>
        <trans-unit id="fe9aa772c2d97bd3d2707cc2379051eb1e145422" translate="yes" xml:space="preserve">
          <source>A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. These kinds of array may have any length up to the largest fixnum, subject to system architecture limits and available memory. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.</source>
          <target state="translated">A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; . These kinds of array may have any length up to the largest fixnum, subject to system architecture limits and available memory. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.</target>
        </trans-unit>
        <trans-unit id="2441898090949c6885e0d3b806fb9b48c4944a10" translate="yes" xml:space="preserve">
          <source>A string is text saved in the register.</source>
          <target state="translated">字符串是保存在寄存器中的文本。</target>
        </trans-unit>
        <trans-unit id="49f6b3f288e48e7a1e61f7ccbc7a20aa90fb1620" translate="yes" xml:space="preserve">
          <source>A string or a bool-vector containing the bits of the image (plus perhaps some extra bits at the end that will not be used). It should contain at least &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; bits, where &lt;var&gt;stride&lt;/var&gt; is the smallest multiple of 8 greater than or equal to the width of the image. In this case, you should specify &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:stride&lt;/code&gt;, both to indicate that the string contains just the bits rather than a whole XBM file, and to specify the size of the image.</source>
          <target state="translated">A string or a bool-vector containing the bits of the image (plus perhaps some extra bits at the end that will not be used). It should contain at least &lt;code&gt;&lt;var&gt;stride&lt;/var&gt;&amp;nbsp;*&amp;nbsp;&lt;var&gt;height&lt;/var&gt;&lt;/code&gt; bits, where &lt;var&gt;stride&lt;/var&gt; is the smallest multiple of 8 greater than or equal to the width of the image. In this case, you should specify &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:stride&lt;/code&gt; , both to indicate that the string contains just the bits rather than a whole XBM file, and to specify the size of the image.</target>
        </trans-unit>
        <trans-unit id="036a59e22e9f954ee65be3ccd2c0ddd139f906a5" translate="yes" xml:space="preserve">
          <source>A string or vector as &lt;var&gt;command&lt;/var&gt; is executed with &lt;code&gt;execute-kbd-macro&lt;/code&gt;. A function is passed to &lt;code&gt;call-interactively&lt;/code&gt; (see above), along with the &lt;var&gt;record-flag&lt;/var&gt; and &lt;var&gt;keys&lt;/var&gt; arguments.</source>
          <target state="translated">A string or vector as &lt;var&gt;command&lt;/var&gt; is executed with &lt;code&gt;execute-kbd-macro&lt;/code&gt; . A function is passed to &lt;code&gt;call-interactively&lt;/code&gt; (see above), along with the &lt;var&gt;record-flag&lt;/var&gt; and &lt;var&gt;keys&lt;/var&gt; arguments.</target>
        </trans-unit>
        <trans-unit id="fb505d9a7d4b3f1a25ce86b9d3dae98375c606b2" translate="yes" xml:space="preserve">
          <source>A string starting with two or more dashes specifies a separator line; see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;.</source>
          <target state="translated">A string starting with two or more dashes specifies a separator line; see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="45afeec22e5b1392a38afb3af0c622aa891ec190" translate="yes" xml:space="preserve">
          <source>A string that gives the repository branch from which Emacs was built. In the most cases this is &lt;code&gt;&quot;master&quot;&lt;/code&gt;. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">A string that gives the repository branch from which Emacs was built. In the most cases this is &lt;code&gt;&quot;master&quot;&lt;/code&gt; . If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a176c29cb00e1ce1efdc8fd4de377dd60ec1aa7c" translate="yes" xml:space="preserve">
          <source>A string that gives the repository revision from which Emacs was built. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">A string that gives the repository revision from which Emacs was built. If Emacs was built outside revision control, the value is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c2c310a05a2e4299069228d4059ebe12c87d4e" translate="yes" xml:space="preserve">
          <source>A string that is the name of the process&amp;rsquo;s controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as</source>
          <target state="translated">A string that is the name of the process&amp;rsquo;s controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as</target>
        </trans-unit>
        <trans-unit id="a07b76952ae2e1b9491a1beda81ccc1a2fb843d7" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor is in this window.</source>
          <target state="translated">一个描述光标在这个窗口中的位置的结构。</target>
        </trans-unit>
        <trans-unit id="20ca76b446ea261daca0ab9858048669216bed62" translate="yes" xml:space="preserve">
          <source>A structure describing where the cursor of this window physically is.</source>
          <target state="translated">描述这个窗口的光标物理位置的结构。</target>
        </trans-unit>
        <trans-unit id="283fbe00ae8cce4ea280dfbb7b15b846c6c4c692" translate="yes" xml:space="preserve">
          <source>A sublist specification may be a dotted list and the corresponding list argument may then be a dotted list. Alternatively, the last &lt;small&gt;CDR&lt;/small&gt; of a dotted list specification may be another sublist specification (via a grouping or an indirect specification, e.g., &lt;code&gt;(spec .  [(more
specs&amp;hellip;)])&lt;/code&gt;) whose elements match the non-dotted list arguments. This is useful in recursive specifications such as in the backquote example. Also see the description of a &lt;code&gt;nil&lt;/code&gt; specification above for terminating such recursion.</source>
          <target state="translated">A sublist specification may be a dotted list and the corresponding list argument may then be a dotted list. Alternatively, the last &lt;small&gt;CDR&lt;/small&gt; of a dotted list specification may be another sublist specification (via a grouping or an indirect specification, e.g., &lt;code&gt;(spec . [(more specs&amp;hellip;)])&lt;/code&gt; ) whose elements match the non-dotted list arguments. This is useful in recursive specifications such as in the backquote example. Also see the description of a &lt;code&gt;nil&lt;/code&gt; specification above for terminating such recursion.</target>
        </trans-unit>
        <trans-unit id="e6bd63f0d6eed94cca2c1d7fa955eac6382d7a76" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs may be &lt;em&gt;synchronous&lt;/em&gt; or &lt;em&gt;asynchronous&lt;/em&gt;, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a &amp;ldquo;process&amp;rdquo;. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</source>
          <target state="translated">A subprocess of Emacs may be &lt;em&gt;synchronous&lt;/em&gt; or &lt;em&gt;asynchronous&lt;/em&gt;, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a &amp;ldquo;process&amp;rdquo;. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</target>
        </trans-unit>
        <trans-unit id="087de830e58dec95d6c61960121c78d539705185" translate="yes" xml:space="preserve">
          <source>A subprocess of Emacs running on the underlying OS.</source>
          <target state="translated">运行在底层操作系统上的Emacs子进程。</target>
        </trans-unit>
        <trans-unit id="35507e345942623bfb6aa6be63bdded05b6c5918" translate="yes" xml:space="preserve">
          <source>A suitable kind of &lt;code&gt;file-error&lt;/code&gt; error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)</source>
          <target state="translated">A suitable kind of &lt;code&gt;file-error&lt;/code&gt; error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)</target>
        </trans-unit>
        <trans-unit id="58e5791b58ed962f6049e196b317aabc08f3c119" translate="yes" xml:space="preserve">
          <source>A symbol as a mode line construct stands for its value. The value of &lt;var&gt;symbol&lt;/var&gt; is used as a mode line construct, in place of &lt;var&gt;symbol&lt;/var&gt;. However, the symbols &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; are ignored, as is any symbol whose value is void.</source>
          <target state="translated">A symbol as a mode line construct stands for its value. The value of &lt;var&gt;symbol&lt;/var&gt; is used as a mode line construct, in place of &lt;var&gt;symbol&lt;/var&gt; . However, the symbols &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; are ignored, as is any symbol whose value is void.</target>
        </trans-unit>
        <trans-unit id="136dfe6f1f6290980b0a544df03bc8031bada37f" translate="yes" xml:space="preserve">
          <source>A symbol as input stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">A symbol as input stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</target>
        </trans-unit>
        <trans-unit id="11075144c8ce3c1e072d1e5adaac43cdc6ed22f8" translate="yes" xml:space="preserve">
          <source>A symbol as output stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</source>
          <target state="translated">A symbol as output stream is equivalent to the symbol&amp;rsquo;s function definition (if any).</target>
        </trans-unit>
        <trans-unit id="bce876b9cd2acba081d2ad07d0fc80b3afe79b3c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.</source>
          <target state="translated">符号可以作为一个变量,作为一个函数名,或者用来存放一个属性列表。或者,它可能只是为了与所有其他Lisp对象区分开来,以便在数据结构中能够可靠地识别它的存在。在一个给定的上下文中,通常只打算使用其中的一种。但你可以将一个符号独立地用于所有这些用途。</target>
        </trans-unit>
        <trans-unit id="1b40c765dfb974c4520f948565e6ea3abebbf26c" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function.</source>
          <target state="translated">符号可以作为函数的名称。</target>
        </trans-unit>
        <trans-unit id="2522095758f15f287bcb68febcef4a1aef3c93ca" translate="yes" xml:space="preserve">
          <source>A symbol can serve as the name of a function. This happens when the symbol&amp;rsquo;s &lt;em&gt;function cell&lt;/em&gt; (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.</source>
          <target state="translated">A symbol can serve as the name of a function. This happens when the symbol&amp;rsquo;s &lt;em&gt;function cell&lt;/em&gt; (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.</target>
        </trans-unit>
        <trans-unit id="dc66ecbc9c4221d50048e15206869a3b042473a6" translate="yes" xml:space="preserve">
          <source>A symbol is a function to compute the height. It is called with the current height as argument, and should return the new height to use.</source>
          <target state="translated">符号是一个计算高度的函数。它以当前的高度作为参数被调用,并应返回新的高度来使用。</target>
        </trans-unit>
        <trans-unit id="1735c25eacfa5dbfa81d50d3791a7b3948064021" translate="yes" xml:space="preserve">
          <source>A symbol may possess any number of &lt;em&gt;symbol properties&lt;/em&gt;, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a &lt;code&gt;risky-local-variable&lt;/code&gt; property with a non-&lt;code&gt;nil&lt;/code&gt; value, that means the variable which the symbol names is a risky file-local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">A symbol may possess any number of &lt;em&gt;symbol properties&lt;/em&gt;, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a &lt;code&gt;risky-local-variable&lt;/code&gt; property with a non- &lt;code&gt;nil&lt;/code&gt; value, that means the variable which the symbol names is a risky file-local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="4af456786cdb930cf51a2fe8cb251937c0f92f76" translate="yes" xml:space="preserve">
          <source>A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters &amp;lsquo;</source>
          <target state="translated">A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="c152fe70962941670ef3592324bbdb47115752ec" translate="yes" xml:space="preserve">
          <source>A symbol whose name starts with a colon (&amp;lsquo;</source>
          <target state="translated">A symbol whose name starts with a colon (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3728c8c2eb3343e2a05d9141c3b791e811332750" translate="yes" xml:space="preserve">
          <source>A symbol. In other words, &lt;code&gt;(setf x y)&lt;/code&gt; is exactly equivalent to &lt;code&gt;(setq x y)&lt;/code&gt;, and &lt;code&gt;setq&lt;/code&gt; itself is strictly speaking redundant given that &lt;code&gt;setf&lt;/code&gt; exists. Most programmers will continue to prefer &lt;code&gt;setq&lt;/code&gt; for setting simple variables, though, for stylistic and historical reasons. The macro &lt;code&gt;(setf x y)&lt;/code&gt; actually expands to &lt;code&gt;(setq x y)&lt;/code&gt;, so there is no performance penalty for using it in compiled code.</source>
          <target state="translated">A symbol. In other words, &lt;code&gt;(setf x y)&lt;/code&gt; is exactly equivalent to &lt;code&gt;(setq x y)&lt;/code&gt; , and &lt;code&gt;setq&lt;/code&gt; itself is strictly speaking redundant given that &lt;code&gt;setf&lt;/code&gt; exists. Most programmers will continue to prefer &lt;code&gt;setq&lt;/code&gt; for setting simple variables, though, for stylistic and historical reasons. The macro &lt;code&gt;(setf x y)&lt;/code&gt; actually expands to &lt;code&gt;(setq x y)&lt;/code&gt; , so there is no performance penalty for using it in compiled code.</target>
        </trans-unit>
        <trans-unit id="1954d27d0637fd3ddd907ebc88c0499752335e55" translate="yes" xml:space="preserve">
          <source>A syntax table can &lt;em&gt;inherit&lt;/em&gt; from another syntax table, which is called its &lt;em&gt;parent syntax table&lt;/em&gt;. A syntax table can leave the syntax class of some characters unspecified, by giving them the &amp;ldquo;inherit&amp;rdquo; syntax class; such a character then acquires the syntax class specified by the parent syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;). Emacs defines a &lt;em&gt;standard syntax table&lt;/em&gt;, which is the default parent syntax table, and is also the syntax table used by Fundamental mode.</source>
          <target state="translated">A syntax table can &lt;em&gt;inherit&lt;/em&gt; from another syntax table, which is called its &lt;em&gt;parent syntax table&lt;/em&gt;. A syntax table can leave the syntax class of some characters unspecified, by giving them the &amp;ldquo;inherit&amp;rdquo; syntax class; such a character then acquires the syntax class specified by the parent syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;). Emacs defines a &lt;em&gt;standard syntax table&lt;/em&gt;, which is the default parent syntax table, and is also the syntax table used by Fundamental mode.</target>
        </trans-unit>
        <trans-unit id="b659b2d3d03e0d7773e900b73de02d70d5ddcd88" translate="yes" xml:space="preserve">
          <source>A syntax table is a data structure which can be used to look up the &lt;em&gt;syntax class&lt;/em&gt; and other syntactic properties of each character. Syntax tables are used by Lisp programs for scanning and moving across text.</source>
          <target state="translated">A syntax table is a data structure which can be used to look up the &lt;em&gt;syntax class&lt;/em&gt; and other syntactic properties of each character. Syntax tables are used by Lisp programs for scanning and moving across text.</target>
        </trans-unit>
        <trans-unit id="611cab9bf171d524f8bb167ff2d975371afdf4c3" translate="yes" xml:space="preserve">
          <source>A terminal device displays frames.</source>
          <target state="translated">终端设备显示帧。</target>
        </trans-unit>
        <trans-unit id="154579a3c3d7f8dbf4dedff1e12b0784abbfebd3" translate="yes" xml:space="preserve">
          <source>A themable named sound from the freedesktop.org sound naming specification from &amp;lsquo;</source>
          <target state="translated">A themable named sound from the freedesktop.org sound naming specification from &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="26c5fb26d2d40b902e4464e332d9e274ac27ae65" translate="yes" xml:space="preserve">
          <source>A thread of Emacs Lisp execution.</source>
          <target state="translated">一个Emacs Lisp的执行线程。</target>
        </trans-unit>
        <trans-unit id="57dfda42a48a44a57cc294b3f4f34e2af8232910" translate="yes" xml:space="preserve">
          <source>A token can be an &lt;code&gt;opener&lt;/code&gt; (something similar to an open-paren), a &lt;code&gt;closer&lt;/code&gt; (like a close-paren), or &lt;code&gt;neither&lt;/code&gt; of the two (e.g., an infix operator, or an inner token like &lt;code&gt;&quot;else&quot;&lt;/code&gt;).</source>
          <target state="translated">A token can be an &lt;code&gt;opener&lt;/code&gt; (something similar to an open-paren), a &lt;code&gt;closer&lt;/code&gt; (like a close-paren), or &lt;code&gt;neither&lt;/code&gt; of the two (e.g., an infix operator, or an inner token like &lt;code&gt;&quot;else&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d764cf0b69eb00f7e2c9718e179e351b46213d5" translate="yes" xml:space="preserve">
          <source>A tool bar is a row of images.</source>
          <target state="translated">工具栏是一排图像。</target>
        </trans-unit>
        <trans-unit id="b6e511e3067670e626e12e33340269d446fde317" translate="yes" xml:space="preserve">
          <source>A translation table has two extra slots. The first is either &lt;code&gt;nil&lt;/code&gt; or a translation table that performs the reverse translation; the second is the maximum number of characters to look up for translating sequences of characters (see the description of &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; below).</source>
          <target state="translated">A translation table has two extra slots. The first is either &lt;code&gt;nil&lt;/code&gt; or a translation table that performs the reverse translation; the second is the maximum number of characters to look up for translating sequences of characters (see the description of &lt;code&gt;make-translation-table-from-alist&lt;/code&gt; below).</target>
        </trans-unit>
        <trans-unit id="fdc3d3499bd5bb07db44fa25b08d5a6a535373e6" translate="yes" xml:space="preserve">
          <source>A true mirror-image of &lt;code&gt;re-search-forward&lt;/code&gt; would require a special feature for matching regular expressions from end to beginning. It&amp;rsquo;s not worth the trouble of implementing that.</source>
          <target state="translated">A true mirror-image of &lt;code&gt;re-search-forward&lt;/code&gt; would require a special feature for matching regular expressions from end to beginning. It&amp;rsquo;s not worth the trouble of implementing that.</target>
        </trans-unit>
        <trans-unit id="d8e822f12fc2d0ada4fa0abd7fbe433aba2b4039" translate="yes" xml:space="preserve">
          <source>A type predicate function takes one argument; it returns &lt;code&gt;t&lt;/code&gt; if the argument belongs to the appropriate type, and &lt;code&gt;nil&lt;/code&gt; otherwise. Following a general Lisp convention for predicate functions, most type predicates&amp;rsquo; names end with &amp;lsquo;</source>
          <target state="translated">A type predicate function takes one argument; it returns &lt;code&gt;t&lt;/code&gt; if the argument belongs to the appropriate type, and &lt;code&gt;nil&lt;/code&gt; otherwise. Following a general Lisp convention for predicate functions, most type predicates&amp;rsquo; names end with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0d50bc7f95aabd11c78a01358b272f4c298b3579" translate="yes" xml:space="preserve">
          <source>A type used for automatically loading seldom-used functions.</source>
          <target state="translated">用于自动加载很少使用的功能的类型。</target>
        </trans-unit>
        <trans-unit id="b25d98417944fbcf3fe27fffb07995fdd6887711" translate="yes" xml:space="preserve">
          <source>A typical value might look like this:</source>
          <target state="translated">一个典型的数值可能是这样的。</target>
        </trans-unit>
        <trans-unit id="7068fb3333ff355206cad1f5c8ac4e885a7b5eaa" translate="yes" xml:space="preserve">
          <source>A unique number assigned to this window when it was created.</source>
          <target state="translated">窗口创建时分配给该窗口的唯一编号。</target>
        </trans-unit>
        <trans-unit id="1f49c36b6b4f969d94158af5c04fa459e6fb756b" translate="yes" xml:space="preserve">
          <source>A user interface for building JSONRPC applications</source>
          <target state="translated">构建JSONRPC应用程序的用户界面。</target>
        </trans-unit>
        <trans-unit id="da28673ff5250624bbd9c79fdce5b46476250e40" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.</source>
          <target state="translated">A value of &lt;code&gt;nil&lt;/code&gt; is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.</target>
        </trans-unit>
        <trans-unit id="761af930570eba02ee4263e0c4625df53668e35d" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;nil&lt;/code&gt; says to ignore the lock and let this user edit the file anyway.</source>
          <target state="translated">A value of &lt;code&gt;nil&lt;/code&gt; says to ignore the lock and let this user edit the file anyway.</target>
        </trans-unit>
        <trans-unit id="2614ea86270afac8b5acd08878d712db67414cd0" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;t&lt;/code&gt; says to grab the lock on the file. Then this user may edit the file and &lt;var&gt;other-user&lt;/var&gt; loses the lock.</source>
          <target state="translated">A value of &lt;code&gt;t&lt;/code&gt; says to grab the lock on the file. Then this user may edit the file and &lt;var&gt;other-user&lt;/var&gt; loses the lock.</target>
        </trans-unit>
        <trans-unit id="0f7035c80e73faf961d120dfe6ba3e3b9a60ff4c" translate="yes" xml:space="preserve">
          <source>A value of the form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; stands for the product of the values of &lt;var&gt;num&lt;/var&gt; and &lt;var&gt;expr&lt;/var&gt;. For example, &lt;code&gt;(2 . in)&lt;/code&gt; specifies a width of 2 inches, while &lt;code&gt;(0.5 .
&lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; specifies half the width (or height) of the specified &lt;var&gt;image&lt;/var&gt; (which should be given by its image spec).</source>
          <target state="translated">A value of the form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt; . &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; stands for the product of the values of &lt;var&gt;num&lt;/var&gt; and &lt;var&gt;expr&lt;/var&gt; . For example, &lt;code&gt;(2 . in)&lt;/code&gt; specifies a width of 2 inches, while &lt;code&gt;(0.5 . &lt;var&gt;image&lt;/var&gt;)&lt;/code&gt; specifies half the width (or height) of the specified &lt;var&gt;image&lt;/var&gt; (which should be given by its image spec).</target>
        </trans-unit>
        <trans-unit id="7d6f07646985192c4276dea56a0bd52c3ee59a86" translate="yes" xml:space="preserve">
          <source>A variable can be let-bound (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) to a value. This makes its global value shadowed by the binding; &lt;code&gt;default-value&lt;/code&gt; will then return the value from that binding, not the global value, and &lt;code&gt;set-default&lt;/code&gt; will be prevented from setting the global value (it will change the let-bound value instead). The following two functions allow to reference the global value even if it&amp;rsquo;s shadowed by a let-binding.</source>
          <target state="translated">A variable can be let-bound (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) to a value. This makes its global value shadowed by the binding; &lt;code&gt;default-value&lt;/code&gt; will then return the value from that binding, not the global value, and &lt;code&gt;set-default&lt;/code&gt; will be prevented from setting the global value (it will change the let-bound value instead). The following two functions allow to reference the global value even if it&amp;rsquo;s shadowed by a let-binding.</target>
        </trans-unit>
        <trans-unit id="42469365ae54b87406fe0c4580eafab3e15cd7f7" translate="yes" xml:space="preserve">
          <source>A variable can have buffer-local bindings in some buffers but not in other buffers. The default binding is shared by all the buffers that don&amp;rsquo;t have their own bindings for the variable. (This includes all newly-created buffers.) If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding.</source>
          <target state="translated">A variable can have buffer-local bindings in some buffers but not in other buffers. The default binding is shared by all the buffers that don&amp;rsquo;t have their own bindings for the variable. (This includes all newly-created buffers.) If you set the variable in a buffer that does not have a buffer-local binding for it, this sets the default binding, so the new value is visible in all the buffers that see the default binding.</target>
        </trans-unit>
        <trans-unit id="7229e30ed01c65b1f554b2be31bb3ad0ddba289e" translate="yes" xml:space="preserve">
          <source>A variable can have more than one local binding at a time (e.g., if there are nested &lt;code&gt;let&lt;/code&gt; forms that bind the variable). The &lt;em&gt;current binding&lt;/em&gt; is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by &lt;code&gt;setq&lt;/code&gt;.</source>
          <target state="translated">A variable can have more than one local binding at a time (e.g., if there are nested &lt;code&gt;let&lt;/code&gt; forms that bind the variable). The &lt;em&gt;current binding&lt;/em&gt; is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by &lt;code&gt;setq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ac65fb2f3cee8bab9b33ddf4b381098337ecd1" translate="yes" xml:space="preserve">
          <source>A variable declared to be a user option (i.e., satisfying the predicate &lt;code&gt;custom-variable-p&lt;/code&gt;). This reads the variable using &lt;code&gt;read-variable&lt;/code&gt;. See &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Definition of read-variable&lt;/a&gt;. Existing, Completion, Prompt.</source>
          <target state="translated">A variable declared to be a user option (i.e., satisfying the predicate &lt;code&gt;custom-variable-p&lt;/code&gt; ). This reads the variable using &lt;code&gt;read-variable&lt;/code&gt; . See &lt;a href=&quot;high_002dlevel-completion#Definition-of-read_002dvariable&quot;&gt;Definition of read-variable&lt;/a&gt;. Existing, Completion, Prompt.</target>
        </trans-unit>
        <trans-unit id="714788a2d69016197f589516788c6c86a085d831" translate="yes" xml:space="preserve">
          <source>A variable definition serves three purposes. First, it informs people who read the code that the symbol is &lt;em&gt;intended&lt;/em&gt; to be used a certain way (as a variable). Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string. Third, it provides information to programming tools such as &lt;code&gt;etags&lt;/code&gt;, allowing them to find where the variable was defined.</source>
          <target state="translated">A variable definition serves three purposes. First, it informs people who read the code that the symbol is &lt;em&gt;intended&lt;/em&gt; to be used a certain way (as a variable). Second, it informs the Lisp system of this, optionally supplying an initial value and a documentation string. Third, it provides information to programming tools such as &lt;code&gt;etags&lt;/code&gt; , allowing them to find where the variable was defined.</target>
        </trans-unit>
        <trans-unit id="6d8469682cf6ae5ee24fbb06b606a67a9bdca6f1" translate="yes" xml:space="preserve">
          <source>A vector of elements groups the elements into a single &lt;em&gt;group specification&lt;/em&gt;. Its meaning has nothing to do with vectors.</source>
          <target state="translated">A vector of elements groups the elements into a single &lt;em&gt;group specification&lt;/em&gt;. Its meaning has nothing to do with vectors.</target>
        </trans-unit>
        <trans-unit id="907ba2db0b69ea3ac390ffc8957c9f20ac952af1" translate="yes" xml:space="preserve">
          <source>A vector of glyphs for indicating the presence of invisible lines (the default is &amp;lsquo;</source>
          <target state="translated">A vector of glyphs for indicating the presence of invisible lines (the default is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="5b9d67749d8a12ed598e9d50f8a2fa40ed3d9434" translate="yes" xml:space="preserve">
          <source>A vector of strings or bool-vectors, each specifying one line of the image. Do specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt;.</source>
          <target state="translated">A vector of strings or bool-vectors, each specifying one line of the image. Do specify &lt;code&gt;:height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd393f14b47e46b8b1b11b3ee71f7e6e4effd32" translate="yes" xml:space="preserve">
          <source>A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector. This does not evaluate or even examine the elements of the vector. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;. Vectors written with square brackets should not be modified via &lt;code&gt;aset&lt;/code&gt; or other destructive operations. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">A vector, like a string or a number, is considered a constant for evaluation: the result of evaluating it is the same vector. This does not evaluate or even examine the elements of the vector. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;. Vectors written with square brackets should not be modified via &lt;code&gt;aset&lt;/code&gt; or other destructive operations. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cea3cbc11949c249de3312f294eef9cb9f938425" translate="yes" xml:space="preserve">
          <source>A version number, in a form that the function &lt;code&gt;version-to-list&lt;/code&gt; understands (e.g., &amp;lsquo;</source>
          <target state="translated">A version number, in a form that the function &lt;code&gt;version-to-list&lt;/code&gt; understands (e.g., &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d6f9261a2dce5769b4273b16b8e7e92056f25007" translate="yes" xml:space="preserve">
          <source>A very simple parsing technique.</source>
          <target state="translated">一个非常简单的解析技术。</target>
        </trans-unit>
        <trans-unit id="a21b6bc0e953a05c7047f6926acdf8cdb6092af2" translate="yes" xml:space="preserve">
          <source>A visible child frame always appears on top of its parent frame thus obscuring parts of it, except on NS builds where it may be positioned beneath the parent. This is comparable to the window-system window of a top-level frame which also always appears on top of its parent window&amp;mdash;the desktop&amp;rsquo;s root window. When a parent frame is iconified or made invisible (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;), its child frames are made invisible. When a parent frame is deiconified or made visible, its child frames are made visible.</source>
          <target state="translated">A visible child frame always appears on top of its parent frame thus obscuring parts of it, except on NS builds where it may be positioned beneath the parent. This is comparable to the window-system window of a top-level frame which also always appears on top of its parent window&amp;mdash;the desktop&amp;rsquo;s root window. When a parent frame is iconified or made invisible (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;), its child frames are made invisible. When a parent frame is deiconified or made visible, its child frames are made visible.</target>
        </trans-unit>
        <trans-unit id="3f15d83470f651a16357e3fbbafed38889367d47" translate="yes" xml:space="preserve">
          <source>A visible frame occupies a rectangular area on its terminal&amp;rsquo;s display. This area may contain a number of nested rectangles, each serving a different purpose. The drawing below sketches the layout of a frame on a graphical terminal:</source>
          <target state="translated">A visible frame occupies a rectangular area on its terminal&amp;rsquo;s display. This area may contain a number of nested rectangles, each serving a different purpose. The drawing below sketches the layout of a frame on a graphical terminal:</target>
        </trans-unit>
        <trans-unit id="9dc2f20dda99554f7dead3ef07cf05023791995d" translate="yes" xml:space="preserve">
          <source>A watch can become invalid if the file or directory it watches is deleted, or if the watcher thread exits abnormally for any other reason. Removing the watch by calling &lt;code&gt;file-notify-rm-watch&lt;/code&gt; also makes it invalid.</source>
          <target state="translated">A watch can become invalid if the file or directory it watches is deleted, or if the watcher thread exits abnormally for any other reason. Removing the watch by calling &lt;code&gt;file-notify-rm-watch&lt;/code&gt; also makes it invalid.</target>
        </trans-unit>
        <trans-unit id="efb12abaf84e2ff0588000ce76b06f219405368d" translate="yes" xml:space="preserve">
          <source>A web server providing access to a package archive must support the following queries:</source>
          <target state="translated">提供访问软件包存档的 Web 服务器必须支持以下查询。</target>
        </trans-unit>
        <trans-unit id="96a8665d6abd124bc5fe28303880a92b178554c2" translate="yes" xml:space="preserve">
          <source>A well-designed macro definition takes steps to avoid this problem by producing an expansion that evaluates the argument expressions exactly once unless repeated evaluation is part of the intended purpose of the macro. Here is a correct expansion for the &lt;code&gt;for&lt;/code&gt; macro:</source>
          <target state="translated">A well-designed macro definition takes steps to avoid this problem by producing an expansion that evaluates the argument expressions exactly once unless repeated evaluation is part of the intended purpose of the macro. Here is a correct expansion for the &lt;code&gt;for&lt;/code&gt; macro:</target>
        </trans-unit>
        <trans-unit id="b1827635d79dea77c5cd2894c432de677a45e87a" translate="yes" xml:space="preserve">
          <source>A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;, see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) or when resizing the window&amp;rsquo;s frame (see &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Frame Size&lt;/a&gt;).</source>
          <target state="translated">A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;, see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) or when resizing the window&amp;rsquo;s frame (see &lt;a href=&quot;frame-size#Frame-Size&quot;&gt;Frame Size&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="da0f4aabb2b28d1adb4d16bd804393865c93bf0e" translate="yes" xml:space="preserve">
          <source>A window can have a &lt;em&gt;header line&lt;/em&gt; at the top, just as it can have a mode line at the bottom. The header line feature works just like the mode line feature, except that it&amp;rsquo;s controlled by &lt;code&gt;header-line-format&lt;/code&gt;:</source>
          <target state="translated">A window can have a &lt;em&gt;header line&lt;/em&gt; at the top, just as it can have a mode line at the bottom. The header line feature works just like the mode line feature, except that it&amp;rsquo;s controlled by &lt;code&gt;header-line-format&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7eb040f86ff87638d96bfd4ec298244d1a1c95a8" translate="yes" xml:space="preserve">
          <source>A window is resized if and only if it has been specially created for the buffer. In particular, windows that have shown another buffer before are not resized. By default, this mode uses &lt;code&gt;fit-window-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) for resizing. You can specify a different function by customizing the options &lt;code&gt;temp-buffer-max-height&lt;/code&gt; and &lt;code&gt;temp-buffer-max-width&lt;/code&gt; below.</source>
          <target state="translated">仅当为缓冲区专门创建窗口时，才调整窗口大小。特别是，以前显示过另一个缓冲区的窗口不会调整大小。默认情况下，此模式使用 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; （请参见&amp;ldquo;&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;调整Windows大小&amp;rdquo;&lt;/a&gt;）进行大小调整。您可以通过自定义下面的 &lt;code&gt;temp-buffer-max-height&lt;/code&gt; 和 &lt;code&gt;temp-buffer-max-width&lt;/code&gt; 选项来指定其他功能。</target>
        </trans-unit>
        <trans-unit id="5b181ae523d21d580fe4dc9490e28d52beda4e36" translate="yes" xml:space="preserve">
          <source>A window showing a temporary buffer can be fitted to the size of that buffer using the following mode:</source>
          <target state="translated">一个显示临时缓冲区的窗口可以使用以下模式与该缓冲区的大小相适应。</target>
        </trans-unit>
        <trans-unit id="10b80aceee959c8dcb16c72ed1a2553043421e82" translate="yes" xml:space="preserve">
          <source>A window that is just one line tall never displays a header line. A window that is two lines tall cannot display both a mode line and a header line at once; if it has a mode line, then it does not display a header line.</source>
          <target state="translated">只有一行高的窗口永远不会显示页眉行。两行高的窗口不能同时显示模式行和页眉行;如果有模式行,则不显示页眉行。</target>
        </trans-unit>
        <trans-unit id="6004ea783485bff5b8ff0a2c4b58ed331fceaf67" translate="yes" xml:space="preserve">
          <source>A window that showed &lt;var&gt;buffer&lt;/var&gt; before, provided it is not the selected window.</source>
          <target state="translated">如果不是选定窗口，则之前显示 &lt;var&gt;buffer&lt;/var&gt; 的窗口。</target>
        </trans-unit>
        <trans-unit id="24fac820e9dc3bcfec792e9cbea05e313a184dd9" translate="yes" xml:space="preserve">
          <source>A working buffer for decoding.</source>
          <target state="translated">一个用于解码的工作缓冲区。</target>
        </trans-unit>
        <trans-unit id="a0c46d9d748b73163c147c1ce7040c6c5f099f4e" translate="yes" xml:space="preserve">
          <source>A working buffer for encoding.</source>
          <target state="translated">编码的工作缓冲区。</target>
        </trans-unit>
        <trans-unit id="616b07ea95b58bd9c829efac045d8e3b914aeaa6" translate="yes" xml:space="preserve">
          <source>A wrap prefix may also be specified for regions of text, using the &lt;code&gt;wrap-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;wrap-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">还可以使用 &lt;code&gt;wrap-prefix&lt;/code&gt; 文本或overlay属性为文本区域指定一个wrap前缀。这优先于 &lt;code&gt;wrap-prefix&lt;/code&gt; 变量。请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b61659ac0aca26e539585c1b71cc13614c39334" translate="yes" xml:space="preserve">
          <source>A wrap-prefix may also be specified for an entire buffer using the &lt;code&gt;wrap-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;wrap-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;wrap-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">还可以使用 &lt;code&gt;wrap-prefix&lt;/code&gt; 缓冲区局部变量为整个缓冲区指定一个wrap-prefix（但是， &lt;code&gt;wrap-prefix&lt;/code&gt; 文本属性优先于 &lt;code&gt;wrap-prefix&lt;/code&gt; 变量的值）。请参阅&lt;a href=&quot;truncation#Truncation&quot;&gt;截断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a6a3baa60990f601b340b07ecccc1672c3cca03" translate="yes" xml:space="preserve">
          <source>A-</source>
          <target state="translated">A-</target>
        </trans-unit>
        <trans-unit id="a85e90f9835e6411e691ebde65582614cea81732" translate="yes" xml:space="preserve">
          <source>ALT</source>
          <target state="translated">ALT</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="031fd11ba8734ab304116a023b5216306b246bee" translate="yes" xml:space="preserve">
          <source>AT</source>
          <target state="translated">AT</target>
        </trans-unit>
        <trans-unit id="99122025a15b80d993018f40997751b62445924e" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T Unix System V.</source>
          <target state="translated">AT＆T Unix系统V。</target>
        </trans-unit>
        <trans-unit id="54f90b5155803aae21271b2ad64b0075c858dfb3" translate="yes" xml:space="preserve">
          <source>Abbrev Properties</source>
          <target state="translated">缩写属性</target>
        </trans-unit>
        <trans-unit id="f784445cdd616480acdfafb0159b1dd57c47999c" translate="yes" xml:space="preserve">
          <source>Abbrev Table Properties</source>
          <target state="translated">缩略表属性</target>
        </trans-unit>
        <trans-unit id="2a8b96a9acfbae4f72a46878195e3d362ca12a6d" translate="yes" xml:space="preserve">
          <source>Abbrev Tables</source>
          <target state="translated">缩略表</target>
        </trans-unit>
        <trans-unit id="a762e02aeaccf777576ff3c307e562d8de1c9496" translate="yes" xml:space="preserve">
          <source>Abbrev tables used by various major modes.</source>
          <target state="translated">各种主要模式使用的缩写表。</target>
        </trans-unit>
        <trans-unit id="49470700c92eb0723c4ce23a16459e8c3cadae63" translate="yes" xml:space="preserve">
          <source>Abbrevs</source>
          <target state="translated">Abbrevs</target>
        </trans-unit>
        <trans-unit id="0305dceae89338799d1bdcabaff23a024687a7d6" translate="yes" xml:space="preserve">
          <source>Abbrevs and Abbrev Expansion</source>
          <target state="translated">缩略语和缩略语扩展</target>
        </trans-unit>
        <trans-unit id="b4aa8f55f18e483e3d99ff9bebe3bd5c52648359" translate="yes" xml:space="preserve">
          <source>Abbrevs are usually expanded by certain interactive commands, including &lt;code&gt;self-insert-command&lt;/code&gt;. This section describes the subroutines used in writing such commands, as well as the variables they use for communication.</source>
          <target state="translated">缩写通常通过某些交互式命令来扩展，包括 &lt;code&gt;self-insert-command&lt;/code&gt; 。本节描述编写此类命令时使用的子例程，以及它们用于通信的变量。</target>
        </trans-unit>
        <trans-unit id="1631d5afa2a3227c2b1fff62aedf669a7aee3c55" translate="yes" xml:space="preserve">
          <source>Abbrevs have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev&lt;/code&gt;, and manipulate them with the following functions:</source>
          <target state="translated">缩写具有属性，其中一些属性会影响其工作方式。您可以将它们提供为 &lt;code&gt;define-abbrev&lt;/code&gt; 的参数，并使用以下功能对其进行操作：</target>
        </trans-unit>
        <trans-unit id="fd64ebde815890af94b19555b946c61d882f6e1a" translate="yes" xml:space="preserve">
          <source>Abort one level back to the previous command level (&lt;code&gt;abort-recursive-edit&lt;/code&gt;).</source>
          <target state="translated">将一个级别中止回到先前的命令级别（ &lt;code&gt;abort-recursive-edit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="649f859d67e712421f56a26ae61a458542dd60ea" translate="yes" xml:space="preserve">
          <source>Absolute and Relative File Names</source>
          <target state="translated">绝对和相对文件名</target>
        </trans-unit>
        <trans-unit id="059d44280b6e5c431c206b204f4f62d2e05d3635" translate="yes" xml:space="preserve">
          <source>Absolute times may be specified using a string with a limited variety of formats, and are taken to be times &lt;em&gt;today&lt;/em&gt;, even if already in the past. The recognized forms are &amp;lsquo;</source>
          <target state="translated">绝对时间可以使用格式有限的字符串来指定，即使&lt;em&gt;今天&lt;/em&gt;已经是过去，也可以视为&lt;em&gt;今天&lt;/em&gt;。公认的形式是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c2929c3c521daab9f85d0df0bc4e1eb3e6ff7ace" translate="yes" xml:space="preserve">
          <source>Abstract Display</source>
          <target state="translated">摘要展示</target>
        </trans-unit>
        <trans-unit id="0dd14bcbc9ae50a4fc5b86a822cc2f2f4d8cca03" translate="yes" xml:space="preserve">
          <source>Abstract Display Example</source>
          <target state="translated">摘要显示示例</target>
        </trans-unit>
        <trans-unit id="8ca47e66401ef945d4b28414ef0d5576741f3686" translate="yes" xml:space="preserve">
          <source>Abstract Display Functions</source>
          <target state="translated">抽象显示功能</target>
        </trans-unit>
        <trans-unit id="69257aa08447c746dd43fabf319f01b5bf36c541" translate="yes" xml:space="preserve">
          <source>Accepting Output from Processes</source>
          <target state="translated">接受流程的输出</target>
        </trans-unit>
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="translated">访问控制</target>
        </trans-unit>
        <trans-unit id="c95b17f402b7316d8ba7de52ef60427ce9506d18" translate="yes" xml:space="preserve">
          <source>Access to Documentation Strings</source>
          <target state="translated">访问文档字符串</target>
        </trans-unit>
        <trans-unit id="ad4938a0faaa972c17f8af4c4d5fdcca75e5ab35" translate="yes" xml:space="preserve">
          <source>Access to Frame Parameters</source>
          <target state="translated">访问帧参数</target>
        </trans-unit>
        <trans-unit id="51a874cb0f96d3ea9f2ce946b1290deba1b58fd0" translate="yes" xml:space="preserve">
          <source>Access, manipulate and search the</source>
          <target state="translated">访问、操作和搜索</target>
        </trans-unit>
        <trans-unit id="21dbc590326eedf17d212f7c64c83e8331fddf48" translate="yes" xml:space="preserve">
          <source>Accessing Elements of Lists</source>
          <target state="translated">访问列表中的元素</target>
        </trans-unit>
        <trans-unit id="b4efd1b0aae332f4b617e49e2f68b08f45ba40e4" translate="yes" xml:space="preserve">
          <source>Accessing Function Cell Contents</source>
          <target state="translated">访问功能单元内容</target>
        </trans-unit>
        <trans-unit id="2ae0d4aab84373932fbdccdc1dd027efe8eb99b1" translate="yes" xml:space="preserve">
          <source>Accessing Mouse Events</source>
          <target state="translated">访问鼠标事件</target>
        </trans-unit>
        <trans-unit id="7b70ffbc5424e39bca6adad4e4d11285e1ac347b" translate="yes" xml:space="preserve">
          <source>Accessing Other Processes</source>
          <target state="translated">访问其他进程</target>
        </trans-unit>
        <trans-unit id="8339c289bb6c2a3facc1658bda0b35c1d194fecf" translate="yes" xml:space="preserve">
          <source>Accessing Scroll Bar Events</source>
          <target state="translated">访问滚动条事件</target>
        </trans-unit>
        <trans-unit id="8eb474e9f84ed1c8d415f59983dd55f6ddf51322" translate="yes" xml:space="preserve">
          <source>Accessing Symbol Properties</source>
          <target state="translated">访问符号属性</target>
        </trans-unit>
        <trans-unit id="dd21e1a656d1c33e1a0961edb1425706c4dca0fb" translate="yes" xml:space="preserve">
          <source>Accessing Variable Values</source>
          <target state="translated">访问变量值</target>
        </trans-unit>
        <trans-unit id="8572c608682fbb32c330cfe123c0c1e48efb3125" translate="yes" xml:space="preserve">
          <source>Accessing a window&amp;rsquo;s size.</source>
          <target state="translated">访问窗口的大小。</target>
        </trans-unit>
        <trans-unit id="f8f65e4cb3dd5208adf445a32728a6ff8fca1a80" translate="yes" xml:space="preserve">
          <source>Accessing and changing buffer names.</source>
          <target state="translated">访问和更改缓冲区名称。</target>
        </trans-unit>
        <trans-unit id="3129221bf25c4d4b56aa75c86a37cdcc52d7977f" translate="yes" xml:space="preserve">
          <source>Accessing and recording terminal input.</source>
          <target state="translated">访问和记录终端输入。</target>
        </trans-unit>
        <trans-unit id="8631d7461d61b93f0e7f285fa1d91660e92fcc8e" translate="yes" xml:space="preserve">
          <source>Accessing files.</source>
          <target state="translated">访问文件。</target>
        </trans-unit>
        <trans-unit id="6ab94f81e36e6a4e03c0557995d9d781180dfde7" translate="yes" xml:space="preserve">
          <source>Accessing or setting the function definition of a symbol.</source>
          <target state="translated">访问或设置符号的功能定义。</target>
        </trans-unit>
        <trans-unit id="febe729637e545444f7ff407ae1d3c58bfa2095e" translate="yes" xml:space="preserve">
          <source>Accessing other processes running on your system.</source>
          <target state="translated">访问系统上运行的其他进程。</target>
        </trans-unit>
        <trans-unit id="317d74ecc1929588bf8f86c73cd8f7de6158a955" translate="yes" xml:space="preserve">
          <source>Accessing property lists stored elsewhere.</source>
          <target state="translated">访问存储在其他地方的财产清单。</target>
        </trans-unit>
        <trans-unit id="4de3522fad93f3eb20523cf511d421cb8eef7ca4" translate="yes" xml:space="preserve">
          <source>Accessing run-status and other attributes.</source>
          <target state="translated">访问运行状态和其他属性。</target>
        </trans-unit>
        <trans-unit id="e4d2ebfdc40bb29558e41e11ad7b405042d411f3" translate="yes" xml:space="preserve">
          <source>Accessing single items of match data, such as where a particular subexpression started.</source>
          <target state="translated">访问单项匹配数据,如某一子表达式的起始位置。</target>
        </trans-unit>
        <trans-unit id="e47d1cd990a7768c115296fc95220fcfe9f44b0e" translate="yes" xml:space="preserve">
          <source>Accessing symbol properties.</source>
          <target state="translated">访问符号属性。</target>
        </trans-unit>
        <trans-unit id="97a8946bf0993a5ece0972055df9d2232582c889" translate="yes" xml:space="preserve">
          <source>Accessing the Entire Match Data</source>
          <target state="translated">访问整个匹配数据</target>
        </trans-unit>
        <trans-unit id="0098eec4c4a85cc7153b9941ac7e084d9e2e8113" translate="yes" xml:space="preserve">
          <source>Accessing the entire match data at once, as a list.</source>
          <target state="translated">以列表的形式一次性访问整个匹配数据。</target>
        </trans-unit>
        <trans-unit id="6d51c3b889a7d39ffb0cd69aa7cdd6137813bf7a" translate="yes" xml:space="preserve">
          <source>Accessor functions are provided to access the elements in this list. The accessors are mentioned along with the descriptions of the elements below.</source>
          <target state="translated">提供了访问该列表中元素的访问函数。下文提到的存取函数与各要素的说明一起。</target>
        </trans-unit>
        <trans-unit id="a16eff51e0f2460918136851c80aba409432bd14" translate="yes" xml:space="preserve">
          <source>Accordingly, the native height of a frame may include the height of the tool bar but not that of the menu bar (Lucid, Motif, MS-Windows) or those of the menu bar and the tool bar (non-toolkit and text terminal frames).</source>
          <target state="translated">因此,框架的本机高度可以包括工具栏的高度,但不包括菜单栏的高度(Lucid、Motif、MS-Windows)或菜单栏和工具栏的高度(非工具箱和文本终端框架)。</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="8be718ab6c21edb41bfaec3e8d4ff0416d658fc0" translate="yes" xml:space="preserve">
          <source>Action Alists for Buffer Display</source>
          <target state="translated">缓冲区显示的动作列表</target>
        </trans-unit>
        <trans-unit id="ce9f32ee0623ab47f4c96611c146ef4fcb105048" translate="yes" xml:space="preserve">
          <source>Action Functions for Buffer Display</source>
          <target state="translated">缓冲区显示的动作功能</target>
        </trans-unit>
        <trans-unit id="bea1043802a5a73ba6a935cc95001c4084c8eed4" translate="yes" xml:space="preserve">
          <source>Active Display Table</source>
          <target state="translated">活动显示表</target>
        </trans-unit>
        <trans-unit id="1b42bb970933421bd7fe384eb941f0b135fc8d12" translate="yes" xml:space="preserve">
          <source>Active Keymaps</source>
          <target state="translated">活跃的钥匙图</target>
        </trans-unit>
        <trans-unit id="8bae209835d078ba1a2b628e6a1e2a530501a3e6" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice</source>
          <target state="translated">使用旧的defadvice改编代码。</target>
        </trans-unit>
        <trans-unit id="fb2cba4aab141960fa84cebe7cdaa1f7b5ca40f1" translate="yes" xml:space="preserve">
          <source>Adapting code using the old defadvice.</source>
          <target state="translated">使用旧的defadvice改编代码。</target>
        </trans-unit>
        <trans-unit id="d3aca0f70608cde924c0c717aa6f76cc5b6dd2c8" translate="yes" xml:space="preserve">
          <source>Adaptive Fill Mode</source>
          <target state="translated">自适应填充模式</target>
        </trans-unit>
        <trans-unit id="ad3177b884766938f06c1f5cfe5f60876bbecbb6" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode chooses a fill prefix from context.</source>
          <target state="translated">自适应填充模式从上下文中选择一个填充前缀。</target>
        </trans-unit>
        <trans-unit id="45867255fd797585e4916e018bbccee9a35d212f" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode is enabled when this variable is non-&lt;code&gt;nil&lt;/code&gt;. It is &lt;code&gt;t&lt;/code&gt; by default.</source>
          <target state="translated">当此变量为非 &lt;code&gt;nil&lt;/code&gt; 时，启用自适应填充模式。默认为 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41fe7af53eab5acab9f4d23fedd7b9d027e07088" translate="yes" xml:space="preserve">
          <source>Adaptive Fill mode matches this regular expression against the text starting after the left margin whitespace (if any) on a line; the characters it matches are that line&amp;rsquo;s candidate for the fill prefix.</source>
          <target state="translated">自适应填充模式将此正则表达式与一行上左边距空白（如果有）之后的文本匹配；它匹配的字符是该行的填充前缀候选者。</target>
        </trans-unit>
        <trans-unit id="1298942391d0f9524543f2b581a0f4733a3cd521" translate="yes" xml:space="preserve">
          <source>Add &lt;var&gt;child&lt;/var&gt; to &lt;var&gt;node&lt;/var&gt;&amp;rsquo;s child list before the &lt;var&gt;before&lt;/var&gt; node. If &lt;var&gt;before&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, make &lt;var&gt;child&lt;/var&gt; the first child.</source>
          <target state="translated">添加 &lt;var&gt;child&lt;/var&gt; 到 &lt;var&gt;node&lt;/var&gt; 前的孩子名单 &lt;var&gt;before&lt;/var&gt; 节点。如果 &lt;var&gt;before&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，化妆 &lt;var&gt;child&lt;/var&gt; 的第一个孩子。</target>
        </trans-unit>
        <trans-unit id="86a8c842c5f2e03db4ed77dc6cfb42a4e1d59a0e" translate="yes" xml:space="preserve">
          <source>Add a clipping path to &lt;var&gt;svg&lt;/var&gt;. If applied to a shape via the &lt;var&gt;:clip-path&lt;/var&gt; property, parts of that shape which lie outside of the clipping path are not drawn.</source>
          <target state="translated">将剪切路径添加到 &lt;var&gt;svg&lt;/var&gt; 。如果通过 &lt;var&gt;:clip-path&lt;/var&gt; 属性应用于形状，则不会绘制该形状位于剪切路径之外的部分。</target>
        </trans-unit>
        <trans-unit id="ca2976f450cc856aed523c528c25b64c84e61f8c" translate="yes" xml:space="preserve">
          <source>Add a function to &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; that does the &lt;em&gt;identification&lt;/em&gt; and extends the scan so that the scanned text never starts or ends in the middle of a multiline construct.</source>
          <target state="translated">在 &lt;code&gt;font-lock-extend-region-functions&lt;/code&gt; 中添加一个函数，该函数进行&lt;em&gt;标识&lt;/em&gt;并扩展扫描，以使扫描的文本永远不会在多行构造的中间开始或结束。</target>
        </trans-unit>
        <trans-unit id="2437c12b4ee8245aff3c6e915602340a5cb79372" translate="yes" xml:space="preserve">
          <source>Add a polygon to &lt;var&gt;svg&lt;/var&gt; where &lt;var&gt;points&lt;/var&gt; is a list of X/Y pairs that describe the outer circumference of the polygon.</source>
          <target state="translated">在 &lt;var&gt;svg&lt;/var&gt; 中添加一个多边形，其中 &lt;var&gt;points&lt;/var&gt; 是描述多边形外圆周的X / Y对列表。</target>
        </trans-unit>
        <trans-unit id="d0cd8a519df07a3ed1321bd58a41305e60e7eb92" translate="yes" xml:space="preserve">
          <source>Add a watch for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt;. This arranges for filesystem events pertaining to &lt;var&gt;file&lt;/var&gt; to be reported to Emacs.</source>
          <target state="translated">添加监视与 &lt;var&gt;file&lt;/var&gt; 有关的文件系统事件。这安排了与 &lt;var&gt;file&lt;/var&gt; 有关的文件系统事件要报告给Emacs。</target>
        </trans-unit>
        <trans-unit id="e14f3bd4b7856be2d474146674d049259534d312" translate="yes" xml:space="preserve">
          <source>Add an element to &lt;code&gt;minor-mode-alist&lt;/code&gt; for each minor mode (see &lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;Definition of minor-mode-alist&lt;/a&gt;), if you want to indicate the minor mode in the mode line. This element should be a list of the following form:</source>
          <target state="translated">如果要在模式行中指示次要模式，请为每个次要模式将一个元素添加到 &lt;code&gt;minor-mode-alist&lt;/code&gt; （请参见&lt;a href=&quot;mode-line-variables#Definition-of-minor_002dmode_002dalist&quot;&gt;minor-mode-alist的定义&lt;/a&gt;）。该元素应该是以下形式的列表：</target>
        </trans-unit>
        <trans-unit id="7cff03d7e41619c195637edc380375b892f0845c" translate="yes" xml:space="preserve">
          <source>Add an embedded (raster) image to &lt;var&gt;svg&lt;/var&gt;. If &lt;var&gt;datap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;image&lt;/var&gt; should be a file name; otherwise it should be a string containing the image data as raw bytes. &lt;var&gt;image-type&lt;/var&gt; should be a</source>
          <target state="translated">将嵌入的（光栅）图像添加到 &lt;var&gt;svg&lt;/var&gt; 。如果 &lt;var&gt;datap&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;var&gt;image&lt;/var&gt; 应该是文件名；否则，它应该是一个包含图像数据作为原始字节的字符串。 &lt;var&gt;image-type&lt;/var&gt; 应为</target>
        </trans-unit>
        <trans-unit id="a711fa29586567ced283637a07f291daf9eccd20" translate="yes" xml:space="preserve">
          <source>Add line breaks and indentation to the top-level Lisp form at point to make it more readable.</source>
          <target state="translated">在点的顶层Lisp表格中增加换行和缩进,使其更易读。</target>
        </trans-unit>
        <trans-unit id="4d943f97d99246a36fad53c87be01c95f3a766cf" translate="yes" xml:space="preserve">
          <source>Add the advice &lt;var&gt;function&lt;/var&gt; to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;where&lt;/var&gt; and &lt;var&gt;props&lt;/var&gt; have the same meaning as for &lt;code&gt;add-function&lt;/code&gt; (see &lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising Primitives&lt;/a&gt;).</source>
          <target state="translated">将建议 &lt;var&gt;function&lt;/var&gt; 添加到命名功能 &lt;var&gt;symbol&lt;/var&gt; 。 &lt;var&gt;where&lt;/var&gt; 和 &lt;var&gt;props&lt;/var&gt; 与 &lt;code&gt;add-function&lt;/code&gt; 具有相同的含义（请参阅&lt;a href=&quot;core-advising-primitives#Core-Advising-Primitives&quot;&gt;Core Advising基元&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="83a774fd7318f04762e68de4e2b137225620ce7f" translate="yes" xml:space="preserve">
          <source>Add the custom node &lt;var&gt;tag&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">将自定义节点 &lt;var&gt;tag&lt;/var&gt; 到 &lt;var&gt;svg&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3861b616706cb862303f0503ef614aace33c9de7" translate="yes" xml:space="preserve">
          <source>Add the outline of a shape to &lt;var&gt;svg&lt;/var&gt; according to &lt;var&gt;commands&lt;/var&gt;, see &lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG Path Commands&lt;/a&gt;.</source>
          <target state="translated">根据 &lt;var&gt;commands&lt;/var&gt; 将形状的轮廓添加到 &lt;var&gt;svg&lt;/var&gt; ，请参阅&lt;a href=&quot;#SVG-Path-Commands&quot;&gt;SVG路径命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9913c193acde9c02d5ae3b24bc390ab6d78afa81" translate="yes" xml:space="preserve">
          <source>Add the specified &lt;var&gt;text&lt;/var&gt; to &lt;var&gt;svg&lt;/var&gt;.</source>
          <target state="translated">将指定的 &lt;var&gt;text&lt;/var&gt; 添加到 &lt;var&gt;svg&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="8aacc8a54a520b2ac614e1a90f78fb2eedfee11f" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a circle whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose radius is &lt;var&gt;radius&lt;/var&gt;.</source>
          <target state="translated">将一个以 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; 为中心，半径为 &lt;var&gt;radius&lt;/var&gt; 的圆添加到 &lt;var&gt;svg&lt;/var&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4fe52fae4d07b75457a9542137a4b9b5c60d0aef" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a line that starts at &lt;var&gt;x1&lt;/var&gt;/&lt;var&gt;y1&lt;/var&gt; and extends to &lt;var&gt;x2&lt;/var&gt;/&lt;var&gt;y2&lt;/var&gt;.</source>
          <target state="translated">在 &lt;var&gt;svg&lt;/var&gt; 中添加从 &lt;var&gt;x1&lt;/var&gt; / &lt;var&gt;y1&lt;/var&gt; 开始并延伸到 &lt;var&gt;x2&lt;/var&gt; / &lt;var&gt;y2&lt;/var&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="6a286d1f3e95235d9468003833dcabc092caa2e1" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a multiple-segment line (a.k.a. &amp;ldquo;polyline&amp;rdquo;) that goes through &lt;var&gt;points&lt;/var&gt;, which is a list of X/Y position pairs.</source>
          <target state="translated">将经过 &lt;var&gt;points&lt;/var&gt; 的多段线（也称为&amp;ldquo;折线&amp;rdquo;）添加到 &lt;var&gt;svg&lt;/var&gt; 中，这是X / Y位置对的列表。</target>
        </trans-unit>
        <trans-unit id="565a0d4084aef376e27a550cb97be439640f51cd" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; a rectangle whose upper left corner is at position &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt; and whose size is &lt;var&gt;width&lt;/var&gt;/&lt;var&gt;height&lt;/var&gt;.</source>
          <target state="translated">向 &lt;var&gt;svg&lt;/var&gt; 添加一个矩形，其左上角位于 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; 位置，其大小为 &lt;var&gt;width&lt;/var&gt; / &lt;var&gt;height&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f117e38663daed515f31d78095890b69b59541be" translate="yes" xml:space="preserve">
          <source>Add to &lt;var&gt;svg&lt;/var&gt; an ellipse whose center is at &lt;var&gt;x&lt;/var&gt;/&lt;var&gt;y&lt;/var&gt;, and whose horizontal radius is &lt;var&gt;x-radius&lt;/var&gt; and the vertical radius is &lt;var&gt;y-radius&lt;/var&gt;.</source>
          <target state="translated">将一个椭圆的中心添加到 &lt;var&gt;svg&lt;/var&gt; ,该椭圆的中心为 &lt;var&gt;x&lt;/var&gt; / &lt;var&gt;y&lt;/var&gt; ，其水平半径为 &lt;var&gt;x-radius&lt;/var&gt; ，垂直半径为 &lt;var&gt;y-radius&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a72995a8fcd466eb526d56641ee9c271fda926c9" translate="yes" xml:space="preserve">
          <source>Adding additional information about a function.</source>
          <target state="translated">添加有关函数的附加信息。</target>
        </trans-unit>
        <trans-unit id="8d9d382c9e9984ab00e1fba4ef0f8c1158adf2d5" translate="yes" xml:space="preserve">
          <source>Adding buttons to Emacs buffers.</source>
          <target state="translated">为Emacs缓冲区添加按钮。</target>
        </trans-unit>
        <trans-unit id="53b2f670a3f5ad65cee3f0da686a14d79f042bed" translate="yes" xml:space="preserve">
          <source>Adding clickable buttons to Emacs buffers.</source>
          <target state="translated">为Emacs缓冲区添加可点击的按钮。</target>
        </trans-unit>
        <trans-unit id="4679096d507cd2c89ee536f4f3c0706150098e70" translate="yes" xml:space="preserve">
          <source>Adding new text to a buffer.</source>
          <target state="translated">在缓冲区中添加新的文本。</target>
        </trans-unit>
        <trans-unit id="95751041c5c1654a609b5b64e61a15f9bddb79a0" translate="yes" xml:space="preserve">
          <source>Adding to the definition of a function.</source>
          <target state="translated">在函数的定义中增加:</target>
        </trans-unit>
        <trans-unit id="58b99f3d38ede1597b9ac02693be3ab80822e821" translate="yes" xml:space="preserve">
          <source>Adding, subtracting, comparing times, etc.</source>
          <target state="translated">加、减、比较时间等。</target>
        </trans-unit>
        <trans-unit id="500196012d89f448a3af179ba361faa20093707c" translate="yes" xml:space="preserve">
          <source>Additional Options for Displaying Buffers</source>
          <target state="translated">显示缓冲区的其他选项</target>
        </trans-unit>
        <trans-unit id="58c09d8cc944ca4e37be6c32b0108073f18357b2" translate="yes" xml:space="preserve">
          <source>Additional alist entries may be defined in the future.</source>
          <target state="translated">未来可能会定义更多的alist条目。</target>
        </trans-unit>
        <trans-unit id="a22e777afc57137b40767d7ea63841431e6d681d" translate="yes" xml:space="preserve">
          <source>Additional customization facilities.</source>
          <target state="translated">额外的定制设施。</target>
        </trans-unit>
        <trans-unit id="d931ed9a4962a5016c462de8f0c48ae86a47f189" translate="yes" xml:space="preserve">
          <source>Additional flags each character can have.</source>
          <target state="translated">每个角色可以拥有的额外标志。</target>
        </trans-unit>
        <trans-unit id="94e8d86d4f239006083ee80460e98ca2f47369d1" translate="yes" xml:space="preserve">
          <source>Additional image properties supported for the &lt;code&gt;xbm&lt;/code&gt; image type are:</source>
          <target state="translated">&lt;code&gt;xbm&lt;/code&gt; 图像类型支持的其他图像属性包括：</target>
        </trans-unit>
        <trans-unit id="6431dff5a05dff6ce51567fbc49ea8750d45e21d" translate="yes" xml:space="preserve">
          <source>Additional keypad duplicates of keys ordinarily found elsewhere. Emacs normally translates these into the like-named non-keypad keys.</source>
          <target state="translated">额外的键盘重复键,通常在其他地方都能找到,Emacs通常会将这些键翻译成同名的非键盘键。Emacs通常会将这些键翻译成相同名称的非键盘键。</target>
        </trans-unit>
        <trans-unit id="6338a470de402714fad49d59e574ee2a004eb402" translate="yes" xml:space="preserve">
          <source>Additional relevant functions for net connections.</source>
          <target state="translated">网络连接的其他相关功能。</target>
        </trans-unit>
        <trans-unit id="3c7e388f967fe300edc4c7b897df6b058218b157" translate="yes" xml:space="preserve">
          <source>Additional space to leave below each text line, in pixels (a positive integer). See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;, for more information.</source>
          <target state="translated">在每行文本下方保留的额外空间，以像素为单位（正整数）。有关更多信息，请参见&lt;a href=&quot;line-height#Line-Height&quot;&gt;线高&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1fd54e2342c288944104eeefd68ecbc3f125806" translate="yes" xml:space="preserve">
          <source>Additional typographic style information for the font, such as &amp;lsquo;</source>
          <target state="translated">字体的其他印刷样式信息，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ee273060f190cc74f93860343b827ad47759d5a0" translate="yes" xml:space="preserve">
          <source>Additionally, C code can modify the value of variables directly, bypassing the watchpoint mechanism.</source>
          <target state="translated">此外,C代码还可以绕过监视点机制,直接修改变量的值。</target>
        </trans-unit>
        <trans-unit id="a8a4e955fb763f3e97efcc9f314ccd7894853f87" translate="yes" xml:space="preserve">
          <source>Additionally, arrange to display &lt;var&gt;doc&lt;/var&gt; along with the docstring of &lt;code&gt;pcase&lt;/code&gt;. By convention, &lt;var&gt;doc&lt;/var&gt; should use &lt;code&gt;EXPVAL&lt;/code&gt; to stand for the result of evaluating &lt;var&gt;expression&lt;/var&gt; (first arg to &lt;code&gt;pcase&lt;/code&gt;).</source>
          <target state="translated">另外，安排显示 &lt;var&gt;doc&lt;/var&gt; 和 &lt;code&gt;pcase&lt;/code&gt; 的文档字符串。按照约定， &lt;var&gt;doc&lt;/var&gt; 应该使用 &lt;code&gt;EXPVAL&lt;/code&gt; 代表对 &lt;var&gt;expression&lt;/var&gt; 进行求值的结果（第一个arg到 &lt;code&gt;pcase&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21af65202f21fc2dc93653ae03092063c5b61dff" translate="yes" xml:space="preserve">
          <source>Additionally, conflicts can occur:</source>
          <target state="translated">此外,还可能发生冲突。</target>
        </trans-unit>
        <trans-unit id="e75498292efb2e16310b12aff15b14972a22b009" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;var&gt;collection&lt;/var&gt; should generally not be pre-filtered based on the current text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, because that is the responsibility of the caller of &lt;code&gt;completion-at-point-functions&lt;/code&gt; to do that according to the completion styles it decides to use.</source>
          <target state="translated">另外，通常不应该基于 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 之间的当前文本对 &lt;var&gt;collection&lt;/var&gt; 进行预过滤，因为这是 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 的调用者的责任，即根据其决定使用的完成样式来执行此操作。</target>
        </trans-unit>
        <trans-unit id="82ec8503880130af95fe77d33f6e32d8d45be1c7" translate="yes" xml:space="preserve">
          <source>Adjustable Tab Stops</source>
          <target state="translated">可调式止动器</target>
        </trans-unit>
        <trans-unit id="cce71d8b4de0fbe7b1d1416d923c41d53c78a09c" translate="yes" xml:space="preserve">
          <source>Adjustable, typewriter-like tab stops.</source>
          <target state="translated">可调节的、类似于打字机的卡位。</target>
        </trans-unit>
        <trans-unit id="3b315ad397f4b4a0ed97547b767a1277549aaf87" translate="yes" xml:space="preserve">
          <source>Adjusting Point After Commands</source>
          <target state="translated">指令后调整点</target>
        </trans-unit>
        <trans-unit id="9a61906e01d69a6bb351e657b21352956d8d32ce" translate="yes" xml:space="preserve">
          <source>Adjustment of point after a command.</source>
          <target state="translated">命令后调整点。</target>
        </trans-unit>
        <trans-unit id="e59f2f2723f7c1f609f3550bb2671a6cb90986fe" translate="yes" xml:space="preserve">
          <source>Advice and coding conventions for Emacs Lisp.</source>
          <target state="translated">Emacs Lisp的建议和编码习惯。</target>
        </trans-unit>
        <trans-unit id="40d1b99315ff674405912fd3cc10e5b67c67dd32" translate="yes" xml:space="preserve">
          <source>Advising Emacs Lisp Functions</source>
          <target state="translated">建议Emacs Lisp函数</target>
        </trans-unit>
        <trans-unit id="7d52de2eb6adab7304f81575e610e6fdaba9cc2d" translate="yes" xml:space="preserve">
          <source>Advising Named Functions</source>
          <target state="translated">咨询指定职能</target>
        </trans-unit>
        <trans-unit id="ab277db91341f63fab17a1c61d2a97a801877f92" translate="yes" xml:space="preserve">
          <source>Advising named functions.</source>
          <target state="translated">建议命名功能。</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="2001d34da0f06a489ff0edce787794897f4aeb55" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;set-text-properties&lt;/code&gt; returns, all the characters in the specified range have identical properties.</source>
          <target state="translated">后 &lt;code&gt;set-text-properties&lt;/code&gt; 的回报，在指定的所有字符范围具有相同的属性。</target>
        </trans-unit>
        <trans-unit id="26622072ea6b71fa07e70b43c76041b80e7e5a30" translate="yes" xml:space="preserve">
          <source>After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.</source>
          <target state="translated">Emacs修改文件后,有两个原因可能导致修改后的文件在后来的电源或介质故障中无法存活,这两个原因都与效率有关。第一,操作系统可能会将写入的数据与已经存储在二级存储上的其他地方的数据进行别名,直到后来修改一个文件或另一个文件;如果二级存储上的唯一副本因介质故障而丢失,这将会丢失两个文件。其次,操作系统可能不会立即将数据写入二级存储,这将在断电时丢失数据。</target>
        </trans-unit>
        <trans-unit id="9f89518425e409284cb01cc7c3c6a1775a6a510d" translate="yes" xml:space="preserve">
          <source>After Emacs reads your init file, it initializes &lt;code&gt;auto-save-list-file-name&lt;/code&gt; (if you have not already set it non-&lt;code&gt;nil&lt;/code&gt;) based on this prefix, adding the host name and process ID. If you set this to &lt;code&gt;nil&lt;/code&gt; in your init file, then Emacs does not initialize &lt;code&gt;auto-save-list-file-name&lt;/code&gt;.</source>
          <target state="translated">Emacs读取您的初始化文件后，它将基于此前缀初始化 &lt;code&gt;auto-save-list-file-name&lt;/code&gt; （如果尚未将其设置为non- &lt;code&gt;nil&lt;/code&gt; ），并添加主机名和进程ID。如果在初始化文件中将其设置为 &lt;code&gt;nil&lt;/code&gt; ，则Emacs不会初始化 &lt;code&gt;auto-save-list-file-name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6d6ee5d7d9a1dbc90deb665a4ae3ffff4b1c578" translate="yes" xml:space="preserve">
          <source>After Font Lock evaluates &lt;var&gt;pre-form&lt;/var&gt;, it does not search for &lt;var&gt;anchored-matcher&lt;/var&gt; beyond the end of the line. However, if &lt;var&gt;pre-form&lt;/var&gt; returns a buffer position that is greater than the position of point after &lt;var&gt;pre-form&lt;/var&gt; is evaluated, then the position returned by &lt;var&gt;pre-form&lt;/var&gt; is used as the limit of the search instead. It is generally a bad idea to return a position greater than the end of the line; in other words, the &lt;var&gt;anchored-matcher&lt;/var&gt; search should not span lines.</source>
          <target state="translated">在Font Lock评估 &lt;var&gt;pre-form&lt;/var&gt; 之后，它不会在行尾之外搜索 &lt;var&gt;anchored-matcher&lt;/var&gt; 。然而，如果 &lt;var&gt;pre-form&lt;/var&gt; 返回一个缓冲器位置大于后点的位置 &lt;var&gt;pre-form&lt;/var&gt; 进行评价，然后通过返回的位置 &lt;var&gt;pre-form&lt;/var&gt; 被用作代替搜索的限制。返回大于行尾的头寸通常是个坏主意；换句话说， &lt;var&gt;anchored-matcher&lt;/var&gt; 搜索不应跨越行。</target>
        </trans-unit>
        <trans-unit id="0d5f3b64280f526c25116915081cc07a4ccb40b7" translate="yes" xml:space="preserve">
          <source>After a &lt;em&gt;synchronous process&lt;/em&gt; is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix&lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt; is an example of this: it runs &lt;code&gt;ls&lt;/code&gt; in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.</source>
          <target state="translated">创建&lt;em&gt;同步进程&lt;/em&gt;后，Emacs将等待进程终止，然后再继续。在GNU或Unix &lt;a href=&quot;#FOOT21&quot; name=&quot;DOCF21&quot;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt;上启动Dired就是一个例子：它在同步进程中运行 &lt;code&gt;ls&lt;/code&gt; ，然后稍作修改输出。因为该过程是同步的，所以整个目录列表将在Emacs尝试对其执行任何操作之前到达缓冲区。</target>
        </trans-unit>
        <trans-unit id="79d05caca5759ed0ecaf87a1fc890988221544d6" translate="yes" xml:space="preserve">
          <source>After adding this advice, if you call &lt;code&gt;my-double&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">加入这个建议后，如果您拨打 &lt;code&gt;my-double&lt;/code&gt; 带&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b482ecda0086b5db531f75dfdba2467dc5429ef2" translate="yes" xml:space="preserve">
          <source>After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.</source>
          <target state="translated">定义了一个内联函数后,它的内联扩展可以在以后的同一文件中进行,就像宏一样。</target>
        </trans-unit>
        <trans-unit id="1711c03422a1600eb8ad808ec0bc8cf24123cdd2" translate="yes" xml:space="preserve">
          <source>After defining &lt;var&gt;name&lt;/var&gt; in this way, you can use it as the &lt;var&gt;test&lt;/var&gt; argument in &lt;code&gt;make-hash-table&lt;/code&gt;. When you do that, the hash table will use &lt;var&gt;test-fn&lt;/var&gt; to compare key values, and &lt;var&gt;hash-fn&lt;/var&gt; to compute a hash code from a key value.</source>
          <target state="translated">以这种方式定义 &lt;var&gt;name&lt;/var&gt; 后，可以将其用作 &lt;code&gt;make-hash-table&lt;/code&gt; 中的 &lt;var&gt;test&lt;/var&gt; 参数。当您这样做时，哈希表将使用 &lt;var&gt;test-fn&lt;/var&gt; 比较键值，并使用 &lt;var&gt;hash-fn&lt;/var&gt; 从键值计算哈希码。</target>
        </trans-unit>
        <trans-unit id="cb84be952166d7a786e0f5810ef1b95aefca141b" translate="yes" xml:space="preserve">
          <source>After executing the body of the handler, the &lt;code&gt;condition-case&lt;/code&gt; returns normally, using the value of the last form in the handler body as the overall value.</source>
          <target state="translated">在执行处理程序的主体之后， &lt;code&gt;condition-case&lt;/code&gt; 将以处理程序主体中的最后一个形式的值作为总值而正常返回。</target>
        </trans-unit>
        <trans-unit id="4dcf95c5a0c487e8209e489fa588abd672d9e8b8" translate="yes" xml:space="preserve">
          <source>After execution of the handler body, execution returns from the &lt;code&gt;condition-case&lt;/code&gt; form. Because the protected form is exited completely before execution of the handler, the handler cannot resume execution at the point of the error, nor can it examine variable bindings that were made within the protected form. All it can do is clean up and proceed.</source>
          <target state="translated">在执行处理程序主体之后，执行从 &lt;code&gt;condition-case&lt;/code&gt; 形式返回。因为受保护的表单在处理程序执行之前已完全退出，所以处理程序无法在错误时恢复执行，也无法检查在受保护的表单内进行的变量绑定。它所能做的就是清理并继续。</target>
        </trans-unit>
        <trans-unit id="f9f96cc122b695225532f65f8c1dc5af1dd81ad0" translate="yes" xml:space="preserve">
          <source>After installation, the installed package is &lt;em&gt;loaded&lt;/em&gt;: Emacs adds the package&amp;rsquo;s content directory to &lt;code&gt;load-path&lt;/code&gt;, and evaluates the autoload definitions in</source>
          <target state="translated">安装后，将&lt;em&gt;加载&lt;/em&gt;已安装的软件包：Emacs将软件包的内容目录添加到 &lt;code&gt;load-path&lt;/code&gt; ，并在以下位置评估自动加载定义：</target>
        </trans-unit>
        <trans-unit id="7d8f54422101c3e253d2eea8938b01fa0aa88a65" translate="yes" xml:space="preserve">
          <source>After moving point, you may wish to jump back to the stop point. You can do that with</source>
          <target state="translated">移动点后,你可能希望跳回停止点。你可以用</target>
        </trans-unit>
        <trans-unit id="70f30068f24e099728f9220f33c66de8c45b3661" translate="yes" xml:space="preserve">
          <source>After selecting</source>
          <target state="translated">在选择</target>
        </trans-unit>
        <trans-unit id="6b47650b2f0eeaae057157d2f6dba970bba4bcc2" translate="yes" xml:space="preserve">
          <source>After substitution, if a &amp;lsquo;</source>
          <target state="translated">替换后，如果&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="11efe5f0fdddc5460cc69a92a923925429424bb2" translate="yes" xml:space="preserve">
          <source>After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.</source>
          <target state="translated">在切换窗口或缓冲区后,以及在其他一些情况下,如果窗口开始在行的中间,Emacs会将窗口开始调整为行的开始。这可以防止某些操作将窗口起始点留在行内的一个无意义的点上。这个功能可能会干扰使用Lisp模式的命令执行某些Lisp代码的测试,因为它们会触发这个重新调整。要测试这类代码,请将其放入命令中,并将命令绑定到一个键上。</target>
        </trans-unit>
        <trans-unit id="495827ab1d768e91f37fdef6604e6f5836895698" translate="yes" xml:space="preserve">
          <source>After that, &lt;var&gt;body&lt;/var&gt; is executed, and the connection-local variables are unwound. Example:</source>
          <target state="translated">之后，执行 &lt;var&gt;body&lt;/var&gt; ，并取消连接局部变量。例：</target>
        </trans-unit>
        <trans-unit id="6ba43c834d967b77f336f5c21c19c92d28a6987a" translate="yes" xml:space="preserve">
          <source>After the &amp;lsquo;</source>
          <target state="translated">之后 '</target>
        </trans-unit>
        <trans-unit id="d9009ae4cb68e38ac581c27d4e2acc4e2c297d9b" translate="yes" xml:space="preserve">
          <source>After the call to the &lt;code&gt;DEFUN&lt;/code&gt; macro, you must write the argument list for the C function, including the types for the arguments. If the primitive accepts a fixed maximum number of Lisp arguments, there must be one C argument for each Lisp argument, and each argument must be of type &lt;code&gt;Lisp_Object&lt;/code&gt;. (Various macros and functions for creating values of type &lt;code&gt;Lisp_Object&lt;/code&gt; are declared in the file</source>
          <target state="translated">调用 &lt;code&gt;DEFUN&lt;/code&gt; 宏后，必须编写C函数的参数列表，包括参数的类型。如果基元接受固定数量的Lisp自变量，则每个Lisp自变量必须有一个C自变量，并且每个自变量的类型必须为 &lt;code&gt;Lisp_Object&lt;/code&gt; 。（在文件中声明了用于创建 &lt;code&gt;Lisp_Object&lt;/code&gt; 类型的值的各种宏和函数。</target>
        </trans-unit>
        <trans-unit id="33d79aff6f896ac6094c3c7ab2c4138388d48ec5" translate="yes" xml:space="preserve">
          <source>After the command loop has translated a key sequence into a command, it invokes that command using the function &lt;code&gt;command-execute&lt;/code&gt;. If the command is a function, &lt;code&gt;command-execute&lt;/code&gt; calls &lt;code&gt;call-interactively&lt;/code&gt;, which reads the arguments and calls the command. You can also call these functions yourself.</source>
          <target state="translated">命令循环将键序列转换为命令后，它将使用 &lt;code&gt;command-execute&lt;/code&gt; 调用该命令。如果命令是函数，则 &lt;code&gt;command-execute&lt;/code&gt; &lt;code&gt;call-interactively&lt;/code&gt; 调用call，该命令读取参数并调用命令。您也可以自己调用这些函数。</target>
        </trans-unit>
        <trans-unit id="eb00eb8abe509aa0e806964b17e030d795a6dcae" translate="yes" xml:space="preserve">
          <source>After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user&amp;rsquo;s point of view, the function call works as expected, using the function definition in the loaded file.</source>
          <target state="translated">加载文件后，该符号应具有一个不是自动加载对象的新函数定义。然后调用新定义，就好像它是从那里开始的。从用户的角度来看，使用已加载文件中的函数定义，函数调用可以按预期工作。</target>
        </trans-unit>
        <trans-unit id="5e64aa108dd56236b255a2bfaa30873fae10d663" translate="yes" xml:space="preserve">
          <source>After the lines are joined, the function &lt;code&gt;fixup-whitespace&lt;/code&gt; is responsible for deciding whether to leave a space at the junction.</source>
          <target state="translated">连接线后，功能 &lt;code&gt;fixup-whitespace&lt;/code&gt; 负责确定是否在连接处保留空间。</target>
        </trans-unit>
        <trans-unit id="8028d1d381d5b478f2dffeace51ce5901d720198" translate="yes" xml:space="preserve">
          <source>After the terminal is initialized, this is set to the terminal-specific initialization function.</source>
          <target state="translated">终端初始化后,设置为终端特有的初始化功能。</target>
        </trans-unit>
        <trans-unit id="c2df18475dff27329715d9ae9944a0845bdbbdd4" translate="yes" xml:space="preserve">
          <source>After these mandatory arguments follow the keyword arguments. The most important is &lt;code&gt;:type&lt;/code&gt;, which describes the data type we want to match with this widget. Here a &lt;code&gt;binary-tree-of-string&lt;/code&gt; is described as being either a string, or a cons-cell whose car and cdr are themselves both &lt;code&gt;binary-tree-of-string&lt;/code&gt;. Note the reference to the widget type we are currently in the process of defining. The &lt;code&gt;:tag&lt;/code&gt; attribute is a string to name the widget in the user interface, and the &lt;code&gt;:offset&lt;/code&gt; argument is there to ensure that child nodes are indented four spaces relative to the parent node, making the tree structure apparent in the customization buffer.</source>
          <target state="translated">在这些必填参数之后，跟随关键字参数。最重要的是 &lt;code&gt;:type&lt;/code&gt; ，它描述了我们要与此小部件匹配的数据类型。在这里， &lt;code&gt;binary-tree-of-string&lt;/code&gt; 被描述为字符串，或者是cons-cell，其car和cdr本身都是 &lt;code&gt;binary-tree-of-string&lt;/code&gt; 。请注意对我们当前正在定义的窗口小部件类型的引用。的 &lt;code&gt;:tag&lt;/code&gt; 属性是一个字符串来命名在用户界面窗口小部件，并且 &lt;code&gt;:offset&lt;/code&gt; 参数是有保证的子节点被缩进相对于父节点四个空间，使得树结构在定制缓冲器显而易见。</target>
        </trans-unit>
        <trans-unit id="fdf9c94744bf9492e6805756a0c97707a0c90bae" translate="yes" xml:space="preserve">
          <source>After writing your C code for a module function, you should make a Lisp function object from it using the &lt;code&gt;make_function&lt;/code&gt; function, whose pointer is provided in the environment (recall that the pointer to the environment is returned by &lt;code&gt;get_environment&lt;/code&gt;). This is normally done in the module initialization function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;), after verifying the</source>
          <target state="translated">在为模块函数编写C代码之后，您应该使用 &lt;code&gt;make_function&lt;/code&gt; 函数从中创建Lisp函数对象，该函数的指针在环境中提供（请注意，指向环境的指针由 &lt;code&gt;get_environment&lt;/code&gt; 返回）。通常，在验证以下内容后，即可在模块初始化功能（请参见&lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;模块初始化功能&lt;/a&gt;）中完成此操作</target>
        </trans-unit>
        <trans-unit id="01273641f1108e9334b3ff2f2de5aac2328b0349" translate="yes" xml:space="preserve">
          <source>After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must &lt;em&gt;finish&lt;/em&gt; the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.</source>
          <target state="translated">激活更改组后，您在该缓冲区中进行的所有更改都将成为其中的一部分。在缓冲区中&lt;em&gt;完成&lt;/em&gt;所有所需的更改后，必须&lt;em&gt;完成&lt;/em&gt;更改组。有两种方法可以执行此操作：您可以接受（确定）所有更改，也可以全部取消。</target>
        </trans-unit>
        <trans-unit id="156a361715177a7a195a547edfc720451b956bc1" translate="yes" xml:space="preserve">
          <source>After you create an archive, remember that it is not accessible in the Package Menu interface unless it is in &lt;code&gt;package-archives&lt;/code&gt;.</source>
          <target state="translated">创建归档文件后，请记住，除非它在 &lt;code&gt;package-archives&lt;/code&gt; 中,否则无法在Package Menu界面中访问它。</target>
        </trans-unit>
        <trans-unit id="e6177c7642a19bf3ac0b659b32ac63c9a38ada82" translate="yes" xml:space="preserve">
          <source>After you think you have fixed the problem, use</source>
          <target state="translated">在您认为您已经解决了问题之后,使用</target>
        </trans-unit>
        <trans-unit id="26afb7a30b02ada3701025dcae553b3342d65c03" translate="yes" xml:space="preserve">
          <source>Alias Menu Items</source>
          <target state="translated">别名菜单项目</target>
        </trans-unit>
        <trans-unit id="4ecfd05f5c4a9c12f77ec0ab644b70282ba9ee84" translate="yes" xml:space="preserve">
          <source>Alist with elements</source>
          <target state="translated">包含元素的列表</target>
        </trans-unit>
        <trans-unit id="4a7098b2dd254466abcb5233fdc2c39c1c9bc767" translate="yes" xml:space="preserve">
          <source>Alists for fine-tuning buffer display.</source>
          <target state="translated">用于微调缓冲区显示的列表。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="a745dcd86b59cafb3c0ca3bc7c385a6602657fcf" translate="yes" xml:space="preserve">
          <source>All &lt;var&gt;exp&lt;/var&gt;s are evaluated first, after which they are matched against their respective &lt;var&gt;pattern&lt;/var&gt;, introducing new variable bindings that can then be used inside &lt;var&gt;body&lt;/var&gt;. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">首先评估所有 &lt;var&gt;exp&lt;/var&gt; ，然后将它们与各自的 &lt;var&gt;pattern&lt;/var&gt; 匹配，引入新的变量绑定，然后可以在 &lt;var&gt;body&lt;/var&gt; 内部使用。可变绑定是通过将 &lt;var&gt;pattern&lt;/var&gt; 元素与已评估 &lt;var&gt;exp&lt;/var&gt; 的相应元素的值解构而生成的。</target>
        </trans-unit>
        <trans-unit id="aa4b6e4b0a07d4d70f84e83caad6fff48d32fad3" translate="yes" xml:space="preserve">
          <source>All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.</source>
          <target state="translated">所有Emacs Lisp数组都是一维的。(大多数其他编程语言都支持多维数组,但它们并不是必不可少的;你可以用嵌套的一维数组获得同样的效果。)每种类型的数组都有自己的读取语法,详情请看下面的章节。</target>
        </trans-unit>
        <trans-unit id="78dab1ef3770dfe21362526370a14bdcd828cdca" translate="yes" xml:space="preserve">
          <source>All arguments are instrumented for evaluation.</source>
          <target state="translated">所有的参数都是通过工具进行评估的。</target>
        </trans-unit>
        <trans-unit id="b6a1d847b868b0a62fa982b38796821b2fb0c23f" translate="yes" xml:space="preserve">
          <source>All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; returns the one element list &lt;code&gt;(0.4)&lt;/code&gt;, whereas &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; returns a list with three elements. The &lt;var&gt;n&lt;/var&gt;th element of the list is computed by the exact formula &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt;. Thus, if one wants to make sure that &lt;var&gt;to&lt;/var&gt; is included in the list, one can pass an expression of this exact type for &lt;var&gt;to&lt;/var&gt;. Alternatively, one can replace &lt;var&gt;to&lt;/var&gt; with a slightly larger value (or a slightly more negative value if &lt;var&gt;separation&lt;/var&gt; is negative).</source>
          <target state="translated">所有参数都是数字。浮点参数可能很棘手，因为浮点算法不精确。例如，根据机器的不同，很可能会发生 &lt;code&gt;(number-sequence 0.4 0.6 0.2)&lt;/code&gt; 返回一个元素列表 &lt;code&gt;(0.4)&lt;/code&gt; ，而 &lt;code&gt;(number-sequence 0.4 0.8 0.2)&lt;/code&gt; 返回具有三个元素的列表的情况。列表的第 &lt;var&gt;n&lt;/var&gt; 个元素由精确的公式 &lt;code&gt;(+ &lt;var&gt;from&lt;/var&gt; (* &lt;var&gt;n&lt;/var&gt; &lt;var&gt;separation&lt;/var&gt;))&lt;/code&gt; 计算得出。因此，如果要确保将 &lt;var&gt;to&lt;/var&gt; 包含在列表中，可以为 &lt;var&gt;to&lt;/var&gt; 传递此确切类型的表达式。或者，可以替换 &lt;var&gt;to&lt;/var&gt; 值稍大（如果 &lt;var&gt;separation&lt;/var&gt; 为负，则为负）。</target>
        </trans-unit>
        <trans-unit id="2208c34161ce80d7a782807d1e4cec6e6a7dd001" translate="yes" xml:space="preserve">
          <source>All breakpoints in a definition are forgotten each time you reinstrument it. If you wish to make a breakpoint that won&amp;rsquo;t be forgotten, you can write a &lt;em&gt;source breakpoint&lt;/em&gt;, which is simply a call to the function &lt;code&gt;edebug&lt;/code&gt; in your source code. You can, of course, make such a call conditional. For example, in the &lt;code&gt;fac&lt;/code&gt; function, you can insert the first line as shown below, to stop when the argument reaches zero:</source>
          <target state="translated">每次重新定义时，定义中的所有断点都会被忘记。如果您希望创建一个不会被遗忘的断点，则可以编写&lt;em&gt;源断点&lt;/em&gt;，它只是在源代码中对 &lt;code&gt;edebug&lt;/code&gt; 函数的调用。当然，您可以有条件地进行此类呼叫。例如，在 &lt;code&gt;fac&lt;/code&gt; 函数中，您可以插入第一行，如下所示，以在参数达到零时停止：</target>
        </trans-unit>
        <trans-unit id="9bb2b7fe1708d34d491b12dd030e589c31b4ac12" translate="yes" xml:space="preserve">
          <source>All built-in functions do check the types of their actual arguments when appropriate, and signal a &lt;code&gt;wrong-type-argument&lt;/code&gt; error if an argument is of the wrong type. For example, here is what happens if you pass an argument to &lt;code&gt;+&lt;/code&gt; that it cannot handle:</source>
          <target state="translated">所有内置函数都会在适当的时候检查其实际参数的类型，如果参数 &lt;code&gt;wrong-type-argument&lt;/code&gt; 错误，则会发出错误的类型参数错误。例如，如果将参数传递给 &lt;code&gt;+&lt;/code&gt; 无法处理，则会发生以下情况：</target>
        </trans-unit>
        <trans-unit id="0a8b2cb5ecd2f67ffd2840d4654471062074ad24" translate="yes" xml:space="preserve">
          <source>All buttons have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;button&lt;/code&gt; property, which may be useful in finding regions of text that comprise buttons (which is what the standard button functions do).</source>
          <target state="translated">所有按钮都具有非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;button&lt;/code&gt; 属性，这对于查找包含按钮的文本区域可能很有用（这是标准按钮功能的作用）。</target>
        </trans-unit>
        <trans-unit id="0de9e1669bff9ffa03c0a6b06c8fc7f25b299da9" translate="yes" xml:space="preserve">
          <source>All command loops, including recursive ones, set up all-purpose error handlers so that an error in a command run from the command loop will not exit the loop.</source>
          <target state="translated">所有的命令循环,包括递归的命令循环,都设置了万能的错误处理程序,这样从命令循环中运行的命令出现错误就不会退出循环。</target>
        </trans-unit>
        <trans-unit id="2bf532e176c9ef15e8a341ec22d44645c0ae9a2a" translate="yes" xml:space="preserve">
          <source>All connection-local variables, which are specified by &lt;code&gt;default-directory&lt;/code&gt;, are applied.</source>
          <target state="translated">将应用由 &lt;code&gt;default-directory&lt;/code&gt; 指定的所有连接局部变量。</target>
        </trans-unit>
        <trans-unit id="e7f6062bb49c083289ef91ea0670a9dad56b4214" translate="yes" xml:space="preserve">
          <source>All customization types are implemented as widgets; see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">所有定制类型都以小部件的形式实现；看到&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;介绍&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="dca342b020ceabede3de91c0d8473d75e1b019c2" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are optional; as soon as one does not match, Edebug stops matching at this level.</source>
          <target state="translated">规范列表中的以下所有元素都是可选的,只要有一个不符合,Edebug就会在这个级别停止匹配。</target>
        </trans-unit>
        <trans-unit id="2c01d7a4983336c611392d0fc00fd2b83de2bc6d" translate="yes" xml:space="preserve">
          <source>All following elements in the specification list are repeated zero or more times. In the last repetition, however, it is not a problem if the expression runs out before matching all of the elements of the specification list.</source>
          <target state="translated">规格列表中的所有后续元素都会重复零次或多次。但在最后一次重复中,如果表达式在匹配规格表的所有元素之前就用完了,也没有问题。</target>
        </trans-unit>
        <trans-unit id="25b37db993c79b5143fd020bfa5984f4943de615" translate="yes" xml:space="preserve">
          <source>All four kinds of array share these characteristics:</source>
          <target state="translated">这四种阵列都有这些特点。</target>
        </trans-unit>
        <trans-unit id="b65738468b638316e78cf6dcd55faa5077ce8a18" translate="yes" xml:space="preserve">
          <source>All functions defined in this library are free of side-effects; i.e., they do not modify any sequence (list, vector, or string) that you pass as an argument. Unless otherwise stated, the result is a sequence of the same type as the input. For those functions that take a predicate, this should be a function of one argument.</source>
          <target state="translated">在这个库中定义的所有函数都是没有副作用的,也就是说,它们不会修改你作为参数传递的任何序列(list、vector或string)。除非另有说明,否则结果是一个与输入相同类型的序列。对于那些接受谓词的函数,这应该是一个参数的函数。</target>
        </trans-unit>
        <trans-unit id="c71e30856d625975a83aead946dd7f4e5c8c274a" translate="yes" xml:space="preserve">
          <source>All functions that create markers without accepting an argument that specifies the insertion type, create them with insertion type &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;Creating Markers&lt;/a&gt;). Also, the mark has, by default, insertion type &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">所有创建标记但不接受指定插入类型的参数的函数，请使用插入类型 &lt;code&gt;nil&lt;/code&gt; 创建它们（请参见&lt;a href=&quot;creating-markers#Creating-Markers&quot;&gt;创建标记&lt;/a&gt;）。另外，默认情况下，标记的插入类型为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e5df34fc50a10cee1104c398dc0d288148f5677" translate="yes" xml:space="preserve">
          <source>All numbers can be compared with &lt;code&gt;eql&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;; fixnums can also be compared with &lt;code&gt;eq&lt;/code&gt;. To test whether an integer is a fixnum or a bignum, you can compare it to &lt;code&gt;most-negative-fixnum&lt;/code&gt; and &lt;code&gt;most-positive-fixnum&lt;/code&gt;, or you can use the convenience predicates &lt;code&gt;fixnump&lt;/code&gt; and &lt;code&gt;bignump&lt;/code&gt; on any object.</source>
          <target state="translated">所有数字都可以与 &lt;code&gt;eql&lt;/code&gt; 或 &lt;code&gt;=&lt;/code&gt; 进行比较；fixnums也可以与 &lt;code&gt;eq&lt;/code&gt; 比较。要测试整数是fixnum还是bignum，可以将其与 &lt;code&gt;most-negative-fixnum&lt;/code&gt; 和 &lt;code&gt;most-positive-fixnum&lt;/code&gt; 进行比较，或者可以在任何对象上使用便捷谓词 &lt;code&gt;fixnump&lt;/code&gt; 和 &lt;code&gt;bignump&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2c85ce8bd7457b271669cf5c05e295e1385ce6f" translate="yes" xml:space="preserve">
          <source>All of the &lt;var&gt;value-form&lt;/var&gt;s in &lt;var&gt;bindings&lt;/var&gt; are evaluated in the order they appear and &lt;em&gt;before&lt;/em&gt; binding any of the symbols to them. Here is an example of this: &lt;code&gt;z&lt;/code&gt; is bound to the old value of &lt;code&gt;y&lt;/code&gt;, which is 2, not the new value of &lt;code&gt;y&lt;/code&gt;, which is 1.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 中的所有 &lt;var&gt;value-form&lt;/var&gt; s均按它们出现的顺序进行评估，然后&lt;em&gt;再将&lt;/em&gt;任何符号绑定到它们。这是一个示例： &lt;code&gt;z&lt;/code&gt; 绑定到 &lt;code&gt;y&lt;/code&gt; 的旧值2，而不是 &lt;code&gt;y&lt;/code&gt; 的新值1。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb57c7da298437e1c1c392f0acf73eba41691d75" translate="yes" xml:space="preserve">
          <source>All of the deletion functions operate on the current buffer.</source>
          <target state="translated">所有的删除功能都是在当前的缓冲区上操作。</target>
        </trans-unit>
        <trans-unit id="af4a5a5cd065f9f5dbe42b33024e60fb527b8391" translate="yes" xml:space="preserve">
          <source>All of the functions described below are actually &lt;em&gt;function pointers&lt;/em&gt; provided via the pointer to the environment which every module function accepts. Therefore, module code should call these functions through the environment pointer, like this:</source>
          <target state="translated">下面描述的所有功能实际上都是通过指向每个模块功能都接受的环境的&lt;em&gt;指针&lt;/em&gt;提供的&lt;em&gt;功能指针&lt;/em&gt;。因此，模块代码应通过环境指针调用这些函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="2486aadd4696b33394cf13a628e5e81f8336dc69" translate="yes" xml:space="preserve">
          <source>All of these keywords, except &lt;code&gt;:tag&lt;/code&gt;, can be used more than once in a given item. Each use of the keyword has an independent effect. The keyword &lt;code&gt;:tag&lt;/code&gt; is an exception because any given item can only display one name.</source>
          <target state="translated">除了 &lt;code&gt;:tag&lt;/code&gt; 以外，所有这些关键字都可以在给定项目中多次使用。每次使用关键字都有独立的作用。关键字 &lt;code&gt;:tag&lt;/code&gt; 是个例外，因为任何给定的项目只能显示一个名称。</target>
        </trans-unit>
        <trans-unit id="7c58a8aa90e29eb8cc586744cbf0bae2b76d1c9b" translate="yes" xml:space="preserve">
          <source>All the Emacs primitives for file access and file name transformation check the given file name against &lt;code&gt;file-name-handler-alist&lt;/code&gt;. If the file name matches &lt;var&gt;regexp&lt;/var&gt;, the primitives handle that file by calling &lt;var&gt;handler&lt;/var&gt;.</source>
          <target state="translated">所有用于文件访问和文件名转换的Emacs原语都会根据 &lt;code&gt;file-name-handler-alist&lt;/code&gt; 检查给定的文件名。如果文件名与 &lt;var&gt;regexp&lt;/var&gt; 相匹配，则原语通过调用 &lt;var&gt;handler&lt;/var&gt; 处理该文件。</target>
        </trans-unit>
        <trans-unit id="9a0d1e07e928a09c5cfab793d66c3b83e32a68e0" translate="yes" xml:space="preserve">
          <source>All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the &lt;code&gt;enable-multibyte-characters&lt;/code&gt; flag (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;), etc.</source>
          <target state="translated">与缓冲区文本相关的所有缓冲区属性也被交换：点和标记的位置，所有标记，覆盖图，文本属性，撤消列表， &lt;code&gt;enable-multibyte-characters&lt;/code&gt; 标志的值（请参见&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;enable-multibyte-characters&lt;/a&gt;）等</target>
        </trans-unit>
        <trans-unit id="41d1c4b0b8ba4df658a7d43aad707edd6505e753" translate="yes" xml:space="preserve">
          <source>All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an &lt;em&gt;absolute&lt;/em&gt; file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a &lt;em&gt;relative&lt;/em&gt; file name. On GNU and other POSIX-like systems, after any leading &amp;lsquo;</source>
          <target state="translated">文件系统中的所有目录都从根目录开始形成一棵树。文件名可以指定从树的根开始的所有目录名；那么它被称为&lt;em&gt;绝对&lt;/em&gt;文件名。或者它可以指定文件在树中相对于默认目录的位置；然后称为&lt;em&gt;相对&lt;/em&gt;文件名。在GNU和其他类似POSIX的系统上，</target>
        </trans-unit>
        <trans-unit id="6d03c2077a45424604dd5945928dd7d581573444" translate="yes" xml:space="preserve">
          <source>All the flags except &amp;lsquo;</source>
          <target state="translated">除&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1fa32ceee23a50f9250c28b0af70936b4c7fea6b" translate="yes" xml:space="preserve">
          <source>All the following functions take an optional list of keyword parameters that alter the various attributes from their default values. Valid attributes include:</source>
          <target state="translated">下面的所有函数都采用了一个可选的关键字参数列表,用于改变各种属性的默认值。有效的属性包括:</target>
        </trans-unit>
        <trans-unit id="fd4e3414635a6335aabdd75003f817dd7df606f1" translate="yes" xml:space="preserve">
          <source>All the operations that transfer text in and out of Emacs have the ability to use a coding system to encode or decode the text. You can also explicitly encode and decode text using the functions in this section.</source>
          <target state="translated">所有将文本传入和传出Emacs的操作都可以使用编码系统对文本进行编码或解码。您也可以使用本节中的函数对文本进行显式编码和解码。</target>
        </trans-unit>
        <trans-unit id="3d0ec5a014b164fea677713adc2d6869587a38a2" translate="yes" xml:space="preserve">
          <source>All the remaining elements (if any) are collectively called &lt;var&gt;other-vars&lt;/var&gt;. Each of these elements should have the form &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;&amp;mdash;which means, make &lt;var&gt;variable&lt;/var&gt; buffer-local and then set it to &lt;var&gt;value&lt;/var&gt;. You can use these &lt;var&gt;other-vars&lt;/var&gt; to set other variables that affect fontification, aside from those you can control with the first five elements. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">其余所有元素（如果有）统称为 &lt;var&gt;other-vars&lt;/var&gt; 。这些元件的每应具有的形式 &lt;code&gt;(&lt;var&gt;variable&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 哪位装置，使 &lt;var&gt;variable&lt;/var&gt; 缓冲器的本地和然后将其设置为 &lt;var&gt;value&lt;/var&gt; 。除了可以使用前五个元素控制的变量以外，还可以使用这些 &lt;var&gt;other-vars&lt;/var&gt; 来设置影响字体化的其他变量。请参阅&lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;其他字体锁定变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eef34056c9664b484982e4f51615ce7ab9a41812" translate="yes" xml:space="preserve">
          <source>All the specification characters allow an optional &lt;em&gt;precision&lt;/em&gt; after the field number, flags and width, if present. The precision is a decimal-point &amp;lsquo;</source>
          <target state="translated">所有规范字符都允许在字段号，标志和宽度（如果存在）之后的可选&lt;em&gt;精度&lt;/em&gt;。精度是小数点&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ca4ef7026f0627fed1dbae0beb181539bc4f6f15" translate="yes" xml:space="preserve">
          <source>All the usual rules for documentation strings in Lisp code (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;) apply to C code documentation strings too.</source>
          <target state="translated">Lisp代码中文档字符串的所有常规规则（请参阅&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;文档提示&lt;/a&gt;）也适用于C代码文档字符串。</target>
        </trans-unit>
        <trans-unit id="58d526aa213005ab745d03bed480a0d5feb42ba3" translate="yes" xml:space="preserve">
          <source>All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;call-process-region&lt;/code&gt;, these come in the form of a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, &lt;var&gt;args&lt;/var&gt;. For &lt;code&gt;make-process&lt;/code&gt;, both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.</source>
          <target state="translated">创建子进程的所有三个功能均允许为运行的进程指定命令行参数。对于 &lt;code&gt;call-process&lt;/code&gt; 和 &lt;code&gt;call-process-region&lt;/code&gt; ，它们以 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 参数 &lt;var&gt;args&lt;/var&gt; 的形式出现。对于 &lt;code&gt;make-process&lt;/code&gt; ，要运行的程序及其命令行参数均指定为字符串列表。命令行参数必须全部为字符串，并且它们作为单独的参数字符串提供给程序。通配符和其他shell构造在这些字符串中没有特殊含义，因为这些字符串直接传递到指定的程序。</target>
        </trans-unit>
        <trans-unit id="0dd2c1f56aad50efd70754bd7b0f1448e6dee489" translate="yes" xml:space="preserve">
          <source>All you need to do is add a &lt;code&gt;declare-function&lt;/code&gt; statement before the first use of the function in question:</source>
          <target state="translated">您需要做的就是在首次使用该函数之前添加一个 &lt;code&gt;declare-function&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="83a5fc8fd0c6232ad2485feb2941be6df4658ce5" translate="yes" xml:space="preserve">
          <source>Allow &lt;var&gt;command&lt;/var&gt; (a symbol) to be executed without special confirmation from now on, and alter the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) so that this will apply to future sessions.</source>
          <target state="translated">从现在开始，允许 &lt;var&gt;command&lt;/var&gt; （符号）而无需特殊确认，并更改用户的init文件（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;），以便将其应用于将来的会话。</target>
        </trans-unit>
        <trans-unit id="fbe56df0c14a0941bf2865207a4eec4975a429b2" translate="yes" xml:space="preserve">
          <source>Almost all the messages displayed in the echo area are also recorded in the</source>
          <target state="translated">几乎所有显示在回音区的信息也都被记录在回音区中。</target>
        </trans-unit>
        <trans-unit id="0a6cdeb0d1c09e0504231be0c620803ea8ce80be" translate="yes" xml:space="preserve">
          <source>Along with the mandatory &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, users of the &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; class should pass the following initargs as keyword-value pairs to &lt;code&gt;make-instance&lt;/code&gt;:</source>
          <target state="translated">与强制性的 &lt;code&gt;:request-dispatcher&lt;/code&gt; 和 &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs一起， &lt;code&gt;jsonrpc-process-connection&lt;/code&gt; 类的用户应将以下initargs作为关键字-值对传递给 &lt;code&gt;make-instance&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="986ce8469a3d5002d455b0f41722b9928e133cc8" translate="yes" xml:space="preserve">
          <source>Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.</source>
          <target state="translated">字母排序是指通过比较两个排序键各自的第一个字符、第二个字符,以此类推。如果发现不匹配,则表示排序键不相等,第一次不匹配时字符较少的排序键为较少的排序键。各个字符按照Emacs字符集中的数字字符代码进行比较。</target>
        </trans-unit>
        <trans-unit id="3397c8f08539eaf212b8a514976581cd47575863" translate="yes" xml:space="preserve">
          <source>Also by convention, the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in a list is &lt;code&gt;nil&lt;/code&gt;. We call such a &lt;code&gt;nil&lt;/code&gt;-terminated structure a &lt;em&gt;proper list&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list with no elements. For convenience, the symbol &lt;code&gt;nil&lt;/code&gt; is considered to have &lt;code&gt;nil&lt;/code&gt; as its &lt;small&gt;CDR&lt;/small&gt; (and also as its &lt;small&gt;CAR&lt;/small&gt;).</source>
          <target state="translated">同样按照惯例，列表中最后一个cons单元的&lt;small&gt;CDR&lt;/small&gt;为 &lt;code&gt;nil&lt;/code&gt; 。我们称这样的 &lt;code&gt;nil&lt;/code&gt; 封端的结构的&lt;em&gt;适当列表&lt;/em&gt;&lt;a href=&quot;#FOOT3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;。在Emacs Lisp中，符号 &lt;code&gt;nil&lt;/code&gt; 既是符号又是没有元素的列表。为方便起见，符号 &lt;code&gt;nil&lt;/code&gt; 被视为 &lt;code&gt;nil&lt;/code&gt; 作为其&lt;small&gt;CDR&lt;/small&gt;（以及其&lt;small&gt;CAR&lt;/small&gt;）。</target>
        </trans-unit>
        <trans-unit id="fff39e0b11dcde645d91107c5004ab17b6696524" translate="yes" xml:space="preserve">
          <source>Also note that this variable is not meant to be a generic facility for accessing external libraries; only those already known by Emacs can be loaded through it.</source>
          <target state="translated">另外要注意的是,这个变量并不是用来访问外部库的通用工具,只有那些Emacs已经知道的库才可以通过它来加载。</target>
        </trans-unit>
        <trans-unit id="b0218093aabf50731b0dfd5f6bc99d6da5f04d9a" translate="yes" xml:space="preserve">
          <source>Also see &lt;code&gt;edebug-tracing&lt;/code&gt;, in &lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;Trace Buffer&lt;/a&gt;.</source>
          <target state="translated">另见 &lt;code&gt;edebug-tracing&lt;/code&gt; ，在&lt;a href=&quot;trace-buffer#Trace-Buffer&quot;&gt;跟踪缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d0d7b652d689c605bbb8e508dce118b76e3835d" translate="yes" xml:space="preserve">
          <source>Also see the following function.</source>
          <target state="translated">也请看下面的功能。</target>
        </trans-unit>
        <trans-unit id="f91d8e06c0823bced203ecdc95d5ffb09f2dca97" translate="yes" xml:space="preserve">
          <source>Also see the functions &lt;code&gt;bolp&lt;/code&gt; and &lt;code&gt;eolp&lt;/code&gt; in &lt;a href=&quot;near-point#Near-Point&quot;&gt;Near Point&lt;/a&gt;. These functions do not move point, but test whether it is already at the beginning or end of a line.</source>
          <target state="translated">另请参见功能 &lt;code&gt;bolp&lt;/code&gt; 和 &lt;code&gt;eolp&lt;/code&gt; 在&lt;a href=&quot;near-point#Near-Point&quot;&gt;近点&lt;/a&gt;。这些函数不会移动点，而是测试它是否已经在行的开头或结尾。</target>
        </trans-unit>
        <trans-unit id="1c151f9dd941153aa652ba089e31237c83748274" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, this function does not delete any window whose &lt;code&gt;no-delete-other-windows&lt;/code&gt; parameter is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">另外，如果 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，此函数不删除其任何窗口 &lt;code&gt;no-delete-other-windows&lt;/code&gt; 的参数是不 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7732936fed3ff7cd50aeba214305d9cb5cc02021" translate="yes" xml:space="preserve">
          <source>Also, inline functions do not behave well with respect to debugging, tracing, and advising (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it&amp;rsquo;s small, unless its speed is really crucial, and you&amp;rsquo;ve timed the code to verify that using &lt;code&gt;defun&lt;/code&gt; actually has performance problems.</source>
          <target state="translated">此外，内联函数在调试，跟踪和建议方面也不佳（请参阅&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising函数&lt;/a&gt;）。由于易于调试和灵活地重新定义函数是Emacs的重要功能，因此即使函数很小，也不应使其内联，除非它的速度非常关键，并且您已对代码进行定时以验证使用 &lt;code&gt;defun&lt;/code&gt; 确实具有性能问题。</target>
        </trans-unit>
        <trans-unit id="3a284929ebe4ecbc4627599844c16f8ee2075a18" translate="yes" xml:space="preserve">
          <source>Also, this variable is bound to non-&lt;code&gt;nil&lt;/code&gt; while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. However, doing this may cause recursive calls to the modification hooks, so be sure to prepare for that (for example, by binding some variable which tells your hook to do nothing).</source>
          <target state="translated">另外，在运行这些相同的挂钩变量时，此变量绑定为 &lt;code&gt;nil&lt;/code&gt; ，因此默认情况下，从修改挂钩修改缓冲区不会导致其他修改挂钩运行。如果您确实希望在特定代码段中运行修改钩子，而该代码本身是从修改钩子运行的，则将本地 &lt;code&gt;inhibit-modification-hooks&lt;/code&gt; 重新绑定到 &lt;code&gt;nil&lt;/code&gt; 。但是，这样做可能会导致对修改钩子的递归调用，因此请确保为此做准备（例如，通过绑定一些告诉钩子什么都不做的变量）。</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="a5a07d26b576b4c962f39501eaa335d2542ec41a" translate="yes" xml:space="preserve">
          <source>Alt-Hyper-Meta-x</source>
          <target state="translated">Alt-Hyper-Meta-x</target>
        </trans-unit>
        <trans-unit id="ce59e9b5171b68822f40796bb3f0c52339cf67a2" translate="yes" xml:space="preserve">
          <source>Alt-TAB</source>
          <target state="translated">Alt-TAB</target>
        </trans-unit>
        <trans-unit id="3569cde666bf1d56550417379b59c63f9186f81c" translate="yes" xml:space="preserve">
          <source>Altering List Elements with setcar</source>
          <target state="translated">用setcar改变列表元素</target>
        </trans-unit>
        <trans-unit id="c23b06af6029fc510471e91f93630d6b95133fec" translate="yes" xml:space="preserve">
          <source>Altering the CDR of a List</source>
          <target state="translated">更改列表的CDR</target>
        </trans-unit>
        <trans-unit id="32b911a69c85aa2eed0e0429593ee1d599f1648f" translate="yes" xml:space="preserve">
          <source>Altering the contents of an existing string.</source>
          <target state="translated">改变现有字符串的内容。</target>
        </trans-unit>
        <trans-unit id="03e916d44308e382702efa38414c976b82eebcbb" translate="yes" xml:space="preserve">
          <source>Alternative foreground color, a string. This is like &lt;code&gt;:foreground&lt;/code&gt; but the color is only used as a foreground when the background color is near to the foreground that would have been used. This is useful for example when marking text (i.e., the region face). If the text has a foreground that is visible with the region face, that foreground is used. If the foreground is near the region face background, &lt;code&gt;:distant-foreground&lt;/code&gt; is used instead so the text is readable.</source>
          <target state="translated">替代前景颜色，字符串。就像 &lt;code&gt;:foreground&lt;/code&gt; 一样,但是只有当背景色接近将要使用的前景时，该颜色才用作前景。例如，在标记文本（即区域面）时，这很有用。如果文本的前景在区域面中可见，则使用该前景。如果前景在区域面部背景附近，则使用 &lt;code&gt;:distant-foreground&lt;/code&gt; 代替，以便使文本可读。</target>
        </trans-unit>
        <trans-unit id="b201fde3a76a13fb565d2139c2505d62747c3f3d" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;var&gt;menu&lt;/var&gt; can have the following form:</source>
          <target state="translated">另外， &lt;var&gt;menu&lt;/var&gt; 可以采用以下形式：</target>
        </trans-unit>
        <trans-unit id="612d416a8c5c9032e5eee36eda3e173bd67f6d8e" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a list with the same format as &lt;var&gt;menu&lt;/var&gt;. This is a submenu.</source>
          <target state="translated">或者，菜单项可以是与 &lt;var&gt;menu&lt;/var&gt; 格式相同的列表。这是一个子菜单。</target>
        </trans-unit>
        <trans-unit id="0f3215559a2b65437e72958763c4ad5ae7956797" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item can be a string. Then that string appears in the menu as unselectable text. A string consisting of dashes is displayed as a separator (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;).</source>
          <target state="translated">或者，菜单项可以是字符串。然后，该字符串作为不可选择的文本出现在菜单中。由破折号组成的字符串显示为分隔符（请参阅&lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;菜单分隔符&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f86166f09a2fa545f30584a0fa07bc98a8228018" translate="yes" xml:space="preserve">
          <source>Alternatively, a menu item may have the form:</source>
          <target state="translated">另外,一个菜单项目可以有以下形式:</target>
        </trans-unit>
        <trans-unit id="2a475682f68cc8d5942ac33225fa6641ddb131e3" translate="yes" xml:space="preserve">
          <source>Alternatively, an &lt;code&gt;interactive&lt;/code&gt; form may be specified in a function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property. A non-&lt;code&gt;nil&lt;/code&gt; value for this property takes precedence over any &lt;code&gt;interactive&lt;/code&gt; form in the function body itself. This feature is seldom used.</source>
          <target state="translated">可替换地， &lt;code&gt;interactive&lt;/code&gt; 形式可以以一个函数的符号的指定 &lt;code&gt;interactive-form&lt;/code&gt; 属性。此属性的非 &lt;code&gt;nil&lt;/code&gt; 值优先于函数主体本身中的任何 &lt;code&gt;interactive&lt;/code&gt; 形式。很少使用此功能。</target>
        </trans-unit>
        <trans-unit id="70290e19eb34b55b8e6acff0975f8bd70f0b8116" translate="yes" xml:space="preserve">
          <source>Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.</source>
          <target state="translated">另外,每当拆分或删除一个窗口时,总是以相同的组合调整所有窗口的大小,就可以避免上述问题。这也允许拆分窗口,否则窗口太小,无法进行这种操作。</target>
        </trans-unit>
        <trans-unit id="b26670ac06db641e3e84463f0ad2daa068f83654" translate="yes" xml:space="preserve">
          <source>Alternatively, the value can specify the bitmap directly, with a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the size in pixels, and &lt;var&gt;data&lt;/var&gt; is a string containing the raw bits of the bitmap, row by row. Each row occupies &lt;em&gt;(&lt;var&gt;width&lt;/var&gt; + 7) / 8&lt;/em&gt; consecutive bytes in the string (which should be a unibyte string for best results). This means that each row always occupies at least one whole byte.</source>
          <target state="translated">另外，该值可以直接指定位图，形式为 &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; 形式的列表。在这里， &lt;var&gt;width&lt;/var&gt; 和 &lt;var&gt;height&lt;/var&gt; 指定像素大小， &lt;var&gt;data&lt;/var&gt; 是一个字符串，其中包含位图的原始位，逐行。每行在字符串中占用&lt;em&gt;（ &lt;var&gt;width&lt;/var&gt; + 7）/ 8&lt;/em&gt;个连续字节（为了获得最佳结果，该字符串应为单字节字符串）。这意味着每一行总是至少占据一个完整的字节。</target>
        </trans-unit>
        <trans-unit id="3fffa4436d30acad881ee763e3e490d5b00c5e0b" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use the &lt;code&gt;with-current-buffer&lt;/code&gt; macro:</source>
          <target state="translated">另外，我们可以使用 &lt;code&gt;with-current-buffer&lt;/code&gt; 宏：</target>
        </trans-unit>
        <trans-unit id="b512dedf489786abd4f584013029d9c643312107" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.</source>
          <target state="translated">另外,你也可以通过提供代码来定义一个函数,并将其内联为一个编译器宏。下面的宏使之成为可能。</target>
        </trans-unit>
        <trans-unit id="a6177cf1ed61859e6ad146c7a2e9af66ea184b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; to &lt;code&gt;nil&lt;/code&gt;. In that case, the progress reporter does not report process percentages; it instead displays a &amp;ldquo;spinner&amp;rdquo; that rotates a notch each time you update the progress reporter.</source>
          <target state="translated">另外，您可以将 &lt;var&gt;min-value&lt;/var&gt; 和 &lt;var&gt;max-value&lt;/var&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 。在这种情况下，进度报告程序将不报告流程百分比。而是显示一个&amp;ldquo;微调框&amp;rdquo;，每当您更新进度报告器时，该微调框就会旋转一个凹口。</target>
        </trans-unit>
        <trans-unit id="92226f9d87069cd2db7b3d326f09e83f23a82036" translate="yes" xml:space="preserve">
          <source>Alternatively, you could use the &lt;code&gt;:stderr&lt;/code&gt; parameter with a non-&lt;code&gt;nil&lt;/code&gt; value in a call to &lt;code&gt;make-process&lt;/code&gt; (see &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.</source>
          <target state="translated">另外，您可以在对 &lt;code&gt;make-process&lt;/code&gt; 的调用中使用带有非 &lt;code&gt;nil&lt;/code&gt; 值的 &lt;code&gt;:stderr&lt;/code&gt; 参数（请参见&lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;make-process&lt;/a&gt;），以使错误输出的目标与标准输出分开；在这种情况下，Emacs将使用管道与子流程进行通信。</target>
        </trans-unit>
        <trans-unit id="67171d73924b845a3534e0ecdf7ce358ebf03943" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;(time-convert nil nil)&lt;/code&gt; is equivalent to &lt;code&gt;(current-time)&lt;/code&gt;, the latter may be a bit faster.</source>
          <target state="translated">尽管 &lt;code&gt;(time-convert nil nil)&lt;/code&gt; 等同于 &lt;code&gt;(current-time)&lt;/code&gt; ，但后者可能会更快一些。</target>
        </trans-unit>
        <trans-unit id="ada9e95e67f8cc5ff4fdc84a7549ab0fbfa66304" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;redisplay&lt;/code&gt; tries immediately to redisplay, it does not change how Emacs decides which parts of its frame(s) to redisplay. By contrast, the following function adds certain windows to the pending redisplay work (as if their contents had completely changed), but does not immediately try to perform redisplay.</source>
          <target state="translated">尽管 &lt;code&gt;redisplay&lt;/code&gt; 立即尝试重新显示，但它不会更改Emacs决定重新显示其框架的哪些部分的方式。相比之下，以下功能将某些窗口添加到挂起的重新显示工作中（就像它们的内容已完全更改一样），但是不会立即尝试执行重新显示。</target>
        </trans-unit>
        <trans-unit id="1b09322d9e876baf3954f8eeffbc89a79699d7f4" translate="yes" xml:space="preserve">
          <source>Although Emacs normally respects access permissions of the underlying operating system, in some cases it handles accesses specially. For example, file names can have handlers that treat the files specially, with their own access checking. See &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;. Also, a buffer can be read-only even if the corresponding file is writable, and vice versa, which can result in messages such as &amp;lsquo;</source>
          <target state="translated">尽管Emacs通常会尊重基础操作系统的访问权限，但在某些情况下，它会专门处理访问。例如，文件名可以具有使用其自身的访问检查来专门处理文件的处理程序。请参阅&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;魔术文件名&lt;/a&gt;。另外，即使相应的文件是可写的，缓冲区也可以是只读的，反之亦然，这可能导致出现诸如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="41aec9e3c0639b5cbc769510aa631eca22825357" translate="yes" xml:space="preserve">
          <source>Although a &amp;lsquo;</source>
          <target state="translated">虽然是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0f3c6c13e12239c0128c12d87359384cf4720010" translate="yes" xml:space="preserve">
          <source>Although a character alternative can include duplicates, it is better style to avoid them. For example, &amp;lsquo;</source>
          <target state="translated">尽管替代字符可以包含重复项，但最好避免重复。例如， '</target>
        </trans-unit>
        <trans-unit id="003ff1a62df2fa3817a8fd6c5d1dd5fe04cc547c" translate="yes" xml:space="preserve">
          <source>Although a range can denote just one, two, or three characters, it is simpler to list the characters. For example, &amp;lsquo;</source>
          <target state="translated">尽管一个范围只能表示一个，两个或三个字符，但是列出这些字符比较简单。例如， '</target>
        </trans-unit>
        <trans-unit id="743be7d85c6dff8ab2c12b47e5caa1355172e2a0" translate="yes" xml:space="preserve">
          <source>Although a range&amp;rsquo;s bound can be almost any character, it is better style to stay within natural sequences of ASCII letters and digits because most people have not memorized character code tables. For example, &amp;lsquo;</source>
          <target state="translated">尽管范围的边界几乎可以是任何字符，但最好将样式保留在ASCII字母和数字的自然序列内，因为大多数人没有记住字符代码表。例如， '</target>
        </trans-unit>
        <trans-unit id="a6f6b98c4f64609315a55f827d800190bc2958cc" translate="yes" xml:space="preserve">
          <source>Although both sorts of failures can largely be avoided by a suitably configured file system, such systems are typically more expensive or less efficient. In more-typical systems, to survive media failure you can copy the file to a different device, and to survive a power failure you can use the &lt;code&gt;write-region&lt;/code&gt; function with the &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; variable set to &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;.</source>
          <target state="translated">尽管可以通过适当配置的文件系统来避免两种类型的故障，但是此类系统通常更昂贵或更不高效。在更典型的系统中，要避免介质故障，您可以将文件复制到其他设备上，而要避免电源故障，可以使用 &lt;code&gt;write-region&lt;/code&gt; 函数，并将 &lt;code&gt;write-region-inhibit-fsync&lt;/code&gt; 变量设置为 &lt;code&gt;nil&lt;/code&gt; 。请参阅&lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;写入文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d6a6f038f930d539ab3543bcd22fa56a80436b0" translate="yes" xml:space="preserve">
          <source>Although completion is usually done in the minibuffer, the completion facility can also be used on the text in ordinary Emacs buffers. In many major modes, in-buffer completion is performed by the</source>
          <target state="translated">虽然完成通常是在minibuffer中完成,但完成设施也可以用于普通Emacs缓冲区中的文本。在许多主要模式中,缓冲区内的完成是由</target>
        </trans-unit>
        <trans-unit id="67fae8b88cdfb0b03098409367fbfcfd4933ca60" translate="yes" xml:space="preserve">
          <source>Although functions are usually defined with &lt;code&gt;defun&lt;/code&gt; and given names at the same time, it is sometimes convenient to use an explicit lambda expression&amp;mdash;an &lt;em&gt;anonymous function&lt;/em&gt;. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the &lt;var&gt;function&lt;/var&gt; argument to &lt;code&gt;mapcar&lt;/code&gt;, which applies that function to each element of a list (see &lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;Mapping Functions&lt;/a&gt;). See &lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;describe-symbols example&lt;/a&gt;, for a realistic example of this.</source>
          <target state="translated">尽管通常使用 &lt;code&gt;defun&lt;/code&gt; 和给定名称同时定义函数，但是有时使用显式lambda表达式（&lt;em&gt;匿名函数&lt;/em&gt;）会很方便。无论函数名称在哪里，匿名函数均有效。它们通常被分配为变量值或函数的参数。例如，您可以将一个作为 &lt;var&gt;function&lt;/var&gt; 参数传递给 &lt;code&gt;mapcar&lt;/code&gt; ，该函数将该函数应用于列表的每个元素（请参见&lt;a href=&quot;mapping-functions#Mapping-Functions&quot;&gt;映射函数&lt;/a&gt;）。有关此&lt;a href=&quot;accessing-documentation#describe_002dsymbols-example&quot;&gt;示例&lt;/a&gt;，请参阅describe-symbols示例。</target>
        </trans-unit>
        <trans-unit id="1be7de9f1b9c2d003e43c343730f7fd8d2bd62d3" translate="yes" xml:space="preserve">
          <source>Although numbers never change and all markers are mutable, some types have members some of which are mutable and others not. These types include conses, vectors, and strings. For example, although &lt;code&gt;&quot;cons&quot;&lt;/code&gt; and &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; both yield strings that should not be changed, &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; and &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; both yield mutable strings that can be changed via later calls to &lt;code&gt;aset&lt;/code&gt;.</source>
          <target state="translated">尽管数字永远不变，并且所有标记都是可变的，但某些类型的成员可变，而某些则不可变。这些类型包括cons，vector和string。例如，尽管 &lt;code&gt;&quot;cons&quot;&lt;/code&gt; 和 &lt;code&gt;(symbol-name 'cons)&lt;/code&gt; 都产生了不应更改的字符串，但 &lt;code&gt;(copy-sequence &quot;cons&quot;)&lt;/code&gt; 和 &lt;code&gt;(make-string 3 ?a)&lt;/code&gt; 都产生了可通过以下方式更改的可变字符串：以后打电话给 &lt;code&gt;aset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd89d9ee767436b48e243e1fec03f6f21ceca0df" translate="yes" xml:space="preserve">
          <source>Although packing and unpacking operations change the organization of data (in memory), they preserve the data&amp;rsquo;s &lt;em&gt;total length&lt;/em&gt;, which is the sum of all the fields&amp;rsquo; lengths, in bytes. This value is not generally inherent in either the specification or alist alone; instead, both pieces of information contribute to its calculation. Likewise, the length of a string or array being unpacked may be longer than the data&amp;rsquo;s total length as described by the specification.</source>
          <target state="translated">尽管打包和拆包操作会更改数据的组织（在内存中），但它们会保留数据的&lt;em&gt;总长度&lt;/em&gt;，即所有字段长度的总和（以字节为单位）。通常，此值不是规范本身或列表所固有的；相反，两条信息都有助于其计算。同样，要解包的字符串或数组的长度可能比规范描述的数据总长度长。</target>
        </trans-unit>
        <trans-unit id="d96567dd4450662d62d221615f9401c0781977ac" translate="yes" xml:space="preserve">
          <source>Although the expressions &lt;code&gt;(list '+ 1 2)&lt;/code&gt; and &lt;code&gt;'(+ 1 2)&lt;/code&gt; both yield lists equal to &lt;code&gt;(+ 1 2)&lt;/code&gt;, the former yields a freshly-minted mutable list whereas the latter yields a list built from conses that might be shared and should not be modified. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">尽管表达式 &lt;code&gt;(list '+ 1 2)&lt;/code&gt; 和 &lt;code&gt;'(+ 1 2)&lt;/code&gt; 都产生等于 &lt;code&gt;(+ 1 2)&lt;/code&gt; ，但前者产生的是新鲜的可变列表，而后者则产生了由可能共享的conses构建的列表并且不应修改。请参阅&lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;自我评估表格&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22404d7c1088551650eedf30d445b02f32c8b26a" translate="yes" xml:space="preserve">
          <source>Although the list &lt;code&gt;(0.5)&lt;/code&gt; was mutable when it was created, it should not have been changed via &lt;code&gt;setcar&lt;/code&gt; because it given to &lt;code&gt;eval&lt;/code&gt;. The reverse does not occur: an object that should not be changed never becomes mutable afterwards.</source>
          <target state="translated">尽管列表 &lt;code&gt;(0.5)&lt;/code&gt; 在创建时是可变的，但不应通过 &lt;code&gt;setcar&lt;/code&gt; 对其进行更改，因为它已赋给 &lt;code&gt;eval&lt;/code&gt; 。不会发生相反的情况：不应更改的对象之后永远不会变得可变。</target>
        </trans-unit>
        <trans-unit id="391c1ca03938de65f008bec7937cdacbb0a5f7c8" translate="yes" xml:space="preserve">
          <source>Although the portable dumper code can run on many platforms, the dump files that it produces are not portable&amp;mdash;they can be loaded only by the Emacs executable that dumped them.</source>
          <target state="translated">尽管可移植的转储程序代码可以在许多平台上运行，但是它生成的转储文件不是可移植的-它们只能由转储它们的Emacs可执行文件加载。</target>
        </trans-unit>
        <trans-unit id="6fa602a74e291da2cfde0e718a9868c53eb69aef" translate="yes" xml:space="preserve">
          <source>Although top-level calls to &lt;code&gt;require&lt;/code&gt; are evaluated during byte compilation, &lt;code&gt;provide&lt;/code&gt; calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a &lt;code&gt;provide&lt;/code&gt; followed by a &lt;code&gt;require&lt;/code&gt; for the same feature, as in the following example.</source>
          <target state="translated">尽管在字节编译过程中评估了对 &lt;code&gt;require&lt;/code&gt; 的顶级调用，但是 &lt;code&gt;provide&lt;/code&gt; 调用却没有。因此，您可以确保定义的文件被加载之前，它是字节编译通过，包括 &lt;code&gt;provide&lt;/code&gt; 后跟一个 &lt;code&gt;require&lt;/code&gt; 同一功能，如下面的例子。</target>
        </trans-unit>
        <trans-unit id="0d330d60bab6b0316e891e9303762414649958a9" translate="yes" xml:space="preserve">
          <source>Although traditionally Lisp timestamps were integer pairs, their form has evolved and programs ordinarily should not depend on the current default form. If your program needs a particular timestamp form, you can use the &lt;code&gt;time-convert&lt;/code&gt; function to convert it to the needed form. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">尽管传统上Lisp时间戳是整数对，但是它们的形式已经发展，并且程序通常不应该依赖于当前的默认形式。如果您的程序需要特定的时间戳格式，则可以使用 &lt;code&gt;time-convert&lt;/code&gt; 功能将其转换为所需的格式。请参阅&lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;时间转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03d337a2cc5120b55c2c85cdc5a80ad1a0f608d6" translate="yes" xml:space="preserve">
          <source>Always use the &lt;code&gt;:set&lt;/code&gt; function to initialize the variable. If the variable is already non-void, reset it by calling the &lt;code&gt;:set&lt;/code&gt; function using the current value (returned by the &lt;code&gt;:get&lt;/code&gt; method). This is the default &lt;code&gt;:initialize&lt;/code&gt; function.</source>
          <target state="translated">始终使用 &lt;code&gt;:set&lt;/code&gt; 函数初始化变量。如果变量已经是非空变量，则使用当前值（由 &lt;code&gt;:get&lt;/code&gt; 方法返回）调用 &lt;code&gt;:set&lt;/code&gt; 函数来将其重置。这是默认的 &lt;code&gt;:initialize&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3d4ac6bb796b287295b9fa9b0f33f9196a9c4247" translate="yes" xml:space="preserve">
          <source>Amongst other things, this function sets up the &lt;code&gt;comment-start&lt;/code&gt; variable to handle Lisp comments:</source>
          <target state="translated">除其他外，此函数设置 &lt;code&gt;comment-start&lt;/code&gt; 变量来处理Lisp注释：</target>
        </trans-unit>
        <trans-unit id="55327aa4b2861fca2f67242dee6031a0481c6441" translate="yes" xml:space="preserve">
          <source>An (efficient) array of characters.</source>
          <target state="translated">一个(有效的)字符数组。</target>
        </trans-unit>
        <trans-unit id="b24fa2adc3461b8097e9865ddc5d05a962a6075d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;end-of-file&lt;/code&gt; error is signaled if reading encounters an unterminated list, vector, or string.</source>
          <target state="translated">一个 &lt;code&gt;end-of-file&lt;/code&gt; 如果读取遇到未端接列表，载体，或串信号通知错误。</target>
        </trans-unit>
        <trans-unit id="4fa8eeb2346c8a9639fa3ee155f83ec1952beb3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action alist&lt;/em&gt; is an association list mapping predefined symbols recognized by action functions to values these functions are supposed to interpret accordingly. In each call, &lt;code&gt;display-buffer&lt;/code&gt; constructs a new, possibly empty action alist and passes that entire list on to any action function it calls.</source>
          <target state="translated">一个&lt;em&gt;动作ALIST&lt;/em&gt;是由行动功能认识到这些功能都应该相应地解释的值的关联列表的映射的预定义符号。在每个调用中， &lt;code&gt;display-buffer&lt;/code&gt; 构造一个新的可能为空的动作列表，并将整个列表传递给它调用的任何动作函数。</target>
        </trans-unit>
        <trans-unit id="6fbb202e704ca6497d62596b4b24317b48567731" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action function&lt;/em&gt; is a function &lt;code&gt;display-buffer&lt;/code&gt; calls for choosing a window to display a buffer. Action functions take two arguments: &lt;var&gt;buffer&lt;/var&gt;, the buffer to display, and &lt;var&gt;alist&lt;/var&gt;, an action alist (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). They are supposed to return a window displaying &lt;var&gt;buffer&lt;/var&gt; if they succeed and &lt;code&gt;nil&lt;/code&gt; if they fail.</source>
          <target state="translated">的&lt;em&gt;作用函数&lt;/em&gt;是一个函数 &lt;code&gt;display-buffer&lt;/code&gt; 用于选择窗口中显示缓冲器的呼叫。动作函数有两个参数： &lt;var&gt;buffer&lt;/var&gt; （要显示的缓冲区）和 &lt;var&gt;alist&lt;/var&gt; （一个动作&lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;列表&lt;/a&gt;）（请参阅Buffer Display Action Alists）。如果它们成功，应该返回一个显示 &lt;var&gt;buffer&lt;/var&gt; 的窗口，如果失败，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42d3eec2eded4ad1f09d03ecadb028b0fe97c946" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is a fixed-length object with a slot for each of its elements. All the elements are accessible in constant time. The four types of arrays are strings, vectors, char-tables and bool-vectors.</source>
          <target state="translated">一个&lt;em&gt;阵列&lt;/em&gt;是具有用于它的每个元素的一个时隙中的固定长度的对象。所有元素都可以在恒定时间内访问。数组的四种类型是字符串，向量，字符表和布尔向量。</target>
        </trans-unit>
        <trans-unit id="a4bee20b16add7aae2f3af434413439ac2fc3a32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)</source>
          <target state="translated">一个&lt;em&gt;阵列&lt;/em&gt;被用于保持或参照其它Lisp的目的，设置在一个连续的内存块组成时隙的任意数量的。访问数组的任何元素大约需要花费相同的时间。相反，访问列表中的元素需要的时间与该元素在列表中的位置成比例。（与列表开头的元素相比，列表末尾的元素需要更长的访问时间。）</target>
        </trans-unit>
        <trans-unit id="553ed232664b5e6ef74691641b0767d1d08a7cfd" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;array&lt;/em&gt; object has slots that hold a number of other Lisp objects, called the elements of the array. Any element of an array may be accessed in constant time. In contrast, the time to access an element of a list is proportional to the position of that element in the list.</source>
          <target state="translated">一个&lt;em&gt;阵列&lt;/em&gt;对象具有保持许多其它的Lisp对象的狭槽，被称为阵列的元件。数组的任何元素都可以在恒定时间内访问。相反，访问列表元素的时间与该元素在列表中的位置成比例。</target>
        </trans-unit>
        <trans-unit id="51d6c8f716e9b88b14b6fb96e89f9851f7407153" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt; or &lt;em&gt;alist&lt;/em&gt; is a specially-constructed list whose elements are cons cells. In each element, the &lt;small&gt;CAR&lt;/small&gt; is considered a &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is considered an &lt;em&gt;associated value&lt;/em&gt;. (In some cases, the associated value is stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt;.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.</source>
          <target state="translated">一个&lt;em&gt;关联列表&lt;/em&gt;或&lt;em&gt;ALIST&lt;/em&gt;是一个专门构造的列表，其元素缺点细胞。在每个元素中，&lt;small&gt;CAR&lt;/small&gt;被视为&lt;em&gt;密钥&lt;/em&gt;，而&lt;small&gt;CDR&lt;/small&gt;被视为&lt;em&gt;关联值&lt;/em&gt;。 （在某些情况下，关联的值存储在&lt;small&gt;CDR&lt;/small&gt;的&lt;small&gt;CAR&lt;/small&gt;中。）关联列表经常用作堆栈，因为在列表的开头很容易添加或删除关联。&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1abfa47a133f69e41aaa18f7e94f5e435978d98b" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;association list&lt;/em&gt;, or &lt;em&gt;alist&lt;/em&gt; for short, records a mapping from keys to values. It is a list of cons cells called &lt;em&gt;associations&lt;/em&gt;: the &lt;small&gt;CAR&lt;/small&gt; of each cons cell is the &lt;em&gt;key&lt;/em&gt;, and the &lt;small&gt;CDR&lt;/small&gt; is the &lt;em&gt;associated value&lt;/em&gt;.&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;em&gt;关联列表&lt;/em&gt;，或&lt;em&gt;ALIST&lt;/em&gt;短，记录从键到值的映射。这是一个称为&lt;em&gt;关联&lt;/em&gt;的con单元格列表：每个cons单元格的&lt;small&gt;CAR&lt;/small&gt;是&lt;em&gt;键&lt;/em&gt;，而&lt;small&gt;CDR&lt;/small&gt;是&lt;em&gt;关联值&lt;/em&gt;。&lt;a href=&quot;#FOOT5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5d765e12413afb561974dbf3e3027981ca84c13" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;autoload object&lt;/em&gt; is a list whose first element is the symbol &lt;code&gt;autoload&lt;/code&gt;. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.</source>
          <target state="translated">一个&lt;em&gt;自动加载对象&lt;/em&gt;是其第一个元素是符号的列表 &lt;code&gt;autoload&lt;/code&gt; 。它存储为符号的函数定义，并在其中充当实际定义的占位符。autoload对象说，真正的定义是在Lisp代码文件中找到的，应在必要时加载该文件。它包含文件名以及有关真实定义的其他信息。</target>
        </trans-unit>
        <trans-unit id="24cadccfe6209dab134eadc89a088981a88134fc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;ewoc&lt;/em&gt; is a structure that organizes information required to construct buffer text that represents certain Lisp data. The buffer text of the ewoc has three parts, in order: first, fixed &lt;em&gt;header&lt;/em&gt; text; next, textual descriptions of a series of data elements (Lisp objects that you specify); and last, fixed &lt;em&gt;footer&lt;/em&gt; text. Specifically, an ewoc contains information on:</source>
          <target state="translated">一个&lt;em&gt;ewoc&lt;/em&gt;是组织需要表示某些Lisp的数据构造缓冲器的文本信息的结构。ewoc的缓冲区文本按顺序分为三部分：第一，固定&lt;em&gt;标题&lt;/em&gt;文本；第二，固定&lt;em&gt;标题&lt;/em&gt;文本。接下来，是一系列数据元素的文本描述（您指定的Lisp对象）；最后是固定的&lt;em&gt;页脚&lt;/em&gt;文本。具体而言，ewoc包含以下信息：</target>
        </trans-unit>
        <trans-unit id="45ade8aa3c0307591d943018dc5e837198a89448" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;image descriptor&lt;/em&gt; is a list which specifies the underlying data for an image, and how to display it. It is typically used as the value of a &lt;code&gt;display&lt;/code&gt; overlay or text property (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;); but See &lt;a href=&quot;showing-images#Showing-Images&quot;&gt;Showing Images&lt;/a&gt;, for convenient helper functions to insert images into buffers.</source>
          <target state="translated">一个&lt;em&gt;图像描述符&lt;/em&gt;是指定用于图像的基础数据的列表，以及如何显示它。它通常用作 &lt;code&gt;display&lt;/code&gt; 覆盖或文本属性的值（请参见&lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;其他显示规格&lt;/a&gt;）。但请参阅&lt;a href=&quot;showing-images#Showing-Images&quot;&gt;显示图像&lt;/a&gt;，以获取将图像插入缓冲区的便捷帮助器功能。</target>
        </trans-unit>
        <trans-unit id="8ee4088b1e46a6b8823f17c1848dbfa1804acba9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;indirect buffer&lt;/em&gt; shares the text of some other buffer, which is called the &lt;em&gt;base buffer&lt;/em&gt; of the indirect buffer. In some ways it is the analogue, for buffers, of a symbolic link among files. The base buffer may not itself be an indirect buffer.</source>
          <target state="translated">一个&lt;em&gt;间接缓冲器&lt;/em&gt;股一些其它缓冲液，这就是所谓的文本&lt;em&gt;碱缓冲液&lt;/em&gt;间接缓冲液中。在某些方面，它类似于文件之间的符号链接（对于缓冲区）。基本缓冲区本身可能不是间接缓冲区。</target>
        </trans-unit>
        <trans-unit id="5d4ce81396c742a0b613f8351db2ccbce4a6b846" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;inline function&lt;/em&gt; is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), the function&amp;rsquo;s definition is expanded into the caller.</source>
          <target state="translated">一个&lt;em&gt;内联函数&lt;/em&gt;是作品就像一个普通的功能，除了一件事的功能：当你字节编译到函数的调用（见&lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;字节编译&lt;/a&gt;），该函数的定义扩大到调用。</target>
        </trans-unit>
        <trans-unit id="9f6630c098c66be4689d2cdd9cd8bef1da6dd18e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;overlay&lt;/em&gt; specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.</source>
          <target state="translated">一个&lt;em&gt;覆盖&lt;/em&gt;指定应用到缓冲器的部分特性。每个覆盖都适用于缓冲区的指定范围，并包含一个属性列表（该列表的元素是交替的属性名称和值）。覆盖属性用于以不同的显示样式临时呈现缓冲区的各个部分。覆盖图没有读取语法，并以哈希符号打印，给出了缓冲区名称和位置范围。</target>
        </trans-unit>
        <trans-unit id="07799df1b9d386af6360d33cd65d6f9fe665cd6d" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot be an empty list (an empty list is never needed, since SMIE allows all non-terminals to match the empty string anyway).</source>
          <target state="translated">一个 &lt;var&gt;rhs&lt;/var&gt; 不能是空列表（永远不会需要一个空列表，因为SMIE允许所有非终端为空字符串匹配反正）。</target>
        </trans-unit>
        <trans-unit id="ad5b32c399f18af984f9755a3f1132417efccd31" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;rhs&lt;/var&gt; cannot have 2 consecutive non-terminals: each pair of non-terminals needs to be separated by a terminal (aka token). This is a fundamental limitation of operator precedence grammars.</source>
          <target state="translated">一个 &lt;var&gt;rhs&lt;/var&gt; 不能有2个连续的非端子：每对非终结需要由终端（又名令牌）来分离。这是运算符优先级语法的基本限制。</target>
        </trans-unit>
        <trans-unit id="7922709da81f687d8271ff998b16af874b1814ac" translate="yes" xml:space="preserve">
          <source>An Emacs &lt;em&gt;character set&lt;/em&gt;, or &lt;em&gt;charset&lt;/em&gt;, is a set of characters in which each character is assigned a numeric code point. (The Unicode Standard calls this a &lt;em&gt;coded character set&lt;/em&gt;.) Each Emacs charset has a name which is a symbol. A single character can belong to any number of different character sets, but it will generally have a different code point in each charset. Examples of character sets include &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, &lt;code&gt;greek-iso8859-7&lt;/code&gt;, and &lt;code&gt;windows-1255&lt;/code&gt;. The code point assigned to a character in a charset is usually different from its code point used in Emacs buffers and strings.</source>
          <target state="translated">Emacs&lt;em&gt;字符集&lt;/em&gt;或&lt;em&gt;charset&lt;/em&gt;是一组字符，其中每个字符都分配有一个数字代码点。 （Unicode标准将此称为&lt;em&gt;编码字符集&lt;/em&gt;。）每个Emacs字符集都有一个符号名称。单个字符可以属于任意数量的不同字符集，但每个字符集通常具有不同的代码点。字符集的示例包括 &lt;code&gt;ascii&lt;/code&gt; ， &lt;code&gt;iso-8859-1&lt;/code&gt; ， &lt;code&gt;greek-iso8859-7&lt;/code&gt; 和 &lt;code&gt;windows-1255&lt;/code&gt; 。分配给字符集中的字符的代码点通常与Emacs缓冲区和字符串中使用的代码点不同。</target>
        </trans-unit>
        <trans-unit id="b460981854f34e1d2df2695ccac2e570ff87d223" translate="yes" xml:space="preserve">
          <source>An Emacs installation may have a &lt;em&gt;default init file&lt;/em&gt;, which is a Lisp library named</source>
          <target state="translated">一个Emacs安装可能有一个&lt;em&gt;默认的初始化文件&lt;/em&gt;，它是一个名为Lisp的库。</target>
        </trans-unit>
        <trans-unit id="e2785779758cffeebac8e8b91c79bc832a2d5aa1" translate="yes" xml:space="preserve">
          <source>An abbrev table is represented as an obarray. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol&amp;rsquo;s name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;).</source>
          <target state="translated">缩写表表示为对象数组。有关对象数组的信息，请参见&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建符号&lt;/a&gt;。每个缩写均由obarray中的符号表示。符号的名称是缩写。它的价值在于扩展；它的函数定义是用于执行扩展的钩子函数（请参阅&lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;定义缩写&lt;/a&gt;）；并且其属性列表单元格包含各种其他属性，包括使用次数和缩写的扩展次数（请参阅&lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e708d184dee6ca64093dbe415ec262b16c5b9ff2" translate="yes" xml:space="preserve">
          <source>An abbreviation or &lt;em&gt;abbrev&lt;/em&gt; is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.</source>
          <target state="translated">的缩写词或&lt;em&gt;缩写&lt;/em&gt;是可以扩展到更长的字符串的字符的字符串。用户可以插入缩写字符串，并发现它被缩写扩展自动替换。这样可以节省键入内容。</target>
        </trans-unit>
        <trans-unit id="8be78449d783fd1e94ea043c27376e317eb4caa7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;delete-terminal&lt;/code&gt;. Each function receives one argument, the &lt;var&gt;terminal&lt;/var&gt; argument passed to &lt;code&gt;delete-terminal&lt;/code&gt;. Due to technical details, the functions may be called either just before the terminal is deleted, or just afterwards.</source>
          <target state="translated">由 &lt;code&gt;delete-terminal&lt;/code&gt; 运行的异常钩子。每个函数接收一个参数，将 &lt;var&gt;terminal&lt;/var&gt; 参数传递给 &lt;code&gt;delete-terminal&lt;/code&gt; 。由于技术细节，可以在删除终端之前或之后调用这些功能。</target>
        </trans-unit>
        <trans-unit id="6b8b396e23526cbc99aafc9321a68ad76aeb57a7" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by &lt;code&gt;make-frame&lt;/code&gt; after it created the frame. Each function in &lt;code&gt;after-make-frame-functions&lt;/code&gt; receives one argument, the frame just created.</source>
          <target state="translated">创建 &lt;code&gt;make-frame&lt;/code&gt; 后，make-frame运行了异常的挂钩。 &lt;code&gt;after-make-frame-functions&lt;/code&gt; 中的每个函数都接收一个参数，即刚创建的框架。</target>
        </trans-unit>
        <trans-unit id="d8587f99198f36ccc0868cfa884bdb9eebf7fda4" translate="yes" xml:space="preserve">
          <source>An abnormal hook run by prefix commands (such as</source>
          <target state="translated">由前缀命令运行的异常钩子(如</target>
        </trans-unit>
        <trans-unit id="a76206aa6573ab5f6706b29d3c45607d86b5bf4d" translate="yes" xml:space="preserve">
          <source>An action function accepts two arguments: the buffer to display and an action alist. It attempts to display the buffer in some window, picking or creating a window according to its own criteria. If successful, it returns the window; otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">一个动作函数接受两个参数：要显示的缓冲区和一个动作列表。它尝试在某些窗口中显示缓冲区，并根据自己的条件选择或创建一个窗口。如果成功，则返回窗口。否则，返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8f8b239306495b67e6a33c553a3311a22ea8108" translate="yes" xml:space="preserve">
          <source>An action function for displaying buffers in side windows.</source>
          <target state="translated">用于在侧面窗口中显示缓冲区的操作功能。</target>
        </trans-unit>
        <trans-unit id="8d4ccdf032d06b3ff88d7877263294cc83765270" translate="yes" xml:space="preserve">
          <source>An alist of the minor modes of this buffer.</source>
          <target state="translated">这个缓冲区的小模式列表。</target>
        </trans-unit>
        <trans-unit id="9d0b7856c0ae1bba2fe0095e327228fef5e6cbeb" translate="yes" xml:space="preserve">
          <source>An alternative to keeping around C data structures that need to be passed to module functions later is to create &lt;em&gt;user pointer&lt;/em&gt; objects. A user pointer, or &lt;code&gt;user-ptr&lt;/code&gt;, object is a Lisp object that encapsulates a C pointer and can have an associated finalizer function, which is called when the object is garbage-collected (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;). The module</source>
          <target state="translated">保留以后需要传递给模块函数的C数据结构的一种替代方法是创建&lt;em&gt;用户指针&lt;/em&gt;对象。用户指针或 &lt;code&gt;user-ptr&lt;/code&gt; 对象是一个Lisp对象，它封装了一个C指针，并且可以具有关联的终结器函数，该函数在对象被垃圾回收时被调用（请参见&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;）。模块</target>
        </trans-unit>
        <trans-unit id="76745f9f38a9adc0e71accf01a6af367ec394a13" translate="yes" xml:space="preserve">
          <source>An alternative, structured regexp notation.</source>
          <target state="translated">一个替代的、结构化的regexp符号。</target>
        </trans-unit>
        <trans-unit id="49d23cb0a4197518f11c87451f54d2c79b88ddd3" translate="yes" xml:space="preserve">
          <source>An anonymous face: a property list of the form &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt;, where each &lt;var&gt;keyword&lt;/var&gt; is a face attribute name and &lt;var&gt;value&lt;/var&gt; is a value for that attribute.</source>
          <target state="translated">匿名面孔：形式 &lt;code&gt;(&lt;var&gt;keyword&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; &amp;hellip;)&lt;/code&gt; 的属性列表，其中每个 &lt;var&gt;keyword&lt;/var&gt; 是面孔属性名称， &lt;var&gt;value&lt;/var&gt; 是该属性的值。</target>
        </trans-unit>
        <trans-unit id="0cb1807f666d0b9ab5deb699a6ca67714dc0387b" translate="yes" xml:space="preserve">
          <source>An application can bind this variable to a non-&lt;code&gt;nil&lt;/code&gt; value around calls to these functions. If it does so, the application is fully responsible for correctly assigning the parameters of all involved windows when exiting that function.</source>
          <target state="translated">一个应用程序可以将该变量绑定到一个非 &lt;code&gt;nil&lt;/code&gt; 周围调用这些函数值。如果这样做，则应用程序完全有责任在退出该功能时正确分配所有相关窗口的参数。</target>
        </trans-unit>
        <trans-unit id="17ba397de5d1c307ab7dde751562e065ea00e3df" translate="yes" xml:space="preserve">
          <source>An arrow in the left fringe indicates the line where the function is executing. Point initially shows where within the line the function is executing, but this ceases to be true if you move point yourself.</source>
          <target state="translated">左边边缘的箭头表示函数正在执行的行。点最初显示的是函数在行内的执行位置,但如果你自己移动点,则不再是这样。</target>
        </trans-unit>
        <trans-unit id="ac945ca03e1203355b8e2eb7095f27f8bf8a33d9" translate="yes" xml:space="preserve">
          <source>An asynchronous process is controlled either via a &lt;em&gt;pty&lt;/em&gt; (pseudo-terminal) or a &lt;em&gt;pipe&lt;/em&gt;. The choice of pty or pipe is made when creating the process, by default based on the value of the variable &lt;code&gt;process-connection-type&lt;/code&gt; (see below). If available, ptys are usually preferable for processes visible to the user, as in Shell mode, because they allow for job control (</source>
          <target state="translated">异步过程可以通过&lt;em&gt;pty&lt;/em&gt;（伪终端）或&lt;em&gt;管道进行控制&lt;/em&gt;。默认情况下，将根据变量 &lt;code&gt;process-connection-type&lt;/code&gt; 的值（请参见下文）在创建过程时选择pty还是管道。如果可用，pty通常对于用户可见的进程（如Shell模式）更可取，因为它们允许作业控制（</target>
        </trans-unit>
        <trans-unit id="fed2f1ab264295d6199c8837444baee7f96bfb5c" translate="yes" xml:space="preserve">
          <source>An autoload object is usually created with the function &lt;code&gt;autoload&lt;/code&gt;, which stores the object in the function cell of a symbol. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;, for more details.</source>
          <target state="translated">通常使用函数 &lt;code&gt;autoload&lt;/code&gt; 创建一个自动加载对象，该函数将对象存储在符号的功能单元中。有关更多详细信息，请参见&lt;a href=&quot;autoload#Autoload&quot;&gt;自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="224896b7315afde30421b984952b3f7096f2d130" translate="yes" xml:space="preserve">
          <source>An autoloaded keymap loads automatically during key lookup when a prefix key&amp;rsquo;s binding is the symbol &lt;var&gt;function&lt;/var&gt;. Autoloading does not occur for other kinds of access to the keymap. In particular, it does not happen when a Lisp program gets the keymap from the value of a variable and calls &lt;code&gt;define-key&lt;/code&gt;; not even if the variable name is the same symbol &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">当前缀键的绑定是symbol &lt;var&gt;function&lt;/var&gt; 时，自动加载的键映射会在键查找期间自动加载。其他类型的键盘映射访问不会自动加载。特别是，当Lisp程序从变量的值获取键映射并调用 &lt;code&gt;define-key&lt;/code&gt; 时，不会发生这种情况。即使变量名是相同的符号 &lt;var&gt;function&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="b47c8f66af20cead9b4237e06f3de8a32193907c" translate="yes" xml:space="preserve">
          <source>An element can also look like this:</source>
          <target state="translated">一个元素也可以是这样的。</target>
        </trans-unit>
        <trans-unit id="d07aa0262359efa83d0dc291cc7ca1c53bb48bad" translate="yes" xml:space="preserve">
          <source>An empty element in the value of the environment variable, whether trailing (as in the above example), leading, or embedded, is replaced by the default value of &lt;code&gt;load-path&lt;/code&gt; as determined by the standard initialization procedure. If there are no such empty elements, then &lt;code&gt;EMACSLOADPATH&lt;/code&gt; specifies the entire &lt;code&gt;load-path&lt;/code&gt;. You must include either an empty element, or the explicit path to the directory containing the standard Lisp files, else Emacs will not function. (Another way to modify &lt;code&gt;load-path&lt;/code&gt; is to use the</source>
          <target state="translated">环境变量值中的空元素（无论是尾随的（如上例中所示），前导的还是嵌入的）都由标准初始化过程确定的 &lt;code&gt;load-path&lt;/code&gt; 的默认值替换。如果没有这样的空元素，则 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; 指定整个 &lt;code&gt;load-path&lt;/code&gt; 。您必须包括一个空元素或包含标准Lisp文件的目录的显式路径，否则Emacs将不起作用。（修改 &lt;code&gt;load-path&lt;/code&gt; 另一种方法是使用</target>
        </trans-unit>
        <trans-unit id="4ebff7dd30b4758ff88bcc9a085f45ded794db52" translate="yes" xml:space="preserve">
          <source>An empty sequence contributes nothing to the value returned by &lt;code&gt;append&lt;/code&gt;. As a consequence of this, a final &lt;code&gt;nil&lt;/code&gt; argument forces a copy of the previous argument:</source>
          <target state="translated">空序列对 &lt;code&gt;append&lt;/code&gt; 返回的值没有任何贡献。结果，最后一个 &lt;code&gt;nil&lt;/code&gt; 参数强制复制前一个参数：</target>
        </trans-unit>
        <trans-unit id="a86a8ba20f9c2d16da923dc8e59ec1f1d98d5dee" translate="yes" xml:space="preserve">
          <source>An equivalent expression for &lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt;
&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; is this:</source>
          <target state="translated">&lt;code&gt;(add-to-list '&lt;var&gt;var&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 的等效表达式是这样的：</target>
        </trans-unit>
        <trans-unit id="d3b3af3cc140e3e00a2eb7021cf621de45339c06" translate="yes" xml:space="preserve">
          <source>An error in &lt;var&gt;body&lt;/var&gt; does not undo the load, but does prevent execution of the rest of &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 中的错误不会消除负载，但会阻止其余 &lt;var&gt;body&lt;/var&gt; 执行。</target>
        </trans-unit>
        <trans-unit id="780991d8624f2cb2ad931ebb1b65ed8116e288c9" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;command&lt;/var&gt; is not a function or if it cannot be called interactively (i.e., is not a command). Note that keyboard macros (strings and vectors) are not accepted, even though they are considered commands, because they are not functions. If &lt;var&gt;command&lt;/var&gt; is a symbol, then &lt;code&gt;call-interactively&lt;/code&gt; uses its function definition.</source>
          <target state="translated">如果 &lt;var&gt;command&lt;/var&gt; 不是功能或不能以交互方式调用（即，不是命令），则将指示错误。请注意，即使键盘宏（字符串和向量）被视为命令，也不会被接受，因为它们不是函数。如果 &lt;var&gt;command&lt;/var&gt; 是符号，则 &lt;code&gt;call-interactively&lt;/code&gt; 将使用其功能定义。</target>
        </trans-unit>
        <trans-unit id="61727b4effcd7b8d96ef35b8becbc54d386ea1fd" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;directory&lt;/var&gt; is not the name of a directory that can be read.</source>
          <target state="translated">如果 &lt;var&gt;directory&lt;/var&gt; 不是可以读取的目录的名称，则会指示错误。</target>
        </trans-unit>
        <trans-unit id="a857332d53570982c6dc820fa3fd199f30c64bac" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;frame&lt;/var&gt; has no side windows and no saved state is found for it.</source>
          <target state="translated">如果 &lt;var&gt;frame&lt;/var&gt; 没有侧窗且未找到保存状态，则指示错误。</target>
        </trans-unit>
        <trans-unit id="4c7868057424e94cc2ec18aa245abf34334cd76a" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;marker&lt;/var&gt; is neither a marker nor an integer.</source>
          <target state="translated">如果 &lt;var&gt;marker&lt;/var&gt; 既不是标记也不是整数，则表明存在错误。</target>
        </trans-unit>
        <trans-unit id="ce502c5c14b3dd5ab57c7b1bc0667e1dce7ae3f1" translate="yes" xml:space="preserve">
          <source>An error is signaled if &lt;var&gt;name&lt;/var&gt; is not a string.</source>
          <target state="translated">如果 &lt;var&gt;name&lt;/var&gt; 不是字符串，则表明存在错误。</target>
        </trans-unit>
        <trans-unit id="d180f585f076cc17698606f42a90ec93eb4bf554" translate="yes" xml:space="preserve">
          <source>An error is signaled if you cannot write or create &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">如果您无法写入或创建 &lt;var&gt;filename&lt;/var&gt; 则会指示错误。</target>
        </trans-unit>
        <trans-unit id="4b96760d80ee8b7d0f895bcbd78c4d4e13017398" translate="yes" xml:space="preserve">
          <source>An error is signaled unless both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers or markers that indicate positions in the current buffer. (It is unimportant which number is larger.)</source>
          <target state="translated">除非 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 都是指示当前缓冲区中位置的整数或标记，否则将发出错误信号。（哪个数字更大并不重要。）</target>
        </trans-unit>
        <trans-unit id="c51f55b2646e08b61f713ce7217e4887d1b95bfb" translate="yes" xml:space="preserve">
          <source>An error that has no explicit handler may call the Lisp debugger. The debugger is enabled if the variable &lt;code&gt;debug-on-error&lt;/code&gt; (see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Unlike error handlers, the debugger runs in the environment of the error, so that you can examine values of variables precisely as they were at the time of the error.</source>
          <target state="translated">没有显式处理程序的错误可以调用Lisp调试器。如果变量 &lt;code&gt;debug-on-error&lt;/code&gt; （请参见&lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;错误调试&lt;/a&gt;）为非 &lt;code&gt;nil&lt;/code&gt; ,则启用调试器。与错误处理程序不同，调试器在错误的环境中运行，因此您可以像检查错误时一样准确地检查变量的值。</target>
        </trans-unit>
        <trans-unit id="826bd3cc8d084ab396a2d00d5bdbe16d54e818a5" translate="yes" xml:space="preserve">
          <source>An ewoc maintains its text in the buffer that is current when you create it, so switch to the intended buffer before calling &lt;code&gt;ewoc-create&lt;/code&gt;.</source>
          <target state="translated">ewoc在创建时将其文本保存在当前缓冲区中，因此请在调用 &lt;code&gt;ewoc-create&lt;/code&gt; 之前切换到所需的缓冲区。</target>
        </trans-unit>
        <trans-unit id="fc38d0c598a08a05ef1cbe7256ecba3cfbdd4bb4" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Special mode is Buffer Menu mode, which is used by the</source>
          <target state="translated">由特殊模式派生出的主要模式的一个例子是缓冲区菜单模式,该模式由</target>
        </trans-unit>
        <trans-unit id="7d6bea7b0ca20a81d8dc92f7b4dfca2a43542cbd" translate="yes" xml:space="preserve">
          <source>An example of a major mode derived from Text mode is HTML mode. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML and HTML Modes&lt;/a&gt; in</source>
          <target state="translated">从文本模式派生的主要模式的示例是HTML模式。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html#HTML-Mode&quot;&gt;SGML和HTML模式&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="ade7f0bd288bb8a7ac97abf2b4ebdf07442ec432" translate="yes" xml:space="preserve">
          <source>An example of a special form is the definition of &lt;code&gt;or&lt;/code&gt;, from</source>
          <target state="translated">一种特殊形式的一个实例是定义 &lt;code&gt;or&lt;/code&gt; ，从</target>
        </trans-unit>
        <trans-unit id="ef33cd83c0ed34c69762159ed48693bced9fc15f" translate="yes" xml:space="preserve">
          <source>An example of a type descriptor is any instance of &lt;code&gt;cl-structure-class&lt;/code&gt;.</source>
          <target state="translated">类型描述符的一个示例是 &lt;code&gt;cl-structure-class&lt;/code&gt; 的任何实例。</target>
        </trans-unit>
        <trans-unit id="24242de3c100a999285b6229c3f4ecef7f0ccd1f" translate="yes" xml:space="preserve">
          <source>An example of speedup from byte compilation.</source>
          <target state="translated">一个从字节编译加速的例子。</target>
        </trans-unit>
        <trans-unit id="db343fa7b3e5ada913fce5ea3283f949a1870619" translate="yes" xml:space="preserve">
          <source>An example of the use of &lt;code&gt;defconst&lt;/code&gt; is Emacs&amp;rsquo;s definition of &lt;code&gt;float-pi&lt;/code&gt;&amp;mdash;the mathematical constant &lt;em&gt;pi&lt;/em&gt;, which ought not to be changed by anyone (attempts by the Indiana State Legislature notwithstanding). As the second form illustrates, however, &lt;code&gt;defconst&lt;/code&gt; is only advisory.</source>
          <target state="translated">使用 &lt;code&gt;defconst&lt;/code&gt; 的一个例子是Emacs对 &lt;code&gt;float-pi&lt;/code&gt; 的定义-数学常数&lt;em&gt;pi&lt;/em&gt;，任何人都不得更改（尽管印第安纳州立法机构曾尝试这样做）。但是，如第二种形式所示， &lt;code&gt;defconst&lt;/code&gt; 仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="33511a390c0a0778aeb50d2d3d11dc55b02fecef" translate="yes" xml:space="preserve">
          <source>An exclusive lock for thread synchronization.</source>
          <target state="translated">线程同步的专属锁。</target>
        </trans-unit>
        <trans-unit id="33cdd5563375ee0f1deecf7207e816fded24f27d" translate="yes" xml:space="preserve">
          <source>An extended-format menu item is a more flexible and also cleaner alternative to the simple format. You define an event type with a binding that&amp;rsquo;s a list starting with the symbol &lt;code&gt;menu-item&lt;/code&gt;. For a non-selectable string, the binding looks like this:</source>
          <target state="translated">扩展格式菜单项是简单格式的更灵活，更简洁的替代方案。您可以定义一个带有绑定的事件类型，该绑定是一个以symbol &lt;code&gt;menu-item&lt;/code&gt; 开始的列表。对于不可选择的字符串，绑定如下所示：</target>
        </trans-unit>
        <trans-unit id="dd1c3b20fbc2c4f6fdbfa727cc037df93e3d480a" translate="yes" xml:space="preserve">
          <source>An extra vertical space, with no actual line.</source>
          <target state="translated">一个额外的垂直空间,没有实际的线。</target>
        </trans-unit>
        <trans-unit id="7d946c1cee5e1ba6a2795eaa7494b0742a37aa80" translate="yes" xml:space="preserve">
          <source>An image map is an alist where each element has the format &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;. An &lt;var&gt;area&lt;/var&gt; is specified as either a rectangle, a circle, or a polygon.</source>
          <target state="translated">图像映射是一个列表，其中每个元素都具有格式 &lt;code&gt;(&lt;var&gt;area&lt;/var&gt; &lt;var&gt;id&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; 。将 &lt;var&gt;area&lt;/var&gt; 指定为矩形，圆形或多边形。</target>
        </trans-unit>
        <trans-unit id="13e8bfffc43f95cb01c82af877179e85c97c1ef2" translate="yes" xml:space="preserve">
          <source>An important function of each major mode is to customize the</source>
          <target state="translated">每种主要模式的一个重要功能是自定义</target>
        </trans-unit>
        <trans-unit id="3b4e015d01f5bbc54743f05646c0292a69c90141" translate="yes" xml:space="preserve">
          <source>An indication of the depth of recursive editing levels (not counting minibuffer levels): one &amp;lsquo;</source>
          <target state="translated">指示递归编辑级别的深度（不计算最小缓冲区级别）：一个'</target>
        </trans-unit>
        <trans-unit id="93f69cd72673e3fad1210d3ff536f5eac200198d" translate="yes" xml:space="preserve">
          <source>An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually saves the base buffer.</source>
          <target state="translated">一个间接缓冲区不能访问一个文件,但它的基本缓冲区可以。如果你试图保存间接缓冲区,那实际上是保存了基缓冲区。</target>
        </trans-unit>
        <trans-unit id="f4f16819d5893d8be64117345439137741280e45" translate="yes" xml:space="preserve">
          <source>An indirect buffer shares text with some other buffer.</source>
          <target state="translated">间接缓冲区与其他缓冲区共享文本。</target>
        </trans-unit>
        <trans-unit id="dd71440c52babfc9828665c875dc912c73851196" translate="yes" xml:space="preserve">
          <source>An input character event consists of a &lt;em&gt;basic code&lt;/em&gt; between 0 and 524287, plus any or all of these &lt;em&gt;modifier bits&lt;/em&gt;:</source>
          <target state="translated">输入字符事件由介于0到524287之间的&lt;em&gt;基本代码&lt;/em&gt;以及以下任何或所有&lt;em&gt;修饰符位组成&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b3693e265751b6a87adf1612d2ffab4f6ae73018" translate="yes" xml:space="preserve">
          <source>An integer indicating the Universal Time offset in seconds, i.e., the number of seconds east of Greenwich.</source>
          <target state="translated">一个整数,表示以秒为单位的世界时间偏移,即格林威治以东的秒数。</target>
        </trans-unit>
        <trans-unit id="1b85b9238ec8e0326b1ff24adce97a9f1339ccd1" translate="yes" xml:space="preserve">
          <source>An integer number specifies the desired total height of the chosen window in lines.</source>
          <target state="translated">一个整数,指定所选窗口的总高度,以行为单位。</target>
        </trans-unit>
        <trans-unit id="ae5275ccb64692a25834f62374d3e39ff8168087" translate="yes" xml:space="preserve">
          <source>An integer specifies the desired total width of the chosen window in columns.</source>
          <target state="translated">一个整数,指定所选窗口的总宽度,以列为单位。</target>
        </trans-unit>
        <trans-unit id="c25162540c717d611e1426ca74b4483ad68c8fe4" translate="yes" xml:space="preserve">
          <source>An integer that increments each time Emacs is built in the same directory (without cleaning). This is only of relevance when developing Emacs.</source>
          <target state="translated">一个整数,每次Emacs在同一目录下构建时都会递增(不清理)。这只在开发Emacs时才有意义。</target>
        </trans-unit>
        <trans-unit id="a372e2277d8f20cbea84272110bbfb45b40e134a" translate="yes" xml:space="preserve">
          <source>An integer that represents the minimum number of colors the terminal should support. This matches a terminal if its &lt;code&gt;display-color-cells&lt;/code&gt; value is at least the specified integer.</source>
          <target state="translated">一个整数，代表终端应支持的最小颜色数。如果终端的 &lt;code&gt;display-color-cells&lt;/code&gt; 值至少为指定的整数，则此值与终端匹配。</target>
        </trans-unit>
        <trans-unit id="666998409bcbf2ebf0bfb7f00ef2a1f48383fd05" translate="yes" xml:space="preserve">
          <source>An integer, the operating system&amp;rsquo;s process</source>
          <target state="translated">整数，操作系统的进程</target>
        </trans-unit>
        <trans-unit id="85068ddc5e4eeb621888a2f24d4968195abea28e" translate="yes" xml:space="preserve">
          <source>An integer, which stands for itself.</source>
          <target state="translated">一个整数,它代表着自己。</target>
        </trans-unit>
        <trans-unit id="483624c83a349249c67af72f64c85e27874fdcce" translate="yes" xml:space="preserve">
          <source>An integer. Although this is the simplest form, it cannot represent subsecond timestamps.</source>
          <target state="translated">一个整数。虽然这是最简单的形式,但它不能代表亚秒级时间戳。</target>
        </trans-unit>
        <trans-unit id="210e35e78b0bac1a6f24a3e4af59acfd7b9cae5d" translate="yes" xml:space="preserve">
          <source>An interned symbol whose name is read in the minibuffer. Terminate the input with either</source>
          <target state="translated">在迷你缓冲区中读取一个内部符号的名称。用以下两种方式终止输入</target>
        </trans-unit>
        <trans-unit id="d5c7d47ecad208491b6f75958ec8b743a987742f" translate="yes" xml:space="preserve">
          <source>An irrelevant argument. This code always supplies &lt;code&gt;nil&lt;/code&gt; as the argument&amp;rsquo;s value. No I/O.</source>
          <target state="translated">一个无关紧要的论点。此代码始终提供 &lt;code&gt;nil&lt;/code&gt; 作为参数的值。没有I / O。</target>
        </trans-unit>
        <trans-unit id="27856a404b93377dd2ce26256cf827f21924ee05" translate="yes" xml:space="preserve">
          <source>An object which can be invoked via the &lt;code&gt;command-execute&lt;/code&gt; primitive, usually due to the user typing in a key sequence &lt;em&gt;bound&lt;/em&gt; to that command. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;. A command is usually a function; if the function is written in Lisp, it is made into a command by an &lt;code&gt;interactive&lt;/code&gt; form in the function definition (see &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;). Commands that are functions can also be called from Lisp expressions, just like other functions.</source>
          <target state="translated">可以通过 &lt;code&gt;command-execute&lt;/code&gt; 原语调用的对象，通常是由于用户键入&lt;em&gt;绑定&lt;/em&gt;到该命令的键序列所致。请参阅&amp;ldquo;&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;交互式呼叫&amp;rdquo;&lt;/a&gt;。命令通常是一个函数；如果函数是用Lisp编写的，则通过函数定义中的 &lt;code&gt;interactive&lt;/code&gt; 形式将其转换为命令（请参见&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;定义命令&lt;/a&gt;）。与其他函数一样，也可以从Lisp表达式中调用作为函数的命令。</target>
        </trans-unit>
        <trans-unit id="187267476807f080e4cb1366bd55dc6c3a734b11" translate="yes" xml:space="preserve">
          <source>An old piece of advice such as:</source>
          <target state="translated">一个古老的建议,如:</target>
        </trans-unit>
        <trans-unit id="a4f4924d6a637db199a3dbbcbcca04ca29c457ed" translate="yes" xml:space="preserve">
          <source>An ordinary, unencrypted connection.</source>
          <target state="translated">一个普通的、未加密的连接。</target>
        </trans-unit>
        <trans-unit id="8f179ba3c57cb5057b94b469bdc747796dcb263d" translate="yes" xml:space="preserve">
          <source>An output stream specifies what to do with the characters produced by printing. Most print functions accept an output stream as an optional argument. Here are the possible types of output stream:</source>
          <target state="translated">输出流指定如何处理打印产生的字符。大多数打印函数都接受输出流作为一个可选的参数。以下是输出流的可能类型。</target>
        </trans-unit>
        <trans-unit id="4a4e0e2275538ba1b3ea01efe71801a7f7f08073" translate="yes" xml:space="preserve">
          <source>An overlay uses markers to record its beginning and end; thus, editing the text of the buffer adjusts the beginning and end of each overlay so that it stays with the text. When you create the overlay, you can specify whether text inserted at the beginning should be inside the overlay or outside, and likewise for the end of the overlay.</source>
          <target state="translated">叠加使用标记来记录它的开头和结尾,因此,编辑缓冲区的文本会调整每个叠加的开头和结尾,使其与文本保持一致。在创建叠加时,您可以指定在开头插入的文本应该在叠加内还是在叠加外,同样也可以指定叠加的结尾。</target>
        </trans-unit>
        <trans-unit id="b25d5a56d0ee9ca005469f384e566fa726e58945" translate="yes" xml:space="preserve">
          <source>An overlay whose &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; specify the same buffer position is known as &lt;em&gt;empty&lt;/em&gt;. A non-empty overlay can become empty if the text between its &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is deleted. When that happens, the overlay is by default not deleted, but you can cause it to be deleted by giving it the &amp;lsquo;</source>
          <target state="translated">其 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 指定相同缓冲区位置的叠加层称为&lt;em&gt;empty&lt;/em&gt;。如果删除了非空的叠加层的 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 之间的文本，则该字段可能为空。发生这种情况时，默认情况下不会删除叠加层，但是您可以通过将其赋予&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="51ba330dcf0b0a0baa7674c3887cbac685290344" translate="yes" xml:space="preserve">
          <source>An overview of all the special sequences.</source>
          <target state="translated">所有特殊序列的概述。</target>
        </trans-unit>
        <trans-unit id="045422a0880a1615b24f5a3a512245b1c27b53c3" translate="yes" xml:space="preserve">
          <source>An unspecified value, present for backward compatibility.</source>
          <target state="translated">一个未指定的值,为向后兼容而存在。</target>
        </trans-unit>
        <trans-unit id="55764c2c6ec8109ce06467af931be863e9f31e08" translate="yes" xml:space="preserve">
          <source>And here is the code to set up the keymap for Lisp mode:</source>
          <target state="translated">这里是设置Lisp模式的键位图的代码。</target>
        </trans-unit>
        <trans-unit id="b6e7a99ffdd1e497ee1a0b6591309c08b6de6ce9" translate="yes" xml:space="preserve">
          <source>Animation operates by means of a timer. Note that Emacs imposes a minimum frame delay of 0.01 (&lt;code&gt;image-minimum-frame-delay&lt;/code&gt;) seconds. If the image itself does not specify a delay, Emacs uses &lt;code&gt;image-default-frame-delay&lt;/code&gt;.</source>
          <target state="translated">动画通过计时器进行操作。请注意，Emacs施加的最小帧延迟为0.01（ &lt;code&gt;image-minimum-frame-delay&lt;/code&gt; ）秒。如果图像本身未指定延迟，则Emacs使用 &lt;code&gt;image-default-frame-delay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">匿名函数</target>
        </trans-unit>
        <trans-unit id="d155a6db1755fd84bc4701702679a300873b3893" translate="yes" xml:space="preserve">
          <source>Another annoyance (more an inconvenience than a limitation) is that when a series of &lt;var&gt;condition&lt;/var&gt; predicates implement equality tests, there is a lot of repeated code. (&lt;code&gt;cl-case&lt;/code&gt; solves this inconvenience.)</source>
          <target state="translated">另一个烦恼（比限制更多的麻烦）是，当一系列 &lt;var&gt;condition&lt;/var&gt; 谓词实现相等性测试时，会有很多重复的代码。（ &lt;code&gt;cl-case&lt;/code&gt; 解决了这种不便。）</target>
        </trans-unit>
        <trans-unit id="5303f5dba20cc28da9809fdf0b019eb440c2beee" translate="yes" xml:space="preserve">
          <source>Another command,</source>
          <target state="translated">另一个命令。</target>
        </trans-unit>
        <trans-unit id="46429506bccc14a1fccf369e49c5519916a0ddea" translate="yes" xml:space="preserve">
          <source>Another difference from &lt;code&gt;rx-let&lt;/code&gt; is that the &lt;var&gt;bindings&lt;/var&gt; are dynamically scoped, and thus also available in functions called from &lt;var&gt;body&lt;/var&gt;. However, they are not visible inside functions defined in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">与 &lt;code&gt;rx-let&lt;/code&gt; 的另一个区别是 &lt;var&gt;bindings&lt;/var&gt; 是动态作用域的，因此也可以在from &lt;var&gt;body&lt;/var&gt; 调用的函数中使用。但是，它们在 &lt;var&gt;body&lt;/var&gt; 中定义的函数内部不可见。</target>
        </trans-unit>
        <trans-unit id="60eaf91aef5f334ebb5d4be6e2c8a0357829b694" translate="yes" xml:space="preserve">
          <source>Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.</source>
          <target state="translated">另一个缺点是,内联一个大函数会增加编译后的代码在文件和内存中的大小。由于内联函数在速度上的优势对于小函数来说是最大的,所以一般情况下不应该将大函数内联。</target>
        </trans-unit>
        <trans-unit id="6f719d65bc588f6114e05a3ba91ae2e2b8b0fa12" translate="yes" xml:space="preserve">
          <source>Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function &lt;code&gt;force-mode-line-update&lt;/code&gt; works by doing this:</source>
          <target state="translated">调用此函数的另一个效果是导致无条件地重新显示当前缓冲区的模式行。实际上，功能 &lt;code&gt;force-mode-line-update&lt;/code&gt; 通过执行以下操作：</target>
        </trans-unit>
        <trans-unit id="fe8d47ec903dba59decabf21d52ed6b989d5e361" translate="yes" xml:space="preserve">
          <source>Another element is &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;context&lt;/var&gt; is the SELinux context, in the same form returned by &lt;code&gt;file-selinux-context&lt;/code&gt;.</source>
          <target state="translated">另一个要素是 &lt;code&gt;(selinux-context . &lt;var&gt;context&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;context&lt;/var&gt; 是SELinux上下文，在通过返回相同的形式 &lt;code&gt;file-selinux-context&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a41e64a0f4d5fb203b7d54e395a3a3c7314af2" translate="yes" xml:space="preserve">
          <source>Another file for site-customization is</source>
          <target state="translated">另一个用于网站定制的文件是</target>
        </trans-unit>
        <trans-unit id="dc46fb6acabbfa966b8518e0f2262bc229a7fdf8" translate="yes" xml:space="preserve">
          <source>Another important concept is the notion of &lt;em&gt;parent&lt;/em&gt;: The &lt;em&gt;parent&lt;/em&gt; of a token, is the head token of the nearest enclosing syntactic construct. For example, the parent of an &lt;code&gt;else&lt;/code&gt; is the &lt;code&gt;if&lt;/code&gt; to which it belongs, and the parent of an &lt;code&gt;if&lt;/code&gt;, in turn, is the lead token of the surrounding construct. The command &lt;code&gt;backward-sexp&lt;/code&gt; jumps from a token to its parent, but there are some caveats: for &lt;em&gt;openers&lt;/em&gt; (tokens which start a construct, like &lt;code&gt;if&lt;/code&gt;), you need to start with point before the token, while for others you need to start with point after the token. &lt;code&gt;backward-sexp&lt;/code&gt; stops with point before the parent token if that is the &lt;em&gt;opener&lt;/em&gt; of the token of interest, and otherwise it stops with point after the parent token.</source>
          <target state="translated">另一个重要概念是&lt;em&gt;父代&lt;/em&gt;的概念：&lt;em&gt;代&lt;/em&gt;币的&lt;em&gt;父代&lt;/em&gt;是最接近的句法构造的开头代词。例如，父 &lt;code&gt;else&lt;/code&gt; 是 &lt;code&gt;if&lt;/code&gt; 其所属，和一个父 &lt;code&gt;if&lt;/code&gt; 反过来是令牌周围构建体的引线。命令 &lt;code&gt;backward-sexp&lt;/code&gt; 从令牌跳到其父令牌，但有一些警告：对于&lt;em&gt;开瓶器&lt;/em&gt;（启动构建的令牌，如 &lt;code&gt;if&lt;/code&gt; ），您需要从令牌之前的点开始，而对于其他人，则需要从令牌开始点在令牌之后。 &lt;code&gt;backward-sexp&lt;/code&gt; 将在父标记之前的点处停止，如果那是&lt;em&gt;&lt;/em&gt;感兴趣的令牌的&lt;em&gt;打开者&lt;/em&gt;，否则以父令牌后面的点停止。</target>
        </trans-unit>
        <trans-unit id="b9deb7098c7fabbe640d3f39576b579bcc48e2d3" translate="yes" xml:space="preserve">
          <source>Another problem can happen if the macro definition itself evaluates any of the macro argument expressions, such as by calling &lt;code&gt;eval&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;). If the argument is supposed to refer to the user&amp;rsquo;s variables, you may have trouble if the user happens to use a variable with the same name as one of the macro arguments. Inside the macro body, the macro argument binding is the most local binding of this variable, so any references inside the form being evaluated do refer to it. Here is an example:</source>
          <target state="translated">如果宏定义本身对任何宏参数表达式求值，例如调用 &lt;code&gt;eval&lt;/code&gt; （请参阅&lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;），则可能会发生另一个问题。如果该参数应该引用用户的变量，则如果用户碰巧使用了与宏参数之一同名的变量，则可能会遇到麻烦。在宏主体内部，宏参数绑定是此变量的最本地绑定，因此，要评估的表单内的任何引用都引用该变量。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="0557ba812636c13b28f9c028bebedfc50e7d0d42" translate="yes" xml:space="preserve">
          <source>Another problem with calling &lt;code&gt;eval&lt;/code&gt; in a macro definition is that it probably won&amp;rsquo;t do what you intend in a compiled program. The byte compiler runs macro definitions while compiling the program, when the program&amp;rsquo;s own computations (which you might have wished to access with &lt;code&gt;eval&lt;/code&gt;) don&amp;rsquo;t occur and its local variable bindings don&amp;rsquo;t exist.</source>
          <target state="translated">在宏定义中调用 &lt;code&gt;eval&lt;/code&gt; 的另一个问题是，它可能无法满足您在编译程序中的意图。当程序自身的计算（您可能希望使用 &lt;code&gt;eval&lt;/code&gt; 访问）不发生且其局部变量绑定不存在时，字节编译器在编译程序时运行宏定义。</target>
        </trans-unit>
        <trans-unit id="2808e270cef0e3cc098d7ecd467a657ae4eca448" translate="yes" xml:space="preserve">
          <source>Another prominent use of property lists is for storing symbol properties. Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">属性列表的另一个显着用途是用于存储符号属性。每个符号都有一个属性列表，用于记录有关该符号的各种信息。这些属性以属性列表的形式存储。请参见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;符号属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7cde5f29771c6fd0640e059c163a4125f612e60" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;image-flush&lt;/code&gt; is for memory conservation. If your Lisp program creates a large number of temporary images over a period much shorter than &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; (see below), you can opt to flush unused images yourself, instead of waiting for Emacs to do it automatically.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; 另一个用途是保存内存。如果您的Lisp程序在比 &lt;code&gt;image-cache-eviction-delay&lt;/code&gt; （请参见下文）短得多的时间内创建了大量临时映像，则可以选择自己清除未使用的映像，而不必等待Emacs自动执行。</target>
        </trans-unit>
        <trans-unit id="641eb2680ee1c66beb56d48bd54946b6ae9853e6" translate="yes" xml:space="preserve">
          <source>Another way of classifying character syntax.</source>
          <target state="translated">字符语法的另一种分类方法。</target>
        </trans-unit>
        <trans-unit id="4bd2ea34cde1c693974149a710eecd977a89a21d" translate="yes" xml:space="preserve">
          <source>Another way to customize Imenu for a major mode is to set the variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;:</source>
          <target state="translated">为主要模式自定义Imenu的另一种方法是设置变量 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; 和 &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6a0538015d82239738c87e340807fdb7d0f6e3a0" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions for the current buffer. Continue to the next buffer in the sequence.</source>
          <target state="translated">回答&amp;ldquo;否&amp;rdquo;，然后放弃当前缓冲区的全部问题。继续执行序列中的下一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="274994b09ea810169b43f8a646ebc9ffc6bce18b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;no&amp;rdquo;, and give up on the entire series of questions, assuming that the answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">回答&amp;ldquo;否&amp;rdquo;，并假设答案为&amp;ldquo;否&amp;rdquo;，放弃整个系列问题。</target>
        </trans-unit>
        <trans-unit id="d8496e3b1f926969c35562be91206a0af61ee16e" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, and give up on the entire series of questions, assuming that subsequent answers will be &amp;ldquo;no&amp;rdquo;.</source>
          <target state="translated">假设随后的答案为&amp;ldquo;否&amp;rdquo;，则回答&amp;ldquo;是&amp;rdquo;，并放弃整个系列问题。</target>
        </trans-unit>
        <trans-unit id="f56b5305911f928e39581a218bfd705b0028549b" translate="yes" xml:space="preserve">
          <source>Answer this question &amp;ldquo;yes&amp;rdquo;, but show the results&amp;mdash;don&amp;rsquo;t advance yet to the next question.</source>
          <target state="translated">回答这个问题&amp;ldquo;是&amp;rdquo;，但是显示结果-尚未进入下一个问题。</target>
        </trans-unit>
        <trans-unit id="c32d375e1b285db59346c4795a32d1241b4b196d" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction, for all remaining buffers.</source>
          <target state="translated">对于所有剩余的缓冲区，使用&amp;ldquo;是&amp;rdquo;回答该问题以及系列中所有后续问题，而无需进一步的用户交互。</target>
        </trans-unit>
        <trans-unit id="cf8d75f96842754b6fdf5c2cb0d9b07cc288c581" translate="yes" xml:space="preserve">
          <source>Answer this question and all subsequent questions in the series with &amp;ldquo;yes&amp;rdquo;, without further user interaction.</source>
          <target state="translated">使用&amp;ldquo;是&amp;rdquo;回答该问题和系列中所有后续问题，而无需进一步的用户交互。</target>
        </trans-unit>
        <trans-unit id="58980dd0f49cd2faac7cab10b446ea677250ef35" translate="yes" xml:space="preserve">
          <source>Antinews</source>
          <target state="translated">Antinews</target>
        </trans-unit>
        <trans-unit id="1fa1accc626834eb5e37df54ce5a411a8faa2f5a" translate="yes" xml:space="preserve">
          <source>Any Lisp program output that would normally go to the echo area, either using &lt;code&gt;message&lt;/code&gt;, or using &lt;code&gt;prin1&lt;/code&gt;, etc., with &lt;code&gt;t&lt;/code&gt; as the stream, goes instead to Emacs&amp;rsquo;s standard descriptors when in batch mode: &lt;code&gt;message&lt;/code&gt; writes to the standard error descriptor, while &lt;code&gt;prin1&lt;/code&gt; and other print functions write to the standard output. Similarly, input that would normally come from the minibuffer is read from the standard input descriptor. Thus, Emacs behaves much like a noninteractive application program. (The echo area output that Emacs itself normally generates, such as command echoing, is suppressed entirely.)</source>
          <target state="translated">正常情况下，任何将使用 &lt;code&gt;t&lt;/code&gt; 作为流使用 &lt;code&gt;message&lt;/code&gt; 或 &lt;code&gt;prin1&lt;/code&gt; 等去回波区域的Lisp程序输出，在批处理模式下都将转至Emacs的标准描述符： &lt;code&gt;message&lt;/code&gt; 写入标准错误描述符，而 &lt;code&gt;prin1&lt;/code&gt; 和其他打印功能将写入标准输出。同样，通常会从迷你缓冲区中输入的内容是从标准输入描述符中读取的。因此，Emacs的行为非常像非交互式应用程序。 （Emacs本身通常生成的回声区域输出（例如命令回声）被完全抑制。）</target>
        </trans-unit>
        <trans-unit id="050f2a1f992936a9f3bd70f97c3df722975a4ffc" translate="yes" xml:space="preserve">
          <source>Any buffer which does not specify values for these variables uses the values specified by the &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">没有为这些变量指定值的任何缓冲区都将使用由 &lt;code&gt;left-fringe&lt;/code&gt; 和 &lt;code&gt;right-fringe&lt;/code&gt; 帧参数指定的值（请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;布局参数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fd492b9bb3754cde03d33417c72155f2cdb192d7" translate="yes" xml:space="preserve">
          <source>Any conditional construct can be expressed with &lt;code&gt;cond&lt;/code&gt; or with &lt;code&gt;if&lt;/code&gt;. Therefore, the choice between them is a matter of style. For example:</source>
          <target state="translated">任何条件构造都可以用 &lt;code&gt;cond&lt;/code&gt; 或 &lt;code&gt;if&lt;/code&gt; 表示。因此，它们之间的选择取决于样式。例如：</target>
        </trans-unit>
        <trans-unit id="6a06364a7a0a952bf465c39928bf99f3f61b0422" translate="yes" xml:space="preserve">
          <source>Any connection profile of &lt;var&gt;profiles&lt;/var&gt; must have been already defined by &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt;.</source>
          <target state="translated">概要文件的任何连接概要 &lt;var&gt;profiles&lt;/var&gt; 必须已经由 &lt;code&gt;connection-local-set-profile-variables&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="a92544790b0c628c4a67c0d9ad0654a8710429c7" translate="yes" xml:space="preserve">
          <source>Any function or macro defined as Lisp code may be set to break on entry, regardless of whether it is interpreted code or compiled code. If the function is a command, it will enter the debugger when called from Lisp and when called interactively (after the reading of the arguments). You can also set debug-on-entry for primitive functions (i.e., those written in C) this way, but it only takes effect when the primitive is called from Lisp code. Debug-on-entry is not allowed for special forms.</source>
          <target state="translated">任何定义为Lisp代码的函数或宏都可以设置为进入时中断,不管它是解释代码还是编译代码。如果函数是一个命令,那么当从Lisp调用时和交互式调用时(读取参数后),它将进入调试器。你也可以通过这种方式为基元函数(即用C语言编写的函数)设置debug-on-entry,但它只有在从Lisp代码中调用基元时才会生效。对于特殊形式的函数,不允许在进入时进行调试。</target>
        </trans-unit>
        <trans-unit id="8638b648157581df0efb6302834ee2f03492764d" translate="yes" xml:space="preserve">
          <source>Any integer glyph code greater than or equal to the length of the glyph table is displayed literally.</source>
          <target state="translated">任何大于或等于字形表长度的整数字形代码都会按字面显示。</target>
        </trans-unit>
        <trans-unit id="4c6a27c6563d69b7aca82f351f60298b13184203" translate="yes" xml:space="preserve">
          <source>Any kind of Lisp code is valid inside &lt;var&gt;body&lt;/var&gt;, but &lt;code&gt;iter-yield&lt;/code&gt; and &lt;code&gt;iter-yield-from&lt;/code&gt; cannot appear inside &lt;code&gt;unwind-protect&lt;/code&gt; forms.</source>
          <target state="translated">任何一种Lisp代码在 &lt;var&gt;body&lt;/var&gt; 都是有效的，但是 &lt;code&gt;iter-yield&lt;/code&gt; 和 &lt;code&gt;iter-yield-from&lt;/code&gt; 不能出现在 &lt;code&gt;unwind-protect&lt;/code&gt; 形式内。</target>
        </trans-unit>
        <trans-unit id="a4fc7cbf2349da81499a5258b7f6c62e471e0a86" translate="yes" xml:space="preserve">
          <source>Any of the above window elements (except &lt;code&gt;text&lt;/code&gt;) can also be used with &lt;code&gt;:align-to&lt;/code&gt; to specify that the position is relative to the left edge of the given area. Once the base offset for a relative position has been set (by the first occurrence of one of these symbols), further occurrences of these symbols are interpreted as the width of the specified area. For example, to align to the center of the left-margin, use</source>
          <target state="translated">上面的任何窗口元素（ &lt;code&gt;text&lt;/code&gt; 除外）也可以与 &lt;code&gt;:align-to&lt;/code&gt; 一起使用，以指定位置相对于给定区域的左边缘。一旦设置了相对位置的基本偏移量（通过第一次出现这些符号），这些符号的进一步出现将被解释为指定区域的宽度。例如，要与左边界的中心对齐，请使用</target>
        </trans-unit>
        <trans-unit id="947bbfa4cfb925a66b42d553b356034e0c632a8d" translate="yes" xml:space="preserve">
          <source>Any of these arguments can be given to identify the process that is to be configured. If none of these arguments is given, the current buffer&amp;rsquo;s process is used.</source>
          <target state="translated">可以提供任何这些参数来标识要配置的进程。如果没有给出这些参数，则使用当前缓冲区的进程。</target>
        </trans-unit>
        <trans-unit id="d761e83aca259b6c169b8f0ba443733debb02169" translate="yes" xml:space="preserve">
          <source>Any other character following &amp;lsquo;</source>
          <target state="translated">'之后的其他任何字符</target>
        </trans-unit>
        <trans-unit id="8b9b2ed191d1fda99979a3c9c2769788ca05c905" translate="yes" xml:space="preserve">
          <source>Any other format character results in an &amp;lsquo;</source>
          <target state="translated">任何其他格式的字符都会导致&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="da32c3cdd65afe4fd7df1698891716e553030ff9" translate="yes" xml:space="preserve">
          <source>Any other keyword arguments are passed directly to the &lt;code&gt;defcustom&lt;/code&gt; generated for the variable &lt;var&gt;mode&lt;/var&gt;.</source>
          <target state="translated">其他任何关键字参数都直接传递给为变量 &lt;var&gt;mode&lt;/var&gt; 生成的 &lt;code&gt;defcustom&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9dd7d9e5f6c66323cdba5127ceece8bda299da3" translate="yes" xml:space="preserve">
          <source>Any other kind of property value is a height spec, which translates into a number&amp;mdash;the specified line height. There are several ways to write a height spec; here&amp;rsquo;s how each of them translates into a number:</source>
          <target state="translated">任何其他类型的属性值都是高度规格，它可以转换为数字-指定的线高。有几种写高度规格的方法。以下是它们每个人如何转换成数字的方法：</target>
        </trans-unit>
        <trans-unit id="80c9ec34ade8e4048b77d042cf2894fc4d219cf7" translate="yes" xml:space="preserve">
          <source>Any other list is a &lt;em&gt;sublist specification&lt;/em&gt; and the argument must be a list whose elements match the specification &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">其他任何列表都是&lt;em&gt;子列表规范&lt;/em&gt;，并且参数必须是其元素与规范 &lt;var&gt;elements&lt;/var&gt; 匹配的列表。</target>
        </trans-unit>
        <trans-unit id="efc5f087f8ebb1db404013a2d9b97f161e290782" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to resize minibuffer-only frames by calling &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;).</source>
          <target state="translated">其他任何非 &lt;code&gt;nil&lt;/code&gt; 值都意味着通过调用 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 来调整仅用于迷你缓冲区的帧的&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;大小&lt;/a&gt;（请参见&amp;ldquo;调整Windows大小&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="de1dca44c2e30439c9ac0151a01ef3eee3bfac38" translate="yes" xml:space="preserve">
          <source>Any other non-&lt;code&gt;nil&lt;/code&gt; value means to select a window instantaneously as soon as the mouse pointer enters it.</source>
          <target state="translated">任何其他非 &lt;code&gt;nil&lt;/code&gt; 值表示鼠标指针一进入就立即选择一个窗口。</target>
        </trans-unit>
        <trans-unit id="e871933984652498dd2af321ce39af05be929b56" translate="yes" xml:space="preserve">
          <source>Any other symbol in a specification list may be a predicate or an indirect specification.</source>
          <target state="translated">规格表中的任何其他符号都可能是谓词或间接规格。</target>
        </trans-unit>
        <trans-unit id="dbbabe65f60d7295c7911e33efd55bcf43789dbf" translate="yes" xml:space="preserve">
          <source>Any other value for &lt;var&gt;order&lt;/var&gt; removes the numeric order of &lt;var&gt;element&lt;/var&gt; if it already has one; otherwise, it is equivalent to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;order&lt;/var&gt; 的其他任何值都已删除，则该 &lt;var&gt;element&lt;/var&gt; 的数字顺序将被删除；否则，它等效于 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8680b4e68cce538925a1e5ee144f0189a305515f" translate="yes" xml:space="preserve">
          <source>Any other value means consider windows on the selected frame.</source>
          <target state="translated">任何其他的值都意味着在选定的框架上考虑窗口。</target>
        </trans-unit>
        <trans-unit id="15b4bce70cfe3f06b7b1a2f9ed3099030510e5dc" translate="yes" xml:space="preserve">
          <source>Any other value means to try iconifying the child frame. Since such an attempt may not be honored by all window managers and can even lead to making the child frame unresponsive to user actions, the default is to iconify the top level frame instead.</source>
          <target state="translated">其他任何值都意味着尝试将子框架图标化。由于这样的尝试可能不会被所有的窗口管理器接受,甚至会导致子框架对用户的操作没有反应,所以默认为将顶层框架图标化。</target>
        </trans-unit>
        <trans-unit id="ebda99dde61c93e02da1a43ffb05fdba89a8d98e" translate="yes" xml:space="preserve">
          <source>Any other value of &lt;var&gt;require-match&lt;/var&gt; behaves like &lt;code&gt;t&lt;/code&gt;, except that the exit commands won&amp;rsquo;t exit if it performs completion.</source>
          <target state="translated">&lt;var&gt;require-match&lt;/var&gt; 的任何其他值的行为都类似于 &lt;code&gt;t&lt;/code&gt; ，除了exit命令执行完成不会退出。</target>
        </trans-unit>
        <trans-unit id="86b521e158439e11f2ef9516804d10581a8219f2" translate="yes" xml:space="preserve">
          <source>Any parameters not mentioned in &lt;var&gt;parameters&lt;/var&gt; default to the values in the alist &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;); parameters not specified there default from the X resources or its equivalent on your operating system (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="translated">中未提及的任何参数 &lt;var&gt;parameters&lt;/var&gt; 默认在ALIST的值 &lt;code&gt;default-frame-alist&lt;/code&gt; （见&lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;初始参数&lt;/a&gt;）; 参数没有指定默认有从X资源或等值操作系统（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X资源&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="9860f00e606061647e41c129f0e0903be5e003a1" translate="yes" xml:space="preserve">
          <source>Any processes that have this buffer as the &lt;code&gt;process-buffer&lt;/code&gt; are sent the &lt;code&gt;SIGHUP&lt;/code&gt; (hangup) signal, which normally causes them to terminate. See &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;.</source>
          <target state="translated">将具有此缓冲区作为 &lt;code&gt;process-buffer&lt;/code&gt; 缓冲区的所有进程都发送给 &lt;code&gt;SIGHUP&lt;/code&gt; （挂断）信号，通常会导致它们终止。请参阅&lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;过程信号&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="545802d960c72afb533f784369e021b83a96956f" translate="yes" xml:space="preserve">
          <source>Any redisplay triggering the run of window change functions may be aborted. If the abort occurs before window change functions have run to their completion, they will be run again with the previous values, that is, as if redisplay had not been performed. If aborted later, they will be run with the new values, that is, as if redisplay had been actually performed.</source>
          <target state="translated">任何触发窗口变化函数运行的重新显示都可能被中止。如果中止发生在窗口更改函数运行完成之前,它们将以以前的值再次运行,也就是说,就像没有执行过重新显示一样。如果稍后被中止,则将以新的值运行,也就是说,如同实际执行了重新显示一样。</target>
        </trans-unit>
        <trans-unit id="7024b793b36bc3e3bb195637c26938af29b056cc" translate="yes" xml:space="preserve">
          <source>Any two distinct Lisp objects are different as keys.</source>
          <target state="translated">任何两个不同的Lisp对象作为键都是不同的。</target>
        </trans-unit>
        <trans-unit id="2402827e518f1d5fcdc03543bf7c6c4f8b5d7ef6" translate="yes" xml:space="preserve">
          <source>Any two regular expressions &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; can be concatenated. The result is a regular expression that matches a string if &lt;var&gt;a&lt;/var&gt; matches some amount of the beginning of that string and &lt;var&gt;b&lt;/var&gt; matches the rest of the string.</source>
          <target state="translated">任何两个正则表达式 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 都可以串联。如果 &lt;var&gt;a&lt;/var&gt; 匹配该字符串的开头部分，而 &lt;var&gt;b&lt;/var&gt; 匹配该字符串的其余部分，则结果是匹配该字符串的正则表达式。</target>
        </trans-unit>
        <trans-unit id="45ffc4ae2f26e287178694c6132c38fe72023bb0" translate="yes" xml:space="preserve">
          <source>Any unhandled errors while loading a file terminate loading. If the load was done for the sake of &lt;code&gt;autoload&lt;/code&gt;, any function definitions made during the loading are undone.</source>
          <target state="translated">加载文件时任何未处理的错误将终止加载。如果加载是出于 &lt;code&gt;autoload&lt;/code&gt; 的考虑，则在加载过程中所做的任何函数定义都将被撤消。</target>
        </trans-unit>
        <trans-unit id="1ceb1e23a710f2ab6b34678613c9db79937409cd" translate="yes" xml:space="preserve">
          <source>Any variable whose name has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property is considered risky. When you define a user option using &lt;code&gt;defcustom&lt;/code&gt;, you can set its &lt;code&gt;risky-local-variable&lt;/code&gt; property by adding the arguments &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to &lt;code&gt;defcustom&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). In addition, any variable whose name ends in any of &amp;lsquo;</source>
          <target state="translated">任何变量，其名称中有非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;risky-local-variable&lt;/code&gt; 特性被认为是有风险的。当您使用定义用户选项 &lt;code&gt;defcustom&lt;/code&gt; ，您可以设置其 &lt;code&gt;risky-local-variable&lt;/code&gt; 通过添加参数属性 &lt;code&gt;:risky &lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 来 &lt;code&gt;defcustom&lt;/code&gt; （见&lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;变量定义&lt;/a&gt;）。此外，任何名称以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2146f7db0997563acb7fa242e2c3506c43699f4a" translate="yes" xml:space="preserve">
          <source>Anything else means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame, and no others.</source>
          <target state="translated">别的意思就是只考虑窗框上的 &lt;var&gt;window&lt;/var&gt; 不要考虑其他任何东西。</target>
        </trans-unit>
        <trans-unit id="ed179d7c24b9f78db2acddd1c26cf5d5e3a10309" translate="yes" xml:space="preserve">
          <source>Apart from Fundamental mode, there are three major modes that other major modes commonly derive from: Text mode, Prog mode, and Special mode. While Text mode is useful in its own right (e.g., for editing files ending in</source>
          <target state="translated">除了基本模式,其他主要模式通常衍生出三种主要模式:文本模式、程序模式和特殊模式。虽然文本模式本身就很有用(例如,编辑以</target>
        </trans-unit>
        <trans-unit id="d92f266ff96117cb3b55d3ff2938ee734d58418c" translate="yes" xml:space="preserve">
          <source>Apart from the above usual keymaps, Emacs provides special ways for programs to make other keymaps active. Firstly, the variable &lt;code&gt;overriding-local-map&lt;/code&gt; specifies a keymap that replaces the usual active keymaps, except for the global keymap. Secondly, the terminal-local variable &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; specifies a keymap that takes precedence over &lt;em&gt;all&lt;/em&gt; other keymaps (including &lt;code&gt;overriding-local-map&lt;/code&gt;); this is normally used for modal/transient keybindings (the function &lt;code&gt;set-transient-map&lt;/code&gt; provides a convenient interface for this). See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;, for details.</source>
          <target state="translated">除了上述通常的键盘映射外，Emacs还为程序提供了使其他键盘映射处于活动状态的特殊方法。首先，变量 &lt;code&gt;overriding-local-map&lt;/code&gt; 指定了一个键盘图，该键盘图代替了除了全局键盘图之外的常用活动键盘图。其次，terminal-local变量 &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; 指定了一个优先于&lt;em&gt;所有&lt;/em&gt;其他 &lt;code&gt;overriding-local-map&lt;/code&gt; （包括overriding-local-map）的键图；通常用于模式/瞬态键绑定（功能 &lt;code&gt;set-transient-map&lt;/code&gt; 为此提供了一个方便的接口）。有关详细信息，请参见&lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;控制活动地图&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a68119502a0311abd68d0719c5b77a5911c9e84f" translate="yes" xml:space="preserve">
          <source>Apart from the functions documented in this section, you can print Lisp objects to the echo area by specifying &lt;code&gt;t&lt;/code&gt; as the output stream. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">除了本节中介绍的功能外，还可以通过将 &lt;code&gt;t&lt;/code&gt; 指定为输出流，将Lisp对象打印到回显区域。请参见&lt;a href=&quot;output-streams#Output-Streams&quot;&gt;输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cd2802aef7e489fd6909738c550b3b9f5ec028d" translate="yes" xml:space="preserve">
          <source>Apart from the values given below, each face attribute can have the value &lt;code&gt;unspecified&lt;/code&gt;. This special value means that the face doesn&amp;rsquo;t specify that attribute directly. An &lt;code&gt;unspecified&lt;/code&gt; attribute tells Emacs to refer instead to a parent face (see the description &lt;code&gt;:inherit&lt;/code&gt; attribute below); or, failing that, to an underlying face (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). The &lt;code&gt;default&lt;/code&gt; face must specify all attributes.</source>
          <target state="translated">除了下面给出的值外，每个face属性的值都可 &lt;code&gt;unspecified&lt;/code&gt; 。此特殊值表示面部不会直接指定该属性。一个 &lt;code&gt;unspecified&lt;/code&gt; 属性告诉Emacs的代替来指代一个父面（参见说明书 &lt;code&gt;:inherit&lt;/code&gt; 以下属性）; 或者，如果失败，则&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;显示&lt;/a&gt;在基础面上（请参见显示面）。在 &lt;code&gt;default&lt;/code&gt; 的脸必须指定的所有属性。</target>
        </trans-unit>
        <trans-unit id="f240948e5698f084e306e2f0433d5215c7e9dc03" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;child&lt;/var&gt; as the last child of &lt;var&gt;node&lt;/var&gt;.</source>
          <target state="translated">将 &lt;var&gt;child&lt;/var&gt; 追加为 &lt;var&gt;node&lt;/var&gt; 的最后一个子项。</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="6453a2437bbdcb5f8fffb150dbc05d248106b629" translate="yes" xml:space="preserve">
          <source>Applications should put a function on this hook only if they want to react to changes that happened on (or have been signaled for) two or more frames since last redisplay. In every other case, putting the function on &lt;code&gt;window-state-change-functions&lt;/code&gt; should be preferred.</source>
          <target state="translated">应用程序仅在希望对自上次重新显示以来在两个或更多帧上发生（或已发出信号）的更改做出反应时，才应在此挂钩上放置函数。在其他所有情况下，都应首选将该功能置于 &lt;code&gt;window-state-change-functions&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="26de2593285b5ae9fccf013cfbb25224e0f5a299" translate="yes" xml:space="preserve">
          <source>Applying Customizations</source>
          <target state="translated">应用自定义</target>
        </trans-unit>
        <trans-unit id="36aa9251a3a7a8564f2137c662428024f6ade2c8" translate="yes" xml:space="preserve">
          <source>Applying a function to each element of a list, etc.</source>
          <target state="translated">将函数应用于列表的每个元素等。</target>
        </trans-unit>
        <trans-unit id="8d1feffaedb79bbeb47768ea8d15131f798d1c88" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer and returned as a string (see &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;). Terminate the input with either</source>
          <target state="translated">任意文本，读入minibuffer并作为字符串返回（请参见&lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Minibuffer中的Text&lt;/a&gt;）。使用以下任一终止输入</target>
        </trans-unit>
        <trans-unit id="7d9f86d28b0c0c91c1eb18ed796eb1ba12533f22" translate="yes" xml:space="preserve">
          <source>Arbitrary text, read in the minibuffer using the current buffer&amp;rsquo;s input method, and returned as a string (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;Input Methods&lt;/a&gt; in</source>
          <target state="translated">任意的文本，使用当前缓冲区的输入法读取迷你缓冲区，并返回一个字符串（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Input-Methods.html#Input-Methods&quot;&gt;输入法&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="bd4951fd6a7c3feab0f23a3cd32635bc99258318" translate="yes" xml:space="preserve">
          <source>Args out of range</source>
          <target state="translated">Args超出范围</target>
        </trans-unit>
        <trans-unit id="0c474d136d838c73efef53606031eb17d140e04e" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;literal&lt;/code&gt; and &lt;code&gt;regexp&lt;/code&gt; forms in &lt;var&gt;rx-expr&lt;/var&gt; must be string literals.</source>
          <target state="translated">&lt;var&gt;rx-expr&lt;/var&gt; 中的 &lt;code&gt;literal&lt;/code&gt; 和正则 &lt;code&gt;regexp&lt;/code&gt; 形式的参数必须是字符串文字。</target>
        </trans-unit>
        <trans-unit id="067d717a61de8fed36456114a24a52f9975bc09e" translate="yes" xml:space="preserve">
          <source>Arithmetic Operations</source>
          <target state="translated">算术运算</target>
        </trans-unit>
        <trans-unit id="e9ba134322b748a6c1b2b91140e83920bb3352f8" translate="yes" xml:space="preserve">
          <source>Arithmetic error</source>
          <target state="translated">算术错误</target>
        </trans-unit>
        <trans-unit id="11d55c8ac9f9031983e49487cf4e01cc836699f5" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow error</source>
          <target state="translated">算术溢出错误</target>
        </trans-unit>
        <trans-unit id="d11aaaa37e2311485d3875fbb3013fe0f23d4b0b" translate="yes" xml:space="preserve">
          <source>Around advice such as:</source>
          <target state="translated">左右的建议,如:</target>
        </trans-unit>
        <trans-unit id="41fcc6cba3496dc0275b2af2eceda84dfb41da3d" translate="yes" xml:space="preserve">
          <source>Arrange to scan these files when producing the</source>
          <target state="translated">安排扫描这些文件时,制作</target>
        </trans-unit>
        <trans-unit id="5a208284047f94a448814865ab5ceb940cbbaf32" translate="yes" xml:space="preserve">
          <source>Arranging to run a cleanup form if an error happens.</source>
          <target state="translated">如果发生错误,安排运行清理表格。</target>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="73e54889ed8e57216f0ca1581847b9782331ae4c" translate="yes" xml:space="preserve">
          <source>Array, a fixed-size set of Lisp objects which may be accessed by an index.</source>
          <target state="translated">阵列,一个固定大小的Lisp对象集合,可以通过索引来访问。</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="081ca36507218ed52666e78775654403a5cbd1aa" translate="yes" xml:space="preserve">
          <source>Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;), but vectors do not support text properties, even when their elements happen to be characters.</source>
          <target state="translated">数组是固定长度的序列。它们进一步细分为字符串，向量，字符表和布尔向量。向量可以容纳任何类型的元素，而字符串元素必须是字符，布尔向量元素必须是 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。字符表类似于向量，只是它们由任何有效的字符代码索引。字符串中的字符可以具有文本属性，例如缓冲区中的字符（请参见&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;），但是向量不支持文本属性，即使它们的元素碰巧是字符。</target>
        </trans-unit>
        <trans-unit id="ce9ceca356ae903e8b84ce8876d693efd3ec5212" translate="yes" xml:space="preserve">
          <source>Arrays include strings and vectors.</source>
          <target state="translated">数组包括字符串和向量。</target>
        </trans-unit>
        <trans-unit id="2a256f62beeee99618180946ede4c7802661b91b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;lsh&lt;/code&gt; behaves like &lt;code&gt;ash&lt;/code&gt; except when &lt;var&gt;integer1&lt;/var&gt; and &lt;var&gt;count1&lt;/var&gt; are both negative, the following examples focus on these exceptional cases. These examples assume 30-bit fixnums.</source>
          <target state="translated">由于 &lt;code&gt;lsh&lt;/code&gt; 的行为类似于 &lt;code&gt;ash&lt;/code&gt; ,除了 &lt;var&gt;integer1&lt;/var&gt; 和 &lt;var&gt;count1&lt;/var&gt; 均为负时，下面的示例重点介绍这些例外情况。这些示例假定使用30位fixnum。</target>
        </trans-unit>
        <trans-unit id="85514a867e7a20560268b28853e86e5aa494f0b6" translate="yes" xml:space="preserve">
          <source>As a &amp;lsquo;</source>
          <target state="translated">作为一个 '</target>
        </trans-unit>
        <trans-unit id="06830ace04b31c9ec49e44f925889f374b949f5a" translate="yes" xml:space="preserve">
          <source>As a final step, before returning the chosen coding system, &lt;code&gt;select-safe-coding-system&lt;/code&gt; checks whether that coding system is consistent with what would be selected if the contents of the region were read from a file. (If not, this could lead to data corruption in a file subsequently re-visited and edited.) Normally, &lt;code&gt;select-safe-coding-system&lt;/code&gt; uses &lt;code&gt;buffer-file-name&lt;/code&gt; as the file for this purpose, but if &lt;var&gt;file&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it uses that file instead (this can be relevant for &lt;code&gt;write-region&lt;/code&gt; and similar functions). If it detects an apparent inconsistency, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user before selecting the coding system.</source>
          <target state="translated">最后一步，在返回选定的编码系统之前， &lt;code&gt;select-safe-coding-system&lt;/code&gt; 检查该编码系统是否与从文件中读取区域内容时选择的编码系统一致。 （否则，可能会导致随后重新访问和编辑的文件中的数据损坏。）通常， &lt;code&gt;select-safe-coding-system&lt;/code&gt; 为此目的使用 &lt;code&gt;buffer-file-name&lt;/code&gt; 作为文件，但如果 &lt;var&gt;file&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，它改为使用该文件（这可能与 &lt;code&gt;write-region&lt;/code&gt; 和类似功能有关）。如果检测到明显的不一致， &lt;code&gt;select-safe-coding-system&lt;/code&gt; 将在选择编码系统之前查询用户。</target>
        </trans-unit>
        <trans-unit id="8347ee4e8693c87255357e7f5883850b386cce75" translate="yes" xml:space="preserve">
          <source>As a general recommendation, try to avoid using &lt;code&gt;looking-back&lt;/code&gt; wherever possible, since it is slow. For this reason, there are no plans to add a &lt;code&gt;looking-back-p&lt;/code&gt; function.</source>
          <target state="translated">通常建议尽量避免使用 &lt;code&gt;looking-back&lt;/code&gt; ，因为它很慢。因此，没有计划添加 &lt;code&gt;looking-back-p&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="082ed7d43ef6ed77537415a322f89e49796457df" translate="yes" xml:space="preserve">
          <source>As a historical accident, &lt;var&gt;position&lt;/var&gt; was implemented inconsistently in different functions. In &lt;code&gt;completing-read&lt;/code&gt;, &lt;var&gt;position&lt;/var&gt;&amp;rsquo;s value is interpreted as origin-zero; that is, a value of 0 means the beginning of the string, 1 means after the first character, etc. In &lt;code&gt;read-minibuffer&lt;/code&gt;, and the other non-completion minibuffer input functions that support this argument, 1 means the beginning of the string, 2 means after the first character, etc.</source>
          <target state="translated">作为历史事故， &lt;var&gt;position&lt;/var&gt; 在不同职能中的执行不一致。在 &lt;code&gt;completing-read&lt;/code&gt; ， &lt;var&gt;position&lt;/var&gt; 的值被解释为原点为零；也就是说，值0表示字符串的开头，1表示第一个字符的后面， &lt;code&gt;read-minibuffer&lt;/code&gt; 。在read-minibuffer中，以及其他支持该参数的非完成微型缓冲区输入函数，1表示字符串的开头， 2表示第一个字符之后，依此类推。</target>
        </trans-unit>
        <trans-unit id="4294650896b83fd9e5d4be93d12e4c592d4f0ccc" translate="yes" xml:space="preserve">
          <source>As a practical matter, if you are writing text for other people to read, you should set &lt;code&gt;fill-column&lt;/code&gt; to no more than 70. Otherwise the line will be too long for people to read comfortably, and this can make the text seem clumsy.</source>
          <target state="translated">实际上，如果您要编写文本供其他人阅读，则应将 &lt;code&gt;fill-column&lt;/code&gt; 设置为不超过70。否则，该行将太长而使人们无法舒适地阅读，这会使文本显得笨拙。</target>
        </trans-unit>
        <trans-unit id="bb4aaf8789bdd2420621e991adcf2190aa28b7df" translate="yes" xml:space="preserve">
          <source>As a result, it is currently not possible to represent the character</source>
          <target state="translated">因此,目前还无法表示该字样。</target>
        </trans-unit>
        <trans-unit id="b5eb1265a3a71f4ed8bb8ff9aa6033bf57cae934" translate="yes" xml:space="preserve">
          <source>As a rule, the inner frame is subdivided into the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) and the frame&amp;rsquo;s minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). There are two notable exceptions to this rule: A &lt;em&gt;minibuffer-less frame&lt;/em&gt; contains a root window only and does not contain a minibuffer window. A &lt;em&gt;minibuffer-only frame&lt;/em&gt; contains only a minibuffer window which also serves as that frame&amp;rsquo;s root window. See &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt; for how to create such frame configurations.</source>
          <target state="translated">通常，将内部框架细分为框架的根窗口（请参见&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames&lt;/a&gt;）和框架的&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;minibuffer&lt;/a&gt;窗口（请参见Minibuffer Windows）。此规则有两个值得注意的例外：无小&lt;em&gt;缓冲区的帧&lt;/em&gt;仅包含一个根窗口，不包含小缓冲区窗口。甲&lt;em&gt;只迷你缓冲区帧&lt;/em&gt;仅包含一个小缓冲区窗口也用作该帧的根窗口。有关如何创建此类框架配置的信息，请参见&lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;初始参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7658703b932157d4e051dbdce1277e8475ac36f2" translate="yes" xml:space="preserve">
          <source>As a side effect, backups are necessarily made by copying. See &lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;Rename or Copy&lt;/a&gt;. Yet, at the same time, saving a precious file always breaks all hard links between the file you save and other file names.</source>
          <target state="translated">副作用是，备份必须通过复制进行。请参阅&lt;a href=&quot;rename-or-copy#Rename-or-Copy&quot;&gt;重命名或复制&lt;/a&gt;。但是，同时保存宝贵的文件总是会破坏您保存的文件与其他文件名之间的所有硬链接。</target>
        </trans-unit>
        <trans-unit id="c897a9ef1100434cc7715e3fbb47fdb7454824de" translate="yes" xml:space="preserve">
          <source>As a simple example, we can concatenate the regular expressions &amp;lsquo;</source>
          <target state="translated">举一个简单的例子，我们可以将正则表达式'</target>
        </trans-unit>
        <trans-unit id="bc0e4551b2a377b6cea04f402200bc2b67248275" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;next&lt;/code&gt; of a frame&amp;rsquo;s root window points to the frame&amp;rsquo;s minibuffer window, provided this is not a minibuffer-only or minibuffer-less frame. On such frames &lt;code&gt;prev&lt;/code&gt; of the minibuffer window points to that frame&amp;rsquo;s root window. In any other case, the root window&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; and the minibuffer window&amp;rsquo;s (if present) &lt;code&gt;prev&lt;/code&gt; fields are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">作为一种特殊情况，如果不是非纯缓冲区或无迷你缓冲区的帧，则帧根窗口的 &lt;code&gt;next&lt;/code&gt; 一个指向该帧的微缓冲区窗口。在这样的帧 &lt;code&gt;prev&lt;/code&gt; 迷你缓冲区窗口指向帧的根窗口的。在任何其他情况下，根窗口的 &lt;code&gt;next&lt;/code&gt; 字段和微型缓冲区窗口的 &lt;code&gt;prev&lt;/code&gt; 字段（如果存在）均为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="640b1e7193c0828a7e9c0e26231c2f3a2ad3a5f4" translate="yes" xml:space="preserve">
          <source>As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; arguments of the &lt;code&gt;write-region&lt;/code&gt; call, giving them the values of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function.</source>
          <target state="translated">在特殊情况下，函数可能会以不同的缓冲电流返回。Emacs将此表示当前缓冲区包含要输出的更改的文本。因此，它更改了 &lt;code&gt;write-region&lt;/code&gt; 调用的 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 参数，分别为它们提供了新缓冲区中的 &lt;code&gt;point-min&lt;/code&gt; 和 &lt;code&gt;point-max&lt;/code&gt; 的值。它还会丢弃所有先前的注释，因为此功能本应处理它们。</target>
        </trans-unit>
        <trans-unit id="538f59aab9497ba8d48e55c2e55b2635fbda077a" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">作为特殊情况，如果 &lt;var&gt;cons-cell&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则此函数返回 &lt;code&gt;nil&lt;/code&gt; 。因此，任何列表都是有效的参数。如果参数不是cons单元格或 &lt;code&gt;nil&lt;/code&gt; ,则表明存在错误。</target>
        </trans-unit>
        <trans-unit id="9e59f0605f808bdde6a150c85073aac9e660ad27" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;cons-cell&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt;; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">作为特殊情况，如果 &lt;var&gt;cons-cell&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则此函数返回 &lt;code&gt;nil&lt;/code&gt; ；因此，任何列表都是有效的参数。如果参数不是cons单元格或 &lt;code&gt;nil&lt;/code&gt; ,则表明存在错误。</target>
        </trans-unit>
        <trans-unit id="ca7cece4ddf32f2b45c2031fd9e867d6b7889049" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;var&gt;flag&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;window&lt;/var&gt; becomes &lt;em&gt;strongly&lt;/em&gt; dedicated to its buffer. &lt;code&gt;set-window-buffer&lt;/code&gt; signals an error when the window it acts upon is strongly dedicated to its buffer and does not already display the buffer it is asked to display. Other functions do not treat &lt;code&gt;t&lt;/code&gt; differently from any non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">作为一个特殊的情况下，如果 &lt;var&gt;flag&lt;/var&gt; 是 &lt;code&gt;t&lt;/code&gt; ， &lt;var&gt;window&lt;/var&gt; 变得&lt;em&gt;强烈&lt;/em&gt;奉献给它的缓冲区。当它所作用的窗口强烈专用于其缓冲区并且尚未显示要显示的缓冲区时， &lt;code&gt;set-window-buffer&lt;/code&gt; 会发出错误信号。其它功能不把 &lt;code&gt;t&lt;/code&gt; 不同于任何非 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="4aced0063585f5b279a49199acec884cc3288ce9" translate="yes" xml:space="preserve">
          <source>As a special exception, the error symbol &lt;code&gt;quit&lt;/code&gt; does not have the condition &lt;code&gt;error&lt;/code&gt;, because quitting is not considered an error.</source>
          <target state="translated">作为特殊的例外，错误符号 &lt;code&gt;quit&lt;/code&gt; 没有条件 &lt;code&gt;error&lt;/code&gt; ，因为退出不被视为错误。</target>
        </trans-unit>
        <trans-unit id="07d6ca82a5135dea4c0b8a8393dd8ef483c67bf7" translate="yes" xml:space="preserve">
          <source>As a technical detail, when &lt;var&gt;switches&lt;/var&gt; contains the long &amp;lsquo;</source>
          <target state="translated">作为技术细节，当 &lt;var&gt;switches&lt;/var&gt; 包含较长的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8f4f9b3b2bfdbcd1a575981570d572a49858acde" translate="yes" xml:space="preserve">
          <source>As a trivial example, here&amp;rsquo;s how to add advice that&amp;rsquo;ll modify the return value of a function every time it&amp;rsquo;s called:</source>
          <target state="translated">作为一个简单的示例，以下是添加建议的方法，该建议将在每次调用函数时修改函数的返回值：</target>
        </trans-unit>
        <trans-unit id="b1f3d0120b8c51d503e5e5327b8ce35d598fd0fd" translate="yes" xml:space="preserve">
          <source>As always, there must be no possibility of intervening searches between the call to a search function and the call to &lt;code&gt;match-data&lt;/code&gt; that is intended to access the match data for that search.</source>
          <target state="translated">与往常一样，在搜索功能的调用 &lt;code&gt;match-data&lt;/code&gt; 旨在访问该搜索的匹配数据的对匹配数据的调用之间不应介入搜索。</target>
        </trans-unit>
        <trans-unit id="1472e06e8a8fc0331e8821e03360d8c11b163707" translate="yes" xml:space="preserve">
          <source>As an alternative to the string-based syntax, Emacs provides the structured &lt;code&gt;rx&lt;/code&gt; notation based on Lisp S-expressions. This notation is usually easier to read, write and maintain than regexp strings, and can be indented and commented freely. It requires a conversion into string form since that is what regexp functions expect, but that conversion typically takes place during byte-compilation rather than when the Lisp code using the regexp is run.</source>
          <target state="translated">作为基于字符串的语法的替代，Emacs提供了基于Lisp S表达式的结构化 &lt;code&gt;rx&lt;/code&gt; 表示法。这种表示法通常比regexp字符串更易于阅读，编写和维护，并且可以自由缩进和注释。它需要转换为字符串形式，因为这是regexp函数所期望的，但是这种转换通常在字节编译期间进行，而不是在运行使用regexp的Lisp代码时进行。</target>
        </trans-unit>
        <trans-unit id="95b6d5f91746264f4dd9c82e53bfbbe800efcb96" translate="yes" xml:space="preserve">
          <source>As an example of &lt;code&gt;sort-subr&lt;/code&gt;, here is the complete function definition for &lt;code&gt;sort-lines&lt;/code&gt;:</source>
          <target state="translated">作为一个例子 &lt;code&gt;sort-subr&lt;/code&gt; ，这里是完整的函数定义 &lt;code&gt;sort-lines&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39d7c3afd50025e1aeeb3300312260fc1e12eaba" translate="yes" xml:space="preserve">
          <source>As an example, here is a sequence of &lt;code&gt;split-window&lt;/code&gt; calls that yields the window configuration discussed in &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;. This example demonstrates splitting a live window as well as splitting an internal window. We begin with a frame containing a single window (a live root window), which we denote by &lt;var&gt;W4&lt;/var&gt;. Calling &lt;code&gt;(split-window W4)&lt;/code&gt; yields this window configuration:</source>
          <target state="translated">例如，这是一系列 &lt;code&gt;split-window&lt;/code&gt; 调用，产生了&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames中&lt;/a&gt;讨论的窗口配置。此示例演示了拆分活动窗口以及拆分内部窗口。我们从包含单个窗口（活动根窗口）的框架开始，用 &lt;var&gt;W4&lt;/var&gt; 表示。调用 &lt;code&gt;(split-window W4)&lt;/code&gt; 产生以下窗口配置：</target>
        </trans-unit>
        <trans-unit id="3000460ba524b76305a7ac5b84a2be2cc384cf2b" translate="yes" xml:space="preserve">
          <source>As an example, here&amp;rsquo;s a simplified (and inefficient) version of the primitive function &lt;code&gt;next-single-char-property-change&lt;/code&gt; (see &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;). It searches forward from position &lt;var&gt;pos&lt;/var&gt; for the next position where the value of a given property &lt;code&gt;prop&lt;/code&gt;, as obtained from either overlays or text properties, changes.</source>
          <target state="translated">作为示例，这是原始函数 &lt;code&gt;next-single-char-property-change&lt;/code&gt; 的简化（且效率低下）版本（请参阅&lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;）。它从位置 &lt;var&gt;pos&lt;/var&gt; 向前搜索下一个位置，在下一个位置，从覆盖或文本属性获得的给定属性 &lt;code&gt;prop&lt;/code&gt; 的值将发生变化。</target>
        </trans-unit>
        <trans-unit id="ac2005a3b3b773dfac881bf44c6dc9ffab49bfce" translate="yes" xml:space="preserve">
          <source>As an exception to the rule that a symbol&amp;rsquo;s name serves as its printed representation, &amp;lsquo;</source>
          <target state="translated">作为符号印刷名称的规则的例外，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2daa82fa454d2ab6dd7bfac54a9eefb51ae6ff85" translate="yes" xml:space="preserve">
          <source>As an exception, if you evaluate a &lt;code&gt;defface&lt;/code&gt; form with</source>
          <target state="translated">作为例外，如果你评估一个 &lt;code&gt;defface&lt;/code&gt; 形式</target>
        </trans-unit>
        <trans-unit id="1a2d268c77084e31235d0ca81e4bd6ebfe990b03" translate="yes" xml:space="preserve">
          <source>As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:</source>
          <target state="translated">作为例外,如果以下条件全部为真,该函数将使用图形文件对话框而不是minibuffer读取文件名。</target>
        </trans-unit>
        <trans-unit id="7f170945bb4b449cfc683c1ed37876c06db96463" translate="yes" xml:space="preserve">
          <source>As an obsolescent calling convention, this function can be given six or more arguments. The first six arguments &lt;var&gt;second&lt;/var&gt;, &lt;var&gt;minute&lt;/var&gt;, &lt;var&gt;hour&lt;/var&gt;, &lt;var&gt;day&lt;/var&gt;, &lt;var&gt;month&lt;/var&gt;, and &lt;var&gt;year&lt;/var&gt; specify most of the components of a decoded time. If there are more than six arguments the &lt;em&gt;last&lt;/em&gt; argument is used as &lt;var&gt;zone&lt;/var&gt; and any other extra arguments are ignored, so that &lt;code&gt;(apply
#'encode-time (decode-time ...))&lt;/code&gt; works. In this obsolescent convention, &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule (see &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;), and &lt;var&gt;dst&lt;/var&gt; is treated as if it was -1.</source>
          <target state="translated">作为过时的调用约定，可以给此函数六个或更多参数。前六个参数 &lt;var&gt;second&lt;/var&gt; ， &lt;var&gt;minute&lt;/var&gt; s， &lt;var&gt;hour&lt;/var&gt; ， &lt;var&gt;day&lt;/var&gt; ， &lt;var&gt;month&lt;/var&gt; 和 &lt;var&gt;year&lt;/var&gt; 指定了解码时间的大部分内容。如果有六个以上的参数，则将&lt;em&gt;最后一个&lt;/em&gt;参数用作 &lt;var&gt;zone&lt;/var&gt; 并忽略其他所有参数，以便 &lt;code&gt;(apply #'encode-time (decode-time ...))&lt;/code&gt; 有效。在此过时的约定中， &lt;var&gt;zone&lt;/var&gt; 默认为当前时区规则（请参阅&lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;），并且 &lt;var&gt;dst&lt;/var&gt; 视为-1。</target>
        </trans-unit>
        <trans-unit id="2491282a6d1f8281ac0fcd08cc3d8281fc7d632e" translate="yes" xml:space="preserve">
          <source>As editing continues, undo lists get longer and longer. To prevent them from using up all available memory space, garbage collection trims them back to size limits you can set. (For this purpose, the size of an undo list measures the cons cells that make up the list, plus the strings of deleted text.) Three variables control the range of acceptable sizes: &lt;code&gt;undo-limit&lt;/code&gt;, &lt;code&gt;undo-strong-limit&lt;/code&gt; and &lt;code&gt;undo-outer-limit&lt;/code&gt;. In these variables, size is counted as the number of bytes occupied, which includes both saved text and other data.</source>
          <target state="translated">随着编辑的继续，撤消列表变得越来越长。为了防止它们耗尽所有可用的内存空间，垃圾回收会将它们修剪回可以设置的大小限制。 （为此，撤消列表的大小将测量组成列表的con单元格，以及已删除的文本字符串。）三个变量控制可接受大小的范围： &lt;code&gt;undo-limit&lt;/code&gt; ， &lt;code&gt;undo-strong-limit&lt;/code&gt; 和 &lt;code&gt;undo-outer-limit&lt;/code&gt; 。在这些变量中，大小被计算为占用的字节数，其中包括保存的文本和其他数据。</target>
        </trans-unit>
        <trans-unit id="39fc3a710f302293efc2b0bded9197ae640e963b" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;, Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with &lt;code&gt;defun&lt;/code&gt;), as well as any anonymous function that you create using the &lt;code&gt;lambda&lt;/code&gt; macro or the &lt;code&gt;function&lt;/code&gt; special form or the &lt;code&gt;#'&lt;/code&gt; syntax (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), is automatically converted into a &lt;em&gt;closure&lt;/em&gt;.</source>
          <target state="translated">如&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;变量作用域中所述&lt;/a&gt;，Emacs可以选择启用变量的词法绑定。启用词法绑定后，您创建的任何命名函数（例如，使用 &lt;code&gt;defun&lt;/code&gt; ）以及使用 &lt;code&gt;lambda&lt;/code&gt; 宏或特殊形式的 &lt;code&gt;function&lt;/code&gt; 或 &lt;code&gt;#'&lt;/code&gt; 语法创建的任何匿名函数（请参见&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;匿名函数&lt;/a&gt;）都会自动生成。转换成&lt;em&gt;闭包&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="72d71c3cc374384e0af0a0724fbb040625e0c496" translate="yes" xml:space="preserve">
          <source>As far as &lt;code&gt;define-key&lt;/code&gt; is concerned, &lt;var&gt;item-string&lt;/var&gt; and &lt;var&gt;help-string&lt;/var&gt; are part of the event&amp;rsquo;s binding. However, &lt;code&gt;lookup-key&lt;/code&gt; returns just &lt;var&gt;real-binding&lt;/var&gt;, and only &lt;var&gt;real-binding&lt;/var&gt; is used for executing the key.</source>
          <target state="translated">就 &lt;code&gt;define-key&lt;/code&gt; 而言， &lt;var&gt;item-string&lt;/var&gt; 和 &lt;var&gt;help-string&lt;/var&gt; 是事件绑定的一部分。但是， &lt;code&gt;lookup-key&lt;/code&gt; 仅返回 &lt;var&gt;real-binding&lt;/var&gt; ，并且仅使用 &lt;var&gt;real-binding&lt;/var&gt; 来执行密钥。</target>
        </trans-unit>
        <trans-unit id="04371b35f248ca488e9627aecf5dda4a949a350a" translate="yes" xml:space="preserve">
          <source>As far as possible, new major modes should be derived, either directly or indirectly, from one of these three modes. One reason is that this allows users to customize a single mode hook (e.g., &lt;code&gt;prog-mode-hook&lt;/code&gt;) for an entire family of relevant modes (e.g., all programming language modes).</source>
          <target state="translated">应当尽可能直接或间接地从这三种模式之一派生新的主要模式。一个原因是，这允许用户为整个相关模式家族（例如，所有编程语言模式）定制单个模式挂钩（例如 &lt;code&gt;prog-mode-hook&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff3ef6be607829903e8a6baac8628d90d56c089f" translate="yes" xml:space="preserve">
          <source>As far as the Lisp reader is concerned, &amp;lsquo;</source>
          <target state="translated">就Lisp阅读器而言，</target>
        </trans-unit>
        <trans-unit id="c87e482a1ccf8205de796dac23a5ade838dbdd25" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;nil&lt;/code&gt;, but if</source>
          <target state="translated">至于 &lt;code&gt;nil&lt;/code&gt; ，但如果</target>
        </trans-unit>
        <trans-unit id="e20b47eb8e540da13af46101ac4dc2b6a5827bfb" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;x-popup-menu&lt;/code&gt;, an element of the list may be just a string instead of a cons cell &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. That makes a box that cannot be selected.</source>
          <target state="translated">至于 &lt;code&gt;x-popup-menu&lt;/code&gt; ，列表的一个元件可以是只是一个字符串，而不是一个cons单元 &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 。这将导致无法选择一个框。</target>
        </trans-unit>
        <trans-unit id="18f02bf364dcfbbb51fe785b93d6502cf175baf7" translate="yes" xml:space="preserve">
          <source>As in the previous example (see &lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;Example 1&lt;/a&gt;), &lt;code&gt;and&lt;/code&gt; begins with a &lt;code&gt;pred&lt;/code&gt; sub-pattern to ensure the following sub-patterns work with an object of the correct type (string, in this case). If &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt; fails, and thus &lt;code&gt;and&lt;/code&gt; fails, too.</source>
          <target state="translated">与前面的示例一样（请参见&lt;a href=&quot;#pcase_002dexample_002d1&quot;&gt;示例1&lt;/a&gt;）， &lt;code&gt;and&lt;/code&gt; 从 &lt;code&gt;pred&lt;/code&gt; 子模式开始，以确保以下子模式可与正确类型（在这种情况下为string）的对象一起使用。如果 &lt;code&gt;(stringp&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;pred&lt;/code&gt; 失败，因此 &lt;code&gt;and&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="aca399bc248b6540182b97cdc8a6ceed399a0db7" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;format&lt;/code&gt;, a format specification can include a width, which is a decimal number that appears after any flags. If a substitution contains fewer characters than its specified width, it is padded on the left:</source>
          <target state="translated">与 &lt;code&gt;format&lt;/code&gt; 一样，格式规范可以包含宽度，即在任何标志后出现的十进制数字。如果替换包含的字符少于其指定宽度，则在左侧进行填充：</target>
        </trans-unit>
        <trans-unit id="9007d393cbc677946e3b508fd46f178b4ffc51b8" translate="yes" xml:space="preserve">
          <source>As long as the selected window displays the current buffer, the window&amp;rsquo;s point and the buffer&amp;rsquo;s point always move together; they remain equal.</source>
          <target state="translated">只要所选窗口显示当前缓冲区，该窗口的点和缓冲区的点就始终一起移动；他们保持平等。</target>
        </trans-unit>
        <trans-unit id="a4599968f503223a9b7899912e9301addb3f9878" translate="yes" xml:space="preserve">
          <source>As long as the value of &lt;code&gt;meta-prefix-char&lt;/code&gt; remains 27, key lookup translates</source>
          <target state="translated">只要 &lt;code&gt;meta-prefix-char&lt;/code&gt; 的值保持27，键查找就转换为</target>
        </trans-unit>
        <trans-unit id="2403f847930ce8798404ebfea8bddc7017e3a7dd" translate="yes" xml:space="preserve">
          <source>As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.</source>
          <target state="translated">正如本手册前面所指出的,一个Lisp程序主要是由Lisp对象来表示的,其次才是文本。一个Lisp程序的文本形式是由构成程序的Lisp对象的读语法给出的。因此,Lisp程序中一个变量的文本形式是用代表该变量的符号的读语法来写的。</target>
        </trans-unit>
        <trans-unit id="6c8a180c05fd7458e0ef38127404fa2fa9ac26b5" translate="yes" xml:space="preserve">
          <source>As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with &lt;code&gt;defvar&lt;/code&gt;) and as a function or macro (e.g., with &lt;code&gt;defun&lt;/code&gt;). Such definitions do not conflict.</source>
          <target state="translated">如前所述，Emacs Lisp允许将同一符号定义为变量（例如，使用 &lt;code&gt;defvar&lt;/code&gt; ）和函数或宏（例如，使用 &lt;code&gt;defun&lt;/code&gt; ）。这样的定义不冲突。</target>
        </trans-unit>
        <trans-unit id="2a0ddcf1c50ca193923f438a27950fa2767aba7b" translate="yes" xml:space="preserve">
          <source>As the examples in this section illustrate, &lt;code&gt;format-spec&lt;/code&gt; is often used for selectively formatting an assortment of different pieces of information. This is useful in programs that provide user-customizable format strings, as the user can choose to format with a regular syntax and in any desired order only a subset of the information that the program makes available.</source>
          <target state="translated">如本节中的示例所示， &lt;code&gt;format-spec&lt;/code&gt; 通常用于选择性格式化各种不同的信息。这在提供用户可自定义的格式字符串的程序中很有用，因为用户可以选择使用常规语法进行格式化，并且可以按任何期望的顺序仅选择程序提供的一部分信息。</target>
        </trans-unit>
        <trans-unit id="fcae404ca40596bab0f46fcb1d1aebb078adf297" translate="yes" xml:space="preserve">
          <source>As the heap size increases, the time to perform a garbage collection increases. Thus, it can be desirable to do them less frequently in proportion.</source>
          <target state="translated">随着堆大小的增加,执行垃圾收集的时间也会增加。因此,按比例减少做的频率是可取的。</target>
        </trans-unit>
        <trans-unit id="7e3df73939184a50a6120a14310b27d84575c14c" translate="yes" xml:space="preserve">
          <source>As the name implies, this function does not display any messages.</source>
          <target state="translated">顾名思义,这个函数不显示任何信息。</target>
        </trans-unit>
        <trans-unit id="e31d6bc3247e331efa29ece4c6b4b7ecd35823cc" translate="yes" xml:space="preserve">
          <source>As these examples show, you can use a form with a lambda expression as its &lt;small&gt;CAR&lt;/small&gt; to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form &lt;code&gt;let&lt;/code&gt; for this purpose (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), or stored as symbol function definitions to produce named functions (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;).</source>
          <target state="translated">如这些示例所示，您可以使用带有lambda表达式的表单作为其&lt;small&gt;CAR&lt;/small&gt;来生成局部变量并为其提供值。在Lisp的早期，这种技术是绑定和初始化局部变量的唯一方法。但是，如今，使用更特殊的形式 &lt;code&gt;let&lt;/code&gt; 来实现此目的更为明显（请参阅&lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;）。 Lambda表达式主要用作匿名函数，以作为参数传递给其他函数（请参见&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;），或存储为符号函数定义以产生命名函数（请参见&lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="37412dfde91c59b85070a1fa6f6188f685c97c7f" translate="yes" xml:space="preserve">
          <source>As you use this manual, we ask that you send corrections as soon as you find them. If you think of a simple, real life example for a function or group of functions, please make an effort to write it up and send it in. Please reference any comments to the node name and function or variable name, as appropriate. Also state the number of the edition you are criticizing.</source>
          <target state="translated">在您使用本手册的过程中,我们请您在发现更正的地方尽快寄来。如果您想到了一个简单的、现实生活中的函数或函数组的例子,请您努力写出来,并将其发送过来。如有注释,请酌情引用节点名和函数或变量名。同时请注明你所批评的版本号。</target>
        </trans-unit>
        <trans-unit id="875666f6d9c3564876142613c6760e04a0da95b2" translate="yes" xml:space="preserve">
          <source>Aside from elements that specify bindings for keys, a keymap can also have a string as an element. This is called the &lt;em&gt;overall prompt string&lt;/em&gt; and makes it possible to use the keymap as a menu. See &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;.</source>
          <target state="translated">除了为键指定绑定的元素外，键映射还可以将字符串作为元素。这称为&lt;em&gt;总体提示字符串&lt;/em&gt;，可以将键盘映射用作菜单。请参阅&lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;定义菜单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d3719187ae715d19fbc05c49ed805a355d60c95" translate="yes" xml:space="preserve">
          <source>Aside from some technical details, the body of the &lt;code&gt;find-file&lt;/code&gt; function is basically equivalent to:</source>
          <target state="translated">除了一些技术细节之外， &lt;code&gt;find-file&lt;/code&gt; 函数的主体基本上等效于：</target>
        </trans-unit>
        <trans-unit id="e8854395183315465f485147e2c0e5d0dad0bf04" translate="yes" xml:space="preserve">
          <source>Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the &lt;code&gt;pcase&lt;/code&gt; macro, a hybrid of &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;cl-case&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;Conditionals&lt;/a&gt; in</source>
          <target state="translated">除了四个基本条件表格，的Emacs Lisp也有一个模式匹配条件的形式中， &lt;code&gt;pcase&lt;/code&gt; 宏的混合 &lt;code&gt;cond&lt;/code&gt; 和 &lt;code&gt;cl-case&lt;/code&gt; （见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Conditionals.html#Conditionals&quot;&gt;条件语句&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="d784be167f97d7b6e1444587a023ff8462f0adde" translate="yes" xml:space="preserve">
          <source>Aside from the mathematical incorrectness of asserting that 9 is a double-digit integer, there is another problem with &lt;code&gt;MAYBE&lt;/code&gt;. The body form references &lt;code&gt;n&lt;/code&gt; once more, yet we do not see the updated value&amp;mdash;10&amp;mdash;at all. What happened to it?</source>
          <target state="translated">除了断言9是两位数整数的数学错误外， &lt;code&gt;MAYBE&lt;/code&gt; 还有另一个问题。主体表单再次引用了 &lt;code&gt;n&lt;/code&gt; ，但是我们根本看不到更新的值10。这是怎么回事？</target>
        </trans-unit>
        <trans-unit id="3562777bc6a3edbbbfe49bb7c58769707930308b" translate="yes" xml:space="preserve">
          <source>Ask</source>
          <target state="translated">Ask</target>
        </trans-unit>
        <trans-unit id="5cc8d5b1e25410343b6c6d03e6144240950ba693" translate="yes" xml:space="preserve">
          <source>Ask user a multiple choice question. &lt;var&gt;prompt&lt;/var&gt; should be a string that will be displayed as the prompt.</source>
          <target state="translated">向用户询问多项选择题。 &lt;var&gt;prompt&lt;/var&gt; 应该是将显示为提示的字符串。</target>
        </trans-unit>
        <trans-unit id="a575156671adcef0e66c96ca9986973728b1a5e6" translate="yes" xml:space="preserve">
          <source>Asking Multiple-Choice Questions</source>
          <target state="translated">提出多项选择题</target>
        </trans-unit>
        <trans-unit id="f48d4ab0834bb43d119ea91a0df80bf7d9b32ab7" translate="yes" xml:space="preserve">
          <source>Asking a question with a simple answer.</source>
          <target state="translated">提出一个问题,答案很简单。</target>
        </trans-unit>
        <trans-unit id="fe7e00f4a1fa3a5c1a99ddf9345528ef0e23e5df" translate="yes" xml:space="preserve">
          <source>Asking complex questions.</source>
          <target state="translated">提出复杂的问题。</target>
        </trans-unit>
        <trans-unit id="27b0c683fbfb99510b0eaaaf16a761a3b451a6a0" translate="yes" xml:space="preserve">
          <source>Asking the user to choose a coding system.</source>
          <target state="translated">要求用户选择编码系统。</target>
        </trans-unit>
        <trans-unit id="e753d0e9020f53ad0de8df59f25fdea5680ef2fc" translate="yes" xml:space="preserve">
          <source>Asking the user to specify a character.</source>
          <target state="translated">要求用户指定一个字符。</target>
        </trans-unit>
        <trans-unit id="79f255d18c150763000984a919eb61a8c62cb802" translate="yes" xml:space="preserve">
          <source>Asking where the mouse is, or moving it.</source>
          <target state="translated">询问鼠标在哪里,或者移动它。</target>
        </trans-unit>
        <trans-unit id="9a8aef5df06c4a0630dba0718222fbda7f2ae98b" translate="yes" xml:space="preserve">
          <source>Assertion failed</source>
          <target state="translated">申言失败</target>
        </trans-unit>
        <trans-unit id="906762c6281b489fa4d8cc099d0c4e13c1902efd" translate="yes" xml:space="preserve">
          <source>Assigning Lisp property lists to text characters.</source>
          <target state="translated">将Lisp属性列表分配给文本字符。</target>
        </trans-unit>
        <trans-unit id="8f9fb7e8c09158fb874cf09f8dbca8383f6a050c" translate="yes" xml:space="preserve">
          <source>Associate &lt;var&gt;stderr&lt;/var&gt; with the standard error of the process. A non-&lt;code&gt;nil&lt;/code&gt; value should be either a buffer or a pipe process created with &lt;code&gt;make-pipe-process&lt;/code&gt;, described below. If &lt;var&gt;stderr&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, standard error is mixed with standard output, and both are sent to &lt;var&gt;buffer&lt;/var&gt; or &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">将 &lt;var&gt;stderr&lt;/var&gt; 与该过程的标准错误相关联。阿非 &lt;code&gt;nil&lt;/code&gt; 值应当是一个缓冲器创建的或具有一个管过程 &lt;code&gt;make-pipe-process&lt;/code&gt; ，如下所述。如果 &lt;var&gt;stderr&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则将标准错误与标准输出混合，并将两者都发送到 &lt;var&gt;buffer&lt;/var&gt; 或 &lt;var&gt;filter&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3024403263d4d843f0e51777623d2a49c1231db" translate="yes" xml:space="preserve">
          <source>Associating additional information with windows.</source>
          <target state="translated">将其他信息与窗口联系起来。</target>
        </trans-unit>
        <trans-unit id="e463ae7c0c475efc422013c7bb62639251e2604f" translate="yes" xml:space="preserve">
          <source>Association List Type</source>
          <target state="translated">协会名单类型</target>
        </trans-unit>
        <trans-unit id="c1eecc79e49a6ca7a499806fc8e58814d3aeda58" translate="yes" xml:space="preserve">
          <source>Association Lists</source>
          <target state="translated">协会名单</target>
        </trans-unit>
        <trans-unit id="a0f646334656079aafb8f68fbbd7ae734d08ae78" translate="yes" xml:space="preserve">
          <source>Association lists (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) are very similar to property lists. In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct.</source>
          <target state="translated">关联列表（请参阅&lt;a href=&quot;association-lists#Association-Lists&quot;&gt;关联列表&lt;/a&gt;）与属性列表非常相似。与关联列表相反，属性列表中的对顺序并不重要，因为属性名称必须不同。</target>
        </trans-unit>
        <trans-unit id="14ba3cbc75793dbade1b890546d72c62627ca897" translate="yes" xml:space="preserve">
          <source>Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.</source>
          <target state="translated">关联列表经常被用来记录你可能会保存在堆栈中的信息,因为新的关联可以很容易地被添加到列表的前面。当在关联列表中搜索具有给定键的关联时,如果有多个关联,则返回第一个找到的关联。</target>
        </trans-unit>
        <trans-unit id="c3f9b4c0afa65ab472f88a447b5b643be2caa8ed" translate="yes" xml:space="preserve">
          <source>Asynchronous subprocesses receive input when it is sent to them by Emacs, which is done with the functions in this section. You must specify the process to send input to, and the input data to send. If the subprocess runs a program, the data appears on the standard input of that program; for connections, the data is sent to the connected device or program.</source>
          <target state="translated">当Emacs向其发送输入时,异步子进程就会接收到输入,本节中的函数就是这样做的。你必须指定要发送输入的进程,以及要发送的输入数据。如果子进程运行一个程序,数据就会出现在该程序的标准输入上;对于连接,数据会被发送到连接的设备或程序上。</target>
        </trans-unit>
        <trans-unit id="a5bb8623a169e7bd4940e5f36d437427d3e09d1b" translate="yes" xml:space="preserve">
          <source>At any time, one frame in Emacs is the &lt;em&gt;selected frame&lt;/em&gt;. The selected window always resides on the selected frame.</source>
          <target state="translated">任何时候，Emacs中的一帧都是&lt;em&gt;选定的帧&lt;/em&gt;。所选窗口始终位于所选框架上。</target>
        </trans-unit>
        <trans-unit id="4c816364377c69602fd91de24b490b44a6fcd129" translate="yes" xml:space="preserve">
          <source>At any time, several primary keymaps are &lt;em&gt;active&lt;/em&gt;&amp;mdash;that is, in use for finding key bindings. These are the &lt;em&gt;global map&lt;/em&gt;, which is shared by all buffers; the &lt;em&gt;local keymap&lt;/em&gt;, which is usually associated with a specific major mode; and zero or more &lt;em&gt;minor mode keymaps&lt;/em&gt;, which belong to currently enabled minor modes. (Not all minor modes have keymaps.) The local keymap bindings shadow (i.e., take precedence over) the corresponding global bindings. The minor mode keymaps shadow both local and global keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for details.</source>
          <target state="translated">在任何时候，都有几个主键映射处于&lt;em&gt;活动状态，&lt;/em&gt;即用于查找键绑定。这些是&lt;em&gt;全局映射&lt;/em&gt;，由所有缓冲区共享。的&lt;em&gt;本地键映射&lt;/em&gt;，这通常是与特定的主要模式相关联;零个或多个&lt;em&gt;次要模式键盘映射&lt;/em&gt;，它们属于当前启用的次要模式。 （并非所有次要模式都具有键映射。）本地键映射绑定会遮盖（即优先于）相应的全局绑定。次要模式键盘映射同时遮蔽了本地键盘映射和全局键盘映射。有关详细信息，请参见&lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d93bb5f9a38a88b4da1e36b6fa1f9cb4bfd6596" translate="yes" xml:space="preserve">
          <source>At each stage, if a face has a valid &lt;code&gt;:inherit&lt;/code&gt; attribute, Emacs treats any attribute with an &lt;code&gt;unspecified&lt;/code&gt; value as having the corresponding value drawn from the parent face(s). see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;. Note that the parent face(s) may also leave the attribute unspecified; in that case, the attribute remains unspecified at the next level of face merging.</source>
          <target state="translated">在每个阶段，如果一个面部具有有效的 &lt;code&gt;:inherit&lt;/code&gt; 属性，则Emacs会将具有 &lt;code&gt;unspecified&lt;/code&gt; 值的任何属性视为具有从父面部抽取的对应值。请参阅&lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;面部属性&lt;/a&gt;。请注意，父级面孔也可能未指定属性；在这种情况下，该属性在下一个面部合并级别上仍未指定。</target>
        </trans-unit>
        <trans-unit id="621cbe593d12331614294e33d27df98bfb14d296" translate="yes" xml:space="preserve">
          <source>At some point in the future the base C dialect will no doubt change to C11.</source>
          <target state="translated">在未来的某一天,基础C方言无疑会改为C11。</target>
        </trans-unit>
        <trans-unit id="2d46551267fccda2366ce110501bc5c0ac875511" translate="yes" xml:space="preserve">
          <source>At the beginning or end of a line, the appropriate amount of space is none. Before a character with close parenthesis syntax, or after a character with open parenthesis or expression-prefix syntax, no space is also appropriate. Otherwise, one space is appropriate. See &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;.</source>
          <target state="translated">在一行的开头或结尾，没有足够的空间。在具有紧密括号语法的字符之前，或在具有开放括号或表达式前缀语法的字符之后，也没有空格。否则，一个空格是合适的。请参见&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;语法类表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="007e79f90925179d568d16a8deaddb8c8e8caa2f" translate="yes" xml:space="preserve">
          <source>At the center of the window is the &lt;em&gt;text area&lt;/em&gt;, or &lt;em&gt;body&lt;/em&gt;, where the buffer text is displayed. The text area can be surrounded by a series of optional areas. On the left and right, from innermost to outermost, these are the left and right fringes, denoted by LF and RF (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;); the left and right margins, denoted by LM and RM in the schematic (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;); the left or right vertical scroll bar, only one of which is present at any time, denoted by LS and RS (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); and the right divider, denoted by RD (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;). At the top of the window is the header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;). At the bottom of the window are the horizontal scroll bar (see &lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;Scroll Bars&lt;/a&gt;); the mode line (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;); and the bottom divider (see &lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;Window Dividers&lt;/a&gt;).</source>
          <target state="translated">窗口的中心是显示缓冲区文本的&lt;em&gt;文本区域&lt;/em&gt;或&lt;em&gt;正文&lt;/em&gt;。文本区域可以被一系列可选区域包围。在左侧和右侧，从最内到最外，这些是左侧和右侧条纹，分别由LF和RF表示（请参见&lt;a href=&quot;fringes#Fringes&quot;&gt;条纹&lt;/a&gt;）；左边界和右边界，在示意图中用LM和RM表示（请参见&lt;a href=&quot;display-margins#Display-Margins&quot;&gt;显示&lt;/a&gt;边界）；左侧或右侧垂直滚动条，在任何时候都只有一个，以LS和RS表示（请参见&lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;滚动条&lt;/a&gt;）；右分隔线，用RD表示（请参见&lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;窗口&lt;/a&gt;分隔线）。窗口顶部是标题行（请参见&lt;a href=&quot;header-lines#Header-Lines&quot;&gt;标题行）&lt;/a&gt;）。窗口底部是水平滚动条（请参见&lt;a href=&quot;scroll-bars#Scroll-Bars&quot;&gt;滚动条&lt;/a&gt;）。模式行（请参阅&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;模式行格式&lt;/a&gt;）；和底部分隔线（请参阅&lt;a href=&quot;window-dividers#Window-Dividers&quot;&gt;窗口&lt;/a&gt;分隔线）。</target>
        </trans-unit>
        <trans-unit id="fce2ab087a5fd08a2230eb11f4e344519f5c8db6" translate="yes" xml:space="preserve">
          <source>At the level of C code, quitting cannot happen just anywhere; only at the special places that check &lt;code&gt;quit-flag&lt;/code&gt;. The reason for this is that quitting at other places might leave an inconsistency in Emacs&amp;rsquo;s internal state. Because quitting is delayed until a safe place, quitting cannot make Emacs crash.</source>
          <target state="translated">在C代码级别，退出不可能在任何地方发生。仅在检查 &lt;code&gt;quit-flag&lt;/code&gt; 的特殊位置。这样做的原因是在其他地方退出可能会导致Emacs的内部状态不一致。因为退出被延迟到一个安全的地方，所以退出不能使Emacs崩溃。</target>
        </trans-unit>
        <trans-unit id="d255c59db332c87b9a24623a21d91ebeac724f41" translate="yes" xml:space="preserve">
          <source>At this moment typing</source>
          <target state="translated">此刻打字</target>
        </trans-unit>
        <trans-unit id="ede1fb5d661ab864aba9032ff56e1ac325b126c0" translate="yes" xml:space="preserve">
          <source>Atomic Change Groups</source>
          <target state="translated">原子变化组</target>
        </trans-unit>
        <trans-unit id="aab81d84cf8514fae3d044627f17a742d2c5166b" translate="yes" xml:space="preserve">
          <source>Atomic Windows</source>
          <target state="translated">原子窗</target>
        </trans-unit>
        <trans-unit id="ccb118068fddf7824a58d856e2c3e7b40ebb74f7" translate="yes" xml:space="preserve">
          <source>Atomic windows are implemented with the help of the reserved &lt;code&gt;window-atom&lt;/code&gt; window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) and an internal window (see &lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Basic Windows&lt;/a&gt;) called the root window of the atomic window. All windows that are part of the same atomic window have this root window as their common ancestor and are assigned a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;window-atom&lt;/code&gt; parameter.</source>
          <target state="translated">原子窗口是通过保留的 &lt;code&gt;window-atom&lt;/code&gt; 窗口参数（请参见&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;）和内部窗口（请参见&lt;a href=&quot;basic-windows#Basic-Windows&quot;&gt;Basic Windows&lt;/a&gt;）来实现的，该内部窗口称为原子窗口的根窗口。属于同一原子窗口的所有窗口均具有此根窗口作为其共同祖先，并被分配了非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;window-atom&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="a163ce0a704c17ae2c4e7f0c3f6ff0be652a3729" translate="yes" xml:space="preserve">
          <source>Atomic windows are rectangular compositions of at least two live windows. They have the following distinctive characteristics:</source>
          <target state="translated">原子窗是由至少两个活窗组成的矩形构件。它们具有以下显著特点:</target>
        </trans-unit>
        <trans-unit id="84b84a11114f20365d178505da52d54f0c432b05" translate="yes" xml:space="preserve">
          <source>Atomic windows are useful to construct and preserve window layouts that are meaningful only when all involved buffers are shown simultaneously in a specific manner, such as when showing differences between file revisions, or the same text in different languages or markups. They can also be used to permanently display information pertinent to a specific window in bars on that window&amp;rsquo;s sides.</source>
          <target state="translated">仅当以特定方式同时显示所有涉及的缓冲区时（例如，显示文件修订版之间的差异或使用不同语言或标记的相同文本时），原子窗口才可用于构造和保留有意义的窗口布局。它们还可以用于永久显示与特定窗口相关的信息，该信息在该窗口侧面的栏中。</target>
        </trans-unit>
        <trans-unit id="7ac3939a8902c4e5ec26fa6e697cca7abee0c334" translate="yes" xml:space="preserve">
          <source>Atomic windows automatically cease to exist when one of their constituents gets deleted. To dissolve an atomic window manually, reset the &lt;code&gt;window-atom&lt;/code&gt; parameter of its constituents&amp;mdash;the root of the atomic window and all its descendants.</source>
          <target state="translated">原子窗口的一个组成部分被删除时，原子窗口将自动不复存在。要手动溶解原子窗口，请重置其组成部分的 &lt;code&gt;window-atom&lt;/code&gt; 参数-原子窗口的根及其所有后代。</target>
        </trans-unit>
        <trans-unit id="b9ac22b82065cc69d28fef7fb37ebf9456c2f8c5" translate="yes" xml:space="preserve">
          <source>Attempt to set a constant symbol</source>
          <target state="translated">试图设置一个常数符号</target>
        </trans-unit>
        <trans-unit id="040459de5fdc40f82378844a0d54d538e77e475c" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;&amp;hellip;, in order, until one of them fails to match. In that case, &lt;code&gt;and&lt;/code&gt; likewise fails to match, and the rest of the sub-patterns are not tested. If all sub-patterns match, &lt;code&gt;and&lt;/code&gt; matches.</source>
          <target state="translated">尝试按顺序匹配 &lt;var&gt;pattern1&lt;/var&gt; &amp;hellip;，直到其中之一不匹配。在这种情况下， &lt;code&gt;and&lt;/code&gt; 同样不匹配，并且所述子图案的其余部分未经测试。如果所有子模式都匹配， &lt;code&gt;and&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="d62c51b00eb3d0f88c19008784cb02b23b4ba495" translate="yes" xml:space="preserve">
          <source>Attempts to match &lt;var&gt;pattern1&lt;/var&gt;, &lt;var&gt;pattern2&lt;/var&gt;, &amp;hellip;, in order, until one of them succeeds. In that case, &lt;code&gt;or&lt;/code&gt; likewise matches, and the rest of the sub-patterns are not tested. (Note that there must be at least two sub-patterns. Simply &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; signals error.)</source>
          <target state="translated">尝试按顺序匹配 &lt;var&gt;pattern1&lt;/var&gt; ， &lt;var&gt;pattern2&lt;/var&gt; ，...，直到其中之一成功。在那种情况下， &lt;code&gt;or&lt;/code&gt; 类似的匹配，其余子模式都不会被测试。（请注意，必须至少有两个子模式。简单地 &lt;code&gt;(or&amp;nbsp;&lt;var&gt;pattern1&lt;/var&gt;)&lt;/code&gt; 表示错误。）</target>
        </trans-unit>
        <trans-unit id="5b2467f53cc44078cb438b0c2750bc2ec1578c8a" translate="yes" xml:space="preserve">
          <source>Attract focus to the window chosen</source>
          <target state="translated">吸引焦点到所选择的窗口</target>
        </trans-unit>
        <trans-unit id="19a9640f6e74bf975fe0db395e61ad03d3ece1c7" translate="yes" xml:space="preserve">
          <source>Audible signal to the user.</source>
          <target state="translated">向用户发出声音信号。</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="2667d909be440bdf6583125971872bea1221d4db" translate="yes" xml:space="preserve">
          <source>Auto Fill mode also enables the functions that change the margins and justification style to refill portions of the text. See &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;.</source>
          <target state="translated">自动填充模式还启用了更改边距和对齐方式以重新填充部分文本的功能。参见&lt;a href=&quot;margins#Margins&quot;&gt;边距&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="555de047487d343cd666ab6a903a79ef6c09e487" translate="yes" xml:space="preserve">
          <source>Auto Fill mode is a minor mode that fills lines automatically as text is inserted. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;Auto Fill&lt;/a&gt; in</source>
          <target state="translated">自动填充模式是一种次要模式，可在插入文本时自动填充行。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html#Auto-Fill&quot;&gt;自动填充&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="850ade7a51d735a464313dc8f30adc7d11e8a00d" translate="yes" xml:space="preserve">
          <source>Auto Filling</source>
          <target state="translated">自动灌装</target>
        </trans-unit>
        <trans-unit id="0b4ed412ef994ca0c43e1b7bd22d818d428bb6c5" translate="yes" xml:space="preserve">
          <source>Auto-Saving</source>
          <target state="translated">Auto-Saving</target>
        </trans-unit>
        <trans-unit id="845b01108562c3d927a2af1812a0c1bf88795555" translate="yes" xml:space="preserve">
          <source>Auto-saving...</source>
          <target state="translated">Auto-saving...</target>
        </trans-unit>
        <trans-unit id="c2e779e790c1d4dc28d4326306803dbf362b481e" translate="yes" xml:space="preserve">
          <source>Autoload</source>
          <target state="translated">Autoload</target>
        </trans-unit>
        <trans-unit id="06d7988cf794172658af0153fd1a2481ba35d7d2" translate="yes" xml:space="preserve">
          <source>Autoload Type</source>
          <target state="translated">自动装载类型</target>
        </trans-unit>
        <trans-unit id="85e513dae1246e61ba8640eb87ad292a21840742" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix</source>
          <target state="translated">按前缀自动加载</target>
        </trans-unit>
        <trans-unit id="a316cd16d04dc567c3b4909645684cb65b1f615f" translate="yes" xml:space="preserve">
          <source>Autoload by Prefix.</source>
          <target state="translated">通过前缀自动加载。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="eb9cb47e9f34f586b55a9d914f6b2f6403badd01" translate="yes" xml:space="preserve">
          <source>Automatic Face Assignment</source>
          <target state="translated">自动脸部分配</target>
        </trans-unit>
        <trans-unit id="ae90bbb56c1aa1c308fb3a413aa144f52a6ccd37" translate="yes" xml:space="preserve">
          <source>Automatic Indentation of code</source>
          <target state="translated">自动缩进代码</target>
        </trans-unit>
        <trans-unit id="a8cc32cc81dbf9afed120141fd3975ae43627630" translate="yes" xml:space="preserve">
          <source>Automatic updating of frame titles.</source>
          <target state="translated">自动更新框架标题。</target>
        </trans-unit>
        <trans-unit id="a5bc07194f48e4d3351e56450cd28e631e2382b0" translate="yes" xml:space="preserve">
          <source>Automatically re-evaluate a list of expressions and display their results each time Edebug updates the display.</source>
          <target state="translated">自动重新评估表达式列表,并在每次Edebug更新显示时显示其结果。</target>
        </trans-unit>
        <trans-unit id="1cd844466867bdaf6e1db628300b6112623f0e83" translate="yes" xml:space="preserve">
          <source>Automatically selecting windows with the mouse.</source>
          <target state="translated">用鼠标自动选择窗口。</target>
        </trans-unit>
        <trans-unit id="c89d8ac98afcea167130340f5b561c866ca98fd5" translate="yes" xml:space="preserve">
          <source>Autotyping</source>
          <target state="translated">Autotyping</target>
        </trans-unit>
        <trans-unit id="361af9ca637df41d1dd709df4b2eb262901b3fd8" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;ssize_t&lt;/code&gt; except when communicating to low-level APIs that have &lt;code&gt;ssize_t&lt;/code&gt;-related limitations. Although it&amp;rsquo;s equivalent to &lt;code&gt;ptrdiff_t&lt;/code&gt; on typical platforms, &lt;code&gt;ssize_t&lt;/code&gt; is occasionally narrower, so using it for size-related calculations could overflow. Also, &lt;code&gt;ptrdiff_t&lt;/code&gt; is more ubiquitous and better-standardized, has standard &lt;code&gt;printf&lt;/code&gt; formats, and is the basis for Emacs&amp;rsquo;s internal size-overflow checking. When using &lt;code&gt;ssize_t&lt;/code&gt;, please note that POSIX requires support only for values in the range -1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt;.</source>
          <target state="translated">避免 &lt;code&gt;ssize_t&lt;/code&gt; 传达到具有低级别的API时，除了 &lt;code&gt;ssize_t&lt;/code&gt; -相关限制。尽管在典型平台上它等效于 &lt;code&gt;ptrdiff_t&lt;/code&gt; ，但 &lt;code&gt;ssize_t&lt;/code&gt; 有时会更窄，因此将其用于与尺寸相关的计算可能会溢出。而且， &lt;code&gt;ptrdiff_t&lt;/code&gt; 更加普遍并且标准化程度更高，具有标准的 &lt;code&gt;printf&lt;/code&gt; 格式，并且是Emacs内部大小溢出检查的基础。使用 &lt;code&gt;ssize_t&lt;/code&gt; 时，请注意POSIX仅要求支持-1 .. &lt;code&gt;SSIZE_MAX&lt;/code&gt; 范围内的值。</target>
        </trans-unit>
        <trans-unit id="4db5c02b78c97409e22545eb6907ca4a351e1990" translate="yes" xml:space="preserve">
          <source>Avoid arbitrary limits. For example, avoid &lt;code&gt;int len = strlen
(s);&lt;/code&gt; unless the length of &lt;code&gt;s&lt;/code&gt; is required for other reasons to fit in &lt;code&gt;int&lt;/code&gt; range.</source>
          <target state="translated">避免任意限制。例如，避免 &lt;code&gt;int len = strlen (s);&lt;/code&gt; 除非出于其他原因需要 &lt;code&gt;s&lt;/code&gt; 的长度以适合 &lt;code&gt;int&lt;/code&gt; 范围。</target>
        </trans-unit>
        <trans-unit id="0d6e79e0cc19181112cfd0c36a5750ae8c092fc5" translate="yes" xml:space="preserve">
          <source>Avoid depending on how many times expansion is done.</source>
          <target state="translated">避免取决于扩张的次数。</target>
        </trans-unit>
        <trans-unit id="2e549352e5b71cd7798ed53124f97e4a4c19088d" translate="yes" xml:space="preserve">
          <source>Avoiding evaluation (to put constants in the program).</source>
          <target state="translated">避免评估(要在程序中放入常量)。</target>
        </trans-unit>
        <trans-unit id="98c63cc59f3d9c3c7c9d29e55ddfee0b39d55b90" translate="yes" xml:space="preserve">
          <source>Avoiding problems with dynamic binding.</source>
          <target state="translated">避免动态绑定的问题。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="16374ac2b9a2eb53d18fcede0cdf14c4d6e18ba5" translate="yes" xml:space="preserve">
          <source>BS</source>
          <target state="translated">BS</target>
        </trans-unit>
        <trans-unit id="b52b36b7269fbfc58ec24bb724691951a3decbe8" translate="yes" xml:space="preserve">
          <source>Back</source>
          <target state="translated">Back</target>
        </trans-unit>
        <trans-unit id="17c0e560f6eadc671493346fc0a13caf302e9875" translate="yes" xml:space="preserve">
          <source>Background color, a string. The value can be a system-defined color name, or a hexadecimal color specification. See &lt;a href=&quot;color-names#Color-Names&quot;&gt;Color Names&lt;/a&gt;.</source>
          <target state="translated">背景颜色，字符串。该值可以是系统定义的颜色名称，也可以是十六进制颜色规范。请参阅&lt;a href=&quot;color-names#Color-Names&quot;&gt;颜色名称&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc48ef84cf0ee761d58df4dcb6d99bd10746fd9a" translate="yes" xml:space="preserve">
          <source>Backquote</source>
          <target state="translated">Backquote</target>
        </trans-unit>
        <trans-unit id="1c6ba351e6ca20e8a37172efc2c86d4aab598c50" translate="yes" xml:space="preserve">
          <source>Backquote-Style Patterns</source>
          <target state="translated">反引号风格的图案</target>
        </trans-unit>
        <trans-unit id="c0ecdab9574e4ebcb9dc4d8aec5335a6fb1dc637" translate="yes" xml:space="preserve">
          <source>Backquote-style patterns are a powerful set of &lt;code&gt;pcase&lt;/code&gt; pattern extensions (created using &lt;code&gt;pcase-defmacro&lt;/code&gt;) that make it easy to match &lt;var&gt;expval&lt;/var&gt; against specifications of its &lt;em&gt;structure&lt;/em&gt;.</source>
          <target state="translated">Backquote样式模式是一组强大的 &lt;code&gt;pcase&lt;/code&gt; 模式扩展集（使用 &lt;code&gt;pcase-defmacro&lt;/code&gt; 创建），可以轻松地将 &lt;var&gt;expval&lt;/var&gt; 与它的&lt;em&gt;结构&lt;/em&gt;规范匹配。</target>
        </trans-unit>
        <trans-unit id="a017b7b51d9d23728fcdbbcaa591b2596fe0b09a" translate="yes" xml:space="preserve">
          <source>Backslash Constructs in Regular Expressions</source>
          <target state="translated">正则表达式中的反斜杠结构。</target>
        </trans-unit>
        <trans-unit id="807e6daac187d064954fd59f10abb8e716892ec1" translate="yes" xml:space="preserve">
          <source>Backslash-sequences in regular expressions.</source>
          <target state="translated">正则表达式中的反斜杠序列。</target>
        </trans-unit>
        <trans-unit id="9bfb245aa5d9e794b82e574165fbbc700e3e2a72" translate="yes" xml:space="preserve">
          <source>Backtraces</source>
          <target state="translated">Backtraces</target>
        </trans-unit>
        <trans-unit id="c3e2b2ecbdd4245dd6be8d66bf5a99a7880e1508" translate="yes" xml:space="preserve">
          <source>Backtracking in Specifications</source>
          <target state="translated">规格的回溯</target>
        </trans-unit>
        <trans-unit id="efef7b78f24a9457b9578006ead1a23980b022a2" translate="yes" xml:space="preserve">
          <source>Backtracking is also disabled after successfully matching a quoted symbol or string specification, since this usually indicates a recognized construct. But if you have a set of alternative constructs that all begin with the same symbol, you can usually work around this constraint by factoring the symbol out of the alternatives, e.g., &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt;.</source>
          <target state="translated">成功匹配带引号的符号或字符串规范后，也会禁用回溯，因为这通常表示可识别的构造。但是，如果您有一组全部以相同符号开头的替代构造，则通常可以通过将符号排除在替代之外来解决此约束，例如 &lt;code&gt;[&quot;foo&quot; &amp;amp;or [first case] [second case] ...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b80345f727522e6032bad01fc94ae4ee43720c6" translate="yes" xml:space="preserve">
          <source>Backtracking is disabled while matching any of the form specifications (that is, &lt;code&gt;form&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;, &lt;code&gt;def-form&lt;/code&gt;, and &lt;code&gt;def-body&lt;/code&gt;). These specifications will match any form so any error must be in the form itself rather than at a higher level.</source>
          <target state="translated">在匹配任何表单规范（即 &lt;code&gt;form&lt;/code&gt; ， &lt;code&gt;body&lt;/code&gt; ， &lt;code&gt;def-form&lt;/code&gt; 和 &lt;code&gt;def-body&lt;/code&gt; ）时，将禁用回溯。这些规范将与任何形式匹配，因此任何错误都必须在形式本身而不是更高层次上。</target>
        </trans-unit>
        <trans-unit id="a4fc1af88bf3a7f32329f6577445d6679643e427" translate="yes" xml:space="preserve">
          <source>Backup Files</source>
          <target state="translated">备份文件</target>
        </trans-unit>
        <trans-unit id="40a0ef48a621ee3ca348b1e08eee5e6ff78084ac" translate="yes" xml:space="preserve">
          <source>Backup by Renaming or by Copying?</source>
          <target state="translated">通过重命名还是通过复制进行备份?</target>
        </trans-unit>
        <trans-unit id="3e24bb9e6bf592cfc87438fc7775b2a394418349" translate="yes" xml:space="preserve">
          <source>Backup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user&amp;rsquo;s own errors. Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.</source>
          <target state="translated">备份文件和自动保存文件是Emacs尝试通过两种方法来保护用户免受崩溃或用户自己的错误的影响。自动保存会保留当前编辑会话中较早的文本；备份文件会在当前会话之前保留文件内容。</target>
        </trans-unit>
        <trans-unit id="2b47ba4274b19191cdf1a5d7d53d13dd0235dd70" translate="yes" xml:space="preserve">
          <source>Backups and Auto-Saving</source>
          <target state="translated">备份和自动保存</target>
        </trans-unit>
        <trans-unit id="0cea14da6f943b9330cb8b19aa3f92fa39fb6f16" translate="yes" xml:space="preserve">
          <source>Backups are usually made by renaming the visited file to a new name. Optionally, you can specify that backup files should be made by copying the visited file. This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.</source>
          <target state="translated">通常通过将访问的文件重命名为新名称来进行备份。您可以选择指定通过复制被访问的文件来制作备份文件。这一选择对具有多个名称的文件来说是不同的;它还会影响到编辑后的文件是仍由原所有者拥有还是由编辑它的用户拥有。</target>
        </trans-unit>
        <trans-unit id="980a00caa2a5856cb63bd39c2e2070bc841c28b4" translate="yes" xml:space="preserve">
          <source>Backups of files with names matching &lt;var&gt;regexp&lt;/var&gt; will be made in &lt;var&gt;directory&lt;/var&gt;. &lt;var&gt;directory&lt;/var&gt; may be relative or absolute. If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to &amp;lsquo;</source>
          <target state="translated">名称与 &lt;var&gt;regexp&lt;/var&gt; 匹配的文件的备份将在 &lt;var&gt;directory&lt;/var&gt; 中进行。 &lt;var&gt;directory&lt;/var&gt; 可以是相对的也可以是绝对的。如果它是绝对的，那么所有匹配的文件都备份到同一目录中，则此目录中的文件名将是备份文件的全名，并且所有目录分隔符都更改为'</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">后向兼容性</target>
        </trans-unit>
        <trans-unit id="e514a03485d2668ef95953c312b10de6213c5a6b" translate="yes" xml:space="preserve">
          <source>Base 64 Encoding</source>
          <target state="translated">基数64编码</target>
        </trans-unit>
        <trans-unit id="2da9b468199d7990437f4078993fd373ed775585" translate="yes" xml:space="preserve">
          <source>Base 64 code is used in email to encode a sequence of 8-bit bytes as a longer sequence of</source>
          <target state="translated">Base 64代码在电子邮件中用于将一个8位字节的序列编码为一个较长的序列。</target>
        </trans-unit>
        <trans-unit id="4c671100c5a64e216a5296532f998860991bfe71" translate="yes" xml:space="preserve">
          <source>Based on the provided grammar, SMIE will be able to provide automatic indentation without any extra effort. But in practice, this default indentation style will probably not be good enough. You will want to tweak it in many different cases.</source>
          <target state="translated">基于所提供的语法,SMIE将能够提供自动缩进,而无需任何额外的努力。但在实践中,这种默认的缩进样式可能不够好。你会希望在许多不同的情况下对它进行调整。</target>
        </trans-unit>
        <trans-unit id="ed7c8b81e81eeb80d5baed6aff985328d2115ad0" translate="yes" xml:space="preserve">
          <source>Basic Char Syntax</source>
          <target state="translated">基本字符语法</target>
        </trans-unit>
        <trans-unit id="ca917eb6ff98062e696cf80a8ae061ef35888178" translate="yes" xml:space="preserve">
          <source>Basic Completion Functions</source>
          <target state="translated">基本完成功能</target>
        </trans-unit>
        <trans-unit id="50e2e3f56e746aee43ca80ef4e5fffdf4609c4f8" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Coding Systems</source>
          <target state="translated">编码系统的基本概念</target>
        </trans-unit>
        <trans-unit id="ad89db73741185f622afaecb510f561259b3dde6" translate="yes" xml:space="preserve">
          <source>Basic Concepts of Emacs Windows</source>
          <target state="translated">Emacs Windows的基本概念</target>
        </trans-unit>
        <trans-unit id="00f4714f957a02625aba98347f399df3258beab7" translate="yes" xml:space="preserve">
          <source>Basic Faces</source>
          <target state="translated">基本面</target>
        </trans-unit>
        <trans-unit id="ff9602efc9e32b4e2b30281afa47a5ad0c076c75" translate="yes" xml:space="preserve">
          <source>Basic Major Modes</source>
          <target state="translated">基本主要模式</target>
        </trans-unit>
        <trans-unit id="7f5daf3307f72897980331dcafb0dc7eac1c3f87" translate="yes" xml:space="preserve">
          <source>Basic Parameters</source>
          <target state="translated">基本参数</target>
        </trans-unit>
        <trans-unit id="57d59d1f9034406d74ff83e18c697246b75a0ddb" translate="yes" xml:space="preserve">
          <source>Basic Thread Functions</source>
          <target state="translated">基本线程功能</target>
        </trans-unit>
        <trans-unit id="566fc95e858fa38a59a695bd7cab6cae3b6d8fa3" translate="yes" xml:space="preserve">
          <source>Basic concepts of keymaps.</source>
          <target state="translated">钥匙图的基本概念。</target>
        </trans-unit>
        <trans-unit id="a25b5cf184191bab8faa27ed59d923cece314ddb" translate="yes" xml:space="preserve">
          <source>Basic concepts of syntax tables.</source>
          <target state="translated">语法表的基本概念。</target>
        </trans-unit>
        <trans-unit id="8b4ea8050a775a0f3ea3c2ccd48f52d29c5611ab" translate="yes" xml:space="preserve">
          <source>Basic concepts.</source>
          <target state="translated">基本概念:</target>
        </trans-unit>
        <trans-unit id="0f70f9424495752a5144291186246e76da91be5b" translate="yes" xml:space="preserve">
          <source>Basic ideas of mode line control.</source>
          <target state="translated">模式线控制的基本思路。</target>
        </trans-unit>
        <trans-unit id="1d42c96aca54ef9a010f6e17d0638352d113a90e" translate="yes" xml:space="preserve">
          <source>Basic information about minibuffers.</source>
          <target state="translated">关于迷你缓冲器的基本信息。</target>
        </trans-unit>
        <trans-unit id="3d3ef0f3067180013beb55c1d6dc1d28f43802f5" translate="yes" xml:space="preserve">
          <source>Basic information on using windows.</source>
          <target state="translated">使用windows的基本信息。</target>
        </trans-unit>
        <trans-unit id="1b6019974338c229459a64e3a602d1c23dece46e" translate="yes" xml:space="preserve">
          <source>Basic layout of frames.</source>
          <target state="translated">框架的基本布局。</target>
        </trans-unit>
        <trans-unit id="2a42ee27cdcf6bfedbc7c589958206e56696aee1" translate="yes" xml:space="preserve">
          <source>Basic properties of strings and characters.</source>
          <target state="translated">字符和字符串的基本属性。</target>
        </trans-unit>
        <trans-unit id="3c23a95b197dbd7c57081385c609a0440865eff0" translate="yes" xml:space="preserve">
          <source>Basic thread functions.</source>
          <target state="translated">基本线程功能。</target>
        </trans-unit>
        <trans-unit id="8b6d8cb0fe44b1ea97c8dffd9944957e48ec1ad8" translate="yes" xml:space="preserve">
          <source>Batch Mode</source>
          <target state="translated">批量模式</target>
        </trans-unit>
        <trans-unit id="9b540e8dec8ec13cb761e2f53dc0c1414e9d9fbf" translate="yes" xml:space="preserve">
          <source>Be careful not to redefine existing functions unintentionally. &lt;code&gt;defun&lt;/code&gt; redefines even primitive functions such as &lt;code&gt;car&lt;/code&gt; without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.</source>
          <target state="translated">注意不要无意中重新定义现有功能。 &lt;code&gt;defun&lt;/code&gt; 甚至重新定义了诸如 &lt;code&gt;car&lt;/code&gt; 之类的原始功能，而没有任何犹豫或通知。Emacs不会阻止您执行此操作，因为有时会故意重新定义函数，并且无法将故意重新定义与非故意重新定义区分开。</target>
        </trans-unit>
        <trans-unit id="13b72a62f4358262651a47272a3079ef92b405df" translate="yes" xml:space="preserve">
          <source>Be careful when composing these regular expressions; a poorly written pattern can dramatically slow things down! The function &lt;code&gt;regexp-opt&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) is useful for calculating optimal regular expressions to match several keywords.</source>
          <target state="translated">编写这些正则表达式时要小心；写得不好的模式会大大减慢速度！函数 &lt;code&gt;regexp-opt&lt;/code&gt; （请参阅&lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp函数&lt;/a&gt;）对于计算最佳正则表达式以匹配多个关键字很有用。</target>
        </trans-unit>
        <trans-unit id="27bc044b4c8d3ad73080a8adb64df2e5a46f2bb1" translate="yes" xml:space="preserve">
          <source>Be careful when using non-</source>
          <target state="translated">在使用非</target>
        </trans-unit>
        <trans-unit id="e685f45a3679a7ec991ede319ba164f9a2bcda4c" translate="yes" xml:space="preserve">
          <source>Be careful when writing macro calls in files that you intend to byte-compile. Since macro calls are expanded when they are compiled, the macros need to be loaded into Emacs or the byte compiler will not do the right thing. The usual way to handle this is with &lt;code&gt;require&lt;/code&gt; forms which specify the files containing the needed macro definitions (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Normally, the byte compiler does not evaluate the code that it is compiling, but it handles &lt;code&gt;require&lt;/code&gt; forms specially, by loading the specified libraries. To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;). For more details, See &lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;Compiling Macros&lt;/a&gt;.</source>
          <target state="translated">在要进行字节编译的文件中写入宏调用时要小心。由于宏调用在编译时会扩展，因此需要将宏加载到Emacs中，否则字节编译器将无法正确执行操作。解决此问题的常用方法是使用 &lt;code&gt;require&lt;/code&gt; 表单，该表单指定包含所需宏定义的文件（请参见&lt;a href=&quot;named-features#Named-Features&quot;&gt;命名功能&lt;/a&gt;）。通常，字节编译器不会评估正在编译的代码，但会通过加载指定的库来专门处理 &lt;code&gt;require&lt;/code&gt; 表单。为避免在有人&lt;em&gt;运行&lt;/em&gt;已编译程序时加载宏定义文件，请&lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;在&lt;/a&gt; &lt;code&gt;require&lt;/code&gt; 调用周围编写 &lt;code&gt;eval-when-compile&lt;/code&gt; （请参阅编译期间的Eval）。）。有关更多详细信息，请参见&lt;a href=&quot;compiling-macros#Compiling-Macros&quot;&gt;编译宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6856b62c3a77e855fac355ce1578434726e9581" translate="yes" xml:space="preserve">
          <source>Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.</source>
          <target state="translated">小心使用以空格结尾的文件名。在某些文件系统上(尤其是MS-Windows),文件名中的尾部空白字符会被悄悄地自动忽略。</target>
        </trans-unit>
        <trans-unit id="7baa8406b5920aeefae8bb15fe88275a07b0c0a0" translate="yes" xml:space="preserve">
          <source>Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.</source>
          <target state="translated">在这样做之前,一定要确认文件名是相对的。如果使用绝对文件名,结果可能在语法上无效或引用错误的文件。</target>
        </trans-unit>
        <trans-unit id="98789dc3354690dfbeaecf0f3ce9c8a96fe9026d" translate="yes" xml:space="preserve">
          <source>Because &amp;lsquo;</source>
          <target state="translated">因为</target>
        </trans-unit>
        <trans-unit id="e6dbac2a93ea4cf3cf393a42d12efb8fd86797f8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;kill-emacs&lt;/code&gt; can be called in situations where user interaction is impossible (e.g., when the terminal is disconnected), functions on this hook should not attempt to interact with the user. If you want to interact with the user when Emacs is shutting down, use &lt;code&gt;kill-emacs-query-functions&lt;/code&gt;, described below.</source>
          <target state="translated">因为可以在无法进行用户交互的情况下（例如，当终端断开连接时）调用 &lt;code&gt;kill-emacs&lt;/code&gt; ,所以此挂钩上的功能不应尝试与用户进行交互。如果要在Emacs关闭时与用户进行交互，请使用下面描述的 &lt;code&gt;kill-emacs-query-functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b34653ccb844a855bf2a53664633d4afdefaf2b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;quote&lt;/code&gt; is used so often in programs, Lisp provides a convenient read syntax for it. An apostrophe character (&amp;lsquo;</source>
          <target state="translated">由于在程序中经常使用 &lt;code&gt;quote&lt;/code&gt; ，因此Lisp为此提供了一种方便的读取语法。撇号（'</target>
        </trans-unit>
        <trans-unit id="b2bc1f0e771e6eb95b71dcedaea02b03d8a8a123" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;save-excursion&lt;/code&gt; only saves point for the buffer that was current at the start of the excursion, any changes made to point in other buffers, during the excursion, will remain in effect afterward. This frequently leads to unintended consequences, so the byte compiler warns if you call &lt;code&gt;set-buffer&lt;/code&gt; during an excursion:</source>
          <target state="translated">因为 &lt;code&gt;save-excursion&lt;/code&gt; 仅保存偏移开始时当前的缓冲区的点，所以在偏移期间对其他缓冲区中的点所做的任何更改将在以后保持有效。这通常会导致意想不到的后果，因此，如果您在偏移期间调用 &lt;code&gt;set-buffer&lt;/code&gt; ，则字节编译器会发出警告：</target>
        </trans-unit>
        <trans-unit id="1d3ee6e492f4a143386c60288985612cf7687a32" translate="yes" xml:space="preserve">
          <source>Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called &lt;em&gt;atoms&lt;/em&gt;.</source>
          <target state="translated">由于cons单元格对于Lisp至关重要，因此我们也有一个单词表示不是cons单元格的对象。这些物体称为&lt;em&gt;原子&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8e02576b56371153350d8d25bb27cbfbf989dce0" translate="yes" xml:space="preserve">
          <source>Because each symbol has separate value and function cells, variables names and function names do not conflict. For example, the symbol &lt;code&gt;buffer-file-name&lt;/code&gt; has a value (the name of the file being visited in the current buffer) as well as a function definition (a primitive function that returns the name of the file):</source>
          <target state="translated">因为每个符号都有单独的值和函数单元格，所以变量名和函数名不会冲突。例如，符号 &lt;code&gt;buffer-file-name&lt;/code&gt; 具有一个值（当前缓冲区中正在访问的文件的名称）以及一个函数定义（返回该文件名的原始函数）：</target>
        </trans-unit>
        <trans-unit id="d2ece29760102e60138459a857930034eb578422" translate="yes" xml:space="preserve">
          <source>Because it is common to perform arithmetic operations on a marker position, most of these operations (including &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) accept markers as arguments. In such cases, the marker stands for its current position.</source>
          <target state="translated">因为通常在标记位置执行算术运算，所以大多数这些操作（包括 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; ）都接受标记作为参数。在这种情况下，标记代表其当前位置。</target>
        </trans-unit>
        <trans-unit id="29cedf8199b58b0444621f3b1384580f106a0af6" translate="yes" xml:space="preserve">
          <source>Because it takes some time to load the standard Lisp files, the</source>
          <target state="translated">因为加载标准Lisp文件需要一些时间,所以</target>
        </trans-unit>
        <trans-unit id="42fc09422aef4da2bc16d41efb01630156afbdf1" translate="yes" xml:space="preserve">
          <source>Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">因为大多数cons单元格都用作列表的一部分，所以我们将由cons单元组成的任何结构都称为&lt;em&gt;list结构&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aecbe3fd5b632bec5904e4eeb626bf628ddaa189" translate="yes" xml:space="preserve">
          <source>Because non terminals cannot appear consecutively in the BNF grammar, it is difficult to correctly handle tokens that act as terminators, so the above grammar treats &lt;code&gt;&quot;;&quot;&lt;/code&gt; as a statement &lt;em&gt;separator&lt;/em&gt; instead, which SMIE can handle very well.</source>
          <target state="translated">由于非终结符不能在BNF语法中连续出现，因此很难正确处理充当终止符的标记，因此上述语法将 &lt;code&gt;&quot;;&quot;&lt;/code&gt; 作为语句&lt;em&gt;分隔符&lt;/em&gt;，SMIE可以很好地处理它。</target>
        </trans-unit>
        <trans-unit id="5527da9c81f706f4f494272f6a72b5e6c955dbcd" translate="yes" xml:space="preserve">
          <source>Because of the special nature of lazily bound variables, it is an error to set them (e.g. with &lt;code&gt;setq&lt;/code&gt;).</source>
          <target state="translated">由于延迟绑定变量的特殊性质，设置它们是错误的（例如，使用 &lt;code&gt;setq&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4cc7eee6b3274dd2df5b26429c74414bad10f743" translate="yes" xml:space="preserve">
          <source>Because of the way lists are implemented on top of cons cells, you can treat &lt;code&gt;list-alist&lt;/code&gt; in the example above as a cons cell alist, where the value type is a list with a single element containing the real value.</source>
          <target state="translated">由于列表是在cons单元格顶部实现的方式，因此您可以在上面的示例中将 &lt;code&gt;list-alist&lt;/code&gt; 视为cons单元格alist，其中值类型是一个列表，其中单个元素包含实际值。</target>
        </trans-unit>
        <trans-unit id="d4920f7b17cfb9be5d144cd02f205a26abedb351" translate="yes" xml:space="preserve">
          <source>Because regular expression matching works only going forward, this is implemented by searching backwards from point for a match that ends at point. That can be quite slow if it has to search a long distance. You can bound the time required by specifying a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;limit&lt;/var&gt;, which says not to search before &lt;var&gt;limit&lt;/var&gt;. In this case, the match that is found must begin at or after &lt;var&gt;limit&lt;/var&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">由于正则表达式匹配只能向前进行，因此可以通过从点向后搜索以点结尾的匹配来实现。如果必须搜索很长的距离，那可能会很慢。您可以通过绑定指定非所需的时间 &lt;code&gt;nil&lt;/code&gt; 的数值 &lt;var&gt;limit&lt;/var&gt; ，这不是说之前搜索 &lt;var&gt;limit&lt;/var&gt; 。在这种情况下，找到的匹配项必须在 &lt;var&gt;limit&lt;/var&gt; 或之后开始。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="891978e65a108dec966a02f2c109e3c7ab27e318" translate="yes" xml:space="preserve">
          <source>Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine&amp;rsquo;s hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.</source>
          <target state="translated">因为字节编译的代码是由字节代码解释器评估的，而不是直接由机器的硬件执行（就像真正的编译代码一样），所以字节代码可以在机器之间完全传输，而无需重新编译。但是，它没有真正的编译代码快。</target>
        </trans-unit>
        <trans-unit id="9807276681c6c1286c20092e4291987485eca98a" translate="yes" xml:space="preserve">
          <source>Because the match data normally describe the most recent search only, you must be careful not to do another search inadvertently between the search you wish to refer back to and the use of the match data. If you can&amp;rsquo;t avoid another intervening search, you must save and restore the match data around it, to prevent it from being overwritten.</source>
          <target state="translated">因为匹配数据通常仅描述最近的搜索，所以您必须小心，不要在想要参考的搜索与匹配数据的使用之间无意间进行其他搜索。如果您无法避免进行其他中间搜索，则必须保存并恢复周围的匹配数据，以防止其被覆盖。</target>
        </trans-unit>
        <trans-unit id="2a9a557d3ce6491f8ae2018c1e6773fb2de8d6d8" translate="yes" xml:space="preserve">
          <source>Because the result of the evaluation is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;guard&lt;/code&gt; matches, &lt;code&gt;and&lt;/code&gt; matches, and control passes to that clause&amp;rsquo;s body forms.</source>
          <target state="translated">因为评估的结果为 &lt;code&gt;nil&lt;/code&gt; ，所以 &lt;code&gt;guard&lt;/code&gt; 匹配， &lt;code&gt;and&lt;/code&gt; 匹配，并且控制权传递给该子句的主体形式。</target>
        </trans-unit>
        <trans-unit id="1db90825a22716e728468e821da490caab60e2bd" translate="yes" xml:space="preserve">
          <source>Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.</source>
          <target state="translated">因为用于缩写的符号并不在通常的obarray中,所以它们永远不会出现在读取Lisp表达式的结果中;事实上,除了处理缩写的代码之外,通常它们永远不会被使用。因此,以非标准的方式使用它们是安全的。</target>
        </trans-unit>
        <trans-unit id="4c851d66714e2bb452c04ba43899f653d596ccbc" translate="yes" xml:space="preserve">
          <source>Because the width of a given string depends on the flags that control the appearance of certain characters, &lt;code&gt;vertical-motion&lt;/code&gt; behaves differently, for a given piece of text, depending on the buffer it is in, and even on the selected window (because the width, the truncation flag, and display table may vary between windows). See &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;.</source>
          <target state="translated">因为给定字符串的宽度取决于控制某些字符的外观的标志，所以 &lt;code&gt;vertical-motion&lt;/code&gt; 行为对于给定的一段文本而言，取决于其所在的缓冲区，甚至在选定的窗口中也是如此（因为宽度，截断标志和显示表在两个窗口之间可能会有所不同。请参阅&lt;a href=&quot;usual-display#Usual-Display&quot;&gt;常规显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed8353d04454f502b14b0705a480aaefdecdb99f" translate="yes" xml:space="preserve">
          <source>Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with &lt;code&gt;accept-process-output&lt;/code&gt;, by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.</source>
          <target state="translated">由于线程是Emacs Lisp的相对较晚的新增功能，并且由于有时将动态绑定与 &lt;code&gt;accept-process-output&lt;/code&gt; 结合使用，因此默认情况下，进程会锁定到创建它的线程。当进程锁定到线程时，该进程的输出只能被该线程接受。</target>
        </trans-unit>
        <trans-unit id="edefffca965b0362f640503f05f0a22864aaf0c5" translate="yes" xml:space="preserve">
          <source>Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of &lt;em&gt;each line&lt;/em&gt; to go off screen.</source>
          <target state="translated">因为我们在内部循环中从一侧到另一侧阅读，而在外部循环中从上到下阅读，所以水平滚动的效果与文本或垂直滚动​​的效果不同。文本滚动涉及选择要显示的一部分文本，而垂直滚动则连续移动窗口内容。但是水平滚动会导致&lt;em&gt;每行的&lt;/em&gt;一部分离开屏幕。</target>
        </trans-unit>
        <trans-unit id="ca1ce0d49ba0f409cab2f1c7bbd925fafa44fcfe" translate="yes" xml:space="preserve">
          <source>Beeping</source>
          <target state="translated">Beeping</target>
        </trans-unit>
        <trans-unit id="17f7918b2f07183d74812fc33ccac59180f7ee50" translate="yes" xml:space="preserve">
          <source>Before Emacs can draw a character on a graphical display, it must select a &lt;em&gt;font&lt;/em&gt; for that character&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">在Emacs可以在图形显示器上绘制字符之前，它必须为该字符选择&lt;em&gt;字体&lt;/em&gt;&lt;a href=&quot;#FOOT23&quot; name=&quot;DOCF23&quot;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;字体&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="13e5148e87ac77ce622c012484f91f5a2b40ed38" translate="yes" xml:space="preserve">
          <source>Before actually playing the sound, &lt;code&gt;play-sound&lt;/code&gt; calls the functions in the list &lt;code&gt;play-sound-functions&lt;/code&gt;. Each function is called with one argument, &lt;var&gt;sound&lt;/var&gt;.</source>
          <target state="translated">在实际播放声音之前， &lt;code&gt;play-sound&lt;/code&gt; 调用列表 &lt;code&gt;play-sound-functions&lt;/code&gt; 中的功能。每个函数都使用一个参数 &lt;var&gt;sound&lt;/var&gt; 来调用。</target>
        </trans-unit>
        <trans-unit id="acfa912275db6abf7aab479d6b8b835a2b7d945e" translate="yes" xml:space="preserve">
          <source>Before any attempt to send the request, the application-specific conditions are checked. Since the &lt;code&gt;jsonrpc&lt;/code&gt; library can&amp;rsquo;t know what these conditions are, the program can use the &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; generic function (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) to specify them. The default method for this function returns &lt;code&gt;t&lt;/code&gt;, but you can add overriding methods that return &lt;code&gt;nil&lt;/code&gt; in some situations, based on the arguments passed to it, which are the &lt;code&gt;jsonrpc-connection&lt;/code&gt; object (see &lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC Overview&lt;/a&gt;) and whichever value you passed as the &lt;code&gt;:deferred&lt;/code&gt; keyword argument.</source>
          <target state="translated">在尝试发送请求之前，将检查特定于应用程序的条件。由于 &lt;code&gt;jsonrpc&lt;/code&gt; 库无法确定这些条件，因此程序可以使用 &lt;code&gt;jsonrpc-connection-ready-p&lt;/code&gt; 泛型函数（请参见&lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;泛型函数&lt;/a&gt;）来指定它们。该函数的默认方法返回 &lt;code&gt;t&lt;/code&gt; ，但是您可以添加一些重写方法，这些方法在某些情况下基于传递给它的参数（即 &lt;code&gt;jsonrpc-connection&lt;/code&gt; 对象（请参阅&lt;a href=&quot;jsonrpc-overview#JSONRPC-Overview&quot;&gt;JSONRPC概述&lt;/a&gt;）以及您以 &lt;code&gt;:deferred&lt;/code&gt; 传递的任何值）返回 &lt;code&gt;nil&lt;/code&gt; ：延迟的关键字参数。</target>
        </trans-unit>
        <trans-unit id="dcb73aafe29a27771bb410a3cc2ea9ba475e91b4" translate="yes" xml:space="preserve">
          <source>Before confirming unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; calls the functions in the list &lt;code&gt;kill-buffer-query-functions&lt;/code&gt;, in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;kill-buffer&lt;/code&gt; spares the buffer&amp;rsquo;s life.</source>
          <target state="translated">在确认未保存的更改之前， &lt;code&gt;kill-buffer&lt;/code&gt; 会按出现顺序（不带参数）调用 &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; 列表中的函数。被调用的被杀死的缓冲区是当前缓冲区。此功能的想法是这些功能将要求用户确认。如果它们中的任何一个返回 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;kill-buffer&lt;/code&gt; 会保留缓冲区的生命。</target>
        </trans-unit>
        <trans-unit id="b2c6df81ff9d3d92d5524e2fbe564a5cd653b1ec" translate="yes" xml:space="preserve">
          <source>Before creating the frame, this function ensures that Emacs is set up to display graphics. For instance, if Emacs has not processed X resources (e.g., if it was started on a text terminal), it does so at this time. In all other respects, this function behaves like &lt;code&gt;make-frame&lt;/code&gt; (see &lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;Creating Frames&lt;/a&gt;).</source>
          <target state="translated">在创建框架之前，此功能可确保将Emacs设置为显示图形。例如，如果Emacs尚未处理X资源（例如，如果它是在文本终端上启动的），则此时它会进行处理。在所有其他方面，此功能的行为类似于 &lt;code&gt;make-frame&lt;/code&gt; （请参见&lt;a href=&quot;creating-frames#Creating-Frames&quot;&gt;创建框架&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="838498ac25b34bcaba38e8d1736cb5d1213cbd8a" translate="yes" xml:space="preserve">
          <source>Before restoring the previous definitions, &lt;code&gt;unload-feature&lt;/code&gt; runs &lt;code&gt;remove-hook&lt;/code&gt; to remove functions in the library from certain hooks. These hooks include variables whose names end in &amp;lsquo;</source>
          <target state="translated">在恢复之前的定义之前， &lt;code&gt;unload-feature&lt;/code&gt; 运行 &lt;code&gt;remove-hook&lt;/code&gt; 从某些挂钩中删除库中的函数。这些挂钩包含名称以'结尾的变量</target>
        </trans-unit>
        <trans-unit id="1f9591d8d77ddb1cb74b81db22ada52f623b6efb" translate="yes" xml:space="preserve">
          <source>Before suspending, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-hook&lt;/code&gt;. After the user resumes Emacs, &lt;code&gt;suspend-emacs&lt;/code&gt; runs the normal hook &lt;code&gt;suspend-resume-hook&lt;/code&gt;. See &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">在挂起之前， &lt;code&gt;suspend-emacs&lt;/code&gt; 运行普通的 &lt;code&gt;suspend-hook&lt;/code&gt; 。用户恢复Emacs之后， &lt;code&gt;suspend-emacs&lt;/code&gt; 将运行正常的 &lt;code&gt;suspend-resume-hook&lt;/code&gt; 。参见&lt;a href=&quot;hooks#Hooks&quot;&gt;挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88b944d20a7b391474416844b970d522dd303815" translate="yes" xml:space="preserve">
          <source>Before the display margins can display anything, you must give them a nonzero width. The usual way to do that is to set these variables:</source>
          <target state="translated">在显示边距能够显示任何东西之前,你必须给它们一个非零的宽度。通常的方法是设置这些变量。</target>
        </trans-unit>
        <trans-unit id="b44b66b4a5c9db407d2757ab95949e425a1d30d3" translate="yes" xml:space="preserve">
          <source>Before the double-click or double-drag event, Emacs generates a &lt;em&gt;double-down&lt;/em&gt; event when the user presses the button down for the second time. Its event type contains &amp;lsquo;</source>
          <target state="translated">在双击或双击事件之前，当用户第二次按下按钮时，Emacs会生成一个&lt;em&gt;双击&lt;/em&gt;事件。其事件类型包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="27eeeabd3ce039e5d19034d398eafd77b5b99419" translate="yes" xml:space="preserve">
          <source>Before you do this, make sure the defun has enough close parentheses. Otherwise,</source>
          <target state="translated">在你这样做之前,请确保defun有足够的近括号。否则,</target>
        </trans-unit>
        <trans-unit id="cb9703a6b294ccc0880d4c1dfd4f9f3daf981cdb" translate="yes" xml:space="preserve">
          <source>Begin your module by including the header file</source>
          <target state="translated">在您的模块中加入头文件</target>
        </trans-unit>
        <trans-unit id="b4042d6d0e34481a13a0bd70105a92db402dff7f" translate="yes" xml:space="preserve">
          <source>Beginning of buffer</source>
          <target state="translated">缓冲区的开始</target>
        </trans-unit>
        <trans-unit id="7967dbe1bdfdc4fa11437c00eb1b6a94e7b1839d" translate="yes" xml:space="preserve">
          <source>Being quick and simple, &lt;code&gt;unsafep&lt;/code&gt; does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where &lt;code&gt;unsafep&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; for an unsafe expression. However, a safe Lisp expression can return a string with a &lt;code&gt;display&lt;/code&gt; property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.</source>
          <target state="translated">快速而简单， &lt;code&gt;unsafep&lt;/code&gt; 进行了非常轻松的分析，并拒绝了许多实际上安全的Lisp表达式。没有已知的情况，其中 &lt;code&gt;unsafep&lt;/code&gt; 对于不安全的表达式返回 &lt;code&gt;nil&lt;/code&gt; 。但是，安全的Lisp表达式可以返回具有 &lt;code&gt;display&lt;/code&gt; 属性的字符串，该字符串包含将字符串插入缓冲区后要执行的关联的Lisp表达式。该相关表达可以是病毒。为了安全起见，必须将用户代码计算出的所有字符串中的属性删除，然后再将其插入缓冲区。</target>
        </trans-unit>
        <trans-unit id="cd79998f02d02ee1f54b550965880ade28c0e5ae" translate="yes" xml:space="preserve">
          <source>Below is a table explaining each element. Note that last &lt;code&gt;heap&lt;/code&gt; entry is optional and present only if an underlying &lt;code&gt;malloc&lt;/code&gt; implementation provides &lt;code&gt;mallinfo&lt;/code&gt; function.</source>
          <target state="translated">下表是解释每个元素的表格。请注意，最后一个 &lt;code&gt;heap&lt;/code&gt; 条目是可选的，并且仅在基础 &lt;code&gt;malloc&lt;/code&gt; 实现提供 &lt;code&gt;mallinfo&lt;/code&gt; 函数时才存在。</target>
        </trans-unit>
        <trans-unit id="b3840ae760c97e9024f5cab124e17dbea9c19d2c" translate="yes" xml:space="preserve">
          <source>Below is a table of the classes you can use in a character alternative, and what they mean. Note that the &amp;lsquo;</source>
          <target state="translated">下表列出了可用于替代字符的类及其含义。请注意，</target>
        </trans-unit>
        <trans-unit id="01bae04f3ae2801c065a4011c8954162185dde4a" translate="yes" xml:space="preserve">
          <source>Below there is a description of a few subtypes of &lt;code&gt;Lisp_Vectorlike&lt;/code&gt;. Buffer object represents the text to display and edit. Window is the part of display structure which shows the buffer or is used as a container to recursively place other windows on the same frame. (Do not confuse Emacs Lisp window object with the window as an entity managed by the user interface system like X; in Emacs terminology, the latter is called frame.) Finally, process object is used to manage the subprocesses.</source>
          <target state="translated">下面是对 &lt;code&gt;Lisp_Vectorlike&lt;/code&gt; 的一些子类型的描述。缓冲区对象代表要显示和编辑的文本。窗口是显示结构的一部分，显示缓冲区或用作将其他窗口递归放置在同一框架上的容器。（不要将Emacs Lisp窗口对象与由X这样的用户界面系统管理的实体作为窗口混淆；在Emacs术语中，后者称为框架。）最后，流程对象用于管理子流程。</target>
        </trans-unit>
        <trans-unit id="5c8be3db4820388729d86b1200b856644093f20c" translate="yes" xml:space="preserve">
          <source>Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.</source>
          <target state="translated">下面我们将给出一些准则来挽回上面提到的挫折,从而避免在一个框架的窗口之间真的失去缓冲区。</target>
        </trans-unit>
        <trans-unit id="0353802f217c5a533a465f68ec4f0d8faa7c50cf" translate="yes" xml:space="preserve">
          <source>Below, we show first the regexp as a string in Lisp syntax (to distinguish spaces from tab characters), and then the result of evaluating it. The string constant begins and ends with a double-quote. &amp;lsquo;</source>
          <target state="translated">下面，我们首先以Lisp语法的形式将正则表达式显示为字符串（以区分空格和制表符），然后显示求值结果。字符串常量以双引号开头和结尾。'</target>
        </trans-unit>
        <trans-unit id="3cca15ebda8dce9819d62b75dc10ad2c1696871b" translate="yes" xml:space="preserve">
          <source>Berkeley BSD and its variants.</source>
          <target state="translated">Berkeley BSD及其变种。</target>
        </trans-unit>
        <trans-unit id="01ea07f92a42549b5de550cce8a6d1e85ce49161" translate="yes" xml:space="preserve">
          <source>Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;. For these reasons, this property is obsolete; use the &lt;code&gt;cursor-intangible&lt;/code&gt; property instead.</source>
          <target state="translated">当心：此属性的运行级别很低，并且以意想不到的方式影响很多代码。因此，请格外小心。一个常见的误用是在无形的文本上放置一个无形的属性，这实际上是不必要的，因为在任何命令的末尾，命令循环都会将点移到无形的文本之外。请参阅&lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;调整点&lt;/a&gt;。由于这些原因，此属性已过时；请改用 &lt;code&gt;cursor-intangible&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="f7f5f613a250e0e11c1b4577276a09871c48b610" translate="yes" xml:space="preserve">
          <source>Beyond the basic vector, a lot of objects like markers, overlays and buffers are managed as if they were vectors. The corresponding C data structures include the &lt;code&gt;union vectorlike_header&lt;/code&gt; field whose &lt;code&gt;size&lt;/code&gt; member contains the subtype enumerated by &lt;code&gt;enum pvec_type&lt;/code&gt; and an information about how many &lt;code&gt;Lisp_Object&lt;/code&gt; fields this structure contains and what the size of the rest data is. This information is needed to calculate the memory footprint of an object, and used by the vector allocation code while iterating over the vector blocks.</source>
          <target state="translated">除了基本矢量，还对许多对象（例如标记，覆盖和缓冲区）进行了管理，就好像它们是矢量一样。相应的C数据结构包括并 &lt;code&gt;union vectorlike_header&lt;/code&gt; 字段，其 &lt;code&gt;size&lt;/code&gt; 成员包含 &lt;code&gt;enum pvec_type&lt;/code&gt; 枚举的子类型，以及有关此结构包含多少 &lt;code&gt;Lisp_Object&lt;/code&gt; 字段以及其余数据的大小的信息。此信息是计算对象的内存占用量所必需的，并在对向量块进行迭代时由向量分配代码使用。</target>
        </trans-unit>
        <trans-unit id="f2b8d702e0ae298ec5dfa21f68f107c0b717e304" translate="yes" xml:space="preserve">
          <source>Bidirectional Display</source>
          <target state="translated">双向显示</target>
        </trans-unit>
        <trans-unit id="0f761761aa75d96b2cf2c46b89a33d4202f1f95c" translate="yes" xml:space="preserve">
          <source>Bidirectional reordering can have surprising and unpleasant effects when two strings with bidirectional content are juxtaposed in a buffer, or otherwise programmatically concatenated into a string of text. A typical problematic case is when a buffer consists of sequences of text fields separated by whitespace or punctuation characters, like Buffer Menu mode or Rmail Summary Mode. Because the punctuation characters used as separators have &lt;em&gt;weak directionality&lt;/em&gt;, they take on the directionality of surrounding text. As result, a numeric field that follows a field with bidirectional content can be displayed &lt;em&gt;to the left&lt;/em&gt; of the preceding field, messing up the expected layout. There are several ways to avoid this problem:</source>
          <target state="translated">当两个具有双向内容的字符串并置在缓冲区中，或者以编程方式并入文本字符串时，双向重新排序可能会产生令人惊讶且令人不快的效果。典型的问题情况是缓冲区由文本字段序列组成，这些文本字段序列由空格或标点符号分隔，例如&amp;ldquo;缓冲区菜单&amp;rdquo;模式或&amp;ldquo;邮件摘要&amp;rdquo;模式。由于用作分隔符的标点符号的&lt;em&gt;方向性较弱&lt;/em&gt;，因此它们承担了周围文本的方向性。结果，在具有双向内容的字段之后的数字字段可以显示在前一个字段&lt;em&gt;的左侧&lt;/em&gt;，从而弄乱了预期的布局。有几种方法可以避免此问题：</target>
        </trans-unit>
        <trans-unit id="7618266932012d1bb7d78a709b3b8de0c7e01623" translate="yes" xml:space="preserve">
          <source>Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.</source>
          <target state="translated">Bignums 可以有任意的精度。溢出fixnum的操作将返回一个bignum。</target>
        </trans-unit>
        <trans-unit id="fb38340a365bddb7a78416de50a44b6a7efdea98" translate="yes" xml:space="preserve">
          <source>Bind the symbol &lt;var&gt;ref&lt;/var&gt; to a submatch that matches &lt;var&gt;rx-expr&lt;/var&gt;&lt;small&gt;...&lt;/small&gt;. &lt;var&gt;ref&lt;/var&gt; is bound in &lt;var&gt;body-forms&lt;/var&gt; to the string of the submatch or nil, but can also be used in &lt;code&gt;backref&lt;/code&gt;.</source>
          <target state="translated">将符号 &lt;var&gt;ref&lt;/var&gt; 绑定到与 &lt;var&gt;rx-expr&lt;/var&gt; &lt;small&gt;...&lt;/small&gt;匹配的子匹配项。 &lt;var&gt;ref&lt;/var&gt; 以 &lt;var&gt;body-forms&lt;/var&gt; 绑定到submatch或nil的字符串，但也可以在 &lt;code&gt;backref&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="4379c6bcd5778b843b030784559be7b79a5580f0" translate="yes" xml:space="preserve">
          <source>Binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value prevents output primitives from calling the function specified by &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; (see &lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;User-Chosen Coding Systems&lt;/a&gt;). This is because</source>
          <target state="translated">&lt;code&gt;coding-system-for-write&lt;/code&gt; 绑定到非 &lt;code&gt;nil&lt;/code&gt; 值可防止输出原语调用由 &lt;code&gt;select-safe-coding-system-function&lt;/code&gt; 指定的函数（请参阅&lt;a href=&quot;user_002dchosen-coding-systems#User_002dChosen-Coding-Systems&quot;&gt;用户选择的编码系统&lt;/a&gt;）。这是因为</target>
        </trans-unit>
        <trans-unit id="fd1754f82b6bd628f04b3f5c068badfc9846c322" translate="yes" xml:space="preserve">
          <source>Binding module functions to Lisp symbols</source>
          <target state="translated">将模块函数绑定到Lisp符号上</target>
        </trans-unit>
        <trans-unit id="5d759eb09f19bf06ed84ff18e43aee3a19e46979" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integers</source>
          <target state="translated">整数的位运算</target>
        </trans-unit>
        <trans-unit id="93fd851ff63a4d886e2fa5d2be01e88deb486b52" translate="yes" xml:space="preserve">
          <source>Blinking Parentheses</source>
          <target state="translated">闪烁的括号</target>
        </trans-unit>
        <trans-unit id="6ac648d45e59dfdc6715fe0e3cbd86c82820c6b6" translate="yes" xml:space="preserve">
          <source>Block until &lt;var&gt;thread&lt;/var&gt; exits, or until the current thread is signaled. It returns the result of the &lt;var&gt;thread&lt;/var&gt; function. If &lt;var&gt;thread&lt;/var&gt; has already exited, this returns immediately.</source>
          <target state="translated">阻塞直到 &lt;var&gt;thread&lt;/var&gt; 退出，或者直到发出当前线程信号为止。它返回 &lt;var&gt;thread&lt;/var&gt; 函数的结果。如果 &lt;var&gt;thread&lt;/var&gt; 已经退出，则立即返回。</target>
        </trans-unit>
        <trans-unit id="c6929c141afbaefdc4afd63ac4b5596956cfa67c" translate="yes" xml:space="preserve">
          <source>Bool-Vector Type</source>
          <target state="translated">Bool-Vector类型</target>
        </trans-unit>
        <trans-unit id="882f4e1ca02e65db176c079c22995b90c25fc39c" translate="yes" xml:space="preserve">
          <source>Bool-vectors</source>
          <target state="translated">Bool-vectors</target>
        </trans-unit>
        <trans-unit id="c0a12baab63ceb798d7bac34fa38c4622e4b0373" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;kill-ring&lt;/code&gt; and &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; are Lisp variables whose values are normally lists. The word &amp;ldquo;pointer&amp;rdquo; in the name of the &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; indicates that the variable&amp;rsquo;s purpose is to identify one element of the list for use by the next yank command.</source>
          <target state="translated">既 &lt;code&gt;kill-ring&lt;/code&gt; 和 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 是Lisp的变量，其值通常列表。 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 名称中的单词&amp;ldquo; pointer&amp;rdquo;表示变量的目的是标识列表中的一个元素，供下一个yank命令使用。</target>
        </trans-unit>
        <trans-unit id="2fdc0bac385ea879dbde52d2dd508f2b5a448d88" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;read-from-minibuffer&lt;/code&gt; and &lt;code&gt;completing-read&lt;/code&gt; add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.</source>
          <target state="translated">无论 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 和 &lt;code&gt;completing-read&lt;/code&gt; 新元素添加到历史记录列表自动，并提供命令允许用户在名单上重复使用的物品。程序使用历史记录列表所需要做的唯一一件事就是初始化它，并在需要时将其名称传递给输入函数。但是，当微型缓冲区输入功能未使用列表时，可以手动修改列表。</target>
        </trans-unit>
        <trans-unit id="fc66435a82b20252191500c38ab3e5707fac603e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;yes-or-no-p&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; use the minibuffer.</source>
          <target state="translated">无论 &lt;code&gt;yes-or-no-p&lt;/code&gt; 和 &lt;code&gt;y-or-n-p&lt;/code&gt; 使用迷你缓冲区。</target>
        </trans-unit>
        <trans-unit id="dfd6cff3dbda1d13ebd279438e41124efaba93e7" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;error-symbol&lt;/var&gt; and &lt;var&gt;data&lt;/var&gt; are available to any error handlers that handle the error: &lt;code&gt;condition-case&lt;/code&gt; binds a local variable to a list of the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; .
&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">两个 &lt;var&gt;error-symbol&lt;/var&gt; 和 &lt;var&gt;data&lt;/var&gt; 可用于该处理错误的任何错误处理程序： &lt;code&gt;condition-case&lt;/code&gt; 结合的局部变量的形式的列表 &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; （参见&lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;出错处理&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="62da8c794cc6a7eb9ffe501a46f505c4219f98f2" translate="yes" xml:space="preserve">
          <source>Both forms of this definition (with backquote and without) suffer from the defect that &lt;var&gt;final&lt;/var&gt; is evaluated on every iteration. If &lt;var&gt;final&lt;/var&gt; is a constant, this is not a problem. If it is a more complex form, say &lt;code&gt;(long-complex-calculation x)&lt;/code&gt;, this can slow down the execution significantly. If &lt;var&gt;final&lt;/var&gt; has side effects, executing it more than once is probably incorrect.</source>
          <target state="translated">该定义的两种形式（带反引号和不带反引号）都存在缺陷，即每次迭代都要评估 &lt;var&gt;final&lt;/var&gt; 。如果 &lt;var&gt;final&lt;/var&gt; 是常数，那么这不是问题。如果它是更复杂的形式，例如 &lt;code&gt;(long-complex-calculation x)&lt;/code&gt; ，则这可能会大大降低执行速度。如果 &lt;var&gt;final&lt;/var&gt; 具有副作用，则多次执行它可能是不正确的。</target>
        </trans-unit>
        <trans-unit id="4b35a12cfb8382543b92627bbee4b04423faea8d" translate="yes" xml:space="preserve">
          <source>Both lists and arrays are classified as sequences.</source>
          <target state="translated">列表和数组都被归为序列。</target>
        </trans-unit>
        <trans-unit id="d2f3804efa9fdf3073f4d412bb85880a0a67b5c0" translate="yes" xml:space="preserve">
          <source>Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol &lt;code&gt;a&lt;/code&gt; is associated with the number &lt;code&gt;1&lt;/code&gt;, and the string &lt;code&gt;&quot;b&quot;&lt;/code&gt; is associated with the &lt;em&gt;list&lt;/em&gt;&lt;code&gt;(2 3)&lt;/code&gt;, which is the &lt;small&gt;CDR&lt;/small&gt; of the alist element:</source>
          <target state="translated">列表中的值和键都可以是任何Lisp对象。例如，在以下列表中，符号 &lt;code&gt;a&lt;/code&gt; 与数字 &lt;code&gt;1&lt;/code&gt; 关联，字符串 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 与&lt;em&gt;列表&lt;/em&gt; &lt;code&gt;(2 3)&lt;/code&gt; 关联，&lt;em&gt;列表&lt;/em&gt;（2 3）是alist元素的&lt;small&gt;CDR&lt;/small&gt;：</target>
        </trans-unit>
        <trans-unit id="cce7f2f2f0dc525117a70d581d9c335212145e5b" translate="yes" xml:space="preserve">
          <source>Bottom</source>
          <target state="translated">Bottom</target>
        </trans-unit>
        <trans-unit id="e61ada95a3801a523f8d48042eaed868415934b4" translate="yes" xml:space="preserve">
          <source>Breaking on an event.</source>
          <target state="translated">突破的事件。</target>
        </trans-unit>
        <trans-unit id="25a85b6e8b7cc5b5a89123c777d9b420bfa8cc33" translate="yes" xml:space="preserve">
          <source>Breakpoints at stop points.</source>
          <target state="translated">停止点的断点。</target>
        </trans-unit>
        <trans-unit id="50f88da05c8e174324af021a4ee24bc168eb0c3d" translate="yes" xml:space="preserve">
          <source>Breaks</source>
          <target state="translated">Breaks</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">简要说明</target>
        </trans-unit>
        <trans-unit id="3fb0fc86dfa0b9d7362bd38d269b717749f04cef" translate="yes" xml:space="preserve">
          <source>Buffer Basics</source>
          <target state="translated">缓冲区基础知识</target>
        </trans-unit>
        <trans-unit id="c027215488849466cacd3006649b1340a2edd0fc" translate="yes" xml:space="preserve">
          <source>Buffer File Name</source>
          <target state="translated">缓冲区文件名</target>
        </trans-unit>
        <trans-unit id="a4af6911c145bae353cfba5cde3bbb16bdca445e" translate="yes" xml:space="preserve">
          <source>Buffer Internals</source>
          <target state="translated">缓冲区内部</target>
        </trans-unit>
        <trans-unit id="5032b3933a4bf66e8948fdd3b1195bf2ec955ec7" translate="yes" xml:space="preserve">
          <source>Buffer Modification</source>
          <target state="translated">缓冲区修改</target>
        </trans-unit>
        <trans-unit id="a1220d5a5dc0d3413a288b7d866d2b909c573bb8" translate="yes" xml:space="preserve">
          <source>Buffer Modification Time</source>
          <target state="translated">缓冲区修改时间</target>
        </trans-unit>
        <trans-unit id="44e02f9bcee199b59cbd729f000935b0a07991dd" translate="yes" xml:space="preserve">
          <source>Buffer Names</source>
          <target state="translated">缓冲区名称</target>
        </trans-unit>
        <trans-unit id="ccf9f9fdff4870f16ae30767ca4be6fe76523e15" translate="yes" xml:space="preserve">
          <source>Buffer Parameters</source>
          <target state="translated">缓冲区参数</target>
        </trans-unit>
        <trans-unit id="e93f01132bbaec25c49799efddeb64957f02afd2" translate="yes" xml:space="preserve">
          <source>Buffer Text Notation</source>
          <target state="translated">缓冲区文本符号</target>
        </trans-unit>
        <trans-unit id="f1294c425911ac20d751cb9d1c51979e6e34f62e" translate="yes" xml:space="preserve">
          <source>Buffer Type</source>
          <target state="translated">缓冲区类型</target>
        </trans-unit>
        <trans-unit id="abcd68a1e18c1b87353060b6dc458244da82927b" translate="yes" xml:space="preserve">
          <source>Buffer is read-only</source>
          <target state="translated">缓冲区是只读的</target>
        </trans-unit>
        <trans-unit id="344030f3634d1baa3762609d3692b8f3c1316b48" translate="yes" xml:space="preserve">
          <source>Buffer positions and motion functions.</source>
          <target state="translated">缓冲位置和运动功能。</target>
        </trans-unit>
        <trans-unit id="6246ccf7dd19ff26d69c92fb853ac66fb5ae4f89" translate="yes" xml:space="preserve">
          <source>Buffer positions are measured in character units. This function returns the byte-position corresponding to buffer position &lt;var&gt;position&lt;/var&gt; in the current buffer. This is 1 at the start of the buffer, and counts upward in bytes. If &lt;var&gt;position&lt;/var&gt; is out of range, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">缓冲区位置以字符为单位进行测量。该函数返回与当前缓冲区中的缓冲区位置 &lt;var&gt;position&lt;/var&gt; 相对应的字节位置。在缓冲区的开头为1，并以字节为单位向上计数。如果 &lt;var&gt;position&lt;/var&gt; 超出范围，则值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35ca209a656833f1530433e2982a81634d31ea0e" translate="yes" xml:space="preserve">
          <source>Buffer positions indicating which text is on-screen in a window.</source>
          <target state="translated">缓冲区位置,表示窗口中哪些文字在屏幕上。</target>
        </trans-unit>
        <trans-unit id="8a53998ea65d2c55189b85c0ba6f6abc07875258" translate="yes" xml:space="preserve">
          <source>Buffer-Local Variables</source>
          <target state="translated">缓冲区局部变量</target>
        </trans-unit>
        <trans-unit id="e1f999c3ef7294166b2203dddf8a38a2a12863ad" translate="yes" xml:space="preserve">
          <source>Buffer-specific information that is directly accessible is stored in &lt;em&gt;buffer-local&lt;/em&gt; variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as &lt;code&gt;fill-column&lt;/code&gt; or &lt;code&gt;comment-column&lt;/code&gt; in this way. For more information about buffer-local variables and functions related to them, see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">可直接访问的特定于&lt;em&gt;缓冲区的&lt;/em&gt;信息存储在&lt;em&gt;缓冲区局部&lt;/em&gt;变量绑定中，这些变量绑定值仅在特定缓冲区中有效。此功能允许每个缓冲区覆盖某些变量的值。大多数主要模式都以这种方式覆盖变量，例如 &lt;code&gt;fill-column&lt;/code&gt; 或 &lt;code&gt;comment-column&lt;/code&gt; 。有关缓冲区局部变量和与之相关的函数的更多信息，请参见&lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;缓冲区局部变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea28d2b0e2e067c2d49b361f79f8dd13430b1c1f" translate="yes" xml:space="preserve">
          <source>Buffer-wide commands and bindings for buttons.</source>
          <target state="translated">缓冲区范围的命令和按钮的绑定。</target>
        </trans-unit>
        <trans-unit id="4cbcd2f7b704b607643b54842a2d38a1465e1a06" translate="yes" xml:space="preserve">
          <source>Buffers</source>
          <target state="translated">Buffers</target>
        </trans-unit>
        <trans-unit id="c34ea999c856831b2f1f1b93ec2c55bca01f7339" translate="yes" xml:space="preserve">
          <source>Buffers and Windows</source>
          <target state="translated">缓冲区和窗口</target>
        </trans-unit>
        <trans-unit id="89fab4e05ae4baad776ec1df498d67259c031ce8" translate="yes" xml:space="preserve">
          <source>Buffers are displayed in windows.</source>
          <target state="translated">缓冲区显示在窗口中。</target>
        </trans-unit>
        <trans-unit id="813e70bd28e3a98cb6625b026a7542aa93fd1a0a" translate="yes" xml:space="preserve">
          <source>Buffers exist until explicitly killed.</source>
          <target state="translated">缓冲区存在,直到被明确杀死。</target>
        </trans-unit>
        <trans-unit id="5807d4a79a20e298c7a061e07bafbf257b7f1329" translate="yes" xml:space="preserve">
          <source>Buffers have no read syntax. They print in hash notation, showing the buffer name.</source>
          <target state="translated">缓冲区没有读取语法。它们以哈希符号打印,显示缓冲区名称。</target>
        </trans-unit>
        <trans-unit id="c849b71243437a37c01b415363a9e00d3f75220f" translate="yes" xml:space="preserve">
          <source>Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">Emacs编辑中的缓冲区是具有不同名称并保存可以编辑的文本的对象。在Lisp程序中，缓冲区似乎是一种特殊的数据类型。您可以将缓冲区的内容视为可以扩展的字符串。插入和删除可能发生在缓冲区的任何部分。参见&lt;a href=&quot;text#Text&quot;&gt;文本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d9c37d98ed9d04e80b306fce37d88ced34649fb" translate="yes" xml:space="preserve">
          <source>Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the &lt;code&gt;list-buffers&lt;/code&gt; and &lt;code&gt;buffer-menu&lt;/code&gt; commands don&amp;rsquo;t mention them (but if such a buffer visits a file, it &lt;strong&gt;is&lt;/strong&gt; mentioned). A name starting with space also initially disables recording undo information; see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</source>
          <target state="translated">缓冲区是短暂的，一般用户不感兴趣的有开头的空间名称，从而使 &lt;code&gt;list-buffers&lt;/code&gt; 和 &lt;code&gt;buffer-menu&lt;/code&gt; 命令不提他们（但如果一个文件，它这样的缓冲访问&lt;strong&gt;被&lt;/strong&gt;提及）。以空格开头的名称最初也会禁止记录撤消信息。参见&lt;a href=&quot;undo#Undo&quot;&gt;撤消&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="330d744f9b4b4abc2c70c54c6b6b286c98dced2b" translate="yes" xml:space="preserve">
          <source>Build a new evaluation list from the contents of the buffer (&lt;code&gt;edebug-update-eval-list&lt;/code&gt;).</source>
          <target state="translated">从缓冲区的内容构建一个新的评估列表（ &lt;code&gt;edebug-update-eval-list&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="317d4e3a3a04e5eea5fc26c035b1ef9dd209902c" translate="yes" xml:space="preserve">
          <source>Build new types from other types or data.</source>
          <target state="translated">从其他类型或数据建立新的类型。</target>
        </trans-unit>
        <trans-unit id="b1f5f048510e296c0efaf69fd58cab73cd422bd8" translate="yes" xml:space="preserve">
          <source>Building Cons Cells and Lists</source>
          <target state="translated">建筑物弊端单元和清单</target>
        </trans-unit>
        <trans-unit id="bdc049a5ba45c2fd12b217cecac69626d97e5db0" translate="yes" xml:space="preserve">
          <source>Building Emacs</source>
          <target state="translated">构建Emacs</target>
        </trans-unit>
        <trans-unit id="f53b042cb4d6b635c59397892faa831033884cbc" translate="yes" xml:space="preserve">
          <source>Building Emacs requires GNU Make version 3.81 or later.</source>
          <target state="translated">构建Emacs需要GNU Make 3.81或更高版本。</target>
        </trans-unit>
        <trans-unit id="79b6b1f02a69a8e5241277580817571424a17daa" translate="yes" xml:space="preserve">
          <source>Building and dumping Emacs; internal data structures.</source>
          <target state="translated">建立和转储Emacs;内部数据结构。</target>
        </trans-unit>
        <trans-unit id="34812aaa741da1103c385a52808aa91b80e9594f" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;rx&lt;/code&gt; forms, like &lt;code&gt;digit&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;, cannot be redefined.</source>
          <target state="translated">内置 &lt;code&gt;rx&lt;/code&gt; 格式（例如 &lt;code&gt;digit&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; ）无法重新定义。</target>
        </trans-unit>
        <trans-unit id="f1c7bd5dfbc70feff63bb4c975105aed8228177c" translate="yes" xml:space="preserve">
          <source>Builtin Commands</source>
          <target state="translated">内置命令</target>
        </trans-unit>
        <trans-unit id="eb37717154ce80760d9e952968529a057b6b75e2" translate="yes" xml:space="preserve">
          <source>Builtin Constants</source>
          <target state="translated">内置常量</target>
        </trans-unit>
        <trans-unit id="ce64a3485e5540eb2d738ffca93bc4a6a99dac9d" translate="yes" xml:space="preserve">
          <source>Builtin Functions</source>
          <target state="translated">内置功能</target>
        </trans-unit>
        <trans-unit id="a9cc087245dc67aa0bcbea3954c8f85e35fb9e6d" translate="yes" xml:space="preserve">
          <source>Builtin Macros</source>
          <target state="translated">内置的宏程序</target>
        </trans-unit>
        <trans-unit id="c87bbec5d329be7d9ab3d4f7f28179b67b985893" translate="yes" xml:space="preserve">
          <source>Builtin Special Forms</source>
          <target state="translated">内置特殊表格</target>
        </trans-unit>
        <trans-unit id="ce27ad322fdf4fa3514cbeb626501e0ed27f14ae" translate="yes" xml:space="preserve">
          <source>Builtin User Options</source>
          <target state="translated">内置的用户选项</target>
        </trans-unit>
        <trans-unit id="843ed68047eb8a91c66fd38a5ea1a9307d042738" translate="yes" xml:space="preserve">
          <source>Builtin Variables</source>
          <target state="translated">内置变量</target>
        </trans-unit>
        <trans-unit id="5067c37a304c3bbf7192b5da6e72fcd4d8ed1b67" translate="yes" xml:space="preserve">
          <source>But if you type a control combination not in</source>
          <target state="translated">但如果你输入的控制组合不在</target>
        </trans-unit>
        <trans-unit id="5a9ec335ac0058bc8871067e4469ec28043b246e" translate="yes" xml:space="preserve">
          <source>But this will create conflicts for &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt;: on the one hand, the IF rule implies (among many other things) that &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt;; but on the other hand, since &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; appears within &lt;code&gt;cases&lt;/code&gt;, which appears left of &lt;code&gt;&quot;END&quot;&lt;/code&gt;, we also have &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt;. We can solve the conflict either by using:</source>
          <target state="translated">但是，这将为 &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; 造成冲突：一方面，IF规则（除其他外）暗示 &lt;code&gt;&quot;ELSE&quot; = &quot;END&quot;&lt;/code&gt; ；但另一方面，由于 &lt;code&gt;cases&lt;/code&gt; 中出现了 &lt;code&gt;&quot;ELSE&quot;&lt;/code&gt; 出现在 &lt;code&gt;&quot;END&quot;&lt;/code&gt; 左侧，因此我们也有 &lt;code&gt;&quot;ELSE&quot; &amp;gt; &quot;END&quot;&lt;/code&gt; 。我们可以使用以下方法解决冲突：</target>
        </trans-unit>
        <trans-unit id="2a081c2786dbf00aa6d8f9b177ec4a1ad92a73fe" translate="yes" xml:space="preserve">
          <source>But this would add multiple elements if the library is reloaded. To avoid the problem, use &lt;code&gt;add-to-list&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;):</source>
          <target state="translated">但是，如果重新加载该库，则会添加多个元素。为避免此问题，请使用 &lt;code&gt;add-to-list&lt;/code&gt; （请参阅&lt;a href=&quot;list-variables#List-Variables&quot;&gt;列表变量&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="07ec1dfa598ebfb12e7443602444d7a051d224dd" translate="yes" xml:space="preserve">
          <source>But we recommend &lt;code&gt;copy-sequence&lt;/code&gt; for this purpose (see &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;).</source>
          <target state="translated">但是我们建议为此目的使用 &lt;code&gt;copy-sequence&lt;/code&gt; （请参阅&lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;序列函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c0bd785491e817f0f44e14205af6a59e1a447d90" translate="yes" xml:space="preserve">
          <source>But you should use &lt;code&gt;advice-add&lt;/code&gt; and &lt;code&gt;advice-remove&lt;/code&gt; for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to &lt;code&gt;add-function&lt;/code&gt;: they know how to deal with macros and autoloaded functions, they let &lt;code&gt;describe-function&lt;/code&gt; preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.</source>
          <target state="translated">但是您应该改为使用 &lt;code&gt;advice-add&lt;/code&gt; 和 &lt;code&gt;advice-remove&lt;/code&gt; 。与 &lt;code&gt;add-function&lt;/code&gt; 相比，这套独立的函数集可处理应用于命名函数的建议，它们提供了以下额外功能：他们知道如何处理宏和自动加载的函数， &lt;code&gt;describe-function&lt;/code&gt; 可以保留原始文档字符串和文档添加的建议，它们使您甚至可以在定义函数之前添加和删除建议。</target>
        </trans-unit>
        <trans-unit id="7d8a0e63cd1a06ea0e2679c87030f5570105b2a4" translate="yes" xml:space="preserve">
          <source>Button Buffer Commands</source>
          <target state="translated">按钮缓冲区命令</target>
        </trans-unit>
        <trans-unit id="d055960c135678f62a49f9b6f7a5d94add754440" translate="yes" xml:space="preserve">
          <source>Button Properties</source>
          <target state="translated">按钮属性</target>
        </trans-unit>
        <trans-unit id="41fa24540db10de11f239ddb922c6363c465adf0" translate="yes" xml:space="preserve">
          <source>Button Types</source>
          <target state="translated">按钮类型</target>
        </trans-unit>
        <trans-unit id="1e308eff60f72b546296987374ea4612fa02db86" translate="yes" xml:space="preserve">
          <source>Button properties with special meanings.</source>
          <target state="translated">具有特殊含义的按钮属性。</target>
        </trans-unit>
        <trans-unit id="e8bf727af91015f6f823f13b436c2880666b454a" translate="yes" xml:space="preserve">
          <source>Button-Down Events</source>
          <target state="translated">钮扣式活动</target>
        </trans-unit>
        <trans-unit id="503d46db37b0db45db898aabed77244252918ca2" translate="yes" xml:space="preserve">
          <source>Buttons</source>
          <target state="translated">Buttons</target>
        </trans-unit>
        <trans-unit id="4c379f628ac77bed975fa656ab1146980f7bff07" translate="yes" xml:space="preserve">
          <source>Buttons are associated with a region of text, using an overlay or text properties to hold button-specific information, all of which are initialized from the button&amp;rsquo;s type (which defaults to the built-in button type &lt;code&gt;button&lt;/code&gt;). Like all Emacs text, the appearance of the button is governed by the &lt;code&gt;face&lt;/code&gt; property; by default (via the &lt;code&gt;face&lt;/code&gt; property inherited from the &lt;code&gt;button&lt;/code&gt; button-type) this is a simple underline, like a typical web-page link.</source>
          <target state="translated">按钮使用覆盖或文本属性来保存特定于按钮的信息，这些按钮与文本区域相关联，所有信息均从按钮的类型（默认为内置按钮类型 &lt;code&gt;button&lt;/code&gt; ）初始化。像所有Emacs文本一样，按钮的外观由 &lt;code&gt;face&lt;/code&gt; 属性控制；默认情况下（通过从 &lt;code&gt;button&lt;/code&gt; button-type继承的 &lt;code&gt;face&lt;/code&gt; 属性），这是一个简单的下划线，类似于典型的网页链接。</target>
        </trans-unit>
        <trans-unit id="91c7c66c2c1453401e19d50861895a10fdbd7d8e" translate="yes" xml:space="preserve">
          <source>By &lt;em&gt;separator&lt;/em&gt;, we mean here a token whose sole purpose is to separate various elements within some enclosing syntactic construct, and which does not have any semantic significance in itself (i.e., it would typically not exist as a node in an abstract syntax tree).</source>
          <target state="translated">通过&lt;em&gt;分离&lt;/em&gt;，我们这里指的是一个令牌，其唯一目的是为了一些封闭语法结构中分离出来的各种元素，并且不会对自己有任何语义意义（即它通常不存在作为一个抽象语法树的节点）。</target>
        </trans-unit>
        <trans-unit id="1286985575cca5c62cde4a1b9229a630c85b3182" translate="yes" xml:space="preserve">
          <source>By contrast, a Lisp program can do insertion with inheritance or without, depending on the choice of insertion primitive. The ordinary text insertion functions, such as &lt;code&gt;insert&lt;/code&gt;, do not inherit any properties. They insert text with precisely the properties of the string being inserted, and no others. This is correct for programs that copy text from one context to another&amp;mdash;for example, into or out of the kill ring. To insert with inheritance, use the special primitives described in this section. Self-inserting characters inherit properties because they work using these primitives.</source>
          <target state="translated">相比之下，取决于插入原语的选择，Lisp程序可以进行带继承或不带继承的插入。普通的文本插入功能（例如 &lt;code&gt;insert&lt;/code&gt; ）不继承任何属性。它们插入的文本恰好具有要插入的字符串的属性，而没有其他属性。这对于将文本从一个上下文复制到另一个上下文（例如，插入或退出kill ring）的程序是正确的。要插入继承，请使用本节中描述的特殊原语。自插入字符继承属性，因为它们使用这些原语工作。</target>
        </trans-unit>
        <trans-unit id="78d9ed9ffae62086921d390616b3fa2296925abd" translate="yes" xml:space="preserve">
          <source>By contrast, for an array of keyboard input characters (such as a key sequence), a vector may be necessary, because many keyboard input characters are outside the range that will fit in a string. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">相反，对于一组键盘输入字符（例如按键序列），可能需要一个向量，因为许多键盘输入字符超出了可容纳在字符串中的范围。请参阅&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;按键序列输入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12144324278ff8b90e0a364f623b2e54380c481c" translate="yes" xml:space="preserve">
          <source>By contrast, in programs that manipulate function definitions for other purposes, it is better to use &lt;code&gt;fset&lt;/code&gt;, which does not keep such records. See &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;.</source>
          <target state="translated">相反，在为其他目的操纵函数定义的程序中，最好使用 &lt;code&gt;fset&lt;/code&gt; ，它不保留此类记录。请参见&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;功能单元&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e28b30f108e8c96578a3e1fc9b8f49f98c5c829d" translate="yes" xml:space="preserve">
          <source>By contrast, object-oriented programs use &lt;em&gt;polymorphic functions&lt;/em&gt;: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.</source>
          <target state="translated">相比之下，面向对象的程序使用&lt;em&gt;多态函数&lt;/em&gt;：一组具有相同名称的专用函数，每个函数都是针对一组特定的参数类型编写的。实际调用哪个函数是在运行时根据实际参数的类型确定的。</target>
        </trans-unit>
        <trans-unit id="955d83a02806ccf2dfd155108f9d134b64fbc8d8" translate="yes" xml:space="preserve">
          <source>By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol.</source>
          <target state="translated">相比之下,下面的例子调用了一个没有任何符号函数的函数,因为第一个元素是一个匿名Lisp函数,而不是一个符号。</target>
        </trans-unit>
        <trans-unit id="90d9b7ac9f08bada9648d4c6e90292b9adc5f05d" translate="yes" xml:space="preserve">
          <source>By contrast, using only error symbols without condition names would seriously decrease the power of &lt;code&gt;condition-case&lt;/code&gt;. Condition names make it possible to categorize errors at various levels of generality when you write an error handler. Using error symbols alone would eliminate all but the narrowest level of classification.</source>
          <target state="translated">相比之下，仅使用不带条件名称的错误符号将严重降低 &lt;code&gt;condition-case&lt;/code&gt; 。使用条件名称，可以在编写错误处理程序时以各种通用级别对错误进行分类。仅使用错误符号将消除除最窄等级之外的所有等级。</target>
        </trans-unit>
        <trans-unit id="c262827c2a008bc82000c720bb603706e79b1b54" translate="yes" xml:space="preserve">
          <source>By convention, any argument whose name contains the name of a type (e.g., &lt;var&gt;integer&lt;/var&gt;, &lt;var&gt;integer1&lt;/var&gt; or &lt;var&gt;buffer&lt;/var&gt;) is expected to be of that type. A plural of a type (such as &lt;var&gt;buffers&lt;/var&gt;) often means a list of objects of that type. An argument named &lt;var&gt;object&lt;/var&gt; may be of any type. (For a list of Emacs object types, see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.) An argument with any other sort of name (e.g., &lt;var&gt;new-file&lt;/var&gt;) is specific to the function; if the function has a documentation string, the type of the argument should be described there (see &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;).</source>
          <target state="translated">按照约定，任何名称包含类型名称（例如 &lt;var&gt;integer&lt;/var&gt; ， &lt;var&gt;integer1&lt;/var&gt; 或 &lt;var&gt;buffer&lt;/var&gt; ）的参数都应属于该类型。一个类型的复数（例如 &lt;var&gt;buffers&lt;/var&gt; ）通常表示该类型的对象的列表。名为 &lt;var&gt;object&lt;/var&gt; 的参数可以是任何类型。（有关Emacs对象类型的列表，请参见&lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp数据类型&lt;/a&gt;。）具有任何其他种类名称（例如 &lt;var&gt;new-file&lt;/var&gt; ）的参数特定于该函数；例如，如果函数具有文档字符串，则应在此处描述参数的类型（请参见&lt;a href=&quot;documentation#Documentation&quot;&gt;文档&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29edadc76625945d3e9732385f723229ac2c6358" translate="yes" xml:space="preserve">
          <source>By convention, if a function&amp;rsquo;s symbol consists of two names separated by &amp;lsquo;</source>
          <target state="translated">按照惯例，如果函数的符号由两个名称组成，且两个名称之间用'</target>
        </trans-unit>
        <trans-unit id="81288ed35b7f8aec4f961beebc97c447985deae4" translate="yes" xml:space="preserve">
          <source>By convention, the entries &lt;code&gt;window-height&lt;/code&gt;, &lt;code&gt;window-width&lt;/code&gt; and &lt;code&gt;preserve-size&lt;/code&gt; are applied after the chosen window&amp;rsquo;s buffer has been set up and if and only if that window never showed another buffer before. More precisely, the latter means that the window must have been either created by the current &lt;code&gt;display-buffer&lt;/code&gt; call or the window was created earlier by &lt;code&gt;display-buffer&lt;/code&gt; to show the buffer and never was used to show another buffer until it was reused by the current invocation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">按照约定，在设置了所选窗口的缓冲区之后，并且仅当该窗口之前从未显示过另一个缓冲区时，才会应用 &lt;code&gt;window-height&lt;/code&gt; ， &lt;code&gt;window-width&lt;/code&gt; 和 &lt;code&gt;preserve-size&lt;/code&gt; 条目。更精确地讲，后者意味着该窗口必须是由当前的 &lt;code&gt;display-buffer&lt;/code&gt; 调用创建的，或者该窗口是由 &lt;code&gt;display-buffer&lt;/code&gt; 先前创建的以显示该缓冲区的，而从未被用于显示另一个缓冲区，直到当前的复用调用 &lt;code&gt;display-buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="961315a74279b10aa81793f8f190e6ad9e46b005" translate="yes" xml:space="preserve">
          <source>By convention, the height of the chosen window is adjusted only if the window is part of a vertical combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the height of other, unrelated windows. Also, this entry should be processed only under certain conditions which are specified right below this list.</source>
          <target state="translated">按照惯例，只有在窗口是垂直组合的一部分（请参见&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames&lt;/a&gt;）的情况下，才调整所选窗口的高度，以避免更改其他不相关的窗口的高度。此外，仅在此列表正下方指定的某些条件下才应处理此条目。</target>
        </trans-unit>
        <trans-unit id="46e87bdc0265fdf29ddfc65a07831e51565c646d" translate="yes" xml:space="preserve">
          <source>By convention, the pixels of the display at the values returned for &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are considered to be inside (part of) &lt;var&gt;frame&lt;/var&gt;. Hence, if &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;top&lt;/var&gt; are both zero, the pixel at the display&amp;rsquo;s origin is part of &lt;var&gt;frame&lt;/var&gt;. The pixels at &lt;var&gt;bottom&lt;/var&gt; and &lt;var&gt;right&lt;/var&gt;, on the other hand, are considered to lie immediately outside &lt;var&gt;frame&lt;/var&gt;. This means that if you have, for example, two side-by-side frames positioned such that the right outer edge of the frame on the left equals the left outer edge of the frame on the right, the pixels at that edge show a part of the frame on the right.</source>
          <target state="translated">按照惯例，显示像素的返回值为 &lt;var&gt;left&lt;/var&gt; 和 &lt;var&gt;top&lt;/var&gt; 的像素被视为在 &lt;var&gt;frame&lt;/var&gt; 内部（部分）。因此，如果 &lt;var&gt;left&lt;/var&gt; 和 &lt;var&gt;top&lt;/var&gt; 均为零，则显示器原点的像素是 &lt;var&gt;frame&lt;/var&gt; 的一部分。另一方面， &lt;var&gt;bottom&lt;/var&gt; 和 &lt;var&gt;right&lt;/var&gt; 的像素被认为位于 &lt;var&gt;frame&lt;/var&gt; 外部。这意味着，例如，如果您放置了两个并排的框架，以使左侧框架的右外边缘与右侧框架的左外边缘相等，则该边缘处的像素将显示一部分在右边的框架。</target>
        </trans-unit>
        <trans-unit id="6a4bd0ccbb65351d0542d9701b9e76e9ff39eb97" translate="yes" xml:space="preserve">
          <source>By convention, the width of the chosen window is adjusted only if the window is part of a horizontal combination (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;) to avoid changing the width of other, unrelated windows. Also, this entry should be processed under only certain conditions which are specified right below this list.</source>
          <target state="translated">按照惯例，只有在窗口是水平组合的一部分（请参见&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames&lt;/a&gt;）的情况下，才调整所选窗口的宽度，以避免更改其他不相关窗口的宽度。另外，应仅在此列表正下方指定的某些条件下处理此条目。</target>
        </trans-unit>
        <trans-unit id="f1f59fea98d20db1b1e18d570c20cefba2dd601a" translate="yes" xml:space="preserve">
          <source>By convention, vertical offsets increase &amp;ldquo;downwards&amp;rdquo;. This means that the height of a frame is obtained by subtracting the offset of its top edge from that of its bottom edge. Horizontal offsets increase &amp;ldquo;rightwards&amp;rdquo;, as expected, so a frame&amp;rsquo;s width is calculated by subtracting the offset of its left edge from that of its right edge.</source>
          <target state="translated">按照惯例，垂直偏移量&amp;ldquo;向下&amp;rdquo;增加。这意味着框架的高度是通过将其上边缘的偏移量减去其下边缘的偏移量而获得的。如预期的那样，水平偏移量&amp;ldquo;向右&amp;rdquo;增加，因此框架的宽度是通过从其右边缘的偏移量减去其左边缘的偏移量来计算的。</target>
        </trans-unit>
        <trans-unit id="5bc4ab559bcd3485770406aa3206099c2c318a03" translate="yes" xml:space="preserve">
          <source>By convention, when defining variables of a &amp;ldquo;native&amp;rdquo; type (&lt;code&gt;int&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;), the name of the C variable is the name of the Lisp variable with &lt;code&gt;-&lt;/code&gt; replaced by &lt;code&gt;_&lt;/code&gt;. When the variable has type &lt;code&gt;Lisp_Object&lt;/code&gt;, the convention is to also prefix the C variable name with &lt;code&gt;V&lt;/code&gt;. i.e.</source>
          <target state="translated">按照惯例，当定义&amp;ldquo;本机&amp;rdquo;类型的变量（ &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;bool&lt;/code&gt; ）时，C变量的名称是Lisp变量的名称，其中 &lt;code&gt;-&lt;/code&gt; 替换为 &lt;code&gt;_&lt;/code&gt; 。当变量的类型为 &lt;code&gt;Lisp_Object&lt;/code&gt; 时，约定还应在C变量名称前加上 &lt;code&gt;V&lt;/code&gt; 前缀。即</target>
        </trans-unit>
        <trans-unit id="0b42bb254be6d5ac55cc35f34239ee11afcaf79a" translate="yes" xml:space="preserve">
          <source>By convention, you should put the &lt;code&gt;interactive&lt;/code&gt; form in the function body, as the first top-level form. If there is an &lt;code&gt;interactive&lt;/code&gt; form in both the &lt;code&gt;interactive-form&lt;/code&gt; symbol property and the function body, the former takes precedence. The &lt;code&gt;interactive-form&lt;/code&gt; symbol property can be used to add an interactive form to an existing function, or change how its arguments are processed interactively, without redefining the function.</source>
          <target state="translated">按照惯例，您应该将 &lt;code&gt;interactive&lt;/code&gt; 表单放在函数主体中，作为第一个顶级表单。如果有一个 &lt;code&gt;interactive&lt;/code&gt; 两个形式 &lt;code&gt;interactive-form&lt;/code&gt; 符号属性和功能体，前者优先。所述 &lt;code&gt;interactive-form&lt;/code&gt; 符号属性可用于交互式表单添加到现有的功能，或改变如何其参数被交互地处理，不需要重新定义的功能。</target>
        </trans-unit>
        <trans-unit id="bd6cd1964a58199f17af10ed0710e7304dbef795" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; can switch to a buffer that is already shown in another window. The following option can be used to override this behavior.</source>
          <target state="translated">默认情况下， &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 和 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 可以切换到已经在另一个窗口中显示的缓冲区。以下选项可用于替代此行为。</target>
        </trans-unit>
        <trans-unit id="c2e5b9fa592a3409a2011f26d6c0a6701c7e5da1" translate="yes" xml:space="preserve">
          <source>By default both IPv4 and IPv6 lookups are attempted. The optional argument &lt;var&gt;family&lt;/var&gt; controls this behavior, specifying the symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts lookups to IPv4 and IPv6 respectively.</source>
          <target state="translated">默认情况下，尝试同时进行IPv4和IPv6查找。可选参数 &lt;var&gt;family&lt;/var&gt; 控制此行为，指定符号 &lt;code&gt;ipv4&lt;/code&gt; 或 &lt;code&gt;ipv6&lt;/code&gt; 分别将查找限制为IPv4和IPv6。</target>
        </trans-unit>
        <trans-unit id="af6f338f5f9982890241460392dfd56c79820ad8" translate="yes" xml:space="preserve">
          <source>By default the dumped</source>
          <target state="translated">默认情况下,转储的</target>
        </trans-unit>
        <trans-unit id="ec8b6ebd7649499745ebeafd06ed0b949a38dabd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;eval-region&lt;/code&gt; does not produce any output. However, if &lt;var&gt;stream&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any output produced by output functions (see &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;), as well as the values that result from evaluating the expressions in the region are printed using &lt;var&gt;stream&lt;/var&gt;. See &lt;a href=&quot;output-streams#Output-Streams&quot;&gt;Output Streams&lt;/a&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;eval-region&lt;/code&gt; 不产生任何输出。但是，如果 &lt;var&gt;stream&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则使用 &lt;var&gt;stream&lt;/var&gt; 打印由输出函数（请参见&lt;a href=&quot;output-functions#Output-Functions&quot;&gt;输出函数&lt;/a&gt;）产生的任何输出，以及评估该区域中的表达式所得的值。请参见&lt;a href=&quot;output-streams#Output-Streams&quot;&gt;输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a53473f0b03225bb59517eff6e8b663daa1b7774" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;switch-to-buffer&lt;/code&gt; tries to preserve &lt;code&gt;window-point&lt;/code&gt;. This behavior can be tuned using the following option.</source>
          <target state="translated">默认情况下， &lt;code&gt;switch-to-buffer&lt;/code&gt; 尝试保留 &lt;code&gt;window-point&lt;/code&gt; 。可以使用以下选项调整此行为。</target>
        </trans-unit>
        <trans-unit id="ee1412f6a4896bbf8989a04623bf820b553fdea4" translate="yes" xml:space="preserve">
          <source>By default, &lt;var&gt;keywords&lt;/var&gt; are added at the beginning of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If the optional argument &lt;var&gt;how&lt;/var&gt; is &lt;code&gt;set&lt;/code&gt;, they are used to replace the value of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If &lt;var&gt;how&lt;/var&gt; is any other non-&lt;code&gt;nil&lt;/code&gt; value, they are added at the end of &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;var&gt;keywords&lt;/var&gt; 添加在 &lt;code&gt;font-lock-keywords&lt;/code&gt; 的开头。如果可选参数 &lt;var&gt;how&lt;/var&gt; 进行 &lt;code&gt;set&lt;/code&gt; ，它们被用来替代的价值 &lt;code&gt;font-lock-keywords&lt;/code&gt; 。如果其他非 &lt;code&gt;nil&lt;/code&gt; 值 &lt;var&gt;how&lt;/var&gt; ，则将它们添加在 &lt;code&gt;font-lock-keywords&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="10521942e8c52f15b21a03de5615c1566c427141" translate="yes" xml:space="preserve">
          <source>By default, Emacs determines the base direction of each paragraph by looking at the text at its beginning. The precise method of determining the base direction is specified by the</source>
          <target state="translated">默认情况下,Emacs通过查看每段开头的文本来确定其基本方向。确定基本方向的精确方法是由</target>
        </trans-unit>
        <trans-unit id="d9bc871638c9fc2d81d98a2b4d5d096f7d797fd7" translate="yes" xml:space="preserve">
          <source>By default, Emacs makes a single backup file for each file edited. You can alternatively request numbered backups; then each new backup file gets a new name. You can delete old numbered backups when you don&amp;rsquo;t want them any more, or Emacs can delete them automatically.</source>
          <target state="translated">默认情况下，Emacs为每个编辑的文件制作一个备份文件。您也可以请求编号的备份。那么每个新的备份文件都会得到一个新名称。您可以在不再需要旧编号的备份时删除它们，或者Emacs可以自动删除它们。</target>
        </trans-unit>
        <trans-unit id="eb5fb3e174ce7ebaa56506756450880c9f6707f5" translate="yes" xml:space="preserve">
          <source>By default, Emacs starts in multibyte mode: it stores the contents of buffers and strings using an internal encoding that represents non-</source>
          <target state="translated">默认情况下,Emacs以多字节模式启动:它使用内部编码存储缓冲区和字符串的内容,这些内容代表了非</target>
        </trans-unit>
        <trans-unit id="2439b1b4fb24aa8804e6e4ef3da82558ce16fc14" translate="yes" xml:space="preserve">
          <source>By default, Emacs tries to keep the number of lines and columns of a frame&amp;rsquo;s text area unaltered when, for example, toggling its menu or tool bar, changing its default font or setting the width of any of its scroll bars. This means that in such case Emacs must ask the window manager to resize the frame&amp;rsquo;s window in order to accommodate the size change.</source>
          <target state="translated">默认情况下，Emacs尝试保持框架文本区域的行数和列数不变，例如，在切换菜单或工具栏，更改其默认字体或设置其任何滚动条的宽度时。这意味着在这种情况下，Emacs必须要求窗口管理器调整框架窗口的大小以适应尺寸变化。</target>
        </trans-unit>
        <trans-unit id="c3302471f75eaf89ac88db46d17c6df0b07bc2a8" translate="yes" xml:space="preserve">
          <source>By default, a text property is rear-sticky but not front-sticky; thus, the default is to inherit all the properties of the preceding character, and nothing from the following character.</source>
          <target state="translated">默认情况下,一个文本属性是后粘性的,但不是前粘性的,因此,默认情况下是继承前一个字符的所有属性,而不继承后一个字符的任何属性。</target>
        </trans-unit>
        <trans-unit id="b6bdb814df1ff8f4484bd14e8665079dde59b196" translate="yes" xml:space="preserve">
          <source>By default, all subdirectories are descended into. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, errors when trying to descend into a subdirectory (for instance, if it&amp;rsquo;s not readable by this user) are ignored. If it&amp;rsquo;s neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, it should be a function that takes one parameter (the subdirectory name) and should return non-&lt;code&gt;nil&lt;/code&gt; if the directory is to be descended into.</source>
          <target state="translated">默认情况下，所有子目录都属于该子目录。如果 &lt;var&gt;predicate&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则尝试下级到子目录时（例如，如果该用户不可读）时的错误将被忽略。如果它既不是 &lt;code&gt;nil&lt;/code&gt; 也不是 &lt;code&gt;t&lt;/code&gt; ，则它应该是一个带有一个参数（子目录名称）的函数，并且如果该目录要降级到该函数，则应返回non- &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34620b2db91cbe790eb8b807c0d8c806964cdff3" translate="yes" xml:space="preserve">
          <source>By default, format specifications correspond to successive values from &lt;var&gt;objects&lt;/var&gt;. Thus, the first format specification in &lt;var&gt;string&lt;/var&gt; uses the first such value, the second format specification uses the second such value, and so on. Any extra format specifications (those for which there are no corresponding values) cause an error. Any extra values to be formatted are ignored.</source>
          <target state="translated">默认情况下，格式规范对应于 &lt;var&gt;objects&lt;/var&gt; 连续值。因此， &lt;var&gt;string&lt;/var&gt; 的第一个格式说明使用第一个这样的值，第二个格式说明使用第二个这样的值，依此类推。任何其他格式规范（没有对应的值）都会导致错误。任何要格式化的额外值都将被忽略。</target>
        </trans-unit>
        <trans-unit id="cfab6cab0b08bc4c2da07991fa913322ec8175a9" translate="yes" xml:space="preserve">
          <source>By default, frame parameters are saved and restored by the desktop library functions (see &lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;Desktop Save Mode&lt;/a&gt;) when the variable &lt;code&gt;desktop-restore-frames&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. It&amp;rsquo;s the responsibility of applications that their parameters are included in &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; to avoid that they get meaningless or even harmful values in restored sessions.</source>
          <target state="translated">默认情况下，当变量 &lt;code&gt;desktop-restore-frames&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 时，框架参数由桌面库功能保存和恢复（请参阅&lt;a href=&quot;desktop-save-mode#Desktop-Save-Mode&quot;&gt;桌面保存模式&lt;/a&gt;）。应用程序负责将它们的参数包含在 &lt;code&gt;frameset-persistent-filter-alist&lt;/code&gt; 中,以避免在恢复的会话中它们变得毫无意义甚至有害。</target>
        </trans-unit>
        <trans-unit id="4ff08fda735af5f6543bdd7e51226e1a37b99336" translate="yes" xml:space="preserve">
          <source>By default, if the latest auto-save file is more recent than the visited file, and the argument &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; asks the user whether to use that auto-save instead. When you invoke this command interactively, &lt;var&gt;ignore-auto&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.</source>
          <target state="translated">默认情况下，如果最新的自动保存文件比访问的文件更新，并且参数 &lt;var&gt;ignore-auto&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;revert-buffer&lt;/code&gt; 询问用户是否使用该自动保存。交互式调用此命令时，如果没有数字前缀参数，则 &lt;var&gt;ignore-auto&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ;否则为0。因此，交互式默认设置是不检查自动保存文件。</target>
        </trans-unit>
        <trans-unit id="2816188a5a0e8a3ed928cd480d7464b05373951a" translate="yes" xml:space="preserve">
          <source>By default, it also defines a variable named &lt;var&gt;mode&lt;/var&gt;, which is set to &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; by enabling or disabling the mode. The variable is initialized to &lt;var&gt;init-value&lt;/var&gt;. Except in unusual circumstances (see below), this value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">默认情况下，它还定义了一个名为 &lt;var&gt;mode&lt;/var&gt; 的变量，通过启用或禁用模式将其设置为 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。变量被初始化为 &lt;var&gt;init-value&lt;/var&gt; 。除非在特殊情况下（请参阅下文），否则该值必须为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1adc609228685b29696e0ff7e75061c83ffb5bde" translate="yes" xml:space="preserve">
          <source>By default, output is put in a buffer.</source>
          <target state="translated">默认情况下,输出会放在一个缓冲区中。</target>
        </trans-unit>
        <trans-unit id="410cbb685716930dfd39abc9cbf65a643f166d48" translate="yes" xml:space="preserve">
          <source>By default, process output is inserted in the associated buffer. (You can change this by defining a custom filter function, see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.) The position to insert the output is determined by the &lt;code&gt;process-mark&lt;/code&gt;, which is then updated to point to the end of the text just inserted. Usually, but not always, the &lt;code&gt;process-mark&lt;/code&gt; is at the end of the buffer.</source>
          <target state="translated">默认情况下，进程输出插入关联的缓冲区中。（您可以通过定义自定义过滤器功能来更改此设置，请参阅&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;过滤器功能&lt;/a&gt;。）插入输出的位置由 &lt;code&gt;process-mark&lt;/code&gt; 决定，然后将其更新为指向刚插入的文本的结尾。通常但并非总是如此， &lt;code&gt;process-mark&lt;/code&gt; 位于缓冲区的末尾。</target>
        </trans-unit>
        <trans-unit id="f08b23f065e4db8b7e347aa8e9d5f1dfa79f259d" translate="yes" xml:space="preserve">
          <source>By default, searches in Emacs ignore the case of the text they are searching through; if you specify searching for &amp;lsquo;</source>
          <target state="translated">默认情况下，Emacs中的搜索会忽略它们正在搜索的文本的大小写；如果您指定搜索&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1fd764f8ebd1a38813dea49832550f50112ed16b" translate="yes" xml:space="preserve">
          <source>By default, side windows cannot be split via &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;). Also, a side window is not reused or split by any buffer display action (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) unless it is explicitly specified as target of that action. Note also that &lt;code&gt;delete-other-windows&lt;/code&gt; cannot make a side window the only window on its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;).</source>
          <target state="translated">默认情况下，无法通过 &lt;code&gt;split-window&lt;/code&gt; （请参见&lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;拆分窗口&lt;/a&gt;）。另外，未再利用的侧窗或拆分通过任何缓冲器显示动作（见&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;缓冲显示屏操作功能&lt;/a&gt;），除非它被明确地指定为目标作用。还要注意， &lt;code&gt;delete-other-windows&lt;/code&gt; 不能使侧面窗口成为其框架上的唯一窗口（请参阅&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="337f680b05ae479de5bb330579bb081a7cad8c38" translate="yes" xml:space="preserve">
          <source>By default, the error output from the process, if any, is also passed to the filter function, unless the destination for the standard error stream of the process was separated from the standard output when the process was created. Emacs will only call the filter function during certain function calls. See &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;. Note that if any of those functions are called by the filter, the filter may be called recursively.</source>
          <target state="translated">默认情况下，过程的错误输出（如果有的话）也会传递到过滤器函数，除非在创建过程时将过程的标准错误流的目标与标准输出分开。 Emacs仅在某些函数调用期间调用filter函数。请参阅&lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;流程的输出&lt;/a&gt;。请注意，如果过滤器调用了这些函数中的任何一个，则可以递归调用过滤器。</target>
        </trans-unit>
        <trans-unit id="06b7d4e5494854a61c5e08ae9fc06e3dd1a74a05" translate="yes" xml:space="preserve">
          <source>By default, the functions that save and restore window configurations or the states of windows (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;) do not care about window parameters. This means that when you change the value of a parameter within the body of a &lt;code&gt;save-window-excursion&lt;/code&gt;, the previous value is not restored when that macro exits. It also means that when you restore via &lt;code&gt;window-state-put&lt;/code&gt; a window state saved earlier by &lt;code&gt;window-state-get&lt;/code&gt;, all cloned windows have their parameters reset to &lt;code&gt;nil&lt;/code&gt;. The following variable allows you to override the standard behavior:</source>
          <target state="translated">默认情况下，保存和恢复窗口配置或窗口状态的功能（请参阅&lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;窗口配置&lt;/a&gt;）不关心窗口参数。这意味着，当您更改 &lt;code&gt;save-window-excursion&lt;/code&gt; 主体内的参数值时，该宏退出时不会恢复先前的值。这也意味着，当您通过 &lt;code&gt;window-state-put&lt;/code&gt; 还原先前由 &lt;code&gt;window-state-get&lt;/code&gt; 保存的窗口状态时，所有克隆的窗口的参数都将重置为 &lt;code&gt;nil&lt;/code&gt; 。以下变量使您可以覆盖标准行为：</target>
        </trans-unit>
        <trans-unit id="42d60f64d2f3044aeab0d538900375a76783a13e" translate="yes" xml:space="preserve">
          <source>By default, the global map binds &lt;code&gt;[tool-bar]&lt;/code&gt; as follows:</source>
          <target state="translated">默认情况下，全局映射按以下方式绑定 &lt;code&gt;[tool-bar]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7273860db2763e093bd47c6c91c3aff5ba16714f" translate="yes" xml:space="preserve">
          <source>By default, the local bindings that Emacs creates are &lt;em&gt;dynamic bindings&lt;/em&gt;. Such a binding has &lt;em&gt;dynamic scope&lt;/em&gt;, meaning that any part of the program can potentially access the variable binding. It also has &lt;em&gt;dynamic extent&lt;/em&gt;, meaning that the binding lasts only while the binding construct (such as the body of a &lt;code&gt;let&lt;/code&gt; form) is being executed.</source>
          <target state="translated">默认情况下，Emacs创建的本地绑定是&lt;em&gt;动态绑定&lt;/em&gt;。这样的绑定具有&lt;em&gt;动态范围&lt;/em&gt;，这意味着程序的任何部分都可以潜在地访问变量绑定。它还具有&lt;em&gt;动态范围&lt;/em&gt;，这意味着绑定仅在执行绑定构造（例如 &lt;code&gt;let&lt;/code&gt; 窗体的主体）时才持续。</target>
        </trans-unit>
        <trans-unit id="fd1815fd5a5c0fb02829db09a71557be08961cdb" translate="yes" xml:space="preserve">
          <source>By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding.</source>
          <target state="translated">默认情况下,Emacs所做的局部变量绑定是动态绑定。当一个变量被动态绑定时,在Lisp程序执行的任何一点上,它的当前绑定只是该符号最近创建的动态局部绑定,如果没有这样的局部绑定,则是全局绑定。</target>
        </trans-unit>
        <trans-unit id="47f31a9758da1b80f09abc18f1231cee612e7b61" translate="yes" xml:space="preserve">
          <source>By default, the range of codepoints passed to &lt;var&gt;function&lt;/var&gt; includes all the characters in &lt;var&gt;charset&lt;/var&gt;, but optional arguments &lt;var&gt;from-code&lt;/var&gt; and &lt;var&gt;to-code&lt;/var&gt; limit that to the range of characters between these two codepoints of &lt;var&gt;charset&lt;/var&gt;. If either of them is &lt;code&gt;nil&lt;/code&gt;, it defaults to the first or last codepoint of &lt;var&gt;charset&lt;/var&gt;, respectively.</source>
          <target state="translated">默认情况下，传递给 &lt;var&gt;function&lt;/var&gt; 的代码点范围包括 &lt;var&gt;charset&lt;/var&gt; 中的所有字符，但是可选参数 &lt;var&gt;from-code&lt;/var&gt; 和 &lt;var&gt;to-code&lt;/var&gt; 将其限制为 &lt;var&gt;charset&lt;/var&gt; 这两个代码点之间的字符范围。如果它们中的任何一个为 &lt;code&gt;nil&lt;/code&gt; ，则分别默认为 &lt;var&gt;charset&lt;/var&gt; 的第一个或最后一个代码点。</target>
        </trans-unit>
        <trans-unit id="3d1494bcaafdc3c540ef160a9f8e6f65dd4261e3" translate="yes" xml:space="preserve">
          <source>By default, the space taken up by &lt;var&gt;window&lt;/var&gt; is given to one of its adjacent sibling windows, if any. However, if the variable &lt;code&gt;window-combination-resize&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the space is proportionally distributed among any remaining windows in the same window combination. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;.</source>
          <target state="translated">默认情况下， &lt;var&gt;window&lt;/var&gt; 占用的空间将分配给其相邻的同级窗口之一（如果有）。但是，如果变量 &lt;code&gt;window-combination-resize&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则该空间将按比例分配在同一窗口组合中的所有其余窗口之间。请参阅重新组合&lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Windows&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1defe0245424aab283006a635faaa0b360d0c56" translate="yes" xml:space="preserve">
          <source>By default, the value is a function that asks the user whether to proceed.</source>
          <target state="translated">默认情况下,该值是一个询问用户是否继续的函数。</target>
        </trans-unit>
        <trans-unit id="6d7d2b01d1d4f6143cd45dbac4779e0cc9e9e7c9" translate="yes" xml:space="preserve">
          <source>By default, the values are integers that are 100 times the system load averages, but if &lt;var&gt;use-float&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then they are returned as floating-point numbers without multiplying by 100.</source>
          <target state="translated">默认情况下，这些值是系统负载平均值的100倍的整数，但是如果 &lt;var&gt;use-float&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则它们将以浮点数形式返回而不乘以100。</target>
        </trans-unit>
        <trans-unit id="e561fba1f476b09361515566e3c64701551c6912" translate="yes" xml:space="preserve">
          <source>By default, this alist contains one entry with the key &lt;code&gt;edebug&lt;/code&gt; and a list of three functions, which are the default implementations of the functions inserted in instrumented code: &lt;code&gt;edebug-enter&lt;/code&gt;, &lt;code&gt;edebug-before&lt;/code&gt; and &lt;code&gt;edebug-after&lt;/code&gt;. To change Edebug&amp;rsquo;s behavior globally, modify the default entry.</source>
          <target state="translated">默认情况下，此列表包含一个具有 &lt;code&gt;edebug&lt;/code&gt; 键的条目和三个函数的列表，这三个函数是插入已插入代码中的函数的默认实现： &lt;code&gt;edebug-enter&lt;/code&gt; ， &lt;code&gt;edebug-before&lt;/code&gt; 和 &lt;code&gt;edebug-after&lt;/code&gt; 。要全局更改Edebug的行为，请修改默认条目。</target>
        </trans-unit>
        <trans-unit id="a30c2c9f6f69702d4744ebbd4fe0caff5ca90a07" translate="yes" xml:space="preserve">
          <source>By default, this function also moves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer to the front of the buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) and makes &lt;var&gt;window&lt;/var&gt; the most recently selected window. If the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these additional actions are omitted.</source>
          <target state="translated">默认情况下，此功能还将 &lt;var&gt;window&lt;/var&gt; 的缓冲区移到缓冲区列表的前面（请参见&lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;），并使 &lt;var&gt;window&lt;/var&gt; 成为最近选择的窗口。如果可选参数 &lt;var&gt;norecord&lt;/var&gt; 为non- &lt;code&gt;nil&lt;/code&gt; ，则将省略这些其他操作。</target>
        </trans-unit>
        <trans-unit id="314e04d83201875669bd5820e278b79ec5e410e1" translate="yes" xml:space="preserve">
          <source>By default, this function resets &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s position, display margins, fringe widths, and scroll bar settings, based on the local variables in the specified buffer. However, if the optional argument &lt;var&gt;keep-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it leaves &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display margins, fringes and scroll bar settings alone.</source>
          <target state="translated">默认情况下，此功能会根据指定缓冲区中的局部变量来重置 &lt;var&gt;window&lt;/var&gt; 的位置，显示边距，边缘宽度和滚动条设置。但是，如果可选参数 &lt;var&gt;keep-margins&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则仅保留 &lt;var&gt;window&lt;/var&gt; 的显示边距，边缘和滚动条设置。</target>
        </trans-unit>
        <trans-unit id="c8d7822491c87018aaf653bdc89135199d35d678" translate="yes" xml:space="preserve">
          <source>By default, this variable is always set to &lt;code&gt;t&lt;/code&gt;, meaning that a call of &lt;code&gt;process-file&lt;/code&gt; could potentially change any file on a remote host. When set to &lt;code&gt;nil&lt;/code&gt;, a file name handler could optimize its behavior with respect to remote file attribute caching.</source>
          <target state="translated">默认情况下，此变量始终设置为 &lt;code&gt;t&lt;/code&gt; ，这意味着对 &lt;code&gt;process-file&lt;/code&gt; 的调用可能会更改远程主机上的任何文件。设置为 &lt;code&gt;nil&lt;/code&gt; 时，文件名处理程序可以针对远程文件属性缓存优化其行为。</target>
        </trans-unit>
        <trans-unit id="fe49d9f104dc3f50cf901776febad4cfc3162c78" translate="yes" xml:space="preserve">
          <source>By default, this variable&amp;rsquo;s value is &lt;code&gt;read&lt;/code&gt;. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">默认情况下，此变量的值为 &lt;code&gt;read&lt;/code&gt; 。请参阅&lt;a href=&quot;input-functions#Input-Functions&quot;&gt;输入函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2688defb0c98a25897334d05cea4581b8ab7493" translate="yes" xml:space="preserve">
          <source>By design, action functions are free in their interpretation of action alist entries. In fact, some entries like &lt;code&gt;allow-no-window&lt;/code&gt; or &lt;code&gt;previous-window&lt;/code&gt; have a meaning only for one or a few action functions, and are ignored by the rest. Other entries, like &lt;code&gt;inhibit-same-window&lt;/code&gt; or &lt;code&gt;window-parameters&lt;/code&gt;, are supposed to be respected by most action functions, including those provided by application programs and external packages.</source>
          <target state="translated">通过设计，动作功能在解释动作列表条目时是免费的。实际上，某些条目（例如 &lt;code&gt;allow-no-window&lt;/code&gt; 或 &lt;code&gt;previous-window&lt;/code&gt; )仅对一个或几个动作函数具有含义，而其余的则被忽略。其他动作（如 &lt;code&gt;inhibit-same-window&lt;/code&gt; 或 &lt;code&gt;window-parameters&lt;/code&gt; ）应被大多数动作功能所尊重，包括应用程序和外部程序包所提供的功能。</target>
        </trans-unit>
        <trans-unit id="5df52f7953c9e1e23b06b07d93d36bf7c4082b84" translate="yes" xml:space="preserve">
          <source>By design, operations to make or modify child frames are implemented with the help of frame parameters (see &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;) without any specialized functions or customizable variables. Note that child frames are meaningful on graphical terminals only.</source>
          <target state="translated">通过设计，在没有任何专门功能或可自定义变量的情况下，借助框架参数（请参阅&amp;ldquo;&lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;框架参数&amp;rdquo;&lt;/a&gt;）来实现制作或修改子框架的操作。请注意，子框架仅在图形终端上才有意义。</target>
        </trans-unit>
        <trans-unit id="bc5e006af20582138d39d0ef5f207bc52db0c4b3" translate="yes" xml:space="preserve">
          <source>By editing the buffer in place. In this case, &lt;var&gt;to-fn&lt;/var&gt; should return the end-position of the range of text, as modified.</source>
          <target state="translated">通过在适当位置编辑缓冲区。在这种情况下， &lt;var&gt;to-fn&lt;/var&gt; 应该返回修改后的文本范围的结束位置。</target>
        </trans-unit>
        <trans-unit id="63b5c76c72ae22fa7a5d14c68660da304cacecaf" translate="yes" xml:space="preserve">
          <source>By returning a list of annotations. This is a list of elements of the form &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;position&lt;/var&gt; is an integer specifying the relative position in the text to be written, and &lt;var&gt;string&lt;/var&gt; is the annotation to add there. The list must be sorted in order of position when &lt;var&gt;to-fn&lt;/var&gt; returns it.</source>
          <target state="translated">通过返回注释列表。这是形式的元素的列表 &lt;code&gt;(&lt;var&gt;position&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; ，其中， &lt;var&gt;position&lt;/var&gt; 是一个整数，它指定在文本中的相对位置将被写入，并 &lt;var&gt;string&lt;/var&gt; 是添加有注释。当 &lt;var&gt;to-fn&lt;/var&gt; 返回列表时，该列表必须按位置顺序排序。</target>
        </trans-unit>
        <trans-unit id="b9df056fb7a4026d67a3485fe6622bd0ac5e4705" translate="yes" xml:space="preserve">
          <source>By setting the &lt;var&gt;action&lt;/var&gt; argument, an application effectively overrules any customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt;. Our user can now either accept the choice of the application, or redouble by customizing the option &lt;code&gt;display-buffer-alist&lt;/code&gt; as follows:</source>
          <target state="translated">通过设置 &lt;var&gt;action&lt;/var&gt; 参数，应用程序可以有效地否决 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 的任何自定义。我们的用户现在可以接受应用程序的选择，也可以通过如下所示自定义选项 &lt;code&gt;display-buffer-alist&lt;/code&gt; 加倍：</target>
        </trans-unit>
        <trans-unit id="3d82e754d3481447db663d32552753c526295b30" translate="yes" xml:space="preserve">
          <source>Byte Compilation</source>
          <target state="translated">字节汇编</target>
        </trans-unit>
        <trans-unit id="38293ea2f575b674a58092e2860f65e375cf569f" translate="yes" xml:space="preserve">
          <source>Byte compilation functions.</source>
          <target state="translated">字节编译功能。</target>
        </trans-unit>
        <trans-unit id="05bc2b18f50e1c59ce5be83b3a043fed7d8464a5" translate="yes" xml:space="preserve">
          <source>Byte compiler warnings can be controlled more precisely by setting the variable &lt;code&gt;byte-compile-warnings&lt;/code&gt;. See its documentation string for details.</source>
          <target state="translated">通过设置变量 &lt;code&gt;byte-compile-warnings&lt;/code&gt; 可以更精确地控制字节编译器警告。有关详细信息，请参见其文档字符串。</target>
        </trans-unit>
        <trans-unit id="30c3dfd8676a2b612dc32e5e0e6e366336cdb1d2" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Objects</source>
          <target state="translated">字节码函数对象</target>
        </trans-unit>
        <trans-unit id="11dfd8a56350515cd4673e500974d1d76f92ac16" translate="yes" xml:space="preserve">
          <source>Byte-Code Function Type</source>
          <target state="translated">字节码功能类型</target>
        </trans-unit>
        <trans-unit id="59fecc0a37710dd91bf58606dfa13b25c3069f87" translate="yes" xml:space="preserve">
          <source>Byte-Compilation Functions</source>
          <target state="translated">字节编译函数</target>
        </trans-unit>
        <trans-unit id="1a37ba1d3be3c3de01e4d5d496b8285b080495ba" translate="yes" xml:space="preserve">
          <source>Byte-compiled functions have a special data type: they are &lt;em&gt;byte-code function objects&lt;/em&gt;. Whenever such an object appears as a function to be called, Emacs uses the byte-code interpreter to execute the byte-code.</source>
          <target state="translated">字节编译函数具有特殊的数据类型：它们是&lt;em&gt;字节码函数对象&lt;/em&gt;。每当此类对象显示为要调用的函数时，Emacs就会使用字节码解释器来执行字节码。</target>
        </trans-unit>
        <trans-unit id="3bb9f8596b1e76a28bc9081c521014596231e12a" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file also executes any &lt;code&gt;require&lt;/code&gt; calls at top-level in the file, so you can ensure that necessary macro definitions are available during compilation by requiring the files that define them (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). To avoid loading the macro definition files when someone &lt;em&gt;runs&lt;/em&gt; the compiled program, write &lt;code&gt;eval-when-compile&lt;/code&gt; around the &lt;code&gt;require&lt;/code&gt; calls (see &lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;Eval During Compile&lt;/a&gt;).</source>
          <target state="translated">字节编译文件还可以在文件的顶层执行所有 &lt;code&gt;require&lt;/code&gt; 调用，因此您可以通过要求定义文件的宏来确保必要的宏定义可用（请参见&lt;a href=&quot;named-features#Named-Features&quot;&gt;命名功能&lt;/a&gt;）。为了避免在有人&lt;em&gt;运行&lt;/em&gt;已编译程序时加载宏定义文件，请&lt;a href=&quot;eval-during-compile#Eval-During-Compile&quot;&gt;在&lt;/a&gt; &lt;code&gt;require&lt;/code&gt; 调用周围编写 &lt;code&gt;eval-when-compile&lt;/code&gt; （请参见编译期间的Eval）。</target>
        </trans-unit>
        <trans-unit id="cc41f45aabe0cfaf8f1fb19aff9d4d9cd35def84" translate="yes" xml:space="preserve">
          <source>Byte-compiling a file often produces warnings about functions that the compiler doesn&amp;rsquo;t know about (see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling</source>
          <target state="translated">字节编译文件通常会产生有关编译器不知道的功能的警告（请参阅&lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;编译器错误&lt;/a&gt;）。有时这表明存在实际问题，但通常有问题的功能是在其他文件中定义的，如果运行该代码，则这些文件将被加载。例如，字节编译</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="440395ca055b9f07fbed0d7cf4596c35fc237caa" translate="yes" xml:space="preserve">
          <source>C Dialect</source>
          <target state="translated">C方言</target>
        </trans-unit>
        <trans-unit id="161c19c41476b0282b81eeb78bdaec44cc5f26eb" translate="yes" xml:space="preserve">
          <source>C Integer Types</source>
          <target state="translated">C 整数类型</target>
        </trans-unit>
        <trans-unit id="f1dfdb58024fd801bb8d8d91b16183f255579149" translate="yes" xml:space="preserve">
          <source>C-</source>
          <target state="translated">C-</target>
        </trans-unit>
        <trans-unit id="e98b70997278aacbb8d37c462eeefc3cbd3956d9" translate="yes" xml:space="preserve">
          <source>C-=</source>
          <target state="translated">C-=</target>
        </trans-unit>
        <trans-unit id="f91ccd340101fead85b132fc626cf86c66e71760" translate="yes" xml:space="preserve">
          <source>C-@</source>
          <target state="translated">C-@</target>
        </trans-unit>
        <trans-unit id="5a32717cd694e62b994ffe84487a025e94d4ba8d" translate="yes" xml:space="preserve">
          <source>C-A</source>
          <target state="translated">C-A</target>
        </trans-unit>
        <trans-unit id="a0720f926a1edd4fcb28152926e89547a933d93b" translate="yes" xml:space="preserve">
          <source>C-DEL</source>
          <target state="translated">C-DEL</target>
        </trans-unit>
        <trans-unit id="e8de50b9ffc20496735696fad0e0b83e070a5838" translate="yes" xml:space="preserve">
          <source>C-M-S-v</source>
          <target state="translated">C-M-S-v</target>
        </trans-unit>
        <trans-unit id="a587267328d8d782313379e66ff7b0b685da74e3" translate="yes" xml:space="preserve">
          <source>C-M-a</source>
          <target state="translated">C-M-a</target>
        </trans-unit>
        <trans-unit id="523363599c87501263758c3178a881d56b0ca0f3" translate="yes" xml:space="preserve">
          <source>C-M-b</source>
          <target state="translated">C-M-b</target>
        </trans-unit>
        <trans-unit id="9ab2ef69a1c8dee51e5c638f3f4dfb634fbe96a6" translate="yes" xml:space="preserve">
          <source>C-M-c</source>
          <target state="translated">C-M-c</target>
        </trans-unit>
        <trans-unit id="a2b4c4a3c492ba7d8900be9b332ed927f932ea89" translate="yes" xml:space="preserve">
          <source>C-M-e</source>
          <target state="translated">C-M-e</target>
        </trans-unit>
        <trans-unit id="1415d2b0c002711c0b18baff2ffb42f215277da7" translate="yes" xml:space="preserve">
          <source>C-M-f</source>
          <target state="translated">C-M-f</target>
        </trans-unit>
        <trans-unit id="e1283736390e7ca8f0e8dae4d7c15501e7285305" translate="yes" xml:space="preserve">
          <source>C-M-i</source>
          <target state="translated">C-M-i</target>
        </trans-unit>
        <trans-unit id="5554d733d6164f6f3c0310969979f52f4373a6f3" translate="yes" xml:space="preserve">
          <source>C-M-q</source>
          <target state="translated">C-M-q</target>
        </trans-unit>
        <trans-unit id="e48088e6addb18372a14ed6b8da1a6b58ad7c957" translate="yes" xml:space="preserve">
          <source>C-M-v</source>
          <target state="translated">C-M-v</target>
        </trans-unit>
        <trans-unit id="e3d2747af9266236b31cfe9dbcc1d21c148863e4" translate="yes" xml:space="preserve">
          <source>C-M-x</source>
          <target state="translated">C-M-x</target>
        </trans-unit>
        <trans-unit id="d149ce62d1e517cc3bc28b8250bb976be43efcc0" translate="yes" xml:space="preserve">
          <source>C-\</source>
          <target state="translated">C-\</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="5ec9d3dadc7abaeb1f5f16db2365b2aeb6a2f74b" translate="yes" xml:space="preserve">
          <source>C-_</source>
          <target state="translated">C-_</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="b3b7965656c0921692a30673d7781acd51c4eed9" translate="yes" xml:space="preserve">
          <source>C-c</source>
          <target state="translated">C-c</target>
        </trans-unit>
        <trans-unit id="2922399c2d547241985d2d9050d0f4a253f10c73" translate="yes" xml:space="preserve">
          <source>C-c 3</source>
          <target state="translated">C-c 3</target>
        </trans-unit>
        <trans-unit id="8c846cf1bd5b4fe56864ee3f4c9665e8b3b8fcc4" translate="yes" xml:space="preserve">
          <source>C-c &lt;var&gt;letter&lt;/var&gt;</source>
          <target state="translated">抄送 &lt;var&gt;letter&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">C-c C-d</target>
        </trans-unit>
        <trans-unit id="d0bed7baa3038554c15ed1dd0d2b6090b9910013" translate="yes" xml:space="preserve">
          <source>C-c C-u</source>
          <target state="translated">C-c C-u</target>
        </trans-unit>
        <trans-unit id="f74c88ff9d7e7d40f5d62f507900f4cb7519ee90" translate="yes" xml:space="preserve">
          <source>C-c C-w</source>
          <target state="translated">C-c-C-w</target>
        </trans-unit>
        <trans-unit id="e396508e7aa9423085342ba159b546882b435194" translate="yes" xml:space="preserve">
          <source>C-c C-z</source>
          <target state="translated">C-c C-z</target>
        </trans-unit>
        <trans-unit id="98c56570dd5671b7a19fbc0ebf8785f9ff91eddc" translate="yes" xml:space="preserve">
          <source>C-c ESC</source>
          <target state="translated">C-c ESC</target>
        </trans-unit>
        <trans-unit id="f9d21da244350a9db0114ec30af406d5bef1cb45" translate="yes" xml:space="preserve">
          <source>C-c ESC O P</source>
          <target state="translated">C-c ESC O P</target>
        </trans-unit>
        <trans-unit id="57e4e54e9967cd42daed8a76a5aa899b154b7b12" translate="yes" xml:space="preserve">
          <source>C-c PF1</source>
          <target state="translated">C-c PF1</target>
        </trans-unit>
        <trans-unit id="d2e5a2b66c696b957548f71ee728ee1ae137f0c0" translate="yes" xml:space="preserve">
          <source>C-c h</source>
          <target state="translated">C-c h</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a4b41cc50f9ee3592ac03dec905ea87299f64719" translate="yes" xml:space="preserve">
          <source>C-f C-n</source>
          <target state="translated">C-f C-n</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="a8d14a9f4bc55d9a8a84935ad37682321efb17a6" translate="yes" xml:space="preserve">
          <source>C-h</source>
          <target state="translated">C-h</target>
        </trans-unit>
        <trans-unit id="131f9a03ecbf035173b42486265daa4c059aa594" translate="yes" xml:space="preserve">
          <source>C-h C-h</source>
          <target state="translated">C-h C-h</target>
        </trans-unit>
        <trans-unit id="8fc1636b1726f0f848e9110d7df8ad94624fe8a2" translate="yes" xml:space="preserve">
          <source>C-h P</source>
          <target state="translated">C-h P</target>
        </trans-unit>
        <trans-unit id="d24cf6f79d3eca79589b614119c65a877786e8e3" translate="yes" xml:space="preserve">
          <source>C-h a</source>
          <target state="translated">C-h a</target>
        </trans-unit>
        <trans-unit id="c947b2d5d96ff5df49e3e32802fd4fbc37367b9c" translate="yes" xml:space="preserve">
          <source>C-h b</source>
          <target state="translated">C-h b</target>
        </trans-unit>
        <trans-unit id="2f32ced337101528820a543fba4ae73fd0b8a020" translate="yes" xml:space="preserve">
          <source>C-h c</source>
          <target state="translated">C-h c</target>
        </trans-unit>
        <trans-unit id="b6509cacdcc73abddf104ea8e33a97a3ac5575fa" translate="yes" xml:space="preserve">
          <source>C-h f</source>
          <target state="translated">C-h f</target>
        </trans-unit>
        <trans-unit id="044ffa482f401d4a34b0ce3d2fc0aa8a6c6451c5" translate="yes" xml:space="preserve">
          <source>C-h m</source>
          <target state="translated">C-h m</target>
        </trans-unit>
        <trans-unit id="94df7f22a37722547e0a4acb987c3e85a4c7583c" translate="yes" xml:space="preserve">
          <source>C-h v</source>
          <target state="translated">C-h v</target>
        </trans-unit>
        <trans-unit id="223627ab9c74b5ae56858c226557c9e9be301085" translate="yes" xml:space="preserve">
          <source>C-i</source>
          <target state="translated">C-i</target>
        </trans-unit>
        <trans-unit id="4d83990cce829d69d972a1ed2a1e206afb6b5b37" translate="yes" xml:space="preserve">
          <source>C-j</source>
          <target state="translated">C-j</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="023f8e3d8a24aa022603e7bc5546978051323321" translate="yes" xml:space="preserve">
          <source>C-p 6</source>
          <target state="translated">C-p 6</target>
        </trans-unit>
        <trans-unit id="7e58e0990d0a53938ca001b4ad01a74ad57ecbdf" translate="yes" xml:space="preserve">
          <source>C-p C-f</source>
          <target state="translated">C-p C-f</target>
        </trans-unit>
        <trans-unit id="1666955c646a9bb3fabdb2404112bd45b66ccb34" translate="yes" xml:space="preserve">
          <source>C-q</source>
          <target state="translated">C-q</target>
        </trans-unit>
        <trans-unit id="74b18abb702cb69395f60707416dd8e1f9e92a32" translate="yes" xml:space="preserve">
          <source>C-r</source>
          <target state="translated">C-r</target>
        </trans-unit>
        <trans-unit id="78540d990eb5e51e46b3d550d8999b517398872e" translate="yes" xml:space="preserve">
          <source>C-s</source>
          <target state="translated">C-s</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="d22f544f91c38776df9e98de756eed3debe16cdc" translate="yes" xml:space="preserve">
          <source>C-u -</source>
          <target state="translated">C-u-</target>
        </trans-unit>
        <trans-unit id="10f8bc5307f68632db725ed0931d63de1460ddfa" translate="yes" xml:space="preserve">
          <source>C-u -1 C-M-u</source>
          <target state="translated">C-u-1 C-M-u</target>
        </trans-unit>
        <trans-unit id="5f418fb7321d2ab8c56f997e5658b00a3040a2d1" translate="yes" xml:space="preserve">
          <source>C-u 0 C-j</source>
          <target state="translated">C-u 0 C-j</target>
        </trans-unit>
        <trans-unit id="da79c04f91b004dd27140e6acdba5d94bb656395" translate="yes" xml:space="preserve">
          <source>C-u 0 C-x C-e</source>
          <target state="translated">C-u 0 C-x C-e</target>
        </trans-unit>
        <trans-unit id="9abc686ab642db3617ba866712386a2c3367c984" translate="yes" xml:space="preserve">
          <source>C-u 1 2 3-</source>
          <target state="translated">C-u 1 2 3</target>
        </trans-unit>
        <trans-unit id="078553441ff260418cd0fae179ba0b421b563072" translate="yes" xml:space="preserve">
          <source>C-u 4</source>
          <target state="translated">C-u 4</target>
        </trans-unit>
        <trans-unit id="b45852e2bb35925480811fa34c28817e312757e2" translate="yes" xml:space="preserve">
          <source>C-u C-M-u</source>
          <target state="translated">C-u C-M-u</target>
        </trans-unit>
        <trans-unit id="320929c2d1df45760946518161a90d14f7c50bd7" translate="yes" xml:space="preserve">
          <source>C-u C-M-x</source>
          <target state="translated">C-u C-M-x</target>
        </trans-unit>
        <trans-unit id="c64b6c2b2de84365236fe039ef1643ad9097b181" translate="yes" xml:space="preserve">
          <source>C-u C-f</source>
          <target state="translated">C-u C-f</target>
        </trans-unit>
        <trans-unit id="144ed887662b97ccd7d5e4df38590e6b0c9188ee" translate="yes" xml:space="preserve">
          <source>C-u RET</source>
          <target state="translated">C-u RET</target>
        </trans-unit>
        <trans-unit id="c228f37d7ea330bf7c0d73a894ac443b387f3c40" translate="yes" xml:space="preserve">
          <source>C-u-</source>
          <target state="translated">C-u-</target>
        </trans-unit>
        <trans-unit id="0a23d9de112f4305bbf7d308788b4615cc11e2a2" translate="yes" xml:space="preserve">
          <source>C-v</source>
          <target state="translated">C-v</target>
        </trans-unit>
        <trans-unit id="298ef629795cfb23ea736c739c02035ede13e0c6" translate="yes" xml:space="preserve">
          <source>C-x</source>
          <target state="translated">C-x</target>
        </trans-unit>
        <trans-unit id="4347a3678ac074d5ec07c3503e15ff18b018adc3" translate="yes" xml:space="preserve">
          <source>C-x 0</source>
          <target state="translated">C-x 0</target>
        </trans-unit>
        <trans-unit id="10124bcc79d4680d2849a4ecb1654c7898083a7b" translate="yes" xml:space="preserve">
          <source>C-x 1</source>
          <target state="translated">C-x 1</target>
        </trans-unit>
        <trans-unit id="4d47f604c607b6bcf678aa67ec1bf75bf4ba7c33" translate="yes" xml:space="preserve">
          <source>C-x 2</source>
          <target state="translated">C-x 2</target>
        </trans-unit>
        <trans-unit id="556f397c3864e7f8b2430507a0e9a218c58fd56b" translate="yes" xml:space="preserve">
          <source>C-x 3</source>
          <target state="translated">C-x 3</target>
        </trans-unit>
        <trans-unit id="abc0d3ddf5ac08765cf41363b262bc421ad3ed38" translate="yes" xml:space="preserve">
          <source>C-x 4</source>
          <target state="translated">C-x 4</target>
        </trans-unit>
        <trans-unit id="63307f15d6b42550d550cea24aeaa5bda8c024a5" translate="yes" xml:space="preserve">
          <source>C-x 4 C-f</source>
          <target state="translated">C-x 4 C-f</target>
        </trans-unit>
        <trans-unit id="d7e8408a7a87b24eb8ce1e9cd577a71f1abc5c24" translate="yes" xml:space="preserve">
          <source>C-x 4 C-o</source>
          <target state="translated">C-x 4 C-o</target>
        </trans-unit>
        <trans-unit id="d4b75cbe5b9f13c775f58fb5aadb4fd2fca9c73f" translate="yes" xml:space="preserve">
          <source>C-x 5</source>
          <target state="translated">C-x 5</target>
        </trans-unit>
        <trans-unit id="74dc274a8f353a10c8762b6eeb01cd5d80e205ba" translate="yes" xml:space="preserve">
          <source>C-x 6</source>
          <target state="translated">C-x 6</target>
        </trans-unit>
        <trans-unit id="b0c7a6e9bf270123c8284d4924a852cb0abe30d2" translate="yes" xml:space="preserve">
          <source>C-x @</source>
          <target state="translated">C-x @</target>
        </trans-unit>
        <trans-unit id="9ac0e333a25e06893ccf8044371d24b9f4683984" translate="yes" xml:space="preserve">
          <source>C-x C-\</source>
          <target state="translated">C-x C-</target>
        </trans-unit>
        <trans-unit id="fdd391c7388aca6906f3e720a86ca5447e7d9c38" translate="yes" xml:space="preserve">
          <source>C-x C-a C-m</source>
          <target state="translated">C-x C-a C-m</target>
        </trans-unit>
        <trans-unit id="38858c4b382736f825616a2e73e26265ca9bb63a" translate="yes" xml:space="preserve">
          <source>C-x C-c</source>
          <target state="translated">C-x C-c</target>
        </trans-unit>
        <trans-unit id="2e574ba4b6c51b8c22a26b1eabc3a75c78d4ea7e" translate="yes" xml:space="preserve">
          <source>C-x C-e</source>
          <target state="translated">C-x C-e</target>
        </trans-unit>
        <trans-unit id="94093db9cb5d3fcd6ac5d93df4e2811d80860744" translate="yes" xml:space="preserve">
          <source>C-x C-f</source>
          <target state="translated">C-x C-f</target>
        </trans-unit>
        <trans-unit id="5aa04c1406d2bc59f9f02c65f0475fb37d41d69f" translate="yes" xml:space="preserve">
          <source>C-x C-g</source>
          <target state="translated">C-x C-g</target>
        </trans-unit>
        <trans-unit id="42560a5db134ba65783348e3bb0520d740376d48" translate="yes" xml:space="preserve">
          <source>C-x C-k</source>
          <target state="translated">C-x C-k</target>
        </trans-unit>
        <trans-unit id="92e72c608b382e9a997922e89877037677057e63" translate="yes" xml:space="preserve">
          <source>C-x C-k RET</source>
          <target state="translated">C-x C-k RET</target>
        </trans-unit>
        <trans-unit id="1c401be2ef044065bde20ae40271bd4ce7c9dbaa" translate="yes" xml:space="preserve">
          <source>C-x C-q</source>
          <target state="translated">C-x C-q</target>
        </trans-unit>
        <trans-unit id="a35119fcea09407a970dc0c67d75cdf4c7493695" translate="yes" xml:space="preserve">
          <source>C-x C-v</source>
          <target state="translated">C-x C-v</target>
        </trans-unit>
        <trans-unit id="380c2576bb1153c21b82305ecfd8e9cf75bb83cb" translate="yes" xml:space="preserve">
          <source>C-x C-w</source>
          <target state="translated">C-x C-w</target>
        </trans-unit>
        <trans-unit id="ad8e8247f1608bee89a7e56cab4034588ceeed4a" translate="yes" xml:space="preserve">
          <source>C-x ESC</source>
          <target state="translated">C-x ESC</target>
        </trans-unit>
        <trans-unit id="08a670503878dc334b05f1ec67cd80daa09a543f" translate="yes" xml:space="preserve">
          <source>C-x RET</source>
          <target state="translated">C-x RET</target>
        </trans-unit>
        <trans-unit id="33f00fe6ae825deab6e618f2518c895513248309" translate="yes" xml:space="preserve">
          <source>C-x RET c</source>
          <target state="translated">C-x RET c</target>
        </trans-unit>
        <trans-unit id="79182736a3f6f4a9b73be73dd66c6a963d18e6ef" translate="yes" xml:space="preserve">
          <source>C-x X =</source>
          <target state="translated">C-x X =</target>
        </trans-unit>
        <trans-unit id="06fec4fbfa2b40b5ba7dcd2878f2262be7a89cc4" translate="yes" xml:space="preserve">
          <source>C-x X W</source>
          <target state="translated">C-x X W</target>
        </trans-unit>
        <trans-unit id="b2d82441407b634931a0202fcd846528c8356104" translate="yes" xml:space="preserve">
          <source>C-x X X</source>
          <target state="translated">C-x X X</target>
        </trans-unit>
        <trans-unit id="0eabb8db03adc6a93c843bc7c3b4405a882bfbbf" translate="yes" xml:space="preserve">
          <source>C-x X w</source>
          <target state="translated">C-x X w</target>
        </trans-unit>
        <trans-unit id="a433c8910fd90328a865425f7cba86d9473bd9b8" translate="yes" xml:space="preserve">
          <source>C-x a</source>
          <target state="translated">C-x a</target>
        </trans-unit>
        <trans-unit id="d678c9278cafdf31c68ce0a63d4dfdb3f69b7e79" translate="yes" xml:space="preserve">
          <source>C-x a i</source>
          <target state="translated">C-x a i</target>
        </trans-unit>
        <trans-unit id="2aaaca2013569838cb0a146bd12e35301c230558" translate="yes" xml:space="preserve">
          <source>C-x b</source>
          <target state="translated">C-x b</target>
        </trans-unit>
        <trans-unit id="81a4dfc7002c34a5db314fd55a88c71ce9f8561c" translate="yes" xml:space="preserve">
          <source>C-x l</source>
          <target state="translated">C-x l</target>
        </trans-unit>
        <trans-unit id="b228794009dfb59282b23e84edcb2dc535059148" translate="yes" xml:space="preserve">
          <source>C-x left</source>
          <target state="translated">C-x左</target>
        </trans-unit>
        <trans-unit id="0b13a73400d0c3c495b50621ca5fbf45fa714316" translate="yes" xml:space="preserve">
          <source>C-x m</source>
          <target state="translated">C-x m</target>
        </trans-unit>
        <trans-unit id="e78aa0259487687b23094dfc0b1d246956ee5054" translate="yes" xml:space="preserve">
          <source>C-x n</source>
          <target state="translated">C-x n</target>
        </trans-unit>
        <trans-unit id="37419a3d9d60f9f4a3c3ceeae49cb867b0552dd5" translate="yes" xml:space="preserve">
          <source>C-x o</source>
          <target state="translated">C-x o</target>
        </trans-unit>
        <trans-unit id="06bba06d9146ec872930935a408ff9e6db7b540e" translate="yes" xml:space="preserve">
          <source>C-x q</source>
          <target state="translated">C-x q</target>
        </trans-unit>
        <trans-unit id="6e1b8f11e4e004ffcd85260453eb416fadd8becd" translate="yes" xml:space="preserve">
          <source>C-x r</source>
          <target state="translated">C-x r</target>
        </trans-unit>
        <trans-unit id="c03a751f3df1d75c00ca555cdecb7ea0f12e35b3" translate="yes" xml:space="preserve">
          <source>C-x t</source>
          <target state="translated">C-x t</target>
        </trans-unit>
        <trans-unit id="16f34907c9a94600e9a207daf61c838d0b36dc8a" translate="yes" xml:space="preserve">
          <source>C-x v</source>
          <target state="translated">C-x v</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="acbbb692ba3dcc7f0dd54066ac8990ff1950dc9c" translate="yes" xml:space="preserve">
          <source>C-z</source>
          <target state="translated">C-z</target>
        </trans-unit>
        <trans-unit id="ee5254754a61a705597a6d10837027cbbdd49eb6" translate="yes" xml:space="preserve">
          <source>CLOS</source>
          <target state="translated">CLOS</target>
        </trans-unit>
        <trans-unit id="8a9cbc4396b103e6b251b294230c1bb9eed38e2f" translate="yes" xml:space="preserve">
          <source>COM1</source>
          <target state="translated">COM1</target>
        </trans-unit>
        <trans-unit id="23f35962de37902073c854bc889f0133b87d83ae" translate="yes" xml:space="preserve">
          <source>COM9</source>
          <target state="translated">COM9</target>
        </trans-unit>
        <trans-unit id="cbb44b8d4066ca53d103823d7579880a884c46f2" translate="yes" xml:space="preserve">
          <source>CTL</source>
          <target state="translated">CTL</target>
        </trans-unit>
        <trans-unit id="b38bed0f0e9601a07358ec72777da31f91720f2a" translate="yes" xml:space="preserve">
          <source>CTRL</source>
          <target state="translated">CTRL</target>
        </trans-unit>
        <trans-unit id="5e1dd8155002a7d7db24335015acaddd25a44f09" translate="yes" xml:space="preserve">
          <source>CVS</source>
          <target state="translated">CVS</target>
        </trans-unit>
        <trans-unit id="36e5803b7728bb1569947feca18d17ebe22e40b0" translate="yes" xml:space="preserve">
          <source>Calendrical conversion functions always use the Gregorian calendar, even for dates before the Gregorian calendar was introduced. Year numbers count the number of years since the year 1 BC, and do not skip zero as traditional Gregorian years do; for example, the year number -37 represents the Gregorian year 38 BC.</source>
          <target state="translated">历法转换函数总是使用公历,即使是公历引入之前的日期。年号是指从公元前1年开始计算的年数,而不是像传统的格里高利年那样跳过0;例如,年号-37代表公元前38年的格里高利年。</target>
        </trans-unit>
        <trans-unit id="de42e995f53f7e732b05aa461dce2010e145fa00" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;button&lt;/var&gt;&amp;rsquo;s &lt;code&gt;action&lt;/code&gt; property (i.e., invoke the function that is the value of that property, passing it the single argument &lt;var&gt;button&lt;/var&gt;). If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. If the &lt;code&gt;button-data&lt;/code&gt; property is present in &lt;var&gt;button&lt;/var&gt;, use that as the argument for the &lt;code&gt;action&lt;/code&gt; function instead of &lt;var&gt;button&lt;/var&gt;.</source>
          <target state="translated">呼叫 &lt;var&gt;button&lt;/var&gt; 的 &lt;code&gt;action&lt;/code&gt; 属性（即，调用该属性的值的函数，并为其传递单个参数 &lt;var&gt;button&lt;/var&gt; ）。如果 &lt;var&gt;use-mouse-action&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，请尝试调用按钮的 &lt;code&gt;mouse-action&lt;/code&gt; 属性而不是 &lt;code&gt;action&lt;/code&gt; ；如果按钮没有 &lt;code&gt;mouse-action&lt;/code&gt; 属性，请照常使用 &lt;code&gt;action&lt;/code&gt; 。如果 &lt;code&gt;button-data&lt;/code&gt; 属性存在于 &lt;var&gt;button&lt;/var&gt; 中，请将其用作 &lt;code&gt;action&lt;/code&gt; 函数的参数，而不是 &lt;var&gt;button&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7e81e62a0bc26dffa21e5943c5b76d235ec9103" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">仅在旧函数返回 &lt;code&gt;nil&lt;/code&gt; 之后，才在旧 &lt;var&gt;function&lt;/var&gt; 之后调用函数。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="15f89cad7964a4c4ff36312550efc21a307afff6" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function and only if the old function returned non-&lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">调用 &lt;var&gt;function&lt;/var&gt; 的旧功能后，只有当旧的函数返回非 &lt;code&gt;nil&lt;/code&gt; 。这两个函数接收相同的参数，并且合成的返回值是 &lt;var&gt;function&lt;/var&gt; 的返回值。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="11b9ee6402d0942f809e7bacb34c109edce11c8a" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">调用 &lt;var&gt;function&lt;/var&gt; 的旧功能后。这两个函数接收相同的参数，并且合成的返回值是旧函数的返回值。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="dd45f95fef4e571698af292b7cdd92bffd8265e2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and don&amp;rsquo;t call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">在旧 &lt;var&gt;function&lt;/var&gt; 之前调用函数，并且如果 &lt;var&gt;function&lt;/var&gt; 返回 &lt;code&gt;nil&lt;/code&gt; ，则不要调用旧函数。这两个函数接收相同的参数，并且合成的返回值是旧函数的返回值。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="e177089f3e47a75e445f46873115fbe430078933" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function and only call the old function if &lt;var&gt;function&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">在旧 &lt;var&gt;function&lt;/var&gt; 之前调用函数，并且仅在 &lt;var&gt;function&lt;/var&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 时才调用旧函数。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="5a61495f3b296416244dbb85cc0933049276d9d5" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">调用 &lt;var&gt;function&lt;/var&gt; 的旧功能之前。这两个函数接收相同的参数，并且合成的返回值是旧函数的返回值。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="f4cc04f8d665904345400ebc070afe6901974fc2" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">首先调用 &lt;var&gt;function&lt;/var&gt; ，并将结果（应该是列表）用作新参数传递给旧函数。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="e77c6828a07ec693781d6efe3e57ff1a5a36a8c0" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for characters in &lt;var&gt;charset&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments. The first one is a cons cell &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; .  &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; indicate a range of characters contained in charset. The second argument passed to &lt;var&gt;function&lt;/var&gt; is &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">字符 &lt;var&gt;charset&lt;/var&gt; 调用 &lt;var&gt;function&lt;/var&gt; 。 &lt;var&gt;function&lt;/var&gt; 有两个参数。第一个是一个缺点细胞 &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;from&lt;/var&gt; 。 &lt;var&gt;to&lt;/var&gt; ），其中 &lt;var&gt;from&lt;/var&gt; 和 &lt;var&gt;to&lt;/var&gt; 指示包含在字符集字符的范围。传递给 &lt;var&gt;function&lt;/var&gt; 的第二个参数是 &lt;var&gt;arg&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="fae0114c2201a949abeef4209c12323f1f0e324b" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; for every piece of advice that was added to the named function &lt;var&gt;symbol&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">为添加到命名函数 &lt;var&gt;symbol&lt;/var&gt; 每条建议调用 &lt;var&gt;function&lt;/var&gt; 。 &lt;var&gt;function&lt;/var&gt; 使用两个参数调用：通知函数及其属性。</target>
        </trans-unit>
        <trans-unit id="567ee80f88e9b6fcfc133e840199c180bb8db2d1" translate="yes" xml:space="preserve">
          <source>Call &lt;var&gt;function&lt;/var&gt; instead of the old function, but provide the old function as an extra argument to &lt;var&gt;function&lt;/var&gt;. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">通话 &lt;var&gt;function&lt;/var&gt; ，而不是旧的功能，但提供旧功能作为额外参数 &lt;var&gt;function&lt;/var&gt; 。这是最灵活的组成。例如，它允许您使用不同的参数或多次或在let绑定中调用旧函数，或者有时可以将工作委派给旧函数，有时可以完全覆盖它。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="d1a7d71503696cf38410fc1322aa1095b06486f0" translate="yes" xml:space="preserve">
          <source>Call the anonymous function with one argument, &lt;var&gt;expval&lt;/var&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">使用一个参数 &lt;var&gt;expval&lt;/var&gt; 调用匿名函数（请参阅&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7476fa450c9cf57b9d41330c2668e502b573753f" translate="yes" xml:space="preserve">
          <source>Call the function (the first element of the function call) with &lt;var&gt;n&lt;/var&gt; arguments (the other elements) and an additional &lt;var&gt;n&lt;/var&gt;+1-th argument that is &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">用 &lt;var&gt;n&lt;/var&gt; 个参数（其他元素）和另一个 &lt;var&gt;n&lt;/var&gt; + 1个参数 &lt;var&gt;expval&lt;/var&gt; 调用函数（函数调用的第一个元素）。</target>
        </trans-unit>
        <trans-unit id="cce8159a07f7ca94dd3aede2fb066a149472cac4" translate="yes" xml:space="preserve">
          <source>Call the function &lt;var&gt;f&lt;/var&gt; for every piece of advice that was added to &lt;var&gt;function-def&lt;/var&gt;. &lt;var&gt;f&lt;/var&gt; is called with two arguments: the advice function and its properties.</source>
          <target state="translated">为添加到 &lt;var&gt;function-def&lt;/var&gt; 的每条建议调用函数 &lt;var&gt;f&lt;/var&gt; 。 &lt;var&gt;f&lt;/var&gt; 由两个参数调用：通知函数及其属性。</target>
        </trans-unit>
        <trans-unit id="f7bee42ac2cfe40e42c5b3d7a4488a39eab8279c" translate="yes" xml:space="preserve">
          <source>Call the named function with one argument, &lt;var&gt;expval&lt;/var&gt;.</source>
          <target state="translated">使用一个参数 &lt;var&gt;expval&lt;/var&gt; 调用命名函数。</target>
        </trans-unit>
        <trans-unit id="c5bef85c072afa5ae3f80c86a71f855f8cba1aac" translate="yes" xml:space="preserve">
          <source>Call the old function first and pass the result to &lt;var&gt;function&lt;/var&gt;. More specifically, the composition of the two functions behaves like:</source>
          <target state="translated">首先调用旧函数，然后将结果传递给 &lt;var&gt;function&lt;/var&gt; 。更具体地说，这两个函数的组成类似于：</target>
        </trans-unit>
        <trans-unit id="6afd776be5db841a6dc68b637bb932e7dfca56a9" translate="yes" xml:space="preserve">
          <source>Call this command after using &lt;code&gt;smie-config-guess&lt;/code&gt;, to save your settings for future sessions.</source>
          <target state="translated">使用 &lt;code&gt;smie-config-guess&lt;/code&gt; 之后，调用此命令以保存您的设置以供将来的会话使用。</target>
        </trans-unit>
        <trans-unit id="8506342e0260dd8016e03d646af20a2c9018a199" translate="yes" xml:space="preserve">
          <source>Call this function instead of using a literal value (usually, zero) of the column number for indenting top-level program constructs. The function&amp;rsquo;s value is the column number to use for top-level constructs. When no superior mode is in effect, this function returns zero.</source>
          <target state="translated">调用此函数，而不是使用列号的文字值（通常为零）来缩进顶级程序结构。该函数的值是用于顶级构造的列号。当没有高级模式生效时，此函数将返回零。</target>
        </trans-unit>
        <trans-unit id="98d6a6a2c4f2e6e0e83bdfbcc0730217802507ab" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;concat&lt;/code&gt; converts the list to a string so you can see its contents more clearly.</source>
          <target state="translated">调用 &lt;code&gt;concat&lt;/code&gt; 会将列表转换为字符串，以便您可以更清楚地看到其内容。</target>
        </trans-unit>
        <trans-unit id="aa38eb2554dbe5c7a33e4b709e55fe4dded0e886" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;smie-setup&lt;/code&gt; is also sufficient to make</source>
          <target state="translated">调用 &lt;code&gt;smie-setup&lt;/code&gt; 也足以使</target>
        </trans-unit>
        <trans-unit id="511ba4c0240efeaabfee01e6c6a8c90f51297283" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;substitute-in-file-name&lt;/code&gt; on output produced by &lt;code&gt;substitute-in-file-name&lt;/code&gt; tends to give incorrect results. For instance, use of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;substitute-in-file-name&lt;/code&gt; &lt;code&gt;substitute-in-file-name&lt;/code&gt; 产生的输出上调用文件名替换往往会产生错误的结果。例如，使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9ac3d844132b984a3eb47bf8dcb79e4bbd848878" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;window-preserve-size&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;) will try to keep the size of the argument window unchanged when popping up a new window. You have to make sure that another window in the same combination can be shrunk instead, though.</source>
          <target state="translated">调用 &lt;code&gt;window-preserve-size&lt;/code&gt; （请参见&lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;）将在弹出新窗口时尝试使参数窗口的大小保持不变。但是，您必须确保可以缩小同一组合中的另一个窗口。</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">调用功能</target>
        </trans-unit>
        <trans-unit id="504886a8ce3a7ab2de140289b5cdac7f6b388ff2" translate="yes" xml:space="preserve">
          <source>Calling a command, so that it will read arguments.</source>
          <target state="translated">调用一个命令,这样它就会读取参数。</target>
        </trans-unit>
        <trans-unit id="a961505da75e77209eaa6b59e8f61a3dffb36635" translate="yes" xml:space="preserve">
          <source>Calling the major mode command twice in direct succession should not fail and should do the same thing as calling the command only once. In other words, the major mode command should be idempotent.</source>
          <target state="translated">连续两次直接调用主要模式命令,不应该失败,应该和只调用一次命令做同样的事情。换句话说,主要模式命令应该是幂等的。</target>
        </trans-unit>
        <trans-unit id="1e6c66b20a23a26c0a918b56cec3c86770820c22" translate="yes" xml:space="preserve">
          <source>Calling this function explicitly is useful for splitting the effects of a command into more than one unit. For example, &lt;code&gt;query-replace&lt;/code&gt; calls &lt;code&gt;undo-boundary&lt;/code&gt; after each replacement, so that the user can undo individual replacements one by one.</source>
          <target state="translated">显式调用此函数对于将命令的效果分成多个单元很有用。例如，每次替换后 &lt;code&gt;query-replace&lt;/code&gt; 调用 &lt;code&gt;undo-boundary&lt;/code&gt; ，以便用户可以逐个撤消单个替换。</target>
        </trans-unit>
        <trans-unit id="8a5bda3d28236066116676706c47de1d0f0328a6" translate="yes" xml:space="preserve">
          <source>Calling this function is sufficient to make commands such as &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;backward-sexp&lt;/code&gt;, and &lt;code&gt;transpose-sexps&lt;/code&gt; be able to properly handle structural elements other than just the paired parentheses already handled by syntax tables. For example, if the provided grammar is precise enough, &lt;code&gt;transpose-sexps&lt;/code&gt; can correctly transpose the two arguments of a &lt;code&gt;+&lt;/code&gt; operator, taking into account the precedence rules of the language.</source>
          <target state="translated">调用此函数足以使诸如 &lt;code&gt;forward-sexp&lt;/code&gt; ， &lt;code&gt;backward-sexp&lt;/code&gt; 和 &lt;code&gt;transpose-sexps&lt;/code&gt; 之类的命令能够正确处理结构元素，而不仅仅是语法表已经处理过的成对括号。例如，如果所提供的语法足够精确，那么考虑到语言的优先级规则， &lt;code&gt;transpose-sexps&lt;/code&gt; 可以正确地转换 &lt;code&gt;+&lt;/code&gt; 运算符的两个参数。</target>
        </trans-unit>
        <trans-unit id="e5b34fd5a2e36cd4eafb9c4fcecc3d11f251e2e3" translate="yes" xml:space="preserve">
          <source>Cannot determine image type</source>
          <target state="translated">无法确定图像类型</target>
        </trans-unit>
        <trans-unit id="c1186dd76154d57de923217a8dd3d16441be124a" translate="yes" xml:space="preserve">
          <source>Cannot open load file &lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">无法打开加载文件文件 &lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">捕获组</target>
        </trans-unit>
        <trans-unit id="5fe52af8b2d198c370691f5d3a5caec003b55dcc" translate="yes" xml:space="preserve">
          <source>Case Changes</source>
          <target state="translated">案件变化</target>
        </trans-unit>
        <trans-unit id="ff5641735ee7c07e5eed18f7107abe940e61dcc3" translate="yes" xml:space="preserve">
          <source>Case Conversion in Lisp</source>
          <target state="translated">Lisp中的大小写转换</target>
        </trans-unit>
        <trans-unit id="ee05e5edf5d51051d5e8ea58e5fb1140b748c002" translate="yes" xml:space="preserve">
          <source>Case conversion functions.</source>
          <target state="translated">案件转换功能。</target>
        </trans-unit>
        <trans-unit id="4fc7e1d52f22796c47c268de900d6e7082017f5a" translate="yes" xml:space="preserve">
          <source>Case conversion of parts of the buffer.</source>
          <target state="translated">缓冲区部分的案例转换。</target>
        </trans-unit>
        <trans-unit id="60f886006f4b5be396aef39220ae04232401704b" translate="yes" xml:space="preserve">
          <source>Case tables (see &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;).</source>
          <target state="translated">案例表（请参阅&lt;a href=&quot;case-tables#Case-Tables&quot;&gt;案例表&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="760a611d6b77c0b6b7da5b461fa97629808e415a" translate="yes" xml:space="preserve">
          <source>Case-independent or case-significant searching.</source>
          <target state="translated">与案件无关或有案件意义的检索。</target>
        </trans-unit>
        <trans-unit id="6ccb60071be8f00760a3824d9f7d0fad57de789f" translate="yes" xml:space="preserve">
          <source>Categories</source>
          <target state="translated">Categories</target>
        </trans-unit>
        <trans-unit id="c62bb44b2dbb1eab36c5fe60b6989181f7595720" translate="yes" xml:space="preserve">
          <source>Category character</source>
          <target state="translated">类别字符</target>
        </trans-unit>
        <trans-unit id="ed3dc45ada47ab5b03a62a82e4fe63e2c08a4aa5" translate="yes" xml:space="preserve">
          <source>Category name</source>
          <target state="translated">类别名称</target>
        </trans-unit>
        <trans-unit id="21ee11841e5216e7932316a3ba9dbe3bf176d378" translate="yes" xml:space="preserve">
          <source>Causes the server to suppress playing any sounds, if it has that ability.</source>
          <target state="translated">导致服务器抑制播放任何声音,如果它有这个能力。</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="983a41bf08948cb10ca36f96d754fedb2fa51108" translate="yes" xml:space="preserve">
          <source>Caveats for &lt;var&gt;symbol&lt;/var&gt; in Sequencing Patterns</source>
          <target state="translated">测序模式中 &lt;var&gt;symbol&lt;/var&gt; 注意事项</target>
        </trans-unit>
        <trans-unit id="10c846191e34dad7942410f081d90ef9a60dccb4" translate="yes" xml:space="preserve">
          <source>Certain &lt;em&gt;special events&lt;/em&gt; are handled at a very low level&amp;mdash;as soon as they are read. The &lt;code&gt;read-event&lt;/code&gt; function processes these events itself, and never returns them. Instead, it keeps waiting for the first event that is not special and returns that one.</source>
          <target state="translated">某些&lt;em&gt;特殊事件&lt;/em&gt;一经读取就以非常低的级别处理。在 &lt;code&gt;read-event&lt;/code&gt; 函数处理这些事件本身，并不会返回它们。而是继续等待不特殊的第一个事件并返回该事件。</target>
        </trans-unit>
        <trans-unit id="2668c38616b8f82385530ab10556316664076de7" translate="yes" xml:space="preserve">
          <source>Certain abbrevs, called &lt;em&gt;system abbrevs&lt;/em&gt;, are defined by a major mode instead of the user. A system abbrev is identified by its non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;:system&lt;/code&gt; property (see &lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;). When abbrevs are saved to an abbrev file, system abbrevs are omitted. See &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev Files&lt;/a&gt;.</source>
          <target state="translated">某些缩写，称为&lt;em&gt;系统缩写&lt;/em&gt;，由主要模式而不是用户定义。系统缩写由其 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;:system&lt;/code&gt; 属性标识（请参见&lt;a href=&quot;abbrev-properties#Abbrev-Properties&quot;&gt;Abbrev Properties&lt;/a&gt;）。将缩写保存到缩写文件时，将省略系统缩写。请参阅&lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb70bbca935cc9ba0d3270144cb857746601caf3" translate="yes" xml:space="preserve">
          <source>Certain format specifications require values of particular types. If you supply a value that doesn&amp;rsquo;t fit the requirements, an error is signaled.</source>
          <target state="translated">某些格式规范需要特定类型的值。如果您提供的值不符合要求，则会提示错误。</target>
        </trans-unit>
        <trans-unit id="17f9520304f622d054d6e6a095bc91eb04688136" translate="yes" xml:space="preserve">
          <source>Certain function-like objects, called &lt;em&gt;special forms&lt;/em&gt; and &lt;em&gt;macros&lt;/em&gt;, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.</source>
          <target state="translated">某些类似于函数的对象（称为&lt;em&gt;特殊形式&lt;/em&gt;和&lt;em&gt;宏&lt;/em&gt;）也接受参数来执行计算。但是，如下所述，这些在Emacs Lisp中不视为功能。</target>
        </trans-unit>
        <trans-unit id="a3317a453486426103c83a8405cdf6293656cb02" translate="yes" xml:space="preserve">
          <source>Certain functions such as &lt;code&gt;read-key-sequence&lt;/code&gt; or &lt;code&gt;read-quoted-char&lt;/code&gt; prevent quitting entirely even though they wait for input. Instead of quitting,</source>
          <target state="translated">某些功能（例如， &lt;code&gt;read-key-sequence&lt;/code&gt; 或 &lt;code&gt;read-quoted-char&lt;/code&gt; 即使在等待输入时也无法完全退出。与其放弃，</target>
        </trans-unit>
        <trans-unit id="9781a84dc281e4b3ac7e8fb884e18e00f10c91d8" translate="yes" xml:space="preserve">
          <source>Certain other values of &lt;var&gt;separator-type&lt;/var&gt; specify a different style of separator. Here is a table of them:</source>
          <target state="translated">&lt;var&gt;separator-type&lt;/var&gt; 某些其他值指定了不同的分隔符样式。这是它们的表：</target>
        </trans-unit>
        <trans-unit id="b28516fbcb8e500a178b2a631de8639fdef46b0f" translate="yes" xml:space="preserve">
          <source>Certain text properties are meaningful in the mode line. The &lt;code&gt;face&lt;/code&gt; property affects the appearance of text; the &lt;code&gt;help-echo&lt;/code&gt; property associates help strings with the text, and &lt;code&gt;keymap&lt;/code&gt; can make the text mouse-sensitive.</source>
          <target state="translated">某些文本属性在模式行中有意义。该 &lt;code&gt;face&lt;/code&gt; 属性影响文字的外观;在 &lt;code&gt;help-echo&lt;/code&gt; 性质将帮助字符串与文本和 &lt;code&gt;keymap&lt;/code&gt; 可以使文字鼠标敏感。</target>
        </trans-unit>
        <trans-unit id="78b3210742dadf1e3c0eabba8c8ed5204a166dda" translate="yes" xml:space="preserve">
          <source>Change Hooks</source>
          <target state="translated">更换钩子</target>
        </trans-unit>
        <trans-unit id="b474b780b926dcbfa75d96cb86ad31c3233c390b" translate="yes" xml:space="preserve">
          <source>Change the font-related attributes of &lt;var&gt;face&lt;/var&gt; to those of &lt;var&gt;font&lt;/var&gt; (a string or a font object). See &lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute&lt;/a&gt;, for the supported formats of the &lt;var&gt;font&lt;/var&gt; argument. This function sets the attribute &lt;code&gt;:font&lt;/code&gt; of the face, and indirectly also the &lt;code&gt;:family&lt;/code&gt;, &lt;code&gt;:foundry&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt; attributes, as defined by the font. If &lt;var&gt;frame&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only change the attributes on the specified frame.</source>
          <target state="translated">将 &lt;var&gt;face&lt;/var&gt; 的字体相关属性更改为 &lt;var&gt;font&lt;/var&gt; （字符串或字体对象）的属性。有关 &lt;var&gt;font&lt;/var&gt; 参数支持的格式，请参见&lt;a href=&quot;face-attributes#face_002dfont_002dattribute&quot;&gt;face-font-attribute&lt;/a&gt;。此函数设置面部的 &lt;code&gt;:font&lt;/code&gt; 属性，并间接设置字体定义的 &lt;code&gt;:family&lt;/code&gt; ， &lt;code&gt;:foundry&lt;/code&gt; ， &lt;code&gt;:width&lt;/code&gt; ， &lt;code&gt;:height&lt;/code&gt; ， &lt;code&gt;:weight&lt;/code&gt; 和 &lt;code&gt;:slant&lt;/code&gt; 属性。如果 &lt;var&gt;frame&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则仅更改指定框架上的属性。</target>
        </trans-unit>
        <trans-unit id="100a984c74cd76a27c5abd1250aa8a0325533085" translate="yes" xml:space="preserve">
          <source>Changes in process sentinels take effect immediately&amp;mdash;if the sentinel is slated to be run but has not been called yet, and you specify a new sentinel, the eventual call to the sentinel will use the new one.</source>
          <target state="translated">过程标记的更改将立即生效-如果该标记将被运行但尚未被调用，并且您指定了一个新标记，则最终调用该标记将使用新标记。</target>
        </trans-unit>
        <trans-unit id="156524b67d9176e9980be07f37b022c85504061b" translate="yes" xml:space="preserve">
          <source>Changing File Names and Attributes</source>
          <target state="translated">更改文件名和属性</target>
        </trans-unit>
        <trans-unit id="51016b235a030223e05c662ad0783ea8a9b72574" translate="yes" xml:space="preserve">
          <source>Changing Key Bindings</source>
          <target state="translated">更改键绑定</target>
        </trans-unit>
        <trans-unit id="7594cb533c4a496e3f17056c9667959d56338aee" translate="yes" xml:space="preserve">
          <source>Changing Text Properties</source>
          <target state="translated">更改文本属性</target>
        </trans-unit>
        <trans-unit id="de45395bd6cb72dc2da08ba6aae7cf507d1e0f7f" translate="yes" xml:space="preserve">
          <source>Changing any of the &lt;code&gt;scroll-bar-width&lt;/code&gt;, &lt;code&gt;scroll-bar-height&lt;/code&gt;, &lt;code&gt;vertical-scroll-bars&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bars&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt; and &lt;code&gt;right-fringe&lt;/code&gt; frame parameters is handled as if the frame contained just one live window. This means, for example, that removing vertical scroll bars on a frame containing several side by side windows will shrink the outer frame width by the width of one scroll bar provided this option is &lt;code&gt;nil&lt;/code&gt; and keep it unchanged if this option is &lt;code&gt;t&lt;/code&gt; or a list containing &lt;code&gt;vertical-scroll-bars&lt;/code&gt;.</source>
          <target state="translated">更改任何 &lt;code&gt;scroll-bar-width&lt;/code&gt; ， &lt;code&gt;scroll-bar-height&lt;/code&gt; ， &lt;code&gt;vertical-scroll-bars&lt;/code&gt; ， &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; ， &lt;code&gt;left-fringe&lt;/code&gt; 和 &lt;code&gt;right-fringe&lt;/code&gt; 框架参数都如同处理该框架仅包含一个活动窗口一样。例如，这意味着，如果删除包含多个并排窗口的框架上的垂直滚动条，则将外部框架的宽度缩小一个滚动条的宽度，前提是此选项为 &lt;code&gt;nil&lt;/code&gt; ，如果此选项为 &lt;code&gt;t&lt;/code&gt; 或列表，则使其保持不变包含 &lt;code&gt;vertical-scroll-bars&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd7f426a8c11556d236e6fe7c9beb52aa001a64a" translate="yes" xml:space="preserve">
          <source>Changing point.</source>
          <target state="translated">换点。</target>
        </trans-unit>
        <trans-unit id="35bbf3ed9b965bfacb89f9f800e62d4fe12c4c01" translate="yes" xml:space="preserve">
          <source>Changing the &lt;small&gt;CAR&lt;/small&gt; of a cons cell is done with &lt;code&gt;setcar&lt;/code&gt;. When used on a list, &lt;code&gt;setcar&lt;/code&gt; replaces one element of a list with a different element.</source>
          <target state="translated">更改cons单元格的&lt;small&gt;CAR&lt;/small&gt;是使用 &lt;code&gt;setcar&lt;/code&gt; 完成的。当在列表上使用时， &lt;code&gt;setcar&lt;/code&gt; 用另一个元素替换列表中的一个元素。</target>
        </trans-unit>
        <trans-unit id="562e2b4207b6c404cf6c751160157bd49ac95781" translate="yes" xml:space="preserve">
          <source>Changing the sizes of windows.</source>
          <target state="translated">改变窗户的大小。</target>
        </trans-unit>
        <trans-unit id="6a1f8e8787fc1acb606cc50f5b6e9d8f7bdd458d" translate="yes" xml:space="preserve">
          <source>Changing this variable does not force an update of the mode line.</source>
          <target state="translated">改变这个变量不会强制更新模式行。</target>
        </trans-unit>
        <trans-unit id="f0c739408abd052ee5d44db4e8e0adc91f0b680a" translate="yes" xml:space="preserve">
          <source>Char-Table Type</source>
          <target state="translated">图表类型</target>
        </trans-unit>
        <trans-unit id="ce090131f8a640a66d14740f37efd79c98da2f52" translate="yes" xml:space="preserve">
          <source>Char-Tables</source>
          <target state="translated">Char-Tables</target>
        </trans-unit>
        <trans-unit id="89a0d26064c88761be4481b9b52065531e5e024c" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">角色类</target>
        </trans-unit>
        <trans-unit id="8cd166d7b5c972d19c78d965c26afe0d852a6bbc" translate="yes" xml:space="preserve">
          <source>Character Codes</source>
          <target state="translated">字符代码</target>
        </trans-unit>
        <trans-unit id="198408dd9120e5714424c5f00fa2e02c78a9427b" translate="yes" xml:space="preserve">
          <source>Character Display</source>
          <target state="translated">字符显示</target>
        </trans-unit>
        <trans-unit id="b1c5fa0155ae3ab9ad380fa3cfc349d0a0ec23e9" translate="yes" xml:space="preserve">
          <source>Character Properties</source>
          <target state="translated">字符属性</target>
        </trans-unit>
        <trans-unit id="0e7c11d7a7200a36005057b0e953e12aae6033f0" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
          <target state="translated">字符集</target>
        </trans-unit>
        <trans-unit id="275450cc1e4926b0829cc65cd3f2b3d835f4e048" translate="yes" xml:space="preserve">
          <source>Character Type</source>
          <target state="translated">字符类型</target>
        </trans-unit>
        <trans-unit id="ea8d87953a98f75b2aa021b7b8cb876f766bf6b9" translate="yes" xml:space="preserve">
          <source>Character attributes that define their behavior and handling.</source>
          <target state="translated">角色属性,定义其行为和处理方式。</target>
        </trans-unit>
        <trans-unit id="5978dbfeccf01151025eeaa59ed56b27e00fec9f" translate="yes" xml:space="preserve">
          <source>Character category tables (see &lt;a href=&quot;categories#Categories&quot;&gt;Categories&lt;/a&gt;).</source>
          <target state="translated">字符类别表（请参阅&lt;a href=&quot;categories#Categories&quot;&gt;分类&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9755699503a79e3114d0435a6c41d83696a2d623" translate="yes" xml:space="preserve">
          <source>Character classes used in regular expressions.</source>
          <target state="translated">正则表达式中使用的字符类。</target>
        </trans-unit>
        <trans-unit id="1d5a2032f34ffea795feb6720457cf5de1c95dbd" translate="yes" xml:space="preserve">
          <source>Character quotes: &amp;lsquo;</source>
          <target state="translated">字符引号：'</target>
        </trans-unit>
        <trans-unit id="d4eeaab110722d926fe33c40dc614e75f6d0aef8" translate="yes" xml:space="preserve">
          <source>Characteristics of arrays in Emacs Lisp.</source>
          <target state="translated">Emacs Lisp中数组的特性。</target>
        </trans-unit>
        <trans-unit id="7295605dcc69f48d0631634d8294614f5cae238b" translate="yes" xml:space="preserve">
          <source>Characters for which there is no suitable font, or which cannot be encoded by the terminal&amp;rsquo;s coding system.</source>
          <target state="translated">没有合适字体的字符，或无法由终端的编码系统编码的字符。</target>
        </trans-unit>
        <trans-unit id="f395a989f7613a08007721455bd0e01ef846f3c5" translate="yes" xml:space="preserve">
          <source>Characters in strings and buffers are currently limited to the range of 0 to 4194303&amp;mdash;twenty two bits (see &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;). Codes 0 through 127 are</source>
          <target state="translated">当前，字符串和缓冲区中的字符限制在0到4194303的范围内-22位（请参阅&lt;a href=&quot;character-codes#Character-Codes&quot;&gt;字符代码&lt;/a&gt;）。代码0到127是</target>
        </trans-unit>
        <trans-unit id="2f2d8febd021625a726bddcf901f92bcf114c32e" translate="yes" xml:space="preserve">
          <source>Characters in this class count as part of words if &lt;code&gt;words-include-escapes&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;word-motion#Word-Motion&quot;&gt;Word Motion&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;words-include-escapes&lt;/code&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则此类中的字符将作为单词的一部分。请参阅&lt;a href=&quot;word-motion#Word-Motion&quot;&gt;文字运动&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a10df5b911a93e079b9555a76636c96ac49a9a5" translate="yes" xml:space="preserve">
          <source>Characters of Unicode General Category [Cf], such as U+200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;, but excluding characters that have graphic images, such as U+00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt;.</source>
          <target state="translated">Unicode通用类别[Cf]的字符，例如U + 200E &lt;small&gt;LEFT-TO-RIGHT MARK&lt;/small&gt;，但不包括具有图形图像的字符，例如U + 00AD &lt;small&gt;SOFT HYPHEN&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="d64597528b4665933dfaeebfdafad56f74f0e55b" translate="yes" xml:space="preserve">
          <source>Characters that have the property &lt;code&gt;inhibit-read-only&lt;/code&gt; can be edited even in read-only buffers. See &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;.</source>
          <target state="translated">即使在只读缓冲区中，也可以编辑具有 &lt;code&gt;inhibit-read-only&lt;/code&gt; 属性的字符。请参阅&lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;只读缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e63d767e9c8b2c1671e34752b2089312848063bf" translate="yes" xml:space="preserve">
          <source>Characters that separate symbols and words from each other. Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one. Space, tab, and formfeed are classified as whitespace in almost all major modes.</source>
          <target state="translated">将符号和单词相互分开的字符。通常情况下,空白字符没有其他语法意义,多个空白字符在语法上等同于一个空白字符。在几乎所有的主要模式中,空格、tab和formfeed都被归为whitespace。</target>
        </trans-unit>
        <trans-unit id="fa30e64c5637f1d5a32a9a352ecb5ba52a350acf" translate="yes" xml:space="preserve">
          <source>Characters that start an escape sequence, such as is used in string and character constants. The character &amp;lsquo;</source>
          <target state="translated">开始转义序列的字符，例如在字符串和字符常量中使用的字符。人物 '</target>
        </trans-unit>
        <trans-unit id="c81c548b4c8ec05d54666a049f54eb670318ccea" translate="yes" xml:space="preserve">
          <source>Characters that start or end a special kind of comment. &lt;em&gt;Any&lt;/em&gt; generic comment delimiter matches &lt;em&gt;any&lt;/em&gt; generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other.</source>
          <target state="translated">以特殊注释开头或结尾的字符。&lt;em&gt;任何&lt;/em&gt;通用注释定界符都与&lt;em&gt;任何&lt;/em&gt;通用注释定界符匹配，但不能与注释起始符或注释提供者匹配；通用注释定界符只能相互匹配。</target>
        </trans-unit>
        <trans-unit id="ac7296c49b8b1a6c9dc8eb94911bbbba5328c176" translate="yes" xml:space="preserve">
          <source>Characters that start or end a string. This class differs from the string quote class in that &lt;em&gt;any&lt;/em&gt; generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters.</source>
          <target state="translated">以字符串开头或结尾的字符。该类与字符串引用类的不同之处在于，&lt;em&gt;任何&lt;/em&gt;通用字符串定界符都可以与任何其他通用字符串定界符匹配。但它们与普通的字符串引号字符不匹配。</target>
        </trans-unit>
        <trans-unit id="878c9eb0cca3656e2070d507e9c66472d4b16d58" translate="yes" xml:space="preserve">
          <source>Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another. Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses. Other programming language modes, such as C mode, use punctuation syntax for operators.</source>
          <target state="translated">在人类语言中用作标点符号的字符,或在编程语言中用来分隔符号与符号之间的字符。有些编程语言模式,如Emacs Lisp模式,没有这一类的字符,因为少数不是符号或单词成分的字符都有其他用途。其他的编程语言模式,如C模式,则使用标点符号语法作为运算符。</target>
        </trans-unit>
        <trans-unit id="06f7786b4e99ee5ceb3cb305cfc63a98ff812c14" translate="yes" xml:space="preserve">
          <source>Characters used for syntactic operators that are considered as part of an expression if they appear next to one. In Lisp modes, these characters include the apostrophe, &amp;lsquo;</source>
          <target state="translated">用于句法运算符的字符，如果出现在一个字符旁边，则被视为表达式的一部分。在Lisp模式下，这些字符包括撇号'</target>
        </trans-unit>
        <trans-unit id="b0de87a3961de259dc33f8a42911d09393a940b8" translate="yes" xml:space="preserve">
          <source>Characters used in dissimilar pairs to surround sentences or expressions. Such a grouping is begun with an open parenthesis character and terminated with a close. Each open parenthesis character matches a particular close parenthesis character, and vice versa. Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis. See &lt;a href=&quot;blinking#Blinking&quot;&gt;Blinking&lt;/a&gt;.</source>
          <target state="translated">成对使用的字符围绕句子或表达。这样的分组以圆括号开头开始，以结尾结束。每个开括号字符都与特定的闭括号字符匹配，反之亦然。通常，当您插入一个封闭的括号时，Emacs会立即指示匹配的开放括号。请参阅&lt;a href=&quot;blinking#Blinking&quot;&gt;闪烁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4150dd70fbcba800bf39a3d8687d1d7aeb5b8bb0" translate="yes" xml:space="preserve">
          <source>Characters used in various languages to delimit comments. Human text has no comment characters. In Lisp, the semicolon (&amp;lsquo;</source>
          <target state="translated">各种语言中用来分隔注释的字符。人工文本没有注释字符。在Lisp中，分号（'</target>
        </trans-unit>
        <trans-unit id="48fc8012fa06ff8528f92e294cf2c321f8c94197" translate="yes" xml:space="preserve">
          <source>Characters used to delimit string constants. The same string quote character appears at the beginning and the end of a string. Such quoted strings do not nest.</source>
          <target state="translated">用于分隔字符串常量的字符。同一字符串引号字符出现在一个字符串的开头和结尾。这种引号字符串不会嵌套。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
