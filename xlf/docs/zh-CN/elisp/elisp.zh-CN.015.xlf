<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="7d5d7ee8f609d032732725e8d3c8c089bc52554d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;push-mark&lt;/code&gt; normally &lt;em&gt;does not&lt;/em&gt; activate the mark. To do that, specify &lt;code&gt;t&lt;/code&gt; for the argument &lt;var&gt;activate&lt;/var&gt;.</source>
          <target state="translated">功能 &lt;code&gt;push-mark&lt;/code&gt; 通常&lt;em&gt;不会&lt;/em&gt;激活该标记。为此，请为参数 &lt;var&gt;activate&lt;/var&gt; 指定 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9fa560f2451740cc751b4488378f30d7e73bffc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; also transforms some mouse events. It converts unbound drag events into click events, and discards unbound button-down events entirely. It also reshuffles focus events and miscellaneous window events so that they never appear in a key sequence with any other events.</source>
          <target state="translated">该函数 &lt;code&gt;read-key-sequence&lt;/code&gt; 也转变了一些鼠标事件。它将未绑定的拖动事件转换为单击事件，并完全丢弃未绑定的按下按钮事件。它还会重新调整焦点事件和其他窗口事件，以使它们永远不会与任何其他事件一起出现在按键序列中。</target>
        </trans-unit>
        <trans-unit id="411c4d145671b4036ab4f7cb6fa9e30b7580ebe1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; ignores any button-down events that don&amp;rsquo;t have command bindings; therefore, the Emacs command loop ignores them too. This means that you need not worry about defining button-down events unless you want them to do something. The usual reason to define a button-down event is so that you can track mouse motion (by reading motion events) until the button is released. See &lt;a href=&quot;motion-events#Motion-Events&quot;&gt;Motion Events&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;read-key-sequence&lt;/code&gt; 会忽略所有没有命令绑定的按钮按下事件。因此，Emacs命令循环也将其忽略。这意味着您不必担心定义按钮按下事件，除非您希望它们做一些事情。定义按钮按下事件的通常原因是，您可以跟踪鼠标运动（通过读取运动事件），直到释放按钮为止。请参阅&lt;a href=&quot;motion-events#Motion-Events&quot;&gt;运动事件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eba65b635c04edcaac2d00aa8b06564194485459" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-key-sequence&lt;/code&gt; suppresses quitting:</source>
          <target state="translated">函数 &lt;code&gt;read-key-sequence&lt;/code&gt; 禁止退出：</target>
        </trans-unit>
        <trans-unit id="56cd8086393902fb3f2fd966bb33828c275959f0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;read-regexp&lt;/code&gt; may use the value of this variable to determine its list of default regular expressions. If non-&lt;code&gt;nil&lt;/code&gt;, the value of this variable should be either:</source>
          <target state="translated">函数 &lt;code&gt;read-regexp&lt;/code&gt; 可以使用此变量的值来确定其默认正则表达式列表。如果为非 &lt;code&gt;nil&lt;/code&gt; ，则此变量的值应为：</target>
        </trans-unit>
        <trans-unit id="bfc9d89212eee790f8bef26e1a7f3b5f75f045d1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;redraw-frame&lt;/code&gt; clears and redisplays the entire contents of a given frame (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;). This is useful if the screen is corrupted.</source>
          <target state="translated">函数 &lt;code&gt;redraw-frame&lt;/code&gt; 清除并重新显示给定框架的全部内容（请参阅&lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;）。如果屏幕损坏，这很有用。</target>
        </trans-unit>
        <trans-unit id="bbfc0c7e3b7ab2136aac8aac4311c80559dc8786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-at-time&lt;/code&gt; returns a timer value that identifies the particular scheduled future action. You can use this value to call &lt;code&gt;cancel-timer&lt;/code&gt; (see below).</source>
          <target state="translated">函数 &lt;code&gt;run-at-time&lt;/code&gt; 返回一个计时器值，该值标识特定的计划的将来操作。您可以使用此值来调用 &lt;code&gt;cancel-timer&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="ebf16908ab8cdf77cbe0ed4cf8fac00f9d1be78c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;run-with-idle-timer&lt;/code&gt; returns a timer value which you can use in calling &lt;code&gt;cancel-timer&lt;/code&gt; (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;run-with-idle-timer&lt;/code&gt; 函数返回一个计时器值，您可以在调用 &lt;code&gt;cancel-timer&lt;/code&gt; 时使用它（请参见&lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c8d58a42db5f4f64609112ba848f62aa4f6033e5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;signal&lt;/code&gt; never returns.</source>
          <target state="translated">功能 &lt;code&gt;signal&lt;/code&gt; 永不返回。</target>
        </trans-unit>
        <trans-unit id="e957fc96b50a902c38bbd9080cce211dda054fa5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to create the new window outside of the atomic window.</source>
          <target state="translated">&lt;code&gt;split-window&lt;/code&gt; 功能（请参阅&lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;拆分窗口&lt;/a&gt;）在应用于原子窗口的组成部分时，将尝试在原子窗口之外创建新窗口。</target>
        </trans-unit>
        <trans-unit id="6df956fe28921ed43fa43bd2788b8f0492e99c5e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;substitute-key-definition&lt;/code&gt; scans a keymap for keys that have a certain binding and rebinds them with a different binding. Another feature which is cleaner and can often produce the same results is to remap one command into another (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;).</source>
          <target state="translated">函数replace &lt;code&gt;substitute-key-definition&lt;/code&gt; 扫描键映射表以查找具有特定绑定的键，然后将其重新绑定为其他绑定。另一个更干净的功能（通常可以产生相同的结果）是将一个命令重新映射到另一个命令（请参阅&lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;重新映射命令&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bc471743e21a847c0361cb115c2214f8054e6289" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; is also the place to define any C variables that are to be visible as Lisp variables. &lt;code&gt;DEFVAR_LISP&lt;/code&gt; makes a C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt; visible in Lisp. &lt;code&gt;DEFVAR_INT&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is always an integer. &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; makes a C variable of type &lt;code&gt;int&lt;/code&gt; visible in Lisp with a value that is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. Note that variables defined with &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; are automatically added to the list &lt;code&gt;byte-boolean-vars&lt;/code&gt; used by the byte compiler.</source>
          <target state="translated">函数 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; 也是定义任何可见为Lisp变量的C变量的地方。 &lt;code&gt;DEFVAR_LISP&lt;/code&gt; 在Lisp &lt;code&gt;Lisp_Object&lt;/code&gt; 类型的C变量可见。 &lt;code&gt;DEFVAR_INT&lt;/code&gt; 使得类型的C变量 &lt;code&gt;int&lt;/code&gt; 在Lisp中可见与总是整数的值。 &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 使在Lisp中可见 &lt;code&gt;int&lt;/code&gt; 类型的C变量，其值为 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。注意，用 &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 定义的变量会自动添加到字节编译器使用的列表 &lt;code&gt;byte-boolean-vars&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3a8cd13dfa2e44b4ddf44780a2531422e59cdecc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;throw&lt;/code&gt; finds the matching &lt;code&gt;catch&lt;/code&gt; based on the first argument: it searches for a &lt;code&gt;catch&lt;/code&gt; whose first argument is &lt;code&gt;eq&lt;/code&gt; to the one specified in the &lt;code&gt;throw&lt;/code&gt;. If there is more than one applicable &lt;code&gt;catch&lt;/code&gt;, the innermost one takes precedence. Thus, in the above example, the &lt;code&gt;throw&lt;/code&gt; specifies &lt;code&gt;foo&lt;/code&gt;, and the &lt;code&gt;catch&lt;/code&gt; in &lt;code&gt;foo-outer&lt;/code&gt; specifies the same symbol, so that &lt;code&gt;catch&lt;/code&gt; is the applicable one (assuming there is no other matching &lt;code&gt;catch&lt;/code&gt; in between).</source>
          <target state="translated">该函数 &lt;code&gt;throw&lt;/code&gt; 找到匹配的 &lt;code&gt;catch&lt;/code&gt; 基础上，第一个参数：它搜索一个 &lt;code&gt;catch&lt;/code&gt; 它的第一个参数是 &lt;code&gt;eq&lt;/code&gt; 在指定的一个 &lt;code&gt;throw&lt;/code&gt; 。如果有多个适用的 &lt;code&gt;catch&lt;/code&gt; ，则最里面的一个优先。因此，在上述例子中， &lt;code&gt;throw&lt;/code&gt; 指定 &lt;code&gt;foo&lt;/code&gt; ，并且 &lt;code&gt;catch&lt;/code&gt; 在 &lt;code&gt;foo-outer&lt;/code&gt; 指定了相同的符号，以使得 &lt;code&gt;catch&lt;/code&gt; 是（假设没有其它的匹配适用的一个 &lt;code&gt;catch&lt;/code&gt; 在它们之间）。</target>
        </trans-unit>
        <trans-unit id="5661573f71139d597425c8fd348b8554cabd492f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;tool-bar-make-keymap&lt;/code&gt;, in turn, derives the actual tool bar map dynamically from the value of the variable &lt;code&gt;tool-bar-map&lt;/code&gt;. Hence, you should normally adjust the default (global) tool bar by changing that map. Some major modes, such as Info mode, completely replace the global tool bar by making &lt;code&gt;tool-bar-map&lt;/code&gt; buffer-local and setting it to a different keymap.</source>
          <target state="translated">反过来，功能 &lt;code&gt;tool-bar-make-keymap&lt;/code&gt; 从变量 &lt;code&gt;tool-bar-map&lt;/code&gt; 的值动态得出实际的工具栏图。因此，通常应通过更改该地图来调整默认（全局）工具栏。一些主要模式（例如信息模式）通过将局部 &lt;code&gt;tool-bar-map&lt;/code&gt; 设置为局部缓冲区并将其设置为其他键映射来完全替换全局工具栏。</target>
        </trans-unit>
        <trans-unit id="05e5fdd0ff72a822c0cc55151d5a6c9edaf5d75c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;view-buffer&lt;/code&gt; does not enable View mode in buffers whose mode-class is special, because such modes usually provide their own View-like bindings.</source>
          <target state="translated">函数 &lt;code&gt;view-buffer&lt;/code&gt; 不会在模式类特殊的缓冲区中启用View模式，因为此类模式通常提供自己的类似于View的绑定。</target>
        </trans-unit>
        <trans-unit id="a049ee6872282215d8c5e6687a889741cbf6e11f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt; converts the data which it writes to the appropriate file formats specified by &lt;code&gt;buffer-file-format&lt;/code&gt; and also calls the functions in the list &lt;code&gt;write-region-annotate-functions&lt;/code&gt;. See &lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;Format Conversion&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;write-region&lt;/code&gt; 将其写入的数据转换为 &lt;code&gt;buffer-file-format&lt;/code&gt; 指定的适当文件格式，还调用列表 &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 中的函数。请参阅&lt;a href=&quot;format-conversion#Format-Conversion&quot;&gt;格式转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2746b27a56c8ff0cc634f6dc15fff67621f22f61" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;write-region&lt;/code&gt;:</source>
          <target state="translated">函数 &lt;code&gt;write-region&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="37f0357f6437343569a44c1bbed9f09179966f30" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-get-resource&lt;/code&gt; retrieves a resource value from the X Window defaults database.</source>
          <target state="translated">函数 &lt;code&gt;x-get-resource&lt;/code&gt; 从X Window默认数据库检索资源值。</target>
        </trans-unit>
        <trans-unit id="fb6053497d7338bd26e25c53f5d17dd9d465fac4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;x-parse-geometry&lt;/code&gt; converts a standard X window geometry string to an alist that you can use as part of the argument to &lt;code&gt;make-frame&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;x-parse-geometry&lt;/code&gt; 将标准的X窗口几何字符串转换为列表，您可以将其用作 &lt;code&gt;make-frame&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="765f4cca514fe5d2dfb2aca5ee2926f744c31bf9" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; provides a simple way to use a timer to avoid waiting too long for an answer. See &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;y-or-n-p-with-timeout&lt;/code&gt; 提供了一种使用计时器的简单方法，可以避免等待太长时间等待答案。请参阅&lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;是或否查询&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df0ab2f26bcca2763cb6e43bfe8851ca6f1b858d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined as an autoload.</source>
          <target state="translated">函数 &lt;var&gt;fun&lt;/var&gt; 被定义为自动加载。</target>
        </trans-unit>
        <trans-unit id="54c8609b51778bf7d45e6af7c3a0089e651dafd8" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was defined.</source>
          <target state="translated">定义了功能 &lt;var&gt;fun&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="1197aefcb8e997f46503d415a6f7bd440fa422e7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;fun&lt;/var&gt; was previously an autoload before this library redefined it as a function. The following element is always &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt;, which represents defining &lt;var&gt;fun&lt;/var&gt; as a function.</source>
          <target state="translated">在该库将函数 &lt;var&gt;fun&lt;/var&gt; 重新定义为函数之前，fun函数以前是自动加载的。以下元素总是 &lt;code&gt;(defun . &lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; ，其代表限定 &lt;var&gt;fun&lt;/var&gt; 为函数。</target>
        </trans-unit>
        <trans-unit id="4a8ed9e0e2bf16ef5d1d934174aa221a2fe5895d" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;hash-fn&lt;/var&gt; should accept one argument, a key, and return an integer that is the hash code of that key. For good results, the function should use the whole range of fixnums for hash codes, including negative fixnums.</source>
          <target state="translated">函数 &lt;var&gt;hash-fn&lt;/var&gt; 应该接受一个参数，一个键，并返回一个整数，该整数是该键的哈希码。为了获得良好的结果，该函数应将整个Fixnum都用于哈希码，包括负的Fixnum。</target>
        </trans-unit>
        <trans-unit id="bceb96a81c6ae7fe6ca85c909a8b34d1e250dcc7" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;restore-buffer-function&lt;/var&gt; will be called with argument list</source>
          <target state="translated">函数 &lt;var&gt;restore-buffer-function&lt;/var&gt; 将与参数列表一起调用</target>
        </trans-unit>
        <trans-unit id="542f7b37d57061c8a923579b6d757e44f707ccd9" translate="yes" xml:space="preserve">
          <source>The function &lt;var&gt;test-fn&lt;/var&gt; should accept two arguments, two keys, and return non-&lt;code&gt;nil&lt;/code&gt; if they are considered the same.</source>
          <target state="translated">函数 &lt;var&gt;test-fn&lt;/var&gt; 应该接受两个参数，两个键，如果认为相同，则返回non- &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0267fd50dfdf570f50991445f5d60831fec0bbb2" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;set-auto-mode&lt;/code&gt; to choose and set a major mode. If this does not specify a mode, the buffer stays in the major mode determined by the default value of &lt;code&gt;major-mode&lt;/code&gt; (see below).</source>
          <target state="translated">该函数调用 &lt;code&gt;set-auto-mode&lt;/code&gt; 来选择和设置主要模式。如果未指定模式，则缓冲区将停留在由主模式默认值确定的 &lt;code&gt;major-mode&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="b1b2ebec7b7f741cc24d28e6e32513259cab8c5e" translate="yes" xml:space="preserve">
          <source>The function cell holds a symbol&amp;rsquo;s function definition. Often, we refer to &amp;ldquo;the function &lt;code&gt;foo&lt;/code&gt;&amp;rdquo; when we really mean the function stored in the function cell of &lt;code&gt;foo&lt;/code&gt;; we make the distinction explicit only when necessary. Typically, the function cell is used to hold a function (see &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;) or a macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). However, it can also be used to hold a symbol (see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;), keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;), keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;), or autoload object (see &lt;a href=&quot;autoloading#Autoloading&quot;&gt;Autoloading&lt;/a&gt;). To get the contents of a symbol&amp;rsquo;s function cell, use the function &lt;code&gt;symbol-function&lt;/code&gt; (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;).</source>
          <target state="translated">功能单元格包含符号的功能定义。通常，当我们真正指的是存储在 &lt;code&gt;foo&lt;/code&gt; 函数单元格中的函数时，我们将其称为&amp;ldquo; &lt;code&gt;foo&lt;/code&gt; 函数&amp;rdquo; 。我们仅在必要时才明确区分。通常，函数单元格用于保存一个函数（请参见&lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;）或一个宏（请参见&lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;）。但是，它也可以用于保存符号（请参见&lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;函数间接性&lt;/a&gt;），键盘宏（请参见&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard宏&lt;/a&gt;），键映射（请参见&lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;）或自动加载对象（请参见&lt;a href=&quot;autoloading#Autoloading&quot;&gt;Autoloading&lt;/a&gt;）。要获取符号功能单元的内容，请使用 &lt;code&gt;symbol-function&lt;/code&gt; （请参见&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;功能单元）。&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="16328c91ba726096f5314f142ff38c105df7239d" translate="yes" xml:space="preserve">
          <source>The function cell or the value cell may be &lt;em&gt;void&lt;/em&gt;, which means that the cell does not reference any object. (This is not the same thing as holding the symbol &lt;code&gt;void&lt;/code&gt;, nor the same as holding the symbol &lt;code&gt;nil&lt;/code&gt;.) Examining a function or value cell that is void results in an error, such as &amp;lsquo;</source>
          <target state="translated">函数单元格或值单元格可能为&lt;em&gt;void&lt;/em&gt;，这意味着该单元格未引用任何对象。（这与将符号保持为 &lt;code&gt;void&lt;/code&gt; 并不相同，也不与将符号 &lt;code&gt;nil&lt;/code&gt; 保持为相同。）检查为空的函数或值单元会导致错误，例如'</target>
        </trans-unit>
        <trans-unit id="77d0d2f3edeb3f16b9066342192972eab714c545" translate="yes" xml:space="preserve">
          <source>The function definition of &lt;var&gt;symbol&lt;/var&gt; is used in place of &lt;var&gt;symbol&lt;/var&gt;. If that too is a symbol, then this process is repeated, any number of times. Ultimately this should lead to an object that is a keymap, a command, or a keyboard macro.</source>
          <target state="translated">使用 &lt;var&gt;symbol&lt;/var&gt; 的功能定义代替 &lt;var&gt;symbol&lt;/var&gt; 。如果那也是一个符号，则此过程将重复任意次。最终，这将导致一个对象，该对象是键盘映射，命令或键盘宏。</target>
        </trans-unit>
        <trans-unit id="70e234ce635436f65ccf5ff5428cbb855d712c68" translate="yes" xml:space="preserve">
          <source>The function is called by &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;), and by Font Lock mode during syntactic fontification (see &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;). It is called with two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, which are the starting and ending positions of the text on which it should act. It is allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on any position before &lt;var&gt;end&lt;/var&gt;. However, it should not call &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt;; so, it is not allowed to call &lt;code&gt;syntax-ppss&lt;/code&gt; on some position and later modify the buffer at an earlier position.</source>
          <target state="translated">&lt;code&gt;syntax-ppss&lt;/code&gt; （请参阅&lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;）和&lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;语法字体化&lt;/a&gt;期间的字体锁定模式（请参见Syntactic Font Lock）调用该函数。它用两个参数 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 调用，这两个参数是文本应在其上作用的开始和结束位置。允许在 &lt;var&gt;end&lt;/var&gt; 之前的任何位置调用 &lt;code&gt;syntax-ppss&lt;/code&gt; 。然而，它不应该调用 &lt;code&gt;syntax-ppss-flush-cache&lt;/code&gt; ;因此，不允许在某个位置调用 &lt;code&gt;syntax-ppss&lt;/code&gt; ，然后再在较早的位置修改缓冲区。</target>
        </trans-unit>
        <trans-unit id="7b365c1ea990ed74fa23e69f3e59bb3fef165d33" translate="yes" xml:space="preserve">
          <source>The function is called with one argument, the parse state at point returned by &lt;code&gt;parse-partial-sexp&lt;/code&gt;, and should return a face. The default value returns &lt;code&gt;font-lock-comment-face&lt;/code&gt; for comments and &lt;code&gt;font-lock-string-face&lt;/code&gt; for strings (see &lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt;).</source>
          <target state="translated">该函数使用一个参数调用，即 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 返回的解析状态，并且应该返回一个面。缺省值返回 &lt;code&gt;font-lock-comment-face&lt;/code&gt; 和 &lt;code&gt;font-lock-string-face&lt;/code&gt; （请参见&lt;a href=&quot;faces-for-font-lock#Faces-for-Font-Lock&quot;&gt;Faces for Font Lock&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9328a25f093f15182803d9023b33252b886864e6" translate="yes" xml:space="preserve">
          <source>The function is called with three arguments, &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;object&lt;/var&gt;, and &lt;var&gt;pos&lt;/var&gt;. The second argument, &lt;var&gt;object&lt;/var&gt;, is either the overlay that had the property (for overlay buttons), or the buffer containing the button (for text property buttons). The other arguments have the same meaning as for the special text property &lt;code&gt;help-echo&lt;/code&gt;.</source>
          <target state="translated">该函数用三个参数 &lt;var&gt;window&lt;/var&gt; ， &lt;var&gt;object&lt;/var&gt; 和 &lt;var&gt;pos&lt;/var&gt; 调用。第二个参数 &lt;var&gt;object&lt;/var&gt; 是具有属性的叠加层（对于叠加按钮），或者是包含按钮的缓冲区（对于文本属性按钮）。其他参数与特殊文本属性 &lt;code&gt;help-echo&lt;/code&gt; 具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="9bcf0f786e7063f34c780ba9d084a745154f7f7f" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments, the severity level and its entry in &lt;code&gt;warning-levels&lt;/code&gt;. It should return a list to use as the entry (this value need not be an actual member of &lt;code&gt;warning-levels&lt;/code&gt;). By constructing this value, the function can change the severity of the warning, or specify different handling for a given severity level.</source>
          <target state="translated">该函数使用两个参数调用，严重性级别及其在 &lt;code&gt;warning-levels&lt;/code&gt; 中的条目。它应该返回一个列表用作条目（此值不必是 &lt;code&gt;warning-levels&lt;/code&gt; 的实际成员）。通过构造此值，该函数可以更改警告的严重性，或针对给定的严重性级别指定不同的处理方式。</target>
        </trans-unit>
        <trans-unit id="a2a2dd9cb6611c3a2fb4ae6ecd12f7c5ac258cb7" translate="yes" xml:space="preserve">
          <source>The function is given three parameters, the standard &lt;var&gt;beg&lt;/var&gt;, &lt;var&gt;end&lt;/var&gt;, and &lt;var&gt;old-len&lt;/var&gt; from &lt;code&gt;after-change-functions&lt;/code&gt; (see &lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;Change Hooks&lt;/a&gt;). It should return either a cons of the beginning and end buffer positions (in that order) of the region to fontify, or &lt;code&gt;nil&lt;/code&gt; (which means choose the region in the standard way). This function needs to preserve point, the match-data, and the current restriction. The region it returns may start or end in the middle of a line.</source>
          <target state="translated">该函数给出三个参数，标准 &lt;var&gt;beg&lt;/var&gt; ， &lt;var&gt;end&lt;/var&gt; ，和 &lt;var&gt;old-len&lt;/var&gt; 从 &lt;code&gt;after-change-functions&lt;/code&gt; （见&lt;a href=&quot;change-hooks#Change-Hooks&quot;&gt;change钩子&lt;/a&gt;）。它应返回要字体化的区域的开始和结束缓冲区位置（按此顺序）的坏处，或者返回 &lt;code&gt;nil&lt;/code&gt; （这意味着以标准方式选择区域）。此功能需要保留点，匹配数据和当前限制。它返回的区域可以在一行的中间开始或结束。</target>
        </trans-unit>
        <trans-unit id="d5d86a312c704be80fff26fc16b50d833ac4546d" translate="yes" xml:space="preserve">
          <source>The function now compares the two candidate prefixes heuristically: if the non-whitespace characters in the line 2 candidate occur in the same order in the line 1 candidate, the function returns the line 2 candidate. Otherwise, it returns the largest initial substring which is common to both candidates (which might be the empty string).</source>
          <target state="translated">现在函数对两个候选前缀进行启发式比较:如果第2行候选中的非空格字符与第1行候选中的顺序相同,则函数返回第2行候选。否则,它将返回两个候选字符共同的最大初始子串(可能是空字符串)。</target>
        </trans-unit>
        <trans-unit id="3010538a15326f7f4a43ca9704f87dc561e6ae88" translate="yes" xml:space="preserve">
          <source>The function now has a list of regular expressions that it passes to &lt;code&gt;read-from-minibuffer&lt;/code&gt; to obtain the user&amp;rsquo;s input. The first element of the list is the default result in case of empty input. All elements of the list are available to the user as the &amp;ldquo;future minibuffer history&amp;rdquo; list (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;future list&lt;/a&gt; in</source>
          <target state="translated">现在，该函数具有一个正则表达式列表，该规则表达式传递给 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 以获取用户的输入。如果输入为空，则列表的第一个元素是默认结果。列表中的所有元素都可以给用户作为&amp;ldquo;未来小缓冲区的历史&amp;rdquo;的文章（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-History.html#Minibuffer-History&quot;&gt;未来的列表&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="d3712f3990384c32b001189f990196c3e25d4f1c" translate="yes" xml:space="preserve">
          <source>The function passed as &lt;code&gt;:request-dispatcher&lt;/code&gt; is responsible for handling the remote endpoint&amp;rsquo;s requests, which expect a reply from the local endpoint (in this case, the program you&amp;rsquo;re building). Inside that function, you may either return locally (a normal return) or non-locally (an error return). A local return value must be a Lisp object that can be serialized as JSON (see &lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;Parsing JSON&lt;/a&gt;). This determines a success response, and the object is forwarded to the server as the JSONRPC &lt;code&gt;result&lt;/code&gt; object. A non-local return, achieved by calling the function &lt;code&gt;jsonrpc-error&lt;/code&gt;, causes an error response to be sent to the server. The details of the accompanying JSONRPC &lt;code&gt;error&lt;/code&gt; are filled out with whatever was passed to &lt;code&gt;jsonrpc-error&lt;/code&gt;. A non-local return triggered by an unexpected error of any other type also causes an error response to be sent (unless you have set &lt;code&gt;debug-on-error&lt;/code&gt;, in which case this calls the Lisp debugger, see &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;).</source>
          <target state="translated">作为 &lt;code&gt;:request-dispatcher&lt;/code&gt; 传递的函数负责处理远程端点的请求，该请求需要本地端点（在这种情况下，您正在构建的程序）的答复。在该函数内部，您可以本地返回（正常返回）或非本地返回（错误返回）。本地返回值必须是可以序列化为JSON的Lisp对象（请参见&lt;a href=&quot;parsing-json#Parsing-JSON&quot;&gt;解析JSON&lt;/a&gt;）。这确定成功响应，并且该对象作为JSONRPC &lt;code&gt;result&lt;/code&gt; 对象转发到服务器。通过调用函数 &lt;code&gt;jsonrpc-error&lt;/code&gt; 实现的非本地返回会导致将错误响应发送到服务器。伴随的JSONRPC &lt;code&gt;error&lt;/code&gt; 的详细信息将通过传递给的内容进行填写 &lt;code&gt;jsonrpc-error&lt;/code&gt; 。由任何其他类型的意外错误触发的非本地返回也会导致发送错误响应（除非您设置了 &lt;code&gt;debug-on-error&lt;/code&gt; ，在这种情况下，这将调用Lisp调试器，请参见&lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7f4f854a3fe920f9dd18f4fb474ba93f955016a3" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;nil&lt;/code&gt; if images of this type are not supported. Otherwise it returns an image descriptor.</source>
          <target state="translated">如果不支持此类图像，则该函数返回 &lt;code&gt;nil&lt;/code&gt; 。否则，它将返回图像描述符。</target>
        </trans-unit>
        <trans-unit id="271e1437bfe3ecbde27422c4523f32b9c7ffd067" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it actually tried to redisplay, and &lt;code&gt;nil&lt;/code&gt; otherwise. A value of &lt;code&gt;t&lt;/code&gt; does not mean that redisplay proceeded to completion; it could have been preempted by newly arriving input.</source>
          <target state="translated">如果它实际上试图重新显示，则该函数返回 &lt;code&gt;t&lt;/code&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; 。 &lt;code&gt;t&lt;/code&gt; 值并不表示重新显示已经完成。它可能已经被新到达的输入抢占了。</target>
        </trans-unit>
        <trans-unit id="a2c86b439365c249c948c8efa2d07fe8ef2ae3a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it succeeds in setting the SELinux context of &lt;var&gt;filename&lt;/var&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if the context was not set (e.g., if SELinux is disabled, or if Emacs was compiled without SELinux support).</source>
          <target state="translated">如果成功设置 &lt;var&gt;filename&lt;/var&gt; 的SELinux上下文，则该函数返回 &lt;code&gt;t&lt;/code&gt; 。如果未设置上下文，则返回 &lt;code&gt;nil&lt;/code&gt; （例如，如果SELinux被禁用，或者Emacs是在没有SELinux支持的情况下编译的）。</target>
        </trans-unit>
        <trans-unit id="8aa3622a93da6a8f83161ce66b0a13088cd542a2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if it successfully sets the ACL of &lt;var&gt;filename&lt;/var&gt;, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功设置了 &lt;var&gt;filename&lt;/var&gt; 的ACL，则该函数返回 &lt;code&gt;t&lt;/code&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4adc69487e5f1fde8f02ec91f8b4f6899e76a34b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;t&lt;/code&gt; if the last actual modification time and Emacs&amp;rsquo;s recorded modification time are the same, &lt;code&gt;nil&lt;/code&gt; otherwise. It also returns &lt;code&gt;t&lt;/code&gt; if the buffer has no recorded last modification time, that is if &lt;code&gt;visited-file-modtime&lt;/code&gt; would return zero.</source>
          <target state="translated">如果最后的实际修改时间和Emacs记录的修改时间相同，则该函数返回 &lt;code&gt;t&lt;/code&gt; ,否则返回 &lt;code&gt;nil&lt;/code&gt; 。如果缓冲区没有记录上次修改时间，也就是返回 &lt;code&gt;t&lt;/code&gt; ，即， &lt;code&gt;visited-file-modtime&lt;/code&gt; 将返回零。</target>
        </trans-unit>
        <trans-unit id="eb47fbb29639c623b56d142e3e79686425e3d118" translate="yes" xml:space="preserve">
          <source>The function returns a list of elements that look like this:</source>
          <target state="translated">该函数返回的元素列表是这样的。</target>
        </trans-unit>
        <trans-unit id="b576d5d04a96dba46391f5334628078f6e91dee5" translate="yes" xml:space="preserve">
          <source>The function returns an existing buffer if there is one; otherwise it creates a new buffer and reads the file into it. When &lt;code&gt;find-file-noselect&lt;/code&gt; uses an existing buffer, it first verifies that the file has not changed since it was last visited or saved in that buffer. If the file has changed, this function asks the user whether to reread the changed file. If the user says &amp;lsquo;</source>
          <target state="translated">如果有缓冲区，该函数将返回一个现有缓冲区；否则，该函数将返回一个缓冲区。否则，它将创建一个新缓冲区，并将文件读入其中。当 &lt;code&gt;find-file-noselect&lt;/code&gt; 使用现有缓冲区时，它首先验证该文件自上次访问或保存到该缓冲区以来是否没有更改。如果文件已更改，此功能将询问用户是否重新读取更改的文件。如果用户说&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1501aaa047bf3d422b1edc8df28a63aa3d3d72eb" translate="yes" xml:space="preserve">
          <source>The function returns the new buffer position as its value.</source>
          <target state="translated">该函数返回新的缓冲区位置作为其值。</target>
        </trans-unit>
        <trans-unit id="58c3348b08983e8a23db0b1d6c78b02a290ca8f9" translate="yes" xml:space="preserve">
          <source>The function returns the text of the &lt;var&gt;long-answer&lt;/var&gt; selected by the user, regardless of whether long or short answers were shown in the prompt and typed by the user.</source>
          <target state="translated">该函数返回用户选择的 &lt;var&gt;long-answer&lt;/var&gt; 的文本，而不管提示中显示的长答案还是短答案并由用户键入。</target>
        </trans-unit>
        <trans-unit id="715f03109b9380bc908d0550c413f8b1448908f0" translate="yes" xml:space="preserve">
          <source>The function returns the value that &lt;var&gt;func&lt;/var&gt; returned.</source>
          <target state="translated">该函数返回 &lt;var&gt;func&lt;/var&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="0e79ba4a0ec06385532067bc2dfd92eef04abf37" translate="yes" xml:space="preserve">
          <source>The function scans text for a change in the &lt;var&gt;prop&lt;/var&gt; property, then returns the position of the change. The scan goes forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt;. In other words, this function returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose &lt;var&gt;prop&lt;/var&gt; property differs from that of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">该函数在 &lt;var&gt;prop&lt;/var&gt; 属性中扫描文本以查找更改，然后返回更改的位置。扫描从字符串或缓冲区 &lt;var&gt;object&lt;/var&gt; 中的位置 &lt;var&gt;pos&lt;/var&gt; 开始。换句话说，这个函数返回以后的第一个字符的位置 &lt;var&gt;pos&lt;/var&gt; ，其 &lt;var&gt;prop&lt;/var&gt; 刚过性质不同于字符的 &lt;var&gt;pos&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcc76f6509469249f57ba4ca3b63e8ba3ae15e54" translate="yes" xml:space="preserve">
          <source>The function scans the text forward from position &lt;var&gt;pos&lt;/var&gt; in the string or buffer &lt;var&gt;object&lt;/var&gt; until it finds a change in some text property, then returns the position of the change. In other words, it returns the position of the first character beyond &lt;var&gt;pos&lt;/var&gt; whose properties are not identical to those of the character just after &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">该函数从字符串或缓冲区 &lt;var&gt;object&lt;/var&gt; 中的位置 &lt;var&gt;pos&lt;/var&gt; 向前扫描文本，直到在某些text属性中找到更改为止，然后返回更改的位置。换句话说，它返回的第一个字符以外的位置 &lt;var&gt;pos&lt;/var&gt; ，其性质是不相同的，只是这些后字符的 &lt;var&gt;pos&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2569b6d3f2a4920cd818025751b427d49a3a937" translate="yes" xml:space="preserve">
          <source>The function searches for &lt;var&gt;image&lt;/var&gt; first using &lt;code&gt;image-load-path&lt;/code&gt;, excluding</source>
          <target state="translated">该函数首先使用 &lt;code&gt;image-load-path&lt;/code&gt; 搜索 &lt;var&gt;image&lt;/var&gt; ，但不包括</target>
        </trans-unit>
        <trans-unit id="f61dc72b5ae5c926752f9b2ea93c7b17926bb658" translate="yes" xml:space="preserve">
          <source>The function should report its choice by placing the region around it. A good choice is a range of text large enough to give proper results, but not too large so that refontification becomes slow. Typical values are &lt;code&gt;mark-defun&lt;/code&gt; for programming modes or &lt;code&gt;mark-paragraph&lt;/code&gt; for textual modes.</source>
          <target state="translated">该功能应通过在其周围放置区域来报告其选择。一个好的选择是文本范围足够大，可以给出适当的结果，但又不要太大，以免字体更改变慢。典型值是用于编程模式的 &lt;code&gt;mark-defun&lt;/code&gt; 或用于文本模式的 &lt;code&gt;mark-paragraph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e569deba575fd9eecea0636fcb5581d08c592fbf" translate="yes" xml:space="preserve">
          <source>The function specified by this option is called to automatically hide frames. This function is called with one argument&amp;mdash;a frame.</source>
          <target state="translated">调用此选项指定的功能以自动隐藏框架。使用一个参数（一个框架）调用此函数。</target>
        </trans-unit>
        <trans-unit id="9e523dba464ace87982922281becd877253b4c57" translate="yes" xml:space="preserve">
          <source>The function specified here is called by &lt;code&gt;bury-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;) when the selected window is dedicated and shows the buffer to bury. It is also called by &lt;code&gt;quit-restore-window&lt;/code&gt; (see above) when the frame of the window to quit has been specially created for displaying that window&amp;rsquo;s buffer and the buffer is not killed.</source>
          <target state="translated">此处指定的函数的调用 &lt;code&gt;bury-buffer&lt;/code&gt; （见&lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;缓冲器表&lt;/a&gt;）时是专门选择的窗口，并显示缓冲器埋葬。当专门为显示该窗口的缓冲区创建了要退出的窗口的框架并且未杀死该缓冲区时，也称为 &lt;code&gt;quit-restore-window&lt;/code&gt; （请参见上文）。</target>
        </trans-unit>
        <trans-unit id="4c5fe7b1d57c09eb96638f6d29a8d55ea70693dc" translate="yes" xml:space="preserve">
          <source>The function to call when the user invokes the button, which is passed the single argument &lt;var&gt;button&lt;/var&gt;. By default this is &lt;code&gt;ignore&lt;/code&gt;, which does nothing.</source>
          <target state="translated">用户调用按钮时调用的函数，该按钮传递了单个参数 &lt;var&gt;button&lt;/var&gt; 。默认情况下，它是 &lt;code&gt;ignore&lt;/code&gt; ，它什么都不做。</target>
        </trans-unit>
        <trans-unit id="0d346489c44defc5f50064e457e61d13f6a78be1" translate="yes" xml:space="preserve">
          <source>The function to define a new widget is called &lt;code&gt;define-widget&lt;/code&gt;. The first argument is the symbol we want to make a new widget type. The second argument is a symbol representing an existing widget, the new widget is going to be defined in terms of difference from the existing widget. For the purpose of defining new customization types, the &lt;code&gt;lazy&lt;/code&gt; widget is perfect, because it accepts a &lt;code&gt;:type&lt;/code&gt; keyword argument with the same syntax as the keyword argument to &lt;code&gt;defcustom&lt;/code&gt; with the same name. The third argument is a documentation string for the new widget. You will be able to see that string with the</source>
          <target state="translated">定义新窗口小部件的函数称为 &lt;code&gt;define-widget&lt;/code&gt; 。第一个参数是我们要创建新的窗口小部件类型的符号。第二个参数是代表现有窗口小部件的符号，将根据与现有窗口小部件的区别来定义新窗口小部件。为了定义新的自定义类型， &lt;code&gt;lazy&lt;/code&gt; 窗口小部件非常完美，因为它接受具有与语法 &lt;code&gt;defcustom&lt;/code&gt; 相同名称的关键字参数语法相同的 &lt;code&gt;:type&lt;/code&gt; 关键字参数。第三个参数是新窗口小部件的文档字符串。您将可以使用</target>
        </trans-unit>
        <trans-unit id="a3be86b3d84b881b3e6d6fe8ec9995afa24e5702" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s return value is the string typed by the user in the minibuffer. However, when called interactively or if the optional argument &lt;var&gt;convert&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it converts any input color name into the corresponding RGB value string and instead returns that. This function requires a valid color specification to be input. Empty color names are allowed when &lt;var&gt;allow-empty&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the user enters null input.</source>
          <target state="translated">函数的返回值是用户在迷你缓冲区中键入的字符串。但是，当以交互方式调用或可选参数 &lt;var&gt;convert&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 时，它将任何输入颜色名称转换为相应的RGB值字符串，并返回该值。此功能需要输入有效的颜色规格。当空的颜色名称被允许 &lt;var&gt;allow-empty&lt;/var&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 且用户输入零输入。</target>
        </trans-unit>
        <trans-unit id="24f9a1a492a75ddcf165b535a392f152caa63130" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;create-image&lt;/code&gt;, &lt;code&gt;defimage&lt;/code&gt; and &lt;code&gt;find-image&lt;/code&gt; provide convenient ways to create image descriptors.</source>
          <target state="translated">函数 &lt;code&gt;create-image&lt;/code&gt; ， &lt;code&gt;defimage&lt;/code&gt; 和 &lt;code&gt;find-image&lt;/code&gt; 提供了创建图像描述符的便捷方法。</target>
        </trans-unit>
        <trans-unit id="930041ed415a386650d1c27097780e324d3d97ff" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;default-value&lt;/code&gt; and &lt;code&gt;setq-default&lt;/code&gt; access and change a variable&amp;rsquo;s default value regardless of whether the current buffer has a buffer-local binding. For example, you could use &lt;code&gt;setq-default&lt;/code&gt; to change the default setting of &lt;code&gt;paragraph-start&lt;/code&gt; for most buffers; and this would work even when you are in a C or Lisp mode buffer that has a buffer-local value for this variable.</source>
          <target state="translated">函数 &lt;code&gt;default-value&lt;/code&gt; 和 &lt;code&gt;setq-default&lt;/code&gt; 访问并更改变量的默认值，而不管当前缓冲区是否具有本地缓冲区绑定。例如，您可以使用 &lt;code&gt;setq-default&lt;/code&gt; 来更改大多数缓冲区的 &lt;code&gt;paragraph-start&lt;/code&gt; 的默认设置；例如：即使在处于C或Lisp模式的缓冲区中，该缓冲区具有该变量的局部缓冲区值，该方法也将起作用。</target>
        </trans-unit>
        <trans-unit id="54fbaadcac6b546aa87b794bc4678dae8bd49959" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;event-modifiers&lt;/code&gt; and &lt;code&gt;event-basic-type&lt;/code&gt; are provided to get such information conveniently.</source>
          <target state="translated">提供 &lt;code&gt;event-modifiers&lt;/code&gt; 和 &lt;code&gt;event-basic-type&lt;/code&gt; 是为了方便地获取此类信息。</target>
        </trans-unit>
        <trans-unit id="f14e4ed51e1588f4afeb3f2808a8e88fb021c9e4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;ffloor&lt;/code&gt;, &lt;code&gt;fceiling&lt;/code&gt;, &lt;code&gt;fround&lt;/code&gt;, and &lt;code&gt;ftruncate&lt;/code&gt; take a floating-point argument and return a floating-point result whose value is a nearby integer. &lt;code&gt;ffloor&lt;/code&gt; returns the nearest integer below; &lt;code&gt;fceiling&lt;/code&gt;, the nearest integer above; &lt;code&gt;ftruncate&lt;/code&gt;, the nearest integer in the direction towards zero; &lt;code&gt;fround&lt;/code&gt;, the nearest integer.</source>
          <target state="translated">函数 &lt;code&gt;ffloor&lt;/code&gt; ， &lt;code&gt;fceiling&lt;/code&gt; ， &lt;code&gt;fround&lt;/code&gt; 和 &lt;code&gt;ftruncate&lt;/code&gt; 接受一个浮点参数，并返回一个浮点结果，其值是附近的整数。 &lt;code&gt;ffloor&lt;/code&gt; 返回下面最接近的整数； &lt;code&gt;fceiling&lt;/code&gt; ，最接近的整数； &lt;code&gt;ftruncate&lt;/code&gt; ，朝零方向的最近整数； &lt;code&gt;fround&lt;/code&gt; ，最接近的整数。</target>
        </trans-unit>
        <trans-unit id="2c140441fed92d7b6f61e961aac8a0aa69c39764" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;make-progress-reporter&lt;/code&gt; and &lt;code&gt;y-or-n-p&lt;/code&gt; don&amp;rsquo;t have to do anything special to activate the message log combination feature. It operates whenever two consecutive messages are logged that share a common prefix ending in &amp;lsquo;</source>
          <target state="translated">函数 &lt;code&gt;make-progress-reporter&lt;/code&gt; 和 &lt;code&gt;y-or-n-p&lt;/code&gt; 无需执行任何特殊操作即可激活消息日志组合功能。只要记录了两个连续的消息，它们共享以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1da791873fb7d70506573ba68b6bb43c2ea88baa" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;match-data&lt;/code&gt; and &lt;code&gt;set-match-data&lt;/code&gt; read or write the entire match data, all at once.</source>
          <target state="translated">功能 &lt;code&gt;match-data&lt;/code&gt; 和 &lt;code&gt;set-match-data&lt;/code&gt; 读取或写入一次，整场比赛的数据，所有的。</target>
        </trans-unit>
        <trans-unit id="9f3763eba26d0fcd98983ff84241c85f7df4ee68" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;mouse-position&lt;/code&gt; and &lt;code&gt;set-mouse-position&lt;/code&gt; give access to the current position of the mouse.</source>
          <target state="translated">使用 &lt;code&gt;mouse-position&lt;/code&gt; 和 &lt;code&gt;set-mouse-position&lt;/code&gt; 功能可以访问鼠标的当前位置。</target>
        </trans-unit>
        <trans-unit id="f6d9b7af5bfb64034127dfa877a8ed48be4859ab" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-next-sibling&lt;/code&gt; and &lt;code&gt;window-prev-sibling&lt;/code&gt; should not be confused with the functions &lt;code&gt;next-window&lt;/code&gt; and &lt;code&gt;previous-window&lt;/code&gt;, which return the next and previous window, respectively, in the cyclic ordering of windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">功能 &lt;code&gt;window-next-sibling&lt;/code&gt; 和 &lt;code&gt;window-prev-sibling&lt;/code&gt; 不应与功能相混淆 &lt;code&gt;next-window&lt;/code&gt; 和 &lt;code&gt;previous-window&lt;/code&gt; ，它返回下一个和前一个窗口，分别在窗口的循环顺序（见&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;循环窗口排序&lt;/a&gt;） 。</target>
        </trans-unit>
        <trans-unit id="a4599c26cca67f961f777727cb6555459567d4a8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;window-state-get&lt;/code&gt; and &lt;code&gt;window-state-put&lt;/code&gt; also allow to exchange the contents of two live windows. The following function does precisely that:</source>
          <target state="translated">功能 &lt;code&gt;window-state-get&lt;/code&gt; 和 &lt;code&gt;window-state-put&lt;/code&gt; 也允许交换两个现场窗口的内容。以下功能正是这样做的：</target>
        </trans-unit>
        <trans-unit id="9fce438f0ed03253c60350ad3e2d979328b783c3" translate="yes" xml:space="preserve">
          <source>The functions and variables described in this section evaluate forms, specify limits to the evaluation process, or record recently returned values. Loading a file also does evaluation (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;).</source>
          <target state="translated">本节中描述的函数和变量评估表单，指定评估过程的限制或记录最近返回的值。加载文件也会进行评估（请参阅&lt;a href=&quot;loading#Loading&quot;&gt;加载&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8e4bd3a8ad416b6b274e61c0311ccc7aceb93329" translate="yes" xml:space="preserve">
          <source>The functions are called in the order listed, with one argument, a buffer position &lt;var&gt;pos&lt;/var&gt;. Collectively they should attempt to assign faces to the text in the current buffer starting at &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">这些函数按列出的顺序调用，带有一个参数，即缓冲区位置 &lt;var&gt;pos&lt;/var&gt; 。他们应该共同尝试将面孔分配给当前缓冲区中从 &lt;var&gt;pos&lt;/var&gt; 开始的文本。</target>
        </trans-unit>
        <trans-unit id="6521a8bc086f1a3f8aefcf593df4fa2328b88776" translate="yes" xml:space="preserve">
          <source>The functions below signal an error if &lt;var&gt;keymap&lt;/var&gt; is not a keymap, or if &lt;var&gt;key&lt;/var&gt; is not a string or vector representing a key sequence. You can use event types (symbols) as shorthand for events that are lists. The &lt;code&gt;kbd&lt;/code&gt; function (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;) is a convenient way to specify the key sequence.</source>
          <target state="translated">如果 &lt;var&gt;keymap&lt;/var&gt; 不是keymap，或者 &lt;var&gt;key&lt;/var&gt; 不是表示键序列的字符串或向量，则下面的函数会发出错误消息。您可以使用事件类型（符号）作为列表事件的简写。在 &lt;code&gt;kbd&lt;/code&gt; 的功能（见&lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;键序列&lt;/a&gt;）是指定按键顺序的便捷方式。</target>
        </trans-unit>
        <trans-unit id="78ab65059bf6060d13b0ce32e999f9aebe8f6925" translate="yes" xml:space="preserve">
          <source>The functions described in this section accept a fixed set of specification characters. The next section describes a function &lt;code&gt;format-spec&lt;/code&gt; which can accept custom specification characters, such as &amp;lsquo;</source>
          <target state="translated">本节中描述的功能接受一组固定的规范字符。下一节将介绍一个函数 &lt;code&gt;format-spec&lt;/code&gt; ，该规范可以接受自定义规范字符，例如'</target>
        </trans-unit>
        <trans-unit id="e86fa617815c4b094651f86026f3ee350a021eb8" translate="yes" xml:space="preserve">
          <source>The functions described in this section control how terminal colors are used by Emacs.</source>
          <target state="translated">本节中描述的功能控制Emacs如何使用终端颜色。</target>
        </trans-unit>
        <trans-unit id="f169c28c5651085613c243ee2d7b8b6a97f3524f" translate="yes" xml:space="preserve">
          <source>The functions following next return the pixel widths and heights of the native, outer and inner frame and the text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;) of a given frame. For a text terminal, the results are in characters rather than pixels.</source>
          <target state="translated">接下来的函数返回原始，外部和内部框架以及给定框架的文本区域（请参见&lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;框架布局&lt;/a&gt;）的像素宽度和高度。对于文本终端，结果以字符而不是像素为单位。</target>
        </trans-unit>
        <trans-unit id="9720c55f16c083bb07299d34092580b6ec7aab89" translate="yes" xml:space="preserve">
          <source>The functions for parsing words described below use the syntax table and &lt;code&gt;char-script-table&lt;/code&gt; to decide whether a given character is part of a word. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;, and see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">下文描述的用于解析单词的功能使用语法表和 &lt;code&gt;char-script-table&lt;/code&gt; 来确定给定字符是否是单词的一部分。请参见&lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;语法表&lt;/a&gt;和&lt;a href=&quot;character-properties#Character-Properties&quot;&gt;字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84e553855a8b2ca8a57ae076b9aaef6d677d36c1" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;quit-window-hook&lt;/code&gt; are run before doing anything else.</source>
          <target state="translated">在执行其他操作之前，先运行 &lt;code&gt;quit-window-hook&lt;/code&gt; 中的函数。</target>
        </trans-unit>
        <trans-unit id="0e800d933c2fece3683cecc14ad7da075688816e" translate="yes" xml:space="preserve">
          <source>The functions in this list could be called either when the file is visited and Emacs wants to decode its contents, and/or when the file&amp;rsquo;s buffer is about to be saved and Emacs wants to determine how to encode its contents.</source>
          <target state="translated">当访问文件且Emacs想要解码其内容时，和/或当文件的缓冲区即将被保存并且Emacs想要确定如何对其内容进行编码时，可以调用此列表中的函数。</target>
        </trans-unit>
        <trans-unit id="669d58b77eada51f85ff6d10a60632f82115668b" translate="yes" xml:space="preserve">
          <source>The functions in this section are documented mainly because you can customize the naming conventions for backup files by redefining them. If you change one, you probably need to change the rest.</source>
          <target state="translated">记录本节中的功能,主要是因为您可以通过重新定义备份文件的命名约定来定制它们。如果您更改了一个,您可能需要更改其余的功能。</target>
        </trans-unit>
        <trans-unit id="ddf6614534160f658305998c350626e957a6f335" translate="yes" xml:space="preserve">
          <source>The functions in this section describe the basic capabilities of a particular display. Lisp programs can use them to adapt their behavior to what the display can do. For example, a program that ordinarily uses a popup menu could use the minibuffer if popup menus are not supported.</source>
          <target state="translated">本节中的函数描述了特定显示器的基本功能。Lisp程序可以使用它们来调整自己的行为以适应显示器的功能。例如,一个通常使用弹出式菜单的程序,如果不支持弹出式菜单,可以使用迷你缓冲区。</target>
        </trans-unit>
        <trans-unit id="f00c70d2142808c1b8036e8e15d164e6ace38175" translate="yes" xml:space="preserve">
          <source>The functions in this section do not actually access files, so they can operate on file names that do not refer to an existing file or directory.</source>
          <target state="translated">本节中的函数实际上并不访问文件,所以它们可以对不引用现有文件或目录的文件名进行操作。</target>
        </trans-unit>
        <trans-unit id="016907d83a21967cc3e08258bf37e7e359803f3f" translate="yes" xml:space="preserve">
          <source>The functions in this section rename, copy, delete, link, and set the modes (permissions) of files. Typically, they signal a &lt;code&gt;file-error&lt;/code&gt; error if they fail to perform their function, reporting the system-dependent error message that describes the reason for the failure. If they fail because a file is missing, they signal a &lt;code&gt;file-missing&lt;/code&gt; error instead.</source>
          <target state="translated">本节中的功能重命名，复制，删除，链接和设置文件的模式（权限）。通常，如果他们无法执行其功能，则会发出 &lt;code&gt;file-error&lt;/code&gt; 错误的信号，并报告描述失败原因的系统相关错误消息。如果由于文件丢失而导致失败，则表示 &lt;code&gt;file-missing&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="890b0146bfdda395f86d14be742c512118143bed" translate="yes" xml:space="preserve">
          <source>The functions in this section return unpredictable values unless otherwise stated.</source>
          <target state="translated">除非另有说明,本节中的函数将返回不可预测的值。</target>
        </trans-unit>
        <trans-unit id="f48a87c01a2f7dffcffdc543703f3903c8ef0749" translate="yes" xml:space="preserve">
          <source>The functions in this section test for numbers, or for a specific type of number. The functions &lt;code&gt;integerp&lt;/code&gt; and &lt;code&gt;floatp&lt;/code&gt; can take any type of Lisp object as argument (they would not be of much use otherwise), but the &lt;code&gt;zerop&lt;/code&gt; predicate requires a number as its argument. See also &lt;code&gt;integer-or-marker-p&lt;/code&gt; and &lt;code&gt;number-or-marker-p&lt;/code&gt;, in &lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;Predicates on Markers&lt;/a&gt;.</source>
          <target state="translated">本节中的功能将测试数字或特定类型的数字。函数 &lt;code&gt;integerp&lt;/code&gt; 和 &lt;code&gt;floatp&lt;/code&gt; 可以将任何类型的Lisp对象用作自变量（否则它们没有多大用处），但是 &lt;code&gt;zerop&lt;/code&gt; 谓词需要一个数字作为其自变量。也参见 &lt;code&gt;integer-or-marker-p&lt;/code&gt; 和 &lt;code&gt;number-or-marker-p&lt;/code&gt; ，在&lt;a href=&quot;predicates-on-markers#Predicates-on-Markers&quot;&gt;对标记谓词&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64495a754cd6c704e9f9d907a29b2bd6ed3d60e3" translate="yes" xml:space="preserve">
          <source>The functions on this hook should generally return quickly, since they may be called very often (e.g., from &lt;code&gt;post-command-hook&lt;/code&gt;). Supplying a function for &lt;var&gt;collection&lt;/var&gt; is strongly recommended if generating the list of completions is an expensive operation. Emacs may internally call functions in &lt;code&gt;completion-at-point-functions&lt;/code&gt; many times, but care about the value of &lt;var&gt;collection&lt;/var&gt; for only some of these calls. By supplying a function for &lt;var&gt;collection&lt;/var&gt;, Emacs can defer generating completions until necessary. You can use &lt;code&gt;completion-table-dynamic&lt;/code&gt; to create a wrapper function:</source>
          <target state="translated">通常，此挂钩上的函数应该很快返回，因为它们可能经常被调用（例如，从 &lt;code&gt;post-command-hook&lt;/code&gt; 调用）。如果生成完成列表是一项昂贵的操作，则强烈建议提供用于 &lt;var&gt;collection&lt;/var&gt; 的功能。 Emacs可以在内部多次 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 功能中调用函数，但是仅关心其中某些调用的 &lt;var&gt;collection&lt;/var&gt; 值。通过提供 &lt;var&gt;collection&lt;/var&gt; 功能，Emacs可以将生成完成时间推迟到必要时。您可以使用 &lt;code&gt;completion-table-dynamic&lt;/code&gt; 创建包装函数：</target>
        </trans-unit>
        <trans-unit id="2b93b057b358caf809f0e8e2015f2926ba7f4928" translate="yes" xml:space="preserve">
          <source>The functions should record the faces they assign by setting the &lt;code&gt;face&lt;/code&gt; property. They should also add a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property to all the text they have assigned faces to. That property tells redisplay that faces have been assigned to that text already.</source>
          <target state="translated">这些函数应该通过设置 &lt;code&gt;face&lt;/code&gt; 属性记录分配给他们的面孔。他们还应该在 &lt;code&gt;fontified&lt;/code&gt; 分配了面孔的所有文本中添加非 &lt;code&gt;nil&lt;/code&gt; fontized属性。该属性告诉redisplay已将面孔分配给该文本。</target>
        </trans-unit>
        <trans-unit id="41a0cd34297ecae8f4a088b103fb22bcddfee322" translate="yes" xml:space="preserve">
          <source>The functions that modify the contents of buffers are described in &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;中描述了修改缓冲区内容的功能。</target>
        </trans-unit>
        <trans-unit id="f40f1de7f1f1333998ea5f91c2f809716617bf8b" translate="yes" xml:space="preserve">
          <source>The functions you use in these hooks should save and restore the match data if they do anything that uses regular expressions; otherwise, they will interfere in bizarre ways with the editing operations that call them.</source>
          <target state="translated">你在这些钩子中使用的函数如果做任何使用正则表达式的事情,应该保存和恢复匹配数据;否则,它们会以奇怪的方式干扰调用它们的编辑操作。</target>
        </trans-unit>
        <trans-unit id="9072c6223cc7e87e04b922ff1eeb8eb85826e5dd" translate="yes" xml:space="preserve">
          <source>The fundamental interface to input methods is through the variable &lt;code&gt;input-method-function&lt;/code&gt;. See &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;, and &lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;Invoking the Input Method&lt;/a&gt;.</source>
          <target state="translated">输入法的基本接口是通过变量 &lt;code&gt;input-method-function&lt;/code&gt; 。请参阅&lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;读取一个事件&lt;/a&gt;和&lt;a href=&quot;invoking-the-input-method#Invoking-the-Input-Method&quot;&gt;调用输入法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="864ab21bc83654287c4cd15a4aee02d9312d9750" translate="yes" xml:space="preserve">
          <source>The gap in the buffer.</source>
          <target state="translated">缓冲区的间隙。</target>
        </trans-unit>
        <trans-unit id="2874b04cef330c832d718bb6b17cf07f619d5cf4" translate="yes" xml:space="preserve">
          <source>The garbage collector described above is used to manage data visible from Lisp programs, as well as most of the data internally used by the Lisp interpreter. Sometimes it may be useful to allocate temporary internal objects using the C stack of the interpreter. This can help performance, as stack allocation is typically faster than using heap memory to allocate and the garbage collector to free. The downside is that using such objects after they are freed results in undefined behavior, so uses should be well thought out and carefully debugged by using the &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; feature (see</source>
          <target state="translated">上述垃圾回收器用于管理从Lisp程序可见的数据以及Lisp解释器内部使用的大多数数据。有时使用解释器的C堆栈分配临时内部对象可能很有用。这可以提高性能，因为堆栈分配通常比使用堆内存分配和垃圾回收器释放更快。缺点是释放这些对象后使用它们会导致未定义的行为，因此应仔细考虑使用情况，并通过使用 &lt;code&gt;GC_CHECK_MARKED_OBJECTS&lt;/code&gt; 功能进行仔细调试（请参见</target>
        </trans-unit>
        <trans-unit id="da7a69d66cc2d899f159c6785baa3eb8aa0ce902" translate="yes" xml:space="preserve">
          <source>The general sequence functions &lt;code&gt;copy-sequence&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are often useful for objects known to be arrays. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">通用序列函数 &lt;code&gt;copy-sequence&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 通常对于已知为数组的对象很有用。请参阅&lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;序列函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74ab5893b0c67e70995b4afd47d2628e73c2db5f" translate="yes" xml:space="preserve">
          <source>The geometry of a frame depends on the toolkit that was used to build this instance of Emacs and the terminal that displays the frame. This chapter describes these dependencies and some of the functions to deal with them. Note that the &lt;var&gt;frame&lt;/var&gt; argument of all of these functions has to specify a live frame (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;). If omitted or &lt;code&gt;nil&lt;/code&gt;, it specifies the selected frame (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">框架的几何形状取决于用于构建此Emacs实例的工具箱以及显示框架的终端。本章介绍了这些依赖关系以及一些处理它们的功能。请注意，所有这些函数的 &lt;var&gt;frame&lt;/var&gt; 参数都必须指定一个实时帧（请参阅&lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;）。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则指定选定的帧（请参见&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b1b29a18ef7eb3bc56262e0c7ebd91ab2315293b" translate="yes" xml:space="preserve">
          <source>The global break condition is the simplest way to find where in your code some event occurs, but it makes code run much more slowly. So you should reset the condition to &lt;code&gt;nil&lt;/code&gt; when not using it.</source>
          <target state="translated">全局中断条件是查找代码中某些事件发生位置的最简单方法，但它会使代码运行慢得多。因此，在不使用该条件时，应将其重置为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="677591024d62617ead5c6d0b2e26233fd0d1c3c3" translate="yes" xml:space="preserve">
          <source>The global keymap used for the</source>
          <target state="translated">全局钥匙图用于</target>
        </trans-unit>
        <trans-unit id="f34b8f5f97a899dc0235f5429a6468bfeef23c7c" translate="yes" xml:space="preserve">
          <source>The global value of a variable with buffer-local bindings is also called the &lt;em&gt;default&lt;/em&gt; value, because it is the value that is in effect whenever neither the current buffer nor the selected frame has its own binding for the variable.</source>
          <target state="translated">具有缓冲区局部绑定的变量的全局值也称为&lt;em&gt;默认&lt;/em&gt;值，因为当当前缓冲区或选定帧都没有自己的变量绑定时，该值才有效。</target>
        </trans-unit>
        <trans-unit id="48d60332f6bc67502145a457cd0abab79aebcbd7" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a character displayed as an octal character code (the default is &amp;lsquo;</source>
          <target state="translated">指示以八进制字符代码显示的字符的字形（默认为'</target>
        </trans-unit>
        <trans-unit id="4c3656eced1ce2d785af3b405b7e21744ff87d83" translate="yes" xml:space="preserve">
          <source>The glyph for indicating a control character (the default is &amp;lsquo;</source>
          <target state="translated">表示控制字符的字形（默认为'</target>
        </trans-unit>
        <trans-unit id="69c90a66f7f1266d48dbdea6d60aeb7561e7e5b2" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a continued line (the default is &amp;lsquo;</source>
          <target state="translated">连续行结尾的字形（默认为'</target>
        </trans-unit>
        <trans-unit id="306df86e6b80484f756d552795447d03999ab82a" translate="yes" xml:space="preserve">
          <source>The glyph for the end of a truncated screen line (the default for this is &amp;lsquo;</source>
          <target state="translated">截断的屏幕行末尾的字形（默认值为'</target>
        </trans-unit>
        <trans-unit id="e37bea5e929c17d760a16f5f703fed0ee026e680" translate="yes" xml:space="preserve">
          <source>The glyph used to draw the border between side-by-side windows (the default is &amp;lsquo;</source>
          <target state="translated">用于在并排窗口之间绘制边框的字形（默认为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="97cde47c6c4afb345587e69edf666417f9a205ca" translate="yes" xml:space="preserve">
          <source>The gradient created (and inserted into the SVG object) can later be used by all functions that create shapes.</source>
          <target state="translated">创建的渐变(并插入到SVG对象中)可以在以后被所有创建形状的函数使用。</target>
        </trans-unit>
        <trans-unit id="0f64a77472c5aab1a530dafab8dc80afd47098d3" translate="yes" xml:space="preserve">
          <source>The grammar category &lt;code&gt;id&lt;/code&gt; has no right hand side: this does not mean that it can match only the empty string, since as mentioned any sequence of sexps can appear anywhere anyway.</source>
          <target state="translated">语法类别 &lt;code&gt;id&lt;/code&gt; 没有右边：这并不意味着它只能匹配空字符串，因为如上所述，任何六边形序列都可能出现在任何地方。</target>
        </trans-unit>
        <trans-unit id="731ba1b7288e05cf815c9c7aa4fd003aeedac70a" translate="yes" xml:space="preserve">
          <source>The greediness of some repetition forms can be controlled using the following constructs. However, it is usually better to use the explicit non-greedy forms above when such matching is required.</source>
          <target state="translated">一些重复形式的贪婪性可以使用以下构造来控制。但是,当需要这种匹配时,通常最好使用上面的显式非贪婪形式。</target>
        </trans-unit>
        <trans-unit id="25880d28e40fdac189e642330863b2e6c8e69129" translate="yes" xml:space="preserve">
          <source>The group ID of the effective user ID, a number.</source>
          <target state="translated">有效用户ID的集团ID,一个数字。</target>
        </trans-unit>
        <trans-unit id="b554cee81a954e5281b1fceb788df4a63ce37792" translate="yes" xml:space="preserve">
          <source>The handler function must handle all of the above operations, and possibly others to be added in the future. It need not implement all these operations itself&amp;mdash;when it has nothing special to do for a certain operation, it can reinvoke the primitive, to handle the operation in the usual way. It should always reinvoke the primitive for an operation it does not recognize. Here&amp;rsquo;s one way to do this:</source>
          <target state="translated">处理函数必须处理所有上述操作，将来可能还要添加其他操作。它不需要自己实现所有这些操作-当它不需要为某个特定的操作做任何事情时，它可以重新调用原语，以通常的方式处理该操作。它应始终为无法识别的操作重新调用原语。这是执行此操作的一种方法：</target>
        </trans-unit>
        <trans-unit id="8c0ade08243887c3328d4d5be685acc33d281985" translate="yes" xml:space="preserve">
          <source>The handler specifies condition name &lt;code&gt;arith-error&lt;/code&gt; so that it will handle only division-by-zero errors. Other kinds of errors will not be handled (by this &lt;code&gt;condition-case&lt;/code&gt;). Thus:</source>
          <target state="translated">处理程序指定条件名称 &lt;code&gt;arith-error&lt;/code&gt; ,以便仅处理被零除的错误。其他类型的错误将不被处理（在这种 &lt;code&gt;condition-case&lt;/code&gt; ）。从而：</target>
        </trans-unit>
        <trans-unit id="5e2f99bb60355a4bbc279516a684257561edba5f" translate="yes" xml:space="preserve">
          <source>The header and footer strings.</source>
          <target state="translated">页眉和页脚字符串。</target>
        </trans-unit>
        <trans-unit id="e6adc3e0fab908b197122795c03e598c9a217b17" translate="yes" xml:space="preserve">
          <source>The height in pixels of the mode line and the header line, or -1 if not known.</source>
          <target state="translated">模式行和标题行的高度,以像素为单位,如果不知道,则为-1。</target>
        </trans-unit>
        <trans-unit id="9e8ea212a3dcb1bbe9f9c723144aa8ee19f65b61" translate="yes" xml:space="preserve">
          <source>The height is normally the length of &lt;var&gt;bits&lt;/var&gt;. However, you can specify a different height with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;height&lt;/var&gt;. The width is normally 8, but you can specify a different width with non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;width&lt;/var&gt;. The width must be an integer between 1 and 16.</source>
          <target state="translated">高度通常是 &lt;var&gt;bits&lt;/var&gt; 的长度。但是，您可以使用non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;height&lt;/var&gt; 指定其他高度。宽度通常为8，但是您可以使用non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;width&lt;/var&gt; 指定其他宽度。宽度必须是1到16之间的整数。</target>
        </trans-unit>
        <trans-unit id="52397327e47c6d0da26d3462e7bc63626661f579" translate="yes" xml:space="preserve">
          <source>The height of horizontal scroll bars, in pixels, or &lt;code&gt;nil&lt;/code&gt; meaning to use the default height.</source>
          <target state="translated">水平滚动条的高度，以像素为单位，或者为 &lt;code&gt;nil&lt;/code&gt; ,表示使用默认高度。</target>
        </trans-unit>
        <trans-unit id="085e0e5d1f8cb968ce655bf2b24ca248fa12970b" translate="yes" xml:space="preserve">
          <source>The height of the default face must be specified using an integer; floating point and function values are not allowed.</source>
          <target state="translated">默认面的高度必须使用整数来指定,不允许使用浮点和函数值。</target>
        </trans-unit>
        <trans-unit id="d18f875e6e2637cf49c5905a5f35264c51a521b7" translate="yes" xml:space="preserve">
          <source>The height of the font in pixels.</source>
          <target state="translated">字体的高度,单位为像素。</target>
        </trans-unit>
        <trans-unit id="bcc4b1c7f0f04cad27e2f37687ce77b17aac9cc1" translate="yes" xml:space="preserve">
          <source>The height of the font. In the simplest case, this is an integer in units of 1/10 point.</source>
          <target state="translated">字体的高度。在最简单的情况下,这是一个以1/10点为单位的整数。</target>
        </trans-unit>
        <trans-unit id="3ed16f18e3452e0d7fb567a3976b1f69a672c4c7" translate="yes" xml:space="preserve">
          <source>The height of the line contents is the maximum height of any character or image on that display line, including the final newline if there is one. (A display line that is continued doesn&amp;rsquo;t include a final newline.) That is the default line height, if you do nothing to specify a greater height. (In the most common case, this equals the height of the corresponding frame&amp;rsquo;s default font, see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;.)</source>
          <target state="translated">行内容的高度是该显示行上任何字符或图像的最大高度，包括最后一个换行符（如果有的话）。（连续的显示行不包含最终换行符。）这是默认的行高，如果您不执行任何操作来指定更大的高度。（在最常见的情况下，它等于相应框架默认字体的高度，请参见&lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="fa5537f62fa0722eb0e8bcb5ec344261bd62fa37" translate="yes" xml:space="preserve">
          <source>The help character is special after prefix keys, too. If it has no binding as a subcommand of the prefix key, it runs &lt;code&gt;describe-prefix-bindings&lt;/code&gt;, which displays a list of all the subcommands of the prefix key.</source>
          <target state="translated">前缀键后的帮助字符也很特殊。如果没有绑定作为前缀键的子命令，它将运行 &lt;code&gt;describe-prefix-bindings&lt;/code&gt; ，该命令显示前缀键的所有子命令的列表。</target>
        </trans-unit>
        <trans-unit id="cf1897bec9624ad141a9f5fdb49dabce4abf14b2" translate="yes" xml:space="preserve">
          <source>The high-level completion functions &lt;code&gt;read-file-name&lt;/code&gt;, &lt;code&gt;read-directory-name&lt;/code&gt;, and &lt;code&gt;read-shell-command&lt;/code&gt; are designed to read file names, directory names, and shell commands, respectively. They provide special features, including automatic insertion of the default directory.</source>
          <target state="translated">高级完成功能 &lt;code&gt;read-file-name&lt;/code&gt; ， &lt;code&gt;read-directory-name&lt;/code&gt; 和 &lt;code&gt;read-shell-command&lt;/code&gt; 旨在分别读取文件名，目录名和shell命令。它们提供了特殊功能，包括自动插入默认目录。</target>
        </trans-unit>
        <trans-unit id="fc37323f324eaba3ae4eff83c852720c416eda92" translate="yes" xml:space="preserve">
          <source>The homepage for GNU Emacs is at &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;. For information on using Emacs, refer to the &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;Emacs Manual&lt;/a&gt;. To view this manual in other formats, click &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GNU Emacs的主页位于&lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;。有关使用Emacs的信息，请参阅《&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/emacs.html&quot;&gt;Emacs手册》&lt;/a&gt;。要以其他格式查看本手册，请单击&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b911bf982537bd609db0a1e22baeb6c2bb97081a" translate="yes" xml:space="preserve">
          <source>The hook functions are called both before and after each change. If the functions save the information they receive, and compare notes between calls, they can determine exactly what change has been made in the buffer text.</source>
          <target state="translated">钩子函数在每次修改之前和之后都会被调用。如果函数保存它们收到的信息,并在调用之间进行比较,它们就可以确定缓冲区文本中到底发生了什么变化。</target>
        </trans-unit>
        <trans-unit id="22eea4ac020189ebcc5a0b2b55d9b0917f8943a9" translate="yes" xml:space="preserve">
          <source>The hook functions in &lt;code&gt;write-file-functions&lt;/code&gt; are also responsible for encoding the data (if desired): they must choose a suitable coding system and end-of-line conversion (see &lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Lisp and Coding Systems&lt;/a&gt;), perform the encoding (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;), and set &lt;code&gt;last-coding-system-used&lt;/code&gt; to the coding system that was used (see &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;Encoding and I/O&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;write-file-functions&lt;/code&gt; 函数中的钩子函数还负责对数据进行编码（如果需要）：它们必须选择合适的编码系统并进行行尾转换（请参阅&lt;a href=&quot;lisp-and-coding-systems#Lisp-and-Coding-Systems&quot;&gt;Lisp和编码系统&lt;/a&gt;），执行编码（请参阅&lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;显式编码）&lt;/a&gt;），并将使用的 &lt;code&gt;last-coding-system-used&lt;/code&gt; 的编码系统（请参阅&lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;Encoding和I / O&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a83d039cd150de7d3779ef3fed719d6f59169d0d" translate="yes" xml:space="preserve">
          <source>The hook variable&amp;rsquo;s value can also be a single function&amp;mdash;either a lambda expression or a symbol with a function definition&amp;mdash;which &lt;code&gt;run-hooks&lt;/code&gt; calls. But this usage is obsolete.</source>
          <target state="translated">hook变量的值也可以是一个单独的函数，即lambda表达式或具有函数定义的符号，它们 &lt;code&gt;run-hooks&lt;/code&gt; 调用。但是这种用法已经过时了。</target>
        </trans-unit>
        <trans-unit id="917207ef55ed03cab5a1b55d69aa1063946c90b6" translate="yes" xml:space="preserve">
          <source>The horizontal scroll position is measured in units of the normal character width, which is the width of space in the default font. Thus, if the value is 5, that means the window contents are scrolled left by 5 times the normal character width. How many characters actually disappear off to the left depends on their width, and could vary from line to line.</source>
          <target state="translated">水平滚动位置的测量单位是正常字符宽度,也就是默认字体的空间宽度。因此,如果该值为5,则意味着窗口内容向左滚动的幅度为正常字符宽度的5倍。实际上有多少字符向左消失取决于它们的宽度,并且可能因行而异。</target>
        </trans-unit>
        <trans-unit id="2c1208df201cdc168e0e1bc7a6b67590a4982002" translate="yes" xml:space="preserve">
          <source>The hour of the day, as an integer between 0 and 23.</source>
          <target state="translated">一天中的小时,是0到23之间的整数。</target>
        </trans-unit>
        <trans-unit id="ff593a5384b2422b04132851d0695820fe2b360f" translate="yes" xml:space="preserve">
          <source>The hyper modifier.</source>
          <target state="translated">超修饰语。</target>
        </trans-unit>
        <trans-unit id="49029170f2d47fd9fece1b8af2f1320f67032a13" translate="yes" xml:space="preserve">
          <source>The idea of these variables is that you set them once and for all to the defaults you want, and then do not change them again. To specify a particular coding system for a particular operation in a Lisp program, don&amp;rsquo;t change these variables; instead, override them using &lt;code&gt;coding-system-for-read&lt;/code&gt; and &lt;code&gt;coding-system-for-write&lt;/code&gt; (see &lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;Specifying Coding Systems&lt;/a&gt;).</source>
          <target state="translated">这些变量的想法是，将它们一次又一次地设置为所需的默认值，然后不要再次更改它们。要为Lisp程序中的特定操作指定特定的编码系统，请不要更改这些变量。相反，使用覆盖它们 &lt;code&gt;coding-system-for-read&lt;/code&gt; 和 &lt;code&gt;coding-system-for-write&lt;/code&gt; （参见&lt;a href=&quot;specifying-coding-systems#Specifying-Coding-Systems&quot;&gt;指定编码系统&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9bcbe3e1bcf694fbe61bf24fe3189fb33ab88208" translate="yes" xml:space="preserve">
          <source>The identified of the shape.</source>
          <target state="translated">形状的确定。</target>
        </trans-unit>
        <trans-unit id="fcfecb9412ebffc1d18084e74054383228e6b207" translate="yes" xml:space="preserve">
          <source>The image is looked for in &lt;code&gt;image-load-path&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;image-load-path&lt;/code&gt; 中查找图像。</target>
        </trans-unit>
        <trans-unit id="8ea3cffbf70cec22855c36d36842437f817a7f5e" translate="yes" xml:space="preserve">
          <source>The image type. See &lt;a href=&quot;image-formats#Image-Formats&quot;&gt;Image Formats&lt;/a&gt;. Every image descriptor must include this property.</source>
          <target state="translated">图像类型。请参阅&lt;a href=&quot;image-formats#Image-Formats&quot;&gt;图像格式&lt;/a&gt;。每个图像描述符都必须包含此属性。</target>
        </trans-unit>
        <trans-unit id="caab580d160dc64b9167916da831f3bf977e17a4" translate="yes" xml:space="preserve">
          <source>The indentation functions are used to examine, move to, and change whitespace that is at the beginning of a line. Some of the functions can also change whitespace elsewhere on a line. Columns and indentation count from zero at the left margin.</source>
          <target state="translated">缩进函数用于检查、移动到和改变行首的空白处。有些函数还可以改变行内其他地方的空白。列和缩进从左边空白处的零开始计算。</target>
        </trans-unit>
        <trans-unit id="6cabff1a9cf356561844c4900ceadda4f5c31acc" translate="yes" xml:space="preserve">
          <source>The index alist can have three types of elements. Simple elements look like this:</source>
          <target state="translated">索引列表可以有三种类型的元素。简单的元素是这样的。</target>
        </trans-unit>
        <trans-unit id="7a2782dc40deb6629a41f6379bf7a7210bdb0f97" translate="yes" xml:space="preserve">
          <source>The index of the first character of the string is 0, the index of the second character is 1, and so on.</source>
          <target state="translated">字符串的第一个字符的索引为0,第二个字符的索引为1,以此类推。</target>
        </trans-unit>
        <trans-unit id="60e96bc26c021609e7a6560eb3d5be49e8d331cc" translate="yes" xml:space="preserve">
          <source>The initial threshold value is &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt;, defined in</source>
          <target state="translated">初始阈值为 &lt;code&gt;GC_DEFAULT_THRESHOLD&lt;/code&gt; ，在</target>
        </trans-unit>
        <trans-unit id="9fd1b2d43c07a66938f2a442d8dcfd842c600cd8" translate="yes" xml:space="preserve">
          <source>The initial value must be &lt;code&gt;nil&lt;/code&gt; except in cases where (1) the mode is preloaded in Emacs, or (2) it is painless for loading to enable the mode even though the user did not request it. For instance, if the mode has no effect unless something else is enabled, and will always be loaded by that time, enabling it by default is harmless. But these are unusual circumstances. Normally, the initial value must be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">初始值必须为 &lt;code&gt;nil&lt;/code&gt; ,除非（1）在Emacs中预加载了该模式，或者（2）即使用户没有请求，也可以轻松加载以启用该模式。例如，如果该模式除非启用了其他功能，否则没有任何作用，并且在那时将始终加载，因此默认情况下启用它是无害的。但是这些都是不寻常的情况。通常，初始值必须为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5ea75158d88e76423df4c71cfe451830055f3b4" translate="yes" xml:space="preserve">
          <source>The initialization function should perform whatever initialization is required for the module. In addition, it can perform the following tasks:</source>
          <target state="translated">初始化函数应该执行模块所需的任何初始化。此外,它还可以执行以下任务:</target>
        </trans-unit>
        <trans-unit id="2048f16a290b5e24dd2783eb5cab68b8c1d9c150" translate="yes" xml:space="preserve">
          <source>The input characters are generated by &lt;var&gt;function&lt;/var&gt;, which must support two kinds of calls:</source>
          <target state="translated">输入字符由 &lt;var&gt;function&lt;/var&gt; 生成，该函数必须支持两种调用：</target>
        </trans-unit>
        <trans-unit id="d16b3143ae14de892229a66c0119a9b13c4bbc54" translate="yes" xml:space="preserve">
          <source>The input characters are read from &lt;var&gt;buffer&lt;/var&gt;, starting with the character directly after point. Point advances as characters are read.</source>
          <target state="translated">输入字符是从 &lt;var&gt;buffer&lt;/var&gt; 中读取的，从点之后的字符开始。随着字符的读取，点前进。</target>
        </trans-unit>
        <trans-unit id="b99b6f486be0660a0034322da91996c0f39b3329" translate="yes" xml:space="preserve">
          <source>The input characters are read from the buffer that &lt;var&gt;marker&lt;/var&gt; is in, starting with the character directly after the marker. The marker position advances as characters are read. The value of point in the buffer has no effect when the stream is a marker.</source>
          <target state="translated">从 &lt;var&gt;marker&lt;/var&gt; 所在的缓冲区读取输入字符，从标记之后的字符开始。标记位置随着字符的读取而增加。当流是标记时，缓冲区中的point值不起作用。</target>
        </trans-unit>
        <trans-unit id="d8b5e8488b3fb00ae952a888effb061b3b3f5bf0" translate="yes" xml:space="preserve">
          <source>The input characters are taken from &lt;var&gt;string&lt;/var&gt;, starting at the first character in the string and using as many characters as required.</source>
          <target state="translated">输入字符取自 &lt;var&gt;string&lt;/var&gt; ，从字符串的第一个字符开始，并根据需要使用任意多个字符。</target>
        </trans-unit>
        <trans-unit id="30d1dd399ecaac7e239b3eddf29871a33b0d6701" translate="yes" xml:space="preserve">
          <source>The input method function is not called when reading the second and subsequent events of a key sequence. Thus, these characters are not subject to input method processing. The input method function should test the values of &lt;code&gt;overriding-local-map&lt;/code&gt; and &lt;code&gt;overriding-terminal-local-map&lt;/code&gt;; if either of these variables is non-&lt;code&gt;nil&lt;/code&gt;, the input method should put its argument into a list and return that list with no further processing.</source>
          <target state="translated">读取键序列的第二个和后续事件时，不会调用输入法函数。因此，这些字符不受输入法处理。输入法功能应测试 &lt;code&gt;overriding-local-map&lt;/code&gt; 和 &lt;code&gt;overriding-terminal-local-map&lt;/code&gt; 的值；如果这些变量中的任何一个都不为 &lt;code&gt;nil&lt;/code&gt; ，则输入法应将其参数放入列表中，并在不进行进一步处理的情况下返回该列表。</target>
        </trans-unit>
        <trans-unit id="f8c4abba5f74f931bc34d6747a6123acafdf7779" translate="yes" xml:space="preserve">
          <source>The input method function should return a list of events which should be used as input. (If the list is &lt;code&gt;nil&lt;/code&gt;, that means there is no input, so &lt;code&gt;read-event&lt;/code&gt; waits for another event.) These events are processed before the events in &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;). Events returned by the input method function are not passed to the input method function again, even if they are printing characters with no modifier bits.</source>
          <target state="translated">输入法函数应返回事件列表，这些事件应用作输入。（如果列表为 &lt;code&gt;nil&lt;/code&gt; ，则表示没有输入，因此 &lt;code&gt;read-event&lt;/code&gt; 等待另一个事件。）这些事件在 &lt;code&gt;unread-command-events&lt;/code&gt; 中的事件之前进行处理（请参阅&lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;）。即使输入的方法没有修饰位，输入方法函数返回的事件也不会再次传递给输入方法函数。</target>
        </trans-unit>
        <trans-unit id="539f747cb977830607d3cb710459ac2c2e5fa6fa" translate="yes" xml:space="preserve">
          <source>The inputs to GnuTLS cryptographic functions can be specified in several ways, both as primitive Emacs Lisp types or as lists.</source>
          <target state="translated">GnuTLS加密函数的输入可以通过多种方式指定,既可以是原始Emacs Lisp类型,也可以是列表。</target>
        </trans-unit>
        <trans-unit id="a7b8358b8f766540c234e4f8211a9601148d23fb" translate="yes" xml:space="preserve">
          <source>The inserted whitespace characters inherit text properties from the surrounding text (usually, from the preceding text only). See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">插入的空格字符从周围的文本（通常，仅从前面的文本）继承文本属性。请参阅&lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;粘性属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19fcbfab08e4368504efbf1b8e28b4430ed27384" translate="yes" xml:space="preserve">
          <source>The insertion functions convert text from unibyte to multibyte in order to insert in a multibyte buffer, and vice versa&amp;mdash;if the text comes from a string or from a buffer. However, they do not convert unibyte character codes 128 through 255 to multibyte characters, not even if the current buffer is a multibyte buffer. See &lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;Converting Representations&lt;/a&gt;.</source>
          <target state="translated">插入函数将文本从单字节转换为多字节，以便插入多字节缓冲区，反之亦然&amp;mdash;如果文本来自字符串或缓冲区。但是，即使当前缓冲区是多字节缓冲区，它们也不会将128到255的单字节字符代码转换为多字节字符。请参见&lt;a href=&quot;converting-representations#Converting-Representations&quot;&gt;转换制图表达&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edd2288269cf326b182d9af537f1760ef9f7146" translate="yes" xml:space="preserve">
          <source>The integer -1 looks like this:</source>
          <target state="translated">整数-1是这样的。</target>
        </trans-unit>
        <trans-unit id="2f33429d3899a8b5708f577a6767b2323bf9589e" translate="yes" xml:space="preserve">
          <source>The integer number of 365-day years.</source>
          <target state="translated">365天的整数年。</target>
        </trans-unit>
        <trans-unit id="e0d849236066efb1e790a734829181ed8c3e9ff5" translate="yes" xml:space="preserve">
          <source>The integer number of days.</source>
          <target state="translated">天数的整数。</target>
        </trans-unit>
        <trans-unit id="5cf7a7da13ec55fcd8e83c9522a19ff613f26c8a" translate="yes" xml:space="preserve">
          <source>The integer number of hours.</source>
          <target state="translated">的整数小时。</target>
        </trans-unit>
        <trans-unit id="bb774face5c62942103b0f3a113c848cd3042edd" translate="yes" xml:space="preserve">
          <source>The integer number of minutes.</source>
          <target state="translated">的整数分钟。</target>
        </trans-unit>
        <trans-unit id="9cbc76323d9ab5bd63ae8f77ccce189f3b0df5e3" translate="yes" xml:space="preserve">
          <source>The integer number of seconds.</source>
          <target state="translated">秒的整数。</target>
        </trans-unit>
        <trans-unit id="d26badfedc58bbcef7881a113b18e385a9856fff" translate="yes" xml:space="preserve">
          <source>The intent of &lt;code&gt;key-translation-map&lt;/code&gt; is for users to map one character set to another, including ordinary characters normally bound to &lt;code&gt;self-insert-command&lt;/code&gt;.</source>
          <target state="translated">本意向书 &lt;code&gt;key-translation-map&lt;/code&gt; 是用户映射一个字符集到另一个，包括通常势必普通字符 &lt;code&gt;self-insert-command&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d665cdf72ab80e27c444ceb9eb5618fb5457fb" translate="yes" xml:space="preserve">
          <source>The interactive declaration is a list of the form &lt;code&gt;(interactive
&lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt;. This declares how to provide arguments if the function is used interactively. Functions with this declaration are called &lt;em&gt;commands&lt;/em&gt;; they can be called using</source>
          <target state="translated">交互式声明是形式 &lt;code&gt;(interactive &lt;var&gt;code-string&lt;/var&gt;)&lt;/code&gt; 。声明了在交互使用函数时如何提供参数。具有此声明的函数称为&lt;em&gt;命令&lt;/em&gt;; 他们可以使用</target>
        </trans-unit>
        <trans-unit id="ae08d2dbfcabdf279e14b8cbd62c32467dc9f2d0" translate="yes" xml:space="preserve">
          <source>The interactive spec (if any). This can be a string or a Lisp expression. It is &lt;code&gt;nil&lt;/code&gt; for a function that isn&amp;rsquo;t interactive.</source>
          <target state="translated">交互式规范（如果有）。这可以是字符串或Lisp表达式。对于非交互功能，它 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2978362f714e301a7d1292d0bf49abf86d8926e4" translate="yes" xml:space="preserve">
          <source>The internal border is a border drawn by Emacs around the inner frame (see below). Its width is specified by the &lt;code&gt;internal-border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). Its color is specified by the background of the &lt;code&gt;internal-border&lt;/code&gt; face.</source>
          <target state="translated">内部边框是Emacs在内部框架周围绘制的边框（请参见下文）。其宽度由 &lt;code&gt;internal-border-width&lt;/code&gt; 框架参数指定（请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;）。其颜色由 &lt;code&gt;internal-border&lt;/code&gt; 面的背景指定。</target>
        </trans-unit>
        <trans-unit id="a6cb4b170f13ea9783523a2b390523918e77d98d" translate="yes" xml:space="preserve">
          <source>The interval tree which records the text properties of this buffer.</source>
          <target state="translated">记录该缓冲区文本属性的区间树。</target>
        </trans-unit>
        <trans-unit id="2b193cdd686eaf4559317677f35332fe025a0bac" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;make-temp-file&lt;/code&gt; is to prevent two different users or two different jobs from trying to use the exact same file name.</source>
          <target state="translated">的工作 &lt;code&gt;make-temp-file&lt;/code&gt; 是防止两个不同的用户或两个不同的工作试图使用完全相同的文件名。</target>
        </trans-unit>
        <trans-unit id="7d566fc76f2e6f4607003117618cbc1ab1b17dde" translate="yes" xml:space="preserve">
          <source>The key bindings are not commands, just symbols that are meaningful to the functions that use this map.</source>
          <target state="translated">键绑定不是命令,只是对使用该地图的函数有意义的符号。</target>
        </trans-unit>
        <trans-unit id="9bf1df2bbd01f543a3f0da8d68e7df8f3b5f2761" translate="yes" xml:space="preserve">
          <source>The key definition and lookup functions accept an alternate syntax for event types in a key sequence that is a vector: you can use a list containing modifier names plus one base event (a character or function key name). For example, &lt;code&gt;(control ?a)&lt;/code&gt; is equivalent to &lt;code&gt;?\C-a&lt;/code&gt; and &lt;code&gt;(hyper control left)&lt;/code&gt; is equivalent to &lt;code&gt;C-H-left&lt;/code&gt;. One advantage of such lists is that the precise numeric codes for the modifier bits don&amp;rsquo;t appear in compiled files.</source>
          <target state="translated">键定义和查找函数对作为矢量的键序列中的事件类型接受替代语法：您可以使用包含修饰符名称和一个基本事件（字符或功能键名称）的列表。例如， &lt;code&gt;(control ?a)&lt;/code&gt; 等效于 &lt;code&gt;?\C-a&lt;/code&gt; ， &lt;code&gt;(hyper control left)&lt;/code&gt; 等效于 &lt;code&gt;C-H-left&lt;/code&gt; 。这样的列表的优点之一是修饰符位的精确数字代码不会出现在编译文件中。</target>
        </trans-unit>
        <trans-unit id="628ce08bf218a05f5cf92a428c7d664ca579e0cc" translate="yes" xml:space="preserve">
          <source>The key sequence is translated into a command through the currently active keymaps. See &lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup&lt;/a&gt;, for information on how this is done. The result should be a keyboard macro or an interactively callable function. If the key is</source>
          <target state="translated">按键序列通过当前活动的按键图转换为命令。有关如何完成此操作的信息，请参见&lt;a href=&quot;key-lookup#Key-Lookup&quot;&gt;Key Lookup&lt;/a&gt;。结果应该是键盘宏或可交互调用的函数。如果关键是</target>
        </trans-unit>
        <trans-unit id="569f93f6d66684562d4fe017a80dce902677f074" translate="yes" xml:space="preserve">
          <source>The key sequences bound in a major mode keymap should usually start with</source>
          <target state="translated">主模式键位图中绑定的键序通常应以</target>
        </trans-unit>
        <trans-unit id="7950f6c49354bf68f27de0ba9e4826c034b3d35d" translate="yes" xml:space="preserve">
          <source>The key translation function receives one argument, which is the prompt that was specified in &lt;code&gt;read-key-sequence&lt;/code&gt;&amp;mdash;or &lt;code&gt;nil&lt;/code&gt; if the key sequence is being read by the editor command loop. In most cases you can ignore the prompt value.</source>
          <target state="translated">密钥转换函数接收一个参数，该参数是在指定的提示 &lt;code&gt;read-key-sequence&lt;/code&gt; -OR &lt;code&gt;nil&lt;/code&gt; 如果密钥序列正被编辑命令循环读取。在大多数情况下，您可以忽略提示值。</target>
        </trans-unit>
        <trans-unit id="9c724c94075d725787e5d581c532371826e09281" translate="yes" xml:space="preserve">
          <source>The keymap &lt;var&gt;keymap&lt;/var&gt; is active whenever &lt;var&gt;variable&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value. Typically &lt;var&gt;variable&lt;/var&gt; is the variable that enables or disables a minor mode. See &lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;Keymaps and Minor Modes&lt;/a&gt;.</source>
          <target state="translated">只要 &lt;var&gt;variable&lt;/var&gt; 具有非 &lt;code&gt;nil&lt;/code&gt; 值，键映射键 &lt;var&gt;keymap&lt;/var&gt; 就处于活动状态。通常， &lt;var&gt;variable&lt;/var&gt; 是启用或禁用次要模式的变量。请参阅&lt;a href=&quot;keymaps-and-minor-modes#Keymaps-and-Minor-Modes&quot;&gt;键盘映射和次要模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="778deedcebfd753f594652405f80825572066516" translate="yes" xml:space="preserve">
          <source>The keymap binding of a prefix key is used for looking up the event that follows the prefix key. (It may instead be a symbol whose function definition is a keymap. The effect is the same, but the symbol serves as a name for the prefix key.) Thus, the binding of</source>
          <target state="translated">前缀键的键图绑定用于查找前缀键后面的事件。(它可以是一个符号,其函数定义是一个键图。效果是一样的,但这个符号是作为前缀键的名称)。)因此,对</target>
        </trans-unit>
        <trans-unit id="fd6135585180a24face202b71c46d7d4e0321d54" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tab bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;Tab Bars&lt;/a&gt; in</source>
          <target state="translated">定义选项卡栏内容的键盘映射。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html#Tab-Bars&quot;&gt;标签栏&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="dbdf9f5934eb2533828d5b82e95608cabd6b6788" translate="yes" xml:space="preserve">
          <source>The keymap defining the contents of the tool bar. See &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;.</source>
          <target state="translated">定义工具栏内容的键盘映射。请参阅&lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;工具栏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e0069d3ae618f793f1fa2e4550594c9b75d2f72" translate="yes" xml:space="preserve">
          <source>The keymap for characters following</source>
          <target state="translated">后面字符的键位图</target>
        </trans-unit>
        <trans-unit id="c3be0c367d559d4bcc94776ddab26cb11131700e" translate="yes" xml:space="preserve">
          <source>The keymap for translating key sequences to preferred alternatives. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">用于将键序列转换为首选替代方案的键图。如果没有，则它包含一个空的稀疏键映射。请参见&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻译键盘映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13b5ef05286cb723bbea46afe3ee9fb02d42a48b" translate="yes" xml:space="preserve">
          <source>The keymap for translating keypad and function keys. If there are none, then it contains an empty sparse keymap. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">用于翻译键盘和功能键的键映射。如果没有，则它包含一个空的稀疏键映射。请参见&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻译键盘映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e7dbb9716bd01a43838b53fe70be9a55bda1567" translate="yes" xml:space="preserve">
          <source>The keymap used by Prog mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">Prog模式使用的键盘映射。请参阅&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本专业模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ab245ddfa519516f3703f74bf4d4e8acfbe8994" translate="yes" xml:space="preserve">
          <source>The keymap used by Special mode. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">特殊模式使用的键盘映射。请参阅&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本专业模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e1ee3684d67359a88650e4fd1514d3bc1388140" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;&amp;amp;rest&lt;/code&gt; (which must be followed by a single argument name) indicates that any number of arguments can follow. The single argument name following &lt;code&gt;&amp;amp;rest&lt;/code&gt; receives, as its value, a list of all the remaining arguments passed to the function. Do not write &lt;code&gt;&amp;amp;rest&lt;/code&gt; when you call the function.</source>
          <target state="translated">关键字 &lt;code&gt;&amp;amp;rest&lt;/code&gt; （必须后跟一个参数名称）表示可以跟随任意数量的参数。 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 之后的单个参数名称将接收传递给函数的所有其余参数的列表作为其值。调用函数时请勿编写 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3a2577e25ef4336cea54dd5ba9525c1ac899432" translate="yes" xml:space="preserve">
          <source>The kill ring records killed text as strings in a list, most recent first. A short kill ring, for example, might look like this:</source>
          <target state="translated">杀人环将被杀死的文本以字符串的形式记录在一个列表中,最近的先记录。例如,一个简短的杀戒可能是这样的。</target>
        </trans-unit>
        <trans-unit id="5310f9fc7ac635f8fb0f1f88e49865f96859f4ff" translate="yes" xml:space="preserve">
          <source>The kind of background&amp;mdash;either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">一种背景- &lt;code&gt;light&lt;/code&gt; 或 &lt;code&gt;dark&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bde2896c92556891a9a522e437678bf44d775c73" translate="yes" xml:space="preserve">
          <source>The kind of display associated with the terminal. This is the symbol returned by the function &lt;code&gt;terminal-live-p&lt;/code&gt; (i.e., &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;w32&lt;/code&gt;, &lt;code&gt;ns&lt;/code&gt;, or &lt;code&gt;pc&lt;/code&gt;). See &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;.</source>
          <target state="translated">与终端关联的显示类型。这是函数 &lt;code&gt;terminal-live-p&lt;/code&gt; 返回的符号（即 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; ， &lt;code&gt;w32&lt;/code&gt; ， &lt;code&gt;ns&lt;/code&gt; 或 &lt;code&gt;pc&lt;/code&gt; ）。请参阅&lt;a href=&quot;frames#Frames&quot;&gt;框架&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5c7577d4b10f36a18bbab67549b2c58143927c6" translate="yes" xml:space="preserve">
          <source>The kind of window system the terminal uses&amp;mdash;either &lt;code&gt;graphic&lt;/code&gt; (any graphics-capable display), &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;pc&lt;/code&gt; (for the MS-DOS console), &lt;code&gt;w32&lt;/code&gt; (for MS Windows 9X/NT/2K/XP), or &lt;code&gt;tty&lt;/code&gt; (a non-graphics-capable display). See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;window-system&lt;/a&gt;.</source>
          <target state="translated">终端使用的窗口系统类型- &lt;code&gt;graphic&lt;/code&gt; （任何具有图形功能的显示器）， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;pc&lt;/code&gt; （对于MS-DOS控制台）， &lt;code&gt;w32&lt;/code&gt; （对于MS Windows 9X / NT / 2K / XP）或 &lt;code&gt;tty&lt;/code&gt; （非-具有图形功能的显示）。请参阅&lt;a href=&quot;window-systems#Window-Systems&quot;&gt;window-system&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01ef18971dfd086d0f3bdf7cf4fbd00a90436fd8" translate="yes" xml:space="preserve">
          <source>The language that the font should support. The value should be a symbol whose name is a two-letter ISO-639 language name. On X, the value is matched against the &amp;ldquo;Additional Style&amp;rdquo; field of the XLFD name of a font, if it is non-empty. On MS-Windows, fonts matching the spec are required to support codepages needed for the language. Currently, only a small set of CJK languages is supported with this property: &amp;lsquo;</source>
          <target state="translated">字体应支持的语言。该值应该是一个符号，其名称是两个字母的ISO-639语言名称。在X上，该值与字体的XLFD名称的&amp;ldquo;其他样式&amp;rdquo;字段匹配，如果它不是空的。在MS-Windows上，需要使用符合规范的字体来支持该语言所需的代码页。目前，此属性仅支持一小部分CJK语言：&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="88a7e776b65a937667815eb3a6eaf67a01ff78ce" translate="yes" xml:space="preserve">
          <source>The last</source>
          <target state="translated">最后一个</target>
        </trans-unit>
        <trans-unit id="dccd686ce06e60750b4337124ef02d3ac122a8dc" translate="yes" xml:space="preserve">
          <source>The last form also makes sure that none of the created side windows are accessible via</source>
          <target state="translated">最后一种形式也确保所创建的侧窗都不能通过</target>
        </trans-unit>
        <trans-unit id="37be7c944a107a298305238e57bd913b69f97266" translate="yes" xml:space="preserve">
          <source>The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:</source>
          <target state="translated">文档字符串的最后一行可以指定与实际函数参数不同的调用约定。写这样的文字。</target>
        </trans-unit>
        <trans-unit id="ddcb40b64096f3eaa561946b2a19e292247e85b0" translate="yes" xml:space="preserve">
          <source>The last optional item, &lt;var&gt;noerror&lt;/var&gt;, overrides the normal error when the text can&amp;rsquo;t be encoded using the specified or chosen coding system. When &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">当无法使用指定或选择的编码系统对文本进行编码时，最后一个可选项目 &lt;var&gt;noerror&lt;/var&gt; 会覆盖普通错误。当 &lt;var&gt;noerror&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 时，此函数将以静默方式使用 &lt;code&gt;raw-text&lt;/code&gt; 编码。</target>
        </trans-unit>
        <trans-unit id="ab880934452e3eacbf10a61506631f3e7e86eb71" translate="yes" xml:space="preserve">
          <source>The last thing &lt;code&gt;after-find-file&lt;/code&gt; does is call all the functions in the list &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after-find-file&lt;/code&gt; 做的最后一件事是调用 &lt;code&gt;find-file-hook&lt;/code&gt; 列表中的所有函数。</target>
        </trans-unit>
        <trans-unit id="0003f3c71cb33be508071e1a28e112d5cd1a93de" translate="yes" xml:space="preserve">
          <source>The last three elements give additional information about the font. &lt;var&gt;fixed-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; if the font is fixed-pitch. &lt;var&gt;full&lt;/var&gt; is the full name of the font, and &lt;var&gt;registry-and-encoding&lt;/var&gt; is a string giving the registry and encoding of the font.</source>
          <target state="translated">最后三个元素提供有关字体的其他信息。 &lt;var&gt;fixed-p&lt;/var&gt; 是不 &lt;code&gt;nil&lt;/code&gt; ，如果字体是固定间距。 &lt;var&gt;full&lt;/var&gt; 是字体的全名， &lt;var&gt;registry-and-encoding&lt;/var&gt; 是提供字体的注册表和编码的字符串。</target>
        </trans-unit>
        <trans-unit id="6c23485a20be9be1024893537c3477b18df28155" translate="yes" xml:space="preserve">
          <source>The last two values in &lt;var&gt;subexp-highlighter&lt;/var&gt;, &lt;var&gt;override&lt;/var&gt; and &lt;var&gt;laxmatch&lt;/var&gt;, are optional flags. If &lt;var&gt;override&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this element can override existing fontification made by previous elements of &lt;code&gt;font-lock-keywords&lt;/code&gt;. If it is &lt;code&gt;keep&lt;/code&gt;, then each character is fontified if it has not been fontified already by some other element. If it is &lt;code&gt;prepend&lt;/code&gt;, the face specified by &lt;var&gt;facespec&lt;/var&gt; is added to the beginning of the &lt;code&gt;font-lock-face&lt;/code&gt; property. If it is &lt;code&gt;append&lt;/code&gt;, the face is added to the end of the &lt;code&gt;font-lock-face&lt;/code&gt; property.</source>
          <target state="translated">&lt;var&gt;subexp-highlighter&lt;/var&gt; 中的最后两个值， &lt;var&gt;override&lt;/var&gt; 和 &lt;var&gt;laxmatch&lt;/var&gt; 是可选标志。如果 &lt;var&gt;override&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则此元素可以覆盖由 &lt;code&gt;font-lock-keywords&lt;/code&gt; 的先前元素构成的现有字体。如果为 &lt;code&gt;keep&lt;/code&gt; ，则如果每个字符尚未被其他元素设置为字体，则将其设置为字体。如果它是 &lt;code&gt;prepend&lt;/code&gt; ，则由 &lt;var&gt;facespec&lt;/var&gt; 指定的面部将添加到 &lt;code&gt;font-lock-face&lt;/code&gt; 属性的开头。如果为 &lt;code&gt;append&lt;/code&gt; ，则将脸添加到 &lt;code&gt;font-lock-face&lt;/code&gt; 属性的末尾。</target>
        </trans-unit>
        <trans-unit id="992a1c51c72e3b37e35b641195dd8337943b2596" translate="yes" xml:space="preserve">
          <source>The last way to customize Imenu for a major mode is to set the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt;:</source>
          <target state="translated">为主要模式自定义Imenu的最后一种方法是设置变量 &lt;code&gt;imenu-create-index-function&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3ce25b448ce366df7fb622e8f8aa9485fb8699a5" translate="yes" xml:space="preserve">
          <source>The layer 2 address (Ethernet MAC address, for instance).</source>
          <target state="translated">第2层地址(例如以太网MAC地址)。</target>
        </trans-unit>
        <trans-unit id="a47ca85c8b203a3f800aea8cd96b6a61549d375d" translate="yes" xml:space="preserve">
          <source>The layout of side windows on the left or right of a frame is not affected by the value of this variable.</source>
          <target state="translated">框的左边或右边的侧窗布局不受此变量值的影响。</target>
        </trans-unit>
        <trans-unit id="6009ec89412305c052749a52bf8f3c7e8431cbcf" translate="yes" xml:space="preserve">
          <source>The layout of such a frame might appear as follows:</source>
          <target state="translated">这种框架的布局可能如下:</target>
        </trans-unit>
        <trans-unit id="3b025a85b17d93fe80056a9fbbc6aa0c12299f7e" translate="yes" xml:space="preserve">
          <source>The least specialized major mode is called &lt;em&gt;Fundamental mode&lt;/em&gt;, which has no mode-specific definitions or variable settings.</source>
          <target state="translated">最少专业的主要模式称为&lt;em&gt;基本模式&lt;/em&gt;，该模式没有特定于模式的定义或变量设置。</target>
        </trans-unit>
        <trans-unit id="cf0a2de49bf1a621f861fc10249ddf1c3e8e8639" translate="yes" xml:space="preserve">
          <source>The left-hand and top edges of this window, measured in pixels, relative to the top-left corner (0, 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">该窗口的左边缘和上边缘，以像素为单位，相对于窗口本机框架的左上角（0，0）。</target>
        </trans-unit>
        <trans-unit id="0e159da910fc18db25e6c0af5e99bdff417543a4" translate="yes" xml:space="preserve">
          <source>The left-hand edge of the window, measured in columns, relative to the leftmost column (column 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">窗口的左边缘，以列为单位，相对于窗口本机框架的最左列（第0列）。</target>
        </trans-unit>
        <trans-unit id="85b6183109a9a7b6efad378049191669aefc0fd8" translate="yes" xml:space="preserve">
          <source>The length of the array is fixed once you create it; you cannot change the length of an existing array.</source>
          <target state="translated">一旦创建了数组,数组的长度是固定的,不能改变现有数组的长度。</target>
        </trans-unit>
        <trans-unit id="bb9a27d08446955ce106744ef3b710dbc15d43b6" translate="yes" xml:space="preserve">
          <source>The length of the file this buffer is visiting, when last read or saved. It can have 2 special values: -1 means auto-saving was turned off in this buffer, and -2 means don&amp;rsquo;t turn off auto-saving if buffer text shrinks a lot. This and other fields concerned with saving are not kept in the &lt;code&gt;buffer_text&lt;/code&gt; structure because indirect buffers are never saved.</source>
          <target state="translated">上次读取或保存时此缓冲区正在访问的文件的长度。它可以具有2个特殊值：-1表示此缓冲区中的自动保存已关闭，而-2表示如果缓冲区文本缩小很多，则不关闭自动保存。与保存有关的该字段和其他字段未保留在 &lt;code&gt;buffer_text&lt;/code&gt; 结构中，因为从不保存间接缓冲区。</target>
        </trans-unit>
        <trans-unit id="2735538fcce561a7758f21b1ebbd03c667ab66da" translate="yes" xml:space="preserve">
          <source>The length of the old text is the difference between the buffer positions before and after that text as it was before the change. As for the changed text, its length is simply the difference between the first two arguments.</source>
          <target state="translated">旧文本的长度是该文本前后缓冲区位置与更改前的差值。至于更改后的文本,其长度只是前两个参数之间的差值。</target>
        </trans-unit>
        <trans-unit id="959fbf29c3f8bb0bab090fdff0de9a589ee90bcb" translate="yes" xml:space="preserve">
          <source>The license for this documentation.</source>
          <target state="translated">本文件的许可证。</target>
        </trans-unit>
        <trans-unit id="620613354f3eaf838b72f4f12e00f9803d440b0f" translate="yes" xml:space="preserve">
          <source>The line functions in the previous section count text lines, delimited only by newline characters. By contrast, these functions count screen lines, which are defined by the way the text appears on the screen. A text line is a single screen line if it is short enough to fit the width of the selected window, but otherwise it may occupy several screen lines.</source>
          <target state="translated">上一节中的行函数计算的是文本行,仅以换行符为界。与此相反,这些函数计算的是屏幕线,屏幕线是由屏幕上的文本显示方式定义的。如果文本行短到足以适应所选窗口的宽度,那么它就是一条屏幕行,否则它可能会占用几条屏幕行。</target>
        </trans-unit>
        <trans-unit id="716452ebec7e673d1d9d81cc51b8547f340814e1" translate="yes" xml:space="preserve">
          <source>The line number of a certain position in the buffer, or zero. This is used for displaying the line number of point in the mode line.</source>
          <target state="translated">缓冲区中某一位置的行号,或为零。用于显示模式行中点的行号。</target>
        </trans-unit>
        <trans-unit id="839f8d216431863a7a00ea59f4be71c60c8c2e5b" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;(rose violet)&lt;/code&gt; is equivalent to &lt;code&gt;(rose . (violet))&lt;/code&gt;, and looks like this:</source>
          <target state="translated">列表 &lt;code&gt;(rose violet)&lt;/code&gt; 等同于 &lt;code&gt;(rose . (violet))&lt;/code&gt; ，看起来像这样：</target>
        </trans-unit>
        <trans-unit id="962c62424fbca05b4167123b8512730f70e28cc4" translate="yes" xml:space="preserve">
          <source>The list describes the display that &lt;var&gt;frame&lt;/var&gt; is on; if &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it applies to the selected frame&amp;rsquo;s display (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">该列表描述了该 &lt;var&gt;frame&lt;/var&gt; 所在的显示。如果 &lt;var&gt;frame&lt;/var&gt; 省略或为 &lt;code&gt;nil&lt;/code&gt; ，则适用于所选框架的显示（请参见&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a5e7dd03ee241b78dea866b6e88f99a7a8764678" translate="yes" xml:space="preserve">
          <source>The list form is currently similar to how &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;secure-hash&lt;/code&gt; operate.</source>
          <target state="translated">该列表形式当前类似于 &lt;code&gt;md5&lt;/code&gt; 和 &lt;code&gt;secure-hash&lt;/code&gt; 的操作方式。</target>
        </trans-unit>
        <trans-unit id="f1ee49ad7464cab64ae226a805d7b31a9c327b50" translate="yes" xml:space="preserve">
          <source>The list is ordered so that earlier elements correspond to more recently-shown buffers, and the first element usually corresponds to the buffer most recently removed from the window.</source>
          <target state="translated">列表是有序的,因此较早的元素对应于最近显示的缓冲区,第一个元素通常对应于最近从窗口中删除的缓冲区。</target>
        </trans-unit>
        <trans-unit id="bf28d6cd5c13b4c859c3624b6a63099b610df792" translate="yes" xml:space="preserve">
          <source>The list of the positions of the currently open parentheses, starting with the outermost.</source>
          <target state="translated">当前打开的小括号的位置列表,从最外层开始。</target>
        </trans-unit>
        <trans-unit id="42d7eea344ddd2896a97642d094a7e8335564359" translate="yes" xml:space="preserve">
          <source>The list returned by &lt;code&gt;buffer-list&lt;/code&gt; is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:</source>
          <target state="translated">&lt;code&gt;buffer-list&lt;/code&gt; list返回的列表是专门构造的；它不是内部Emacs数据结构，对其进行修改不会影响缓冲区的顺序。如果要更改基本缓冲区列表中缓冲区的顺序，这是一种简单的方法：</target>
        </trans-unit>
        <trans-unit id="a8c850e06ee228bef706e71be70435aebad07c66" translate="yes" xml:space="preserve">
          <source>The load functions evaluate all the expressions in a file just as the &lt;code&gt;eval-buffer&lt;/code&gt; function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.</source>
          <target state="translated">加载函数评估文件中的所有表达式，就像 &lt;code&gt;eval-buffer&lt;/code&gt; 函数评估缓冲区中的所有表达式一样。区别在于加载功能读取并评估磁盘上找到的文件中的文本，而不是Emacs缓冲区中的文本。</target>
        </trans-unit>
        <trans-unit id="bcf097db69a4c3e2b9f156a93318f5b55b88be14" translate="yes" xml:space="preserve">
          <source>The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a &lt;em&gt;top-level form&lt;/em&gt;. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.</source>
          <target state="translated">加载的文件必须包含Lisp表达式，无论是作为源代码还是作为字节编译的代码。文件中的每个表单都称为&lt;em&gt;顶级表单&lt;/em&gt;。可加载文件中的表单没有特殊格式；同样，文件中的任何形式都可以直接输入缓冲区并在其中求值。（实际上，大多数代码都是以这种方式测试的。）大多数情况下，形式是函数定义和变量定义。</target>
        </trans-unit>
        <trans-unit id="95d55d2fde6c278fb97386c98daf3e630c566eab" translate="yes" xml:space="preserve">
          <source>The local address, in internal format.</source>
          <target state="translated">本地地址,采用内部格式。</target>
        </trans-unit>
        <trans-unit id="56aaea215b4bc49234f9ee74677196b8ffb7af78" translate="yes" xml:space="preserve">
          <source>The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.</source>
          <target state="translated">本地键谱和变量列表包含单独覆盖全局绑定或值的条目。这些用于自定义不同缓冲区中程序的行为,而不实际改变程序。</target>
        </trans-unit>
        <trans-unit id="8497e1e143889552fd6d29f50ee9c1a86ceb2d17" translate="yes" xml:space="preserve">
          <source>The local keymap is normally set by the buffer&amp;rsquo;s major mode, and every buffer with the same major mode shares the same local keymap. Hence, if you call &lt;code&gt;local-set-key&lt;/code&gt; (see &lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;) to change the local keymap in one buffer, that also affects the local keymaps in other buffers with the same major mode.</source>
          <target state="translated">本地键映射通常由缓冲区的主模式设置，并且具有相同主模式的每个缓冲区共享相同的本地键映射。因此，如果您调用 &lt;code&gt;local-set-key&lt;/code&gt; （请参阅&lt;a href=&quot;key-binding-commands#Key-Binding-Commands&quot;&gt;Key Binding Commands&lt;/a&gt;）以更改一个缓冲区中的本地键映射，这也会影响具有相同主模式的其他缓冲区中的本地键映射。</target>
        </trans-unit>
        <trans-unit id="c20827cfc5ffe09c075650e5199361a56b68cec0" translate="yes" xml:space="preserve">
          <source>The low-level mechanism for disabling a command is to put a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;disabled&lt;/code&gt; property on the Lisp symbol for the command. These properties are normally set up by the user&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) with Lisp expressions such as this:</source>
          <target state="translated">禁用命令的低级机制是在命令的Lisp符号上放置 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;disabled&lt;/code&gt; 属性。这些属性通常由用户的init文件（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;）使用Lisp表达式设置，例如：</target>
        </trans-unit>
        <trans-unit id="23fe2196399552d25b3c061985ee305fa84c2b18" translate="yes" xml:space="preserve">
          <source>The low-level primitives for creating buffers do not use this function, but medium-level commands such as &lt;code&gt;switch-to-buffer&lt;/code&gt; and &lt;code&gt;find-file-noselect&lt;/code&gt; use it whenever they create buffers.</source>
          <target state="translated">用于创建缓冲区的低级原语不使用此功能，但是中级命令（例如 &lt;code&gt;switch-to-buffer&lt;/code&gt; 和 &lt;code&gt;find-file-noselect&lt;/code&gt; )在创建缓冲区时都会使用它。</target>
        </trans-unit>
        <trans-unit id="8010635f2bb24a96123a821123a02c24a306bdce" translate="yes" xml:space="preserve">
          <source>The lowest level functions for command input are &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char&lt;/code&gt;, and &lt;code&gt;read-char-exclusive&lt;/code&gt;.</source>
          <target state="translated">命令输入的最低级别功能是 &lt;code&gt;read-event&lt;/code&gt; ， &lt;code&gt;read-char&lt;/code&gt; 和 &lt;code&gt;read-char-exclusive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14145dceb516643fe37d9fc1ff0f68417500b0ec" translate="yes" xml:space="preserve">
          <source>The lowest-level primitive for modifying a &lt;small&gt;CDR&lt;/small&gt; is &lt;code&gt;setcdr&lt;/code&gt;:</source>
          <target state="translated">修改&lt;small&gt;CDR&lt;/small&gt;的最低级别的原语是 &lt;code&gt;setcdr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3f8ff2bd3febbb80e6a03979190f1d4a93f85b99" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;condition-case-unless-debug&lt;/code&gt; provides another way to handle debugging of such forms. It behaves exactly like &lt;code&gt;condition-case&lt;/code&gt;, unless the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, in which case it does not handle any errors at all.</source>
          <target state="translated">宏 &lt;code&gt;condition-case-unless-debug&lt;/code&gt; 提供了另一种方式来处理这种形式的调试。它的行为与 &lt;code&gt;condition-case&lt;/code&gt; 完全相同，除非变量 &lt;code&gt;debug-on-error&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，在这种情况下，它根本不会处理任何错误。</target>
        </trans-unit>
        <trans-unit id="69ddcd0a4bf2d4a7d5ed7f86f791b6ffe043c1a1" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-alternatives&lt;/code&gt; can be used to define &lt;em&gt;generic commands&lt;/em&gt;. These are interactive functions whose implementation can be selected from several alternatives, as a matter of user preference.</source>
          <target state="translated">宏 &lt;code&gt;define-alternatives&lt;/code&gt; 可用于定义&lt;em&gt;通用命令&lt;/em&gt;。这些是交互式功能，根据用户的喜好，可以从多种选择中选择其实现方式。</target>
        </trans-unit>
        <trans-unit id="5119a1b3dc9bf2349246f3d4b6d6761f1510e515" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;define-minor-mode&lt;/code&gt; offers a convenient way of implementing a mode in one self-contained definition.</source>
          <target state="translated">宏 &lt;code&gt;define-minor-mode&lt;/code&gt; 提供了一种在一个独立定义中实现模式的便捷方法。</target>
        </trans-unit>
        <trans-unit id="a18ca22eed3764c8d5592c00e25721489dd6a12d" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;gv-letplace&lt;/code&gt; can be useful in defining macros that perform similarly to &lt;code&gt;setf&lt;/code&gt;; for example, the &lt;code&gt;incf&lt;/code&gt; macro of Common Lisp could be implemented this way:</source>
          <target state="translated">宏 &lt;code&gt;gv-letplace&lt;/code&gt; 有助于定义与 &lt;code&gt;setf&lt;/code&gt; 相似的宏。例如，可以通过以下方式实现Common Lisp的 &lt;code&gt;incf&lt;/code&gt; 宏：</target>
        </trans-unit>
        <trans-unit id="1e1e3b145e098e8f5ecb2f49f1bfd35918691f45" translate="yes" xml:space="preserve">
          <source>The macro cannot be used to suppress file name handlers from magic file names (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">该宏不能用于禁止魔术文件名中的文件名处理程序（请参见&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;魔术文件名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8cf63348f1b08167a736e3e7aac8f62de5938951" translate="yes" xml:space="preserve">
          <source>The macro executes &lt;var&gt;body&lt;/var&gt; normally, but arranges to call the after-change functions just once for a series of several changes&amp;mdash;if that seems safe.</source>
          <target state="translated">宏正常执行 &lt;var&gt;body&lt;/var&gt; ，但安排对一系列更改进行一次调用后更改功能（如果看起来很安全）。</target>
        </trans-unit>
        <trans-unit id="eae48ac7e81744b77b10a9b79e04ee1eb49c6a47" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;push&lt;/code&gt; (see &lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;) and &lt;code&gt;pop&lt;/code&gt; (see &lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;) can manipulate generalized variables, not just lists. &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; removes and returns the first element of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt;, except that it takes care to evaluate all subforms only once. &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; inserts &lt;var&gt;x&lt;/var&gt; at the front of the list stored in &lt;var&gt;place&lt;/var&gt;. It is analogous to &lt;code&gt;(setf
&lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt;, except for evaluation of the subforms. Note that &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; on an &lt;code&gt;nthcdr&lt;/code&gt; place can be used to insert or delete at any position in a list.</source>
          <target state="translated">宏 &lt;code&gt;push&lt;/code&gt; （请参阅&lt;a href=&quot;list-variables#List-Variables&quot;&gt;List Variables&lt;/a&gt;）和 &lt;code&gt;pop&lt;/code&gt; （请参阅&lt;a href=&quot;list-elements#List-Elements&quot;&gt;List Elements&lt;/a&gt;）可以操纵广义变量，而不仅仅是列表。 &lt;code&gt;(pop &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; 删除并返回存储在 &lt;var&gt;place&lt;/var&gt; 的列表的第一个元素。它类似于 &lt;code&gt;(prog1 (car &lt;var&gt;place&lt;/var&gt;) (setf &lt;var&gt;place&lt;/var&gt; (cdr &lt;var&gt;place&lt;/var&gt;)))&lt;/code&gt; ，不同之处在于它只对所有子表单进行一次评估。 &lt;code&gt;(push &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;)&lt;/code&gt; 将 &lt;var&gt;x&lt;/var&gt; 插入存储在 &lt;var&gt;place&lt;/var&gt; 的列表的开头。它类似于 &lt;code&gt;(setf &lt;var&gt;place&lt;/var&gt; (cons &lt;var&gt;x&lt;/var&gt; &lt;var&gt;place&lt;/var&gt;))&lt;/code&gt; ，但评估子表单除外。请注意， &lt;code&gt;nthcdr&lt;/code&gt; 位置上的 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;pop&lt;/code&gt; 可以用于在列表中的任何位置插入或删除。</target>
        </trans-unit>
        <trans-unit id="09c0ddd15714530f62c1af5eecb2c98c7086baee" translate="yes" xml:space="preserve">
          <source>The macros described in this section use &lt;code&gt;pcase&lt;/code&gt; patterns to perform destructuring binding. The condition of the object to be of compatible structure means that the object must match the pattern, because only then the object&amp;rsquo;s subfields can be extracted. For example:</source>
          <target state="translated">本节中描述的宏使用 &lt;code&gt;pcase&lt;/code&gt; 模式执行解构绑定。对象具有兼容结构的条件意味着该对象必须与模式匹配，因为只有这样才能提取该对象的子字段。例如：</target>
        </trans-unit>
        <trans-unit id="f9f8d8ecb58d3451cb2b5457cb2f37a869983a68" translate="yes" xml:space="preserve">
          <source>The main reason for writing an Emacs module is to make additional functions available to Lisp programs that load the module. This subsection describes how to write such &lt;em&gt;module functions&lt;/em&gt;.</source>
          <target state="translated">编写Emacs模块的主要原因是使附加功能可用于加载该模块的Lisp程序。本小节介绍如何编写此类&lt;em&gt;模块功能&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="877426dcb86887eef639d5e653cc17f51b41fa0e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;const&lt;/code&gt; is inside of &lt;code&gt;choice&lt;/code&gt;. For example, &lt;code&gt;(choice integer (const nil))&lt;/code&gt; allows either an integer or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 的主要用途是 &lt;code&gt;choice&lt;/code&gt; 。例如， &lt;code&gt;(choice integer (const nil))&lt;/code&gt; 允许整数或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26e9b14420c609493efab668d934c559a0c3429e" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;current-idle-time&lt;/code&gt; is when an idle timer function wants to &amp;ldquo;take a break&amp;rdquo; for a while. It can set up another idle timer to call the same function again, after a few seconds more idleness. Here&amp;rsquo;s an example:</source>
          <target state="translated">&lt;code&gt;current-idle-time&lt;/code&gt; 的主要用途是当空闲计时器功能想要&amp;ldquo;暂停&amp;rdquo;一会儿时。在闲置几秒钟后，它可以设置另一个空闲计时器以再次调用同一功能。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="530ebc1f037074c726faee61b32cae1039f33cbf" translate="yes" xml:space="preserve">
          <source>The main use of &lt;code&gt;other&lt;/code&gt; is as the last element of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 的主要用途是 &lt;code&gt;choice&lt;/code&gt; 的最后一个元素。例如，</target>
        </trans-unit>
        <trans-unit id="f26c01b277b5d5c1d3d508a4f0fb33a502c2a50b" translate="yes" xml:space="preserve">
          <source>The major mode command may start by calling some other major mode command (called the &lt;em&gt;parent mode&lt;/em&gt;) and then alter some of its settings. A mode that does this is called a &lt;em&gt;derived mode&lt;/em&gt;. The recommended way to define one is to use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, but this is not required. Such a mode should call the parent mode command inside a &lt;code&gt;delay-mode-hooks&lt;/code&gt; form. (Using &lt;code&gt;define-derived-mode&lt;/code&gt; does this automatically.) See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;, and &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">主模式命令可以通过调用一些其他主模式命令（称为&lt;em&gt;父模式&lt;/em&gt;）开始，然后更改其某些设置。执行此操作的&lt;em&gt;模式&lt;/em&gt;称为&lt;em&gt;派生模式&lt;/em&gt;。推荐的一种定义方法是使用 &lt;code&gt;define-derived-mode&lt;/code&gt; 宏，但这不是必需的。这种模式应在 &lt;code&gt;delay-mode-hooks&lt;/code&gt; 表单内调用父模式命令。（使用 &lt;code&gt;define-derived-mode&lt;/code&gt; 自动执行此操作。）请参阅&amp;ldquo;&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生模式&lt;/a&gt;&amp;rdquo;和&amp;ldquo;&lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;模式挂钩&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d17a35b712255a2afb0c14c8a0d624c5811e326" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;major-mode&lt;/code&gt; to the major mode command symbol. This is how &lt;code&gt;describe-mode&lt;/code&gt; discovers which documentation to print.</source>
          <target state="translated">major mode命令应将变量 &lt;code&gt;major-mode&lt;/code&gt; 设置为major mode命令符号。这就是 &lt;code&gt;describe-mode&lt;/code&gt; 如何发现要打印的文档。</target>
        </trans-unit>
        <trans-unit id="cc2e4f72d7acbc5634e4c8fb360f612e207aadac" translate="yes" xml:space="preserve">
          <source>The major mode command should set the variable &lt;code&gt;mode-name&lt;/code&gt; to the &amp;ldquo;pretty&amp;rdquo; name of the mode, usually a string (but see &lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;, for other possible forms). The name of the mode appears in the mode line.</source>
          <target state="translated">major mode命令应将变量 &lt;code&gt;mode-name&lt;/code&gt; 设置为模式的&amp;ldquo;漂亮&amp;rdquo;名称，通常是字符串（但请参见&lt;a href=&quot;mode-line-data#Mode-Line-Data&quot;&gt;Mode Line Data&lt;/a&gt;，以了解其他可能的形式）。模式名称出现在模式行中。</target>
        </trans-unit>
        <trans-unit id="e9542e90f40b187eea4684e0c6016160f19daa55" translate="yes" xml:space="preserve">
          <source>The major mode command should start by calling &lt;code&gt;kill-all-local-variables&lt;/code&gt;. This runs the normal hook &lt;code&gt;change-major-mode-hook&lt;/code&gt;, then gets rid of the buffer-local variables of the major mode previously in effect. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</source>
          <target state="translated">主模式命令应从调用 &lt;code&gt;kill-all-local-variables&lt;/code&gt; 开始。这将运行正常的hook &lt;code&gt;change-major-mode-hook&lt;/code&gt; ，然后摆脱先前有效的主模式的局部缓冲区变量。请参阅&lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;创建Buffer-Local&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4edcb1b916452f2aa05fab479bef5803ee546f7" translate="yes" xml:space="preserve">
          <source>The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level; see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.) If the name begins with a space, the buffer initially disables undo information recording (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;).</source>
          <target state="translated">新创建的缓冲区的主要模式设置为基本模式。（变量 &lt;code&gt;major-mode&lt;/code&gt; 的默认值在更高级别上处理；请参见&lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;。）如果名称以空格开头，则缓冲区最初会禁用撤消信息记录（请参见&lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ba726196ac6572a0dc3557cdc5106eff7f9d6ee0" translate="yes" xml:space="preserve">
          <source>The major mode for the new buffer is set to Fundamental mode. The default value of the variable &lt;code&gt;major-mode&lt;/code&gt; is handled at a higher level. See &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;.</source>
          <target state="translated">新缓冲区的主要模式设置为基本模式。变量 &lt;code&gt;major-mode&lt;/code&gt; 的默认值在更高级别上处理。请参阅&lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;自动专业模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87268c52362ac57b90f14c23d4e6a6de48b2d02a" translate="yes" xml:space="preserve">
          <source>The major mode should usually have its own keymap, which is used as the local keymap in all buffers in that mode. The major mode command should call &lt;code&gt;use-local-map&lt;/code&gt; to install this local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;, for more information.</source>
          <target state="translated">主模式通常应具有自己的键映射，该键映射在该模式下的所有缓冲区中用作本地键映射。major mode命令应调用 &lt;code&gt;use-local-map&lt;/code&gt; 来安装此本地映射。有关更多信息，请参见&lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;活动键盘映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172cb58908f30e86253a48b7781eed8cfd4c158b" translate="yes" xml:space="preserve">
          <source>The major version number of Emacs, as an integer. For Emacs version 23.1, the value is 23.</source>
          <target state="translated">Emacs的主要版本号,为整数。对于Emacs的23.1版本,数值为23。</target>
        </trans-unit>
        <trans-unit id="0d1af093b0fd27af29ab4b28e1513e6dc00a63aa" translate="yes" xml:space="preserve">
          <source>The manual should be fully correct in what it does cover, and it is therefore open to criticism on anything it says&amp;mdash;from specific examples and descriptive text, to the ordering of chapters and sections. If something is confusing, or you find that you have to look at the sources or experiment to learn something not covered in the manual, then perhaps the manual should be fixed. Please let us know.</source>
          <target state="translated">该手册涵盖的内容应完全正确，因此，对于所写内容，无论是具体示例还是说明性文字，以及各章和各部分的顺序，均应接受批评。如果有什么令人困惑的地方，或者您发现必须查看源代码或进行实验以学习手册中未涵盖的内容，则可能应该修复手册。请告诉我们。</target>
        </trans-unit>
        <trans-unit id="a5e22ef195f16823ddf7673778585082a4f46066" translate="yes" xml:space="preserve">
          <source>The mark for the buffer. The mark is a marker, hence it is also included on the list &lt;code&gt;markers&lt;/code&gt;. See &lt;a href=&quot;the-mark#The-Mark&quot;&gt;The Mark&lt;/a&gt;.</source>
          <target state="translated">缓冲区的标记。标记是一个标记，因此它也包含在列表 &lt;code&gt;markers&lt;/code&gt; 。参见&lt;a href=&quot;the-mark#The-Mark&quot;&gt;标记&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b258116b18e88b2e80482d5981d360a38a61fc94" translate="yes" xml:space="preserve">
          <source>The mark is active when this variable is non-&lt;code&gt;nil&lt;/code&gt;. This variable is always buffer-local in each buffer. Do &lt;em&gt;not&lt;/em&gt; use the value of this variable to decide whether a command that normally operates on text near point should operate on the region instead. Use the function &lt;code&gt;use-region-p&lt;/code&gt; for that (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;).</source>
          <target state="translated">当此变量为非 &lt;code&gt;nil&lt;/code&gt; 时，标记处于活动状态。在每个缓冲区中，此变量始终是本地缓冲区的。千万&lt;em&gt;不能&lt;/em&gt;使用这个变量的值来决定，通常在近点文字工作的命令是否应在区域操作来代替。为此 &lt;code&gt;use-region-p&lt;/code&gt; 函数（请参见&lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf467a06fad52dab305b0df8d802a3dd9b6b7599" translate="yes" xml:space="preserve">
          <source>The mark is not active now</source>
          <target state="translated">该标记现在不活跃</target>
        </trans-unit>
        <trans-unit id="2294805a57144c8f475dd286330832439e218b3b" translate="yes" xml:space="preserve">
          <source>The mark specifies a position to bound a range of text for many commands, such as &lt;code&gt;kill-region&lt;/code&gt; and &lt;code&gt;indent-rigidly&lt;/code&gt;. These commands typically act on the text between point and the mark, which is called the &lt;em&gt;region&lt;/em&gt;. If you are writing a command that operates on the region, don&amp;rsquo;t examine the mark directly; instead, use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">标记为许多命令（例如 &lt;code&gt;kill-region&lt;/code&gt; 和 &lt;code&gt;indent-rigidly&lt;/code&gt; )指定了绑定文本范围的位置。这些命令通常作用于点和标记之间的文本（称为&lt;em&gt;region）&lt;/em&gt;。如果要编写在该区域上运行的命令，请不要直接检查标记；相反，使用 &lt;code&gt;interactive&lt;/code&gt; 与'</target>
        </trans-unit>
        <trans-unit id="1b1540074aa53b63216cd2456d72381dd8d0fc52" translate="yes" xml:space="preserve">
          <source>The markers that refer to this buffer. This is actually a single marker, and successive elements in its marker &lt;em&gt;chain&lt;/em&gt; (a linked list) are the other markers referring to this buffer text.</source>
          <target state="translated">引用此缓冲区的标记。这实际上是单个标记，其标记&lt;em&gt;链&lt;/em&gt;（链接列表）中的后续元素是引用此缓冲区文本的其他标记。</target>
        </trans-unit>
        <trans-unit id="bb06b83e3da02615a4f7e9ab6d8336bdd25a1731" translate="yes" xml:space="preserve">
          <source>The matcher processes a &amp;lsquo;</source>
          <target state="translated">匹配器处理&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="92f6e3600296536bb76b7fcd8d76a0af6e42a364" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;e&lt;/em&gt; (2.71828&amp;hellip;).</source>
          <target state="translated">数学常数&lt;em&gt;e&lt;/em&gt;（2.71828&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="1a3e48f3d1745f4908462da41660cc121d6d0f68" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;pi&lt;/em&gt; (3.14159&amp;hellip;).</source>
          <target state="translated">数学常数&lt;em&gt;pi&lt;/em&gt;（3.14159&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="8e605715e3d2691c70b3f21b0b8462b89a7614e5" translate="yes" xml:space="preserve">
          <source>The maximum advance width of the font.</source>
          <target state="translated">字体的最大前进宽度。</target>
        </trans-unit>
        <trans-unit id="978782c408873797cfb6aaf7d660218a112071f9" translate="yes" xml:space="preserve">
          <source>The maximum number of changes that can be amalgamated is controlled by the &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; variable. If this variable is 1, no changes are amalgamated.</source>
          <target state="translated">可以合并的最大更改数由 &lt;code&gt;amalgamating-undo-limit&lt;/code&gt; 变量控制。如果此变量为1，则不会合并任何更改。</target>
        </trans-unit>
        <trans-unit id="82b0cf778d9e1f9d0ac00a5da272e14e2306ca7f" translate="yes" xml:space="preserve">
          <source>The maximum stack size this function needs.</source>
          <target state="translated">该函数需要的最大堆栈大小。</target>
        </trans-unit>
        <trans-unit id="459b7d57f50aecb28cc2870ce7b74f07723e326b" translate="yes" xml:space="preserve">
          <source>The meaning of a list depends on what it contains:</source>
          <target state="translated">列表的意义取决于它所包含的内容。</target>
        </trans-unit>
        <trans-unit id="d3fe651ac40ed9579fa5231d4fcd52354eb5372a" translate="yes" xml:space="preserve">
          <source>The meanings of these list elements are as follows:</source>
          <target state="translated">这些清单要素的含义如下:</target>
        </trans-unit>
        <trans-unit id="12d4b0de515899d94eda4148e6b314c9f86a96b8" translate="yes" xml:space="preserve">
          <source>The menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by the toolkit). Most builds (GTK+, Lucid, Motif and MS-Windows) rely on an external menu bar. NS also uses an external menu bar which, however, is not part of the outer frame. Non-toolkit builds can provide an internal menu bar. On text terminal frames, the menu bar is part of the frame&amp;rsquo;s root window (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). As a rule, menu bars are never shown on child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the menu bar can be suppressed by setting the &lt;code&gt;menu-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">菜单栏（请参阅&lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;菜单栏&lt;/a&gt;）可以是内部的（由Emacs本身绘制）或外部的（由工具箱绘制）。大多数版本（GTK +，Lucid，Motif和MS-Windows）都依赖于外部菜单栏。 NS还使用外部菜单栏，但是它不是外部框架的一部分。非工具包版本可以提供内部菜单栏。在文本终端框架上，菜单栏是框架根窗口的一部分（请参见&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames&lt;/a&gt;）。通常，菜单栏永远不会显示在子框架上（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）。可以通过将 &lt;code&gt;menu-bar-lines&lt;/code&gt; 参数（请参阅&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;）设置为零来抑制菜单栏的显示。</target>
        </trans-unit>
        <trans-unit id="9c36ca261c29f5622700c6f2f7d03d8bacd64def" translate="yes" xml:space="preserve">
          <source>The menu bar does not recalculate which items are enabled every time you look at a menu. This is because the X toolkit requires the whole tree of menus in advance. To force recalculation of the menu bar, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">每次查看菜单时，菜单栏都不会重新计算启用了哪些项目。这是因为X工具箱需要事先提供整个菜单树。要强制重新计算菜单栏，请调用 &lt;code&gt;force-mode-line-update&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;模式行格式&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0671d125fcb3f27fb5c40fddd77a7227205c4dea" translate="yes" xml:space="preserve">
          <source>The menu bar mechanism, which lets you switch between submenus by moving the mouse, cannot look within the definition of a command to see that it calls &lt;code&gt;x-popup-menu&lt;/code&gt;. Therefore, if you try to implement a submenu using &lt;code&gt;x-popup-menu&lt;/code&gt;, it cannot work with the menu bar in an integrated fashion. This is why all menu bar submenus are implemented with menu keymaps within the parent menu, and never with &lt;code&gt;x-popup-menu&lt;/code&gt;. See &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;.</source>
          <target state="translated">菜单栏机制使您可以通过移动鼠标在子菜单之间进行切换，但无法在命令定义中查看它是否调用了 &lt;code&gt;x-popup-menu&lt;/code&gt; 。因此，如果尝试使用 &lt;code&gt;x-popup-menu&lt;/code&gt; 实现子菜单，则该子菜单无法与菜单栏以集成方式一起使用。这就是为什么所有菜单栏子菜单都通过父菜单中的菜单键映射而不是 &lt;code&gt;x-popup-menu&lt;/code&gt; 来实现的原因。请参阅&lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;菜单栏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fccd406d5e813b76ef7a41fe974c95db256bdc6" translate="yes" xml:space="preserve">
          <source>The menu in this example is intended for use with the mouse. If a menu is intended for use with the keyboard, that is, if it is bound to a key sequence ending with a keyboard event, then the menu items should be bound to characters or real function keys, that can be typed with the keyboard.</source>
          <target state="translated">这个例子中的菜单是为了与鼠标一起使用的。如果一个菜单用于键盘,也就是说,如果它绑定到一个以键盘事件结束的键序,那么菜单项应该绑定到可以用键盘输入的字符或实际功能键。</target>
        </trans-unit>
        <trans-unit id="884ca4e3a78e0c7d0eb618828c719ec2bc18c4b5" translate="yes" xml:space="preserve">
          <source>The menu&amp;rsquo;s items are the bindings in the keymap. Each binding associates an event type to a definition, but the event types have no significance for the menu appearance. (Usually we use pseudo-events, symbols that the keyboard cannot generate, as the event types for menu item bindings.) The menu is generated entirely from the bindings that correspond in the keymap to these events.</source>
          <target state="translated">菜单的项目是键盘映射中的绑定。每个绑定都将事件类型与定义关联，但是事件类型对于菜单外观没有任何意义。（通常，使用伪事件，即键盘无法生成的符号，作为菜单项绑定的事件类型。）菜单完全由键映射中与这些事件对应的绑定生成。</target>
        </trans-unit>
        <trans-unit id="4ffe1db1ee3430043bd7d7cfed2fce90a58b2f33" translate="yes" xml:space="preserve">
          <source>The message is &amp;lsquo;</source>
          <target state="translated">消息是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1b4522d132316958b60412509a75ad9dd71138ff" translate="yes" xml:space="preserve">
          <source>The message is &lt;code&gt;Arithmetic range error&lt;/code&gt;.</source>
          <target state="translated">该消息是 &lt;code&gt;Arithmetic range error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14845ac05edc00f5ef9aed326e6a4acbb2d66dc1" translate="yes" xml:space="preserve">
          <source>The message is the empty string. See &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;.</source>
          <target state="translated">该消息是空字符串。请参阅&lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;信令错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a343531eec6204803775063bd43c8b0c3b1e1d7d" translate="yes" xml:space="preserve">
          <source>The message is usually &amp;lsquo;</source>
          <target state="translated">该消息通常是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="a72cf44ed0b2379b5bd18fbbfcf576f977b2239c" translate="yes" xml:space="preserve">
          <source>The meta modifier.</source>
          <target state="translated">元的修饰语。</target>
        </trans-unit>
        <trans-unit id="b1a58020916aba3f6cdf104343f3433939d15e37" translate="yes" xml:space="preserve">
          <source>The meta variants of those characters, with codes in the range of 2**27 to 2**27+127, can also go in the string, but you must change their numeric values. You must set the 2**7 bit instead of the 2**27 bit, resulting in a value between 128 and 255. Only a unibyte string can include these codes.</source>
          <target state="translated">这些字符的元变体,代码范围为2**27到2**27+127,也可以放在字符串中,但必须改变它们的数值。你必须设置2**7位而不是2**27位,结果是128和255之间的值。只有单字节的字符串才能包含这些代码。</target>
        </trans-unit>
        <trans-unit id="9260d6b48ff908594f1c64bdc5084fd35f5bbde1" translate="yes" xml:space="preserve">
          <source>The minibuffer&amp;rsquo;s window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame&amp;rsquo;s other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work &lt;code&gt;resize-mini-windows&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt;.) If the frame contains just a minibuffer window, you can change its size by changing the frame&amp;rsquo;s size.</source>
          <target state="translated">迷你缓冲区的窗口通常是一行；如果内容需要更多空间，它会自动增长。当微型缓冲区处于活动状态时，您可以使用窗口大小调整命令临时显式地调整其窗口大小。退出迷你缓冲区时，窗口将恢复为正常大小。当微型缓冲区处于非活动状态时，您可以通过使用框架的其他窗口中的窗口大小调整命令或用鼠标拖动模式行来永久调整其窗口大小。 （由于当前实现的细节，要使其正常工作， &lt;code&gt;resize-mini-windows&lt;/code&gt; 必须为 &lt;code&gt;nil&lt;/code&gt; 。）如果框架仅包含一个迷你缓冲区窗口，则可以通过更改框架的大小来更改其大小。</target>
        </trans-unit>
        <trans-unit id="fc66b2b22fab10f272a2733f5220517063d244a8" translate="yes" xml:space="preserve">
          <source>The minimum parenthesis depth encountered during this scan.</source>
          <target state="translated">本次扫描中遇到的最小括号深度。</target>
        </trans-unit>
        <trans-unit id="f63caeb9d63ae3ea523b1bd607e47fabe4f9c44a" translate="yes" xml:space="preserve">
          <source>The minor mode should, if possible, support enabling and disabling via Custom (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). To do this, the mode variable should be defined with &lt;code&gt;defcustom&lt;/code&gt;, usually with &lt;code&gt;:type 'boolean&lt;/code&gt;. If just setting the variable is not sufficient to enable the mode, you should also specify a &lt;code&gt;:set&lt;/code&gt; method which enables the mode by invoking the mode command. Note in the variable&amp;rsquo;s documentation string that setting the variable other than via Custom may not take effect. Also, mark the definition with an autoload cookie (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;), and specify a &lt;code&gt;:require&lt;/code&gt; so that customizing the variable will load the library that defines the mode. For example:</source>
          <target state="translated">次要模式应该尽可能支持通过Custom启用和禁用（请参阅&lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;）。为此，应该使用 &lt;code&gt;defcustom&lt;/code&gt; 定义模式变量，通常使用 &lt;code&gt;:type 'boolean&lt;/code&gt; type'boolean。如果仅设置变量不足以启用该模式，则还应该指定 &lt;code&gt;:set&lt;/code&gt; 方法，该方法通过调用mode命令来启用该模式。请注意，在变量的文档字符串中，通过自定义以外的其他方式设置变量可能不会生效。另外，用自动加载cookie标记定义（请参阅&lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;），并指定 &lt;code&gt;:require&lt;/code&gt; ,以便自定义变量将加载定义模式的库。例如：</target>
        </trans-unit>
        <trans-unit id="a754ecbf865ded2f8f972fadc0f979ee00b4c003" translate="yes" xml:space="preserve">
          <source>The minor version number of Emacs, as an integer. For Emacs version 23.1, the value is 1.</source>
          <target state="translated">Emacs的次要版本号,为整数。对于Emacs的23.1版本,数值为1。</target>
        </trans-unit>
        <trans-unit id="1778e11c806e3d03eed718920a2bdcbe70425f0c" translate="yes" xml:space="preserve">
          <source>The mnemonics of keyboard, terminal, and buffer coding systems.</source>
          <target state="translated">键盘、终端、缓冲区编码系统的口令。</target>
        </trans-unit>
        <trans-unit id="d4aa0cdb7029a5f2355863fdbbab99919ce6ce82" translate="yes" xml:space="preserve">
          <source>The mode can specify a local value for &lt;code&gt;eldoc-documentation-function&lt;/code&gt; to tell ElDoc mode how to handle this mode.</source>
          <target state="translated">该模式可以为 &lt;code&gt;eldoc-documentation-function&lt;/code&gt; 指定一个本地值，以告诉ElDoc模式如何处理该模式。</target>
        </trans-unit>
        <trans-unit id="354ca13496161c1669222f09fc05f88ea22e29e9" translate="yes" xml:space="preserve">
          <source>The mode can specify how to complete various keywords by adding one or more buffer-local entries to the special hook &lt;code&gt;completion-at-point-functions&lt;/code&gt;. See &lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;Completion in Buffers&lt;/a&gt;.</source>
          <target state="translated">该模式可以通过将一个或多个缓冲区本地条目添加到特殊的hook &lt;code&gt;completion-at-point-functions&lt;/code&gt; 来指定如何完成各种关键字。请参见&lt;a href=&quot;completion-in-buffers#Completion-in-Buffers&quot;&gt;缓冲区中的完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ced895ea9c1431eb7e76df2f2cbdc9e5d0836c8" translate="yes" xml:space="preserve">
          <source>The mode command should accept one optional argument. If called interactively with no prefix argument, it should toggle the mode (i.e., enable if it is disabled, and disable if it is enabled). If called interactively with a prefix argument, it should enable the mode if the argument is positive and disable it otherwise.</source>
          <target state="translated">mode命令应该接受一个可选参数。如果交互式调用时没有前缀参数,它应该切换模式(即,如果禁用则启用,如果启用则禁用)。如果用前缀参数交互式调用,如果参数为正值,则启用模式,否则禁用。</target>
        </trans-unit>
        <trans-unit id="44819a97a0e2f91469bd3f92a2d58321df9329f0" translate="yes" xml:space="preserve">
          <source>The mode line contents are controlled by a data structure called a &lt;em&gt;mode line construct&lt;/em&gt;, made up of lists, strings, symbols, and numbers kept in buffer-local variables. Each data type has a specific meaning for the mode line appearance, as described below. The same data structure is used for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">模式行内容由称为&lt;em&gt;模式行构造&lt;/em&gt;的数据结构控制，该数据结构由保存在缓冲区局部变量中的列表，字符串，符号和数字组成。每种数据类型对于模式行外观都有特定的含义，如下所述。相同的数据结构用于构造框架标题（请参见&lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;）和标题行（请参见&lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e208e76c5548c1d095dbde47ed20de1a7d12aa6a" translate="yes" xml:space="preserve">
          <source>The mode may have its own abbrev table or may share one with other related modes. If it has its own abbrev table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt;. If the major mode command defines any abbrevs itself, it should pass &lt;code&gt;t&lt;/code&gt; for the &lt;var&gt;system-flag&lt;/var&gt; argument to &lt;code&gt;define-abbrev&lt;/code&gt;. See &lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;Defining Abbrevs&lt;/a&gt;.</source>
          <target state="translated">该模式可以具有其自己的缩写表，或者可以与其他相关模式共享一个表。如果它具有自己的缩写表，则应将其存储在名为 &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-abbrev-table&lt;/code&gt; 的变量中。如果主模式命令本身定义了任何缩写，则应将 &lt;code&gt;t&lt;/code&gt; 的 &lt;var&gt;system-flag&lt;/var&gt; 参数传递给 &lt;code&gt;define-abbrev&lt;/code&gt; 。请参阅&lt;a href=&quot;defining-abbrevs#Defining-Abbrevs&quot;&gt;定义缩写&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="566eebc546ff4022d5692ebd193f3372e5deedf9" translate="yes" xml:space="preserve">
          <source>The mode may have its own syntax table or may share one with other related modes. If it has its own syntax table, it should store this in a variable named &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt;. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">该模式可以具有自己的语法表，或者可以与其他相关模式共享一个。如果它具有自己的语法表，则应将其存储在名为 &lt;code&gt;&lt;var&gt;modename&lt;/var&gt;-mode-syntax-table&lt;/code&gt; 的变量中。请参阅&lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;语法表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7febfb2248d6f317197277153f5791a4f2a7185b" translate="yes" xml:space="preserve">
          <source>The mode should specify how Imenu should find the definitions or sections of a buffer, by setting up a buffer-local value for the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt;, for the two variables &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt;, or for the variable &lt;code&gt;imenu-create-index-function&lt;/code&gt; (see &lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;).</source>
          <target state="translated">该模式应通过为变量 &lt;code&gt;imenu-generic-expression&lt;/code&gt; ，两个变量 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; 和 &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; 设置缓冲区局部值来指定Imenu如何查找缓冲区的定义或部分。-index-name-function，或用于 &lt;code&gt;imenu-create-index-function&lt;/code&gt; 变量（请参阅&lt;a href=&quot;imenu#Imenu&quot;&gt;Imenu&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e819d19cb71035bc2b05451e5471df8840dc6d69" translate="yes" xml:space="preserve">
          <source>The mode should specify how to do highlighting for Font Lock mode, by setting up a buffer-local value for the variable &lt;code&gt;font-lock-defaults&lt;/code&gt; (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;).</source>
          <target state="translated">该模式应通过为变量 &lt;code&gt;font-lock-defaults&lt;/code&gt; 设置缓冲区本地值来指定如何对Font Lock模式进行突出显示（请参见&lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="41a1cfe199d882964dc064f09142206bb96f8e6c" translate="yes" xml:space="preserve">
          <source>The modification time of the visited file. It is set when the file is written or read. Before writing the buffer into a file, this field is compared to the modification time of the file to see if the file has changed on disk. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">访问文件的修改时间。写入或读取文件时设置。在将缓冲区写入文件之前，将该字段与文件的修改时间进行比较，以查看文件在磁盘上是否已更改。请参阅&lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;缓冲区修改&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e9e26b12f5c002c1627a4d332042e4cecc33362" translate="yes" xml:space="preserve">
          <source>The modifiers list for a click event explicitly contains &lt;code&gt;click&lt;/code&gt;, but the event symbol name itself does not contain &amp;lsquo;</source>
          <target state="translated">click事件的修饰符列表明确包含 &lt;code&gt;click&lt;/code&gt; ，但事件符号名称本身不包含'</target>
        </trans-unit>
        <trans-unit id="b3b787746e135e4f51648da476a31670954846cd" translate="yes" xml:space="preserve">
          <source>The momentary display remains until the next input event. If the next input event is &lt;var&gt;char&lt;/var&gt;, &lt;code&gt;momentary-string-display&lt;/code&gt; ignores it and returns. Otherwise, that event remains buffered for subsequent use as input. Thus, typing &lt;var&gt;char&lt;/var&gt; will simply remove the string from the display, while typing (say)</source>
          <target state="translated">瞬时显示将一直保持到下一个输入事件为止。如果下一个输入事件是 &lt;var&gt;char&lt;/var&gt; ，则 &lt;code&gt;momentary-string-display&lt;/code&gt; 忽略它并返回。否则，该事件将保留下来以备后用。因此，在键入（例如）时，键入 &lt;var&gt;char&lt;/var&gt; 只会从显示中删除字符串。</target>
        </trans-unit>
        <trans-unit id="6ccfa1f10310929beb049fb30bcfc7d9086811f9" translate="yes" xml:space="preserve">
          <source>The month of the year, as an integer between 1 and 12.</source>
          <target state="translated">年的月份,是1到12之间的整数。</target>
        </trans-unit>
        <trans-unit id="edb5bce3a7e2bd1bf00ac6d3a9eb55fc41355ba2" translate="yes" xml:space="preserve">
          <source>The most basic primitive for minibuffer input is &lt;code&gt;read-from-minibuffer&lt;/code&gt;, which can be used to read either a string or a Lisp object in textual form. The function &lt;code&gt;read-regexp&lt;/code&gt; is used for reading regular expressions (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;), which are a special kind of string. There are also specialized functions for reading commands, variables, file names, etc. (see &lt;a href=&quot;completion#Completion&quot;&gt;Completion&lt;/a&gt;).</source>
          <target state="translated">最小缓冲区输入的最基本原语是 &lt;code&gt;read-from-minibuffer&lt;/code&gt; ，它可用于以文本形式读取字符串或Lisp对象。函数 &lt;code&gt;read-regexp&lt;/code&gt; 用于读取正则表达式（请参阅&lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;正则表达式&lt;/a&gt;），这是一种特殊的字符串。还有一些专门的功能可以读取命令，变量，文件名等（请参阅&lt;a href=&quot;completion#Completion&quot;&gt;Completion&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="04571e47b6db6005c0928b2d449f301cebe34f7a" translate="yes" xml:space="preserve">
          <source>The most basic way to alter the contents of an existing string is with &lt;code&gt;aset&lt;/code&gt; (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;). &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt;
&lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; stores &lt;var&gt;char&lt;/var&gt; into &lt;var&gt;string&lt;/var&gt; at index &lt;var&gt;idx&lt;/var&gt;. Each character occupies one or more bytes, and if &lt;var&gt;char&lt;/var&gt; needs a different number of bytes from the character already present at that index, &lt;code&gt;aset&lt;/code&gt; signals an error.</source>
          <target state="translated">更改现有字符串内容的最基本方法是使用 &lt;code&gt;aset&lt;/code&gt; （参见&lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;）。 &lt;code&gt;(aset &lt;var&gt;string&lt;/var&gt; &lt;var&gt;idx&lt;/var&gt; &lt;var&gt;char&lt;/var&gt;)&lt;/code&gt; 将 &lt;var&gt;char&lt;/var&gt; 存储到索引为 &lt;var&gt;idx&lt;/var&gt; 的 &lt;var&gt;string&lt;/var&gt; 中。每个字符占用一个或多个字节，并且如果 &lt;var&gt;char&lt;/var&gt; 需要与该索引处已经存在的字符不同的字节数，则 &lt;code&gt;aset&lt;/code&gt; 表示错误。</target>
        </trans-unit>
        <trans-unit id="bf4dd793bfdf67867b9bdc6495e0ff90954bd76e" translate="yes" xml:space="preserve">
          <source>The most basic way to use the expression parser is to tell it to start at a given position with a certain state, and parse up to a specified end position.</source>
          <target state="translated">使用表达式解析器的最基本方法是告诉它从某个状态的给定位置开始,并解析到指定的结束位置。</target>
        </trans-unit>
        <trans-unit id="b7f2a6fce568eb37624dbc5a896f8aecf156540b" translate="yes" xml:space="preserve">
          <source>The most common items to autoload are the interactive entry points to a library. For example, if</source>
          <target state="translated">最常见的自动加载项目是库的交互式入口。例如,如果</target>
        </trans-unit>
        <trans-unit id="00ce30cf3da30f9ec9b191e1b5b38d0ab5c7d881" translate="yes" xml:space="preserve">
          <source>The most common problem in writing macros is doing some of the real work prematurely&amp;mdash;while expanding the macro, rather than in the expansion itself. For instance, one real package had this macro definition:</source>
          <target state="translated">编写宏时，最常见的问题是过早地完成了一些实际工作，同时扩展了宏，而不是扩展本身。例如，一个实际的包装具有以下宏定义：</target>
        </trans-unit>
        <trans-unit id="2cf92a8ba2845654523982a452093a675127ce73" translate="yes" xml:space="preserve">
          <source>The most common reason to use &lt;code&gt;:require&lt;/code&gt; is when a variable enables a feature such as a minor mode, and just setting the variable won&amp;rsquo;t have any effect unless the code which implements the mode is loaded.</source>
          <target state="translated">使用 &lt;code&gt;:require&lt;/code&gt; 的最常见原因是变量启用了诸如次要模式之类的功能，并且仅设置变量不会有任何效果，除非加载了实现该模式的代码。</target>
        </trans-unit>
        <trans-unit id="00d251711d163f90f5dc973380466e863d64f7b0" translate="yes" xml:space="preserve">
          <source>The most common repeat events are &lt;em&gt;double-click&lt;/em&gt; events. Emacs generates a double-click event when you click a button twice; the event happens when you release the button (as is normal for all click events).</source>
          <target state="translated">最常见的重复事件是&lt;em&gt;双击&lt;/em&gt;事件。当您单击两次按钮时，Emacs会生成一个双击事件。该事件在您释放按钮时发生（这是所有单击事件的正常现象）。</target>
        </trans-unit>
        <trans-unit id="57850c0a76ab6f2efce7f9ee07926b9e3846b613" translate="yes" xml:space="preserve">
          <source>The most common use of buffer-local bindings is for major modes to change variables that control the behavior of commands. For example, C mode and Lisp mode both set the variable &lt;code&gt;paragraph-start&lt;/code&gt; to specify that only blank lines separate paragraphs. They do this by making the variable buffer-local in the buffer that is being put into C mode or Lisp mode, and then setting it to the new value for that mode. See &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;.</source>
          <target state="translated">缓冲区局部绑定的最常见用法是用于主要模式，以更改控制命令行为的变量。例如，C模式和Lisp模式都将变量 &lt;code&gt;paragraph-start&lt;/code&gt; 为指定仅空行分隔段落。他们通过在进入C模式或Lisp模式的缓冲区中使变量局部变量化，然后将其设置为该模式的新值来实现。请参阅&lt;a href=&quot;major-modes#Major-Modes&quot;&gt;主要模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="702580a0fb96dc0456829bb764ce3a637ffd43c4" translate="yes" xml:space="preserve">
          <source>The most common way of invoking a function is by evaluating a list. For example, evaluating the list &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; calls the function &lt;code&gt;concat&lt;/code&gt; with arguments &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt;. See &lt;a href=&quot;evaluation#Evaluation&quot;&gt;Evaluation&lt;/a&gt;, for a description of evaluation.</source>
          <target state="translated">调用功能的最常见方法是评估列表。例如，对列表 &lt;code&gt;(concat &quot;a&quot; &quot;b&quot;)&lt;/code&gt; 求值会调用带有参数 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;b&quot;&lt;/code&gt; &lt;code&gt;concat&lt;/code&gt; 函数。有关&lt;a href=&quot;evaluation#Evaluation&quot;&gt;评估&lt;/a&gt;的说明，请参见评估。</target>
        </trans-unit>
        <trans-unit id="d131735a093456a7b6d24f8f667e2b2a59acf4e8" translate="yes" xml:space="preserve">
          <source>The most common way to compute the length of a list, when you are not worried that it may be circular, is with &lt;code&gt;length&lt;/code&gt;. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">当您不担心列表可能是圆形时，最常见的计算列表长度的方法是使用 &lt;code&gt;length&lt;/code&gt; 。请参阅&lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;序列函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="347c946e7276a21392ff141fa45e82a75d88329c" translate="yes" xml:space="preserve">
          <source>The most general of the two facilities is controlled by the variable &lt;code&gt;format-alist&lt;/code&gt;, a list of &lt;em&gt;file format&lt;/em&gt; specifications, which describe textual representations used in files for the data in an Emacs buffer. The descriptions for reading and writing are paired, which is why we call this &amp;ldquo;round-trip&amp;rdquo; specification (see &lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;Format Conversion Piecemeal&lt;/a&gt;, for non-paired specification).</source>
          <target state="translated">这两种功能中最通用的是由变量 &lt;code&gt;format-alist&lt;/code&gt; 控制的，它是&lt;em&gt;文件格式&lt;/em&gt;规范的列表，这些规范描述文件中用于Emacs缓冲区中数据的文本表示形式。读写的描述是成对的，这就是为什么我们称此为&amp;ldquo;往返&amp;rdquo;规范（有关非成对规范，请参见&lt;a href=&quot;format-conversion-piecemeal#Format-Conversion-Piecemeal&quot;&gt;Format Conversion Piecemeal&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cd8ccdf82fe4e52359af0e8e7311554e454e5dd4" translate="yes" xml:space="preserve">
          <source>The most general way to check the type of an object is to call the function &lt;code&gt;type-of&lt;/code&gt;. Recall that each object belongs to one and only one primitive type; &lt;code&gt;type-of&lt;/code&gt; tells you which one (see &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;). But &lt;code&gt;type-of&lt;/code&gt; knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than &lt;code&gt;type-of&lt;/code&gt;.</source>
          <target state="translated">检查对象类型的最通用方法是调用函数 &lt;code&gt;type-of&lt;/code&gt; 。回想一下，每个对象都属于一个且只有一个原始类型； &lt;code&gt;type-of&lt;/code&gt; 会告诉您哪一个（请参阅&lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp数据类型&lt;/a&gt;）。但是 &lt;code&gt;type-of&lt;/code&gt; 对非基本类型一无所知。在大多数情况下，使用类型谓词比 &lt;code&gt;type-of&lt;/code&gt; 更方便。</target>
        </trans-unit>
        <trans-unit id="c939ba5fb7000b3ef15a75258275fafbcfabe6bd" translate="yes" xml:space="preserve">
          <source>The most important time to enter the debugger is when a Lisp error happens. This allows you to investigate the immediate causes of the error.</source>
          <target state="translated">进入调试器最重要的时间是当Lisp错误发生时。这允许你调查错误的直接原因。</target>
        </trans-unit>
        <trans-unit id="18cb17b94649eed8921d3ce73d54ecd88ad00023" translate="yes" xml:space="preserve">
          <source>The most simple approach to make a new atomic window is to take an existing internal window and apply the following function:</source>
          <target state="translated">制作一个新的原子窗口的最简单的方法是取一个现有的内部窗口并应用以下函数。</target>
        </trans-unit>
        <trans-unit id="e1e8fa969491d0969bdb64f111c245755eef7fdd" translate="yes" xml:space="preserve">
          <source>The mutex ensures atomicity, and the loop is for robustness&amp;mdash;there may be spurious notifications.</source>
          <target state="translated">互斥锁确保原子性，而循环则是为了健壮性-可能存在虚假通知。</target>
        </trans-unit>
        <trans-unit id="20600bb0132abd59b71aa3abecbc6c3c79d7ed11" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; is an alias for this macro.</source>
          <target state="translated">名称 &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; 是此宏的别名。</target>
        </trans-unit>
        <trans-unit id="0164386da8dab74b0dca8dc21998a6981ad8f3bc" translate="yes" xml:space="preserve">
          <source>The name &lt;var&gt;property&lt;/var&gt; is compared with the existing property names using &lt;code&gt;eq&lt;/code&gt;, so any object is a legitimate property.</source>
          <target state="translated">使用 &lt;code&gt;eq&lt;/code&gt; 将name &lt;var&gt;property&lt;/var&gt; 与现有属性名称进行比较，因此任何对象都是合法属性。</target>
        </trans-unit>
        <trans-unit id="81686d309fb6971d2f0465f17ae4fbda5d84fd34" translate="yes" xml:space="preserve">
          <source>The name of a face from which to inherit attributes, or a list of face names. Attributes from inherited faces are merged into the face like an underlying face would be, with higher priority than underlying faces (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If the face to inherit from is &lt;code&gt;unspecified&lt;/code&gt;, it is treated the same as &lt;code&gt;nil&lt;/code&gt;, since Emacs never merges &lt;code&gt;:inherit&lt;/code&gt; attributes. If a list of faces is used, attributes from faces earlier in the list override those from later faces.</source>
          <target state="translated">要从中继承属性的人脸名称，或人脸名称列表。继承的面孔的属性像基础面孔一样被合并到面孔中，其优先级高于基础面孔（请参见&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;显示面孔&lt;/a&gt;）。如果 &lt;code&gt;unspecified&lt;/code&gt; 要继承的面孔，则将其与 &lt;code&gt;nil&lt;/code&gt; 相同，因为Emacs从未合并 &lt;code&gt;:inherit&lt;/code&gt; 属性。如果使用面孔列表，则列表中较早面孔的属性会覆盖较晚面孔的属性。</target>
        </trans-unit>
        <trans-unit id="f14b4e7f3d214e623215de71ea76c596c58a8147" translate="yes" xml:space="preserve">
          <source>The name of an existing buffer. By default, uses the name of the current buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">现有缓冲区的名称。默认情况下，使用当前缓冲区的名称（请参阅&lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;）。现有，完成，默认，提示。</target>
        </trans-unit>
        <trans-unit id="2d3de7a674caef56f2edb7325689eee077d5c503" translate="yes" xml:space="preserve">
          <source>The name of the &lt;em&gt;font foundry&lt;/em&gt; for the font family specified by the &lt;code&gt;:family&lt;/code&gt; attribute (a string). See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;:family&lt;/code&gt; 属性指定的字体家族的&lt;em&gt;字体铸造厂&lt;/em&gt;名称（字符串）。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;字体&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="d84e4020bfcfa0d5df12e11e36810c5a458fbc2c" translate="yes" xml:space="preserve">
          <source>The name of the application sending the notification. The default is &lt;code&gt;notifications-application-name&lt;/code&gt;.</source>
          <target state="translated">发送通知的应用程序的名称。默认值为 &lt;code&gt;notifications-application-name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31bc03ff12180dc54cb103b5e65b3d301c362de1" translate="yes" xml:space="preserve">
          <source>The name of the command that runs in the process. This is a string that usually specifies the name of the executable file of the process, without the leading directories. However, some special system processes can report strings that do not correspond to an executable file of a program.</source>
          <target state="translated">进程中运行的命令名称。这是一个字符串,通常指定进程的可执行文件的名称,不含前导目录。但是,一些特殊的系统进程可以报告与程序的可执行文件不对应的字符串。</target>
        </trans-unit>
        <trans-unit id="dd51404aec6b7e3516493114c0df7bd668d69bf8" translate="yes" xml:space="preserve">
          <source>The name of the device used by the terminal (e.g., &amp;lsquo;</source>
          <target state="translated">终端使用的设备名称（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="86223234e995255179c7f5ed59ad98c61222e8f0" translate="yes" xml:space="preserve">
          <source>The name of the file visited in this buffer, or &lt;code&gt;nil&lt;/code&gt;. This is the value of the buffer-local variable &lt;code&gt;buffer-file-name&lt;/code&gt; (see &lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;Buffer File Name&lt;/a&gt;).</source>
          <target state="translated">在此缓冲区中访问的文件名，或 &lt;code&gt;nil&lt;/code&gt; 。这是缓冲区局部变量 &lt;code&gt;buffer-file-name&lt;/code&gt; 的值（请参阅&lt;a href=&quot;buffer-file-name#Buffer-File-Name&quot;&gt;缓冲区文件名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9cf516df8bd70dd62a0f6c98d528269943f52170" translate="yes" xml:space="preserve">
          <source>The name of the font for displaying text in the frame. This is a string, either a valid font name for your system or the name of an Emacs fontset (see &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;). It is equivalent to the &lt;code&gt;font&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">在框架中显示文本的字体名称。这是一个字符串，可以是您系统的有效字体名称，也可以是Emacs字体集的名称（请参阅&lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;）。它等效于 &lt;code&gt;default&lt;/code&gt; 面孔的 &lt;code&gt;font&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c12d93ce989364c1c7d4f9a741900cf941c5dab1" translate="yes" xml:space="preserve">
          <source>The name of the frame. The frame name serves as a default for the frame title, if the &lt;code&gt;title&lt;/code&gt; parameter is unspecified or &lt;code&gt;nil&lt;/code&gt;. If you don&amp;rsquo;t specify a name, Emacs sets the frame name automatically (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">框架的名称。如果未指定 &lt;code&gt;title&lt;/code&gt; 参数或 &lt;code&gt;nil&lt;/code&gt; ，则框架名称将作为框架标题的默认名称。如果未指定名称，则Emacs会自动设置框架名称（请参阅&lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;框架标题&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d46a694cb309b5635ce7fcf75332cf135b35bc90" translate="yes" xml:space="preserve">
          <source>The name of the keysym that should stand for the Control modifier (respectively, for Alt, Meta, Hyper, and Super). For example, here is how to swap the Meta and Alt modifiers within Emacs:</source>
          <target state="translated">应该代表控制修饰符的键名(分别代表Alt、Meta、Hyper和Super)。例如,下面是如何在Emacs中交换Meta和Alt修饰符的方法。</target>
        </trans-unit>
        <trans-unit id="ea60fe57d26ab008b617db1ef54c09ed08318866" translate="yes" xml:space="preserve">
          <source>The name of the package is the same as the base name of the file, as written on the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">包的名称与文件的基本名称相同，如第一行所示。这里是 '</target>
        </trans-unit>
        <trans-unit id="e21cb3a697575e4abea29254c179c8f2f42f271b" translate="yes" xml:space="preserve">
          <source>The name of the process. If &lt;var&gt;name&lt;/var&gt; is not given, &lt;var&gt;port&lt;/var&gt; will serve as the process name as well.</source>
          <target state="translated">进程的名称。如果未提供 &lt;var&gt;name&lt;/var&gt; ，则 &lt;var&gt;port&lt;/var&gt; 也将用作进程名称。</target>
        </trans-unit>
        <trans-unit id="33d6a32c269c144c63e53d0f2cba19c64ba4f020" translate="yes" xml:space="preserve">
          <source>The name of the terminal that the subprocess is using, or &lt;code&gt;nil&lt;/code&gt; if it is using pipes.</source>
          <target state="translated">子进程正在使用的终端的名称；如果正在使用管道，则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb41db266496240f445c6fb5baacf0f57a720b53" translate="yes" xml:space="preserve">
          <source>The name of the variable in the C sources.</source>
          <target state="translated">C源中的变量名称。</target>
        </trans-unit>
        <trans-unit id="a4f65da0bf349454db5eb2650407f2361527b7b0" translate="yes" xml:space="preserve">
          <source>The name of the variable to be used by Lisp programs.</source>
          <target state="translated">Lisp程序要使用的变量名称。</target>
        </trans-unit>
        <trans-unit id="3670965055037b4c4d3b2f88fc9e6bd05ff338ee" translate="yes" xml:space="preserve">
          <source>The name of this format.</source>
          <target state="translated">这种格式的名称。</target>
        </trans-unit>
        <trans-unit id="8b92537c9d27af39ba1f11b476a35f30e67426f9" translate="yes" xml:space="preserve">
          <source>The name to use in the icon for this frame, when and if the icon appears. If this is &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s title is used.</source>
          <target state="translated">出现图标时（如果出现）在此框架的图标中使用的名称。如果为 &lt;code&gt;nil&lt;/code&gt; ，则使用框架的标题。</target>
        </trans-unit>
        <trans-unit id="773601ddb143e48334daba0a066ba237e287a6d6" translate="yes" xml:space="preserve">
          <source>The name used to open the font, a string.</source>
          <target state="translated">用于打开字体的名称,一个字符串。</target>
        </trans-unit>
        <trans-unit id="8fcccebb07f7dee6937b0795494fd79034dd2f04" translate="yes" xml:space="preserve">
          <source>The named &lt;var&gt;method&lt;/var&gt; was defined by using &lt;code&gt;cl-defmethod&lt;/code&gt;, with &lt;var&gt;specializers&lt;/var&gt; as its specializers.</source>
          <target state="translated">命名 &lt;var&gt;method&lt;/var&gt; ，通过使用定义的 &lt;code&gt;cl-defmethod&lt;/code&gt; ，与 &lt;var&gt;specializers&lt;/var&gt; 作为其specializers。</target>
        </trans-unit>
        <trans-unit id="fe3c2e352de1a3150f44a8697619e4fda0c3a43a" translate="yes" xml:space="preserve">
          <source>The names &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; &lt;small&gt;CAR&lt;/small&gt; was an instruction to extract the contents of the address part of a register, and &lt;small&gt;CDR&lt;/small&gt; an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function &lt;code&gt;cons&lt;/code&gt; that creates them, which in turn was named for its purpose, the construction of cells.</source>
          <target state="translated">名称&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;源自Lisp的历史。最初的Lisp实现在IBM 704计算机上运行，​​该计算机将单词分为地址和减量两部分。&lt;small&gt;CAR&lt;/small&gt;是提取寄存器的地址部分内容的指令，而&lt;small&gt;CDR&lt;/small&gt;是提取减量内容的指令。相比之下，cons单元是根据创建它们的功能 &lt;code&gt;cons&lt;/code&gt; 命名的，而功能cons又因其目的而被命名为单元的构造。</target>
        </trans-unit>
        <trans-unit id="ba31422c908b55bb35be7435bbd860d86c29702f" translate="yes" xml:space="preserve">
          <source>The native position of a frame is the reference position for functions that set or return the current position of the mouse (see &lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Mouse Position&lt;/a&gt;) and for functions dealing with the position of windows like &lt;code&gt;window-edges&lt;/code&gt;, &lt;code&gt;window-at&lt;/code&gt; or &lt;code&gt;coordinates-in-window-p&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;). It also specifies the (0, 0) origin for locating and positioning child frames within this frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">框架的原始位置是设置或返回鼠标当前位置的功能（请参见&lt;a href=&quot;mouse-position#Mouse-Position&quot;&gt;Mouse Position&lt;/a&gt;）以及处理诸如 &lt;code&gt;window-edges&lt;/code&gt; ， &lt;code&gt;window-at&lt;/code&gt; 边缘或窗口 &lt;code&gt;coordinates-in-window-p&lt;/code&gt; 类的窗口位置的函数的参考位置-p（请参阅&lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;坐标和Windows&lt;/a&gt;）。它还指定了（0，0）原点，用于在此框架中定位和定位子框架（请参见&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="79b45725606655f4197b9ae82b2b82dab59aede2" translate="yes" xml:space="preserve">
          <source>The native size of a frame is the size Emacs passes to the window-system or window manager when creating or resizing the frame from within Emacs. It is also the size Emacs receives from the window-system or window manager whenever these resize the frame&amp;rsquo;s window-system window, for example, after maximizing the frame by clicking on the corresponding button in the title bar or when dragging its external border with the mouse.</source>
          <target state="translated">框架的原始大小是Emacs在Emacs中创建框架或调整框架大小时传递给窗口系统或窗口管理器的大小。这也是Emacs从窗口系统或窗口管理器接收到的大小，无论它们何时调整框架的窗口系统窗口的大小，例如，通过单击标题栏中的相应按钮来最大化框架，或者使用鼠。</target>
        </trans-unit>
        <trans-unit id="14825e98a6bb7730ba468267f3c379f4d50eadd3" translate="yes" xml:space="preserve">
          <source>The network mask.</source>
          <target state="translated">网络掩码。</target>
        </trans-unit>
        <trans-unit id="7fc5eefdbee523b516c3a56d241e65616fe5cea8" translate="yes" xml:space="preserve">
          <source>The new command &lt;var&gt;variant&lt;/var&gt; is defined to call the function &lt;var&gt;parent&lt;/var&gt;, then override certain aspects of that parent mode:</source>
          <target state="translated">新的命令 &lt;var&gt;variant&lt;/var&gt; 定义为调用函数 &lt;var&gt;parent&lt;/var&gt; ，然后覆盖该父模式的某些方面：</target>
        </trans-unit>
        <trans-unit id="5ce6d115e553357dfd304409824efeb325dc1b14" translate="yes" xml:space="preserve">
          <source>The new definition of &lt;code&gt;for&lt;/code&gt; has a new problem: it introduces a local variable named &lt;code&gt;max&lt;/code&gt; which the user does not expect. This causes trouble in examples such as the following:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 的新定义有一个新问题：它引入了一个用户不希望使用的名为 &lt;code&gt;max&lt;/code&gt; 的局部变量。这会在以下示例中引起麻烦：</target>
        </trans-unit>
        <trans-unit id="6a336356f22c547d590556ea521f2dad738c8349" translate="yes" xml:space="preserve">
          <source>The new fontset has two names, one long and one short. The long name is &lt;var&gt;fontpattern&lt;/var&gt; in its entirety. The short name is &amp;lsquo;</source>
          <target state="translated">新字体集有两个名称，一个长和一个短。长名称全部是 &lt;var&gt;fontpattern&lt;/var&gt; 。简称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c3a411aa70ab9bb343c22475f4a8a3db7a1aaaa6" translate="yes" xml:space="preserve">
          <source>The new marker&amp;rsquo;s insertion type is specified by the argument &lt;var&gt;insertion-type&lt;/var&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">新标记的插入类型由参数 &lt;var&gt;insertion-type&lt;/var&gt; 指定。请参见&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;标记插入类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e53ad877e538af9a720bbb66ac6ff5d4008840d4" translate="yes" xml:space="preserve">
          <source>The new mode has its own abbrev table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:abbrev-table&lt;/code&gt; keyword (see below).</source>
          <target state="translated">新的模式有它自己的缩写表，保存在变量 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-abbrev-table&lt;/code&gt; ，除非你重写此使用 &lt;code&gt;:abbrev-table&lt;/code&gt; 的关键字（见下文）。</target>
        </trans-unit>
        <trans-unit id="b817ae5e0fd787bbcf07fe3487597358970c4e96" translate="yes" xml:space="preserve">
          <source>The new mode has its own mode hook, &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt;. It runs this hook, after running the hooks of its ancestor modes, with &lt;code&gt;run-mode-hooks&lt;/code&gt;, as the last thing it does, apart from running any &lt;code&gt;:after-hook&lt;/code&gt; form it may have. See &lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;Mode Hooks&lt;/a&gt;.</source>
          <target state="translated">新的模式有它自己的模式挂钩， &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-hook&lt;/code&gt; 。除了运行它可能具有的任何 &lt;code&gt;:after-hook&lt;/code&gt; 形式外，它还会在运行其祖先模式的钩子之后再运行 &lt;code&gt;run-mode-hooks&lt;/code&gt; 来运行此钩子。请参阅&lt;a href=&quot;mode-hooks#Mode-Hooks&quot;&gt;模式挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00570ab789edcc32fb33047192ad9e67acc9f749" translate="yes" xml:space="preserve">
          <source>The new mode has its own sparse keymap, named &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt;. &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s keymap the parent of the new map, unless &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; is already set and already has a parent.</source>
          <target state="translated">新的模式都有自己稀疏的键盘映射，名为 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; 。 &lt;code&gt;define-derived-mode&lt;/code&gt; 使父模式的键盘映射成为新映射的父映射，除非已经设置了 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-map&lt;/code&gt; &lt;var&gt;variant&lt;/var&gt; 并且已经有一个父映射。</target>
        </trans-unit>
        <trans-unit id="945a91028fd0f8fc9a5b05174767e7c35cb3f960" translate="yes" xml:space="preserve">
          <source>The new mode has its own syntax table, kept in the variable &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless you override this using the &lt;code&gt;:syntax-table&lt;/code&gt; keyword (see below). &lt;code&gt;define-derived-mode&lt;/code&gt; makes the parent mode&amp;rsquo;s syntax-table the parent of &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt;, unless the latter is already set and already has a parent different from the standard syntax table.</source>
          <target state="translated">新的模式有它自己的语法表，保存在变量 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; ，除非你重写此使用 &lt;code&gt;:syntax-table&lt;/code&gt; 的关键字（见下文）。 &lt;code&gt;define-derived-mode&lt;/code&gt; 使父模式的语法表成为 &lt;code&gt;&lt;var&gt;variant&lt;/var&gt;-syntax-table&lt;/code&gt; -table的父表，除非后者已设置且其父表与标准语法表不同。</target>
        </trans-unit>
        <trans-unit id="c2597cc1d2ff3aeb01d30bac9fc3cde7623c9599" translate="yes" xml:space="preserve">
          <source>The new thread is created with no local variable bindings in effect. The new thread&amp;rsquo;s current buffer is inherited from the current thread.</source>
          <target state="translated">创建新线程时没有有效的局部变量绑定。新线程的当前缓冲区是从当前线程继承的。</target>
        </trans-unit>
        <trans-unit id="8df0e83e8de1eb380770375b9be1ffb711a27047" translate="yes" xml:space="preserve">
          <source>The newest element in the ring always has index 0. Higher indices correspond to older elements. Indices are computed modulo the ring length. Index -1 corresponds to the oldest element, -2 to the next-oldest, and so forth.</source>
          <target state="translated">环中最新的元素总是有0的索引,更高的索引对应较老的元素。指数是以环长为模数计算的。索引-1对应最老的元素,-2对应次老的元素,以此类推。</target>
        </trans-unit>
        <trans-unit id="8e1c114485b4df403bf7d12c30cb8c0fba64430c" translate="yes" xml:space="preserve">
          <source>The newline character (character code 10) has a special effect: it ends the preceding line and starts a new line.</source>
          <target state="translated">换行符(字符代码10)有一个特殊的效果:它结束前一行,开始新的一行。</target>
        </trans-unit>
        <trans-unit id="2e9517c16f2af179f8f22773bf78a93935c17bc6" translate="yes" xml:space="preserve">
          <source>The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline&amp;mdash;one that is preceded by &amp;lsquo;</source>
          <target state="translated">换行符在字符串的读取语法中并不特殊；如果在双引号之间写了新行，则它将成为字符串中的字符。但是转义的换行符-前面带有'</target>
        </trans-unit>
        <trans-unit id="4efa69ac3b7f005e072f33b3c4d9d2015117589e" translate="yes" xml:space="preserve">
          <source>The next &lt;code&gt;pred&lt;/code&gt; (lines 4-5) evaluates &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; and matches if the result is non-&lt;code&gt;nil&lt;/code&gt;, which means that &lt;var&gt;expval&lt;/var&gt; has the desired form: &lt;code&gt;key:NUMBER&lt;/code&gt;. Again, failing this, &lt;code&gt;pred&lt;/code&gt; fails and &lt;code&gt;and&lt;/code&gt;, too.</source>
          <target state="translated">下一个 &lt;code&gt;pred&lt;/code&gt; （第4-5行）求值 &lt;code&gt;(string-match&amp;nbsp;RX&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; ，如果结果为非 &lt;code&gt;nil&lt;/code&gt; ，则匹配，这意味着 &lt;var&gt;expval&lt;/var&gt; 具有所需的形式： &lt;code&gt;key:NUMBER&lt;/code&gt; 。同样，如果失败， &lt;code&gt;pred&lt;/code&gt; 也将失败，并且 &lt;code&gt;and&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7694837921d35a54e56c860831d6080ffe61e74" translate="yes" xml:space="preserve">
          <source>The next and previous sibling of this window as Lisp objects. &lt;code&gt;next&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the window is the right-most or bottom-most in its group; &lt;code&gt;prev&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if it is the left-most or top-most in its group. Whether the sibling is left/right or up/down is determined by the &lt;code&gt;horizontal&lt;/code&gt; field of the sibling&amp;rsquo;s parent: if it&amp;rsquo;s non-zero, the siblings are arranged horizontally.</source>
          <target state="translated">此窗口作为Lisp对象的下一个和上一个同级对象。如果窗口在其组中最右边或最底部，则 &lt;code&gt;next&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ;否则为nil。如果 &lt;code&gt;prev&lt;/code&gt; 是其组中最左侧或最顶部，则为 &lt;code&gt;nil&lt;/code&gt; 。同级是左/右还是上/下是由同级父级的 &lt;code&gt;horizontal&lt;/code&gt; 字段确定的：如果非零，则同级是水平排列的。</target>
        </trans-unit>
        <trans-unit id="20020241f8b21f6f1b62e467e43654e312585449" translate="yes" xml:space="preserve">
          <source>The next four arguments to &lt;code&gt;sort-subr&lt;/code&gt; are functions that are called to move point across a sort record. They are called many times from within &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sort-subr&lt;/code&gt; 的下四个参数是调用这些函数以在排序记录上移动点的函数。它们在 &lt;code&gt;sort-subr&lt;/code&gt; 中被多次调用。</target>
        </trans-unit>
        <trans-unit id="6e6df56c6cfd59f81e1889be41424dbd8e05af1c" translate="yes" xml:space="preserve">
          <source>The next four functions all return markers with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;.</source>
          <target state="translated">接下来的四个函数都返回插入类型为 &lt;code&gt;nil&lt;/code&gt; 的标记。请参见&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;标记插入类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6e450313c4033e8457df931e4950913eecef97c" translate="yes" xml:space="preserve">
          <source>The next redisplay after resumption will redraw the entire screen, unless the variable &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;Refresh Screen&lt;/a&gt;.</source>
          <target state="translated">恢复后的下一次重新显示将重绘整个屏幕，除非变量 &lt;code&gt;no-redraw-on-reenter&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 。请参阅&lt;a href=&quot;refresh-screen#Refresh-Screen&quot;&gt;刷新屏幕&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c62480706c4435432f9cbd719f04c8c0e8d4d4b" translate="yes" xml:space="preserve">
          <source>The next step is to determine precisely what is wrong. There is no way to be sure of this except by studying the program, but often the existing indentation is a clue to where the parentheses should have been. The easiest way to use this clue is to reindent with</source>
          <target state="translated">下一步就是要准确地判断出问题所在。除了研究程序外,没有办法确定,但往往现有的缩进是一个线索,可以知道括号应该在哪里。最简单的方法是用以下方法重新缩进</target>
        </trans-unit>
        <trans-unit id="e881ec82dc043025b05e415a53a5307e0b9d1a7c" translate="yes" xml:space="preserve">
          <source>The next subsection describes how to define your own fringe bitmaps.</source>
          <target state="translated">下一小节介绍如何定义自己的边缘位图。</target>
        </trans-unit>
        <trans-unit id="28f5894deb6be2c66452b9dec8f473fdb6fefb38" translate="yes" xml:space="preserve">
          <source>The next two commands are similar to &lt;code&gt;switch-to-buffer&lt;/code&gt;, except for the described features.</source>
          <target state="translated">接下来的两个命令除了描述的功能外，与 &lt;code&gt;switch-to-buffer&lt;/code&gt; 相似。</target>
        </trans-unit>
        <trans-unit id="7cc9290c0d0d2e4b42ba908efb154f702ea15fc9" translate="yes" xml:space="preserve">
          <source>The next two functions either return the argument &lt;var&gt;string&lt;/var&gt;, or a newly created string with no text properties.</source>
          <target state="translated">接下来的两个函数要么返回参数 &lt;var&gt;string&lt;/var&gt; ，要么返回没有文本属性的新创建的字符串。</target>
        </trans-unit>
        <trans-unit id="c1bc1e54049d4149bb73763e09a0583d8724361a" translate="yes" xml:space="preserve">
          <source>The next two functions signal an error if the mark does not point anywhere. If Transient Mark mode is enabled and &lt;code&gt;mark-even-if-inactive&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, they also signal an error if the mark is inactive.</source>
          <target state="translated">如果标记未指向任何地方，则接下来的两个功能会发出错误信号。如果启用了临时标记模式，并且 &lt;code&gt;mark-even-if-inactive&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，如果标记无效，它们也会发出错误消息。</target>
        </trans-unit>
        <trans-unit id="377df722feabe51756819277064a7bd38601469b" translate="yes" xml:space="preserve">
          <source>The non-printable &lt;em&gt;&lt;acronym&gt;ASCII&lt;/acronym&gt; control characters&lt;/em&gt;&amp;mdash;character codes 0 through 31, as well as the</source>
          <target state="translated">不可打印的&lt;em&gt;&lt;acronym&gt;ASCII&lt;/acronym&gt;控制字符-字符&lt;/em&gt;代码0到31，以及</target>
        </trans-unit>
        <trans-unit id="ce617211fc2ab0bb06bc37aae9e870737adcb1d5" translate="yes" xml:space="preserve">
          <source>The nonce is currently unused and only some MACs support it.</source>
          <target state="translated">nonce目前还没有使用,只有部分MAC支持。</target>
        </trans-unit>
        <trans-unit id="72d8a158209595f8bea693b50b579072c4c32b6d" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to get the window system&amp;rsquo;s clipboard as the most recent kill, even if the selection belongs to another application. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;. However, if the clipboard contents come from the current Emacs session, this function should return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">此功能的正常使用是使窗口系统的剪贴板成为最新的杀手，即使该选择属于另一个应用程序也是如此。请参阅&lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;窗口系统选择&lt;/a&gt;。但是，如果剪贴板内容来自当前的Emacs会话，则此函数应返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4d1f4d52266035590d8daa8fadfd0297361c08" translate="yes" xml:space="preserve">
          <source>The normal use of this function is to put newly killed text in the window system&amp;rsquo;s clipboard. See &lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;Window System Selections&lt;/a&gt;.</source>
          <target state="translated">此功能的正常使用是将新杀死的文本放入窗口系统的剪贴板中。请参阅&lt;a href=&quot;window-system-selections#Window-System-Selections&quot;&gt;窗口系统选择&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe1cb8bbe65ec53be9067206dd1dfa6d2cad2dca" translate="yes" xml:space="preserve">
          <source>The normal value of this variable includes &lt;code&gt;user-error&lt;/code&gt;, as well as several errors that happen often during editing but rarely result from bugs in Lisp programs. However, &amp;ldquo;rarely&amp;rdquo; is not &amp;ldquo;never&amp;rdquo;; if your program fails with an error that matches this list, you may try changing this list to debug the error. The easiest way is usually to set &lt;code&gt;debug-ignored-errors&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">该变量的正常值包括 &lt;code&gt;user-error&lt;/code&gt; ，以及在编辑过程中经常发生但很少由Lisp程序中的错误引起的一些错误。但是，&amp;ldquo;很少&amp;rdquo;不是&amp;ldquo;从不&amp;rdquo;。如果您的程序由于与该列表匹配的错误而失败，则可以尝试更改此列表以调试错误。最简单的方法通常是将 &lt;code&gt;debug-ignored-errors&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="615cf55184d1614679df8cf6d2cbadac0179b9d2" translate="yes" xml:space="preserve">
          <source>The normal way to use this feature is that the &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; functions add this property, as well as others, to the characters they operate on. That way, they avoid being called over and over for the same text.</source>
          <target state="translated">使用此功能的正常方法是 &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; 函数将此属性以及其他属性添加到它们所操作的字符上。这样，它们避免了针对同一文本一遍又一遍的调用。</target>
        </trans-unit>
        <trans-unit id="5bf403f55157eac254eec47b71824c0e07ba8c39" translate="yes" xml:space="preserve">
          <source>The normal way to use this function is after reading text from a file without decoding, if you decide you would rather have decoded it. Instead of deleting the text and reading it again, this time with decoding, you can call this function.</source>
          <target state="translated">正常情况下,使用这个函数的方法是在从文件中读取文本而不进行解码后,如果你决定宁可对其进行解码。你可以调用这个函数,而不是删除文本,然后再读一遍,这次是解码的。</target>
        </trans-unit>
        <trans-unit id="14a4051b3db7273c333fed729bd4705f42b76cf0" translate="yes" xml:space="preserve">
          <source>The notification &lt;var&gt;id&lt;/var&gt; that this notification replaces. &lt;var&gt;id&lt;/var&gt; must be the result of a previous &lt;code&gt;notifications-notify&lt;/code&gt; call.</source>
          <target state="translated">该通知替换的通知 &lt;var&gt;id&lt;/var&gt; 。 &lt;var&gt;id&lt;/var&gt; 必须是先前的 &lt;code&gt;notifications-notify&lt;/code&gt; 呼叫的结果。</target>
        </trans-unit>
        <trans-unit id="235facb694a3673208a66d292afda77da06ef3e0" translate="yes" xml:space="preserve">
          <source>The notification body text. Depending on the implementation of the notification server, the text could contain HTML markups, like &amp;lsquo;</source>
          <target state="translated">通知正文文本。根据通知服务器的实现，文本可能包含HTML标记，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d6d14187af51bbbd99a616baf65fac010ae3eeaf" translate="yes" xml:space="preserve">
          <source>The notification title.</source>
          <target state="translated">通知标题;</target>
        </trans-unit>
        <trans-unit id="e447b4e8d9dde9805fe495b79d88178d76f80ab4" translate="yes" xml:space="preserve">
          <source>The number and significance of the objects in &lt;var&gt;data&lt;/var&gt; depends on &lt;var&gt;error-symbol&lt;/var&gt;. For example, with a &lt;code&gt;wrong-type-argument&lt;/code&gt; error, there should be two objects in the list: a predicate that describes the type that was expected, and the object that failed to fit that type.</source>
          <target state="translated">&lt;var&gt;data&lt;/var&gt; 对象的数量和重要性取决于 &lt;var&gt;error-symbol&lt;/var&gt; 。例如，如果有一个 &lt;code&gt;wrong-type-argument&lt;/code&gt; 错误，则列表中应该有两个对象：一个描述期望类型的谓词，以及一个不适合该类型的对象。</target>
        </trans-unit>
        <trans-unit id="77b891078bd95b24372c2265e2e2cd84fcd84a78" translate="yes" xml:space="preserve">
          <source>The number of &amp;lsquo;</source>
          <target state="translated">的数量 '</target>
        </trans-unit>
        <trans-unit id="69d9f447f26ab68125cf7f7418e7b287e062c516" translate="yes" xml:space="preserve">
          <source>The number of bits per byte, which can be 7 or 8. If &lt;var&gt;bytesize&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 8.</source>
          <target state="translated">每个字节的位数，可以为7或8。如果未指定 &lt;var&gt;bytesize&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则默认为8。</target>
        </trans-unit>
        <trans-unit id="e69db1d2aafc1ecd874d0fd32605ef1930ae4340" translate="yes" xml:space="preserve">
          <source>The number of bool vector entries stored for each row; the smallest multiple of 8 greater than or equal to &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">每行存储的布尔向量条目的数量；大于或等于 &lt;var&gt;width&lt;/var&gt; 的8的最小倍数。</target>
        </trans-unit>
        <trans-unit id="0c696104f1d296d98cbf922f187ea8cac7fb9e83" translate="yes" xml:space="preserve">
          <source>The number of buffer objects in use. This includes killed buffers invisible to users, i.e., all buffers in &lt;code&gt;all_buffers&lt;/code&gt; list.</source>
          <target state="translated">正在使用的缓冲区对象的数量。这包括用户看不见的已 &lt;code&gt;all_buffers&lt;/code&gt; 缓冲区，即all_buffers列表中的所有缓冲区。</target>
        </trans-unit>
        <trans-unit id="252d4f28db846bbf940d1217fadcdf56740580e5" translate="yes" xml:space="preserve">
          <source>The number of characters at the start and end of the text that are known to be unchanged since the last complete redisplay.</source>
          <target state="translated">自上次完整重新显示以来,已知文本开头和结尾处未发生变化的字符数。</target>
        </trans-unit>
        <trans-unit id="89a302eaa04563e94b2b926ac658405d57a2374e" translate="yes" xml:space="preserve">
          <source>The number of cons cells for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">已从操作系统获得空间但目前尚未使用的弊端单元数;</target>
        </trans-unit>
        <trans-unit id="928cf9ce73beb664ce217349a8d5e6418448c470" translate="yes" xml:space="preserve">
          <source>The number of cons cells in use.</source>
          <target state="translated">使用中的弊端单元数。</target>
        </trans-unit>
        <trans-unit id="24f7af3992f54804406740120a68503980b1aaf3" translate="yes" xml:space="preserve">
          <source>The number of currently active &lt;code&gt;unwind-protect&lt;/code&gt; forms counts, together with the number of local variable bindings, against the limit &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;).</source>
          <target state="translated">针对限制 &lt;code&gt;max-specpdl-size&lt;/code&gt; 的限制，当前活动的 &lt;code&gt;unwind-protect&lt;/code&gt; 表单的数量以及局部变量绑定的数量（请参阅&lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;局部变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9c35725bb13e2859f8f990b1b6c1b4705566676f" translate="yes" xml:space="preserve">
          <source>The number of currently active calls to &lt;code&gt;eval&lt;/code&gt; is limited to &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see below).</source>
          <target state="translated">当前对 &lt;code&gt;eval&lt;/code&gt; 的活动调用数限制为 &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="26632f6fb1891fe7db7e3348f1653f11addc21e8" translate="yes" xml:space="preserve">
          <source>The number of floats for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">已从操作系统获得空间,但目前尚未使用的浮点数。</target>
        </trans-unit>
        <trans-unit id="f76646dd4182a8fa6a14d755790c6c7d2864f09c" translate="yes" xml:space="preserve">
          <source>The number of floats in use.</source>
          <target state="translated">使用中的浮动数。</target>
        </trans-unit>
        <trans-unit id="7d151b45b0c5d7e9e3c605630f35524687f27612" translate="yes" xml:space="preserve">
          <source>The number of free slots in all vector blocks.</source>
          <target state="translated">所有向量块的自由槽数。</target>
        </trans-unit>
        <trans-unit id="7a5cbacf926b1512cd0ba23780e03b3e4a98118a" translate="yes" xml:space="preserve">
          <source>The number of intervals for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">已从操作系统获得空间但目前尚未使用的间隔数。</target>
        </trans-unit>
        <trans-unit id="602801cbd4078754bb74d81473f6f900a3e284ba" translate="yes" xml:space="preserve">
          <source>The number of intervals in use.</source>
          <target state="translated">使用的区间数。</target>
        </trans-unit>
        <trans-unit id="92de848307ab335b54cbbb276e13709bea52b86a" translate="yes" xml:space="preserve">
          <source>The number of lines to allocate at the top of the frame for a menu bar (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The default is one if Menu Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;Menu Bars&lt;/a&gt; in</source>
          <target state="translated">要在框架顶部为菜单栏分配的行数（请参阅&lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;菜单栏&lt;/a&gt;）。如果启用了菜单栏模式，则默认值为1，否则为0。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars&quot;&gt;菜单栏&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="5827e772cc5045e135130ea07603e84be0177d9b" translate="yes" xml:space="preserve">
          <source>The number of lines to use for the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;). The default is one if Tool Bar mode is enabled and zero otherwise. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">工具栏要使用的行数（请参阅&lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;工具栏&lt;/a&gt;）。如果启用了工具栏模式，则默认值为1，否则为0。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;工具栏&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="c7f4d7c21579924cbdecd9574578a0259e96375a" translate="yes" xml:space="preserve">
          <source>The number of major page faults caused by the process since its beginning. (Major page faults require a disk to be read, and are thus more expensive than minor page faults.)</source>
          <target state="translated">自进程开始以来,由该进程引起的主要页面故障的数量(主要页面故障需要读取磁盘,因此比次要页面故障更昂贵)。(主要的页面故障需要读取一个磁盘,因此比次要的页面故障更昂贵)。</target>
        </trans-unit>
        <trans-unit id="190fa917612a525a4d94c58578c9ab17ff36e051" translate="yes" xml:space="preserve">
          <source>The number of minor page faults caused by the process since its beginning. (Minor page faults are those that don&amp;rsquo;t involve reading from disk.)</source>
          <target state="translated">自该过程开始以来由该过程引起的次要页面错误数。（较小的页面错误是那些不涉及从磁盘读取的错误。）</target>
        </trans-unit>
        <trans-unit id="9d5ec76f037793ae468581429ef386612dd124f8" translate="yes" xml:space="preserve">
          <source>The number of minutes past the hour, as an integer between 0 and 59.</source>
          <target state="translated">小时后的分钟数,是0到59之间的整数。</target>
        </trans-unit>
        <trans-unit id="ad0f8ee15c9aa29fe5fb9cbe7ca13d4d44b5ef6a" translate="yes" xml:space="preserve">
          <source>The number of names the file has (&lt;code&gt;file-attribute-link-number&lt;/code&gt;). Alternate names, also known as hard links, can be created by using the &lt;code&gt;add-name-to-file&lt;/code&gt; function (see &lt;a href=&quot;changing-files#Changing-Files&quot;&gt;Changing Files&lt;/a&gt;).</source>
          <target state="translated">文件具有的名称数（ &lt;code&gt;file-attribute-link-number&lt;/code&gt; ）。备用名称（也称为硬链接）可以通过使用&amp;ldquo; &lt;code&gt;add-name-to-file&lt;/code&gt; 功能来创建（请参阅&amp;ldquo;&lt;a href=&quot;changing-files#Changing-Files&quot;&gt;更改文件&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="325baa1e7adcb16dc50f6245d77c21d0debe4ede" translate="yes" xml:space="preserve">
          <source>The number of pixels from the top of the scroll bar to the click position. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从滚动条顶部到单击位置的像素数。在某些工具包（包括GTK +）上，Emacs无法提取此数据，因此该值始终为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81f70c31bc5858d0b9ea55feb80b52d7b0622a5a" translate="yes" xml:space="preserve">
          <source>The number of seconds past the minute, with form described below.</source>
          <target state="translated">过分钟的秒数,形式如下:</target>
        </trans-unit>
        <trans-unit id="16f645a9b7573d7e0be85843502b2537b32b9812" translate="yes" xml:space="preserve">
          <source>The number of slots in all used vectors. Slot counts might include some or all overhead from vector headers, depending on the platform.</source>
          <target state="translated">所有使用的向量中的槽数。槽数可能包括部分或全部向量头的开销,取决于平台。</target>
        </trans-unit>
        <trans-unit id="b4c7e2965ba0ba590e73e99ea618e58e9f048f9a" translate="yes" xml:space="preserve">
          <source>The number of stopbits used to terminate a transmission of each byte. &lt;var&gt;stopbits&lt;/var&gt; can be 1 or 2. If &lt;var&gt;stopbits&lt;/var&gt; is not given or &lt;code&gt;nil&lt;/code&gt;, it defaults to 1.</source>
          <target state="translated">用于终止每个字节传输的停止位数量。 &lt;var&gt;stopbits&lt;/var&gt; 可以为1或2。如果未指定 &lt;var&gt;stopbits&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则默认为1。</target>
        </trans-unit>
        <trans-unit id="584465d6a9c8121efa55f5d37a6a82a27d12aa63" translate="yes" xml:space="preserve">
          <source>The number of string headers for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">已从操作系统获得空间,但目前尚未使用的字符串头的数量。</target>
        </trans-unit>
        <trans-unit id="11eee3b04765f2e7c114ec5eb04da8bccc9c8d67" translate="yes" xml:space="preserve">
          <source>The number of string headers in use.</source>
          <target state="translated">正在使用的字符串头的数量。</target>
        </trans-unit>
        <trans-unit id="2adc6fb63d1bc6a3331dbbc9b05d0c9bd724c7c7" translate="yes" xml:space="preserve">
          <source>The number of symbols for which space has been obtained from the operating system, but that are not currently being used.</source>
          <target state="translated">已从操作系统获得空间但目前尚未使用的符号数量。</target>
        </trans-unit>
        <trans-unit id="710444e67e6d2313474db8860db1bd9ce9d6ab60" translate="yes" xml:space="preserve">
          <source>The number of symbols in use.</source>
          <target state="translated">使用的符号数量。</target>
        </trans-unit>
        <trans-unit id="88b7053411bf3b3b073ba4f231a1da2711e2f38c" translate="yes" xml:space="preserve">
          <source>The number of threads in the process.</source>
          <target state="translated">进程中的线程数。</target>
        </trans-unit>
        <trans-unit id="7d720d63753916813fff9649510319aa14c02852" translate="yes" xml:space="preserve">
          <source>The number of vector headers allocated from the vector blocks.</source>
          <target state="translated">从向量块中分配的向量头的数量。</target>
        </trans-unit>
        <trans-unit id="59b6b2c7dabce2307e6e799dfef671c14314174a" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">数字前缀参数。（请注意，此&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="839e8e25e1178c7a8e748322d0c3fe4ba4cb103f" translate="yes" xml:space="preserve">
          <source>The numeric prefix argument; but if there is no prefix argument, read a number as with</source>
          <target state="translated">数字前缀参数;但如果没有前缀参数,则读一个数字,如</target>
        </trans-unit>
        <trans-unit id="439b92119e69deb37b60614763a2c3dea4cdbbe6" translate="yes" xml:space="preserve">
          <source>The numerical priority of the process.</source>
          <target state="translated">流程的优先级数字。</target>
        </trans-unit>
        <trans-unit id="7fe81b17fc17a93e95e511a73b78731b8a8de04d" translate="yes" xml:space="preserve">
          <source>The numerical process group ID of the foreground process group that uses the process&amp;rsquo;s terminal.</source>
          <target state="translated">使用进程终端的前台进程组的数字进程组ID。</target>
        </trans-unit>
        <trans-unit id="6fa1cb69c8ffa6967bb6548d178d71e54c8286e1" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;nil&lt;/code&gt;, in addition to its other meanings, may be used as a stream. It stands for the value of the variable &lt;code&gt;standard-input&lt;/code&gt; or &lt;code&gt;standard-output&lt;/code&gt;. Also, the object &lt;code&gt;t&lt;/code&gt; as a stream specifies input using the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or output in the echo area (see &lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;The Echo Area&lt;/a&gt;).</source>
          <target state="translated">对象 &lt;code&gt;nil&lt;/code&gt; 除了其其他含义外，还可以用作流。它代表变量 &lt;code&gt;standard-input&lt;/code&gt; 或 &lt;code&gt;standard-output&lt;/code&gt; 的值。同样，作为流的对象 &lt;code&gt;t&lt;/code&gt; 使用&lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;minibuffer&lt;/a&gt;（请参见Minibuffers）指定输入，或在echo区域（请参见&lt;a href=&quot;the-echo-area#The-Echo-Area&quot;&gt;Echo Area&lt;/a&gt;）中指定输出。</target>
        </trans-unit>
        <trans-unit id="39f7982b68fb4ab2fb51b7f5f14923219a3d96cd" translate="yes" xml:space="preserve">
          <source>The object &lt;var&gt;name&lt;/var&gt; is a character (an integer) identifying the register.</source>
          <target state="translated">对象 &lt;var&gt;name&lt;/var&gt; 是标识寄存器的字符（整数）。</target>
        </trans-unit>
        <trans-unit id="6833fa0e8edf6ce4aefb60918006191561783d76" translate="yes" xml:space="preserve">
          <source>The objects returned by &lt;code&gt;current-window-configuration&lt;/code&gt; die together with the Emacs process. In order to store a window configuration on disk and read it back in another Emacs session, you can use the functions described next. These functions are also useful to clone the state of a frame into an arbitrary live window (&lt;code&gt;set-window-configuration&lt;/code&gt; effectively clones the windows of a frame into the root window of that very frame only).</source>
          <target state="translated">&lt;code&gt;current-window-configuration&lt;/code&gt; 返回的对象与Emacs进程一起消失。为了将窗口配置存储在磁盘上并在另一个Emacs会话中读回，您可以使用下面描述的功能。这些功能对于将帧的状态克隆到任意活动窗口中也很有用（ &lt;code&gt;set-window-configuration&lt;/code&gt; 仅将帧的窗口克隆到该帧的根窗口中）。</target>
        </trans-unit>
        <trans-unit id="72b9bbaab48ff0495bbabbd0f0bb821e6641bf93" translate="yes" xml:space="preserve">
          <source>The offset in pixels from the</source>
          <target state="translated">画面的偏移量,以像素为单位。</target>
        </trans-unit>
        <trans-unit id="ad4a9f69cf841ef935ee2cfa1f4bc790f26c9421" translate="yes" xml:space="preserve">
          <source>The operating system groups files into directories. To specify a file, you must specify the directory and the file&amp;rsquo;s name within that directory. Therefore, Emacs considers a file name as having two main parts: the &lt;em&gt;directory name&lt;/em&gt; part, and the &lt;em&gt;nondirectory&lt;/em&gt; part (or &lt;em&gt;file name within the directory&lt;/em&gt;). Either part may be empty. Concatenating these two parts reproduces the original file name.</source>
          <target state="translated">操作系统将文件分组到目录中。要指定文件，必须指定目录以及该目录中的文件名。因此，Emacs认为文件名包含两个主要部分：&lt;em&gt;目录名&lt;/em&gt;部分和&lt;em&gt;非&lt;/em&gt;&lt;em&gt;目录&lt;/em&gt;部分（或&lt;em&gt;directory中的文件名&lt;/em&gt;）。任一部分都可能为空。将这两个部分串联在一起将复制原始文件名。</target>
        </trans-unit>
        <trans-unit id="97b655f463790a01acf5417028d665f4f17aa3ca" translate="yes" xml:space="preserve">
          <source>The operation for which certain handlers are presently inhibited.</source>
          <target state="translated">目前抑制某些处理者的操作。</target>
        </trans-unit>
        <trans-unit id="a54beb7452d09412de65a317f1da762f7220f206" translate="yes" xml:space="preserve">
          <source>The operation of inserting text in a buffer also calls the functions listed in the &lt;code&gt;insert-in-front-hooks&lt;/code&gt; property of the following character and in the &lt;code&gt;insert-behind-hooks&lt;/code&gt; property of the preceding character. These functions receive two arguments, the beginning and end of the inserted text. The functions are called &lt;em&gt;after&lt;/em&gt; the actual insertion takes place.</source>
          <target state="translated">在缓冲区中插入文本的操作还调用后一个字符的 &lt;code&gt;insert-in-front-hooks&lt;/code&gt; 属性和前一个字符的 &lt;code&gt;insert-behind-hooks&lt;/code&gt; 属性中列出的函数。这些函数接收两个参数，即插入文本的开头和结尾。在实际插入发生&lt;em&gt;后&lt;/em&gt;调用这些函数。</target>
        </trans-unit>
        <trans-unit id="0102d351953df3a2b1f375d80803fca9ebb0a776" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;resize-mini-windows&lt;/code&gt; does not affect the behavior of minibuffer-only frames (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). The following option allows to automatically resize such frames as well.</source>
          <target state="translated">选项 &lt;code&gt;resize-mini-windows&lt;/code&gt; 不会影响仅使用迷你缓冲区的帧的行为（请参见&lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;）。以下选项也可以自动调整此类框架的大小。</target>
        </trans-unit>
        <trans-unit id="ab3586d91a06c5d8405e148f25236777a77f39af" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; and the &lt;code&gt;buffer-predicate&lt;/code&gt; (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;) of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame affect this command as they do for &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; 框架的选项 &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; 和 &lt;code&gt;buffer-predicate&lt;/code&gt; （请参阅&lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;）会影响此命令，就像 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="c4c6688ae5450a1940363973e63c9245b847575d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; described below can be used to inhibit switching to certain buffers, for example, to those already shown in another window. Also, if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame has a &lt;code&gt;buffer-predicate&lt;/code&gt; parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;), that predicate may inhibit switching to certain buffers.</source>
          <target state="translated">下文所述的选项&amp;ldquo; &lt;code&gt;switch-to-prev-buffer-skip&lt;/code&gt; 可用于禁止切换到某些缓冲区，例如切换到已经在另一个窗口中显示的缓冲区。另外，如果 &lt;var&gt;window&lt;/var&gt; 的框架具有 &lt;code&gt;buffer-predicate&lt;/code&gt; 参数（请参见&lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;），则该谓词可能会禁止切换到某些缓冲区。</target>
        </trans-unit>
        <trans-unit id="835de90b506ab91ee5ca88e6c356759c82274cd9" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;form&lt;/var&gt; argument specifies the timestamp form to be returned. If &lt;var&gt;form&lt;/var&gt; is the symbol &lt;code&gt;integer&lt;/code&gt;, this function returns an integer count of seconds. If &lt;var&gt;form&lt;/var&gt; is a positive integer, it specifies a clock frequency and this function returns an integer-pair timestamp &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt;
. &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;.&lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt; If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function treats it as a positive integer suitable for representing the timestamp; for example, it is treated as 1000000000 if &lt;var&gt;time&lt;/var&gt; is nil and the platform timestamp has nanosecond resolution. If &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;list&lt;/code&gt;, this function returns an integer list &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;. Although an omitted or &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;form&lt;/var&gt; currently acts like &lt;code&gt;list&lt;/code&gt;, this is planned to change in a future Emacs version, so callers requiring list timestamps should pass &lt;code&gt;list&lt;/code&gt; explicitly.</source>
          <target state="translated">可选的 &lt;var&gt;form&lt;/var&gt; 参数指定要返回的时间戳格式。如果 &lt;var&gt;form&lt;/var&gt; 是符号 &lt;code&gt;integer&lt;/code&gt; ，则此函数返回秒的整数计数。如果 &lt;var&gt;form&lt;/var&gt; 是一个正整数，它指定了一个时钟频率和该函数返回一个整数对的时间戳 &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; 。&lt;a href=&quot;#FOOT25&quot; name=&quot;DOCF25&quot;&gt;&lt;sup&gt;25&lt;/sup&gt;&lt;/a&gt;如果 &lt;var&gt;form&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则此函数将其视为适合表示时间戳的正整数；例如，如果 &lt;var&gt;time&lt;/var&gt; 为零且平台时间戳具有纳秒分辨率，则将其视为1000000000 。如果 &lt;var&gt;form&lt;/var&gt; 是 &lt;code&gt;list&lt;/code&gt; ，该函数返回一个整数列表 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; 。尽管当前省略或 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;form&lt;/var&gt; 类似于 &lt;code&gt;list&lt;/code&gt; ，但计划在将来的Emacs版本中对此进行更改，因此需要列表时间戳的调用者应显式传递 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="173acab42d67698663274d178deb55ac822fd58b" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;function&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a function to call with no arguments, to get the user&amp;rsquo;s attention.</source>
          <target state="translated">可选 &lt;var&gt;function&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）是不带参数调用的函数，以引起用户的注意。</target>
        </trans-unit>
        <trans-unit id="426453a518362f581ab8e263e39b1b78287360b0" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;pred&lt;/var&gt; argument provides a predicate that controls which buffers to ask about (or to save silently if &lt;var&gt;save-silently-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;). If &lt;var&gt;pred&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to use the value of &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; instead of &lt;var&gt;pred&lt;/var&gt;. If the result is &lt;code&gt;nil&lt;/code&gt;, it means ask only about file-visiting buffers. If it is &lt;code&gt;t&lt;/code&gt;, that means also offer to save certain other non-file buffers&amp;mdash;those that have a non-&lt;code&gt;nil&lt;/code&gt; buffer-local value of &lt;code&gt;buffer-offer-save&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;). A user who says &amp;lsquo;</source>
          <target state="translated">可选的 &lt;var&gt;pred&lt;/var&gt; 参数提供了一个谓词，该谓词控制要询问的缓冲区（或在 &lt;var&gt;save-silently-p&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 时静默保存）。如果 &lt;var&gt;pred&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则意味着使用 &lt;code&gt;save-some-buffers-default-predicate&lt;/code&gt; 的值代替 &lt;var&gt;pred&lt;/var&gt; 。如果结果为 &lt;code&gt;nil&lt;/code&gt; ，则意味着仅询问有关文件访问缓冲区的信息。如果它是 &lt;code&gt;t&lt;/code&gt; ，这意味着还提供保存某些其它非文件缓冲器-那些具有非 &lt;code&gt;nil&lt;/code&gt; 的缓冲器本地值 &lt;code&gt;buffer-offer-save&lt;/code&gt; （见&lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;杀缓冲器&lt;/a&gt;）。一个说&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3b490b732241cae65bd40b66849ce93f50354a12" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;qualifier&lt;/var&gt; allows combining several applicable methods. If it is not present, the defined method is a &lt;em&gt;primary&lt;/em&gt; method, responsible for providing the primary implementation of the generic function for the specialized arguments. You can also define &lt;em&gt;auxiliary methods&lt;/em&gt;, by using one of the following values as &lt;var&gt;qualifier&lt;/var&gt;:</source>
          <target state="translated">可选的 &lt;var&gt;qualifier&lt;/var&gt; 允许组合几种适用的方法。如果不存在，则定义的方法是&lt;em&gt;主要&lt;/em&gt;方法，负责为专用参数提供通用函数的主要实现。您还可以通过使用以下值之一作为 &lt;var&gt;qualifier&lt;/var&gt; 来定义&lt;em&gt;辅助方法&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="7e8b24c5a3bacf003c936b526cc2b8bc5211832b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;accept-default-p&lt;/var&gt; determines whether a coding system selected without user interaction is acceptable. If it&amp;rsquo;s omitted or &lt;code&gt;nil&lt;/code&gt;, such a silent selection is always acceptable. If it is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; &lt;code&gt;select-safe-coding-system&lt;/code&gt; calls this function with one argument, the base coding system of the selected coding system. If the function returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;select-safe-coding-system&lt;/code&gt; rejects the silently selected coding system, and asks the user to select a coding system from a list of possible candidates.</source>
          <target state="translated">可选参数 &lt;var&gt;accept-default-p&lt;/var&gt; 确定在没有用户交互的情况下选择的编码系统是否可接受。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则始终可以接受这种无声选择。如果为非 &lt;code&gt;nil&lt;/code&gt; ，则应为函数；否则为null。 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 用一个参数调用此函数，该参数是所选编码系统的基本编码系统。如果函数返回 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 拒绝静默选择的编码系统，并要求用户从可能的候选列表中选择一个编码系统。</target>
        </trans-unit>
        <trans-unit id="e961ebb3cc87375ff53fb5dbd5c797ff74355be5" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;access-type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should specify the kind of access that will trigger obsolescence warnings; it can be either &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;access-type&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）应指定将触发过时警告的访问类型；否则为false。它可以是 &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18e8faa626ed3c723b0d4b24ea36af13079f989a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;action&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should normally be a display action (described above). &lt;code&gt;display-buffer&lt;/code&gt; builds a list of action functions and an action alist, by consolidating display actions from the following sources (in order of their precedence, from highest to lowest):</source>
          <target state="translated">可选参数 &lt;var&gt;action&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）通常应为显示操作（如上所述）。 &lt;code&gt;display-buffer&lt;/code&gt; 通过合并来自以下来源的显示动作（按优先级从高到低的顺序）来构建动作功能列表和动作列表：</target>
        </trans-unit>
        <trans-unit id="86a332db454bd3dbba8b146d609ae20fa7e68ddc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;add&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies how to add &lt;var&gt;font-spec&lt;/var&gt; to the font specifications previously set. If it is &lt;code&gt;prepend&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is prepended. If it is &lt;code&gt;append&lt;/code&gt;, &lt;var&gt;font-spec&lt;/var&gt; is appended. By default, &lt;var&gt;font-spec&lt;/var&gt; overrides the previous settings.</source>
          <target state="translated">可选参数 &lt;var&gt;add&lt;/var&gt; ，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则指定如何将 &lt;var&gt;font-spec&lt;/var&gt; 添加到先前设置的字体规范中。如果它是 &lt;code&gt;prepend&lt;/code&gt; ，则 &lt;var&gt;font-spec&lt;/var&gt; 为前置。如果为 &lt;code&gt;append&lt;/code&gt; ，则将附加 &lt;var&gt;font-spec&lt;/var&gt; 。默认情况下， &lt;var&gt;font-spec&lt;/var&gt; 会覆盖以前的设置。</target>
        </trans-unit>
        <trans-unit id="f8a3ae8e924fd8f4d27674f1685f4ee6a3fbe53e" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; has the same meaning as in &lt;code&gt;next-window&lt;/code&gt;, like a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;minibuf&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;all-frames&lt;/var&gt; 具有相同的含义在 &lt;code&gt;next-window&lt;/code&gt; ，像一个 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;minibuf&lt;/var&gt; 参数 &lt;code&gt;next-window&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="202962f0de53dff02d10a00270753bbfa1f06e86" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which frames to consider:</source>
          <target state="translated">可选参数 &lt;var&gt;all-frames&lt;/var&gt; 指定要考虑的帧：</target>
        </trans-unit>
        <trans-unit id="bb40d66cb55d279a86899a88dfb077d4f8e79fbc" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;base-url&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying the base URL for relative URLs occurring in links.</source>
          <target state="translated">可选参数 &lt;var&gt;base-url&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）应该是一个字符串，用于指定链接中出现的相对URL的基本URL。</target>
        </trans-unit>
        <trans-unit id="6a1907330d9a397ccfad9b3e354542f50e48a6fb" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;bury-or-kill&lt;/var&gt; specifies how to deal with &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer. The following values are handled:</source>
          <target state="translated">可选参数 &lt;var&gt;bury-or-kill&lt;/var&gt; 指定如何处理 &lt;var&gt;window&lt;/var&gt; 的缓冲区。处理以下值：</target>
        </trans-unit>
        <trans-unit id="2049134810f7e761207b9b8b3bd49725d3167d1d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;confirm&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, says to read the password twice and insist it must be the same both times. If it isn&amp;rsquo;t the same, the user has to type it over and over until the last two times match.</source>
          <target state="translated">可选参数 &lt;var&gt;confirm&lt;/var&gt; （如果为 &lt;code&gt;nil&lt;/code&gt; ）表示要两次读取密码，并坚持两次必须相同。如果不相同，则用户必须一遍又一遍地键入它，直到最后两次匹配为止。</target>
        </trans-unit>
        <trans-unit id="7bc5835047d79ebfcafd196072cb522b7ad940af" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;contextual&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, forces Font Lock mode to always refontify a syntactically relevant part of the buffer, and not just the modified lines. This argument can usually be omitted.</source>
          <target state="translated">可选参数 &lt;var&gt;contextual&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）将强制字体锁定模式始终重新字体化缓冲区中与语法相关的部分，而不仅是修改后的行。通常可以省略此参数。</target>
        </trans-unit>
        <trans-unit id="580eb5a9bd0d61ea92cc5b8878cb5564112b1db4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;count&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a maximum number of rectangles to return. This means that the return value is a list of triples specifying rectangles with the largest rectangle first. &lt;var&gt;count&lt;/var&gt; can be also a cons cell whose car specifies the number of rectangles to return and whose &lt;small&gt;CDR&lt;/small&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, states that all rectangles returned must be disjoint.</source>
          <target state="translated">可选参数 &lt;var&gt;count&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）指定要返回的最大矩形数。这意味着返回值是一个三元组列表，指定了具有最大矩形的矩形。 &lt;var&gt;count&lt;/var&gt; 也可以是一个cons单元格，该单元格的car指定要返回的矩形数，并且&lt;small&gt;CDR&lt;/small&gt;（如果不为 &lt;code&gt;nil&lt;/code&gt; ，则指出所有返回的矩形必须不相交）。</target>
        </trans-unit>
        <trans-unit id="3ebdbb0e5fb0f2b384549756b4989936faa9a770" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;cur-col&lt;/var&gt; specifies the current column when the function is called. This is the window-relative horizontal coordinate of point, measured in units of font width of the frame&amp;rsquo;s default face. Providing it speeds up the function, especially in very long lines, because the function doesn&amp;rsquo;t have to go back in the buffer in order to determine the current column. Note that &lt;var&gt;cur-col&lt;/var&gt; is also counted from the visual start of the line.</source>
          <target state="translated">可选参数 &lt;var&gt;cur-col&lt;/var&gt; 在调用函数时指定当前列。这是点的窗口相对水平坐标，以框架默认面的字体宽度为单位进行度量。提供它可以加快函数的速度，特别是在很长的行中，因为不必为了确定当前列而返回缓冲区。注意， &lt;var&gt;cur-col&lt;/var&gt; 也是从该行的可视开始算起的。</target>
        </trans-unit>
        <trans-unit id="b5a3875cde45d622d71332d1342451631df66196" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; is used as in &lt;code&gt;read-from-minibuffer&lt;/code&gt;, except that, if non-&lt;code&gt;nil&lt;/code&gt;, it also specifies a default value to return if the user enters null input. As in &lt;code&gt;read-from-minibuffer&lt;/code&gt; it should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string. When &lt;var&gt;default&lt;/var&gt; is a string, that string is the default value. When it is a list of strings, the first string is the default value. (All these strings are available to the user in the &amp;ldquo;future minibuffer history&amp;rdquo;.)</source>
          <target state="translated">可选参数 &lt;var&gt;default&lt;/var&gt; 用作 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 中的参数，不同之处在于，如果为non- &lt;code&gt;nil&lt;/code&gt; ，则它还指定一个默认值，如果用户输入null输入，则返回该默认值。与 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 中读取一样，它应该是一个字符串，一个字符串列表或 &lt;code&gt;nil&lt;/code&gt; ，它等效于一个空字符串。当 &lt;var&gt;default&lt;/var&gt; 为字符串时，该字符串为默认值。当它是一个字符串列表时，第一个字符串是默认值。 （所有这些字符串在&amp;ldquo;将来的微型缓冲区历史记录&amp;rdquo;中对用户可用。）</target>
        </trans-unit>
        <trans-unit id="a8b8f42a687e321f80ab76cd3bccd5897a600a30" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;default&lt;/var&gt; specifies the default password to return if the user enters empty input. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;read-passwd&lt;/code&gt; returns the null string in that case.</source>
          <target state="translated">可选参数 &lt;var&gt;default&lt;/var&gt; 指定用户输入空输入时返回的默认密码。如果 &lt;var&gt;default&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则在这种情况下 &lt;code&gt;read-passwd&lt;/code&gt; 返回空字符串。</target>
        </trans-unit>
        <trans-unit id="0048e481ce17eb199983c7400eaac1a428a4cdd4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;defaults&lt;/var&gt; controls the default value to return if the user enters null input, and should be one of: a string; &lt;code&gt;nil&lt;/code&gt;, which is equivalent to an empty string; a list of strings; or a symbol.</source>
          <target state="translated">可选参数 &lt;var&gt;defaults&lt;/var&gt; 控制如果用户输入空输入则返回的默认值，并且应为以下之一：字符串； &lt;code&gt;nil&lt;/code&gt; ，相当于一个空字符串；字符串列表；或符号。</target>
        </trans-unit>
        <trans-unit id="228f1c49688198d5cc5f85c1fed83e79ddfe5a7f" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;display&lt;/var&gt; in these functions specifies which display to ask the question about. It can be a display name, a frame (which designates the display that frame is on), or &lt;code&gt;nil&lt;/code&gt; (which refers to the selected frame&amp;rsquo;s display, see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">这些函数中的可选参数 &lt;var&gt;display&lt;/var&gt; 指定询问哪个显示。它可以是显示名称，框架（指定框架在其上的显示）或 &lt;code&gt;nil&lt;/code&gt; （指选定框架的显示，请参见&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ecafec37f62287ed8dd3cb905ab5b45b69aeeb0b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt; specifies which frames to operate on:</source>
          <target state="translated">可选的参数 &lt;var&gt;frame&lt;/var&gt; 指定要对哪些帧进行操作：</target>
        </trans-unit>
        <trans-unit id="26bbce4e0ce6d9c586e1c1839883be544a4991a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the frame on which the fonts are to be displayed. The optional argument &lt;var&gt;num&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be an integer that specifies the maximum length of the returned list. The optional argument &lt;var&gt;prefer&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be another font spec, which is used to control the order of the returned list; the returned font entities are sorted in order of decreasing closeness to that font spec.</source>
          <target state="translated">可选参数 &lt;var&gt;frame&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则指定要在其上显示字体的框架。可选参数 &lt;var&gt;num&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）应该是一个整数，该整数指定返回列表的最大长度。可选参数 &lt;var&gt;prefer&lt;/var&gt; red，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则应该是另一个字体规范，用于控制返回列表的顺序。返回的字体实体按照与该字体规格的接近程度递减的顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="160ff97d48ba4a8dfa3b003d791595b0262367a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;frame&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies which frames to check when deciding whether the buffer is already displayed. It is equivalent to adding an element &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; to the action alist of &lt;var&gt;action&lt;/var&gt; (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;). The &lt;var&gt;frame&lt;/var&gt; argument is provided for compatibility reasons, Lisp programs should not use it.</source>
          <target state="translated">可选参数 &lt;var&gt;frame&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则指定在确定是否已显示缓冲区时要检查的帧。它等同于添加元素 &lt;code&gt;(reusable-frames&amp;nbsp;.&amp;nbsp;&lt;var&gt;frame&lt;/var&gt;)&lt;/code&gt; 到的动作ALIST &lt;var&gt;action&lt;/var&gt; （见&lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;缓冲区显示动作Alists&lt;/a&gt;）。该 &lt;var&gt;frame&lt;/var&gt; 提供了兼容性的原因的说法，Lisp程序不应该使用它。</target>
        </trans-unit>
        <trans-unit id="50b9dbdcad227dd99d40dacb6820fdfcb31ad949" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;from&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the first text position to consider, and defaults to the minimum accessible position of the buffer. If &lt;var&gt;from&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the minimum accessible position that is not a newline character. The optional argument &lt;var&gt;to&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the last text position to consider, and defaults to the maximum accessible position of the buffer. If &lt;var&gt;to&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it stands for the maximum accessible position that is not a newline character.</source>
          <target state="translated">&lt;var&gt;from&lt;/var&gt; 的可选参数（如果为非 &lt;code&gt;nil&lt;/code&gt; )，指定要考虑的第一个文本位置，默认为缓冲区的最小可访问位置。如果 &lt;var&gt;from&lt;/var&gt; 是 &lt;code&gt;t&lt;/code&gt; ，则表示不是换行符的最小可访问位置。可选参数 &lt;var&gt;to&lt;/var&gt; ，如果不 &lt;code&gt;nil&lt;/code&gt; ，则指定了最后文本位置来考虑，并默认为缓冲区的最大接近的位置。如果 &lt;var&gt;to&lt;/var&gt; 是 &lt;code&gt;t&lt;/code&gt; ，则表示不是换行符的最大可访问位置。</target>
        </trans-unit>
        <trans-unit id="48d8b7e116733be79108fa56696b0ae152c9cd92" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;history&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a symbol specifying a minibuffer history list to use (see &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, the history list defaults to &lt;code&gt;regexp-history&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;history&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）是一个符号，指定要使用的&lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;最小&lt;/a&gt;缓冲区历史记录列表（请参见Minibuffer History）。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则历史记录列表默认为 &lt;code&gt;regexp-history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54b2555eb4d6971581a755b86e550d7f706a4369" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt; has the same meaning as for the function &lt;code&gt;window-resizable&lt;/code&gt; above.</source>
          <target state="translated">可选参数 &lt;var&gt;ignore&lt;/var&gt; 具有与上面的 &lt;code&gt;window-resizable&lt;/code&gt; 函数相同的含义。</target>
        </trans-unit>
        <trans-unit id="6bdfa63738d1ccee9b5808f3f8c9f1ebe07b8e9b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;ignore&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means ignore restrictions imposed by fixed size windows, &lt;code&gt;window-min-height&lt;/code&gt; or &lt;code&gt;window-min-width&lt;/code&gt; settings. If &lt;var&gt;ignore&lt;/var&gt; equals &lt;code&gt;safe&lt;/code&gt;, live windows may get as small as &lt;code&gt;window-safe-min-height&lt;/code&gt; lines and &lt;code&gt;window-safe-min-width&lt;/code&gt; columns. If &lt;var&gt;ignore&lt;/var&gt; is a window, ignore restrictions for that window only. Any other non-&lt;code&gt;nil&lt;/code&gt; value means ignore all of the above restrictions for all windows.</source>
          <target state="translated">可选参数 &lt;var&gt;ignore&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）表示忽略由固定大小的窗口， &lt;code&gt;window-min-height&lt;/code&gt; 或 &lt;code&gt;window-min-width&lt;/code&gt; 设置施加的限制。如果 &lt;var&gt;ignore&lt;/var&gt; 等于 &lt;code&gt;safe&lt;/code&gt; ，则活动窗口可能会变得与 &lt;code&gt;window-safe-min-height&lt;/code&gt; 行和 &lt;code&gt;window-safe-min-width&lt;/code&gt; 列一样小。如果 &lt;var&gt;ignore&lt;/var&gt; 是一个窗口，则仅忽略该窗口的限制。任何其他非 &lt;code&gt;nil&lt;/code&gt; 值意味着对所有窗口均忽略上述所有限制。</target>
        </trans-unit>
        <trans-unit id="f03394985cfefcfbe4bccbc2c2b7c937f24aa8ff" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;inverse&lt;/var&gt;, if &lt;code&gt;nil&lt;/code&gt;, means that the y-pixel value returned for any line specifies the distance in pixels from the left edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt; to the right edge of the last glyph of that line. &lt;var&gt;inverse&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that the y-pixel value returned for any line specifies the distance in pixels from the right edge of the last glyph of that line to the right edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt;. This is useful for determining the amount of slack space at the end of each line.</source>
          <target state="translated">可选参数 &lt;var&gt;inverse&lt;/var&gt; ，如果为 &lt;code&gt;nil&lt;/code&gt; ，则表示为任何行返回的y像素值指定从 &lt;var&gt;window&lt;/var&gt; 的左边缘（如果 &lt;var&gt;body&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则为body边缘）到该窗口的最后一个字形的右边缘之间的距离（以像素为单位）线。 &lt;var&gt;inverse&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 表示对于任何行返回的y像素值指定了从该行的最后一个字形的右边缘到 &lt;var&gt;window&lt;/var&gt; 的右边缘（如果 &lt;var&gt;body&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 的身体边缘）的距离（以像素为单位）。这对于确定每行末尾的松弛空间量很有用。</target>
        </trans-unit>
        <trans-unit id="36d765e78065810838fe4b4dcd7aee5e46b9c2f7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;keymap&lt;/var&gt; specifies the keymap for the minor mode. If non-&lt;code&gt;nil&lt;/code&gt;, it should be a variable name (whose value is a keymap), a keymap, or an alist of the form</source>
          <target state="translated">可选参数 &lt;var&gt;keymap&lt;/var&gt; 指定次要模式的键映射。如果为非 &lt;code&gt;nil&lt;/code&gt; ，则应为变量名（其值为键映射），键映射或表单列表</target>
        </trans-unit>
        <trans-unit id="45c7531620e27255788236157222d029e67710a7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; means to return the x- and y-coordinates of the lower left corner of the leftmost character on each line. This is the value that should be used for windows that mostly display text from right to left.</source>
          <target state="translated">可选参数 &lt;var&gt;left&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则表示返回每行最左字符左下角的x和y坐标。对于大多数从右到左显示文本的窗口，应该使用该值。</target>
        </trans-unit>
        <trans-unit id="fac44c195c8956dce4604ab79b6495b05c7787fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;left&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to return values suitable for buffers displaying right to left text. In that case, any rectangle returned is assumed to start at the left edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area.</source>
          <target state="translated">可选参数 &lt;var&gt;left&lt;/var&gt; ，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则意味着返回适合于显示从右到左文本的缓冲区的值。在这种情况下，假定返回的任何矩形都始于 &lt;var&gt;window&lt;/var&gt; 文本区域的左边缘。</target>
        </trans-unit>
        <trans-unit id="6b9c6954a4a938b6fd1e1b213483a278916b13fe" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems.</source>
          <target state="translated">可选参数 &lt;var&gt;locale&lt;/var&gt; 是一个字符串，它将覆盖您当前的语言环境标识符的排序规则。该值取决于系统；一个 &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; 是适用于POSIX系统，而这将是，例如， &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; 在MS-Windows系统。</target>
        </trans-unit>
        <trans-unit id="be924dbedb077a7596937c809656d8809cb7f780" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;locale&lt;/var&gt;, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a &lt;var&gt;locale&lt;/var&gt;&lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; is applicable on POSIX systems, while it would be, e.g., &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; on MS-Windows systems. The &lt;var&gt;locale&lt;/var&gt; value of &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; or &lt;code&gt;&quot;C&quot;&lt;/code&gt; lets &lt;code&gt;string-collate-lessp&lt;/code&gt; behave like &lt;code&gt;string-lessp&lt;/code&gt;:</source>
          <target state="translated">可选参数 &lt;var&gt;locale&lt;/var&gt; 是一个字符串，它将覆盖您当前的语言环境标识符的排序规则。该值取决于系统；一个 &lt;var&gt;locale&lt;/var&gt; &lt;code&gt;&quot;en_US.UTF-8&quot;&lt;/code&gt; 是适用于POSIX系统，而这将是，例如， &lt;code&gt;&quot;enu_USA.1252&quot;&lt;/code&gt; 在MS-Windows系统。 &lt;code&gt;&quot;POSIX&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 的 &lt;var&gt;locale&lt;/var&gt; 值使 &lt;code&gt;string-collate-lessp&lt;/code&gt; 行为类似于 &lt;code&gt;string-lessp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4edaf13bc53c89e562d674d18afa431f2d97a551" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;lockname&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the file name to use for purposes of locking and unlocking, overriding &lt;var&gt;filename&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; for that purpose.</source>
          <target state="translated">可选参数 &lt;var&gt;lockname&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）指定用于锁定和解锁目的的文件名，覆盖 &lt;var&gt;filename&lt;/var&gt; 并为此目的而 &lt;var&gt;visit&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="505418b83113b1a1864d4371b2abfa1905c1136b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;maximum&lt;/var&gt; sets a limit on how many fonts to return. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is truncated after the first &lt;var&gt;maximum&lt;/var&gt; matching fonts. Specifying a small value for &lt;var&gt;maximum&lt;/var&gt; can make this function much faster, in cases where many fonts match the pattern.</source>
          <target state="translated">可选参数 &lt;var&gt;maximum&lt;/var&gt; 设置了要返回的字体数的限制。如果它为非 &lt;code&gt;nil&lt;/code&gt; ，则返回值将在第一个 &lt;var&gt;maximum&lt;/var&gt; 匹配字体之后被截断。在许多字体与模式匹配的情况下，为 &lt;var&gt;maximum&lt;/var&gt; 指定一个较小的值可以使此功能更快。</target>
        </trans-unit>
        <trans-unit id="e2fef78645ec648e97c68254439e56ca0814e67d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;millisec&lt;/var&gt; specifies an additional waiting period measured in milliseconds. This adds to the period specified by &lt;var&gt;seconds&lt;/var&gt;. If the system doesn&amp;rsquo;t support waiting fractions of a second, you get an error if you specify nonzero &lt;var&gt;millisec&lt;/var&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;millisec&lt;/var&gt; 指定以毫秒为单位的附加等待时间。这将增加以 &lt;var&gt;seconds&lt;/var&gt; 指定的时间段。如果系统不支持等待的几分之一秒，则如果指定非零 &lt;var&gt;millisec&lt;/var&gt; ，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="a79dc72b2d8c8af7d2c6097667a6efcd584162f8" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuf&lt;/var&gt; specifies whether minibuffer windows should be included in the cyclic ordering. Normally, when &lt;var&gt;minibuf&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, a minibuffer window is included only if it is currently active; this matches the behavior of</source>
          <target state="translated">可选参数 &lt;var&gt;minibuf&lt;/var&gt; 指定是否应在循环顺序中包括微型缓冲区窗口。通常，当 &lt;var&gt;minibuf&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 时，仅在当前处于活动状态时才包括minibuffer窗口；这符合</target>
        </trans-unit>
        <trans-unit id="41718d9699e86f654dd2ea26e540ead2023238f1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;minibuffer&lt;/var&gt; specifies whether to include the minibuffer window in the returned list. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the minibuffer window is included. If &lt;var&gt;minibuffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the minibuffer window is included only if it is active. If &lt;var&gt;minibuffer&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, the minibuffer window is never included.</source>
          <target state="translated">可选参数 &lt;var&gt;minibuffer&lt;/var&gt; 指定是否在返回列表中包括minibuffer窗口。如果 &lt;var&gt;minibuffer&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则包含minibuffer窗口。如果 &lt;var&gt;minibuffer&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则仅当minibuffer窗口处于活动状态时才包括在内。如果 &lt;var&gt;minibuffer&lt;/var&gt; 既不是 &lt;code&gt;nil&lt;/code&gt; 也不不是 &lt;code&gt;t&lt;/code&gt; ，则永远不会包含minibuffer窗口。</target>
        </trans-unit>
        <trans-unit id="295f0ea496d93011b8fee19529ccf2a7cf02e05c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mode-and-header-line&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted means to not include the height of the mode- or header-line of &lt;var&gt;window&lt;/var&gt; in the return value. If it is either the symbol &lt;code&gt;mode-line&lt;/code&gt; or &lt;code&gt;header-line&lt;/code&gt;, include only the height of that line, if present, in the return value. If it is &lt;code&gt;t&lt;/code&gt;, include the height of both, if present, in the return value.</source>
          <target state="translated">可选参数 &lt;var&gt;mode-and-header-line&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或省略表示在返回值中不包括 &lt;var&gt;window&lt;/var&gt; 的模式或标题行的高度。如果它是符号 &lt;code&gt;mode-line&lt;/code&gt; 或 &lt;code&gt;header-line&lt;/code&gt; ，则仅在返回值中包括该行的高度（如果存在）。如果为 &lt;code&gt;t&lt;/code&gt; ，则将两者的高度（如果存在）都包含在返回值中。</target>
        </trans-unit>
        <trans-unit id="e8ec5bd3618893a66ce0e97a3f3a6fa2e9be9058" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;no-activate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, causes Emacs to update its record of installed packages without actually making them available.</source>
          <target state="translated">可选参数 &lt;var&gt;no-activate&lt;/var&gt; ，如果为 &lt;code&gt;nil&lt;/code&gt; ，则导致Emacs更新其已安装软件包的记录，而无需实际使它们可用。</target>
        </trans-unit>
        <trans-unit id="20709a8a77efe587a728d12e613e78b8c48774b1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;noerror&lt;/var&gt; is obsolete, kept for backward compatibility, and has no effect.</source>
          <target state="translated">可选参数 &lt;var&gt;noerror&lt;/var&gt; 已过时，为了向后兼容而保留，并且无效。</target>
        </trans-unit>
        <trans-unit id="2b89e1f5be44e2151710c7bdac8ce82b4cbfb2b4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt; specifies which text to search, and defaults to the current buffer. If &lt;var&gt;object&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it can be some other buffer, or it can be a string or a window. If it is a string, the function searches that string. If it is a window, the function searches the buffer displayed in that window. If a buffer whose text you want to examine is displayed in some window, we recommend to specify it by that window, rather than pass the buffer to the function. This is because telling the function about the window allows it to correctly account for window-specific overlays, which might change the result of the function if some text in the buffer is covered by overlays.</source>
          <target state="translated">可选参数 &lt;var&gt;object&lt;/var&gt; 指定要搜索的文本，并且默认为当前缓冲区。如果 &lt;var&gt;object&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则它可以是其他缓冲区，也可以是字符串或窗口。如果是字符串，则函数将搜索该字符串。如果它是一个窗口，则该函数搜索该窗口中显示的缓冲区。如果要检查其文本的缓冲区显示在某个窗口中，建议您在该窗口中指定该缓冲区，而不要将缓冲区传递给函数。这是因为告诉函数有关窗口的信息，它可以正确说明窗口特定的覆盖，如果缓冲区中的某些文本被覆盖覆盖，则可能会更改函数的结果。</target>
        </trans-unit>
        <trans-unit id="1a510836acc518a4ce80759b09b05d4c9fb80e93" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;object&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a buffer or string to act on, rather than the current buffer. If &lt;var&gt;object&lt;/var&gt; is a string, then &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are zero-based indices into the string.</source>
          <target state="translated">可选参数 &lt;var&gt;object&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）指定要作用的缓冲区或字符串，而不是当前缓冲区。如果 &lt;var&gt;object&lt;/var&gt; 是字符串，则 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 是字符串中从零开始的索引。</target>
        </trans-unit>
        <trans-unit id="6f772ffbd43b315bbe2a2d9ef65a881dd0172794" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;on-exit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function that is called, with no arguments, after &lt;var&gt;keymap&lt;/var&gt; is deactivated.</source>
          <target state="translated">可选参数 &lt;var&gt;on-exit&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则指定在取消激活键 &lt;var&gt;keymap&lt;/var&gt; 后调用的函数，该函数不带任何参数。</target>
        </trans-unit>
        <trans-unit id="59f86c6b81e54496f12f978a2ada198f4a69de49" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;only-present&lt;/var&gt; indicates how to handle specification characters in &lt;var&gt;template&lt;/var&gt; that are not found in &lt;var&gt;spec-alist&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or omitted, the function signals an error. Otherwise, those format specifications and any occurrences of &amp;lsquo;</source>
          <target state="translated">可选参数 &lt;var&gt;only-present&lt;/var&gt; 指示如何处理 &lt;var&gt;template&lt;/var&gt; 中 &lt;var&gt;spec-alist&lt;/var&gt; 中找不到的规范字符。如果为 &lt;code&gt;nil&lt;/code&gt; 或省略，则该函数将发出错误信号。否则，这些格式规范以及任何出现的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="99357a38b2f2682df0548c2c500e9c64e4f6180b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;padding&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a padding character added at the beginning and end of the result string, to extend it to exactly &lt;var&gt;width&lt;/var&gt; columns. The padding character is used at the end of the result if it falls short of &lt;var&gt;width&lt;/var&gt;. It is also used at the beginning of the result if one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;padding&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）是在结果字符串的开头和结尾添加的填充字符，以将其扩展为正好 &lt;var&gt;width&lt;/var&gt; 列。如果 &lt;var&gt;width&lt;/var&gt; 小于宽度，则在结果的末尾使用填充字符。如果 &lt;var&gt;string&lt;/var&gt; 一个多列字符跨列 &lt;var&gt;start-column&lt;/var&gt; 延伸，则它也将在结果的开头使用。</target>
        </trans-unit>
        <trans-unit id="791557e50f0f19bd2818ee21038e7006cdf9270d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;paren&lt;/var&gt; can be any of the following:</source>
          <target state="translated">可选参数 &lt;var&gt;paren&lt;/var&gt; 可以是以下任意一个：</target>
        </trans-unit>
        <trans-unit id="9125d9631a53fcb42a447bf4efdec3689610b1c4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to measure the new width and height in units of pixels instead. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some toolkits may refuse to truly honor the request if it does not increase/decrease the frame size to a multiple of its character size.</source>
          <target state="translated">可选的参数 &lt;var&gt;pixelwise&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 手段来测量像素为单位的新的宽度和高度来代替。请注意，如果 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则如果某些工具包未将帧大小增加/减小到其字符大小的倍数，则可能拒绝真正接受该请求。</target>
        </trans-unit>
        <trans-unit id="1a486c9457c82acbf1a6a199202ab0f46c9a5f6d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return the minimum size of &lt;var&gt;window&lt;/var&gt; counted in pixels.</source>
          <target state="translated">可选的参数 &lt;var&gt;pixelwise&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 装置返回的最小尺寸 &lt;var&gt;window&lt;/var&gt; 中的像素进行计数。</target>
        </trans-unit>
        <trans-unit id="58f7f9c9311afbc394002bdf8390e5e8a66c15d9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;positions&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; specifies the uppermost and whose &lt;small&gt;CDR&lt;/small&gt; specifies the lowermost pixel position that must be covered by any rectangle returned. These positions measure from the start of the text area of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">可选的参数 &lt;var&gt;positions&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）是一个cons单元格，其&lt;small&gt;CAR&lt;/small&gt;指定最上面的像素位置，而其&lt;small&gt;CDR&lt;/small&gt;指定必须由返回的任何矩形覆盖的最低像素位置。这些位置从 &lt;var&gt;window&lt;/var&gt; 的文本区域开始测量。</target>
        </trans-unit>
        <trans-unit id="d4d8d2c166f79b72f18b93ddb099c08e8746fd52" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a function to filter the buffers that should be considered: the function will be called with every potential candidate as its argument, and should return &lt;code&gt;nil&lt;/code&gt; to reject the candidate, non-&lt;code&gt;nil&lt;/code&gt; to accept it.</source>
          <target state="translated">可选参数 &lt;var&gt;predicate&lt;/var&gt; （如果为non- &lt;code&gt;nil&lt;/code&gt; ，则指定一个函数来过滤应考虑的缓冲区）：该函数将以每个潜在候选者作为其自变量调用，并且应返回 &lt;code&gt;nil&lt;/code&gt; 拒绝候选者，non- &lt;code&gt;nil&lt;/code&gt; 接受它。</target>
        </trans-unit>
        <trans-unit id="bf6c3432c82d35a85740cbc2f62db8414db80230" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;predicate&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a predicate function for testing whether a candidate file is suitable. The predicate is passed the candidate file name as its single argument. If &lt;var&gt;predicate&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, &lt;code&gt;locate-file&lt;/code&gt; uses &lt;code&gt;file-readable-p&lt;/code&gt; as the predicate. See &lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;Kinds of Files&lt;/a&gt;, for other useful predicates, e.g., &lt;code&gt;file-executable-p&lt;/code&gt; and &lt;code&gt;file-directory-p&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;predicate&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）指定用于测试候选文件是否合适的谓词函数。谓词被传递候选文件名作为其单个参数。如果 &lt;var&gt;predicate&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则 &lt;code&gt;locate-file&lt;/code&gt; 使用 &lt;code&gt;file-readable-p&lt;/code&gt; 作为谓词。有关其他有用的谓词，请参见&lt;a href=&quot;kinds-of-files#Kinds-of-Files&quot;&gt;文件种类&lt;/a&gt;，例如 &lt;code&gt;file-executable-p&lt;/code&gt; 和 &lt;code&gt;file-directory-p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e2cb767e72f360984a732e376c1c4554ced51fa" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;preserve-size&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, will install a parameter to preserve the size of &lt;var&gt;window&lt;/var&gt; during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">可选参数 &lt;var&gt;preserve-size&lt;/var&gt; ，如果不 &lt;code&gt;nil&lt;/code&gt; ，将安装参数保存的大小 &lt;var&gt;window&lt;/var&gt; 中调整大小的未来行动（见&lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;保留窗口大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="435a1b07679e489657de30782052b8d6eab4ec8b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;require-match&lt;/var&gt; has the same meaning as in &lt;code&gt;completing-read&lt;/code&gt;. See &lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;Minibuffer Completion&lt;/a&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;require-match&lt;/var&gt; 具有与 &lt;code&gt;completing-read&lt;/code&gt; 相同的含义。请参阅&lt;a href=&quot;minibuffer-completion#Minibuffer-Completion&quot;&gt;最小缓冲区完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e40feac3d056e5b6f3adcd167b868b54bdefa42a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;rgb&lt;/var&gt;, if specified, is an rgb value, a list of three numbers that specify what the color actually looks like. If you do not specify &lt;var&gt;rgb&lt;/var&gt;, then this color cannot be used by &lt;code&gt;tty-color-approximate&lt;/code&gt; to approximate other colors, because Emacs will not know what it looks like.</source>
          <target state="translated">可选参数 &lt;var&gt;rgb&lt;/var&gt; （如果已指定）是rgb值，它是三个数字的列表，用于指定颜色的实际外观。如果不指定 &lt;var&gt;rgb&lt;/var&gt; ，那么 &lt;code&gt;tty-color-approximate&lt;/code&gt; 不能使用此颜色来近似其他颜色，因为Emacs不会知道它的外观。</target>
        </trans-unit>
        <trans-unit id="905cbc5fb211abaa07ac0619c5392cdf3e417dd1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;spec-type&lt;/var&gt; determines which spec to set. If it is omitted or &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;face-override-spec&lt;/code&gt;, this function sets the &lt;em&gt;override spec&lt;/em&gt;, which overrides face specs on &lt;var&gt;face&lt;/var&gt; of all the other types mentioned below. This is useful when calling this function outside of Custom code. If &lt;var&gt;spec-type&lt;/var&gt; is &lt;code&gt;customized-face&lt;/code&gt; or &lt;code&gt;saved-face&lt;/code&gt;, this function sets the customized spec or the saved custom spec, respectively. If it is &lt;code&gt;face-defface-spec&lt;/code&gt;, this function sets the default face spec (the same one set by &lt;code&gt;defface&lt;/code&gt;). If it is &lt;code&gt;reset&lt;/code&gt;, this function clears out all customization specs and override specs from &lt;var&gt;face&lt;/var&gt; (in this case, the value of &lt;var&gt;spec&lt;/var&gt; is ignored). The effect of any other value of &lt;var&gt;spec-type&lt;/var&gt; on the face specs is reserved for internal use, but the function will still define &lt;var&gt;face&lt;/var&gt; itself and recalculate its attributes, as described above.</source>
          <target state="translated">可选参数 &lt;var&gt;spec-type&lt;/var&gt; 确定要设置的规范。如果省略它，或者为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;face-override-spec&lt;/code&gt; ，则此函数设置&lt;em&gt;override spec&lt;/em&gt;，它将覆盖下面提到的所有其他类型的 &lt;var&gt;face&lt;/var&gt; 的面部规范。在自定义代码之外调用此函数时，这很有用。如果 &lt;var&gt;spec-type&lt;/var&gt; 是 &lt;code&gt;customized-face&lt;/code&gt; 或 &lt;code&gt;saved-face&lt;/code&gt; ，则此函数分别设置定制的spec或保存的定制spec。如果它是 &lt;code&gt;face-defface-spec&lt;/code&gt; ，则此函数设置默认的脸部规范（ &lt;code&gt;defface&lt;/code&gt; 设置相同）。如果 &lt;code&gt;reset&lt;/code&gt; ，此功能会清除所有自定义规范并从 &lt;var&gt;face&lt;/var&gt; 覆盖规范（在这种情况下，会忽略 &lt;var&gt;spec&lt;/var&gt; 的值）。 &lt;var&gt;spec-type&lt;/var&gt; 的任何其他值对面部规格的影响均保留给内部使用，但如上所述，该功能仍将定义 &lt;var&gt;face&lt;/var&gt; 本身并重新计算其属性。</target>
        </trans-unit>
        <trans-unit id="d6f8de3101851c3382246237fec9a41fcf1e43cd" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;start-column&lt;/var&gt; specifies the starting column. If this is non-&lt;code&gt;nil&lt;/code&gt;, then the first &lt;var&gt;start-column&lt;/var&gt; columns of the string are omitted from the value. If one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;start-column&lt;/var&gt;, that character is not included.</source>
          <target state="translated">可选参数 &lt;var&gt;start-column&lt;/var&gt; 指定起始列。如果这不是非 &lt;code&gt;nil&lt;/code&gt; ，则从值中省略字符串的第一个 &lt;var&gt;start-column&lt;/var&gt; 。如果 &lt;var&gt;string&lt;/var&gt; 一个多列字符跨列 &lt;var&gt;start-column&lt;/var&gt; 延伸，则不包含该字符。</target>
        </trans-unit>
        <trans-unit id="170877c661c774db6181373f0a88ba3c4809375d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;string&lt;/var&gt; means to get a byte value from that string instead of the current buffer.</source>
          <target state="translated">可选参数 &lt;var&gt;string&lt;/var&gt; 表示从该字符串而不是当前缓冲区中获取字节值。</target>
        </trans-unit>
        <trans-unit id="08690ee1143f80767485ceb61e6025b4e1f6ad5a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;suffixes&lt;/var&gt; gives the list of file-name suffixes to append to &lt;var&gt;filename&lt;/var&gt; when searching. &lt;code&gt;locate-file&lt;/code&gt; tries each possible directory with each of these suffixes. If &lt;var&gt;suffixes&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, or &lt;code&gt;(&quot;&quot;)&lt;/code&gt;, then there are no suffixes, and &lt;var&gt;filename&lt;/var&gt; is used only as-is. Typical values of &lt;var&gt;suffixes&lt;/var&gt; are &lt;code&gt;exec-suffixes&lt;/code&gt; (see &lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;Subprocess Creation&lt;/a&gt;), &lt;code&gt;load-suffixes&lt;/code&gt;, &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; and the return value of the function &lt;code&gt;get-load-suffixes&lt;/code&gt; (see &lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Load Suffixes&lt;/a&gt;).</source>
          <target state="translated">可选参数 &lt;var&gt;suffixes&lt;/var&gt; 提供了搜索时要追加到 &lt;var&gt;filename&lt;/var&gt; 的文件名后缀的列表。 &lt;code&gt;locate-file&lt;/code&gt; 尝试使用每个后缀的每个可能的目录。如果 &lt;var&gt;suffixes&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;(&quot;&quot;)&lt;/code&gt; ，则没有后缀，并且 &lt;var&gt;filename&lt;/var&gt; 仅按原样使用。 &lt;var&gt;suffixes&lt;/var&gt; 典型值是 &lt;code&gt;exec-suffixes&lt;/code&gt; （请参阅&lt;a href=&quot;subprocess-creation#Subprocess-Creation&quot;&gt;子进程创建&lt;/a&gt;）， &lt;code&gt;load-suffixes&lt;/code&gt; ， &lt;code&gt;load-file-rep-suffixes&lt;/code&gt; 和函数 &lt;code&gt;get-load-suffixes&lt;/code&gt; 的返回值（请参阅&lt;a href=&quot;load-suffixes#Load-Suffixes&quot;&gt;Load Suffixes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6929cd262e2ec8e57cb83b3bca611739b4dfbf41" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;translation&lt;/var&gt; specifies a translation table to use for scanning the text (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;). If it is non-&lt;code&gt;nil&lt;/code&gt;, then each character in the region is translated through this table, and the value returned describes the translated characters instead of the characters actually in the buffer.</source>
          <target state="translated">可选的参数 &lt;var&gt;translation&lt;/var&gt; 指定用于扫描文本的转换表（请参阅&lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;字符转换&lt;/a&gt;）。如果它为非 &lt;code&gt;nil&lt;/code&gt; ，则将通过此表转换该区域中的每个字符，并且返回的值将描述转换后的字符，而不是缓冲区中实际的字符。</target>
        </trans-unit>
        <trans-unit id="c092e151609e9ec5f01fdc51239dc320c81fb40d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt; is a symbol specifying the image type. If &lt;var&gt;type&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;create-image&lt;/code&gt; tries to determine the image type from the file&amp;rsquo;s first few bytes, or else from the file&amp;rsquo;s name.</source>
          <target state="translated">可选的参数 &lt;var&gt;type&lt;/var&gt; 是指定图像类型的符号。如果 &lt;var&gt;type&lt;/var&gt; 省略或 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;create-image&lt;/code&gt; 尝试根据文件的前几个字节或文件名确定图像类型。</target>
        </trans-unit>
        <trans-unit id="cffa81c7cb380096c5547dae42e6cb7a9528d1b2" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;type&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, determines the exact type of Lisp object to check for. In that case, &lt;var&gt;type&lt;/var&gt; should be one of &lt;code&gt;font-object&lt;/code&gt;, &lt;code&gt;font-spec&lt;/code&gt;, or &lt;code&gt;font-entity&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;type&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则确定要检查的Lisp对象的确切类型。在这种情况下， &lt;var&gt;type&lt;/var&gt; 应该是 &lt;code&gt;font-object&lt;/code&gt; ， &lt;code&gt;font-spec&lt;/code&gt; 或 &lt;code&gt;font-entity&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="bc15e8d2ee27fc6994759226a8e71c2f534f8ee7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;width&lt;/var&gt; specifies a desired font width. If it is non-&lt;code&gt;nil&lt;/code&gt;, the function only returns those fonts whose characters are (on average) &lt;var&gt;width&lt;/var&gt; times as wide as &lt;var&gt;reference-face&lt;/var&gt;.</source>
          <target state="translated">可选的参数 &lt;var&gt;width&lt;/var&gt; 指定所需的字体宽度。如果它不是 &lt;code&gt;nil&lt;/code&gt; ，则该函数仅返回那些字符的 &lt;var&gt;width&lt;/var&gt; （平均）宽度是 &lt;var&gt;reference-face&lt;/var&gt; 宽度的字体。</target>
        </trans-unit>
        <trans-unit id="a4adeba927f11ca868cbbc9ac454375db4897015" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;window&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a live window on the specified frame; then &lt;var&gt;window&lt;/var&gt; will be the first element in the returned list. If &lt;var&gt;window&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the window selected within the frame is the first element.</source>
          <target state="translated">可选参数 &lt;var&gt;window&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）应为指定框架上的实时窗口；否则为false。然后 &lt;var&gt;window&lt;/var&gt; 将是返回列表中的第一个元素。如果省略 &lt;var&gt;window&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则在框架内选择的窗口是第一个元素。</target>
        </trans-unit>
        <trans-unit id="fdc9182a4b3a92a29afde612fa522b47066e0b79" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;x-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum X coordinate beyond which text should be ignored; it is therefore also the largest value of pixel-width that the function can return. If &lt;var&gt;x-limit&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; or omitted, it means to use the pixel-width of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;); this default means that text of truncated lines wider than the window will be ignored. This default is useful when the caller does not intend to change the width of &lt;var&gt;window&lt;/var&gt;. Otherwise, the caller should specify here the maximum width &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body may assume; in particular, if truncated lines are expected and their text needs to be accounted for, &lt;var&gt;x-limit&lt;/var&gt; should be set to a large value. Since calculating the width of long lines can take some time, it&amp;rsquo;s always a good idea to make this argument as small as needed; in particular, if the buffer might contain long lines that will be truncated anyway.</source>
          <target state="translated">可选参数 &lt;var&gt;x-limit&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）指定最大X坐标，超出该最大X坐标应忽略文本；因此，它也是函数可以返回的最大像素宽度值。如果 &lt;var&gt;x-limit&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则表示使用 &lt;var&gt;window&lt;/var&gt; 主体的像素宽度（请参见&lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;）；此默认值表示将忽略比窗口宽的截断文本。当调用者不打算更改 &lt;var&gt;window&lt;/var&gt; 的宽度时，此默认设置很有用。否则，呼叫者应在此处指定 &lt;var&gt;window&lt;/var&gt; 主体可以采用的最大宽度；特别是如果要截断行并且需要说明其文本， &lt;var&gt;x-limit&lt;/var&gt; 应设置为较大的值。由于计算长线的宽度可能会花费一些时间，因此最好使此参数尽可能小。特别是，如果缓冲区中可能包含长行，而这些长行无论如何都会被截断。</target>
        </trans-unit>
        <trans-unit id="c40e0ed4f1db150d7701a53bd11312d3806432c0" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;xrm-string&lt;/var&gt;, if not &lt;code&gt;nil&lt;/code&gt;, is a string of resource names and values, in the same format used in the</source>
          <target state="translated">可选参数 &lt;var&gt;xrm-string&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）是资源名称和值的字符串，格式与</target>
        </trans-unit>
        <trans-unit id="e45d1b4575d0268bdd495d97852d103f4fb454e9" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;y-limit&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum Y coordinate beyond which text is to be ignored; it is therefore also the maximum pixel-height that the function can return. If &lt;var&gt;y-limit&lt;/var&gt; is nil or omitted, it means to considers all the lines of text till the buffer position specified by &lt;var&gt;to&lt;/var&gt;. Since calculating the pixel-height of a large buffer can take some time, it makes sense to specify this argument; in particular, if the caller does not know the size of the buffer.</source>
          <target state="translated">可选参数 &lt;var&gt;y-limit&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ，则指定最大Y坐标），超出该最大Y坐标将忽略文本；因此，它也是函数可以返回的最大像素高度。如果 &lt;var&gt;y-limit&lt;/var&gt; 为nil或省略，则意味着要考虑到 &lt;var&gt;to&lt;/var&gt; 所指定的缓冲区位置之前的所有文本行。由于计算大缓冲区的像素高度可能要花费一些时间，因此指定此参数是有意义的。特别是在调用方不知道缓冲区大小的情况下。</target>
        </trans-unit>
        <trans-unit id="dc3a575ab4003570a9c36540fefa7d4ef44f3823" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;action&lt;/var&gt; and &lt;var&gt;frame&lt;/var&gt; are as for &lt;code&gt;display-buffer&lt;/code&gt;, and only used if a buffer is displayed.</source>
          <target state="translated">可选参数 &lt;var&gt;action&lt;/var&gt; 和 &lt;var&gt;frame&lt;/var&gt; 与 &lt;code&gt;display-buffer&lt;/code&gt; 相同，仅在显示缓冲区时使用。</target>
        </trans-unit>
        <trans-unit id="0c0042672620faa70f4c2ac1559a316ba863df5c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;component&lt;/var&gt; and &lt;var&gt;subclass&lt;/var&gt; add to the key and the class, respectively. You must specify both of them or neither. If you specify them, the key is &amp;lsquo;</source>
          <target state="translated">可选参数 &lt;var&gt;component&lt;/var&gt; 和 &lt;var&gt;subclass&lt;/var&gt; 分别添加到key和class中。您必须同时指定两者。如果指定它们，则密钥为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ee91262e4675f009db2d341be5b1d60c2ec7c619" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;min-width&lt;/var&gt; and &lt;var&gt;min-height&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specify the minimum width and height of any rectangle returned.</source>
          <target state="translated">可选参数 &lt;var&gt;min-width&lt;/var&gt; 和 &lt;var&gt;min-height&lt;/var&gt; ，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则指定返回的任何矩形的最小宽度和高度。</target>
        </trans-unit>
        <trans-unit id="372690aff6ae141943d981fae5474ab55ccff89f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the windows to search, and have the same meanings as in &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;minibuf&lt;/var&gt; 和 &lt;var&gt;all-frames&lt;/var&gt; 指定要搜索的窗口，其含义与 &lt;code&gt;next-window&lt;/code&gt; 中的含义相同。</target>
        </trans-unit>
        <trans-unit id="2c1039de00a7678732da9114d34b59102a11647b" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are character positions specifying the portion of &lt;var&gt;object&lt;/var&gt; to compute the message digest for. If they are &lt;code&gt;nil&lt;/code&gt; or omitted, the hash is computed for the whole of &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 是字符位置，用于指定要为其计算消息摘要的 &lt;var&gt;object&lt;/var&gt; 部分。如果它们为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则为整个 &lt;var&gt;object&lt;/var&gt; 计算哈希值。</target>
        </trans-unit>
        <trans-unit id="2337e7f6ede507e511fcbe99dd954146514bc80b" translate="yes" xml:space="preserve">
          <source>The optional fifth argument, &lt;var&gt;object&lt;/var&gt;, specifies the string or buffer to scan. Positions are relative to &lt;var&gt;object&lt;/var&gt;. The default for &lt;var&gt;object&lt;/var&gt; is the current buffer.</source>
          <target state="translated">可选的第五个参数 &lt;var&gt;object&lt;/var&gt; ，指定要扫描的字符串或缓冲区。位置是相对于 &lt;var&gt;object&lt;/var&gt; 。 &lt;var&gt;object&lt;/var&gt; 的默认值是当前缓冲区。</target>
        </trans-unit>
        <trans-unit id="28e7ede94a8e68a6a581d0669d18f692d137189a" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;height&lt;/var&gt; pixels high. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to truly honor the request if it does not increase/decrease the frame height to a multiple of its character height.</source>
          <target state="translated">可选的第四个参数 &lt;var&gt;pixelwise&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 意味着 &lt;var&gt;frame&lt;/var&gt; 应该是 &lt;var&gt;height&lt;/var&gt; 像素高。请注意，如果 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则如果窗口请求未将帧高度增加/减小到其字符高度的倍数，则某些窗口管理器可能拒绝真正接受该请求。</target>
        </trans-unit>
        <trans-unit id="4cea50b6fa2e62214008b025d8e0f2e6fa48a344" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means that &lt;var&gt;frame&lt;/var&gt; should be &lt;var&gt;width&lt;/var&gt; pixels wide. Note that if &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, some window managers may refuse to fully honor the request if it does not increase/decrease the frame width to a multiple of its character width.</source>
          <target state="translated">可选的第四个参数 &lt;var&gt;pixelwise&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 意味着 &lt;var&gt;frame&lt;/var&gt; 应该是 &lt;var&gt;width&lt;/var&gt; 像素宽。请注意，如果 &lt;code&gt;frame-resize-pixelwise&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则如果窗口请求未将帧宽度增加/减小到其字符宽度的倍数，则某些窗口管理器可能会拒绝完全接受该请求。</target>
        </trans-unit>
        <trans-unit id="46a593eb8b77337d54dd037277b7e1d96651e2a6" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;pixelwise&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to interpret &lt;var&gt;size&lt;/var&gt; in units of pixels, instead of lines and columns.</source>
          <target state="translated">可选的第四个参数 &lt;var&gt;pixelwise&lt;/var&gt; ，如果非 &lt;code&gt;nil&lt;/code&gt; ，则意味着以像素为单位而不是行和列来解释 &lt;var&gt;size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d2d517b24a513e68638fc126f01cf14f00b2b4" translate="yes" xml:space="preserve">
          <source>The optional fourth argument &lt;var&gt;window&lt;/var&gt; specifies the window for obtaining parameters such as width, horizontal scrolling, and so on. The default is to use the selected window&amp;rsquo;s parameters.</source>
          <target state="translated">可选的第四个参数 &lt;var&gt;window&lt;/var&gt; 指定用于获取诸如宽度，水平滚动等参数的窗口。默认值为使用所选窗口的参数。</target>
        </trans-unit>
        <trans-unit id="32d500e9fa66e6e098845ee8a4f7df222a3a64f2" translate="yes" xml:space="preserve">
          <source>The optional second argument &lt;var&gt;size&lt;/var&gt; determines the sizes of &lt;var&gt;window&lt;/var&gt; and/or the new window. If it is omitted or &lt;code&gt;nil&lt;/code&gt;, both windows are given equal sizes; if there is an odd line, it is allocated to the new window. If &lt;var&gt;size&lt;/var&gt; is a positive number, &lt;var&gt;window&lt;/var&gt; is given &lt;var&gt;size&lt;/var&gt; lines (or columns, depending on the value of &lt;var&gt;side&lt;/var&gt;). If &lt;var&gt;size&lt;/var&gt; is a negative number, the new window is given -&lt;var&gt;size&lt;/var&gt; lines (or columns).</source>
          <target state="translated">可选的第二个参数 &lt;var&gt;size&lt;/var&gt; 确定 &lt;var&gt;window&lt;/var&gt; 和/或新窗口的大小。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则两个窗口的大小相等。如果有奇数行，它将分配给新窗口。如果 &lt;var&gt;size&lt;/var&gt; 为正数，则为 &lt;var&gt;window&lt;/var&gt; 提供 &lt;var&gt;size&lt;/var&gt; 线（或列，取决于 &lt;var&gt;side&lt;/var&gt; 的值）。如果 &lt;var&gt;size&lt;/var&gt; 为负数，则显示新窗口- &lt;var&gt;size&lt;/var&gt; 线（或列）。</target>
        </trans-unit>
        <trans-unit id="3ea25d87cc8b43ad9b6088e35f93a262a0c645a2" translate="yes" xml:space="preserve">
          <source>The optional string &lt;var&gt;docstring&lt;/var&gt; is the documentation string of the variable &lt;var&gt;tabname&lt;/var&gt;. The property list &lt;var&gt;props&lt;/var&gt; is applied to the abbrev table (see &lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev Table Properties&lt;/a&gt;).</source>
          <target state="translated">可选字符串 &lt;var&gt;docstring&lt;/var&gt; 是变量 &lt;var&gt;tabname&lt;/var&gt; 的文档字符串。属性列表 &lt;var&gt;props&lt;/var&gt; 应用于abbrev表（请参阅&lt;a href=&quot;abbrev-table-properties#Abbrev-Table-Properties&quot;&gt;Abbrev Table属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c222f8e06e9d5450826a8e535233e76c3aefd4d7" translate="yes" xml:space="preserve">
          <source>The optional third argument &lt;var&gt;side&lt;/var&gt; determines the position of the new window relative to &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;below&lt;/code&gt;, the new window is placed below &lt;var&gt;window&lt;/var&gt;. If it is &lt;code&gt;above&lt;/code&gt;, the new window is placed above &lt;var&gt;window&lt;/var&gt;. In both these cases, &lt;var&gt;size&lt;/var&gt; specifies a total window height, in lines.</source>
          <target state="translated">可选的第三参数 &lt;var&gt;side&lt;/var&gt; 确定新窗口相对于 &lt;var&gt;window&lt;/var&gt; 的位置。如果它是 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;below&lt;/code&gt; ，则新窗口将放置在 &lt;var&gt;window&lt;/var&gt; 下。如果在 &lt;code&gt;above&lt;/code&gt; ，则将新窗口放置在 &lt;var&gt;window&lt;/var&gt; 上方。在这两种情况下， &lt;var&gt;size&lt;/var&gt; 均以行为单位指定总窗口高度。</target>
        </trans-unit>
        <trans-unit id="b1108fc16d48a052af5da3a2a313ad2178d4f97c" translate="yes" xml:space="preserve">
          <source>The optional third argument specifies the argument list of &lt;code&gt;shell-mode&lt;/code&gt;. In this case, it takes no arguments (&lt;code&gt;nil&lt;/code&gt; is different from not specifying a value). In other cases, this might be something like &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt;. You don&amp;rsquo;t have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration.</source>
          <target state="translated">可选的第三个参数指定 &lt;code&gt;shell-mode&lt;/code&gt; 的参数列表。在这种情况下，它不接受任何参数（ &lt;code&gt;nil&lt;/code&gt; 与未指定值不同）。在其他情况下，这可能类似于 &lt;code&gt;(file &amp;amp;optional overwrite)&lt;/code&gt; 。您不必指定参数列表，但是如果这样做，字节编译器可以检查调用是否与声明匹配。</target>
        </trans-unit>
        <trans-unit id="c91189f64260a86a1f42683fa6c4e4a546871bd4" translate="yes" xml:space="preserve">
          <source>The order of items in the menu is the same as the order of bindings in the keymap. Since &lt;code&gt;define-key&lt;/code&gt; puts new bindings at the front, you should define the menu items starting at the bottom of the menu and moving to the top, if you care about the order. When you add an item to an existing menu, you can specify its position in the menu using &lt;code&gt;define-key-after&lt;/code&gt; (see &lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;Modifying Menus&lt;/a&gt;).</source>
          <target state="translated">菜单中项目的顺序与键盘映射中的绑定顺序相同。由于 &lt;code&gt;define-key&lt;/code&gt; 将新的绑定放在最前面，因此，如果您关心顺序，则应该从菜单底部开始到顶部移动菜单项。将项目添加到现有菜单时，可以使用 &lt;code&gt;define-key-after&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;modifying-menus#Modifying-Menus&quot;&gt;修改菜单&amp;rdquo;&lt;/a&gt;）在菜单中指定其位置。</target>
        </trans-unit>
        <trans-unit id="1eb5686cd4b85626eb2e98bbf5e87da933ba4c3c" translate="yes" xml:space="preserve">
          <source>The order of specifications in &lt;var&gt;template&lt;/var&gt; need not correspond to the order of associations in &lt;var&gt;spec-alist&lt;/var&gt;.</source>
          <target state="translated">在规格顺序 &lt;var&gt;template&lt;/var&gt; 不必对应于协会的秩序 &lt;var&gt;spec-alist&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="318b3cee5109ab1253568ca38f5b8b67f4c1e472" translate="yes" xml:space="preserve">
          <source>The ordering information is stored in a hash table on &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s &lt;code&gt;list-order&lt;/code&gt; property. &lt;var&gt;symbol&lt;/var&gt; cannot refer to a lexical variable.</source>
          <target state="translated">订单信息存储在 &lt;var&gt;symbol&lt;/var&gt; 的 &lt;code&gt;list-order&lt;/code&gt; 属性的哈希表中。 &lt;var&gt;symbol&lt;/var&gt; 不能引用词法变量。</target>
        </trans-unit>
        <trans-unit id="2226d00d51a88ba323aae0098cc9991d74673a2e" translate="yes" xml:space="preserve">
          <source>The ordering is determined by a depth-first traversal of each frame&amp;rsquo;s window tree, retrieving the live windows which are the leaf nodes of the tree (see &lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows and Frames&lt;/a&gt;). If the minibuffer is active, the minibuffer window is included too. The ordering is cyclic, so the last window in the sequence is followed by the first one.</source>
          <target state="translated">该顺序由每个框架的窗口树的深度优先遍历确定，并检索作为该树的叶节点的活动窗口（请参见&lt;a href=&quot;windows-and-frames#Windows-and-Frames&quot;&gt;Windows和Frames&lt;/a&gt;）。如果微型缓冲区处于活动状态，那么也会包含微型缓冲区窗口。该顺序是循环的，因此序列中的最后一个窗口后面是第一个窗口。</target>
        </trans-unit>
        <trans-unit id="f22b797aae6cb0756380535cd8ae770baa37540b" translate="yes" xml:space="preserve">
          <source>The ordinary &lt;em&gt;Lisp debugger&lt;/em&gt; provides the ability to suspend evaluation of a form. While evaluation is suspended (a state that is commonly known as a &lt;em&gt;break&lt;/em&gt;), you may examine the run time stack, examine the values of local or global variables, or change those values. Since a break is a recursive edit, all the usual editing facilities of Emacs are available; you can even run programs that will enter the debugger recursively. See &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;.</source>
          <target state="translated">普通的&lt;em&gt;Lisp调试器&lt;/em&gt;提供了暂停表单评估的功能。在暂停评估（这种状态通常称为&lt;em&gt;break&lt;/em&gt;）的同时，您可以检查运行时堆栈，检查局部或全局变量的值或更改这些值。由于中断是递归编辑，因此Emacs的所有常规编辑功能均可用。您甚至可以运行将递归进入调试器的程序。请参阅&lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;递归编辑&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f996d904bee479b366f2c2d0b17fcd959ce9c44" translate="yes" xml:space="preserve">
          <source>The ordinary elements of the display table are indexed by character codes; the element at index &lt;var&gt;c&lt;/var&gt; says how to display the character code &lt;var&gt;c&lt;/var&gt;. The value should be &lt;code&gt;nil&lt;/code&gt; (which means to display the character &lt;var&gt;c&lt;/var&gt; according to the usual display conventions; see &lt;a href=&quot;usual-display#Usual-Display&quot;&gt;Usual Display&lt;/a&gt;), or a vector of glyph codes (which means to display the character &lt;var&gt;c&lt;/var&gt; as those glyphs; see &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;).</source>
          <target state="translated">显示表的普通元素由字符代码索引；索引 &lt;var&gt;c&lt;/var&gt; 处的元素表示如何显示字符代码 &lt;var&gt;c&lt;/var&gt; 。该值应为 &lt;code&gt;nil&lt;/code&gt; （这意味着按照通常的显示约定显示字符 &lt;var&gt;c&lt;/var&gt; ；请参阅&amp;ldquo;&lt;a href=&quot;usual-display#Usual-Display&quot;&gt;常规显示&amp;rdquo;&lt;/a&gt;），或者是一个字形代码的向量（这意味着将字符 &lt;var&gt;c&lt;/var&gt; 显示为那些字形；请参见&lt;a href=&quot;glyphs#Glyphs&quot;&gt;字形&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="623ff6e7f140985ddebe6c27ee8d097d687ce22b" translate="yes" xml:space="preserve">
          <source>The original argument list, modified with the actual connection information, is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">原始参数列表（使用实际的连接信息修改）可通过 &lt;code&gt;process-contact&lt;/code&gt; 功能获得。</target>
        </trans-unit>
        <trans-unit id="3d6da09d571fe6e045570a75658c815203791d82" translate="yes" xml:space="preserve">
          <source>The original argument list, possibly modified by later configuration, is available via the function &lt;code&gt;process-contact&lt;/code&gt;.</source>
          <target state="translated">原始参数列表（可能会在以后的配置中进行修改）可以通过 &lt;code&gt;process-contact&lt;/code&gt; 函数获得。</target>
        </trans-unit>
        <trans-unit id="783a67e957204d836894a368a238fa5382b7ae1b" translate="yes" xml:space="preserve">
          <source>The other Emacs prefix keys are</source>
          <target state="translated">其他Emacs前缀键有</target>
        </trans-unit>
        <trans-unit id="5e87cdc0bc797ddea7fd188f93a5689b5c8765dd" translate="yes" xml:space="preserve">
          <source>The outer position is specified by and can be set via the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; frame parameters (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For a normal, top-level frame these parameters usually represent its absolute position (see below) with respect to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) these parameters represent its position relative to the native position (see below) of its parent frame. For frames on text terminals the values of these parameters are meaningless and always zero.</source>
          <target state="translated">外部位置由 &lt;code&gt;left&lt;/code&gt; 框架参数和 &lt;code&gt;top&lt;/code&gt; 框架参数指定，并且可以通过这些参数设置（请参见&amp;ldquo;&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;位置参数&amp;rdquo;&lt;/a&gt;）。对于正常的顶层框架，这些参数通常代表其相对于显示器原点的绝对位置（请参见下文）。对于子框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;），这些参数表示其相对于其父框架的原始位置（请参见下文）的位置。对于文本终端上的帧，这些参数的值没有意义，并且始终为零。</target>
        </trans-unit>
        <trans-unit id="9b61b570125b083d2bf973be5f7d446a50b1ff1e" translate="yes" xml:space="preserve">
          <source>The output characters are displayed in the echo area.</source>
          <target state="translated">输出字符显示在回音区。</target>
        </trans-unit>
        <trans-unit id="f760a648322efbb4e113d3ec65ce0e0be54106de" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into &lt;var&gt;buffer&lt;/var&gt; at point. Point advances as characters are inserted.</source>
          <target state="translated">输出字符将插入到点的 &lt;var&gt;buffer&lt;/var&gt; 中。随着字符的插入，点前进。</target>
        </trans-unit>
        <trans-unit id="847115e1679c724c2cb4444c6559f9fe7c4d8063" translate="yes" xml:space="preserve">
          <source>The output characters are inserted into the buffer that &lt;var&gt;marker&lt;/var&gt; points into, at the marker position. The marker position advances as characters are inserted. The value of point in the buffer has no effect on printing when the stream is a marker, and this kind of printing does not move point (except that if the marker points at or before the position of point, point advances with the surrounding text, as usual).</source>
          <target state="translated">输出字符将插入到 &lt;var&gt;marker&lt;/var&gt; 指向的缓冲区中，在标记位置处。标记位置随着插入字符而增加。当流是标记时，缓冲区中的point值对打印没有影响，并且这种打印不会移动点（除非如果标记指向点的位置或之前，点会与周围的文本一起前进，照常）。</target>
        </trans-unit>
        <trans-unit id="da1c7a7c56317e365d871f2788f8d99dcda43cbf" translate="yes" xml:space="preserve">
          <source>The output characters are passed to &lt;var&gt;function&lt;/var&gt;, which is responsible for storing them away. It is called with a single character as argument, as many times as there are characters to be output, and is responsible for storing the characters wherever you want to put them.</source>
          <target state="translated">输出字符将传递给 &lt;var&gt;function&lt;/var&gt; ，该函数负责将它们存储起来。它以单个字符作为参数调用，输出的次数与要输出的字符的次数相同，并且负责将字符存储在任何要放置的位置。</target>
        </trans-unit>
        <trans-unit id="97b90b29b23cb79eed0c42878f18676a7f82018f" translate="yes" xml:space="preserve">
          <source>The output from a synchronous subprocess is generally decoded using a coding system, much like text read from a file. The input sent to a subprocess by &lt;code&gt;call-process-region&lt;/code&gt; is encoded using a coding system, much like text written into a file. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;.</source>
          <target state="translated">同步子过程的输出通常使用编码系统解码，就像从文件中读取文本一样。使用编码系统对通过 &lt;code&gt;call-process-region&lt;/code&gt; 发送到子流程的输入进行编码，就像将文本写入文件一样。请参阅&lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;编码系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bf1d258cf8161b4fe6f560101ccee767cdb33ab" translate="yes" xml:space="preserve">
          <source>The output string need not be newly-allocated. For example, if &lt;code&gt;x&lt;/code&gt; is the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, the expressions &lt;code&gt;(eq x
(format x))&lt;/code&gt; and &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; might both yield &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">输出字符串不需要重新分配。例如，如果 &lt;code&gt;x&lt;/code&gt; 是字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ，则表达式 &lt;code&gt;(eq x (format x))&lt;/code&gt; 和 &lt;code&gt;(eq x (format &quot;%s&quot; x))&lt;/code&gt; 可能产生 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3615d741950845df06c53b6a7f56b4c8a5a4ebc" translate="yes" xml:space="preserve">
          <source>The output that an asynchronous subprocess writes to its standard output stream is passed to a function called the &lt;em&gt;filter function&lt;/em&gt;. The default filter function simply inserts the output into a buffer, which is called the associated buffer of the process (see &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;). If the process has no buffer then the default filter discards the output.</source>
          <target state="translated">异步子进程写入其标准输出流的输出将传递到称为&lt;em&gt;过滤器函数的函数&lt;/em&gt;。默认的filter函数只是将输出插入一个缓冲区，该缓冲区称为流程的关联缓冲区（请参见&lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;）。如果进程没有缓冲区，则默认过滤器将丢弃输出。</target>
        </trans-unit>
        <trans-unit id="1ae9bdf1de6c1b3dee1b8c77f2a066e71cd4bda1" translate="yes" xml:space="preserve">
          <source>The output to the filter may come in chunks of any size. A program that produces the same output twice in a row may send it as one batch of 200 characters one time, and five batches of 40 characters the next. If the filter looks for certain text strings in the subprocess output, make sure to handle the case where one of these strings is split across two or more batches of output; one way to do this is to insert the received text into a temporary buffer, which can then be searched.</source>
          <target state="translated">输出到过滤器的数据可以是任何大小的块状数据。一个程序如果连续两次产生相同的输出,可能前一次是200个字符的一批,后一次是40个字符的五批。如果过滤器在子进程输出中寻找某些文本字符串,一定要处理其中一个字符串被分割在两批或多批输出中的情况;一种方法是将接收到的文本插入到一个临时缓冲区中,然后可以对其进行搜索。</target>
        </trans-unit>
        <trans-unit id="58e6196b6fc1654a77feeadf775e93f2d335a94f" translate="yes" xml:space="preserve">
          <source>The outside window configuration is saved and restored if &lt;code&gt;edebug-save-windows&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;edebug-save-windows&lt;/code&gt; 不 &lt;code&gt;nil&lt;/code&gt; 则将保存并还原外部窗口配置（请参阅&lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="443f8535af5feac9009b9eb74d0bd0bbb542eca8" translate="yes" xml:space="preserve">
          <source>The overlay-arrow string is displayed in any given buffer if the value of &lt;code&gt;overlay-arrow-position&lt;/code&gt; in that buffer points into that buffer. Thus, it is possible to display multiple overlay arrow strings by creating buffer-local bindings of &lt;code&gt;overlay-arrow-position&lt;/code&gt;. However, it is usually cleaner to use &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; to achieve this result.</source>
          <target state="translated">如果该缓冲区中的 &lt;code&gt;overlay-arrow-position&lt;/code&gt; 值指向该缓冲区，则将在该缓冲区中显示overlay-arrow字符串。因此，可以通过创建 &lt;code&gt;overlay-arrow-position&lt;/code&gt; 的缓冲区局部绑定来显示多个叠加箭头字符串。但是，通常使用 &lt;code&gt;overlay-arrow-variable-list&lt;/code&gt; 来获得此结果更为干净。</target>
        </trans-unit>
        <trans-unit id="0c4e900964a2a9c8ee2b6d6918d8e7e1d4ae357a" translate="yes" xml:space="preserve">
          <source>The package&amp;rsquo;s main or only group should be a member of one or more of the standard customization groups. (To display the full list of them, use</source>
          <target state="translated">程序包的主要或唯一组应该是一个或多个标准定制组的成员。（要显示它们的完整列表，请使用</target>
        </trans-unit>
        <trans-unit id="056f01b4a46a37e98b55727e87a95ecf4b9b9d41" translate="yes" xml:space="preserve">
          <source>The parameter&amp;rsquo;s second element is either one of the symbols &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;frame&lt;/code&gt;, or a list whose elements are the buffer shown in &lt;var&gt;window&lt;/var&gt; before, that buffer&amp;rsquo;s window start and window point positions, and &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s height at that time. If that buffer is still live when &lt;var&gt;window&lt;/var&gt; is quit, then this function may reuse &lt;var&gt;window&lt;/var&gt; to display it.</source>
          <target state="translated">该参数的第二元件是所述码元中的任何一个 &lt;code&gt;window&lt;/code&gt; 或 &lt;code&gt;frame&lt;/code&gt; ，或它的元素是在所示的缓冲器列表 &lt;var&gt;window&lt;/var&gt; 之前，该缓冲器的窗口的开始和窗口点位置，和 &lt;var&gt;window&lt;/var&gt; 当时的高度。如果退出 &lt;var&gt;window&lt;/var&gt; 时该缓冲区仍处于活动状态，则此函数可以重用 &lt;var&gt;window&lt;/var&gt; 来显示它。</target>
        </trans-unit>
        <trans-unit id="e0a39a896d6a8873b9effa21ba5ee259cb0e77fd" translate="yes" xml:space="preserve">
          <source>The parameters described below provide support for resizing a frame by dragging its internal borders with the mouse. They also allow moving a frame with the mouse by dragging the header line of its topmost or the mode line of its bottommost window.</source>
          <target state="translated">下面描述的参数支持通过用鼠标拖动框架的内部边界来调整框架的大小,也允许用鼠标拖动框架最上面的标题线或最下面的窗口的模式线来移动框架。它们还允许用鼠标拖动最上面的页眉线或最下面的窗口的模式线来移动框架。</target>
        </trans-unit>
        <trans-unit id="1c21c17502bd64c3a71bdbc3fc9084a51f8eb952" translate="yes" xml:space="preserve">
          <source>The parent keymap of all &lt;code&gt;local-function-key-map&lt;/code&gt; (q.v.) instances.</source>
          <target state="translated">所有 &lt;code&gt;local-function-key-map&lt;/code&gt; （qv）实例的父键映射。</target>
        </trans-unit>
        <trans-unit id="83241215538033ded1beeee2b0b4fdef97b639a3" translate="yes" xml:space="preserve">
          <source>The parsing facilities of Emacs consider a string as a single token. The usual syntactic meanings of the characters in the string are suppressed.</source>
          <target state="translated">Emacs 的解析工具将一个字符串视为一个单一的标记。字符串中字符的通常语法含义被抑制。</target>
        </trans-unit>
        <trans-unit id="a4782b103645e67a505ec03626df6bb33c90727f" translate="yes" xml:space="preserve">
          <source>The parsing skips spaces and tabs at the beginning of &lt;var&gt;string&lt;/var&gt;, then reads as much of &lt;var&gt;string&lt;/var&gt; as it can interpret as a number in the given base. (On some systems it ignores other whitespace at the beginning, not just spaces and tabs.) If &lt;var&gt;string&lt;/var&gt; cannot be interpreted as a number, this function returns 0.</source>
          <target state="translated">解析会跳过 &lt;var&gt;string&lt;/var&gt; 开头的空格和制表符，然后读取给定基数中可以解释为数字的尽可能多的 &lt;var&gt;string&lt;/var&gt; 。（在某些系统上，它在开始时会忽略其他空格，而不仅仅是空格和制表符。）如果无法将 &lt;var&gt;string&lt;/var&gt; 解释为数字，则此函数返回0。</target>
        </trans-unit>
        <trans-unit id="d08be782a53bbda1ba8dddd6886664346e48d767" translate="yes" xml:space="preserve">
          <source>The parsing technique used by SMIE does not allow tokens to behave differently in different contexts. For most programming languages, this manifests itself by precedence conflicts when converting the BNF grammar.</source>
          <target state="translated">SMIE使用的解析技术不允许标记在不同的上下文中表现不同。对于大多数编程语言来说,这表现为在转换BNF语法时的优先级冲突。</target>
        </trans-unit>
        <trans-unit id="fbb6c29935ae3da3bb37e989df0289bf03fba226" translate="yes" xml:space="preserve">
          <source>The part of the scroll bar on which the click occurred. It is one of the symbols &lt;code&gt;handle&lt;/code&gt; (the scroll bar handle), &lt;code&gt;above-handle&lt;/code&gt; (the area above the handle), &lt;code&gt;below-handle&lt;/code&gt; (the area below the handle), &lt;code&gt;up&lt;/code&gt; (the up arrow at one end of the scroll bar), or &lt;code&gt;down&lt;/code&gt; (the down arrow at one end of the scroll bar).</source>
          <target state="translated">滚动条上发生单击的部分。它是符号 &lt;code&gt;handle&lt;/code&gt; （滚动条手柄）， &lt;code&gt;above-handle&lt;/code&gt; （手柄上方的区域）， &lt;code&gt;below-handle&lt;/code&gt; （手柄下方的区域）， &lt;code&gt;up&lt;/code&gt; （滚动杆一端的向上箭头），或 &lt;code&gt;down&lt;/code&gt; （滚动条一端的向下箭头）。</target>
        </trans-unit>
        <trans-unit id="1168a5f90813f2fcee380e2f6e20037287e336c0" translate="yes" xml:space="preserve">
          <source>The parts of a lambda expression.</source>
          <target state="translated">兰姆达表达式的部分。</target>
        </trans-unit>
        <trans-unit id="b276da95227712619d809e264d610c7532aff153" translate="yes" xml:space="preserve">
          <source>The path to a sound file to play when the notification pops up.</source>
          <target state="translated">通知弹出时要播放的声音文件的路径。</target>
        </trans-unit>
        <trans-unit id="3eb392db1262ef722d3f867992b904857965d5b1" translate="yes" xml:space="preserve">
          <source>The pcase macro</source>
          <target state="translated">pcase宏</target>
        </trans-unit>
        <trans-unit id="bfe752af47d77462d05ad0c5ca61909d42248960" translate="yes" xml:space="preserve">
          <source>The pcase patterns that are useful for destructuring bindings are generally those described in &lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;Backquote Patterns&lt;/a&gt;, since they express a specification of the structure of objects that will match.</source>
          <target state="translated">可用于解构绑定的&lt;a href=&quot;backquote-patterns#Backquote-Patterns&quot;&gt;pcase模式&lt;/a&gt;通常在Backquote模式中描述，因为它们表示将匹配的对象的结构规范。</target>
        </trans-unit>
        <trans-unit id="85e5e6070e7ace2a864fd54495dc677c9fe2f335" translate="yes" xml:space="preserve">
          <source>The percentage of the CPU time used by the process since it started. The corresponding &lt;var&gt;value&lt;/var&gt; is a floating-point number between 0 and 100.</source>
          <target state="translated">自进程开始以来所使用的CPU时间的百分比。对应的 &lt;var&gt;value&lt;/var&gt; 是0到100之间的浮点数。</target>
        </trans-unit>
        <trans-unit id="74a0e3e0b308a0aa69a778516c8eba726d6c3004" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text above the &lt;strong&gt;top&lt;/strong&gt; of window, or &amp;lsquo;</source>
          <target state="translated">窗口&lt;strong&gt;顶部上方&lt;/strong&gt;的缓冲区文本的百分比，即'</target>
        </trans-unit>
        <trans-unit id="5174826a919540ce04dc971e49d9dcc6a90c357a" translate="yes" xml:space="preserve">
          <source>The percentage of the buffer text that is above the &lt;strong&gt;bottom&lt;/strong&gt; of the window (which includes the text visible in the window, as well as the text above the top), plus &amp;lsquo;</source>
          <target state="translated">窗口&lt;strong&gt;底部&lt;/strong&gt;上方的缓冲区文本的百分比（包括窗口中可见的文本以及顶部上方的文本），加上'</target>
        </trans-unit>
        <trans-unit id="0cf9d906bacdebd3353589bccc8f1c56cff833ae" translate="yes" xml:space="preserve">
          <source>The percentage of the total physical memory installed on the machine used by the process&amp;rsquo;s resident set. The value is a floating-point number between 0 and 100.</source>
          <target state="translated">进程的常驻集使用的计算机上已安装的总物理内存的百分比。该值是0到100之间的浮点数。</target>
        </trans-unit>
        <trans-unit id="745b0bf167534b10d93c434c0e1e395113673fc2" translate="yes" xml:space="preserve">
          <source>The percentages of text above both the &lt;strong&gt;top&lt;/strong&gt; and the &lt;strong&gt;bottom&lt;/strong&gt; of the window, separated by &amp;lsquo;</source>
          <target state="translated">窗口&lt;strong&gt;顶部&lt;/strong&gt;和&lt;strong&gt;底部&lt;/strong&gt;&lt;strong&gt;上方&lt;/strong&gt;的文本百分比，以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0de9363c585da842dc94d7cb92e52e9a964df31b" translate="yes" xml:space="preserve">
          <source>The pixel heights of a window&amp;rsquo;s mode and header line can be retrieved with the functions given below. Their return value is usually accurate unless the window has not been displayed before: In that case, the return value is based on an estimate of the font used for the window&amp;rsquo;s frame.</source>
          <target state="translated">窗口模式和标题行的像素高度可以使用下面给出的函数进行检索。除非之前未显示过窗口，否则它们的返回值通常是准确的：在这种情况下，返回值基于用于窗口框架的字体的估计。</target>
        </trans-unit>
        <trans-unit id="43c14cab8a2b2bb269e27efdcb44906c088989c3" translate="yes" xml:space="preserve">
          <source>The pixel size of the font used to open the font.</source>
          <target state="translated">用于打开字体的像素大小。</target>
        </trans-unit>
        <trans-unit id="0d3304078e97e6d9fcd53507ef3658705f5b3745" translate="yes" xml:space="preserve">
          <source>The pixel size of the font.</source>
          <target state="translated">字体的像素大小。</target>
        </trans-unit>
        <trans-unit id="d5e8626e71efeeae5801637fe0d104f5743bf82a" translate="yes" xml:space="preserve">
          <source>The pixel widths of the left and right fringes in this window. A value of -1 means use the values of the frame.</source>
          <target state="translated">这个窗口中左右边缘的像素宽度。值为-1表示使用框架的值。</target>
        </trans-unit>
        <trans-unit id="a476ed7f718dc326836a3ad0a813832b8273668d" translate="yes" xml:space="preserve">
          <source>The place where you insert &amp;lsquo;</source>
          <target state="translated">您插入&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="489704a85a579cab25a1f96c62ae86111efc895a" translate="yes" xml:space="preserve">
          <source>The places within a function where Edebug can stop execution are called &lt;em&gt;stop points&lt;/em&gt;. These occur both before and after each subexpression that is a list, and also after each variable reference. Here we use periods to show the stop points in the function &lt;code&gt;fac&lt;/code&gt;:</source>
          <target state="translated">函数中Edebug可以停止执行的位置称为&lt;em&gt;停止点&lt;/em&gt;。这些发生在列表的每个子表达式之前和之后，以及每个变量引用之后。在这里，我们使用句点来显示函数 &lt;code&gt;fac&lt;/code&gt; 中的停止点：</target>
        </trans-unit>
        <trans-unit id="31d74db390eea1284d7b4e181bb2f481d81da20c" translate="yes" xml:space="preserve">
          <source>The plural &amp;ldquo;frames&amp;rdquo; in the previous paragraph is deliberate: while Emacs itself has only one selected frame, Emacs can have frames on many different terminals (recall that a connection to a window system counts as a terminal), and each terminal has its own idea of which frame has input focus. When you set the input focus to a frame, you set the focus for that frame&amp;rsquo;s terminal, but frames on other terminals may still remain focused.</source>
          <target state="translated">上一段中的复数&amp;ldquo;框架&amp;rdquo;是有意的：虽然Emacs本身只有一个选定的框架，但Emacs可以在许多不同的终端上具有框架（请注意，与窗口系统的连接被视为终端），并且每个终端都有自己的终端哪个框架具有输入焦点的想法。将输入焦点设置为框架时，将为该框架的终端设置焦点，但是其他终端上的框架可能仍保持聚焦。</target>
        </trans-unit>
        <trans-unit id="ce65815e1a28f37a72576e7cbec00483473f471a" translate="yes" xml:space="preserve">
          <source>The point of running a program through the shell, rather than directly with &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, is so that you can employ shell features such as wildcards in the arguments. It follows that if you include any arbitrary user-specified arguments in the command, you should quote them with &lt;code&gt;shell-quote-argument&lt;/code&gt; first, so that any special shell characters do &lt;em&gt;not&lt;/em&gt; have their special shell meanings. See &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Shell Arguments&lt;/a&gt;. Of course, when executing commands based on user input you should also consider the security implications.</source>
          <target state="translated">通过外壳而不是直接通过 &lt;code&gt;make-process&lt;/code&gt; 或 &lt;code&gt;start-process&lt;/code&gt; 运行程序的目的是，您可以在参数中使用外壳功能，例如通配符。因此，如果在命令中包含任何用户指定的任意参数，则应首先用 &lt;code&gt;shell-quote-argument&lt;/code&gt; 引用它们，以便任何特殊的shell字符&lt;em&gt;都不&lt;/em&gt;具有其特殊的shell含义。请参阅&lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;Shell参数&lt;/a&gt;。当然，在基于用户输入执行命令时，您还应该考虑安全隐患。</target>
        </trans-unit>
        <trans-unit id="87e05b91e6233e17b204f23015097c7049303099" translate="yes" xml:space="preserve">
          <source>The position at which the line being indented begins.</source>
          <target state="translated">被缩进的线开始的位置。</target>
        </trans-unit>
        <trans-unit id="45b07b40e31e169ede72cfe22029fabdc54bc98b" translate="yes" xml:space="preserve">
          <source>The position in the buffer for which the line number is known, or zero meaning none is known. If it is -1, don&amp;rsquo;t display the line number as long as the window shows that buffer.</source>
          <target state="translated">缓冲区中的行号已知的位置，或者为零（意味着不知道）的位置。如果为-1，则只要窗口显示该缓冲区，就不显示行号。</target>
        </trans-unit>
        <trans-unit id="7bb41d39783192e6aaaa6d09fb0dcd6b9d067af6" translate="yes" xml:space="preserve">
          <source>The position in the string where the click occurred.</source>
          <target state="translated">字符串中发生点击的位置。</target>
        </trans-unit>
        <trans-unit id="1c5737b61d1133d53c07a40026bed5c9ffc696e8" translate="yes" xml:space="preserve">
          <source>The position of a frame on its display.</source>
          <target state="translated">帧在其显示上的位置。</target>
        </trans-unit>
        <trans-unit id="887258f07e45dd70c1b6e53e04e7f416f5a7b904" translate="yes" xml:space="preserve">
          <source>The position of point, as an integer (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;). No I/O.</source>
          <target state="translated">点的位置，以整数表示（请参见&lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;）。没有I / O。</target>
        </trans-unit>
        <trans-unit id="6403590e242da2f2207180f395d2c07e997ed88a" translate="yes" xml:space="preserve">
          <source>The position of the frame on the screen.</source>
          <target state="translated">画面在屏幕上的位置。</target>
        </trans-unit>
        <trans-unit id="255ed0f6aab596c870f5c23defcace62009a4b51" translate="yes" xml:space="preserve">
          <source>The position of the mark, as an integer. No I/O.</source>
          <target state="translated">标记的位置,为整数。没有I/O。</target>
        </trans-unit>
        <trans-unit id="a5dd7b877105dceee61a4c59515a66464dc839be" translate="yes" xml:space="preserve">
          <source>The position of the tool bar when Emacs was built with GTK+. Its value can be one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. The default is &lt;code&gt;top&lt;/code&gt;.</source>
          <target state="translated">使用GTK +构建Emacs时工具栏的位置。它的值可以是一个 &lt;code&gt;top&lt;/code&gt; ， &lt;code&gt;bottom&lt;/code&gt; &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; 。默认值为 &lt;code&gt;top&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d4165115759fe0837c49ced5e39ea743ea4c2a" translate="yes" xml:space="preserve">
          <source>The position of the top left corner of the native frame specifies the &lt;em&gt;native position&lt;/em&gt; of the frame. (1)&amp;ndash;(3) in the drawing above indicate that position for the various builds:</source>
          <target state="translated">本机框架左上角的&lt;em&gt;位置&lt;/em&gt;指定框架的&lt;em&gt;本机位置&lt;/em&gt;。上图中的（1）&amp;ndash;（3）指出了各种构建的位置：</target>
        </trans-unit>
        <trans-unit id="833e5a5239b46b2d55c382c18b023ecd55ad49ca" translate="yes" xml:space="preserve">
          <source>The position of the upper left corner of the outer frame (indicated by &amp;lsquo;</source>
          <target state="translated">外框左上角的位置（用'</target>
        </trans-unit>
        <trans-unit id="8410a3b5f6f9e6c84d904b172515815de91f0dd2" translate="yes" xml:space="preserve">
          <source>The position, in pixels, of the left outer edge of the frame with respect to the left edge of the frame&amp;rsquo;s display or parent frame. It can be specified in one of the following ways.</source>
          <target state="translated">框架左外边缘相对于框架显示器或父框架左边缘的位置（以像素为单位）。可以通过以下方式之一指定。</target>
        </trans-unit>
        <trans-unit id="159bfe6471c89158a22673c87af74200df998625" translate="yes" xml:space="preserve">
          <source>The possible values for an actual subprocess are:</source>
          <target state="translated">一个实际子程序的可能值是:</target>
        </trans-unit>
        <trans-unit id="ca9c70ab4f2597d1a37484e4797e646e200cc36c" translate="yes" xml:space="preserve">
          <source>The preceding examples all use sequencing patterns which include the &lt;var&gt;symbol&lt;/var&gt; sub-pattern in some way. Here are some important details about that usage.</source>
          <target state="translated">前面的示例均使用排序模式，该排序模式以某种方式包括 &lt;var&gt;symbol&lt;/var&gt; 子模式。以下是有关该用法的一些重要详细信息。</target>
        </trans-unit>
        <trans-unit id="a258153ccf268c951438b192904eade1c144e0c6" translate="yes" xml:space="preserve">
          <source>The precise effect of adding a value depends on the customization type of &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">添加值的精确效果取决于 &lt;var&gt;symbol&lt;/var&gt; 的自定义类型。</target>
        </trans-unit>
        <trans-unit id="3f4009f97f05ca5f3cb51352b6efa1949bc23635" translate="yes" xml:space="preserve">
          <source>The precise meaning of a value of &lt;code&gt;nil&lt;/code&gt; for this option depends on the toolkit used. Dragging the external border with the mouse is done character-wise provided the window manager is willing to process the corresponding size hints. Calling &lt;code&gt;set-frame-size&lt;/code&gt; (see below) with arguments that do not specify the frame size as an integer multiple of its character size, however, may: be ignored, cause a rounding (GTK+), or be accepted (Lucid, Motif, MS-Windows).</source>
          <target state="translated">此选项的值 &lt;code&gt;nil&lt;/code&gt; 的确切含义取决于所使用的工具包。只要窗口管理器愿意处理相应的大小提示，就可以按字符方式拖动外部边框。使用未将帧大小指定为其字符大小的整数倍的参数调用 &lt;code&gt;set-frame-size&lt;/code&gt; （请参见下文），但是可以：被忽略，导致舍入（GTK +）或被接受（Lucid，Motif， MS-Windows）。</target>
        </trans-unit>
        <trans-unit id="b4aa737004ad2535ebe02bb899113024dc279e7a" translate="yes" xml:space="preserve">
          <source>The precise meaning of the event parameters and the way these parameters are used to display the help-echo text are described in &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;文本help-echo&lt;/a&gt;中描述了事件参数的确切含义以及这些参数用于显示help-echo文本的方式。</target>
        </trans-unit>
        <trans-unit id="c34b9bbf535e3965b815554ff0467b7f149d988d" translate="yes" xml:space="preserve">
          <source>The previous buffer is usually the buffer shown before the buffer currently shown in &lt;var&gt;window&lt;/var&gt;. However, a buffer that has been buried or killed, or has been already shown by a recent invocation of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, does not qualify as previous buffer.</source>
          <target state="translated">前一个缓冲区通常是 &lt;var&gt;window&lt;/var&gt; 中当前显示的缓冲区之前显示的缓冲区。但是，已被掩埋或杀死的缓冲区或最近调用 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 所显示的缓冲区不符合先前的缓冲区的条件。</target>
        </trans-unit>
        <trans-unit id="28721bd17842d6dccb7fd270c15c4194e8d5baba" translate="yes" xml:space="preserve">
          <source>The primary use of this function is as a subroutine by constructs that define or alter functions, like &lt;code&gt;defun&lt;/code&gt; or &lt;code&gt;advice-add&lt;/code&gt; (see &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;):</source>
          <target state="translated">该函数的主要用途是作为定义或更改函数的构造的子例程，例如 &lt;code&gt;defun&lt;/code&gt; 或 &lt;code&gt;advice-add&lt;/code&gt; （请参阅&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising函数&lt;/a&gt;）。您也可以使用它为符号赋予非函数的函数定义，例如，键盘宏（请参阅&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ba9b5b776cc5667a85cd400075ca47d55ca09c2c" translate="yes" xml:space="preserve">
          <source>The primitive that extracts text from the buffer along with its properties is &lt;code&gt;buffer-substring&lt;/code&gt;. Before examining the properties, this function runs the abnormal hook &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt;.</source>
          <target state="translated">从缓冲区中提取文本及其属性的原语是 &lt;code&gt;buffer-substring&lt;/code&gt; 。在检查属性之前，此函数将运行异常的hook &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a90a548ae4af1e7a922a25155c161c7315ce8da" translate="yes" xml:space="preserve">
          <source>The primitive way to create a byte-code object is with &lt;code&gt;make-byte-code&lt;/code&gt;:</source>
          <target state="translated">创建字节码对象的原始方法是使用 &lt;code&gt;make-byte-code&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4906a197371ef069deb8bf9326d82ffeae4a7205" translate="yes" xml:space="preserve">
          <source>The primitives for changing properties apply to a specified range of text in a buffer or string. The function &lt;code&gt;set-text-properties&lt;/code&gt; (see end of section) sets the entire property list of the text in that range; more often, it is useful to add, change, or delete just certain properties specified by name.</source>
          <target state="translated">用于更改属性的原语适用于缓冲区或字符串中指定范围的文本。函数 &lt;code&gt;set-text-properties&lt;/code&gt; （请参见本节末尾）在该范围内设置文本的整个属性列表。通常，添加，更改或删除仅由名称指定的某些属性很有用。</target>
        </trans-unit>
        <trans-unit id="86e6972405ceac8fb0c2ebcbb1d084d74c15e137" translate="yes" xml:space="preserve">
          <source>The principal function for creating a hash table is &lt;code&gt;make-hash-table&lt;/code&gt;.</source>
          <target state="translated">创建哈希表的主要功能是 &lt;code&gt;make-hash-table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e0ef3a61ced98eb5fb2f872d19a707b38cfe6c5" translate="yes" xml:space="preserve">
          <source>The principal purpose of coding systems is for use in reading and writing files. The function &lt;code&gt;insert-file-contents&lt;/code&gt; uses a coding system to decode the file data, and &lt;code&gt;write-region&lt;/code&gt; uses one to encode the buffer contents.</source>
          <target state="translated">编码系统的主要目的是用于读写文件。函数 &lt;code&gt;insert-file-contents&lt;/code&gt; 使用一种编码系统对文件数据进行解码，而 &lt;code&gt;write-region&lt;/code&gt; 使用一种对缓冲区内容进行编码。</target>
        </trans-unit>
        <trans-unit id="55a4ae7918bc297ffd67f49ed5d08ef37025a3dc" translate="yes" xml:space="preserve">
          <source>The print name cell always holds a string, and cannot be changed. Each of the other three cells can be set to any Lisp object.</source>
          <target state="translated">打印名称单元格始终是一个字符串,不能更改。其他三个单元格都可以设置为任何Lisp对象。</target>
        </trans-unit>
        <trans-unit id="de95f3a3b46a96121feaa824d316764b0883107a" translate="yes" xml:space="preserve">
          <source>The print name cell holds the string that is the name of a symbol. Since symbols are represented textually by their names, it is important not to have two symbols with the same name. The Lisp reader ensures this: every time it reads a symbol, it looks for an existing symbol with the specified name before it creates a new one. To get a symbol&amp;rsquo;s name, use the function &lt;code&gt;symbol-name&lt;/code&gt; (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">打印名称单元格包含作为符号名称的字符串。由于符号由名称以文本形式表示，因此重要的是不要让两个符号具有相同的名称。Lisp读取器确保了这一点：每次读取符号时，它都会在创建新符号之前查找具有指定名称的现有符号。要获取符号名称，请使用 &lt;code&gt;symbol-name&lt;/code&gt; 功能（请参阅&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建符号&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2bbc34bf200918e9a448ed9f1f2b1f066e970b26" translate="yes" xml:space="preserve">
          <source>The printed form represents up to 8 boolean values as a single character:</source>
          <target state="translated">打印的表格最多可以用一个字符表示8个布尔值。</target>
        </trans-unit>
        <trans-unit id="12644b40b0774ec2e789694cfc7abf62c019cde5" translate="yes" xml:space="preserve">
          <source>The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">字节码功能对象的打印表示形式和读取语法类似于矢量，带有附加的'</target>
        </trans-unit>
        <trans-unit id="93d512217d9e0e619c1036f6280703870832034c" translate="yes" xml:space="preserve">
          <source>The printed representation for a hash table consists of &amp;lsquo;</source>
          <target state="translated">哈希表的打印表示形式由'</target>
        </trans-unit>
        <trans-unit id="861954f964e54658232242a23ea2b7ee8994c956" translate="yes" xml:space="preserve">
          <source>The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, &amp;lsquo;</source>
          <target state="translated">浮点数的打印表示形式需要小数点（后面至少跟一位数字），指数或两者兼有。例如， '</target>
        </trans-unit>
        <trans-unit id="7b99966b7387dd5ed35f73f081dbe0bcb6cc5e9b" translate="yes" xml:space="preserve">
          <source>The printed representation of a bool-vector is like a string, except that it begins with &amp;lsquo;</source>
          <target state="translated">bool-vector的打印表示形式类似于字符串，只是它以'开头</target>
        </trans-unit>
        <trans-unit id="9a73160413b74c1de6679be1eae2e2a5562706a0" translate="yes" xml:space="preserve">
          <source>The printed representation of a char-table is like a vector except that there is an extra &amp;lsquo;</source>
          <target state="translated">字符表的打印表示形式类似于矢量，不同之处在于有一个额外的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cf4d2204ede2ec7542b976b427c02ab6ac905744" translate="yes" xml:space="preserve">
          <source>The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.</source>
          <target state="translated">矢量的打印表示由左方括号、元素和右方括号组成。这也是读的语法。与数字和字符串一样,向量也被认为是评估的常量。</target>
        </trans-unit>
        <trans-unit id="54bdda2e2c897bbee3fd6ea2ce6150e050bbdbf0" translate="yes" xml:space="preserve">
          <source>The printed representation of an interned symbol whose name is an empty string (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">实习生符号的打印表示形式，其名称为空字符串（请参见&lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b6b4f81ab9ddc9b498748d084ab114136d13e0d2" translate="yes" xml:space="preserve">
          <source>The printed representation of an uninterned symbol whose name is &lt;var&gt;foo&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">名称为 &lt;var&gt;foo&lt;/var&gt; 的未中断符号的打印表示形式为'</target>
        </trans-unit>
        <trans-unit id="f0d146789656a2ca889b28283579fa331b709ea3" translate="yes" xml:space="preserve">
          <source>The printed representation of records is &amp;lsquo;</source>
          <target state="translated">记录的印刷表示为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="06414aa54aa49ed289b3f642280e72ea07845a4c" translate="yes" xml:space="preserve">
          <source>The priority matters when two or more overlays cover the same character and both specify the same property; the one whose &lt;code&gt;priority&lt;/code&gt; value is larger overrides the other. (For the &lt;code&gt;face&lt;/code&gt; property, the higher priority overlay&amp;rsquo;s value does not completely override the other value; instead, its face attributes override the face attributes of the lower priority &lt;code&gt;face&lt;/code&gt; property.) If two overlays have the same priority value, and one is nested in the other, then the inner one will prevail over the outer one. If neither is nested in the other then you should not make assumptions about which overlay will prevail.</source>
          <target state="translated">当两个或多个叠加覆盖相同的字符并且都指定相同的属性时，优先级就很重要。 &lt;code&gt;priority&lt;/code&gt; 值较大的一个优先于另一个。（对于 &lt;code&gt;face&lt;/code&gt; 属性，优先级较高的叠加层的值不会完全覆盖另一个值；相反，其优先级较低的优先级的 &lt;code&gt;face&lt;/code&gt; 属性会覆盖其优先级值。）如果两个叠加层具有相同的优先级值，并且其中一个嵌套在另一个，则内部的将优先于外部的。如果两者都不嵌套，则不应假设哪个覆盖层将占优势。</target>
        </trans-unit>
        <trans-unit id="e73afd850ba19d88fffc870b34d4546ef04a4eba" translate="yes" xml:space="preserve">
          <source>The process ID of the parent process, a number.</source>
          <target state="translated">父进程的进程ID,一个数字。</target>
        </trans-unit>
        <trans-unit id="53e1a9ea303ee6836b551778e58f2f51e300eedc" translate="yes" xml:space="preserve">
          <source>The process group ID of the process, a number.</source>
          <target state="translated">流程的流程组ID,一个数字。</target>
        </trans-unit>
        <trans-unit id="4ccf440991f7f0652996b8ab7560a4dbe5b3aace" translate="yes" xml:space="preserve">
          <source>The process status, as &lt;code&gt;process-status&lt;/code&gt; should return it. This is a Lisp symbol, a cons cell, or a list.</source>
          <target state="translated">流程状态，应以 &lt;code&gt;process-status&lt;/code&gt; 返回。这是一个Lisp符号，一个cons单元格或一个列表。</target>
        </trans-unit>
        <trans-unit id="69ecf0580268b93750c7e889a04309c3293a5f2b" translate="yes" xml:space="preserve">
          <source>The processes are shown in a buffer named</source>
          <target state="translated">进程显示在一个名为</target>
        </trans-unit>
        <trans-unit id="6c8f30c53cf4f4d39e77991527ad73dbc1793851" translate="yes" xml:space="preserve">
          <source>The product name of the server.</source>
          <target state="translated">服务器的产品名称。</target>
        </trans-unit>
        <trans-unit id="0cd39baec68fc236a0a093df363f5e95bd2c4fb6" translate="yes" xml:space="preserve">
          <source>The profiler report buffer shows, on each line, a function that was called, followed by how much resources (cpu or memory) it used in absolute and percentage terms since profiling started. If a given line has a &amp;lsquo;</source>
          <target state="translated">探查器报告缓冲区在每一行上显示了已调用的函数，以及自分析开始以来以绝对和百分比形式使用了多少资源（cpu或内存）。如果给定的行具有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d9d8457c45fc52a797df2f33e4e4ba6a34bec404" translate="yes" xml:space="preserve">
          <source>The prompt string can use &amp;lsquo;</source>
          <target state="translated">提示字符串可以使用'</target>
        </trans-unit>
        <trans-unit id="0ea085744f883658e286f289c21d5bb3c923b174" translate="yes" xml:space="preserve">
          <source>The proper place to use &lt;code&gt;defalias&lt;/code&gt; is where a specific function name is being defined&amp;mdash;especially where that name appears explicitly in the source file being loaded. This is because &lt;code&gt;defalias&lt;/code&gt; records which file defined the function, just like &lt;code&gt;defun&lt;/code&gt; (see &lt;a href=&quot;unloading#Unloading&quot;&gt;Unloading&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;defalias&lt;/code&gt; 的正确位置是在定义特定函数名称的地方，尤其是该名称在要加载的源文件中显式出现的地方。这是因为 &lt;code&gt;defalias&lt;/code&gt; 该文件中定义的功能，就像记录 &lt;code&gt;defun&lt;/code&gt; 定义（见&lt;a href=&quot;unloading#Unloading&quot;&gt;卸载&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d90fe58bfa2b87a1b1cbc6838a53a60deea67366" translate="yes" xml:space="preserve">
          <source>The proper way to construct a keymap with a parent is to use &lt;code&gt;set-keymap-parent&lt;/code&gt;; if you have code that directly constructs a keymap with a parent, please convert the program to use &lt;code&gt;set-keymap-parent&lt;/code&gt; instead.</source>
          <target state="translated">与父级构造键映射的正确方法是使用 &lt;code&gt;set-keymap-parent&lt;/code&gt; ; 如果您有直接与父代构造键映射的代码，请将该程序转换为使用 &lt;code&gt;set-keymap-parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dfec31a43b4f7ab97faaddb57234977bb256c37" translate="yes" xml:space="preserve">
          <source>The property list cell normally should hold a correctly formatted property list. To get a symbol&amp;rsquo;s property list, use the function &lt;code&gt;symbol-plist&lt;/code&gt;. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;.</source>
          <target state="translated">属性列表单元格通常应包含格式正确的属性列表。要获取符号的属性列表，请使用 &lt;code&gt;symbol-plist&lt;/code&gt; 函数。请参见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;符号属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c911a8445b3bd7bfea7954dcdd17b841dcbd3fcb" translate="yes" xml:space="preserve">
          <source>The property&amp;rsquo;s value for the character before point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and rear-sticky, and the property&amp;rsquo;s value for the character after point applies if it is non-&lt;code&gt;nil&lt;/code&gt; and front-sticky. (For mouse clicks, the position of the click is used instead of the position of point.)</source>
          <target state="translated">酒店对点之前的字符值适用，如果它是非 &lt;code&gt;nil&lt;/code&gt; 和后发粘，物业对点之后的字符值适用，如果它是非 &lt;code&gt;nil&lt;/code&gt; 和前粘性。（对于鼠标单击，将使用单击的位置而不是点的位置。）</target>
        </trans-unit>
        <trans-unit id="78c51406ca787ccde17c730ea362d97d0f2b5d6a" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;throw&lt;/code&gt; is to return from a return point previously established with &lt;code&gt;catch&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is used to choose among the various existing return points; it must be &lt;code&gt;eq&lt;/code&gt; to the value specified in the &lt;code&gt;catch&lt;/code&gt;. If multiple return points match &lt;var&gt;tag&lt;/var&gt;, the innermost one is used.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 的目的是从先前使用 &lt;code&gt;catch&lt;/code&gt; 建立的返回点返回。参数 &lt;var&gt;tag&lt;/var&gt; 用于在各种现有的返回点之间进行选择。它必须是 &lt;code&gt;eq&lt;/code&gt; 在指定的值 &lt;code&gt;catch&lt;/code&gt; 。如果有多个返回点与 &lt;var&gt;tag&lt;/var&gt; 匹配，则使用最里面的一个。</target>
        </trans-unit>
        <trans-unit id="a798f48d5361b3f20f9b8da5927f51db1ca4bd70" translate="yes" xml:space="preserve">
          <source>The purpose of records is to allow programmers to create objects with new types that are not built into Emacs. They are used as the underlying representation of &lt;code&gt;cl-defstruct&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; instances.</source>
          <target state="translated">记录的目的是允许程序员使用Emacs中未内置的新类型创建对象。它们用作 &lt;code&gt;cl-defstruct&lt;/code&gt; 和 &lt;code&gt;defclass&lt;/code&gt; 实例的基础表示。</target>
        </trans-unit>
        <trans-unit id="6b48773be77ed3bf897730ad62b02207f496fa84" translate="yes" xml:space="preserve">
          <source>The purpose of this variable is to prevent unreasonably large images from accidentally being loaded into Emacs. It only takes effect the first time an image is loaded. Once an image is placed in the image cache, it can always be displayed, even if the value of &lt;code&gt;max-image-size&lt;/code&gt; is subsequently changed (see &lt;a href=&quot;image-cache#Image-Cache&quot;&gt;Image Cache&lt;/a&gt;).</source>
          <target state="translated">此变量的目的是防止不合理的大图像意外加载到Emacs中。仅在第一次加载图像时生效。将图像放入图像缓存后，即使随后更改了 &lt;code&gt;max-image-size&lt;/code&gt; 的值，也可以始终显示该图像（请参见&lt;a href=&quot;image-cache#Image-Cache&quot;&gt;Image Cache&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8b698db8f7ae03128e22b00ae5ae3b89fa737eaf" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1) but many machines provide a wider range.</source>
          <target state="translated">fixnum的数值范围取决于机器。最小范围是-536,870,912至536,870,911(30位;即-2**29至2**29-1),但许多机器提供了更大的范围。</target>
        </trans-unit>
        <trans-unit id="af85b0412ddc48c46d5b6e80df88faf36ad2e739" translate="yes" xml:space="preserve">
          <source>The range of values for a fixnum depends on the machine. The minimum range is -536,870,912 to 536,870,911 (30 bits; i.e., -2**29 to 2**29 - 1), but many machines provide a wider range.</source>
          <target state="translated">fixnum的数值范围取决于机器。最小范围是-536,870,912到536,870,911(30位;即-2**29到2**29-1),但许多机器提供了更大的范围。</target>
        </trans-unit>
        <trans-unit id="cce27534771922ba161893777df990814edba95c" translate="yes" xml:space="preserve">
          <source>The range of values for bignums is limited by the amount of main memory, by machine characteristics such as the size of the word used to represent a bignum&amp;rsquo;s exponent, and by the &lt;code&gt;integer-width&lt;/code&gt; variable. These limits are typically much more generous than the limits for fixnums. A bignum is never numerically equal to a fixnum; Emacs always represents an integer in fixnum range as a fixnum, not a bignum.</source>
          <target state="translated">bignum的值范围受主内存量，机器特征（例如，用于表示bignum指数的单词的大小）和 &lt;code&gt;integer-width&lt;/code&gt; 变量的限制。这些限制通常比fixnum的限制要慷慨得多。一个bignum永远不会在数值上等于一个fixnum。Emacs始终将fixnum范围内的整数表示为fixnum，而不是bignum。</target>
        </trans-unit>
        <trans-unit id="88fcc9a379dd1cc063bcdc17672afd2ddd066644" translate="yes" xml:space="preserve">
          <source>The raw prefix argument value used by the previous command.</source>
          <target state="translated">前一个命令使用的原始前缀参数值。</target>
        </trans-unit>
        <trans-unit id="188580ce5aed7a8d00ced05add7b99d84193146d" translate="yes" xml:space="preserve">
          <source>The raw prefix argument. (Note that this &amp;lsquo;</source>
          <target state="translated">原始前缀参数。（请注意，此&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="918eb5fe78ecdeb2b74cf1c707d70d8317c7c8ca" translate="yes" xml:space="preserve">
          <source>The raw process status, as returned by the &lt;code&gt;wait&lt;/code&gt; system call.</source>
          <target state="translated">由 &lt;code&gt;wait&lt;/code&gt; 系统调用返回的原始进程状态。</target>
        </trans-unit>
        <trans-unit id="8d40522328efd69f1813ecc9395f2a99749405bb" translate="yes" xml:space="preserve">
          <source>The read syntax &lt;code&gt;#'&lt;/code&gt; is a short-hand for using &lt;code&gt;function&lt;/code&gt;. The following forms are all equivalent:</source>
          <target state="translated">读取语法 &lt;code&gt;#'&lt;/code&gt; 是使用 &lt;code&gt;function&lt;/code&gt; 的简写。以下形式都是等效的：</target>
        </trans-unit>
        <trans-unit id="f0ccfae7f5d50ab8dd7bf0125292e2e7d92e715d" translate="yes" xml:space="preserve">
          <source>The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:</source>
          <target state="translated">列表的读取语法和打印表示方法是相同的,由一个左括号、任意数量的元素和一个右括号组成。下面是列表的例子。</target>
        </trans-unit>
        <trans-unit id="699968d5ddfd6c3b251c3bfee7172adb575ecba8" translate="yes" xml:space="preserve">
          <source>The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, &lt;code&gt;&quot;like this&quot;&lt;/code&gt;. To include a double-quote in a string, precede it with a backslash; thus, &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: &lt;code&gt;&quot;this \\ is a single embedded
backslash&quot;&lt;/code&gt;.</source>
          <target state="translated">字符串的读取语法是双引号，任意数量的字符和另一个双引号 &lt;code&gt;&quot;like this&quot;&lt;/code&gt; 。要在字符串中包含双引号，请在其前面加上反斜杠；因此， &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; 是一个仅包含一个双引号字符的字符串。同样，您可以在其前面加上另一个反斜杠来包含一个反斜杠，例如： &lt;code&gt;&quot;this \\ is a single embedded backslash&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2db9c5ad71fdc5297e7b04c37c25b525f29392e3" translate="yes" xml:space="preserve">
          <source>The read syntax for floating-point numbers requires either a decimal point, an exponent, or both. Optional signs (&amp;lsquo;</source>
          <target state="translated">浮点数的读取语法需要小数点和/或指数。可选标志（'</target>
        </trans-unit>
        <trans-unit id="468ea3ba2253c757dfcdac67156c541df702374c" translate="yes" xml:space="preserve">
          <source>The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading &amp;lsquo;</source>
          <target state="translated">整数的读取语法是（十个基数）数字的序列，在其开头有一个可选符号，在结尾有一个可选句号。 Lisp口译员制作的印刷作品从来没有领先的'</target>
        </trans-unit>
        <trans-unit id="a0df8f0e56b27b7fdf3f7492d928c4cf0eb4466b" translate="yes" xml:space="preserve">
          <source>The read syntax for meta characters uses &amp;lsquo;</source>
          <target state="translated">元字符的读取语法使用'</target>
        </trans-unit>
        <trans-unit id="ef7e662450af28ad76f1d8a4260adb6e69ae8a34" translate="yes" xml:space="preserve">
          <source>The reason for a mode to change this variable instead of &lt;code&gt;revert-buffer-function&lt;/code&gt; is to avoid duplicating or replacing the rest of what &lt;code&gt;revert-buffer&lt;/code&gt; does: asking for confirmation, clearing the undo list, deciding the proper major mode, and running the hooks listed below.</source>
          <target state="translated">模式更改此变量而不是使用 &lt;code&gt;revert-buffer-function&lt;/code&gt; 的原因是为了避免重复或替换其余的 &lt;code&gt;revert-buffer&lt;/code&gt; 功能：要求确认，清除撤消列表，确定适当的主模式以及运行钩子下面列出。</target>
        </trans-unit>
        <trans-unit id="4a9fa0be0804d13fd54899e6b26f2ba4d73ac7bd" translate="yes" xml:space="preserve">
          <source>The reason for the name &lt;code&gt;lazy&lt;/code&gt; is that the other composite widgets convert their inferior widgets to internal form when the widget is instantiated in a buffer. This conversion is recursive, so the inferior widgets will convert &lt;em&gt;their&lt;/em&gt; inferior widgets. If the data structure is itself recursive, this conversion is an infinite recursion. The &lt;code&gt;lazy&lt;/code&gt; widget prevents the recursion: it convert its &lt;code&gt;:type&lt;/code&gt; argument only when needed.</source>
          <target state="translated">之所以说是 &lt;code&gt;lazy&lt;/code&gt; 是因为在缓冲区中实例化其他复合小部件时，其他复合小部件会将其劣等小部件转换为内部形式。此转换是递归的，因此下级小部件将转换&lt;em&gt;其&lt;/em&gt;下级小部件。如果数据结构本身是递归的，则此转换是无限递归。在 &lt;code&gt;lazy&lt;/code&gt; 小部件防止递归：它转换的 &lt;code&gt;:type&lt;/code&gt; 只在需要时的说法。</target>
        </trans-unit>
        <trans-unit id="97c008ed1abdd793cef86b5d0eab947dc6ccb62d" translate="yes" xml:space="preserve">
          <source>The reason for this somewhat complex behavior is that it lets users easily toggle the minor mode interactively, and also lets the minor mode be easily enabled in a mode hook, like this:</source>
          <target state="translated">这种有点复杂的行为的原因是,它可以让用户很容易地交互式地切换小模式,也可以让小模式很容易地在模式钩中启用,就像这样。</target>
        </trans-unit>
        <trans-unit id="ab43773cfe02cb70d41dd331c0415859809fddf1" translate="yes" xml:space="preserve">
          <source>The recommended way to add a hook function to a hook is by calling &lt;code&gt;add-hook&lt;/code&gt; (see &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;Setting Hooks&lt;/a&gt;). The hook functions may be any of the valid kinds of functions that &lt;code&gt;funcall&lt;/code&gt; accepts (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;). Most normal hook variables are initially void; &lt;code&gt;add-hook&lt;/code&gt; knows how to deal with this. You can add hooks either globally or buffer-locally with &lt;code&gt;add-hook&lt;/code&gt;.</source>
          <target state="translated">向钩子添加钩子函数的推荐方法是调用 &lt;code&gt;add-hook&lt;/code&gt; （请参阅&lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;设置钩子&lt;/a&gt;）。挂钩函数可以是 &lt;code&gt;funcall&lt;/code&gt; 接受的任何有效类型的函数（请参阅&amp;ldquo;&lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;什么是函数&amp;rdquo;&lt;/a&gt;）。大多数普通的钩子变量最初都是无效的。 &lt;code&gt;add-hook&lt;/code&gt; 知道如何处理。您可以使用 &lt;code&gt;add-hook&lt;/code&gt; 在全局或局部缓冲区中添加钩子。</target>
        </trans-unit>
        <trans-unit id="e72e25c71fad41850c51c81a50b1cd4e2873976c" translate="yes" xml:space="preserve">
          <source>The recommended way to define a new major mode is to derive it from an existing one using &lt;code&gt;define-derived-mode&lt;/code&gt;. If there is no closely related mode, you should inherit from either &lt;code&gt;text-mode&lt;/code&gt;, &lt;code&gt;special-mode&lt;/code&gt;, or &lt;code&gt;prog-mode&lt;/code&gt;. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;. If none of these are suitable, you can inherit from &lt;code&gt;fundamental-mode&lt;/code&gt; (see &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;).</source>
          <target state="translated">推荐的定义新主模式的方法是使用 &lt;code&gt;define-derived-mode&lt;/code&gt; 从现有的主模式中派生它。如果没有紧密相关的模式，则应该从 &lt;code&gt;text-mode&lt;/code&gt; ， &lt;code&gt;special-mode&lt;/code&gt; 或 &lt;code&gt;prog-mode&lt;/code&gt; 继承。请参阅&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本专业模式&lt;/a&gt;。如果这些都不适合，则可以从 &lt;code&gt;fundamental-mode&lt;/code&gt; 继承（请参阅&amp;ldquo;&lt;a href=&quot;major-modes#Major-Modes&quot;&gt;主要模式&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="55ee00344a022e04c610024dc173a8e737831bfc" translate="yes" xml:space="preserve">
          <source>The recommended way to use this function is to specify a name which fits the conventions of GNU and Unix systems, and pass it to &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">建议使用此功能的方法是指定一个符合GNU和Unix系统约定的名称，并将其传递给 &lt;code&gt;convert-standard-filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55eca5446859f2ea52f9e345f8531406554a48b1" translate="yes" xml:space="preserve">
          <source>The redirection lasts until &lt;code&gt;redirect-frame-focus&lt;/code&gt; is called to change it.</source>
          <target state="translated">重定向一直持续到调用 &lt;code&gt;redirect-frame-focus&lt;/code&gt; 更改它为止。</target>
        </trans-unit>
        <trans-unit id="1a588fb9e8fcf72cfed3b3eefc36b97e65fb8bbc" translate="yes" xml:space="preserve">
          <source>The reference to &lt;var&gt;variable&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;variable&lt;/var&gt; must appear quoted in the call to &lt;code&gt;boundp&lt;/code&gt;.</source>
          <target state="translated">于参考 &lt;var&gt;variable&lt;/var&gt; 一定要在 &lt;var&gt;then-form&lt;/var&gt; 的的 &lt;code&gt;if&lt;/code&gt; ，和 &lt;var&gt;variable&lt;/var&gt; 必须在呼叫出现引述 &lt;code&gt;boundp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e411de3f279f8655e1e219fed4c21701eca0eed7" translate="yes" xml:space="preserve">
          <source>The references to &lt;code&gt;max&lt;/code&gt; inside the body of the &lt;code&gt;for&lt;/code&gt;, which are supposed to refer to the user&amp;rsquo;s binding of &lt;code&gt;max&lt;/code&gt;, really access the binding made by &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 主体内部对 &lt;code&gt;max&lt;/code&gt; 的引用（应该引用用户对 &lt;code&gt;max&lt;/code&gt; 的绑定）实际上访问了 &lt;code&gt;for&lt;/code&gt; 进行的绑定。</target>
        </trans-unit>
        <trans-unit id="a5e79117bc2adbb317bdcd941ebc194bbe9e52a9" translate="yes" xml:space="preserve">
          <source>The reformulation demonstrates &lt;var&gt;symbol&lt;/var&gt; binding as well as &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;pred&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">再形成示范 &lt;var&gt;symbol&lt;/var&gt; 结合，以及 &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;pred&lt;/code&gt; ， &lt;code&gt;app&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b316e0a4b7481395ac11f35d1a9f8c1cc3b4cde" translate="yes" xml:space="preserve">
          <source>The relative pixel coordinates of the click. For clicks in the text area of a window, the coordinate origin &lt;code&gt;(0 . 0)&lt;/code&gt; is taken to be the top left corner of the text area. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. For clicks in a mode line, header line or tab line, the coordinate origin is the top left corner of the window itself. For fringes, margins, and the vertical border, &lt;var&gt;x&lt;/var&gt; does not have meaningful data. For fringes and margins, &lt;var&gt;y&lt;/var&gt; is relative to the bottom edge of the header line. In all cases, the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; coordinates increase rightward and downward respectively.</source>
          <target state="translated">点击的相对像素坐标。对于在窗口的文本区域中的单击，坐标原点 &lt;code&gt;(0 . 0)&lt;/code&gt; 被视为文本区域的左上角。请参阅&lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;窗口大小&lt;/a&gt;。对于模式行，标题行或制表行中的单击，坐标原点是窗口本身的左上角。对于边缘，边距和垂直边框， &lt;var&gt;x&lt;/var&gt; 没有有意义的数据。对于边缘和边缘， &lt;var&gt;y&lt;/var&gt; 相对于标题行的底部边缘。在所有情况下， &lt;var&gt;x&lt;/var&gt; 和 &lt;var&gt;y&lt;/var&gt; 坐标分别向右和向下增加。</target>
        </trans-unit>
        <trans-unit id="6789ca1a5596f585de1cc2056e90783a15f620b8" translate="yes" xml:space="preserve">
          <source>The reliable and easy way to extract events from a key sequence so as to put them in &lt;code&gt;unread-command-events&lt;/code&gt; is to use &lt;code&gt;listify-key-sequence&lt;/code&gt; (see below).</source>
          <target state="translated">从键序列中提取事件以将其置于 &lt;code&gt;unread-command-events&lt;/code&gt; 的可靠而简便的方法是使用 &lt;code&gt;listify-key-sequence&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="6ce491e62987f2bb55f95694ce453e7531e85c7c" translate="yes" xml:space="preserve">
          <source>The remainder of this section covers six hooks that are called during redisplay provided a significant, non-scrolling change of a window has been detected. For simplicity, these hooks and the functions they call will be collectively referred to as &lt;em&gt;window change functions&lt;/em&gt;.</source>
          <target state="translated">本节的其余部分涵盖六个钩子，只要已检测到窗口发生了重要的，非滚动的变化，它们就会在重新显示期间被调用。为简单起见，这些挂钩和它们调用的函数将统称为&lt;em&gt;窗口更改函数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fccefbe9e1b3ac84a03c9262e101056ef8f24db4" translate="yes" xml:space="preserve">
          <source>The remaining arguments (&lt;var&gt;args&lt;/var&gt;) will be passed to the process verbatim. Emacs is not involved in processing file names that are present in &lt;var&gt;args&lt;/var&gt;. To avoid confusion, it may be best to avoid absolute file names in &lt;var&gt;args&lt;/var&gt;, but rather to specify all file names as relative to &lt;code&gt;default-directory&lt;/code&gt;. The function &lt;code&gt;file-relative-name&lt;/code&gt; is useful for constructing such relative file names. Alternatively, you can use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;) to obtain an absolute file name as seen from the remote host&amp;rsquo;s perspective.</source>
          <target state="translated">其余参数（ &lt;var&gt;args&lt;/var&gt; ）将逐字传递给进程。Emacs不参与处理 &lt;var&gt;args&lt;/var&gt; 中存在的文件名。为避免混淆，最好避免在 &lt;var&gt;args&lt;/var&gt; 中使用绝对文件名，而是将所有文件名都指定为相对于 &lt;code&gt;default-directory&lt;/code&gt; 。函数 &lt;code&gt;file-relative-name&lt;/code&gt; 对于构造此类相对文件名很有用。或者，您可以使用 &lt;code&gt;file-local-name&lt;/code&gt; （请参阅&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;）来获得绝对文件名，从远程主机的角度来看。</target>
        </trans-unit>
        <trans-unit id="670a4e0596da84e4ab53487725c486bc97b4f1aa" translate="yes" xml:space="preserve">
          <source>The remaining arguments &lt;var&gt;parameters&lt;/var&gt; are keyword/argument pairs that are mainly relevant to encrypted connections:</source>
          <target state="translated">其余参数 &lt;var&gt;parameters&lt;/var&gt; 是关键字/参数对，它们主要与加密连接有关：</target>
        </trans-unit>
        <trans-unit id="711c3203fb757fbb6071fddfb4565e07916d99bb" translate="yes" xml:space="preserve">
          <source>The remaining arguments control the rate of echo area updates. The progress reporter will wait for at least &lt;var&gt;min-change&lt;/var&gt; more percents of the operation to be completed before printing next message; the default is one percent. &lt;var&gt;min-time&lt;/var&gt; specifies the minimum time in seconds to pass between successive prints; the default is 0.2 seconds. (On some operating systems, the progress reporter may handle fractions of seconds with varying precision).</source>
          <target state="translated">其余参数控制回声区域更新的速率。进度报告程序将等待至少最少 &lt;var&gt;min-change&lt;/var&gt; 更多百分比的操作才能完成，然后再打印下一条消息；默认值为百分之一。 &lt;var&gt;min-time&lt;/var&gt; 指定两次连续打印之间经过的最短时间（以秒为单位）；默认值为0.2秒。 （在某些操作系统上，进度报告程序可能以不同的精度处理几分之一秒的时间）。</target>
        </trans-unit>
        <trans-unit id="922b5762bb85df57750f37171cdcbbec00eba4ff" translate="yes" xml:space="preserve">
          <source>The remaining arguments should be the same arguments that might be given to the corresponding I/O primitive. Depending on the primitive, one of those arguments is selected as the &lt;em&gt;target&lt;/em&gt;. For example, if &lt;var&gt;operation&lt;/var&gt; does file I/O, whichever argument specifies the file name is the target. For subprocess primitives, the process name is the target. For &lt;code&gt;open-network-stream&lt;/code&gt;, the target is the service name or port number.</source>
          <target state="translated">其余参数应与可能提供给相应I / O原语的参数相同。根据原语，选择其中一个参数作为&lt;em&gt;target&lt;/em&gt;。例如，如果 &lt;var&gt;operation&lt;/var&gt; 执行文件I / O，则无论哪个参数指定文件名都是目标。对于子流程原语，流程名称是目标。对于 &lt;code&gt;open-network-stream&lt;/code&gt; ，目标是服务名称或端口号。</target>
        </trans-unit>
        <trans-unit id="3a337a486bdd471460754fa0fdb9252c1ad6a6e1" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program.</source>
          <target state="translated">其余参数 &lt;var&gt;args&lt;/var&gt; 是为程序指定命令行参数的字符串。</target>
        </trans-unit>
        <trans-unit id="c5f9c78575e39313d5c394dcec0f4646b698aca7" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;args&lt;/var&gt;, are strings that specify command line arguments for the program. Each string is passed to &lt;var&gt;program&lt;/var&gt; as a separate argument.</source>
          <target state="translated">其余参数 &lt;var&gt;args&lt;/var&gt; 是为程序指定命令行参数的字符串。每个字符串作为单独的参数传递给 &lt;var&gt;program&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="e63ff1b06b54edf88e3df6de1b60c7d8bc9065cf" translate="yes" xml:space="preserve">
          <source>The remaining arguments, &lt;var&gt;props&lt;/var&gt;, specify additional image properties&amp;mdash;for example,</source>
          <target state="translated">其余参数 &lt;var&gt;props&lt;/var&gt; 指定其他图像属性，例如，</target>
        </trans-unit>
        <trans-unit id="fbf07a85ca35fefe0fcea21832b76725d5868901" translate="yes" xml:space="preserve">
          <source>The remaining clauses use core patterns. &lt;code&gt;(pred numberp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a number. On match, the body evaluates it. &lt;code&gt;(pred symbolp)&lt;/code&gt; matches if &lt;code&gt;form&lt;/code&gt; is a symbol. On match, the body looks up the symbol in &lt;code&gt;env&lt;/code&gt; and returns its association. Finally, &lt;code&gt;_&lt;/code&gt; is the catch-all pattern that matches anything, so it&amp;rsquo;s suitable for reporting syntax errors.</source>
          <target state="translated">其余子句使用核心模式。 &lt;code&gt;(pred numberp)&lt;/code&gt; 如果 &lt;code&gt;form&lt;/code&gt; 是数字则匹配。比赛时，身体对其进行评估。 &lt;code&gt;(pred symbolp)&lt;/code&gt; 如果 &lt;code&gt;form&lt;/code&gt; 是符号则匹配。匹配时，主体在 &lt;code&gt;env&lt;/code&gt; 中查找符号并返回其关联。最后， &lt;code&gt;_&lt;/code&gt; 是可以匹配任何内容的包罗万象的模式，因此适用于报告语法错误。</target>
        </trans-unit>
        <trans-unit id="169a2fbaa470aeea2e4b7eb66378820fbb16842f" translate="yes" xml:space="preserve">
          <source>The remaining elements in &lt;var&gt;menu&lt;/var&gt; are menu items.</source>
          <target state="translated">&lt;var&gt;menu&lt;/var&gt; 中的其余元素是菜单项。</target>
        </trans-unit>
        <trans-unit id="4e6dd61e2904f012d61dbb3c359b6a7c4039effd" translate="yes" xml:space="preserve">
          <source>The remaining image types that Emacs can support are:</source>
          <target state="translated">Emacs能够支持的其余图像类型有:?</target>
        </trans-unit>
        <trans-unit id="66a6e23b71c61a3f987d7762c7e2a5b7599aa9c3" translate="yes" xml:space="preserve">
          <source>The reordering algorithm uses the bidirectional properties of the characters stored as their &lt;code&gt;bidi-class&lt;/code&gt; property (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;). Lisp programs can change these properties by calling the &lt;code&gt;put-char-code-property&lt;/code&gt; function. However, doing this requires a thorough understanding of the</source>
          <target state="translated">重新排序算法使用存储的字符的双向属性作为其 &lt;code&gt;bidi-class&lt;/code&gt; 属性（请参见&lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;）。 Lisp程序可以通过调用 &lt;code&gt;put-char-code-property&lt;/code&gt; 函数来更改这些属性。但是，这样做需要对</target>
        </trans-unit>
        <trans-unit id="0e2760fb3d24d66fd982b8a9de029f1dc2534fb7" translate="yes" xml:space="preserve">
          <source>The replacement buffer in each window is chosen via &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). Any dedicated window displaying &lt;var&gt;buffer-or-name&lt;/var&gt; is deleted if possible (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;). If such a window is the only window on its frame and there are other frames on the same terminal, the frame is deleted as well. If the dedicated window is the only window on the only frame on its terminal, the buffer is replaced anyway.</source>
          <target state="translated">每个窗口中的替换缓冲区都是通过 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; （请参见&lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;）。如果可能，将删除显示 &lt;var&gt;buffer-or-name&lt;/var&gt; 所有专用窗口（请参阅&amp;ldquo;&lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;专用窗口&amp;rdquo;&lt;/a&gt;）。如果此类窗口是其框架上的唯一窗口，并且同一终端上还有其他框架，则该框架也将被删除。如果专用窗口是其终端上唯一帧上的唯一窗口，则无论如何都将替换缓冲区。</target>
        </trans-unit>
        <trans-unit id="a7bc26f1c46834e48b01bc54d1856ec2c2513fe6" translate="yes" xml:space="preserve">
          <source>The replacement is performed using &lt;code&gt;replace-buffer-contents&lt;/code&gt; (see above) which also describes the &lt;var&gt;max-secs&lt;/var&gt; and &lt;var&gt;max-costs&lt;/var&gt; arguments and the return value.</source>
          <target state="translated">使用 &lt;code&gt;replace-buffer-contents&lt;/code&gt; （参见上文）执行替换，该内容还描述了 &lt;var&gt;max-secs&lt;/var&gt; 和 &lt;var&gt;max-costs&lt;/var&gt; 参数以及返回值。</target>
        </trans-unit>
        <trans-unit id="ec1321a0692fb6ebcc794193c05c46720ae0b1d2" translate="yes" xml:space="preserve">
          <source>The representation of letters, numbers and control characters.</source>
          <target state="translated">字母、数字和控制字符的表示。</target>
        </trans-unit>
        <trans-unit id="1888fa813111440fef4cca1b17158b44c62b32a0" translate="yes" xml:space="preserve">
          <source>The rest of &lt;var&gt;args&lt;/var&gt; are strings that specify command line arguments for the subprocess.</source>
          <target state="translated">其余的 &lt;var&gt;args&lt;/var&gt; 是为子进程指定命令行参数的字符串。</target>
        </trans-unit>
        <trans-unit id="e64cb5cbfa4900b03ef274ea22ff266b957788b6" translate="yes" xml:space="preserve">
          <source>The rest of the elements are the &lt;em&gt;body&lt;/em&gt; of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, &amp;ldquo;a list of Lisp forms to evaluate&amp;rdquo;). The value returned by the function is the value returned by the last element of the body.</source>
          <target state="translated">其余的元素是函数的&lt;em&gt;主体&lt;/em&gt;：Lisp代码执行函数的工作（或者，正如Lisp程序员会说的那样，&amp;ldquo;要评估的Lisp形式列表&amp;rdquo;）。该函数返回的值是主体的最后一个元素返回的值。</target>
        </trans-unit>
        <trans-unit id="0d7105d802c517da10dece05da93fcc235f044de" translate="yes" xml:space="preserve">
          <source>The rest of this section describes several kinds of display specifications and what they mean.</source>
          <target state="translated">本节其余部分将介绍几种显示规格及其含义。</target>
        </trans-unit>
        <trans-unit id="75d16b63e700fca272954b8d5c9cbea0eaebf3a4" translate="yes" xml:space="preserve">
          <source>The rest of this subsection describes different forms of core patterns, presents some examples, and concludes with important caveats on using the let-binding facility provided by some pattern forms. A core pattern can have the following forms:</source>
          <target state="translated">本小节的其余部分描述了核心模式的不同形式,介绍了一些例子,并以使用某些模式形式提供的let-binding设施的重要注意事项作为结束。一个核心模式可以有以下几种形式。</target>
        </trans-unit>
        <trans-unit id="d3d63b344006851896165eee8891a4b8d2a80cdd" translate="yes" xml:space="preserve">
          <source>The result &lt;var&gt;prevhpos&lt;/var&gt; is the horizontal position one character back from &lt;var&gt;pos&lt;/var&gt;. The result &lt;var&gt;contin&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; if the last line was continued after (or within) the previous character.</source>
          <target state="translated">结果 &lt;var&gt;prevhpos&lt;/var&gt; 是从 &lt;var&gt;pos&lt;/var&gt; 返回一个字符的水平位置。如果最后一行在前一个字符之后（或之前）继续，则结果 &lt;var&gt;contin&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daae51971c3e086b5b343e27b0d5f3425265bcec" translate="yes" xml:space="preserve">
          <source>The result is not &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt;, which would rarely be useful. If you need such a result, use an explicit value for &lt;var&gt;separators&lt;/var&gt;:</source>
          <target state="translated">结果不是 &lt;code&gt;(&quot;&quot; &quot;two&quot; &quot;words&quot; &quot;&quot;)&lt;/code&gt; ，这很少有用。如果需要这样的结果，请为 &lt;var&gt;separators&lt;/var&gt; 使用显式值：</target>
        </trans-unit>
        <trans-unit id="b472acbf6233b1409a248f2d33fb8eb9ab0e8df6" translate="yes" xml:space="preserve">
          <source>The result must be accurate. The function may need to encode and decode a large part of the buffer, which is expensive and can be slow.</source>
          <target state="translated">结果必须是准确的。该函数可能需要对缓冲区的很大一部分进行编码和解码,这很昂贵,而且速度可能很慢。</target>
        </trans-unit>
        <trans-unit id="3fc3ca66f906ee6817d9bc3b5bb03a793a75bf8c" translate="yes" xml:space="preserve">
          <source>The result of encoding is logically a sequence of bytes, but the buffer remains multibyte if it was multibyte before, and any 8-bit bytes are converted to their multibyte representation (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;).</source>
          <target state="translated">编码的结果在逻辑上是一个字节序列，但是如果缓冲区以前是多字节的，则缓冲区将保持为多字节，并且任何8位字节都将转换为其多字节表示形式（请参见&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c0ac4c7f55c94e4e68eece5bab668740b85fd079" translate="yes" xml:space="preserve">
          <source>The result of encoding, and the input to decoding, are not ordinary text. They logically consist of a series of byte values; that is, a series of</source>
          <target state="translated">编码的结果,以及解码的输入,都不是普通的文本。它们在逻辑上是由一系列字节值组成的;也就是说,一系列的</target>
        </trans-unit>
        <trans-unit id="f2f9b59d04c4a67bead42edef8ea82ec9bf8264f" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item is enabled (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item is not enabled, you can&amp;rsquo;t really click on it.</source>
          <target state="translated">评估的结果 &lt;var&gt;form&lt;/var&gt; 确定该项目是否被启用（非 &lt;code&gt;nil&lt;/code&gt; 手段是）。如果未启用该项目，则无法真正单击它。</target>
        </trans-unit>
        <trans-unit id="0ef7684b6652c1f298625050dc4e7b22d73f9616" translate="yes" xml:space="preserve">
          <source>The result of evaluating &lt;var&gt;form&lt;/var&gt; determines whether the item should actually appear in the menu (non-&lt;code&gt;nil&lt;/code&gt; means yes). If the item does not appear, then the menu is displayed as if this item were not defined at all.</source>
          <target state="translated">评估的结果 &lt;var&gt;form&lt;/var&gt; 确定该项目是否真的应该出现在菜单中（非 &lt;code&gt;nil&lt;/code&gt; 手段是）。如果没有出现该项目，则显示菜单，就好像根本没有定义该项目一样。</target>
        </trans-unit>
        <trans-unit id="acbd2ddb72baf0b207a6321fedc1407724073a97" translate="yes" xml:space="preserve">
          <source>The result of this form is &lt;code&gt;t&lt;/code&gt; if it works to specify &lt;var&gt;keyword&lt;/var&gt; with value &lt;var&gt;value&lt;/var&gt; in &lt;code&gt;make-network-process&lt;/code&gt;. Here are some of the &lt;var&gt;keyword&lt;/var&gt;&amp;mdash;&lt;var&gt;value&lt;/var&gt; pairs you can test in this way.</source>
          <target state="translated">如果它可以在 &lt;code&gt;make-network-process&lt;/code&gt; 中使用value &lt;var&gt;value&lt;/var&gt; 指定 &lt;var&gt;keyword&lt;/var&gt; ，则此格式的结果为 &lt;code&gt;t&lt;/code&gt; 。以下是一些 &lt;var&gt;keyword&lt;/var&gt; -您可以通过这种方式测试的 &lt;var&gt;value&lt;/var&gt; 对。</target>
        </trans-unit>
        <trans-unit id="a66be8edbff7bbe7579ce3f3a75abe46a384d47a" translate="yes" xml:space="preserve">
          <source>The result of this macro is the result returned by &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">该宏的结果是 &lt;var&gt;body&lt;/var&gt; 返回的结果。</target>
        </trans-unit>
        <trans-unit id="27bbea73aa5cdc064da3e057ed92e4ba32abfaad" translate="yes" xml:space="preserve">
          <source>The result of using contradictory flags (for instance, both upper and lower case) is undefined.</source>
          <target state="translated">使用矛盾的标志(例如,同时使用大写和小写)的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="46a20d33611240a9e0e5211ef91f6aa318813c3c" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">最终的鼠标位置被限制为frame的原始 &lt;var&gt;frame&lt;/var&gt; 。如果看不到 &lt;var&gt;frame&lt;/var&gt; ，则此功能不执行任何操作。返回值不重要。</target>
        </trans-unit>
        <trans-unit id="27f056d37a6f909c9875b9547c995c37a964153d" translate="yes" xml:space="preserve">
          <source>The resulting mouse position is not constrained to the native frame of &lt;var&gt;frame&lt;/var&gt;. If &lt;var&gt;frame&lt;/var&gt; is not visible, this function does nothing. The return value is not significant.</source>
          <target state="translated">所得的鼠标位置不限于frame的原始 &lt;var&gt;frame&lt;/var&gt; 。如果看不到 &lt;var&gt;frame&lt;/var&gt; ，则此功能不执行任何操作。返回值不重要。</target>
        </trans-unit>
        <trans-unit id="97e907e5a3426231ca925e4df1a09f1c6f27899f" translate="yes" xml:space="preserve">
          <source>The resulting pixel is computed from the color intensity of the color resulting from summing up the RGB values of surrounding pixels, multiplied by the specified factors, and dividing that sum by the sum of the factors&amp;rsquo; absolute values.</source>
          <target state="translated">根据将周围像素的RGB值相加后得到的颜色的颜色强度，将其乘以指定的因子，然后将该总和除以因子的绝对值之和即可得出结果像素。</target>
        </trans-unit>
        <trans-unit id="a850c2e30c134550ab81c49f18e64cc8581aca70" translate="yes" xml:space="preserve">
          <source>The resulting regexp is preceded by &lt;var&gt;paren&lt;/var&gt; and followed by &amp;lsquo;</source>
          <target state="translated">生成的正则表达式前 &lt;var&gt;paren&lt;/var&gt; ，后跟'</target>
        </trans-unit>
        <trans-unit id="5cb20d9a2af4a08675a28d5ca902bb392372a3c0" translate="yes" xml:space="preserve">
          <source>The resulting regexp is surrounded by &amp;lsquo;</source>
          <target state="translated">生成的正则表达式用'</target>
        </trans-unit>
        <trans-unit id="75f74b291859bcb8fbacd8a981cca3c5abbd5e9c" translate="yes" xml:space="preserve">
          <source>The return value has the form &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt;
&lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt;. These list elements are, respectively, the X coordinate of the leftmost column occupied by the window, the Y coordinate of the topmost row, the X coordinate one column to the right of the rightmost column, and the Y coordinate one row down from the bottommost row.</source>
          <target state="translated">返回值的格式 &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt; &lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt; 。这些列表元素分别是窗口所占据的最左列的X坐标，最上一行的Y坐标，最右边一列的X坐标到最右列的右侧以及Y坐标从最底端向下的一行行。</target>
        </trans-unit>
        <trans-unit id="d012e9e07ddcadec4d4bdcd9c6d25ee2bd788334" translate="yes" xml:space="preserve">
          <source>The return value includes mode and header line, a horizontal scroll bar and a bottom divider, if any. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel height is the pixel height of the screen areas spanned by its children.</source>
          <target state="translated">返回值包括模式和标题行，水平滚动条和底部分隔线（如果有）。如果 &lt;var&gt;window&lt;/var&gt; 是内部窗口，则其像素高度是由其子级跨越的屏幕区域的像素高度。</target>
        </trans-unit>
        <trans-unit id="02435ab528a9d458375ad989e9c07e91ea1d1315" translate="yes" xml:space="preserve">
          <source>The return value includes the fringes and margins of &lt;var&gt;window&lt;/var&gt; as well as any vertical dividers or scroll bars belonging to &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;window&lt;/var&gt; is an internal window, its pixel width is the width of the screen areas spanned by its children.</source>
          <target state="translated">返回值包括 &lt;var&gt;window&lt;/var&gt; 的边缘和边缘以及属于 &lt;var&gt;window&lt;/var&gt; 的任何垂直分隔线或滚动条。如果 &lt;var&gt;window&lt;/var&gt; 是内部窗口，则其像素宽度是由其子元素跨越的屏幕区域的宽度。</target>
        </trans-unit>
        <trans-unit id="3a98f39fffcef1b3f518f4676f34cc9b1b32069e" translate="yes" xml:space="preserve">
          <source>The return value indicates the distance traveled. It is an integer that is zero or less.</source>
          <target state="translated">返回值表示行驶的距离。它是一个零或更小的整数。</target>
        </trans-unit>
        <trans-unit id="3fde61c2b5f5d76aef05339847ec2609e0a0f8e5" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or if no character in the specified text had any of those properties).</source>
          <target state="translated">如果函数实际上更改了某些属性的值，则返回值为 &lt;code&gt;t&lt;/code&gt; ;否则，返回值为0。 &lt;code&gt;nil&lt;/code&gt; 否则（如果 &lt;var&gt;props&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，或者如果在指定的文本没有字符有任何这些属性的）。</target>
        </trans-unit>
        <trans-unit id="90f56f2b19d2b305eccb19f73983ee226bf52495" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;t&lt;/code&gt; if the function actually changed some property&amp;rsquo;s value; &lt;code&gt;nil&lt;/code&gt; otherwise (if &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or its values agree with those in the text).</source>
          <target state="translated">如果函数实际上更改了某些属性的值，则返回值为 &lt;code&gt;t&lt;/code&gt; ;否则，返回值为0。 &lt;code&gt;nil&lt;/code&gt; 否则（如果 &lt;var&gt;props&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; 或它的值与在文本同意）。</target>
        </trans-unit>
        <trans-unit id="d966c0a5582546e03dd65e09ce5f5b7511e5eb89" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;overlay&lt;/var&gt;.</source>
          <target state="translated">返回值是 &lt;var&gt;overlay&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c05af5fac5434c5acee584935759af38f45178" translate="yes" xml:space="preserve">
          <source>The return value is &lt;var&gt;value&lt;/var&gt; from the chosen alternative.</source>
          <target state="translated">返回值是所选替代 &lt;var&gt;value&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="414de02915422d70149abb88fd20a6bbe77b52b9" translate="yes" xml:space="preserve">
          <source>The return value is a Lisp object that serves as a cookie; you can pass this object as an argument to &lt;code&gt;face-remap-remove-relative&lt;/code&gt; if you need to remove the remapping later.</source>
          <target state="translated">返回值是充当Cookie的Lisp对象；如果以后需要删除重新映射，则可以将此对象作为参数传递给 &lt;code&gt;face-remap-remove-relative&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="640083b382042a0f9ab141b72092b58d3b3db8e7" translate="yes" xml:space="preserve">
          <source>The return value is a decoded time structure.</source>
          <target state="translated">返回值是一个解码的时间结构。</target>
        </trans-unit>
        <trans-unit id="6948835c6ed35bc81ffd72935c26a9c6a4b01e26" translate="yes" xml:space="preserve">
          <source>The return value is a list of five elements:</source>
          <target state="translated">返回值是一个由五个元素组成的列表。</target>
        </trans-unit>
        <trans-unit id="90615d81da8d652dcb6154d1dc922a071b14b8e3" translate="yes" xml:space="preserve">
          <source>The return value is a list of the form &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;root&lt;/var&gt; represents the window tree of the frame&amp;rsquo;s root window, and &lt;var&gt;mini&lt;/var&gt; is the frame&amp;rsquo;s minibuffer window.</source>
          <target state="translated">返回值是 &lt;code&gt;(&lt;var&gt;root&lt;/var&gt; &lt;var&gt;mini&lt;/var&gt;)&lt;/code&gt; 形式的列表，其中 &lt;var&gt;root&lt;/var&gt; 表示框架的根窗口的窗口树， &lt;var&gt;mini&lt;/var&gt; 是框架的minibuffer窗口。</target>
        </trans-unit>
        <trans-unit id="52c6a1791b31a7b0eaccc6801b2780ff866415de" translate="yes" xml:space="preserve">
          <source>The return value is a triple of the width and the start and end y-coordinates of the largest rectangle that can be inscribed into the empty space (space not displaying any text) of the text area of &lt;var&gt;window&lt;/var&gt;. No x-coordinates are returned by this function&amp;mdash;any such rectangle is assumed to end at the right edge of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s text area. If no empty space can be found, the return value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">返回值是宽度的三倍，是最大矩形的y起点和终点y坐标，可将其内接到 &lt;var&gt;window&lt;/var&gt; 文本区域的空白区域（不显示任何文本的空间）。此函数不会返回x坐标-假定任何此类矩形都在 &lt;var&gt;window&lt;/var&gt; 的文本区域的右边缘结束。如果找不到空白空间，则返回值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2e42df57a0cc7d257e5e9f1e666fc7a3621ad67" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">返回值始终为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc3028050b974b5c5985a3e65b383b27350e24c" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;nil&lt;/code&gt;; to make calls to &lt;code&gt;map-char-table&lt;/code&gt; useful, &lt;var&gt;function&lt;/var&gt; should have side effects. For example, here is how to examine the elements of the syntax table:</source>
          <target state="translated">返回值始终为 &lt;code&gt;nil&lt;/code&gt; ；为了使对 &lt;code&gt;map-char-table&lt;/code&gt; 的调用有用， &lt;var&gt;function&lt;/var&gt; 应具有副作用。例如，这是如何检查语法表的元素：</target>
        </trans-unit>
        <trans-unit id="6e1ef02d50eb6d3d11a008ae86a182534aaddd6c" translate="yes" xml:space="preserve">
          <source>The return value is like what &lt;code&gt;insert-file-contents&lt;/code&gt; returns: a list of the absolute file name and the length of the data inserted (after conversion).</source>
          <target state="translated">返回值类似于 &lt;code&gt;insert-file-contents&lt;/code&gt; 返回的内容：绝对文件名和插入的数据长度（转换后）的列表。</target>
        </trans-unit>
        <trans-unit id="1667a16b49f259c48f935a06b46d348e1b7a9a28" translate="yes" xml:space="preserve">
          <source>The return value is never negative. It is zero when no horizontal scrolling has been done in &lt;var&gt;window&lt;/var&gt; (which is usually the case).</source>
          <target state="translated">返回值永远不会为负。当 &lt;var&gt;window&lt;/var&gt; 没有水平滚动时，该值为零（通常是这种情况）。</target>
        </trans-unit>
        <trans-unit id="2493392e7fec786dd0b57b9149f6a4de24a60362" translate="yes" xml:space="preserve">
          <source>The return value is the column number actually moved to.</source>
          <target state="translated">返回值是实际移动到的列号。</target>
        </trans-unit>
        <trans-unit id="728cf9e0720907dab6445cd97c1a912356f7f43f" translate="yes" xml:space="preserve">
          <source>The return value is the distance traveled, which is a nonnegative integer.</source>
          <target state="translated">返回值是行驶的距离,是一个非负的整数。</target>
        </trans-unit>
        <trans-unit id="e8f11031b2e43a095f2b7b7de82a02dfcbe6b156" translate="yes" xml:space="preserve">
          <source>The return value is the matching value from &lt;var&gt;choices&lt;/var&gt;.</source>
          <target state="translated">返回值是匹配值 &lt;var&gt;choices&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d181ed19740d80d79cf1130d7058743bf3e3b57" translate="yes" xml:space="preserve">
          <source>The return value is the new window, &lt;code&gt;nil&lt;/code&gt; when creating that window failed.</source>
          <target state="translated">返回值是新窗口，如果创建该窗口失败，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f65065166d5e0c6aa1c92410eeb9adf0999014fa" translate="yes" xml:space="preserve">
          <source>The return value is the number of screen lines over which point was moved. The value may be less in absolute value than &lt;var&gt;count&lt;/var&gt; if the beginning or end of the buffer was reached.</source>
          <target state="translated">返回值是在其上移动了点的屏幕行数。如果到达缓冲区的开始或结尾，则该绝对值可能小于 &lt;var&gt;count&lt;/var&gt; 绝对值。</target>
        </trans-unit>
        <trans-unit id="9d83169f48bfa8d22f5e0a5baa5652dbdd9ad387" translate="yes" xml:space="preserve">
          <source>The return value is the result of this rounding.</source>
          <target state="translated">返回值是这种四舍五入的结果。</target>
        </trans-unit>
        <trans-unit id="a97826aadd65e5acdd8dae2f1cc5f5396c5e9f4d" translate="yes" xml:space="preserve">
          <source>The return value is the same as if you call the low-level parsing function &lt;code&gt;parse-partial-sexp&lt;/code&gt; to parse from the beginning of the visible portion of the buffer to &lt;var&gt;pos&lt;/var&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). However, &lt;code&gt;syntax-ppss&lt;/code&gt; uses caches to speed up the computation. Due to this optimization, the second value (previous complete subexpression) and sixth value (minimum parenthesis depth) in the returned parser state are not meaningful.</source>
          <target state="translated">返回值与调用低级解析函数 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 从缓冲区的可见部分的开头解析到 &lt;var&gt;pos&lt;/var&gt; 相同（请参阅&lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;低级解析&lt;/a&gt;）。但是， &lt;code&gt;syntax-ppss&lt;/code&gt; 使用缓存来加快计算速度。由于此优化，返回的解析器状态中的第二个值（先前的完整子表达式）和第六个值（最小括号深度）没有意义。</target>
        </trans-unit>
        <trans-unit id="e18c940c557733fa2d17296522cd2ee2f382b25f" translate="yes" xml:space="preserve">
          <source>The return value is the total amount of leftward horizontal scrolling in effect after the change&amp;mdash;just like the value returned by &lt;code&gt;window-hscroll&lt;/code&gt; (below).</source>
          <target state="translated">返回值是更改后生效的向左水平滚动的总量，就像 &lt;code&gt;window-hscroll&lt;/code&gt; （如下）所返回的值一样。</target>
        </trans-unit>
        <trans-unit id="d57cd36326fa59864f8c712bddff5dc5bb7f668f" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">返回值是 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。即使由于 &lt;code&gt;throw&lt;/code&gt; 或错误导致异常退出，也将恢复当前缓冲区（请参见&lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eb0d4689de602d882bfebd89386a5243b7f33720" translate="yes" xml:space="preserve">
          <source>The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. You can return the contents of the temporary buffer by using &lt;code&gt;(buffer-string)&lt;/code&gt; as the last form.</source>
          <target state="translated">返回值是 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。您可以使用 &lt;code&gt;(buffer-string)&lt;/code&gt; 作为最后一种形式来返回临时缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="98b96176f1db00d3485afd4a66e4aa0f4d04fd5e" translate="yes" xml:space="preserve">
          <source>The return value makes sure that all components of &lt;var&gt;window&lt;/var&gt; remain fully visible if &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s size were actually set to it. With &lt;var&gt;horizontal&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt; it includes the mode and header line, the horizontal scroll bar and the bottom divider, if present. With &lt;var&gt;horizontal&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; it includes the margins and fringes, the vertical scroll bar and the right divider, if present.</source>
          <target state="translated">如果实际设置了 &lt;var&gt;window&lt;/var&gt; 的大小，则返回值可确保 &lt;var&gt;window&lt;/var&gt; 所有组件保持完全可见。对于 &lt;var&gt;horizontal&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; ,它包括模式和标题行，水平滚动条和底部分隔线（如果有）。与 &lt;var&gt;horizontal&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 它包括页边距和条纹，垂直滚动条和右分隔件，如果存在的话。</target>
        </trans-unit>
        <trans-unit id="56acd2a554fb8715a71ba301e194647feef1c650" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;call-process-region&lt;/code&gt; is just like that of &lt;code&gt;call-process&lt;/code&gt;: &lt;code&gt;nil&lt;/code&gt; if you told it to return without waiting; otherwise, a number or string which indicates how the subprocess terminated.</source>
          <target state="translated">返回值 &lt;code&gt;call-process-region&lt;/code&gt; 就是如此的 &lt;code&gt;call-process&lt;/code&gt; ： &lt;code&gt;nil&lt;/code&gt; ，如果你告诉它，而无需等待返回; 否则为一个数字或字符串，指示子进程如何终止。</target>
        </trans-unit>
        <trans-unit id="5069facca425b351b86dde2c2ae0c0771e388177" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;completion-table-dynamic&lt;/code&gt; is a function that can be used as the 2nd argument to &lt;code&gt;try-completion&lt;/code&gt; and &lt;code&gt;all-completions&lt;/code&gt;. Note that this function will always return empty metadata and trivial boundaries (see &lt;a href=&quot;#Programmed-Completion&quot;&gt;Programmed Completion&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;completion-table-dynamic&lt;/code&gt; 的返回值是一个函数，可以用作 &lt;code&gt;try-completion&lt;/code&gt; 和 &lt;code&gt;all-completions&lt;/code&gt; 的第二个参数。请注意，此函数将始终返回空的元数据和琐碎的边界（请参阅&lt;a href=&quot;#Programmed-Completion&quot;&gt;编程完成&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eb1115fc8b41440862e5616560ee61c6930b3d4e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;defun&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 的返回值是不确定的。</target>
        </trans-unit>
        <trans-unit id="a22f1787f8edaffd1df1c076115e598858217063" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;indent-relative&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;code&gt;indent-relative&lt;/code&gt; 的返回值是不可预测的。</target>
        </trans-unit>
        <trans-unit id="40830d574522cf348ebff2db025053eb30711de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;map-y-or-n-p&lt;/code&gt; is the number of objects acted on.</source>
          <target state="translated">&lt;code&gt;map-y-or-n-p&lt;/code&gt; 的返回值是作用于对象的数量。</target>
        </trans-unit>
        <trans-unit id="bcb50cbd862df1ce6221c36f84f21509e97f8fb8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;momentary-string-display&lt;/code&gt; is not meaningful.</source>
          <target state="translated">&lt;code&gt;momentary-string-display&lt;/code&gt; 的返回值没有意义。</target>
        </trans-unit>
        <trans-unit id="ee4347aba22a42b7519b85d2086502c660164bde" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;translate-region&lt;/code&gt; is the number of characters that were actually changed by the translation. This does not count characters that were mapped into themselves in the translation table.</source>
          <target state="translated">&lt;code&gt;translate-region&lt;/code&gt; 的返回值是翻译实际更改的字符数。这不计算转换表中映射到其自身的字符。</target>
        </trans-unit>
        <trans-unit id="ccc82eb191bcbf19332876523e72f6c383beea99" translate="yes" xml:space="preserve">
          <source>The return value of this function is &lt;code&gt;t&lt;/code&gt; if the text would be completely hidden on display, or a non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; value if the text would be replaced by an ellipsis.</source>
          <target state="translated">如果文本将在显示中完全隐藏，则此函数的返回值为 &lt;code&gt;t&lt;/code&gt; ;如果将文本替换为省略号，则该函数的返回值为 &lt;code&gt;nil&lt;/code&gt; ，non- &lt;code&gt;t&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="43b0ec1a11637964920ecb2540843fb9ed801524" translate="yes" xml:space="preserve">
          <source>The return value of this function. If omitted or &lt;code&gt;nil&lt;/code&gt;, return a process object. Otherwise, a cons of the form &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt;
. &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;plist&lt;/var&gt; has keywords:</source>
          <target state="translated">此函数的返回值。如果省略或 &lt;code&gt;nil&lt;/code&gt; ，则返回一个过程对象。否则，该形式的一个缺点 &lt;code&gt;(&lt;var&gt;process-object&lt;/var&gt; . &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; ，在那里 &lt;var&gt;plist&lt;/var&gt; 了关键字：</target>
        </trans-unit>
        <trans-unit id="6b902298331d5acafbc78a6a866439d8f418148b" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;prec2&lt;/em&gt; table holds constraints between pairs of tokens, and for any given pair only one constraint can be present: T1 &amp;lt; T2, T1 = T2, or T1 &amp;gt; T2.</source>
          <target state="translated">返回的&lt;em&gt;prec2&lt;/em&gt;表包含标记对之间的约束，对于任何给定的一对，只能存在一个约束：T1 &amp;lt;T2，T1 = T2，或T1&amp;gt; T2。</target>
        </trans-unit>
        <trans-unit id="dbc5dc6672398dd058c6b4f7b7fadc842548ff7b" translate="yes" xml:space="preserve">
          <source>The returned event may come directly from the user, or from a keyboard macro. It is not decoded by the keyboard&amp;rsquo;s input coding system (see &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;).</source>
          <target state="translated">返回的事件可能直接来自用户，也可能来自键盘宏。键盘的输入编码系统不对它进行解码（请参阅&lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;终端I / O编码&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4cdf1e97bec67e330632316ef5395fcf7caf2e12" translate="yes" xml:space="preserve">
          <source>The returned regexp is ordered in such a way that it will always match the longest string possible.</source>
          <target state="translated">返回的regexp是以这样一种方式排序的,即它总是尽可能地匹配最长的字符串。</target>
        </trans-unit>
        <trans-unit id="efdbd6df6dfdf2a517533221caa6311ed4d1e39a" translate="yes" xml:space="preserve">
          <source>The returned string may be &lt;var&gt;string&lt;/var&gt; itself if it does not contain any special characters.</source>
          <target state="translated">如果返回的字符串不包含任何特殊字符，则可以是 &lt;var&gt;string&lt;/var&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="fd9bc80d26777c7e0a2a7afa6c8e55fbe066df53" translate="yes" xml:space="preserve">
          <source>The returned value is a descriptor for the added watch. Its type depends on the underlying library, it cannot be assumed to be an integer as in the example below. It should be used for comparison by &lt;code&gt;equal&lt;/code&gt; only.</source>
          <target state="translated">返回的值是添加的手表的描述符。它的类型取决于基础库，不能像下面的示例一样假定它为整数。仅应 &lt;code&gt;equal&lt;/code&gt; 地用于比较。</target>
        </trans-unit>
        <trans-unit id="5526f73a053a966e99ef6b773d23afe60ad9d26c" translate="yes" xml:space="preserve">
          <source>The returned value is a string.</source>
          <target state="translated">返回值是一个字符串。</target>
        </trans-unit>
        <trans-unit id="265dcc02f70278df1fa86f8ca9c808c95d187ef5" translate="yes" xml:space="preserve">
          <source>The returned value is unpredictable.</source>
          <target state="translated">返回的值是不可预知的。</target>
        </trans-unit>
        <trans-unit id="d67d7a62afb4deb22a1a4750f3d9471f23d28534" translate="yes" xml:space="preserve">
          <source>The right way to use this variable is to bind it with &lt;code&gt;let&lt;/code&gt; for a specific I/O operation. Its global value is normally &lt;code&gt;nil&lt;/code&gt;, and you should not globally set it to any other value. Here is an example of the right way to use the variable:</source>
          <target state="translated">使用此变量的正确方法是将其与 &lt;code&gt;let&lt;/code&gt; 绑定以进行特定的I / O操作。它的全局值通常为 &lt;code&gt;nil&lt;/code&gt; ，并且您不应将其全局设置为任何其他值。这是使用变量的正确方法的示例：</target>
        </trans-unit>
        <trans-unit id="39952ca9e7a27cc76fd0f660398052f252830c23" translate="yes" xml:space="preserve">
          <source>The root window of this frame is an internal window, &lt;var&gt;W1&lt;/var&gt;. Its child windows form a horizontal combination, consisting of the live window &lt;var&gt;W2&lt;/var&gt; and the internal window &lt;var&gt;W3&lt;/var&gt;. The child windows of &lt;var&gt;W3&lt;/var&gt; form a vertical combination, consisting of the live windows &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;. Hence, the live windows in this window tree are &lt;var&gt;W2&lt;/var&gt;, &lt;var&gt;W4&lt;/var&gt;, and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">该框架的根窗口是内部窗口 &lt;var&gt;W1&lt;/var&gt; 。其子窗口形成水平组合，包括实时窗口 &lt;var&gt;W2&lt;/var&gt; 和内部窗口 &lt;var&gt;W3&lt;/var&gt; 。 &lt;var&gt;W3&lt;/var&gt; 的子窗口形成垂直组合，由实时窗口 &lt;var&gt;W4&lt;/var&gt; 和 &lt;var&gt;W5&lt;/var&gt; 组成。因此，该窗口树中的活动窗口为 &lt;var&gt;W2&lt;/var&gt; ， &lt;var&gt;W4&lt;/var&gt; 和 &lt;var&gt;W5&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="814d3881be5a72669b9ab4a2a2237b0156c64c15" translate="yes" xml:space="preserve">
          <source>The rule for finding the binding of a key sequence assumes that the intermediate bindings (found for the events before the last) are all keymaps; if this is not so, the sequence of events does not form a unit&amp;mdash;it is not really one key sequence. In other words, removing one or more events from the end of any valid key sequence must always yield a prefix key. For example,</source>
          <target state="translated">查找键序列的绑定的规则假定中间绑定（在最后一个事件之前为事件找到的）都是键映射。如果不是这样，那么事件序列就不构成一个单元，它实际上不是一个关键序列。换句话说，从任何有效键序列的末尾删除一个或多个事件必须始终产生前缀键。例如，</target>
        </trans-unit>
        <trans-unit id="2122fb4e21ddd11686b2348d982b3ec0119e1727" translate="yes" xml:space="preserve">
          <source>The rule for indentation after &lt;code&gt;&quot;:=&quot;&lt;/code&gt; exists because otherwise SMIE would treat &lt;code&gt;&quot;:=&quot;&lt;/code&gt; as an infix operator and would align the right argument with the left one.</source>
          <target state="translated">存在 &lt;code&gt;&quot;:=&quot;&lt;/code&gt; 之后的缩进规则，因为否则SMIE会将 &lt;code&gt;&quot;:=&quot;&lt;/code&gt; 视为中缀运算符，并将右参数与左参数对齐。</target>
        </trans-unit>
        <trans-unit id="37f434c4f0270c5122c827e81b52b88938539dd1" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is an example of the use of virtual indentation: This rule is used only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is hanging, which can happen only when &lt;code&gt;&quot;begin&quot;&lt;/code&gt; is not at the beginning of a line. So this is not used when indenting &lt;code&gt;&quot;begin&quot;&lt;/code&gt; itself but only when indenting something relative to this &lt;code&gt;&quot;begin&quot;&lt;/code&gt;. Concretely, this rule changes the indentation from:</source>
          <target state="translated">&lt;code&gt;&quot;begin&quot;&lt;/code&gt; 之前的缩进规则是使用虚拟缩进的一个示例：仅当 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 挂起时才使用此规则，只有当 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 不在行首时才可能发生。因此，在缩进 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 本身时不使用此方法，而仅在缩进与该 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 。具体来说，此规则将缩进从以下位置更改：</target>
        </trans-unit>
        <trans-unit id="d2ae301bb08cbc756929fb8516392dcfbc907e46" translate="yes" xml:space="preserve">
          <source>The rule for indentation before &lt;code&gt;&quot;if&quot;&lt;/code&gt; is similar to the one for &lt;code&gt;&quot;begin&quot;&lt;/code&gt;, but where the purpose is to treat &lt;code&gt;&quot;else if&quot;&lt;/code&gt; as a single unit, so as to align a sequence of tests rather than indent each test further to the right. This function does this only in the case where the &lt;code&gt;&quot;if&quot;&lt;/code&gt; is not placed on a separate line, hence the &lt;code&gt;smie-rule-bolp&lt;/code&gt; test.</source>
          <target state="translated">&lt;code&gt;&quot;if&quot;&lt;/code&gt; 之前的缩进规则类似于 &lt;code&gt;&quot;begin&quot;&lt;/code&gt; 缩进规则，但目的是将 &lt;code&gt;&quot;else if&quot;&lt;/code&gt; 视为一个单元，以便对齐测试序列，而不是将每个测试进一步缩进对。仅在 &lt;code&gt;&quot;if&quot;&lt;/code&gt; 未放在单独的行上时才执行此功能，因此执行 &lt;code&gt;smie-rule-bolp&lt;/code&gt; 测试。</target>
        </trans-unit>
        <trans-unit id="3e51195c9e4bef9ac5fed369ac13d21d4ecbb83d" translate="yes" xml:space="preserve">
          <source>The rule for the token &lt;code&gt;&quot;,&quot;&lt;/code&gt; make SMIE try to be more clever when the comma separator is placed at the beginning of lines. It tries to outdent the separator so as to align the code after the comma; for example:</source>
          <target state="translated">当逗号分隔符放在行的开头时 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 令牌&amp;ldquo;，&amp;rdquo;的规则使SMIE变得更聪明。它尝试使分隔符伸出，以使代码在逗号后对齐；例如：</target>
        </trans-unit>
        <trans-unit id="2ea9d036c2f0944a227079154b59cbdc7f4c6f40" translate="yes" xml:space="preserve">
          <source>The rx Structured Regexp Notation</source>
          <target state="translated">rx结构化重复表达符号</target>
        </trans-unit>
        <trans-unit id="b8ef342720c667ded9bb4a10754ff3f59b3c59dd" translate="yes" xml:space="preserve">
          <source>The safe value definitions specified with &lt;code&gt;autoload&lt;/code&gt; are copied into the package&amp;rsquo;s autoloads file (</source>
          <target state="translated">用 &lt;code&gt;autoload&lt;/code&gt; 指定的安全值定义被复制到程序包的autoloads文件中（</target>
        </trans-unit>
        <trans-unit id="3d3cd8e2cc092de1d198d6e2528520fe0e19f022" translate="yes" xml:space="preserve">
          <source>The same alist shown above could be regarded as having the associated value in the &lt;small&gt;CDR&lt;/small&gt; of the element; the value associated with &lt;code&gt;rose&lt;/code&gt; would be the list &lt;code&gt;(red)&lt;/code&gt;.</source>
          <target state="translated">可以将上面显示的相同列表视为在元素的&lt;small&gt;CDR&lt;/small&gt;中具有关联的值；与 &lt;code&gt;rose&lt;/code&gt; 相关的值将是列表 &lt;code&gt;(red)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b598a52d532ebb9508666d7703290c6b51b2a77" translate="yes" xml:space="preserve">
          <source>The same comparison is made for the characters before the old and new locations. The result may be to execute two &lt;code&gt;point-left&lt;/code&gt; functions (which may be the same function) and/or two &lt;code&gt;point-entered&lt;/code&gt; functions (which may be the same function). In any case, all the &lt;code&gt;point-left&lt;/code&gt; functions are called first, followed by all the &lt;code&gt;point-entered&lt;/code&gt; functions.</source>
          <target state="translated">对旧位置和新位置之前的字符进行相同的比较。结果可能是执行两个 &lt;code&gt;point-left&lt;/code&gt; 功能（可能是相同的功能）和/或执行两个 &lt;code&gt;point-entered&lt;/code&gt; 功能（可能是相同的功能）。在任何情况下，首先调用所有 &lt;code&gt;point-left&lt;/code&gt; 函数，然后调用所有 &lt;code&gt;point-entered&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="76be1f3a5b9d85ac92db6757c8aa658e4c83550f" translate="yes" xml:space="preserve">
          <source>The same list represented in the second box notation looks like this:</source>
          <target state="translated">同样的列表用第二个方框符号表示是这样的。</target>
        </trans-unit>
        <trans-unit id="de2afa602b0c6c3641bec0bd9db4c0990c1cd810" translate="yes" xml:space="preserve">
          <source>The same magic comment can copy any kind of form into</source>
          <target state="translated">同样的魔法评论可以将任何一种形式复制到</target>
        </trans-unit>
        <trans-unit id="4a6fb3f7c0f51bfade6342cfbde9264dd003c537" translate="yes" xml:space="preserve">
          <source>The same sort of thing goes for macros and &lt;code&gt;defsubst&lt;/code&gt; functions defined locally and only for use within the file. They are needed for compiling the file, but in most cases they are not needed for execution of the compiled file. For example,</source>
          <target state="translated">对于本地定义的宏和 &lt;code&gt;defsubst&lt;/code&gt; 函数，也只能在文件内使用。它们是编译文件所必需的，但是在大多数情况下，执行编译后的文件并不需要它们。例如，</target>
        </trans-unit>
        <trans-unit id="9eafcd90784684c4b6941c5a7e212f4389f29375" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;rx-let&lt;/code&gt; bindings is lexical, which means that they are not visible outside &lt;var&gt;body&lt;/var&gt; itself, even in functions called from &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; 绑定的范围是词法的，这意味着它们在 &lt;var&gt;body&lt;/var&gt; 本身是不可见的，即使在从 &lt;var&gt;body&lt;/var&gt; 调用的函数中也不可见。</target>
        </trans-unit>
        <trans-unit id="b2fa435053db7e98e5d129031c4eef40310ac931" translate="yes" xml:space="preserve">
          <source>The screen position of the left edge of the frame&amp;rsquo;s icon, in pixels, counting from the left edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature. If you specify a value for this parameter, then you must also specify a value for &lt;code&gt;icon-top&lt;/code&gt; and vice versa.</source>
          <target state="translated">从屏幕的左边缘开始算起，框架图标左边缘的屏幕位置（以像素为单位）。如果窗口管理器支持该功能，则该图标在框架被图标化时生效。如果为此参数指定一个值，则还必须为 &lt;code&gt;icon-top&lt;/code&gt; 指定一个值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="e50e923623c82eb23aa190894066a65503358e35" translate="yes" xml:space="preserve">
          <source>The screen position of the top (or bottom) edge, in pixels, with respect to the top (or bottom) edge of the display or parent frame. It works just like &lt;code&gt;left&lt;/code&gt;, except vertically instead of horizontally.</source>
          <target state="translated">顶部（或底部）边缘相对于显示器或父框架的顶部（或底部）边缘的屏幕位置（以像素为单位）。它的工作原理与 &lt;code&gt;left&lt;/code&gt; 相同，只是垂直而不是水平。</target>
        </trans-unit>
        <trans-unit id="0cda3076dfbc17092f6e7b4b160ef022e7169a19" translate="yes" xml:space="preserve">
          <source>The screen position of the top edge of the frame&amp;rsquo;s icon, in pixels, counting from the top edge of the screen. This takes effect when the frame is iconified, if the window manager supports this feature.</source>
          <target state="translated">从屏幕的顶部边缘开始算起，框架图标的顶部边缘的屏幕位置（以像素为单位）。如果窗口管理器支持该功能，则该图标在框架被图标化时生效。</target>
        </trans-unit>
        <trans-unit id="e751536ab732a9f489e9afb199afec619dbdde42" translate="yes" xml:space="preserve">
          <source>The script that the font must support (a symbol).</source>
          <target state="translated">字体必须支持的文字(符号)。</target>
        </trans-unit>
        <trans-unit id="5ca4bb9976c740ecc0981b8e9b17319d5ac9d81d" translate="yes" xml:space="preserve">
          <source>The search for an applicable handler checks all the established handlers starting with the most recently established one. Thus, if two nested &lt;code&gt;condition-case&lt;/code&gt; forms offer to handle the same error, the inner of the two gets to handle it.</source>
          <target state="translated">搜索适用的处理程序将检查所有已建立的处理程序，从最近建立的处理程序开始。因此，如果两个嵌套的 &lt;code&gt;condition-case&lt;/code&gt; 形式提供处理相同的错误，则两个内部条件形式都将处理它。</target>
        </trans-unit>
        <trans-unit id="473e360900bfeca8b04b8a805f75bfd348f74028" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;infile&lt;/var&gt; may invoke a file name handler. The file name handler could be different from the handler chosen for the &lt;code&gt;process-file&lt;/code&gt; function itself. (For example, &lt;code&gt;default-directory&lt;/code&gt; could be on one remote host, and &lt;var&gt;infile&lt;/var&gt; on a different remote host. Or &lt;code&gt;default-directory&lt;/code&gt; could be non-special, whereas &lt;var&gt;infile&lt;/var&gt; is on a remote host.)</source>
          <target state="translated">第二个参数 &lt;var&gt;infile&lt;/var&gt; 可以调用文件名处理程序。文件名处理程序可能与为 &lt;code&gt;process-file&lt;/code&gt; 功能本身选择的处理程序不同。 （例如， &lt;code&gt;default-directory&lt;/code&gt; 可以位于一个远程主机上， &lt;var&gt;infile&lt;/var&gt; 可以位于另一台远程主机上。或者 &lt;code&gt;default-directory&lt;/code&gt; 可以是非特殊目录，而 &lt;var&gt;infile&lt;/var&gt; 可以位于远程主机上。）</target>
        </trans-unit>
        <trans-unit id="79312a7cce37d37bed367239a38284f2028a8f95" translate="yes" xml:space="preserve">
          <source>The second argument &lt;var&gt;size&lt;/var&gt; is the size of text, in characters, following point. The function examines text only within &lt;var&gt;size&lt;/var&gt; characters after point. Normally, the buffer should be positioned at the beginning when this function is called, because one of the places for the &lt;code&gt;coding:&lt;/code&gt; tag is the first one or two lines of the file; in that case, &lt;var&gt;size&lt;/var&gt; should be the size of the buffer.</source>
          <target state="translated">第二个参数 &lt;var&gt;size&lt;/var&gt; 是跟在后面的文本大小，以字符为单位。该功能仅在点后的 &lt;var&gt;size&lt;/var&gt; 字符内检查文本。通常，缓冲区应位于调用此函数的开头，因为 &lt;code&gt;coding:&lt;/code&gt; 一个位置：标签是文件的第一行或第二行；在这种情况下， &lt;var&gt;size&lt;/var&gt; 应为缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="b1571642b672d840c71b1f3b7f58f82da1c8dc26" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;code&gt;condition-case&lt;/code&gt; is called the &lt;em&gt;protected form&lt;/em&gt;. (In the example above, the protected form is a call to &lt;code&gt;delete-file&lt;/code&gt;.) The error handlers go into effect when this form begins execution and are deactivated when this form returns. They remain in effect for all the intervening time. In particular, they are in effect during the execution of functions called by this form, in their subroutines, and so on. This is a good thing, since, strictly speaking, errors can be signaled only by Lisp primitives (including &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;) called by the protected form, not by the protected form itself.</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; 的第二个参数称为&lt;em&gt;保护形式&lt;/em&gt;。（在上面的示例中，受保护的表单是对 &lt;code&gt;delete-file&lt;/code&gt; 的调用。）错误处理程序在此表单开始执行时生效，并在此表单返回时被停用。它们在所有插入时间内一直有效。特别是，它们在执行此形式调用的函数期间，在其子例程中等时有效。这是一件好事，因为严格来说，错误只能由受保护形式调用的Lisp原语（包括 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;error&lt;/code&gt; ）发出信号，而不能由受保护形式本身调用。</target>
        </trans-unit>
        <trans-unit id="335d04a9fb11a0984d4c4b395642d49eb8062099" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;minibuf&lt;/var&gt;, says which frames to consider:</source>
          <target state="translated">第二个参数 &lt;var&gt;minibuf&lt;/var&gt; 表示要考虑的帧：</target>
        </trans-unit>
        <trans-unit id="043e175330e7a9266b5fd9e72aad0ac9c4f497a2" translate="yes" xml:space="preserve">
          <source>The second cons cell, which previously held the element &lt;code&gt;b&lt;/code&gt;, still exists and its &lt;small&gt;CAR&lt;/small&gt; is still &lt;code&gt;b&lt;/code&gt;, but it no longer forms part of this list.</source>
          <target state="translated">先前保留元素 &lt;code&gt;b&lt;/code&gt; 的第二个cons单元格仍然存在，并且其&lt;small&gt;CAR&lt;/small&gt;仍为 &lt;code&gt;b&lt;/code&gt; ，但不再构成此列表的一部分。</target>
        </trans-unit>
        <trans-unit id="cc4971cc83ebc92e997f73e4a1271f23051fec45" translate="yes" xml:space="preserve">
          <source>The second crucial difference between macros and functions is that the value returned by the macro body is an alternate Lisp expression, also known as the &lt;em&gt;expansion&lt;/em&gt; of the macro. The Lisp interpreter proceeds to evaluate the expansion as soon as it comes back from the macro.</source>
          <target state="translated">宏和函数之间的第二个关键区别是宏主体返回的值是备用Lisp表达式，也称为宏&lt;em&gt;扩展&lt;/em&gt;。Lisp解释器从宏返回后立即继续评估扩展。</target>
        </trans-unit>
        <trans-unit id="f1a6950eaae19621908380f623f25ce6e57c63a4" translate="yes" xml:space="preserve">
          <source>The second element is a list of symbols&amp;mdash;the argument variable names. This is called the &lt;em&gt;lambda list&lt;/em&gt;. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">第二个元素是符号列表-参数变量名称。这称为&lt;em&gt;lambda列表&lt;/em&gt;。调用Lisp函数时，参数值将与lambda列表中的变量匹配，这些变量将与提供的值进行本地绑定。请参阅&lt;a href=&quot;local-variables#Local-Variables&quot;&gt;局部变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca40c0325b239bb969d90b6c5d596d17aee4f342" translate="yes" xml:space="preserve">
          <source>The second element, &lt;var&gt;keywords-only&lt;/var&gt;, specifies the value of the variable &lt;code&gt;font-lock-keywords-only&lt;/code&gt;. If this is omitted or &lt;code&gt;nil&lt;/code&gt;, syntactic fontification (of strings and comments) is also performed. If this is non-&lt;code&gt;nil&lt;/code&gt;, syntactic fontification is not performed. See &lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;Syntactic Font Lock&lt;/a&gt;.</source>
          <target state="translated">第二个元素， &lt;var&gt;keywords-only&lt;/var&gt; ，指定变量 &lt;code&gt;font-lock-keywords-only&lt;/code&gt; 的值。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则还将执行（字符串和注释的）语法字体化。如果这是不 &lt;code&gt;nil&lt;/code&gt; ，不进行语法fontification。请参阅&lt;a href=&quot;syntactic-font-lock#Syntactic-Font-Lock&quot;&gt;语法字体锁定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05af5100d6bbcd92ab672dd54e8a7002bdd81fa9" translate="yes" xml:space="preserve">
          <source>The second example shows that when the final argument is a sequence but not a list, the sequence&amp;rsquo;s elements do not become elements of the resulting list. Instead, the sequence becomes the final &lt;small&gt;CDR&lt;/small&gt;, like any other non-list final argument.</source>
          <target state="translated">第二个示例显示，当最终参数是序列而不是列表时，序列的元素不会成为结果列表的元素。而是，该序列成为最终&lt;small&gt;CDR&lt;/small&gt;，就像其他任何非列表最终参数一样。</target>
        </trans-unit>
        <trans-unit id="78870468f3063c31ec99a482f80bcfe4fdf9caa7" translate="yes" xml:space="preserve">
          <source>The second item in the list, &lt;var&gt;regexp&lt;/var&gt;, is a regular expression (see &lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;Regular Expressions&lt;/a&gt;); anything in the buffer that it matches is considered a definition, something to mention in the buffer index. The third item, &lt;var&gt;index&lt;/var&gt;, is a non-negative integer that indicates which subexpression in &lt;var&gt;regexp&lt;/var&gt; matches the definition&amp;rsquo;s name.</source>
          <target state="translated">列表中的第二项 &lt;var&gt;regexp&lt;/var&gt; 是一个正则表达式（请参见&lt;a href=&quot;regular-expressions#Regular-Expressions&quot;&gt;正则表达式&lt;/a&gt;）；它匹配的缓冲区中的任何内容均视为定义，在缓冲区索引中要提及。第三项 &lt;var&gt;index&lt;/var&gt; 是一个非负整数，指示正则表达式中的哪个子 &lt;var&gt;regexp&lt;/var&gt; 与定义的名称匹配。</target>
        </trans-unit>
        <trans-unit id="39db81295962c9250ac04e8024ae7b73da16e061" translate="yes" xml:space="preserve">
          <source>The second of these hooks is run when a &lt;em&gt;window size change&lt;/em&gt; has been detected which means that a window was created, assigned another buffer, or changed its total size or that of its text area.</source>
          <target state="translated">当检测到&lt;em&gt;窗口大小更改&lt;/em&gt;时，便会运行其中的第二个挂钩，这意味着已创建一个窗口，为其分配了另一个缓冲区或更改了其总大小或其文本区域的总大小。</target>
        </trans-unit>
        <trans-unit id="e10a4024014db92893950553799fa332ec4eec91" translate="yes" xml:space="preserve">
          <source>The second part of the pattern matches any closing braces and quotation marks, zero or more of them, that may follow the period, question mark or exclamation mark. The &lt;code&gt;\&quot;&lt;/code&gt; is Lisp syntax for a double-quote in a string. The &amp;lsquo;</source>
          <target state="translated">模式的第二部分与可能在句点，问号或感叹号之后的所有右括号和引号（零个或多个）匹配。在 &lt;code&gt;\&quot;&lt;/code&gt; 是字符串中的双引号Lisp语言的语法。在'</target>
        </trans-unit>
        <trans-unit id="7da34c753b40326f37f6172c1b58a8c5f825b8f9" translate="yes" xml:space="preserve">
          <source>The selected frame is on a graphical display supporting such dialogs.</source>
          <target state="translated">所选择的框架是在一个支持这种对话框的图形显示器上。</target>
        </trans-unit>
        <trans-unit id="dda9cd63960f9a91b850378b1927da3e714f3287" translate="yes" xml:space="preserve">
          <source>The selected window if it is either specified by a &lt;code&gt;previous-window&lt;/code&gt;&lt;var&gt;alist&lt;/var&gt; entry or showed &lt;var&gt;buffer&lt;/var&gt; before.</source>
          <target state="translated">所选窗口是由上一个 &lt;code&gt;previous-window&lt;/code&gt; &lt;var&gt;alist&lt;/var&gt; 条目指定的，还是之前显示的 &lt;var&gt;buffer&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="4beffd62ee0e9328af316739d55ab903054a8e51" translate="yes" xml:space="preserve">
          <source>The selected window is considered part of a group when the buffer local variable &lt;code&gt;selected-window-group-function&lt;/code&gt; is set to a function. In this case, &lt;code&gt;selected-window-group&lt;/code&gt; calls it with no arguments and returns its result (which should be the list of windows in the group).</source>
          <target state="translated">当缓冲区局部变量 &lt;code&gt;selected-window-group-function&lt;/code&gt; 设置为函数时，所选窗口被视为组的一部分。在这种情况下， &lt;code&gt;selected-window-group&lt;/code&gt; 不带任何参数调用它并返回其结果（应该是该组窗口的列表）。</target>
        </trans-unit>
        <trans-unit id="c7b994494213138fb5de0429d794e7e303777bef" translate="yes" xml:space="preserve">
          <source>The selected window is the one that you edit in.</source>
          <target state="translated">选择的窗口就是你编辑的窗口。</target>
        </trans-unit>
        <trans-unit id="8665184a4907ab2354fc3286c669e4a6527d1f62" translate="yes" xml:space="preserve">
          <source>The selected window&amp;rsquo;s mode line is usually displayed in a different color using the face &lt;code&gt;mode-line&lt;/code&gt;. Other windows&amp;rsquo; mode lines appear in the face &lt;code&gt;mode-line-inactive&lt;/code&gt; instead. See &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;.</source>
          <target state="translated">所选窗口的模式行通常使用面部 &lt;code&gt;mode-line&lt;/code&gt; 以不同的颜色显示。其他窗口的模式 &lt;code&gt;mode-line-inactive&lt;/code&gt; 改为不显示在面部模式行中。见&lt;a href=&quot;faces#Faces&quot;&gt;面孔&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8000cca8be137f75ed18782493ccc880df1113c" translate="yes" xml:space="preserve">
          <source>The semantics of maximizing and iconifying child frames is highly window-system dependent. As a rule, applications should never invoke these operations on child frames. By default, invoking &lt;code&gt;iconify-frame&lt;/code&gt; on a child frame will try to iconify the top-level frame corresponding to that child frame instead. To obtain a different behavior, users may customize the option &lt;code&gt;iconify-child-frame&lt;/code&gt; described below.</source>
          <target state="translated">最大化和图标化子框架的语义高度依赖于窗口系统。通常，应用程序永远不要在子框架上调用这些操作。默认情况下，在子 &lt;code&gt;iconify-frame&lt;/code&gt; 上调用iconify-frame会尝试将与该子框架相对应的顶级框架进行图标化。为了获得不同的行为，用户可以自定义下面描述的选项 &lt;code&gt;iconify-child-frame&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fdee8f54d168addba0e7230f98080d05a806af9" translate="yes" xml:space="preserve">
          <source>The sequence of calls to &lt;code&gt;select-window&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument determines an ordering of windows by their selection time. The function &lt;code&gt;get-lru-window&lt;/code&gt; can be used to retrieve the least recently selected live window (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">用非 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;norecord&lt;/var&gt; 参数调用 &lt;code&gt;select-window&lt;/code&gt; 的顺序决定了窗口的选择时间。函数 &lt;code&gt;get-lru-window&lt;/code&gt; 可以用于检索最近最少选择的活动窗口（请参阅&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b6126ae190f28d94232911a10b32f330dbd4538f" translate="yes" xml:space="preserve">
          <source>The sequence of kills in the kill ring wraps around, so that after the oldest one comes the newest one, and before the newest one goes the oldest.</source>
          <target state="translated">杀戒中的杀戮顺序绕来绕去,所以在最老的之后是最新的,而在最新的之前是最老的。</target>
        </trans-unit>
        <trans-unit id="d17460f17018f05e49ff10eb23d17bcf4ac2e075" translate="yes" xml:space="preserve">
          <source>The serial port can be configured at run-time, without having to close and re-open it. The function &lt;code&gt;serial-process-configure&lt;/code&gt; lets you change the speed, bytesize, and other parameters. In a terminal window created by &lt;code&gt;serial-term&lt;/code&gt;, you can click on the mode line for configuration.</source>
          <target state="translated">可以在运行时配置串行端口，而不必关闭并重新打开它。函数 &lt;code&gt;serial-process-configure&lt;/code&gt; 允许您更改速度，字节大小和其他参数。在由 &lt;code&gt;serial-term&lt;/code&gt; 创建的终端窗口中，可以单击模式行进行配置。</target>
        </trans-unit>
        <trans-unit id="d2a9ae6c941e0bf24383fb2647a4f9171e1de594" translate="yes" xml:space="preserve">
          <source>The server supports hyperlinks in the notifications.</source>
          <target state="translated">服务器支持通知中的超链接。</target>
        </trans-unit>
        <trans-unit id="1636c548d4728e3546b4e61c467b130421fb3043" translate="yes" xml:space="preserve">
          <source>The server supports images in the notifications.</source>
          <target state="translated">服务器在通知中支持图片。</target>
        </trans-unit>
        <trans-unit id="3b6b682f52a52c12c8f9b21281af0b720bd16c65" translate="yes" xml:space="preserve">
          <source>The server supports persistence of notifications.</source>
          <target state="translated">服务器支持通知的持久化。</target>
        </trans-unit>
        <trans-unit id="21a9b47dbf0032eaa7cb77326a6a549f6f528a88" translate="yes" xml:space="preserve">
          <source>The server supports sounds on notifications.</source>
          <target state="translated">服务器支持通知的声音。</target>
        </trans-unit>
        <trans-unit id="32a2fb16a21966056b09359c49d25b26580e0735" translate="yes" xml:space="preserve">
          <source>The server will provide the specified actions to the user.</source>
          <target state="translated">服务器将向用户提供指定的操作。</target>
        </trans-unit>
        <trans-unit id="487bc1e1eea831388d87886ebed5499c261328d4" translate="yes" xml:space="preserve">
          <source>The server will render an animation of all the frames in a given image array.</source>
          <target state="translated">服务器将渲染给定图像数组中所有帧的动画。</target>
        </trans-unit>
        <trans-unit id="3d669bc7256cde6bc52048dc9f7dc18c0ff77233" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s process buffer value is never used directly, but the log function can retrieve it and use it to log connections by inserting text there.</source>
          <target state="translated">服务器的进程缓冲区值从不直接使用，但是日志功能可以检索该值，并通过在其中插入文本来使用它来记录连接。</target>
        </trans-unit>
        <trans-unit id="d4af74ba408681f224f4eae7dc1fcceae876b1eb" translate="yes" xml:space="preserve">
          <source>The server&amp;rsquo;s version number.</source>
          <target state="translated">服务器的版本号。</target>
        </trans-unit>
        <trans-unit id="850499dab30d08985261f9268e55591d68aa5d33" translate="yes" xml:space="preserve">
          <source>The session ID of the process. This is a number that is the process ID of the process&amp;rsquo;s &lt;em&gt;session leader&lt;/em&gt;.</source>
          <target state="translated">进程的会话ID。这是一个数字，它是进程的&lt;em&gt;会话领导者&lt;/em&gt;的进程ID 。</target>
        </trans-unit>
        <trans-unit id="76fb62b9ff894328ee87291f8886595e1599a44b" translate="yes" xml:space="preserve">
          <source>The set of abbrevs currently in effect is recorded in an &lt;em&gt;abbrev table&lt;/em&gt;. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.</source>
          <target state="translated">当前有效的&lt;em&gt;缩写&lt;/em&gt;集记录在&lt;em&gt;缩写表中&lt;/em&gt;。每个缓冲区都有一个本地缩写表，但通常，处于相同主模式的所有缓冲区都共享一个缩写表。还有一个全局缩写表。通常都使用。</target>
        </trans-unit>
        <trans-unit id="13bc56e40d973a547522dffd931b5104b534cbab" translate="yes" xml:space="preserve">
          <source>The set of possible multi-event key sequences depends on the bindings for prefix keys; therefore, it can be different for different keymaps, and can change when bindings are changed. However, a one-event sequence is always a key sequence, because it does not depend on any prefix keys for its well-formedness.</source>
          <target state="translated">一组可能的多事件键序列取决于前缀键的绑定;因此,对于不同的键图,它可以是不同的,当绑定改变时,它也可以改变。然而,一个事件序列总是一个密钥序列,因为它不依赖于任何前缀键的良好形式。</target>
        </trans-unit>
        <trans-unit id="ea89afa3ebcf085515befba35c098def36ebf120" translate="yes" xml:space="preserve">
          <source>The set of supported &lt;code&gt;TZ&lt;/code&gt; strings is system-dependent. GNU and many other systems support the tzdata database, e.g., &amp;lsquo;</source>
          <target state="translated">支持的 &lt;code&gt;TZ&lt;/code&gt; 字符串集取决于系统。GNU和许多其他系统支持tzdata数据库，例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ed52d340e29425d0c36d441fce1706eefbff92a9" translate="yes" xml:space="preserve">
          <source>The setf Macro</source>
          <target state="translated">设定f 宏观</target>
        </trans-unit>
        <trans-unit id="656aedcd7cd333555b5a910bc06a2f9bb048509a" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;printenv&lt;/code&gt; prints all or part of the environment:</source>
          <target state="translated">shell命令 &lt;code&gt;printenv&lt;/code&gt; 打印全部或部分环境：</target>
        </trans-unit>
        <trans-unit id="697532010a390342417a302aa64e0eeb89a98cb2" translate="yes" xml:space="preserve">
          <source>The shell command &lt;code&gt;uptime&lt;/code&gt; returns similar information.</source>
          <target state="translated">Shell命令 &lt;code&gt;uptime&lt;/code&gt; 返回类似的信息。</target>
        </trans-unit>
        <trans-unit id="7c0ee07626a06ec319c5fa6dda80e5cd02b895c5" translate="yes" xml:space="preserve">
          <source>The shift modifier.</source>
          <target state="translated">移位修改器。</target>
        </trans-unit>
        <trans-unit id="526047c002039949790c223830818877585cd005" translate="yes" xml:space="preserve">
          <source>The significant way that errors are classified is by their condition names&amp;mdash;the names used to match errors with handlers. An error symbol serves only as a convenient way to specify the intended error message and list of condition names. It would be cumbersome to give &lt;code&gt;signal&lt;/code&gt; a list of condition names rather than one error symbol.</source>
          <target state="translated">对错误进行分类的重要方式是根据它们的条件名称-用于与处理程序匹配错误的名称。错误符号仅用作指定预期错误消息和条件名称列表的简便方法。给 &lt;code&gt;signal&lt;/code&gt; 提供条件名称列表而不是一个错误符号将很麻烦。</target>
        </trans-unit>
        <trans-unit id="701a4ad01ef06b4bddd59b324ead42eff350dde1" translate="yes" xml:space="preserve">
          <source>The simple way to define an inline function, is to write &lt;code&gt;defsubst&lt;/code&gt; instead of &lt;code&gt;defun&lt;/code&gt;. The rest of the definition looks just the same, but using &lt;code&gt;defsubst&lt;/code&gt; says to make it inline for byte compilation.</source>
          <target state="translated">最简单的方法来定义内联函数，是写 &lt;code&gt;defsubst&lt;/code&gt; 而不是 &lt;code&gt;defun&lt;/code&gt; 定义。其余的定义看起来相同，但使用 &lt;code&gt;defsubst&lt;/code&gt; 表示将其内联用于字节编译。</target>
        </trans-unit>
        <trans-unit id="51e0da75b610832dceffa32e7fc903b0a72cc0e2" translate="yes" xml:space="preserve">
          <source>The simpler (and original) way to define a menu item is to bind some event type (it doesn&amp;rsquo;t matter what event type) to a binding like this:</source>
          <target state="translated">定义菜单项的更简单（原始）方法是将某种事件类型（与哪种事件类型无关）绑定到这样的绑定：</target>
        </trans-unit>
        <trans-unit id="c63bdaac10002dfd9144bf4493ac37c5ee6a7227" translate="yes" xml:space="preserve">
          <source>The simplest order of execution is sequential execution: first form &lt;var&gt;a&lt;/var&gt;, then form &lt;var&gt;b&lt;/var&gt;, and so on. This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code&amp;mdash;the forms are executed in the order written. We call this &lt;em&gt;textual order&lt;/em&gt;. For example, if a function body consists of two forms &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt;, evaluation of the function evaluates first &lt;var&gt;a&lt;/var&gt; and then &lt;var&gt;b&lt;/var&gt;. The result of evaluating &lt;var&gt;b&lt;/var&gt; becomes the value of the function.</source>
          <target state="translated">执行的最简单顺序是顺序执行：首先形成 &lt;var&gt;a&lt;/var&gt; ，然后形成 &lt;var&gt;b&lt;/var&gt; ，依此类推。当您在函数的主体中或在Lisp代码文件的顶层连续编写多个表单时，就会发生这种情况-表单按照写入的顺序执行。我们称这种&lt;em&gt;文本顺序&lt;/em&gt;。例如，如果功能主体由两个形式 &lt;var&gt;a&lt;/var&gt; 和 &lt;var&gt;b&lt;/var&gt; 组成，则该功能的评估首先评估 &lt;var&gt;a&lt;/var&gt; ，然后评估 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;b&lt;/var&gt; 的评估结果成为函数的值。</target>
        </trans-unit>
        <trans-unit id="2e0a2f8802289814697d3ff9bc642bb98ac915eb" translate="yes" xml:space="preserve">
          <source>The simplest way to add an element to an alist is like this:</source>
          <target state="translated">向alist添加元素的最简单方法是这样的。</target>
        </trans-unit>
        <trans-unit id="b58a2304ffb2d18ce86b489ba35624a904a8a1e9" translate="yes" xml:space="preserve">
          <source>The simplest way to examine text properties is to ask for the value of a particular property of a particular character. For that, use &lt;code&gt;get-text-property&lt;/code&gt;. Use &lt;code&gt;text-properties-at&lt;/code&gt; to get the entire property list of a character. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;, for functions to examine the properties of a number of characters at once.</source>
          <target state="translated">检查文本属性的最简单方法是询问特定字符的特定属性的值。为此，请使用 &lt;code&gt;get-text-property&lt;/code&gt; 。使用 &lt;code&gt;text-properties-at&lt;/code&gt; 获取字符的整个属性列表。有关一次检查多个字符的属性的功能，请参见&amp;ldquo;&lt;a href=&quot;property-search#Property-Search&quot;&gt;属性搜索&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adc76fb843de7f5b33d2478fbfc134dfe5c4dcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to use a variable is &lt;em&gt;globally&lt;/em&gt;. This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system. The value remains in effect until you specify a new one. When a new value replaces the old one, no trace of the old value remains in the variable.</source>
          <target state="translated">使用变量的最简单方法是&lt;em&gt;全局&lt;/em&gt;。这意味着该变量一次仅具有一个值，并且该值在整个Lisp系统中都有效（至少目前如此）。该值将保持有效，直到您指定一个新值为止。当新值替换旧值时，变量中不会保留任何旧值。</target>
        </trans-unit>
        <trans-unit id="2b36ac08912d39209d118742c10208da562be7cf" translate="yes" xml:space="preserve">
          <source>The size of buffer&amp;rsquo;s gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">缓冲区间隙的大小。请参阅&lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;缓冲区间隙&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="873e96ede3bbdf4e5518603c5529cf1eece61c3f" translate="yes" xml:space="preserve">
          <source>The size of the accessible part of the current buffer; basically &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt;.</source>
          <target state="translated">当前缓冲区可访问部分的大小；基本上 &lt;code&gt;(- (point-max) (point-min))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a849ae6a00f9521aec6d2261f95fba3341d311e" translate="yes" xml:space="preserve">
          <source>The size of the file in bytes (&lt;code&gt;file-attribute-size&lt;/code&gt;).</source>
          <target state="translated">文件大小，以字节为单位（ &lt;code&gt;file-attribute-size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8f563b6a9a8db0e9d2b8a141ce4f9b7d9e8e1e86" translate="yes" xml:space="preserve">
          <source>The size of the new window can be adjusted by supplying &lt;code&gt;window-height&lt;/code&gt; and &lt;code&gt;window-width&lt;/code&gt; entries in &lt;var&gt;alist&lt;/var&gt;. If &lt;var&gt;alist&lt;/var&gt; contains a &lt;code&gt;preserve-size&lt;/code&gt; entry, Emacs will also try to preserve the size of the new window during future resize operations (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">可以通过在 &lt;var&gt;alist&lt;/var&gt; 中提供 &lt;code&gt;window-height&lt;/code&gt; 和 &lt;code&gt;window-width&lt;/code&gt; 条目来调整新窗口的大小。如果 &lt;var&gt;alist&lt;/var&gt; 包含 &lt;code&gt;preserve-size&lt;/code&gt; 入境时，Emacs也将尝试在未来的调整大小操作中保存新窗口的大小（请参阅&lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;保留窗口大小&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="43af7be726f5955aa5ff42c15118a19504247059" translate="yes" xml:space="preserve">
          <source>The size of the process&amp;rsquo;s &lt;em&gt;resident set&lt;/em&gt;, the number of kilobytes occupied by the process in the machine&amp;rsquo;s physical memory.</source>
          <target state="translated">进程的&lt;em&gt;驻留集&lt;/em&gt;大小，该进程在计算机的物理内存中占用的千字节数。</target>
        </trans-unit>
        <trans-unit id="576b8e3ff0609705a9b9504b486dacc40004ea6d" translate="yes" xml:space="preserve">
          <source>The sorting functions described in this section all rearrange text in a buffer. This is in contrast to the function &lt;code&gt;sort&lt;/code&gt;, which rearranges the order of the elements of a list (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;). The values returned by these functions are not meaningful.</source>
          <target state="translated">本节中描述的排序功能均在缓冲区中重新排列文本。这与函数 &lt;code&gt;sort&lt;/code&gt; 相对，后者对列表元素的顺序进行了&lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;重新排列&lt;/a&gt;（请参阅重新排列）。这些函数返回的值没有意义。</target>
        </trans-unit>
        <trans-unit id="4c3d2a4b26d988675d4c78f53514dab4c53dcc03" translate="yes" xml:space="preserve">
          <source>The sound must be stored as a file in RIFF-WAVE format (&amp;lsquo;</source>
          <target state="translated">声音必须以RIFF-WAVE格式存储为文件（'</target>
        </trans-unit>
        <trans-unit id="0497cf1b10750bd04c03011dc18b4f0cfdc47413" translate="yes" xml:space="preserve">
          <source>The space of possible character codes is divided into various character sets.</source>
          <target state="translated">可能的字符代码空间被划分为各种字符集。</target>
        </trans-unit>
        <trans-unit id="9432d6b9187cb979929edaa344995bf72578704f" translate="yes" xml:space="preserve">
          <source>The special commands of Edebug are available in the source code buffer in addition to the commands of Emacs Lisp mode. For example, you can type the Edebug command</source>
          <target state="translated">Edebug的特殊命令除了Emacs Lisp模式的命令外,还可以在源代码缓冲区中使用。例如,你可以输入Edebug命令</target>
        </trans-unit>
        <trans-unit id="749a997c2ad2240b06198fe40cd85ef622970354" translate="yes" xml:space="preserve">
          <source>The special commands of these modes bind &lt;code&gt;buffer-read-only&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; (with &lt;code&gt;let&lt;/code&gt;) or bind &lt;code&gt;inhibit-read-only&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; around the places where they themselves change the text.</source>
          <target state="translated">这些模式的特殊命令将 &lt;code&gt;buffer-read-only&lt;/code&gt; 绑定到 &lt;code&gt;nil&lt;/code&gt; （带有 &lt;code&gt;let&lt;/code&gt; ），或者将 &lt;code&gt;inhibit-read-only&lt;/code&gt; 绑定到 &lt;code&gt;t&lt;/code&gt; 本身更改文本的地方。</target>
        </trans-unit>
        <trans-unit id="388ba11e949e8870ac609c14e29761f15abdd417" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;interactive&lt;/code&gt; turns a Lisp function into a command. The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, usually as the first form in the body; this applies to both lambda expressions (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;) and &lt;code&gt;defun&lt;/code&gt; forms (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;). This form does nothing during the actual execution of the function; its presence serves as a flag, telling the Emacs command loop that the function can be called interactively. The argument of the &lt;code&gt;interactive&lt;/code&gt; form specifies how the arguments for an interactive call should be read.</source>
          <target state="translated">特殊形式的 &lt;code&gt;interactive&lt;/code&gt; 将Lisp函数转换为命令。所述 &lt;code&gt;interactive&lt;/code&gt; 表格必须定位在功能体的顶层，通常作为在体内的第一形式;这适用于lambda表达式（请参阅&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda表达式&lt;/a&gt;）和 &lt;code&gt;defun&lt;/code&gt; 形式（请参见&lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;定义函数&lt;/a&gt;）。在函数的实际执行过程中，此形式不执行任何操作。它的存在充当一个标志，告诉Emacs命令循环该函数可以被交互调用。的的说法 &lt;code&gt;interactive&lt;/code&gt; 形式指定用于交互调用的参数应该如何读。</target>
        </trans-unit>
        <trans-unit id="0005a6b722d00b053f8a1c5bab2e99c2e0e932c1" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;quote&lt;/code&gt; returns its single argument, as written, without evaluating it. This provides a way to include constant symbols and lists, which are not self-evaluating objects, in a program. (It is not necessary to quote self-evaluating objects such as numbers, strings, and vectors.)</source>
          <target state="translated">特殊形式的 &lt;code&gt;quote&lt;/code&gt; 按原样返回其单个参数，而不对其求值。这提供了一种在程序中包括不是自评估对象的常量符号和列表的方法。（没有必要引用自评估对象，例如数字，字符串和向量。）</target>
        </trans-unit>
        <trans-unit id="244f4b5640ec3dae1a8ddb2bdbc59df8cee21b33" translate="yes" xml:space="preserve">
          <source>The special form &lt;code&gt;track-mouse&lt;/code&gt; enables generation of motion events within its body. Outside of &lt;code&gt;track-mouse&lt;/code&gt; forms, Emacs does not generate events for mere motion of the mouse, and these events do not appear. See &lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;Mouse Tracking&lt;/a&gt;.</source>
          <target state="translated">特殊形式的 &lt;code&gt;track-mouse&lt;/code&gt; 可在其体内生成运动事件。在 &lt;code&gt;track-mouse&lt;/code&gt; 形式之外，Emacs不会仅通过鼠标的移动就生成事件，并且这些事件不会出现。请参阅&lt;a href=&quot;mouse-tracking#Mouse-Tracking&quot;&gt;鼠标跟踪&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28ba34c98e1a089b9214cef4dc2999430a1d7a09" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; also set the default value (if they set the variable at all), rather than any buffer-local value.</source>
          <target state="translated">特殊形式 &lt;code&gt;defvar&lt;/code&gt; 和 &lt;code&gt;defconst&lt;/code&gt; 也设置默认值（如果它们完全设置了变量），而不是任何缓冲区局部值。</target>
        </trans-unit>
        <trans-unit id="5e119bef1e610c9f0380fd95f6e4af11230682fc" translate="yes" xml:space="preserve">
          <source>The special forms &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; exist to create local bindings:</source>
          <target state="translated">存在特殊形式 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;let*&lt;/code&gt; 来创建本地绑定：</target>
        </trans-unit>
        <trans-unit id="67b8199effbdb879bbf1f5d04029672e2a21aec2" translate="yes" xml:space="preserve">
          <source>The special marker &amp;lsquo;</source>
          <target state="translated">特殊标记&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="417f26037bec7ec878e05ef7fce97d3107e1525c" translate="yes" xml:space="preserve">
          <source>The special position where editing takes place.</source>
          <target state="translated">进行编辑的特殊位置。</target>
        </trans-unit>
        <trans-unit id="6604b0bf24124b0211a16d199be68fe327c5aa41" translate="yes" xml:space="preserve">
          <source>The special properties &lt;code&gt;point-entered&lt;/code&gt; and &lt;code&gt;point-left&lt;/code&gt; record hook functions that report motion of point. Each time point moves, Emacs compares these two property values:</source>
          <target state="translated">&lt;code&gt;point-entered&lt;/code&gt; 和 &lt;code&gt;point-left&lt;/code&gt; 记录钩子函数的特殊属性可报告点的运动。每个时间点移动时，Emacs都会比较这两个属性值：</target>
        </trans-unit>
        <trans-unit id="84235cb39de6ef4fc27674810653ef520a1cb95c" translate="yes" xml:space="preserve">
          <source>The special return value &amp;lsquo;</source>
          <target state="translated">特殊返回值'</target>
        </trans-unit>
        <trans-unit id="3cfd33d505b3e301ef67641d59464fa7fe2f87dd" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;child-frame&lt;/code&gt; means to make a minibuffer-only child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) whose parent becomes the frame created. As if specified as &lt;code&gt;nil&lt;/code&gt;, Emacs will set this parameter to the minibuffer window of the child frame but will not select the child frame after its creation.</source>
          <target state="translated">特殊值 &lt;code&gt;child-frame&lt;/code&gt; 意味着制作一个只有微型缓冲区的子框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;），其父框架成为创建的框架。就像指定为 &lt;code&gt;nil&lt;/code&gt; 一样，Emacs将此参数设置为子框架的minibuffer窗口，但是在创建后不会选择子框架。</target>
        </trans-unit>
        <trans-unit id="fcdc41fab620d4b9e47384a2bf4786023f64d828" translate="yes" xml:space="preserve">
          <source>The specification for backquote below illustrates how to match dotted lists and use &lt;code&gt;nil&lt;/code&gt; to terminate recursion. It also illustrates how components of a vector may be matched. (The actual specification defined by Edebug is a little different, and does not support dotted lists because doing so causes very deep recursion that could fail.)</source>
          <target state="translated">下面的backquote规范说明了如何匹配点列表和使用 &lt;code&gt;nil&lt;/code&gt; 终止递归。它还说明了如何匹配向量的成分。（Edebug定义的实际规范略有不同，并且不支持点分列表，因为这样做会导致很深的递归，而这可能会失败。）</target>
        </trans-unit>
        <trans-unit id="27d6230ee26567ac631f3131ae7886bcc7a72c78" translate="yes" xml:space="preserve">
          <source>The specification string also says which fonts to use in the fontset. See below for the details.</source>
          <target state="translated">规格字符串还说了要在字体集中使用哪些字体。详情请看下文。</target>
        </trans-unit>
        <trans-unit id="7f25f9498af3ebb82fd4fd0ed6c991c529aa68e9" translate="yes" xml:space="preserve">
          <source>The specification version the server is compliant with.</source>
          <target state="translated">服务器所符合的规格版本。</target>
        </trans-unit>
        <trans-unit id="9a30b5e6e028131d98090823da5db94954c0fdbe" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values. The following symbols have a special meaning:</source>
          <target state="translated">指定 &lt;var&gt;alist&lt;/var&gt; 是符号和值的关联列表。以下符号具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="e407764dfcb6e2f1247a11cf715cac7ed4f26bbf" translate="yes" xml:space="preserve">
          <source>The specified &lt;var&gt;frame&lt;/var&gt; becomes the selected frame, and its terminal becomes the selected terminal. This function then calls &lt;code&gt;select-window&lt;/code&gt; as a subroutine, passing the window selected within &lt;var&gt;frame&lt;/var&gt; as its first argument and &lt;var&gt;norecord&lt;/var&gt; as its second argument (hence, if &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this avoids changing the order of recently selected windows and the buffer list). See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">指定的 &lt;var&gt;frame&lt;/var&gt; 成为所选帧，并且其终端变为所选终端。然后，此函数调用 &lt;code&gt;select-window&lt;/code&gt; 作为子例程，将在 &lt;var&gt;frame&lt;/var&gt; 中选择的窗口作为其第一个参数，并将 &lt;var&gt;norecord&lt;/var&gt; 作为其第二个参数（因此，如果 &lt;var&gt;norecord&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，这避免了更改最近选择的窗口和缓冲区列表的顺序） ）。请参阅&lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;选择Windows&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87e2533bf5024d0890c44a2a577f82288504b5ca" translate="yes" xml:space="preserve">
          <source>The specified functions are stored in the property list of &lt;var&gt;name&lt;/var&gt; under the property &lt;code&gt;hash-table-test&lt;/code&gt;; the property value&amp;rsquo;s form is &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">指定的函数存储在 &lt;var&gt;name&lt;/var&gt; 属性列表中的 &lt;code&gt;hash-table-test&lt;/code&gt; 属性下；属性值的形式为 &lt;code&gt;(&lt;var&gt;test-fn&lt;/var&gt; &lt;var&gt;hash-fn&lt;/var&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91455a3d8f4bdb484463e73b427656cc16a89567" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second, a.k.a. &lt;em&gt;baud rate&lt;/em&gt;. The value can be any number, but most serial ports work only at a few defined values between 1200 and 115200, with 9600 being the most common value. If &lt;var&gt;speed&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the function ignores all other arguments and does not configure the port. This may be useful for special serial ports such as Bluetooth-to-serial converters, which can only be configured through &amp;lsquo;</source>
          <target state="translated">串行端口的速度，以每秒比特数为单位，也称为&lt;em&gt;波特率&lt;/em&gt;。该值可以是任何数字，但是大多数串行端口只能在1200至115200之间的几个已定义值下工作，其中9600是最常用的值。如果 &lt;var&gt;speed&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则该函数将忽略所有其他参数，并且不会配置端口。这对于特殊的串行端口（例如蓝牙到串行转换器）可能很有用，只能通过&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="52128a6146c27dc1c3960ab9a318c70adfaf8c01" translate="yes" xml:space="preserve">
          <source>The speed of the serial port in bits per second. This function calls &lt;code&gt;serial-process-configure&lt;/code&gt; to handle the speed; see the following documentation of that function for more details.</source>
          <target state="translated">串行端口的速度，以每秒位数为单位。该函数调用 &lt;code&gt;serial-process-configure&lt;/code&gt; 来处理速度。有关更多详细信息，请参见该功能的以下文档。</target>
        </trans-unit>
        <trans-unit id="fbb6c823ca23a02980eeae5e0a0001e4cc0886fe" translate="yes" xml:space="preserve">
          <source>The square brackets indicate that the &lt;code&gt;&amp;amp;optional&lt;/code&gt; and &lt;code&gt;&amp;amp;rest&lt;/code&gt; clauses, and the variables that follow them, are optional.</source>
          <target state="translated">方括号表示 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 和 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 子句以及其后的变量是可选的。</target>
        </trans-unit>
        <trans-unit id="81a3604cf4a5ac01501948bd0680c4975564433d" translate="yes" xml:space="preserve">
          <source>The stack frame made for the function call which enters the debugger in this way will be flagged automatically so that the debugger will be called again when the frame is exited. You can use the</source>
          <target state="translated">以这种方式进入调试器的函数调用所做的堆栈框架会被自动标记,这样当框架退出时,调试器将再次被调用。您可以使用</target>
        </trans-unit>
        <trans-unit id="9a119c8d6df162a4c1cd3d34b9608179ca3eb2aa" translate="yes" xml:space="preserve">
          <source>The standard GNU Emacs Lisp directory tree contains the code for several major modes, in files such as</source>
          <target state="translated">标准的GNU Emacs Lisp目录树包含了几种主要模式的代码,在文件中,如</target>
        </trans-unit>
        <trans-unit id="88217deefb3d70a4db90b540339f6b3e6d2c6eee" translate="yes" xml:space="preserve">
          <source>The standard definition of the &lt;code&gt;delete-frame&lt;/code&gt; event is to delete &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;delete-frame&lt;/code&gt; 事件的标准定义是delete &lt;var&gt;frame&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="03b918691e790a880d4fba6e47f98dbbdb8910de" translate="yes" xml:space="preserve">
          <source>The standard definition of this function is as follows:</source>
          <target state="translated">该函数的标准定义如下:</target>
        </trans-unit>
        <trans-unit id="6292beb7dc766e9cc6bfb7027445782776c9d55b" translate="yes" xml:space="preserve">
          <source>The standard definition of this function, on most operating systems, is as follows:</source>
          <target state="translated">在大多数操作系统上,该功能的标准定义如下。</target>
        </trans-unit>
        <trans-unit id="259daec623d20179dd6c873402018404fce5ae52" translate="yes" xml:space="preserve">
          <source>The standard input for the new process comes from file &lt;var&gt;infile&lt;/var&gt; if &lt;var&gt;infile&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, and from the null device otherwise. The argument &lt;var&gt;destination&lt;/var&gt; says where to put the process output. Here are the possibilities:</source>
          <target state="translated">如果 &lt;var&gt;infile&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则新过程的标准输入来自文件 &lt;var&gt;infile&lt;/var&gt; ，否则来自null设备。参数 &lt;var&gt;destination&lt;/var&gt; 指示将过程输出放置在何处。这里是可能性：</target>
        </trans-unit>
        <trans-unit id="44c287ca4b32485d2fbd1b0533c6bc30851eaea0" translate="yes" xml:space="preserve">
          <source>The standard letter-codes for reading arguments in various ways.</source>
          <target state="translated">标准信码,以各种方式解读论点。</target>
        </trans-unit>
        <trans-unit id="8f49ffda7284df4c0cd9b03dae4b8a52126166b8" translate="yes" xml:space="preserve">
          <source>The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. &lt;em&gt;That is a mistake.&lt;/em&gt; The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.</source>
          <target state="translated">文档字符串的开头通常在源文件中缩进，但是由于这些空格位于开始的双引号之前，因此它们不是字符串的一部分。有些人习惯于缩进字符串的任何其他行，以使文本在程序源代码中排成一行。&lt;em&gt;那是一个错误。&lt;/em&gt;以下行的缩进在字符串内；当通过help命令显示时，源代码中看起来不错的东西看起来很难看。</target>
        </trans-unit>
        <trans-unit id="4c672e151d200c22d18367c0a5d6b7e540bedaea" translate="yes" xml:space="preserve">
          <source>The state code of the process. This is a short string that encodes the scheduling state of the process. Here&amp;rsquo;s a list of the most frequently seen codes:</source>
          <target state="translated">进程的状态码。这是一个简短的字符串，用于编码流程的调度状态。以下是最常见的代码列表：</target>
        </trans-unit>
        <trans-unit id="f2d7146dc12f6d9513c21cfa997b6a60f75f956d" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro definition is saved and restored. While Edebug is active, &lt;code&gt;defining-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt;.</source>
          <target state="translated">键盘宏定义的状态已保存和恢复。当Edebug处于活动状态时，define &lt;code&gt;defining-kbd-macro&lt;/code&gt; 绑定到 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c91d0e0a6d197098d1a02ec3a2503f351103980" translate="yes" xml:space="preserve">
          <source>The state of keyboard macro execution is saved and restored. While Edebug is active, &lt;code&gt;executing-kbd-macro&lt;/code&gt; is bound to &lt;code&gt;nil&lt;/code&gt; unless &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">键盘宏执行状态被保存和恢复。虽然Edebug是活动的， &lt;code&gt;executing-kbd-macro&lt;/code&gt; 势必 &lt;code&gt;nil&lt;/code&gt; 除非 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf9ddd67b0e2736562e5e1b48123ad8e5e1a7a7d" translate="yes" xml:space="preserve">
          <source>The state of visibility of the frame. There are three possibilities: &lt;code&gt;nil&lt;/code&gt; for invisible, &lt;code&gt;t&lt;/code&gt; for visible, and &lt;code&gt;icon&lt;/code&gt; for iconified. See &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;.</source>
          <target state="translated">框架的可见状态。有三种可能性： &lt;code&gt;nil&lt;/code&gt; 代表不可见， &lt;code&gt;t&lt;/code&gt; 代表可见， &lt;code&gt;icon&lt;/code&gt; 代表图标。请参阅&lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;框架的可见性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e8a0a928375b331768ea9541d2c2a6c4d37acbb" translate="yes" xml:space="preserve">
          <source>The status of the subprocess belonging to the current buffer, obtained with &lt;code&gt;process-status&lt;/code&gt;. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">属于当前缓冲区的子 &lt;code&gt;process-status&lt;/code&gt; ，通过process-status获得。请参阅&lt;a href=&quot;process-information#Process-Information&quot;&gt;过程信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="999eb55350809e41053d193b69ed4373f0358a4b" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;buffer-name&lt;/var&gt; specifies the temporary buffer, which need not already exist. The argument must be a string, not a buffer. The buffer is erased initially (with no questions asked), and it is marked as unmodified after &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; exits.</source>
          <target state="translated">字符串 &lt;var&gt;buffer-name&lt;/var&gt; 指定了临时缓冲区，该缓冲区不必已经存在。参数必须是字符串，而不是缓冲区。缓冲区最初被擦除（不问任何问题），并且在 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 退出后被标记为未修改。</target>
        </trans-unit>
        <trans-unit id="a4d3cb799dfeca2e1bb98a62be5a7ac517d5ffb4" translate="yes" xml:space="preserve">
          <source>The string &lt;var&gt;lighter&lt;/var&gt; says what to display in the mode line when the mode is enabled; if it is &lt;code&gt;nil&lt;/code&gt;, the mode is not displayed in the mode line.</source>
          <target state="translated">字符串 &lt;var&gt;lighter&lt;/var&gt; 指示启用模式后在模式行中显示的内容；如果为 &lt;code&gt;nil&lt;/code&gt; ，则模式不显示在模式行中。</target>
        </trans-unit>
        <trans-unit id="a03446e19ee8800b453720d31c0b60da78dc7e80" translate="yes" xml:space="preserve">
          <source>The string containing the byte-code instructions.</source>
          <target state="translated">包含字节码指令的字符串。</target>
        </trans-unit>
        <trans-unit id="1ba6ac8d60c10283435c94518d321e4f95295bb9" translate="yes" xml:space="preserve">
          <source>The string describing the event looks like one of the following:</source>
          <target state="translated">描述该事件的字符串看起来像以下之一。</target>
        </trans-unit>
        <trans-unit id="26291a7cd459e196bf1c635f5e136cb0085033bb" translate="yes" xml:space="preserve">
          <source>The string is inserted literally.</source>
          <target state="translated">该字符串是按字面意思插入的。</target>
        </trans-unit>
        <trans-unit id="c1cb47cdeee50f6839e7f1b4e7667115d1fdbb0c" translate="yes" xml:space="preserve">
          <source>The string or comment start position. While inside a comment, this is the position where the comment began; while inside a string, this is the position where the string began. When outside of strings and comments, this element is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">字符串或注释的起始位置。在评论内部，这是评论开始的位置；在字符串内部时，这是字符串开始的位置。在字符串和注释之外时，此元素为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ad211627a8eba28dd5ef9816837befb4643331" translate="yes" xml:space="preserve">
          <source>The string that this function returns is what is recorded in the symbolic link; it may or may not include any leading directories. This function does &lt;em&gt;not&lt;/em&gt; expand the link target to produce a fully-qualified file name, and in particular does not use the leading directories, if any, of the &lt;var&gt;filename&lt;/var&gt; argument if the link target is not an absolute file name. Here&amp;rsquo;s an example:</source>
          <target state="translated">该函数返回的字符串是符号链接中记录的内容；它可能包含也可能不包含任何前导目录。此功能&lt;em&gt;不会&lt;/em&gt;扩展链接目标产生一个完全合格的文件名，特别是不使用领先的目录，如果有的话，的 &lt;var&gt;filename&lt;/var&gt; ，如果链接目标是不是一个绝对的文件名参数。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="ed696d53e7ac7bcc7d08d01175d6eb89bf0c571f" translate="yes" xml:space="preserve">
          <source>The string to be completed.</source>
          <target state="translated">要完成的字符串。</target>
        </trans-unit>
        <trans-unit id="07cf4d672d43fc0025d53260f62ef95ec1c50b45" translate="yes" xml:space="preserve">
          <source>The string which was clicked on, including any properties.</source>
          <target state="translated">被点击的字符串,包括任何属性。</target>
        </trans-unit>
        <trans-unit id="9e01c44c700489e51d428a65abb3864ced471545" translate="yes" xml:space="preserve">
          <source>The strings are compared by the numeric values of their characters. For instance, &lt;var&gt;str1&lt;/var&gt; is considered less than &lt;var&gt;str2&lt;/var&gt; if its first differing character has a smaller numeric value. If &lt;var&gt;ignore-case&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, characters are converted to upper-case before comparing them. Unibyte strings are converted to multibyte for comparison (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;), so that a unibyte string and its conversion to multibyte are always regarded as equal.</source>
          <target state="translated">字符串将通过其字符的数值进行比较。例如，如果 &lt;var&gt;str2&lt;/var&gt; 的第一个不同字符具有较小的数值，则认为 &lt;var&gt;str1&lt;/var&gt; 小于str2。如果 &lt;var&gt;ignore-case&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则在比较字符之前将其转换为大写字母。将单字节字符串转换为多字节以进行比较（请参阅&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;文本表示形式&lt;/a&gt;），因此单字节字符串及其转换为多字节始终被视为相等。</target>
        </trans-unit>
        <trans-unit id="44b6399fd6b44ca0035a1f2fc79dfcc1e1445a5f" translate="yes" xml:space="preserve">
          <source>The strings in &lt;var&gt;list-of-strings&lt;/var&gt; that need quoting are those that include &lt;var&gt;separator&lt;/var&gt; as their substring. Quoting a string encloses it in double quotes &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt;. In the simplest case, if you are consing a command from the individual command-line arguments, every argument that includes embedded blanks will be quoted.</source>
          <target state="translated">字符串 &lt;var&gt;list-of-strings&lt;/var&gt; 中需要引用的字符串是那些包含 &lt;var&gt;separator&lt;/var&gt; 作为其子字符串的字符串。用字符串引号将其括在双引号 &lt;code&gt;&quot;&amp;hellip;&quot;&lt;/code&gt; 。在最简单的情况下，如果您要从各个命令行参数中选择一个命令，则将引用每个包含嵌入式空格的参数。</target>
        </trans-unit>
        <trans-unit id="6eb3410ffb193ecb3bb6cdb461cdb85ed0d15602" translate="yes" xml:space="preserve">
          <source>The strings matching the first nine grouping constructs appearing in the entire regular expression passed to a search or matching function are assigned numbers 1 through 9 in the order that the open parentheses appear in the regular expression. So you can use &amp;lsquo;</source>
          <target state="translated">匹配出现在传递给搜索或匹配函数的整个正则表达式中的前九个分组构造的字符串，其编号以1到9的顺序分配，以使开括号出现在正则表达式中。因此您可以使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d581c2599c93c8f407b1007bbe2ce48ba6714abb" translate="yes" xml:space="preserve">
          <source>The subprocess inherits its environment from Emacs, but you can specify overrides for it with &lt;code&gt;process-environment&lt;/code&gt;. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. The subprocess gets its current directory from the value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">子 &lt;code&gt;process-environment&lt;/code&gt; 从Emacs继承其环境，但是您可以使用process-environment为其指定替代。请参阅&lt;a href=&quot;system-environment#System-Environment&quot;&gt;系统环境&lt;/a&gt;。子进程从 &lt;code&gt;default-directory&lt;/code&gt; 的值获取其当前目录。</target>
        </trans-unit>
        <trans-unit id="36e61db0284478d461aa89c79eac1cab50f7a0e0" translate="yes" xml:space="preserve">
          <source>The substitutions performed by &amp;lsquo;</source>
          <target state="translated">由'执行的替换</target>
        </trans-unit>
        <trans-unit id="8b19565b999d7f6150d2a072214b083a7f92bdb0" translate="yes" xml:space="preserve">
          <source>The subtype controls the number of &lt;em&gt;extra slots&lt;/em&gt; in the char-table. This number is specified by the subtype&amp;rsquo;s &lt;code&gt;char-table-extra-slots&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;), whose value should be an integer between 0 and 10. If the subtype has no such symbol property, the char-table has no extra slots.</source>
          <target state="translated">子类型控制字符表中&lt;em&gt;额外插槽&lt;/em&gt;的数量。此数字由子类型的 &lt;code&gt;char-table-extra-slots&lt;/code&gt; 符号属性（请参见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol属性&lt;/a&gt;）指定，其值应为0到10之间的整数。如果子类型没有这样的symbol属性，则char表没有额外的插槽。</target>
        </trans-unit>
        <trans-unit id="3b7c16dd882ba705b433c0230563b93def38601b" translate="yes" xml:space="preserve">
          <source>The subtype provides an easy way to tell what the char-table is for. For instance, display tables are char-tables with &lt;code&gt;display-table&lt;/code&gt; as the subtype, and syntax tables are char-tables with &lt;code&gt;syntax-table&lt;/code&gt; as the subtype. The subtype can be queried using the function &lt;code&gt;char-table-subtype&lt;/code&gt;, described below.</source>
          <target state="translated">子类型提供了一种简单的方法来判断char表的用途。例如，显示表是将 &lt;code&gt;display-table&lt;/code&gt; 作为子类型的char表， &lt;code&gt;syntax-table&lt;/code&gt; 是将语法表作为子类型的char表。可以使用下面描述的功能 &lt;code&gt;char-table-subtype&lt;/code&gt; 来查询该子类型。</target>
        </trans-unit>
        <trans-unit id="68ac4cd83ea417c1f7f9af452e5cc5b822c521ce" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;utime&lt;/code&gt; and &lt;code&gt;stime&lt;/code&gt;. The corresponding &lt;var&gt;value&lt;/var&gt; is a Lisp timestamp.</source>
          <target state="translated">&lt;code&gt;utime&lt;/code&gt; 和 &lt;code&gt;stime&lt;/code&gt; 之和。相应的 &lt;var&gt;value&lt;/var&gt; Lisp时间戳记。</target>
        </trans-unit>
        <trans-unit id="d35712cec496be81a5cc381ab6d618570491eb43" translate="yes" xml:space="preserve">
          <source>The super modifier.</source>
          <target state="translated">超级修改器。</target>
        </trans-unit>
        <trans-unit id="8e705c61a14589689176e3b34a3649287549f965" translate="yes" xml:space="preserve">
          <source>The sweep phase puts unused cons cells onto a &lt;em&gt;free list&lt;/em&gt; for future allocation; likewise for symbols and markers. It compacts the accessible strings so they occupy fewer 8k blocks; then it frees the other 8k blocks. Unreachable vectors from vector blocks are coalesced to create largest possible free areas; if a free area spans a complete 4k block, that block is freed. Otherwise, the free area is recorded in a free list array, where each entry corresponds to a free list of areas of the same size. Large vectors, buffers, and other large objects are allocated and freed individually.</source>
          <target state="translated">扫描阶段将未使用的cons单元放到&lt;em&gt;空闲列表中&lt;/em&gt;以供将来分配；同样适用于符号和标记。它压缩可访问的字符串，以便它们占用更少的8k块；然后释放其他8k块。向量块中无法到达的向量被合并以创建最大可能的自由区域；如果空闲区域跨越一个完整的4k块，则释放该块。否则，将空闲区域记录在空闲列表数组中，其中每个条目对应于相同大小的区域的空闲列表。大型向量，缓冲区和其他大型对象是分别分配和释放的。</target>
        </trans-unit>
        <trans-unit id="80c81c27e3f0ac4ab84d01b9b6f0b0331d39a84e" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;-&lt;/code&gt;. This indicates that</source>
          <target state="translated">符号 &lt;code&gt;-&lt;/code&gt; 。这表明</target>
        </trans-unit>
        <trans-unit id="d524cc19731a4d7319fdb32e1fd42c2468c1ccdb" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;undefined&lt;/code&gt; is worth special mention: it means to treat the key as undefined. Strictly speaking, the key is defined, and its binding is the command &lt;code&gt;undefined&lt;/code&gt;; but that command does the same thing that is done automatically for an undefined key: it rings the bell (by calling &lt;code&gt;ding&lt;/code&gt;) but does not signal an error.</source>
          <target state="translated">值得特别提及的是 &lt;code&gt;undefined&lt;/code&gt; 符号：这意味着将密钥视为undefined。严格来说，键是定义的，其绑定是命令 &lt;code&gt;undefined&lt;/code&gt; ；但是该命令执行的操作与自动为未定义的键执行的操作相同：它会响铃（通过调用 &lt;code&gt;ding&lt;/code&gt; ），但不会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="262aaa6e5851917f322ee907187b949e88c9ea3d" translate="yes" xml:space="preserve">
          <source>The symbol &lt;var&gt;var&lt;/var&gt; was defined as a variable.</source>
          <target state="translated">符号 &lt;var&gt;var&lt;/var&gt; 被定义为变量。</target>
        </trans-unit>
        <trans-unit id="5b0a7c1e7a600f3ceec6a0c096061763b149143e" translate="yes" xml:space="preserve">
          <source>The symbol must have an Edebug specification, which is used instead. This indirection is repeated until another kind of specification is found. This allows you to inherit the specification from another macro.</source>
          <target state="translated">符号必须有一个Edebug规范,它被用来代替。这种间接性是重复的,直到找到另一种规范。这允许你从另一个宏中继承规范。</target>
        </trans-unit>
        <trans-unit id="6db9e28485fd698ef52d7e3eb3a2773fea9702ff" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s current value as a variable.</source>
          <target state="translated">符号的当前值作为变量。</target>
        </trans-unit>
        <trans-unit id="a0a66fbe0304b2b0365a8eb85d918232ae7d5a27" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s function definition. It can also hold a symbol, a keymap, or a keyboard macro.</source>
          <target state="translated">符号的功能定义。它还可以包含符号，键映射或键盘宏。</target>
        </trans-unit>
        <trans-unit id="116bb8f437931ac9fdc82686fd01e5886bbdad99" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s name.</source>
          <target state="translated">符号的名称。</target>
        </trans-unit>
        <trans-unit id="4815883f12f3ddda91c2ff86c5cf8ead169410ab" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s property list.</source>
          <target state="translated">符号的属性列表。</target>
        </trans-unit>
        <trans-unit id="0da588e9c066744bf4c6e6a6cdf66d1b7de2d7a2" translate="yes" xml:space="preserve">
          <source>The symbol&amp;rsquo;s value is used.</source>
          <target state="translated">使用符号的值。</target>
        </trans-unit>
        <trans-unit id="4757d314ae2103a000ffd713b4431bdf90047a13" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are treated specially, so that the value of &lt;code&gt;nil&lt;/code&gt; is always &lt;code&gt;nil&lt;/code&gt;, and the value of &lt;code&gt;t&lt;/code&gt; is always &lt;code&gt;t&lt;/code&gt;; you cannot set or bind them to any other values. Thus, these two symbols act like self-evaluating forms, even though &lt;code&gt;eval&lt;/code&gt; treats them like any other symbol. A symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">符号 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 经过特殊处理，因此 &lt;code&gt;nil&lt;/code&gt; 的值始终为 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 的值始终为 &lt;code&gt;t&lt;/code&gt; ；您不能将它们设置或绑定到任何其他值。因此，尽管 &lt;code&gt;eval&lt;/code&gt; 像对待其他任何符号一样对待这两个符号，但它们的行为就像自我评估形式。名称以'开头的符号</target>
        </trans-unit>
        <trans-unit id="f0a7fe54d498086e0224f1254ce0302e2d45b30e" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;user-login-name&lt;/code&gt;, &lt;code&gt;user-real-login-name&lt;/code&gt; and &lt;code&gt;user-full-name&lt;/code&gt; are variables as well as functions. The functions return the same values that the variables hold. These variables allow you to fake out Emacs by telling the functions what to return. The variables are also useful for constructing frame titles (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;).</source>
          <target state="translated">符号 &lt;code&gt;user-login-name&lt;/code&gt; ， &lt;code&gt;user-real-login-name&lt;/code&gt; 和 &lt;code&gt;user-full-name&lt;/code&gt; 是变量以及函数。函数返回的值与变量的值相同。这些变量允许您通过告诉函数返回什么来伪造Emacs。变量对于构造框架标题也很有用（请参阅&lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;框架标题&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0804f73f2468d63be3d44abb01edffb59c0ad975" translate="yes" xml:space="preserve">
          <source>The synchronous subprocess functions return an indication of how the process terminated.</source>
          <target state="translated">同步子进程函数返回进程如何终止的指示。</target>
        </trans-unit>
        <trans-unit id="42db7ccb5bf39d0ef36aec66fdcf39beff2dbdf3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; is invalid because there is nothing that it could mean. If anything, it would say to put &lt;code&gt;buttercup&lt;/code&gt; in the &lt;small&gt;CDR&lt;/small&gt; of a cons cell whose &lt;small&gt;CDR&lt;/small&gt; is already used for &lt;code&gt;violet&lt;/code&gt;.</source>
          <target state="translated">语法 &lt;code&gt;(rose . violet . buttercup)&lt;/code&gt; 无效，因为它没有任何含义。如果有的话，它会说把 &lt;code&gt;buttercup&lt;/code&gt; 在&lt;small&gt;CDR&lt;/small&gt;一个cons单元，其的&lt;small&gt;CDR&lt;/small&gt;已用于 &lt;code&gt;violet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cab7667e7d8ac62d20cdad9ef7c79cda38e5bc22" translate="yes" xml:space="preserve">
          <source>The syntax for integers in bases other than 10 consists of &amp;lsquo;</source>
          <target state="translated">以10为底的整数的语法由'</target>
        </trans-unit>
        <trans-unit id="88b43371f5f28d88c8b06cc0133c5c8be8a7772e" translate="yes" xml:space="preserve">
          <source>The syntax is changed only for &lt;var&gt;table&lt;/var&gt;, which defaults to the current buffer&amp;rsquo;s syntax table, and not in any other syntax table.</source>
          <target state="translated">仅对 &lt;var&gt;table&lt;/var&gt; 更改语法，该表默认为当前缓冲区的语法表，而在其他任何语法表中均​​不更改。</target>
        </trans-unit>
        <trans-unit id="239ff1bb3df2ca92e1729acd450422ea90926247" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;EMACSLOADPATH&lt;/code&gt; is the same as used for &lt;code&gt;PATH&lt;/code&gt;; directories are separated by &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;EMACSLOADPATH&lt;/code&gt; 的语法与 &lt;code&gt;PATH&lt;/code&gt; 相同；目录之间用'</target>
        </trans-unit>
        <trans-unit id="1999b037e6c53b71c64122a6e2bea19301ea2ee4" translate="yes" xml:space="preserve">
          <source>The syntax of format specifications accepted by &lt;code&gt;format-spec&lt;/code&gt; is similar, but not identical, to that accepted by &lt;code&gt;format&lt;/code&gt;. In both cases, a format specification is a sequence of characters beginning with &amp;lsquo;</source>
          <target state="translated">通过接受格式规范的语法 &lt;code&gt;format-spec&lt;/code&gt; 类似，但不完全相同，通过接受的 &lt;code&gt;format&lt;/code&gt; 。在这两种情况下，格式规范都是以'开头的字符序列</target>
        </trans-unit>
        <trans-unit id="a7719f40601bdc59c72de428210fe56812c73911" translate="yes" xml:space="preserve">
          <source>The syntax table controls the interpretation of characters, so these functions can be used for Lisp expressions when in Lisp mode and for C expressions when in C mode. See &lt;a href=&quot;list-motion#List-Motion&quot;&gt;List Motion&lt;/a&gt;, for convenient higher-level functions for moving over balanced expressions.</source>
          <target state="translated">语法表控制字符的解释，因此在Lisp模式下，这些函数可用于Lisp表达式；在C模式下，可用于C表达式。有关移动平衡表达式的便捷高级功能，请参见&lt;a href=&quot;list-motion#List-Motion&quot;&gt;List Motion&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d3dd35ac27520d192421173419189f92bfde5f7" translate="yes" xml:space="preserve">
          <source>The syntax table controls word and list parsing.</source>
          <target state="translated">语法表控制单词和列表的解析。</target>
        </trans-unit>
        <trans-unit id="1b828fe7a14532d3214216229166278069ec53be" translate="yes" xml:space="preserve">
          <source>The tab character (character code 9) displays as whitespace stretching up to the next tab stop column. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;Text Display&lt;/a&gt; in</source>
          <target state="translated">制表符（字符代码9）显示为空格，一直延伸到下一个制表符栏。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Text-Display.html#Text-Display&quot;&gt;文本显示&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="4cdb77457b03ae8e4189510caa2d2cd8affcf775" translate="yes" xml:space="preserve">
          <source>The tail of the list, &lt;var&gt;item-property-list&lt;/var&gt;, has the form of a property list which contains other information.</source>
          <target state="translated">列表的尾部 &lt;var&gt;item-property-list&lt;/var&gt; 具有包含其他信息的属性列表的形式。</target>
        </trans-unit>
        <trans-unit id="7527554605fcb9db76071476569c6f6b0cf4a1ce" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;function&lt;/em&gt; refers to all Emacs functions, whether written in Lisp or C. See &lt;a href=&quot;function-type#Function-Type&quot;&gt;Function Type&lt;/a&gt;, for information about the functions written in Lisp.</source>
          <target state="translated">术语&lt;em&gt;函数&lt;/em&gt;是指所有用Lisp或C编写的Emacs函数。有关用Lisp编写的&lt;a href=&quot;function-type#Function-Type&quot;&gt;函数&lt;/a&gt;的信息，请参见函数类型。</target>
        </trans-unit>
        <trans-unit id="bd8132ad5a485b9ab38224ae63509adce1e85797" translate="yes" xml:space="preserve">
          <source>The terminal and keyboard coding systems used on the terminal. See &lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;Terminal I/O Encoding&lt;/a&gt;.</source>
          <target state="translated">终端和终端上使用的键盘编码系统。请参阅&lt;a href=&quot;terminal-i_002fo-encoding#Terminal-I_002fO-Encoding&quot;&gt;终端I / O编码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ad03be7d14630f60e2cb6b2a4f58289b95b8877" translate="yes" xml:space="preserve">
          <source>The terminal output functions send output to a text terminal, or keep track of output sent to the terminal. The variable &lt;code&gt;baud-rate&lt;/code&gt; tells you what Emacs thinks is the output speed of the terminal.</source>
          <target state="translated">终端输出功能将输出发送到文本终端，或跟踪发送到终端的输出。可变的 &lt;code&gt;baud-rate&lt;/code&gt; 告诉您Emacs认为终端的输出速度。</target>
        </trans-unit>
        <trans-unit id="3a63395bf693f4ea5dbf2a2a8a31fd4771954d08" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;line height&lt;/em&gt; and &lt;em&gt;canonical character height&lt;/em&gt; are sometimes used instead of &amp;ldquo;default character height&amp;rdquo;. Similarly, the terms &lt;em&gt;column width&lt;/em&gt; and &lt;em&gt;canonical character width&lt;/em&gt; are used instead of &amp;ldquo;default character width&amp;rdquo;.</source>
          <target state="translated">有时使用术语&lt;em&gt;行高&lt;/em&gt;和&lt;em&gt;规范字符高度&lt;/em&gt;代替&amp;ldquo;默认字符高度&amp;rdquo;。类似地，使用术语&lt;em&gt;列宽&lt;/em&gt;和&lt;em&gt;规范字符宽度&lt;/em&gt;代替&amp;ldquo;默认字符宽度&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4e683c537d7a88f401925ed633251e10fa4e0d2a" translate="yes" xml:space="preserve">
          <source>The terms used herein, such as IV (Initialization Vector), require some familiarity with cryptography and will not be defined in detail. Please consult &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt; for specific documentation which may help you understand the terminology and structure of the GnuTLS library.</source>
          <target state="translated">本文中使用的术语（例如IV（初始化向量））需要对密码学有所了解，因此将不对其进行详细定义。请查阅&lt;a href=&quot;https://www.gnutls.org/&quot;&gt;https://www.gnutls.org/&lt;/a&gt;获取特定的文档，这些文档可以帮助您了解GnuTLS库的术语和结构。</target>
        </trans-unit>
        <trans-unit id="6650dc3f7c947a7cc0f8b1e2e8887236711ab190" translate="yes" xml:space="preserve">
          <source>The test for an existing file, when &lt;var&gt;mustbenew&lt;/var&gt; is &lt;code&gt;excl&lt;/code&gt;, uses a special system feature. At least for files on a local disk, there is no chance that some other program could create a file of the same name before Emacs does, without Emacs&amp;rsquo;s noticing.</source>
          <target state="translated">当 &lt;var&gt;mustbenew&lt;/var&gt; 为 &lt;code&gt;excl&lt;/code&gt; 时，对现有文件的测试使用特殊的系统功能。至少对于本地磁盘上的文件，如果没有Emacs的注意，其他程序就不可能在Emacs之前创建相同名称的文件。</target>
        </trans-unit>
        <trans-unit id="f4bec060d8606173e4510214d476948b1b689bd6" translate="yes" xml:space="preserve">
          <source>The text between point and the mark is known as &lt;em&gt;the region&lt;/em&gt;. Various functions operate on text delimited by point and the mark, but only those functions specifically related to the region itself are described here.</source>
          <target state="translated">点和标记之间的文本称为&lt;em&gt;区域&lt;/em&gt;。各种功能对由点和标记分隔的文本起作用，但是这里仅描述那些专门与区域本身相关的功能。</target>
        </trans-unit>
        <trans-unit id="427235673649693cef34eec5a1c49c535c367214" translate="yes" xml:space="preserve">
          <source>The text in the minibuffer always starts with the &lt;em&gt;prompt string&lt;/em&gt;, the text that was specified by the program that is using the minibuffer to tell the user what sort of input to type. This text is marked read-only so you won&amp;rsquo;t accidentally delete or change it. It is also marked as a field (see &lt;a href=&quot;fields#Fields&quot;&gt;Fields&lt;/a&gt;), so that certain motion functions, including &lt;code&gt;beginning-of-line&lt;/code&gt;, &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;forward-sentence&lt;/code&gt;, and &lt;code&gt;forward-paragraph&lt;/code&gt;, stop at the boundary between the prompt and the actual text.</source>
          <target state="translated">迷你缓冲区中的文本始终以&lt;em&gt;提示字符串&lt;/em&gt;开头，&lt;em&gt;提示字符串&lt;/em&gt;是使用迷你缓冲区告诉用户要键入哪种输入的程序所指定的文本。该文本被标记为只读，因此您不会意外删除或更改它。它也被标记为一个字段（请参见&lt;a href=&quot;fields#Fields&quot;&gt;Fields&lt;/a&gt;），以便某些运动功能（包括 &lt;code&gt;beginning-of-line&lt;/code&gt; ， &lt;code&gt;forward-word&lt;/code&gt; ， &lt;code&gt;forward-sentence&lt;/code&gt; 和 &lt;code&gt;forward-paragraph&lt;/code&gt; ）停在提示和实际文本之间的边界处。</target>
        </trans-unit>
        <trans-unit id="e254c01685b37e41ab942a41fbf59829e6d11ec6" translate="yes" xml:space="preserve">
          <source>The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. This includes the text properties as well as the characters themselves.</source>
          <target state="translated">间接缓冲区的文本总是与基础缓冲区的文本相同;通过编辑任何一个缓冲区所做的更改都会在另一个缓冲区中立即可见。这包括文本属性和字符本身。</target>
        </trans-unit>
        <trans-unit id="af246ddc000534af5859563e36f5153516e93316" translate="yes" xml:space="preserve">
          <source>The text properties &lt;code&gt;front-sticky&lt;/code&gt; and &lt;code&gt;rear-nonsticky&lt;/code&gt;, when used, take precedence over the default &lt;var&gt;nonstickiness&lt;/var&gt; specified in &lt;code&gt;text-property-default-nonsticky&lt;/code&gt;.</source>
          <target state="translated">文本属性 &lt;code&gt;front-sticky&lt;/code&gt; 和 &lt;code&gt;rear-nonsticky&lt;/code&gt; ，当使用时，优先于默认 &lt;var&gt;nonstickiness&lt;/var&gt; 在指定 &lt;code&gt;text-property-default-nonsticky&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61de37a77d48c5a03418142f4c57cbd435c8202a" translate="yes" xml:space="preserve">
          <source>The text properties in &lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; are applied to the prompt. By default, this property list defines a face to use for the prompt. This face, if present, is applied to the end of the face list and merged before display.</source>
          <target state="translated">&lt;code&gt;minibuffer-prompt-properties&lt;/code&gt; 中的文本属性将应用于提示。默认情况下，此属性列表定义用于提示的面孔。该面部（如果存在）将应用于面部列表的末尾，并在显示之前合并。</target>
        </trans-unit>
        <trans-unit id="53d1c0b3638f705814caf89c18a7ce3da885e071" translate="yes" xml:space="preserve">
          <source>The text size of any frame can be set and retrieved with the help of the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; frame parameters (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). The text size of the initial frame can be also set with the help of an X-style geometry specification. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;Command Line Arguments for Emacs Invocation&lt;/a&gt; in</source>
          <target state="translated">可以使用 &lt;code&gt;height&lt;/code&gt; 和 &lt;code&gt;width&lt;/code&gt; 框架参数（请参阅&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;）来设置和检索任何框架的文本大小。也可以借助X样式的几何规范来设置初始框架的文本大小。请参阅&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Invocation.html#Emacs-Invocation&quot;&gt;中的Emacs调用的命令行参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c67ee1668cafc5069fd19fd9ac4ce5d1dfafd95a" translate="yes" xml:space="preserve">
          <source>The text&amp;rsquo;s start position in the buffer.</source>
          <target state="translated">文本在缓冲区中的开始位置。</target>
        </trans-unit>
        <trans-unit id="459ecfaa7406a56efb8cf84eab33df64259674fe" translate="yes" xml:space="preserve">
          <source>The third argument &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to preserve the modification time of the copied files. A prefix arg makes &lt;var&gt;keep-time&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">第三个参数 &lt;var&gt;keep-time&lt;/var&gt; 不 &lt;code&gt;nil&lt;/code&gt; 手段来维护复制的文件的修改时间。前缀ARG品牌 &lt;var&gt;keep-time&lt;/var&gt; 不 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da9ba46202c97f906aff04419daf0a2467b172a5" translate="yes" xml:space="preserve">
          <source>The third element is the window selected at the time the parameter was created. If this function deletes &lt;var&gt;window&lt;/var&gt;, it subsequently tries to reselect the window named by that element.</source>
          <target state="translated">第三个元素是在创建参数时选择的窗口。如果此函数删除 &lt;var&gt;window&lt;/var&gt; ，则它随后尝试重新选择该元素命名的窗口。</target>
        </trans-unit>
        <trans-unit id="290b74a62fe3a2fe85d724d61465dc891525fd6f" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;case-fold&lt;/var&gt;, specifies the value of &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt;. If it is non-&lt;code&gt;nil&lt;/code&gt;, Font Lock mode ignores case during search-based fontification.</source>
          <target state="translated">第三个元素 &lt;var&gt;case-fold&lt;/var&gt; 指定 &lt;code&gt;font-lock-keywords-case-fold-search&lt;/code&gt; 的值。如果它不是 &lt;code&gt;nil&lt;/code&gt; ，则在基于搜索的字体化期间，字体锁定模式将忽略大小写。</target>
        </trans-unit>
        <trans-unit id="a0049f036ce91322d4b97e568763827ed24c4fa6" translate="yes" xml:space="preserve">
          <source>The third element, &lt;var&gt;real-binding&lt;/var&gt;, can be the command to execute (in which case you get a normal menu item). It can also be a keymap, which will result in a submenu. Finally, it can be &lt;code&gt;nil&lt;/code&gt;, in which case you will get a non-selectable menu item. This is mostly useful when creating separator lines and the like.</source>
          <target state="translated">第三个元素 &lt;var&gt;real-binding&lt;/var&gt; 可以是要执行的命令（在这种情况下，您将获得一个普通的菜单项）。它也可以是一个键盘映射，这将导致一个子菜单。最后，它可以是 &lt;code&gt;nil&lt;/code&gt; ，在这种情况下，您将获得一个不可选择的菜单项。这在创建分隔线等时非常有用。</target>
        </trans-unit>
        <trans-unit id="5ded74e35ae11b189414eb3a2feeeaf0372642b2" translate="yes" xml:space="preserve">
          <source>The third of these hooks is run when a &lt;em&gt;window selection change&lt;/em&gt; has selected another window since the last redisplay.</source>
          <target state="translated">自上次重新显示以来，当&lt;em&gt;窗口选择更改&lt;/em&gt;选择了另一个窗口时，将运行这些挂钩中的第三个。</target>
        </trans-unit>
        <trans-unit id="c89651a099ca91af6c8a8b83f402ae4da806d1ff" translate="yes" xml:space="preserve">
          <source>The third part of the pattern matches the whitespace that follows the end of a sentence: the end of a line (optionally with a space), or a tab, or two spaces. The double backslashes mark the parentheses and vertical bars as regular expression syntax; the parentheses delimit a group and the vertical bars separate alternatives. The dollar sign is used to match the end of a line.</source>
          <target state="translated">模式的第三部分与句子末尾的空白相匹配:一行的末尾(可选择用空格),或一个制表符,或两个空格。双反斜杠标志着括号和竖条,作为正则表达式语法;括号限定了一个组,竖条分隔了备选方案。美元符号用于匹配行尾。</target>
        </trans-unit>
        <trans-unit id="607c3d642b7b987d71b42da79930af648e956246" translate="yes" xml:space="preserve">
          <source>The three Lisp modes (Lisp mode, Emacs Lisp mode, and Lisp Interaction mode) have more features than Text mode and the code is correspondingly more complicated. Here are excerpts from</source>
          <target state="translated">三种Lisp模式(Lisp模式、Emacs Lisp模式、Lisp交互模式)比Text模式的功能更多,代码也相应更复杂。以下是节选的内容</target>
        </trans-unit>
        <trans-unit id="45ee5df28937c07f3548f70fd6cc8c94bf25c3ce" translate="yes" xml:space="preserve">
          <source>The three modes for Lisp share much of their code. For instance, each calls the following function to set various variables:</source>
          <target state="translated">Lisp的三种模式共享它们的大部分代码。例如,每种模式都调用以下函数来设置各种变量。</target>
        </trans-unit>
        <trans-unit id="54870091d56fd5e724ee385ddc157eb207f13d76" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, as an integer number of milliseconds since a system-dependent initial time.</source>
          <target state="translated">事件发生的时间,为系统初始时间后的整数毫秒。</target>
        </trans-unit>
        <trans-unit id="1ebfb539c64783c4344442794aee02ad7006a6f2" translate="yes" xml:space="preserve">
          <source>The time at which the event occurred, in milliseconds. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">事件发生的时间（以毫秒为单位）。在某些工具包（包括GTK +）上，Emacs无法提取此数据，因此该值始终为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98e57126dedf2d6400ffdfdef20aa57a4ca36ef3" translate="yes" xml:space="preserve">
          <source>The time elapsed since the process started, as a Lisp timestamp.</source>
          <target state="translated">进程开始后经过的时间,作为Lisp时间戳。</target>
        </trans-unit>
        <trans-unit id="00b925b3b99613c5ebaf63a3e99e731129a59a23" translate="yes" xml:space="preserve">
          <source>The time of last access as a Lisp timestamp (&lt;code&gt;file-attribute-access-time&lt;/code&gt;). The timestamp is in the style of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;) and is truncated to that of the filesystem&amp;rsquo;s timestamp resolution; for example, on some FAT-based filesystems, only the date of last access is recorded, so this time will always hold the midnight of the day of the last access.</source>
          <target state="translated">最后一次访问的时间（以Lisp时间戳记）（ &lt;code&gt;file-attribute-access-time&lt;/code&gt; ）。时间戳的格式为 &lt;code&gt;current-time&lt;/code&gt; （请参阅&lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;&amp;ldquo;每日时间&amp;rdquo;&lt;/a&gt;），并被截断为文件系统的时间戳分辨率；例如，在某些基于FAT的文件系统上，仅记录了上次访问的日期，因此该时间将始终保留上次访问的当天的午夜。</target>
        </trans-unit>
        <trans-unit id="96f255ff11207f96a6ff4be345f0df83a02d827c" translate="yes" xml:space="preserve">
          <source>The time of last modification as a Lisp timestamp (&lt;code&gt;file-attribute-modification-time&lt;/code&gt;). This is the last time when the file&amp;rsquo;s contents were modified.</source>
          <target state="translated">上次修改的时间，作为Lisp时间戳（ &lt;code&gt;file-attribute-modification-time&lt;/code&gt; ）。这是上次修改文件内容的时间。</target>
        </trans-unit>
        <trans-unit id="7647d2bb474bf5d47880005e9fa4aa2091b44379" translate="yes" xml:space="preserve">
          <source>The time of last status change as a Lisp timestamp (&lt;code&gt;file-attribute-status-change-time&lt;/code&gt;). This is the time of the last change to the file&amp;rsquo;s access mode bits, its owner and group, and other information recorded in the filesystem for the file, beyond the file&amp;rsquo;s contents.</source>
          <target state="translated">最后状态更改的时间为Lisp时间戳（ &lt;code&gt;file-attribute-status-change-time&lt;/code&gt; ）。这是文件访问模式位，其所有者和组以及文件内容中文件系统中记录的其他信息的最后更改时间。</target>
        </trans-unit>
        <trans-unit id="24c20ed315222312a2625d91bebf7c20d8b009b0" translate="yes" xml:space="preserve">
          <source>The time to use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; is when it is crucial that no two buffers ever share the same binding. For example, when a variable is used for internal purposes in a Lisp program which depends on having separate values in separate buffers, then using &lt;code&gt;make-variable-buffer-local&lt;/code&gt; can be the best solution.</source>
          <target state="translated">使用 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 的时机是至关重要的，此时两个缓冲区永远不能共享相同的绑定。例如，当一个变量在Lisp程序中用于内部目的时，该变量依赖于在单独的缓冲区中具有单独的值，那么使用 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 是最好的解决方案。</target>
        </trans-unit>
        <trans-unit id="c627015afbabd38bf35740a5ee9f2c3cb23dc48d" translate="yes" xml:space="preserve">
          <source>The time when the buffer was last auto-saved.</source>
          <target state="translated">缓冲区最后一次自动保存的时间。</target>
        </trans-unit>
        <trans-unit id="1e0d0c1f4808016965104728546b5791c182f028" translate="yes" xml:space="preserve">
          <source>The time when the process was started, as a Lisp timestamp.</source>
          <target state="translated">进程启动的时间,作为Lisp时间戳。</target>
        </trans-unit>
        <trans-unit id="802393edc2b9a42653a80bc4d4ec3e5e5f24f1f4" translate="yes" xml:space="preserve">
          <source>The timeout time in milliseconds since the display of the notification at which the notification should automatically close. If -1, the notification&amp;rsquo;s expiration time is dependent on the notification server&amp;rsquo;s settings, and may vary for the type of notification. If 0, the notification never expires. Default value is -1.</source>
          <target state="translated">自通知显示以来的超时时间（以毫秒为单位），通知应在该时间后自动关闭。如果为-1，则通知的到期时间取决于通知服务器的设置，并且随通知类型的不同而不同。如果为0，则通知永不过期。默认值为-1。</target>
        </trans-unit>
        <trans-unit id="5f4688992c1cae810c4b2847d1acc4a25d6a81f0" translate="yes" xml:space="preserve">
          <source>The title (only on a window system) or the name of the selected frame. See &lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;Basic Parameters&lt;/a&gt;.</source>
          <target state="translated">标题（仅在窗口系统上）或所选框架的名称。请参阅&lt;a href=&quot;basic-parameters#Basic-Parameters&quot;&gt;基本参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00a751eb6540114fecfd6321e7957f9e5fe58259" translate="yes" xml:space="preserve">
          <source>The title of the notification. If &lt;var&gt;title&lt;/var&gt; is a string, it is displayed in a larger font immediately above the body text. The title text can be up to 63 characters long; longer text will be truncated.</source>
          <target state="translated">通知的标题。如果 &lt;var&gt;title&lt;/var&gt; 是字符串，则将在正文文本上方以较大的字体显示它。标题文字最多可以包含63个字符。较长的文本将被截断。</target>
        </trans-unit>
        <trans-unit id="fb5b566b508b98eab0c7c5b9ce2a802059ff0fbe" translate="yes" xml:space="preserve">
          <source>The toggle command takes one optional (prefix) argument. If called interactively with no argument it toggles the mode on or off. A positive prefix argument enables the mode, any other prefix argument disables it. From Lisp, an argument of &lt;code&gt;toggle&lt;/code&gt; toggles the mode, whereas an omitted or &lt;code&gt;nil&lt;/code&gt; argument enables the mode. This makes it easy to enable the minor mode in a major mode hook, for example. If &lt;var&gt;doc&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the macro supplies a default documentation string explaining the above.</source>
          <target state="translated">toggle命令采用一个可选的（前缀）参数。如果不带任何参数以交互方式调用，则将打开或关闭模式。正前缀参数启用该模式，任何其他前缀参数均禁用该模式。在Lisp中， &lt;code&gt;toggle&lt;/code&gt; 参数可切换模式，而省略或 &lt;code&gt;nil&lt;/code&gt; 参数可启用模式。例如，这使在主模式挂钩中启用次模式变得容易。如果 &lt;var&gt;doc&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则宏将提供解释上述内容的默认文档字符串。</target>
        </trans-unit>
        <trans-unit id="ee396be1bc2edeec5a010e520887af01b2c0ec1a" translate="yes" xml:space="preserve">
          <source>The tool bar contents are controlled by a menu keymap attached to a fake function key called</source>
          <target state="translated">工具栏的内容由一个附加在假功能键上的菜单键图控制,该键称为</target>
        </trans-unit>
        <trans-unit id="c8e2bf3f449141de6022307bd19ac291ae6a42dd" translate="yes" xml:space="preserve">
          <source>The top edge of the window, measured in lines, relative to the topmost line (line 0) of the window&amp;rsquo;s native frame.</source>
          <target state="translated">窗口的上边缘，以线条为单位，相对于窗口本机框架的最上一行（第0行）。</target>
        </trans-unit>
        <trans-unit id="80ecb166938baeaaabb20112d9fe96a939c773d4" translate="yes" xml:space="preserve">
          <source>The top level variable, mode-line-format.</source>
          <target state="translated">顶层变量,模线格式。</target>
        </trans-unit>
        <trans-unit id="10fcd8fbdfa1f56f99b62be921ede3801375f31b" translate="yes" xml:space="preserve">
          <source>The top-level forms in the file defining the mode should be written so that they may be evaluated more than once without adverse consequences. For instance, use &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defcustom&lt;/code&gt; to set mode-related variables, so that they are not reinitialized if they already have a value (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;).</source>
          <target state="translated">应该编写定义模式的文件中的顶级表单，以便可以对它们进行多次评估而不会产生不利影响。例如，使用 &lt;code&gt;defvar&lt;/code&gt; 或 &lt;code&gt;defcustom&lt;/code&gt; 来设置与模式相关的变量，这样，如果它们已经具有值，就不会重新初始化它们（请参阅&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;定义变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e0bf6b79b51361600ab0d2d09d4929d9f08d380a" translate="yes" xml:space="preserve">
          <source>The total height of each display line consists of the height of the contents of the line, plus optional additional vertical line spacing above or below the display line.</source>
          <target state="translated">每个显示行的总高度由行内内容的高度,加上显示行上方或下方可选的额外垂直行距组成。</target>
        </trans-unit>
        <trans-unit id="31d0e82b6a88e74d0b24a216385d5fc85a5cec98" translate="yes" xml:space="preserve">
          <source>The total length, in pixels, of the scroll bar. On some toolkits, including GTK+, Emacs cannot extract this data, so the value is always &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">滚动条的总长度（以像素为单位）。在某些工具包（包括GTK +）上，Emacs无法提取此数据，因此该值始终为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b25cf92e537fbc457f73f8b8ccd34da35b4b1e0f" translate="yes" xml:space="preserve">
          <source>The total number of cons cells that have been allocated so far in this Emacs session.</source>
          <target state="translated">在这个Emacs会话中,到目前为止已经分配的cons单元的总数。</target>
        </trans-unit>
        <trans-unit id="a994cddf9b826ab8c3b89d449d09ae2a9b73e706" translate="yes" xml:space="preserve">
          <source>The total number of floats that have been allocated so far in this Emacs session.</source>
          <target state="translated">在这个Emacs会话中,到目前为止已经分配的浮点数总数。</target>
        </trans-unit>
        <trans-unit id="fdcf07b9e5a059b00bbaae5593cd683d00025222" translate="yes" xml:space="preserve">
          <source>The total number of intervals that have been allocated so far in this Emacs session.</source>
          <target state="translated">在这个Emacs会话中,到目前为止已经分配的间隔总数。</target>
        </trans-unit>
        <trans-unit id="614654e18f37f5b5f422dea3bbdcbb3a165f297e" translate="yes" xml:space="preserve">
          <source>The total number of string characters that have been allocated so far in this session.</source>
          <target state="translated">本节课到目前为止已分配的字符串字符总数。</target>
        </trans-unit>
        <trans-unit id="abb717f47f8933d7923fb2b52cfb28bd464f36e9" translate="yes" xml:space="preserve">
          <source>The total number of strings that have been allocated so far in this Emacs session.</source>
          <target state="translated">在这个Emacs会话中,到目前为止已经分配的字符串总数。</target>
        </trans-unit>
        <trans-unit id="e9b8f06e1c94173e7b8d8a404718b1b724454813" translate="yes" xml:space="preserve">
          <source>The total number of symbols that have been allocated so far in this Emacs session.</source>
          <target state="translated">在这个Emacs会话中,到目前为止已经分配的符号总数。</target>
        </trans-unit>
        <trans-unit id="27a10a08d892e6a91c5cf07d46fe77aa2af1a3fa" translate="yes" xml:space="preserve">
          <source>The total number of vector cells that have been allocated so far in this Emacs session. This includes vector-like objects such as markers and overlays, plus certain objects not visible to users.</source>
          <target state="translated">迄今为止,在这个 Emacs 会话中已分配的向量单元的总数。这包括类似向量的对象,如标记和覆盖,以及某些用户不可见的对象。</target>
        </trans-unit>
        <trans-unit id="441a3e680eaafec796a9e2a7060e2a280535485a" translate="yes" xml:space="preserve">
          <source>The total size of all string data in bytes.</source>
          <target state="translated">所有字符串数据的总大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="c7d14b13c564dd0ff16404189a2b255627fffdf3" translate="yes" xml:space="preserve">
          <source>The total width and height of the window measured in pixels.</source>
          <target state="translated">窗口的总宽度和高度,以像素为单位。</target>
        </trans-unit>
        <trans-unit id="1ccf2de5b65512cde61e59a9ed444c1197414f54" translate="yes" xml:space="preserve">
          <source>The total width and height of the window, measured in columns and lines respectively. The values include scroll bars and fringes, dividers and/or the separator line on the right of the window (if any).</source>
          <target state="translated">窗口的总宽度和高度,分别以列和线为单位。该值包括滚动条和边缘、分隔线和/或窗口右侧的分隔线(如果有)。</target>
        </trans-unit>
        <trans-unit id="bc966a52b3595d2fcaff1f0ffe9ad07780edb9e3" translate="yes" xml:space="preserve">
          <source>The translation table &lt;var&gt;table&lt;/var&gt; is a string or a char-table; &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; gives the translated character corresponding to &lt;var&gt;ochar&lt;/var&gt;. If &lt;var&gt;table&lt;/var&gt; is a string, any characters with codes larger than the length of &lt;var&gt;table&lt;/var&gt; are not altered by the translation.</source>
          <target state="translated">该转换表 &lt;var&gt;table&lt;/var&gt; 是一个字符串或字符表; &lt;code&gt;(aref &lt;var&gt;table&lt;/var&gt; &lt;var&gt;ochar&lt;/var&gt;)&lt;/code&gt; 给出对应于 &lt;var&gt;ochar&lt;/var&gt; 的翻译后的字符。如果 &lt;var&gt;table&lt;/var&gt; 是一个字符串，则代码长度大于 &lt;var&gt;table&lt;/var&gt; 长度的任何字符都不会被转换更改。</target>
        </trans-unit>
        <trans-unit id="397c955cc662600cfb57e3c9c25331b73b22fe24" translate="yes" xml:space="preserve">
          <source>The two constructs described next are mostly identical to &lt;code&gt;with-temp-buffer-window&lt;/code&gt; but differ from it as specified:</source>
          <target state="translated">接下来描述的两个构造与 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 大部分相同，但是与指定的不同：</target>
        </trans-unit>
        <trans-unit id="04a05211cdc885470090771446510a238e8b75f7" translate="yes" xml:space="preserve">
          <source>The type &lt;var&gt;type&lt;/var&gt; was defined.</source>
          <target state="translated">类型 &lt;var&gt;type&lt;/var&gt; 已定义。</target>
        </trans-unit>
        <trans-unit id="9989a67db7c219bdacd778e97cc75a29828fcbdc" translate="yes" xml:space="preserve">
          <source>The type of connection. Options are:</source>
          <target state="translated">连接的类型。选项有:</target>
        </trans-unit>
        <trans-unit id="10723b34477adf1a54c090dcb75c1b850f7f8519" translate="yes" xml:space="preserve">
          <source>The type of flow control to use for this connection, which is either &lt;code&gt;nil&lt;/code&gt; (don&amp;rsquo;t use flow control), the symbol &lt;code&gt;hw&lt;/code&gt; (use RTS/CTS hardware flow control), or the symbol &lt;code&gt;sw&lt;/code&gt; (use XON/XOFF software flow control). If &lt;var&gt;flowcontrol&lt;/var&gt; is not given, it defaults to no flow control.</source>
          <target state="translated">用于此连接的流控制类型，可以为 &lt;code&gt;nil&lt;/code&gt; （不使用流控制），符号 &lt;code&gt;hw&lt;/code&gt; （使用RTS / CTS硬件流控制）或符号 &lt;code&gt;sw&lt;/code&gt; （使用XON / XOFF软件流控制） 。如果 &lt;var&gt;flowcontrol&lt;/var&gt; 没有给出，则默认为无流量控制。</target>
        </trans-unit>
        <trans-unit id="824546068f92ce5ea60e0deff376010de3e1fec4" translate="yes" xml:space="preserve">
          <source>The type of icon to use for this frame. If the value is a string, that specifies a file containing a bitmap to use; &lt;code&gt;nil&lt;/code&gt; specifies no icon (in which case the window manager decides what to show); any other non-&lt;code&gt;nil&lt;/code&gt; value specifies the default Emacs icon.</source>
          <target state="translated">用于此框架的图标类型。如果该值为字符串，则指定包含要使用的位图的文件；否则为false。 &lt;code&gt;nil&lt;/code&gt; 不指定图标（在这种情况下，窗口管理器决定要显示的内容）；其他任何非 &lt;code&gt;nil&lt;/code&gt; 值都指定默认的Emacs图标。</target>
        </trans-unit>
        <trans-unit id="77d40006d2d51026df28ce9827773f880edd24d6" translate="yes" xml:space="preserve">
          <source>The type of notification this is, a string. See the &lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;Desktop Notifications Specification&lt;/a&gt; for a list of standard categories.</source>
          <target state="translated">通知的类型，是一个字符串。有关标准类别的列表，请参见&lt;a href=&quot;https://developer.gnome.org/notification-spec/#categories&quot;&gt;桌面通知规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55bdf0d544649480b63a1172ccccf6ea3ae2d63d" translate="yes" xml:space="preserve">
          <source>The type slot should be a symbol or a type descriptor. If it&amp;rsquo;s a type descriptor, the symbol naming its type will be returned; &lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;Type Descriptors&lt;/a&gt;. Any other kind of object is returned as-is.</source>
          <target state="translated">类型插槽应为符号或类型描述符。如果是类型描述符，则将返回命名其类型的符号。&lt;a href=&quot;type-descriptors#Type-Descriptors&quot;&gt;类型描述符&lt;/a&gt;。其他任何类型的对象均按原样返回。</target>
        </trans-unit>
        <trans-unit id="e025c62fbc48998b73600c44b54165169adc5d17" translate="yes" xml:space="preserve">
          <source>The type specializer, &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt;, can specify one of the &lt;em&gt;system types&lt;/em&gt; in the following list. When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible.</source>
          <target state="translated">类型专家 &lt;code&gt;(&lt;var&gt;arg&lt;/var&gt; &lt;var&gt;type&lt;/var&gt;)&lt;/code&gt; 可以在以下列表中指定一种&lt;em&gt;系统类型&lt;/em&gt;。当指定父类型时，其类型是其更具体的子类型中的任何一个的参数以及孙子，孙子等也将兼容。</target>
        </trans-unit>
        <trans-unit id="918de08f5d10241b12396b2606b071d4bc53db4a" translate="yes" xml:space="preserve">
          <source>The type, height, and width of the cursor that was last displayed on this window.</source>
          <target state="translated">最后显示在这个窗口的光标的类型、高度和宽度。</target>
        </trans-unit>
        <trans-unit id="813fe6c3982289dedb90eb513614087f1cf82291" translate="yes" xml:space="preserve">
          <source>The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.</source>
          <target state="translated">上一节中的类型用于一般的编程目的,它们中的大多数是大多数Lisp方言所共有的。Emacs Lisp为与编辑有关的目的提供了几个额外的数据类型。</target>
        </trans-unit>
        <trans-unit id="e4129664d859d9f2877eb29408df21ab5cb6661f" translate="yes" xml:space="preserve">
          <source>The types of this window&amp;rsquo;s vertical and horizontal scroll bars.</source>
          <target state="translated">此窗口的垂直和水平滚动条的类型。</target>
        </trans-unit>
        <trans-unit id="4ebd8369f764b15f8731d7001594b37607f527c5" translate="yes" xml:space="preserve">
          <source>The underlying ACL implementation is platform-specific; on GNU/Linux and BSD, Emacs uses the POSIX ACL interface, while on MS-Windows Emacs emulates the POSIX ACL interface with native file security APIs.</source>
          <target state="translated">底层的ACL实现是特定于平台的;在GNU/Linux和BSD上,Emacs使用POSIX ACL接口,而在MS-Windows上,Emacs通过本地文件安全API模拟POSIX ACL接口。</target>
        </trans-unit>
        <trans-unit id="32e0037f866c0451ac34d2bce4ba7d40d8a695e5" translate="yes" xml:space="preserve">
          <source>The unibyte and multibyte text representations use different character codes. The valid character codes for unibyte representation range from 0 to &lt;code&gt;#xFF&lt;/code&gt; (255)&amp;mdash;the values that can fit in one byte. The valid character codes for multibyte representation range from 0 to &lt;code&gt;#x3FFFFF&lt;/code&gt;. In this code space, values 0 through &lt;code&gt;#x7F&lt;/code&gt; (127) are for</source>
          <target state="translated">单字节和多字节文本表示使用不同的字符代码。单字节表示形式的有效字符代码范围是0到 &lt;code&gt;#xFF&lt;/code&gt; （255）-可以容纳一个字节的值。多字节表示形式的有效字符代码范围是0到 &lt;code&gt;#x3FFFFF&lt;/code&gt; 。在此代码空间中，值0到 &lt;code&gt;#x7F&lt;/code&gt; （127）用于</target>
        </trans-unit>
        <trans-unit id="9cca45442a6da20dbdae7b6615f2dc10baadc419" translate="yes" xml:space="preserve">
          <source>The unit of heap space measurement, always equal to 1024 bytes.</source>
          <target state="translated">堆空间计量单位,始终等于1024字节。</target>
        </trans-unit>
        <trans-unit id="63b023b466e3bce22e9d5ba36aecbcf660e048b0" translate="yes" xml:space="preserve">
          <source>The upcase table maps each character into the corresponding upper case character.</source>
          <target state="translated">大写表将每个字符映射成相应的大写字符。</target>
        </trans-unit>
        <trans-unit id="a0c17633f0138ef3e9286c2d1a5c0258bfdb10e0" translate="yes" xml:space="preserve">
          <source>The urgency level. It can be &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;critical&lt;/code&gt;.</source>
          <target state="translated">紧急程度。它可以是 &lt;code&gt;low&lt;/code&gt; ， &lt;code&gt;normal&lt;/code&gt; 或 &lt;code&gt;critical&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce53fb4d208bc4c27337bdd863033417c703f3c" translate="yes" xml:space="preserve">
          <source>The use of a special variable as a formal argument in a function is discouraged. Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times).</source>
          <target state="translated">不鼓励在函数中使用特殊变量作为形式参数。当启用词法绑定模式时,这样做会产生未指定的行为(它可能有时使用词法绑定,而有时使用动态绑定)。</target>
        </trans-unit>
        <trans-unit id="143e85103669e6f3a73e45520cffeb3311a2e64f" translate="yes" xml:space="preserve">
          <source>The use of numbered backups ultimately leads to a large number of backup versions, which must then be deleted. Emacs can do this automatically or it can ask the user whether to delete them.</source>
          <target state="translated">使用编号备份最终会导致大量的备份版本,然后必须将其删除。Emacs可以自动进行删除,也可以询问用户是否要删除它们。</target>
        </trans-unit>
        <trans-unit id="a8707423f159b173b39f4962f0556071463cb869" translate="yes" xml:space="preserve">
          <source>The use of the &lt;var&gt;debugger-args&lt;/var&gt; is that &lt;code&gt;debug&lt;/code&gt; displays the rest of its arguments at the top of the</source>
          <target state="translated">&lt;var&gt;debugger-args&lt;/var&gt; 的用法是， &lt;code&gt;debug&lt;/code&gt; 在其顶部显示其其余参数。</target>
        </trans-unit>
        <trans-unit id="511c6540e54c5649d62befa61b017dde79ffef3a" translate="yes" xml:space="preserve">
          <source>The user can add any key matching the specified key type, but you can give some keys a preferential treatment by specifying them with the &lt;code&gt;:options&lt;/code&gt; (see &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;). The specified keys will always be shown in the customize buffer (together with a suitable value), with a checkbox to include or exclude or disable the key/value pair from the alist. The user will not be able to edit the keys specified by the &lt;code&gt;:options&lt;/code&gt; keyword argument.</source>
          <target state="translated">用户可以添加与指定键类型匹配的任何键，但可以通过使用 &lt;code&gt;:options&lt;/code&gt; 指定它们来对某些键进行优先处理（请参见&lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;变量定义&lt;/a&gt;）。指定的键将始终显示在自定义缓冲区中（连同合适的值），并带有一个复选框，以从列表中包括或排除或禁用键/值对。用户将无法编辑由 &lt;code&gt;:options&lt;/code&gt; 关键字参数指定的键。</target>
        </trans-unit>
        <trans-unit id="fdfe999c9bdc85b3810a58353ece516fc9370b63" translate="yes" xml:space="preserve">
          <source>The user can type</source>
          <target state="translated">用户可以输入</target>
        </trans-unit>
        <trans-unit id="fd064556685bc85b9d72d2d84d2adeec46f6b9f6" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-alist&lt;/code&gt;.</source>
          <target state="translated">用户选项 &lt;code&gt;display-buffer-alist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51ded933043196b29f2223baab0f1acb3d9183ff" translate="yes" xml:space="preserve">
          <source>The user option &lt;code&gt;display-buffer-base-action&lt;/code&gt;.</source>
          <target state="translated">用户选项 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2793d8b41a5fb22673ccbb20fb899bf671a14181" translate="yes" xml:space="preserve">
          <source>The user-level commands for using Imenu are described in the Emacs Manual (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html#Imenu&quot;&gt;Imenu&lt;/a&gt; in</source>
          <target state="translated">使用i菜单用户级命令在Emacs手册中描述（参见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html#Imenu&quot;&gt;i菜单&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="30be3069546127e24c5678d1a47150d319e9b5c5" translate="yes" xml:space="preserve">
          <source>The usual and simplest way is to set the variable &lt;code&gt;imenu-generic-expression&lt;/code&gt;:</source>
          <target state="translated">通常最简单的方法是设置变量 &lt;code&gt;imenu-generic-expression&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="90c75b3bffda92eeaca86bfbbe99a7430c08eb6e" translate="yes" xml:space="preserve">
          <source>The usual conventions for displaying characters.</source>
          <target state="translated">显示字符的通常惯例。</target>
        </trans-unit>
        <trans-unit id="2bd44e25afda0f432266a4e8544ff3b09136787e" translate="yes" xml:space="preserve">
          <source>The usual effect of signaling an error is to terminate the command that is running and return immediately to the Emacs editor command loop. You can arrange to trap errors occurring in a part of your program by establishing an error handler, with the special form &lt;code&gt;condition-case&lt;/code&gt;. A simple example looks like this:</source>
          <target state="translated">发出错误信号的通常效果是终止正在运行的命令，并立即返回Emacs编辑器命令循环。您可以通过建立带有特殊形式 &lt;code&gt;condition-case&lt;/code&gt; 的错误处理程序来安排捕获程序部分中发生的错误。一个简单的示例如下所示：</target>
        </trans-unit>
        <trans-unit id="bda6ef848c823990e6e54452a3858487c06e4809" translate="yes" xml:space="preserve">
          <source>The usual interface functions for visiting.</source>
          <target state="translated">访的常用接口功能。</target>
        </trans-unit>
        <trans-unit id="af1901f1654ae4b4ade44f3e4daa9e941c61b525" translate="yes" xml:space="preserve">
          <source>The usual menu keymap item properties, &lt;code&gt;:visible&lt;/code&gt;, &lt;code&gt;:enable&lt;/code&gt;, &lt;code&gt;:button&lt;/code&gt;, and &lt;code&gt;:filter&lt;/code&gt;, are useful in tool bar bindings and have their normal meanings. The &lt;var&gt;real-binding&lt;/var&gt; in the item must be a command, not a keymap; in other words, it does not work to define a tool bar icon as a prefix key.</source>
          <target state="translated">常用的菜单键盘映射项属性 &lt;code&gt;:visible&lt;/code&gt; ， &lt;code&gt;:enable&lt;/code&gt; ， &lt;code&gt;:button&lt;/code&gt; 和 &lt;code&gt;:filter&lt;/code&gt; 在工具栏绑定中很有用，并具有其通常的含义。项目中的 &lt;var&gt;real-binding&lt;/var&gt; 必须是命令，而不是键映射；换句话说，将工具栏图标定义为前缀键无效。</target>
        </trans-unit>
        <trans-unit id="ac47370c7e29666366c5084b597a830112308e12" translate="yes" xml:space="preserve">
          <source>The usual purpose of tracking mouse motion is to indicate on the screen the consequences of pushing or releasing a button at the current position.</source>
          <target state="translated">跟踪鼠标运动的通常目的是在屏幕上显示在当前位置按下或松开按钮的后果。</target>
        </trans-unit>
        <trans-unit id="4945884c017dad70b10d5d997fdc2f6a3086adf5" translate="yes" xml:space="preserve">
          <source>The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, &amp;lsquo;</source>
          <target state="translated">字母数字字符的常规阅读语法是问号，后跟该字符；因此，</target>
        </trans-unit>
        <trans-unit id="5b4827bb568bf80753c3882d75fd2ab2a82f4c4c" translate="yes" xml:space="preserve">
          <source>The usual reason to specify a documentation string for a type is to provide more information about the meanings of alternatives inside a &lt;code&gt;choice&lt;/code&gt; type or the parts of some other composite type.</source>
          <target state="translated">为类型指定文档字符串的通常原因是提供有关 &lt;code&gt;choice&lt;/code&gt; 类型内部或某些其他复合类型的各个部分的替代含义的更多信息。</target>
        </trans-unit>
        <trans-unit id="93b29e680886ef3e32073a78d95db6b48a506c98" translate="yes" xml:space="preserve">
          <source>The usual regexp special characters are not special inside a character alternative. A completely different set of characters is special: &amp;lsquo;</source>
          <target state="translated">常规正则表达式特殊字符在替代字符内不是特殊的。一组完全不同的字符是特殊的：</target>
        </trans-unit>
        <trans-unit id="d9d1876d8ad2be0bc6c8de7cd54c94dfc02c0053" translate="yes" xml:space="preserve">
          <source>The usual regular expression functions do backtracking when necessary to handle the &amp;lsquo;</source>
          <target state="translated">通常的正则表达式函数会在需要处理'</target>
        </trans-unit>
        <trans-unit id="c019ba7cb944335d1fef89c7810b797ce8729a29" translate="yes" xml:space="preserve">
          <source>The usual role of a terminal-specific library is to enable special keys to send sequences that Emacs can recognize. It may also need to set or add to &lt;code&gt;input-decode-map&lt;/code&gt; if the Termcap or Terminfo entry does not specify all the terminal&amp;rsquo;s function keys. See &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;.</source>
          <target state="translated">特定于终端的库的通常作用是使特殊键能够发送Emacs可以识别的序列。如果Termcap或Terminfo条目未指定所有终端的功能键，则可能还需要设置或添加到 &lt;code&gt;input-decode-map&lt;/code&gt; 。请参阅&lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;终端输入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3392a5efb2e33159132ee8ca55dd0bd95184127" translate="yes" xml:space="preserve">
          <source>The usual use of this feature is to fill comments in programming language modes. If the function needs to fill a paragraph in the usual way, it can do so as follows:</source>
          <target state="translated">该功能的通常用途是在编程语言模式下填充注释。如果函数需要按通常的方式填充一段文字,可以按如下方式进行。</target>
        </trans-unit>
        <trans-unit id="ba8560d5e995fe38c893b74271adb5dbf50667f4" translate="yes" xml:space="preserve">
          <source>The usual way to change the value of a variable is with the special form &lt;code&gt;setq&lt;/code&gt;. When you need to compute the choice of variable at run time, use the function &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">更改变量值的通常方法是使用特殊形式 &lt;code&gt;setq&lt;/code&gt; 。当您需要在运行时计算变量的选择时，请使用函数 &lt;code&gt;set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad41ba273b5018a4ad09f4b5ea08e124af9c068c" translate="yes" xml:space="preserve">
          <source>The usual way to define a face is through the &lt;code&gt;defface&lt;/code&gt; macro. This macro associates a face name (a symbol) with a default &lt;em&gt;face spec&lt;/em&gt;. A face spec is a construct which specifies what attributes a face should have on any given terminal; for example, a face spec might specify one foreground color on high-color terminals, and a different foreground color on low-color terminals.</source>
          <target state="translated">定义面的常用方法是通过 &lt;code&gt;defface&lt;/code&gt; 宏。此宏将人脸名称（符号）与默认人&lt;em&gt;脸规范相关联&lt;/em&gt;。面部规范是一种结构，用于指定面部在任何给定终端上应具有的属性；例如，面部规格可能会在高色终端上指定一种前景色，而在低色终端上指定另一种前景色。</target>
        </trans-unit>
        <trans-unit id="ab4be22e46f2537548bcdd8b14595a57667df9f7" translate="yes" xml:space="preserve">
          <source>The usual way to define the SMIE grammar of a language is by defining a new global variable that holds the precedence table by giving a set of BNF rules. For example, the grammar definition for a small Pascal-like language could look like:</source>
          <target state="translated">通常定义语言的SMIE语法的方法是通过给出一组BNF规则来定义一个新的全局变量,该变量持有优先表。例如,一个小型Pascal类语言的语法定义可以是这样的。</target>
        </trans-unit>
        <trans-unit id="ea823ab039487ce6c627239fb33b038961688356" translate="yes" xml:space="preserve">
          <source>The usual way to make a buffer-local binding is with &lt;code&gt;make-local-variable&lt;/code&gt;, which is what major mode commands typically use. This affects just the current buffer; all other buffers (including those yet to be created) will continue to share the default value unless they are explicitly given their own buffer-local bindings.</source>
          <target state="translated">进行缓冲区本地绑定的通常方法是使用 &lt;code&gt;make-local-variable&lt;/code&gt; ，这是主要模式命令通常使用的方法。这只会影响当前缓冲区；除非明确为其指定了自己的缓冲区本地绑定，否则所有其他缓冲区（包括尚未创建的缓冲区）将继续共享默认值。</target>
        </trans-unit>
        <trans-unit id="0fe16ddfa309e34d499b3360c2ffbfd59734391f" translate="yes" xml:space="preserve">
          <source>The usual way to make a menu keymap produce a menu is to make it the definition of a prefix key. (A Lisp program can explicitly pop up a menu and receive the user&amp;rsquo;s choice&amp;mdash;see &lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;Pop-Up Menus&lt;/a&gt;.)</source>
          <target state="translated">使菜单键映射产生菜单的通常方法是使它成为前缀键的定义。（Lisp程序可以显式弹出菜单并接收用户的选择，请参阅&amp;ldquo;&lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;弹出菜单&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="413eaf722746475cb7fc0070f78d8c7cbef5d401" translate="yes" xml:space="preserve">
          <source>The usual way to read a file into a buffer as a sequence of bytes, so you can decode the contents explicitly, is with &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;); alternatively, specify a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;rawfile&lt;/var&gt; argument when visiting a file with &lt;code&gt;find-file-noselect&lt;/code&gt;. These methods result in a unibyte buffer.</source>
          <target state="translated">将文件按字节顺序读入缓冲区的通常方法是使您可以显式地解码内容，即 &lt;code&gt;insert-file-contents-literally&lt;/code&gt; 使用insert-file-contents（请参阅&lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;从文件读取&lt;/a&gt;）。或者，在使用 &lt;code&gt;find-file-noselect&lt;/code&gt; 访问文件时，指定一个非 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;rawfile&lt;/var&gt; 参数。这些方法产生一个单字节缓冲区。</target>
        </trans-unit>
        <trans-unit id="5a11c911f5b0f69a171b92b7cffb6822859b5ec3" translate="yes" xml:space="preserve">
          <source>The usual way to reference a variable is to write the symbol which names it. See &lt;a href=&quot;symbol-forms#Symbol-Forms&quot;&gt;Symbol Forms&lt;/a&gt;.</source>
          <target state="translated">引用变量的通常方法是编写符号来命名它。请参阅&lt;a href=&quot;symbol-forms#Symbol-Forms&quot;&gt;符号形式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5526547f8b2c540a3aed5c614e44c4e6712243b8" translate="yes" xml:space="preserve">
          <source>The usual way to use the byte sequence that results from explicitly encoding text is to copy it to a file or process&amp;mdash;for example, to write it with &lt;code&gt;write-region&lt;/code&gt; (see &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;Writing to Files&lt;/a&gt;), and suppress encoding by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to &lt;code&gt;no-conversion&lt;/code&gt;.</source>
          <target state="translated">使用由显式编码文本产生的字节序列的通常方法是将其复制到文件或进程中，例如，使用 &lt;code&gt;write-region&lt;/code&gt; 进行写入（请参见Write &lt;a href=&quot;writing-to-files#Writing-to-Files&quot;&gt;to Files&lt;/a&gt;），并通过绑定 &lt;code&gt;coding-system-for-write&lt;/code&gt; 抑制编码for-write到 &lt;code&gt;no-conversion&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36be957267ce38e09b5982a5646ced40aa3279e5" translate="yes" xml:space="preserve">
          <source>The valid values of &lt;code&gt;syntax-table&lt;/code&gt; text property are:</source>
          <target state="translated">&lt;code&gt;syntax-table&lt;/code&gt; 文本属性的有效值为：</target>
        </trans-unit>
        <trans-unit id="356e00fd867a17cbdcb1217100288420420a4192" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;auto-raise&lt;/code&gt; should be used when your window manager has the focus automatically follow the position of the mouse pointer and a frame that gains focus is raised automatically.</source>
          <target state="translated">当窗口管理器的焦点自动跟随鼠标指针的位置并且获得焦点的框架 &lt;code&gt;auto-raise&lt;/code&gt; 应使用值auto-raise。</target>
        </trans-unit>
        <trans-unit id="893aaa83d61bb05c575aed10c479a15392b8a63f" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;t&lt;/code&gt; should be used when your window manager has the focus automatically follow the position of the mouse pointer but a frame that gains focus is not raised automatically and may even remain occluded by other window-system windows.</source>
          <target state="translated">当窗口管理器使焦点自动跟随鼠标指针的位置而获得焦点的帧不会自动升高，甚至可能被其他窗口系统窗口遮挡时，应使用值 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aed9f61a23e975eb7392678e85f51f4d74310e87" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;color&lt;/var&gt; specifies the color to draw with. The default is the foreground color of the face for simple boxes, and the background color of the face for 3D boxes.</source>
          <target state="translated">值 &lt;var&gt;color&lt;/var&gt; 指定用于绘制的颜色。对于简单框，默认值为面部的前景色；对于3D框，默认值为面部的背景色。</target>
        </trans-unit>
        <trans-unit id="726b5e07fbd252dac7c2dae2a2b05f252281e1cf" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;height&lt;/var&gt; is the value that was specified for the height of the horizontal scroll bar (which may be &lt;code&gt;nil&lt;/code&gt;); &lt;var&gt;lines&lt;/var&gt; is the (possibly rounded) number of lines that the horizontally scroll bar actually occupies.</source>
          <target state="translated">值 &lt;var&gt;height&lt;/var&gt; 是已为水平滚动条（其可以是高度指定的值 &lt;code&gt;nil&lt;/code&gt; ）; &lt;var&gt;lines&lt;/var&gt; 是水平滚动条实际占用的（可能是四舍五入的）行数。</target>
        </trans-unit>
        <trans-unit id="db2573e485b9f1d52d90fe7b697fd92212845cf8" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;style&lt;/var&gt; specifies whether to draw a 3D box. If it is &lt;code&gt;released-button&lt;/code&gt;, the box looks like a 3D button that is not being pressed. If it is &lt;code&gt;pressed-button&lt;/code&gt;, the box looks like a 3D button that is being pressed. If it is &lt;code&gt;nil&lt;/code&gt; or omitted, a plain 2D box is used.</source>
          <target state="translated">值 &lt;var&gt;style&lt;/var&gt; 指定是否绘制3D框。如果它是 &lt;code&gt;released-button&lt;/code&gt; ，则该框看起来像未按下的3D按钮。如果 &lt;code&gt;pressed-button&lt;/code&gt; ，则该框看起来像是被按下的3D按钮。如果为 &lt;code&gt;nil&lt;/code&gt; 或省略，则使用普通2D框。</target>
        </trans-unit>
        <trans-unit id="1eb8d30e0ef6e2c616649855299438edaa4b6387" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;width&lt;/var&gt; is the value that was specified for the width of the vertical scroll bar (which may be &lt;code&gt;nil&lt;/code&gt;); &lt;var&gt;columns&lt;/var&gt; is the (possibly rounded) number of columns that the vertical scroll bar actually occupies.</source>
          <target state="translated">值 &lt;var&gt;width&lt;/var&gt; 是已为垂直滚动条（其可以是的宽度指定的值 &lt;code&gt;nil&lt;/code&gt; ）; &lt;var&gt;columns&lt;/var&gt; 是垂直滚动条实际占用的（可能是四舍五入的）列数。</target>
        </trans-unit>
        <trans-unit id="738dcd4e09dec82d9c9cbf00960b591b0d043018" translate="yes" xml:space="preserve">
          <source>The value can also be a list of error conditions (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;). Then the debugger is called only for error conditions in this list (except those also listed in &lt;code&gt;debug-ignored-errors&lt;/code&gt;). For example, if you set &lt;code&gt;debug-on-error&lt;/code&gt; to the list &lt;code&gt;(void-variable)&lt;/code&gt;, the debugger is only called for errors about a variable that has no value.</source>
          <target state="translated">该值也可以是错误条件的列表（请参阅&lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;信号错误&lt;/a&gt;）。然后，仅针对此列表中的错误条件调用调试器（除了在 &lt;code&gt;debug-ignored-errors&lt;/code&gt; 中也列出的错误条件）。例如，如果将 &lt;code&gt;debug-on-error&lt;/code&gt; 设置为列表 &lt;code&gt;(void-variable)&lt;/code&gt; ，则仅针对与没有值的变量有关的错误调用调试器。</target>
        </trans-unit>
        <trans-unit id="0fca95603596a3c0776843a564cf75cbd2a26719" translate="yes" xml:space="preserve">
          <source>The value can also be a symbol with a function definition. That is equivalent to &lt;code&gt;t&lt;/code&gt;, except that the next warning will also call the function with no arguments with the warnings buffer current. The function can insert text which will serve as a header for the series of warnings.</source>
          <target state="translated">该值也可以是带有函数定义的符号。这等效于 &lt;code&gt;t&lt;/code&gt; ，除了下一个警告还将调用不带任何参数且带有警告缓冲区电流的函数。该函数可以插入文本，该文本将用作一系列警告的标题。</target>
        </trans-unit>
        <trans-unit id="036ce65d4e444cc9ca133db8c5ff911fde4b8b3b" translate="yes" xml:space="preserve">
          <source>The value can also be floating point or a function, which specifies the height relative to an &lt;em&gt;underlying face&lt;/em&gt; (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). A floating-point value specifies the amount by which to scale the height of the underlying face. A function value is called with one argument, the height of the underlying face, and returns the height of the new face. If the function is passed an integer argument, it must return an integer.</source>
          <target state="translated">该值也可以是浮点数或一个函数，该函数指定相对于&lt;em&gt;基础面&lt;/em&gt;的高度（请参见&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;显示面&lt;/a&gt;）。浮点值指定缩放基础面的高度的量。使用一个参数（基础面的高度）调用一个函数值，并返回新面的高度。如果函数传递了整数参数，则必须返回整数。</target>
        </trans-unit>
        <trans-unit id="93f34264bf299dd9ff1623c4a048f9a90b6d13e4" translate="yes" xml:space="preserve">
          <source>The value can be &lt;code&gt;nil&lt;/code&gt; (don&amp;rsquo;t use parity), the symbol &lt;code&gt;odd&lt;/code&gt; (use odd parity), or the symbol &lt;code&gt;even&lt;/code&gt; (use even parity). If &lt;var&gt;parity&lt;/var&gt; is not given, it defaults to no parity.</source>
          <target state="translated">该值可以为 &lt;code&gt;nil&lt;/code&gt; （不使用奇偶校验），符号 &lt;code&gt;odd&lt;/code&gt; （使用奇数奇偶校验）或符号 &lt;code&gt;even&lt;/code&gt; （使用偶数奇偶校验）。如果未给出 &lt;var&gt;parity&lt;/var&gt; ，则默认为无奇偶校验。</target>
        </trans-unit>
        <trans-unit id="b19ab7691b129f64fc5f72d4c526e81bb1415159" translate="yes" xml:space="preserve">
          <source>The value can be a string; that should be the name of a file containing external-format X bitmap data. The file is found in the directories listed in the variable &lt;code&gt;x-bitmap-file-path&lt;/code&gt;.</source>
          <target state="translated">该值可以是字符串。该名称应该是包含外部格式X位图数据的文件的名称。该文件位于变量 &lt;code&gt;x-bitmap-file-path&lt;/code&gt; 中列出的目录中。</target>
        </trans-unit>
        <trans-unit id="90810279cbdbc3d6497008e3e858bcead8d9c860" translate="yes" xml:space="preserve">
          <source>The value can be an approximation. The function may avoid expensive processing and return an inexact result.</source>
          <target state="translated">该值可以是一个近似值。该函数可以避免昂贵的处理和返回不精确的结果。</target>
        </trans-unit>
        <trans-unit id="a0ff635173abbeea2ba4af8f9b36759383fe725e" translate="yes" xml:space="preserve">
          <source>The value cell holds a symbol&amp;rsquo;s value as a variable, which is what you get if the symbol itself is evaluated as a Lisp expression. See &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, for details about how values are set and retrieved, including complications such as &lt;em&gt;local bindings&lt;/em&gt; and &lt;em&gt;scoping rules&lt;/em&gt;. Most symbols can have any Lisp object as a value, but certain special symbols have values that cannot be changed; these include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, and any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">值单元格将符号的值保存为变量，这是将符号本身评估为Lisp表达式时得到的结果。有关如何设置和检索值的详细信息，请参见&lt;a href=&quot;variables#Variables&quot;&gt;变量&lt;/a&gt;，包括&lt;em&gt;局部绑定&lt;/em&gt;和&lt;em&gt;作用域规则&lt;/em&gt;等复杂性。大多数符号可以将任何Lisp对象作为值，但是某些特殊符号具有无法更改的值。其中包括 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，以及名称以'开头的任何符号</target>
        </trans-unit>
        <trans-unit id="00902684377c36ec854c666f66e1def68419f7f0" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use for representing a JSON array. It can be either &lt;code&gt;array&lt;/code&gt;, the default, to use Lisp arrays; or &lt;code&gt;list&lt;/code&gt; to use lists.</source>
          <target state="translated">该值决定使用哪个Lisp对象表示JSON数组。它可以是 &lt;code&gt;array&lt;/code&gt; ，默认，使用Lisp的阵列; 或 &lt;code&gt;list&lt;/code&gt; 以使用列表。</target>
        </trans-unit>
        <trans-unit id="16edef5cb81f91f4adf2188db4dc4f629deae17d" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use for representing the key-value mappings of a JSON object. It can be either &lt;code&gt;hash-table&lt;/code&gt;, the default, to make hashtables with strings as keys; &lt;code&gt;alist&lt;/code&gt; to use alists with symbols as keys; or &lt;code&gt;plist&lt;/code&gt; to use plists with keyword symbols as keys.</source>
          <target state="translated">该值决定使用哪个Lisp对象来表示JSON对象的键-值映射。它可以是默认值 &lt;code&gt;hash-table&lt;/code&gt; ，以字符串为键来创建哈希表。 &lt;code&gt;alist&lt;/code&gt; 到使用alists的符号作为键; 或 &lt;code&gt;plist&lt;/code&gt; 可以将带有关键字符号的plists用作键。</target>
        </trans-unit>
        <trans-unit id="3fa2905ebfc7e60316747f384efec8fd2b021c6b" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use to represent the JSON keyword &lt;code&gt;false&lt;/code&gt;. It defaults to the symbol &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">该值决定使用哪个Lisp对象来表示JSON关键字 &lt;code&gt;false&lt;/code&gt; 。默认为符号 &lt;code&gt;:false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70971f173ca78b68c08bef1aa1b243f7d8fcb51c" translate="yes" xml:space="preserve">
          <source>The value decides which Lisp object to use to represent the JSON keyword &lt;code&gt;null&lt;/code&gt;. It defaults to the symbol &lt;code&gt;:null&lt;/code&gt;.</source>
          <target state="translated">该值决定使用哪个Lisp对象来表示JSON关键字 &lt;code&gt;null&lt;/code&gt; 。默认为符号 &lt;code&gt;:null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fe437d2786c53546e9e4721af67a363a80470e7" translate="yes" xml:space="preserve">
          <source>The value denotes the side of the frame or window where a new window displaying the buffer shall be created. This entry is used by &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; to indicate the side of the frame where a new side window shall be placed (see &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Displaying Buffers in Side Windows&lt;/a&gt;). It is also used by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; to indicate the side of an existing window where the new window shall be located (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;).</source>
          <target state="translated">该值表示框架或窗口的一侧，在该侧应创建显示缓冲区的新窗口。 &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; 使用此条目指示框架的应放置新侧窗的一侧（请参阅&lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;在&lt;/a&gt;侧窗中显示缓冲区）。 &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; 也使用它来指示新窗口应位于的现有窗口的一侧（请参阅&lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f7ee348338ce1106641a672b981019be718a72ff" translate="yes" xml:space="preserve">
          <source>The value has no effect when renaming would not alter the owner or group of the file; that is, for files which are owned by the user and whose group matches the default for a new file created there by the user.</source>
          <target state="translated">当重命名不会改变文件的所有者或组时,该值没有任何影响;也就是说,对于用户拥有的文件,其组与用户在那里创建的新文件的默认值一致。</target>
        </trans-unit>
        <trans-unit id="ffc415f45e41ef7cef7291f52d1ca8b82b116694" translate="yes" xml:space="preserve">
          <source>The value has the form &lt;code&gt;(&lt;var&gt;offset&lt;/var&gt; &lt;var&gt;abbr&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;offset&lt;/var&gt; is an integer giving the number of seconds ahead of Universal Time (east of Greenwich). A negative value means west of Greenwich. The second element, &lt;var&gt;abbr&lt;/var&gt;, is a string giving an abbreviation for the time zone, e.g., &amp;lsquo;</source>
          <target state="translated">该值的形式为 &lt;code&gt;(&lt;var&gt;offset&lt;/var&gt; &lt;var&gt;abbr&lt;/var&gt;)&lt;/code&gt; 。这里的 &lt;var&gt;offset&lt;/var&gt; 是一个整数，给出比世界标准时间（格林威治东部）早的秒数。负值表示格林威治以西。第二个元素 &lt;var&gt;abbr&lt;/var&gt; 是一个字符串，给出了时区的缩写，例如'</target>
        </trans-unit>
        <trans-unit id="d54c14bbe8e273d4103e284f553d7a5a47ac3803" translate="yes" xml:space="preserve">
          <source>The value is 5 because that is the</source>
          <target state="translated">该值为5,因为那是</target>
        </trans-unit>
        <trans-unit id="fcb6e2e9389f7780a675906dacf95eb444c0772f" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; for a subexpression inside a &amp;lsquo;</source>
          <target state="translated">对于'中的子表达式，该值为 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac9636b8cfc92069e35cc830e2013018fdbb6b7e" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;count&lt;/var&gt; is out of range, or for a subexpression inside a &amp;lsquo;</source>
          <target state="translated">如果 &lt;var&gt;count&lt;/var&gt; 超出范围，或者对于'中的子表达式，则该值为 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c167e0d6bf2b798519700d2a08b4be56ddb7ac7a" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;window&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for the selected window. If &lt;var&gt;pos&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for the value of point in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">如果 &lt;var&gt;pos&lt;/var&gt; 在 &lt;var&gt;window&lt;/var&gt; 中不可见，则值为 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;var&gt;window&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示所选窗口。如果 &lt;var&gt;pos&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示 &lt;var&gt;window&lt;/var&gt; 中point的值。</target>
        </trans-unit>
        <trans-unit id="a178845a64825fe33f0ce1505830cf0c8571ccb5" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;state&lt;/var&gt; represents a parse which has arrived at a top level position.</source>
          <target state="translated">如果 &lt;var&gt;state&lt;/var&gt; 表示已到达顶级位置的解析，则该值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1847ffb79e4ef977f22b0f89bbfa3a8711353ea" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if the properties remain unchanged all the way to the end of &lt;var&gt;object&lt;/var&gt; and &lt;var&gt;limit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value is non-&lt;code&gt;nil&lt;/code&gt;, it is a position greater than or equal to &lt;var&gt;pos&lt;/var&gt;. The value equals &lt;var&gt;pos&lt;/var&gt; only when &lt;var&gt;limit&lt;/var&gt; equals &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">如果属性一直到 &lt;var&gt;object&lt;/var&gt; 末尾都保持不变，则值为 &lt;code&gt;nil&lt;/code&gt; ，并且 &lt;var&gt;limit&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 。如果该值不为 &lt;code&gt;nil&lt;/code&gt; ，则其位置大于或等于 &lt;var&gt;pos&lt;/var&gt; 。该值等于 &lt;var&gt;pos&lt;/var&gt; 只有当 &lt;var&gt;limit&lt;/var&gt; 等于 &lt;var&gt;pos&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f42191ef8fc8d62fa782e6182ae3d4adf74e945c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;nil&lt;/code&gt; if the property remains unchanged all the way to the end of &lt;var&gt;object&lt;/var&gt; and &lt;var&gt;limit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value is non-&lt;code&gt;nil&lt;/code&gt;, it is a position greater than or equal to &lt;var&gt;pos&lt;/var&gt;; it equals &lt;var&gt;pos&lt;/var&gt; only if &lt;var&gt;limit&lt;/var&gt; equals &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">如果属性一直到 &lt;var&gt;object&lt;/var&gt; 末尾都保持不变，则值为 &lt;code&gt;nil&lt;/code&gt; ，并且 &lt;var&gt;limit&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 。如果该值不为 &lt;code&gt;nil&lt;/code&gt; ，则其位置大于或等于 &lt;var&gt;pos&lt;/var&gt; ；它等于 &lt;var&gt;pos&lt;/var&gt; 只有 &lt;var&gt;limit&lt;/var&gt; 等于 &lt;var&gt;pos&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="862c753ca19532a871df595b1b786989741df504" translate="yes" xml:space="preserve">
          <source>The value is a form (an expression).</source>
          <target state="translated">该值是一种形式(一种表达方式)。</target>
        </trans-unit>
        <trans-unit id="ec33dbdc3801cba4b2a38abf814dcf1da00c4804" translate="yes" xml:space="preserve">
          <source>The value is a function.</source>
          <target state="translated">值是一个函数。</target>
        </trans-unit>
        <trans-unit id="18ad4635bccc9d11d2025c4e0e4bf454e39e4870" translate="yes" xml:space="preserve">
          <source>The value is a key sequence. The customization buffer shows the key sequence using the same syntax as the</source>
          <target state="translated">该值是一个密钥序列。自定义缓冲区显示键序列,使用的语法与</target>
        </trans-unit>
        <trans-unit id="92047d2ff22dd07d30de54ae74480f7db138859c" translate="yes" xml:space="preserve">
          <source>The value is a list of all defined character set names.</source>
          <target state="translated">该值是所有定义的字符集名称的列表。</target>
        </trans-unit>
        <trans-unit id="42e3b3b8e9f18abe4b0e6fc019c88b2b88f0e5a7" translate="yes" xml:space="preserve">
          <source>The value is a list of forms (expressions).</source>
          <target state="translated">该值是一个形式(表达式)的列表。</target>
        </trans-unit>
        <trans-unit id="d9d7add64fd5fda2d55573b4b40ddee4fa132824" translate="yes" xml:space="preserve">
          <source>The value is a list of functions.</source>
          <target state="translated">值是一个函数列表。</target>
        </trans-unit>
        <trans-unit id="744e014c080a028da5111b9957a721b5376e2f9e" translate="yes" xml:space="preserve">
          <source>The value is a predicate&amp;mdash;a function of one argument that returns non-&lt;code&gt;nil&lt;/code&gt; for success and &lt;code&gt;nil&lt;/code&gt; for failure.</source>
          <target state="translated">该值是一个谓词-一个参数的函数，该参数返回 &lt;code&gt;nil&lt;/code&gt; 表示成功， &lt;code&gt;nil&lt;/code&gt; 表示失败。</target>
        </trans-unit>
        <trans-unit id="fc95eed350ead41f92d508546cbe37902aff0c7a" translate="yes" xml:space="preserve">
          <source>The value is a program name.</source>
          <target state="translated">该值是一个程序名称。</target>
        </trans-unit>
        <trans-unit id="b563d6300ce73a67d16482c93e6765622dfc6342" translate="yes" xml:space="preserve">
          <source>The value is a whole shell command.</source>
          <target state="translated">该值是一个完整的shell命令。</target>
        </trans-unit>
        <trans-unit id="0fb0a1e296cb5eb5561689c7425698e96e4d5162" translate="yes" xml:space="preserve">
          <source>The value is always a string ending with a slash.</source>
          <target state="translated">该值总是以斜线结束的字符串。</target>
        </trans-unit>
        <trans-unit id="38abcf64aec0a36e0f511c163ed2cd547b75773a" translate="yes" xml:space="preserve">
          <source>The value is an alist or nested alist in which each element describes one unpacked field.</source>
          <target state="translated">该值是一个列表或嵌套列表,其中每个元素描述一个未打包的字段。</target>
        </trans-unit>
        <trans-unit id="f7f574a40cde0014d34b1f4c77ea68404bc7d6db" translate="yes" xml:space="preserve">
          <source>The value is an expression for determining whether the named menu item should be enabled in menus. See &lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;Simple Menu Items&lt;/a&gt;.</source>
          <target state="translated">该值是用于确定是否应在菜单中启用命名菜单项的表达式。请参阅&lt;a href=&quot;simple-menu-items#Simple-Menu-Items&quot;&gt;简单菜单项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="988d1fb03cc87294d6912ad4a008a4a541a3d1cf" translate="yes" xml:space="preserve">
          <source>The value is an interactive form for the named function. Normally, you should not set this directly; use the &lt;code&gt;interactive&lt;/code&gt; special form instead. See &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;.</source>
          <target state="translated">该值是命名函数的交互形式。通常，您不应该直接设置它。请改用 &lt;code&gt;interactive&lt;/code&gt; 特殊形式。请参阅&amp;ldquo;&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;交互式呼叫&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2675782eef27c42642a60fce1752cbb34644db5" translate="yes" xml:space="preserve">
          <source>The value is boolean&amp;mdash;either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;. Note that by using &lt;code&gt;choice&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; together (see the next section), you can specify that the value must be &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;, but also specify the text to describe each value in a way that fits the specific meaning of the alternative.</source>
          <target state="translated">值为布尔值 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 。请注意，通过将 &lt;code&gt;choice&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 一起使用（请参阅下一节），可以指定值必须为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; ，还可以指定文本来描述每个值，以适合替代方案的特定含义。</target>
        </trans-unit>
        <trans-unit id="3894f2edc61204404042bc861be88ec42f3d3a29" translate="yes" xml:space="preserve">
          <source>The value is copied from &lt;code&gt;this-command&lt;/code&gt; when a command returns to the command loop, except when the command has specified a prefix argument for the following command.</source>
          <target state="translated">当命令返回到命令循环时，将从 &lt;code&gt;this-command&lt;/code&gt; 复制该值，除非该命令为以下命令指定了前缀参数。</target>
        </trans-unit>
        <trans-unit id="306c554506d781ac28efad2e4ea92701f816dce5" translate="yes" xml:space="preserve">
          <source>The value is either a major mode or a list of major modes. &lt;code&gt;display-buffer-reuse-mode-window&lt;/code&gt; may reuse a window whenever the value specified by this entry matches the major mode of that window&amp;rsquo;s buffer. Other action functions ignore such entries.</source>
          <target state="translated">该值是主要模式或主要模式列表。每当此条目指定的值与该窗口的缓冲区的主模式匹配时， &lt;code&gt;display-buffer-reuse-mode-window&lt;/code&gt; 可能会重用该窗口。其他操作功能将忽略此类条目。</target>
        </trans-unit>
        <trans-unit id="1843e0f5c17e7f0a09b0d1319f9a950d3c352fa5" translate="yes" xml:space="preserve">
          <source>The value is either the empty vector, or is a newly constructed nonempty vector that is not &lt;code&gt;eq&lt;/code&gt; to any existing vector.</source>
          <target state="translated">该值可以是空向量，也可以是新构造的非空向量，不 &lt;code&gt;eq&lt;/code&gt; 任何现有向量。</target>
        </trans-unit>
        <trans-unit id="eb6e5361e7a91533e27cdf7399370f943e9ba10d" translate="yes" xml:space="preserve">
          <source>The value is measured in baud.</source>
          <target state="translated">该值以波特为单位。</target>
        </trans-unit>
        <trans-unit id="be4e71b6f99d1f91e5e6b4886554248affe4a867" translate="yes" xml:space="preserve">
          <source>The value is negative if the first substring is less, positive if the first is greater, and zero if they are equal. The absolute value of the result is one plus the index of the first differing characters within the substrings.</source>
          <target state="translated">如果第一个子串较少,其值为负,如果第一个较大,则为正,如果它们相等,则为零。结果的绝对值是1加上子串内第一个差异字符的指数。</target>
        </trans-unit>
        <trans-unit id="a221deec0b7b326eded452b6cef1afc0c42096b1" translate="yes" xml:space="preserve">
          <source>The value is normally &lt;code&gt;nil&lt;/code&gt;; Lisp programs bind it to &lt;code&gt;t&lt;/code&gt; for brief periods of time.</source>
          <target state="translated">该值通常为 &lt;code&gt;nil&lt;/code&gt; ；Lisp程序会在短时间内将其绑定到 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a10d990baa1d6dc687c357d4165562f04a895757" translate="yes" xml:space="preserve">
          <source>The value is normally a list of the form &lt;code&gt;(&lt;var&gt;filenum&lt;/var&gt;
&lt;var&gt;devnum&lt;/var&gt;)&lt;/code&gt;. This pair of numbers uniquely identifies the file among all files accessible on the system. See the function &lt;code&gt;file-attributes&lt;/code&gt;, in &lt;a href=&quot;file-attributes#File-Attributes&quot;&gt;File Attributes&lt;/a&gt;, for more information about them.</source>
          <target state="translated">该值通常是形式 &lt;code&gt;(&lt;var&gt;filenum&lt;/var&gt; &lt;var&gt;devnum&lt;/var&gt;)&lt;/code&gt; 的列表。这对数字唯一标识系统上所有可访问文件中的文件。请参考函数 &lt;code&gt;file-attributes&lt;/code&gt; ，在&lt;a href=&quot;file-attributes#File-Attributes&quot;&gt;文件属性&lt;/a&gt;，以得到更多的信息。</target>
        </trans-unit>
        <trans-unit id="f6457f0bb5cd3fdfe83d6454775a62a020b7ae87" translate="yes" xml:space="preserve">
          <source>The value is normally an absolute file name. It can also be &lt;code&gt;nil&lt;/code&gt;, if the definition is not associated with any file. If &lt;var&gt;symbol&lt;/var&gt; specifies an autoloaded function, the value can be a relative file name without extension.</source>
          <target state="translated">该值通常是绝对文件名。如果定义未与任何文件关联，则也可以为 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;var&gt;symbol&lt;/var&gt; 指定一个自动加载的函数，则该值可以是一个没有扩展名的相对文件名。</target>
        </trans-unit>
        <trans-unit id="f4bcfcbe7d05d1c0191cd0ba7af653328fe120d2" translate="yes" xml:space="preserve">
          <source>The value is significant only as to whether it is &lt;code&gt;nil&lt;/code&gt; or not. Since such variables often end up acquiring more values over time, this convention is not strongly recommended.</source>
          <target state="translated">该值仅对于是否 &lt;code&gt;nil&lt;/code&gt; 才有意义。由于此类变量通常会随着时间的推移最终获得更多的值，因此不建议强烈采用此约定。</target>
        </trans-unit>
        <trans-unit id="778494fde2953cd1ddb11ad185ad2d2dd95186e4" translate="yes" xml:space="preserve">
          <source>The value may also be &lt;code&gt;nil&lt;/code&gt;. Then all commands work normally, even disabled ones.</source>
          <target state="translated">该值也可以为 &lt;code&gt;nil&lt;/code&gt; 。然后，所有命令都可以正常工作，甚至禁用的命令也可以。</target>
        </trans-unit>
        <trans-unit id="ef59b01ef55bdf2efe2493eea3cfaf23a97d2e9e" translate="yes" xml:space="preserve">
          <source>The value may be any Lisp object that can be printed and read back. You can use &lt;code&gt;sexp&lt;/code&gt; as a fall-back for any option, if you don&amp;rsquo;t want to take the time to work out a more specific type to use.</source>
          <target state="translated">该值可以是任何可以打印和读取的Lisp对象。如果您不希望花时间找出更具体的类型来使用，可以将 &lt;code&gt;sexp&lt;/code&gt; 用作任何选项的后备。</target>
        </trans-unit>
        <trans-unit id="b99730ddec359b16348016cabda6e3291d81a09e" translate="yes" xml:space="preserve">
          <source>The value must be &lt;var&gt;value&lt;/var&gt;&amp;mdash;nothing else is allowed.</source>
          <target state="translated">该值必须是 &lt;var&gt;value&lt;/var&gt; 什么也没有别的是允许的。</target>
        </trans-unit>
        <trans-unit id="87b4d5cd14fe72c47e3003a8680a757eb4604dbf" translate="yes" xml:space="preserve">
          <source>The value must be a character code. A character code is actually an integer, but this type shows the value by inserting the character in the buffer, rather than by showing the number.</source>
          <target state="translated">值必须是一个字符代码。字符代码实际上是一个整数,但这种类型通过在缓冲区中插入字符来显示值,而不是显示数字。</target>
        </trans-unit>
        <trans-unit id="356d38d5cf3fa505e305c63022ab492161a1a6ed" translate="yes" xml:space="preserve">
          <source>The value must be a coding-system name, and you can do completion with</source>
          <target state="translated">值必须是编码系统名称,你可以用</target>
        </trans-unit>
        <trans-unit id="63573ffb5bc552f254086ecf27ae3051cb0cceff" translate="yes" xml:space="preserve">
          <source>The value must be a cons cell, its &lt;small&gt;CAR&lt;/small&gt; must fit &lt;var&gt;car-type&lt;/var&gt;, and its &lt;small&gt;CDR&lt;/small&gt; must fit &lt;var&gt;cdr-type&lt;/var&gt;. For example, &lt;code&gt;(cons string
symbol)&lt;/code&gt; is a customization type which matches values such as &lt;code&gt;(&quot;foo&quot; . foo)&lt;/code&gt;.</source>
          <target state="translated">该值必须是一个cons单元格，其&lt;small&gt;CAR&lt;/small&gt;必须适合 &lt;var&gt;car-type&lt;/var&gt; ，其&lt;small&gt;CDR&lt;/small&gt;必须适合 &lt;var&gt;cdr-type&lt;/var&gt; 。例如， &lt;code&gt;(cons string symbol)&lt;/code&gt; 是一种自定义类型，它匹配诸如 &lt;code&gt;(&quot;foo&quot; . foo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57910dac76238c31c6f7af52f08cdcf756ebfb61" translate="yes" xml:space="preserve">
          <source>The value must be a directory. The widget provides completion.</source>
          <target state="translated">值必须是一个目录。小部件提供完成。</target>
        </trans-unit>
        <trans-unit id="810836eddfb49dd28f43e49c497214d6e73aaac5" translate="yes" xml:space="preserve">
          <source>The value must be a file name for an existing file. The widget provides completion.</source>
          <target state="translated">该值必须是现有文件的文件名。小工具提供完成。</target>
        </trans-unit>
        <trans-unit id="b6a74a7f285c0c5906e259820de400e746147836" translate="yes" xml:space="preserve">
          <source>The value must be a file name. The widget provides completion.</source>
          <target state="translated">该值必须是文件名。小工具提供完成。</target>
        </trans-unit>
        <trans-unit id="13f9e716c79c89cbb1b9b4a0a3061a3b3b7535c7" translate="yes" xml:space="preserve">
          <source>The value must be a function taking one argument (a frame), supposed to return non-&lt;code&gt;nil&lt;/code&gt; if that frame is a candidate for displaying the buffer. This entry is used by &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt;.</source>
          <target state="translated">该值必须是一个带有一个参数（一个框架）的函数，如果该框架是显示缓冲区的候选者，则该参数应返回 &lt;code&gt;nil&lt;/code&gt; 。此条目由 &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="d0769814e541d4c1c6d9cf382832b62aff25584a" translate="yes" xml:space="preserve">
          <source>The value must be a function that takes one argument, a window, and returns either a new window (which will be used to display the desired buffer) or &lt;code&gt;nil&lt;/code&gt; (which means the splitting failed). The default value is &lt;code&gt;split-window-sensibly&lt;/code&gt;, which is documented next.</source>
          <target state="translated">该值必须是一个函数，该函数接受一个参数，一个窗口，并返回一个新窗口（将用于显示所需的缓冲区）或 &lt;code&gt;nil&lt;/code&gt; （这意味着拆分失败）。缺省值为 &lt;code&gt;split-window-sensibly&lt;/code&gt; ，将在下面记录。</target>
        </trans-unit>
        <trans-unit id="10add5bdc2dc784e1ca37482866dfd6d4c60ef8f" translate="yes" xml:space="preserve">
          <source>The value must be a list and each element of the list must fit the type &lt;var&gt;element-type&lt;/var&gt;. This appears in the customization buffer as a list of elements, with &amp;lsquo;</source>
          <target state="translated">该值必须是一个列表，并且列表中的每个元素都必须适合类型 &lt;var&gt;element-type&lt;/var&gt; 。这在自定义缓冲区中显示为元素列表，带有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="69283ab46854490317f97e1feb0235ad06aef920" translate="yes" xml:space="preserve">
          <source>The value must be a list of cons-cells, the &lt;small&gt;CAR&lt;/small&gt; of each cell representing a key of customization type &lt;var&gt;key-type&lt;/var&gt;, and the &lt;small&gt;CDR&lt;/small&gt; of the same cell representing a value of customization type &lt;var&gt;value-type&lt;/var&gt;. The user can add and delete key/value pairs, and edit both the key and the value of each pair.</source>
          <target state="translated">该值必须是cons单元的列表，每个单元的&lt;small&gt;CAR&lt;/small&gt;表示定制类型 &lt;var&gt;key-type&lt;/var&gt; 的键，并且同一单元的&lt;small&gt;CDR&lt;/small&gt;表示定制类型 &lt;var&gt;value-type&lt;/var&gt; 的值。用户可以添加和删除键/值对，并编辑键和值对。</target>
        </trans-unit>
        <trans-unit id="e94e481856916cf8928303ce6c5fe6173ae9d7b6" translate="yes" xml:space="preserve">
          <source>The value must be a list of functions. This customization type is used for hook variables. You can use the &lt;code&gt;:options&lt;/code&gt; keyword in a hook variable&amp;rsquo;s &lt;code&gt;defcustom&lt;/code&gt; to specify a list of functions recommended for use in the hook; See &lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;Variable Definitions&lt;/a&gt;.</source>
          <target state="translated">该值必须是功能列表。此定制类型用于挂钩变量。您可以在钩子变量的 &lt;code&gt;defcustom&lt;/code&gt; 中使用 &lt;code&gt;:options&lt;/code&gt; 关键字来指定建议在钩子中使用的函数列表。请参阅&lt;a href=&quot;variable-definitions#Variable-Definitions&quot;&gt;变量定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54b586711663d904f858b9b290b8d22b94a091f6" translate="yes" xml:space="preserve">
          <source>The value must be a list with exactly as many elements as the &lt;var&gt;element-types&lt;/var&gt; given; and each element must fit the corresponding &lt;var&gt;element-type&lt;/var&gt;.</source>
          <target state="translated">该值必须是一个列表，该列表具有与给定 &lt;var&gt;element-types&lt;/var&gt; 一样多的元素。并且每个元素必须适合相应的 &lt;var&gt;element-type&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="896d6796a36a3b3136852c309aa7d01c3792f5f6" translate="yes" xml:space="preserve">
          <source>The value must be a list, and each element of the list must match one of the &lt;var&gt;types&lt;/var&gt; specified.</source>
          <target state="translated">该值必须是一个列表，并且列表的每个元素必须与指定的 &lt;var&gt;types&lt;/var&gt; 之一匹配。</target>
        </trans-unit>
        <trans-unit id="3aeeaa45e096ad8313dd25ab21d8c10013208130" translate="yes" xml:space="preserve">
          <source>The value must be a number (floating point or integer).</source>
          <target state="translated">该值必须是一个数字(浮点或整数)。</target>
        </trans-unit>
        <trans-unit id="945efd91d2acb86b2c28413feb5748c4d0bd2079" translate="yes" xml:space="preserve">
          <source>The value must be a string. The customization buffer shows the string without delimiting &amp;lsquo;</source>
          <target state="translated">该值必须是一个字符串。自定义缓冲区显示的字符串没有定界&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4752821348ac6fabc91456f988d3e618cd05d1f6" translate="yes" xml:space="preserve">
          <source>The value must be a symbol which is a face name. The widget provides completion.</source>
          <target state="translated">该值必须是一个符号,它是一个面名。小部件提供完成。</target>
        </trans-unit>
        <trans-unit id="67a06078fab94776bb45407ad95be9c13181139f" translate="yes" xml:space="preserve">
          <source>The value must be a symbol. It appears in the customization buffer as the symbol name. The widget provides completion.</source>
          <target state="translated">该值必须是一个符号。它作为符号名称出现在自定义缓冲区中。小组件提供完成。</target>
        </trans-unit>
        <trans-unit id="5849f60cb5b32368a764c6539b8c8a00d225ed38" translate="yes" xml:space="preserve">
          <source>The value must be a valid color name. The widget provides completion for color names, as well as a sample and a button for selecting a color name from a list of color names shown in a</source>
          <target state="translated">该值必须是有效的颜色名称。小组件提供颜色名称的完成,以及用于从颜色名称列表中选择颜色名称的样例和按钮,这些颜色名称显示在颜色名称列表中。</target>
        </trans-unit>
        <trans-unit id="d2c0b88b87276fde817f7f25e6fbe66a3b002536" translate="yes" xml:space="preserve">
          <source>The value must be a variable name. The widget provides completion.</source>
          <target state="translated">值必须是一个变量名。小部件提供完成。</target>
        </trans-unit>
        <trans-unit id="866e1c92bc84fa3056c2cc92aa9eb34d171bc22b" translate="yes" xml:space="preserve">
          <source>The value must be an integer.</source>
          <target state="translated">该值必须是一个整数。</target>
        </trans-unit>
        <trans-unit id="ce3a6a49432bb3e2bb25953ebf11758d62c57727" translate="yes" xml:space="preserve">
          <source>The value must be either a lambda expression or a function name. The widget provides completion for function names.</source>
          <target state="translated">值必须是 lambda 表达式或函数名。小组件为函数名提供了完备性。</target>
        </trans-unit>
        <trans-unit id="9de80c74f410724e3e9d2d4e057e94956796434d" translate="yes" xml:space="preserve">
          <source>The value must be floating point.</source>
          <target state="translated">该值必须是浮点数。</target>
        </trans-unit>
        <trans-unit id="597960a6ce739f902fa9c94199257d090be01a23" translate="yes" xml:space="preserve">
          <source>The value must fit one of &lt;var&gt;alternative-types&lt;/var&gt;. For example, &lt;code&gt;(choice integer string)&lt;/code&gt; allows either an integer or a string.</source>
          <target state="translated">该值必须适合 &lt;var&gt;alternative-types&lt;/var&gt; 。例如， &lt;code&gt;(choice integer string)&lt;/code&gt; 允许整数或字符串。</target>
        </trans-unit>
        <trans-unit id="c16d4e66c8a9aef6f1bbfad4e5db9283eb01c2d3" translate="yes" xml:space="preserve">
          <source>The value must specify a window that may have displayed the buffer previously. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; will give preference to such a window provided it is still live and not dedicated to another buffer.</source>
          <target state="translated">该值必须指定一个以前可能已显示缓冲区的窗口。 &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; 一个窗口仍处于活动状态且未专用于另一个缓冲区，则该窗口将优先显示该窗口。</target>
        </trans-unit>
        <trans-unit id="a8dcd9a15008fc01a594ad9652de93cb7a57eb20" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(acos &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; is a number between 0 and pi (inclusive) whose cosine is &lt;var&gt;arg&lt;/var&gt;. If &lt;var&gt;arg&lt;/var&gt; is out of range (outside [-1, 1]), &lt;code&gt;acos&lt;/code&gt; returns a NaN.</source>
          <target state="translated">&lt;code&gt;(acos &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; 的值是一个介于0和pi（含）之间的数字，其余弦为 &lt;var&gt;arg&lt;/var&gt; 。如果 &lt;var&gt;arg&lt;/var&gt; 超出范围（[-1，1]之外），则 &lt;code&gt;acos&lt;/code&gt; 返回NaN。</target>
        </trans-unit>
        <trans-unit id="fd06b4d6ba82cc559a28714761ccf61d840a6365" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(asin &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; is a number between -pi/2 and pi/2 (inclusive) whose sine is &lt;var&gt;arg&lt;/var&gt;. If &lt;var&gt;arg&lt;/var&gt; is out of range (outside [-1, 1]), &lt;code&gt;asin&lt;/code&gt; returns a NaN.</source>
          <target state="translated">&lt;code&gt;(asin &lt;var&gt;arg&lt;/var&gt;)&lt;/code&gt; 的值是-pi / 2到pi / 2（含）之间的数字，其正弦值为 &lt;var&gt;arg&lt;/var&gt; 。如果 &lt;var&gt;arg&lt;/var&gt; 超出范围（[-1，1]之外），则 &lt;code&gt;asin&lt;/code&gt; 返回NaN。</target>
        </trans-unit>
        <trans-unit id="9a7380bf9f6c5b9249cafc94b2adcec1cea58bac" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;(atan &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; is a number between -pi/2 and pi/2 (exclusive) whose tangent is &lt;var&gt;y&lt;/var&gt;. If the optional second argument &lt;var&gt;x&lt;/var&gt; is given, the value of &lt;code&gt;(atan y x)&lt;/code&gt; is the angle in radians between the vector &lt;code&gt;[&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;]&lt;/code&gt; and the &lt;code&gt;X&lt;/code&gt; axis.</source>
          <target state="translated">&lt;code&gt;(atan &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 的值是-pi / 2和pi / 2之间的数字（不包括），其切线为 &lt;var&gt;y&lt;/var&gt; 。如果给出了可选的第二个参数 &lt;var&gt;x&lt;/var&gt; ，则 &lt;code&gt;(atan y x)&lt;/code&gt; 的值是向量 &lt;code&gt;[&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;]&lt;/code&gt; 与 &lt;code&gt;X&lt;/code&gt; 轴之间的弧度角。</target>
        </trans-unit>
        <trans-unit id="c9e728ea829977e40f53b131b5144e09a9f2f814" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;auto-fill-function&lt;/code&gt; is &lt;code&gt;do-auto-fill&lt;/code&gt; when Auto Fill mode is enabled. That is a function whose sole purpose is to implement the usual strategy for breaking a line.</source>
          <target state="translated">值 &lt;code&gt;auto-fill-function&lt;/code&gt; 是 &lt;code&gt;do-auto-fill&lt;/code&gt; 时启用了自动填充模式。这是一个功能，其唯一目的是实施打破常规的常规策略。</target>
        </trans-unit>
        <trans-unit id="d3bae7cd024789f811c4af6bb48478148919779d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;exec-path&lt;/code&gt; is used by &lt;code&gt;call-process&lt;/code&gt; and &lt;code&gt;start-process&lt;/code&gt; when the &lt;var&gt;program&lt;/var&gt; argument is not an absolute file name.</source>
          <target state="translated">当 &lt;var&gt;program&lt;/var&gt; 参数不是绝对文件名时， &lt;code&gt;exec-path&lt;/code&gt; 的值将由 &lt;code&gt;call-process&lt;/code&gt; 和 &lt;code&gt;start-process&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="30c13d6566147e5f7ff2d3b3fa785aa4e4166cab" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global-mode-string&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="3d3a2b88654bd12f5337924840af3d4601a33e57" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;input-decode-map&lt;/code&gt; is usually set up automatically according to the terminal&amp;rsquo;s Terminfo or Termcap entry, but sometimes those need help from terminal-specific Lisp files. Emacs comes with terminal-specific files for many common terminals; their main purpose is to make entries in &lt;code&gt;input-decode-map&lt;/code&gt; beyond those that can be deduced from Termcap and Terminfo. See &lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;Terminal-Specific&lt;/a&gt;.</source>
          <target state="translated">通常根据终端的Terminfo或Termcap条目自动设置 &lt;code&gt;input-decode-map&lt;/code&gt; 的值，但是有时它们需要终端特定的Lisp文件的帮助。 Emacs随附了许多常见终端的终端特定文件。它们的主要目的是使 &lt;code&gt;input-decode-map&lt;/code&gt; 中的条目超出可以从Termcap和Terminfo推导出的条目。请参阅&lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;特定于终端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="639680a63cdaad1e211652d86db8f9e826824dca" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; is always &lt;code&gt;eq&lt;/code&gt; to one of the links in the kill ring list. The element it identifies is the &lt;small&gt;CAR&lt;/small&gt; of that link. Kill commands, which change the kill ring, also set this variable to the value of &lt;code&gt;kill-ring&lt;/code&gt;. The effect is to rotate the ring so that the newly killed text is at the front.</source>
          <target state="translated">值 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 总是 &lt;code&gt;eq&lt;/code&gt; 在杀戒列表中的链接之一。它标识的元素是该链接的&lt;small&gt;CAR&lt;/small&gt;。杀死命令，改变了剪切环，该变量也被设置为的值 &lt;code&gt;kill-ring&lt;/code&gt; 。效果是旋转环，以使新杀死的文本位于最前面。</target>
        </trans-unit>
        <trans-unit id="b0adbfa26a0f5e416e962a7d1ef1be229d44f4eb" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;load-history&lt;/code&gt; may have one element whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;nil&lt;/code&gt;. This element describes definitions made with &lt;code&gt;eval-buffer&lt;/code&gt; on a buffer that is not visiting a file.</source>
          <target state="translated">&lt;code&gt;load-history&lt;/code&gt; 的值可能包含一个&lt;small&gt;CAR&lt;/small&gt;为 &lt;code&gt;nil&lt;/code&gt; 的元素。该元素描述了在不访问文件 &lt;code&gt;eval-buffer&lt;/code&gt; 上使用eval-buffer进行的定义。</target>
        </trans-unit>
        <trans-unit id="0c0cf4e96ec8565ee4c3ece809d9e7876396b3e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;mode-name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode-name&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="01f5f8f11917d60cc33932b39ed53647b1e12540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;pointm&lt;/code&gt; at the last redisplay time.</source>
          <target state="translated">最后一次重新显示时的 &lt;code&gt;pointm&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="15b964ce86184c0c14ba0a0fa6d8168b77cc4283" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;process-connection-type&lt;/code&gt; takes effect when &lt;code&gt;make-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt; is called. So you can specify how to communicate with one subprocess by binding the variable around the call to these functions.</source>
          <target state="translated">调用 &lt;code&gt;make-process&lt;/code&gt; 或 &lt;code&gt;start-process&lt;/code&gt; 时， &lt;code&gt;process-connection-type&lt;/code&gt; 的值生效。因此，您可以通过将调用周围的变量绑定到这些函数来指定如何与一个子流程进行通信。</target>
        </trans-unit>
        <trans-unit id="f4917d7965a0a2a0eceea9527333fc312c3a1d97" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;track-mouse&lt;/code&gt; is that of the last form in &lt;var&gt;body&lt;/var&gt;. You should design &lt;var&gt;body&lt;/var&gt; to return when it sees the up-event that indicates the release of the button, or whatever kind of event means it is time to stop tracking.</source>
          <target state="translated">&lt;code&gt;track-mouse&lt;/code&gt; 的值是 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。您应该设计 &lt;var&gt;body&lt;/var&gt; 使其在看到指示按钮释放的向上事件或任何类型的事件意味着该停止跟踪的时候返回。</target>
        </trans-unit>
        <trans-unit id="8e1d48548038a94283629f3b24139decfc462f06" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;geometry&lt;/var&gt; should be a list of the form &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; specify the width and height of the cropped image. If &lt;var&gt;x&lt;/var&gt; is a positive number it specifies the offset of the cropped area from the left of the original image, and if negative the offset from the right. If &lt;var&gt;y&lt;/var&gt; is a positive number it specifies the offset from the top of the original image, and if negative from the bottom. If &lt;var&gt;x&lt;/var&gt; or &lt;var&gt;y&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; or unspecified the crop area will be centered on the original image.</source>
          <target state="translated">&lt;var&gt;geometry&lt;/var&gt; 的值应为以下形式的列表 &lt;code&gt;(&lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; 。 &lt;var&gt;width&lt;/var&gt; 和 &lt;var&gt;height&lt;/var&gt; 指定裁剪图像的宽度和高度。如果 &lt;var&gt;x&lt;/var&gt; 为正数，则指定裁剪区域距原始图像左侧的偏移量；如果为负，则指定距右侧右侧的偏移量。如果 &lt;var&gt;y&lt;/var&gt; 为正数，则指定距原始图像顶部的偏移量，如果为负数，则指定距底部的偏移量。如果 &lt;var&gt;x&lt;/var&gt; 或 &lt;var&gt;y&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; 或不特定的作物面积将在原始图像上的中心。</target>
        </trans-unit>
        <trans-unit id="f9a0aa42133a8566714c8da5cfb1ac14d08f0cbd" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;list&lt;/var&gt; specifies the objects to ask questions about. It should be either a list of objects or a generator function. If it is a function, it should expect no arguments, and should return either the next object to ask about, or &lt;code&gt;nil&lt;/code&gt;, meaning to stop asking questions.</source>
          <target state="translated">&lt;var&gt;list&lt;/var&gt; 的值指定要提出问题的对象。它应该是对象列表或生成器函数。如果它是一个函数，则不应包含任何参数，并且应返回下一个要询问的对象，或者返回 &lt;code&gt;nil&lt;/code&gt; ，以停止询问。</target>
        </trans-unit>
        <trans-unit id="292f71c1213df0a0c0f3e562c978b3b0e7d59643" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;package&lt;/var&gt; needs to be unique and it needs to match the &lt;var&gt;package&lt;/var&gt; value appearing in the &lt;code&gt;:package-version&lt;/code&gt; keyword. Since the user might see the value in an error message, a good choice is the official name of the package, such as MH-E or Gnus.</source>
          <target state="translated">&lt;var&gt;package&lt;/var&gt; 的值必须唯一，并且必须与 &lt;code&gt;:package-version&lt;/code&gt; 关键字中出现的 &lt;var&gt;package&lt;/var&gt; 值匹配。由于用户可能会在错误消息中看到该值，因此最好选择软件包的正式名称，例如MH-E或Gnus。</target>
        </trans-unit>
        <trans-unit id="fb4c37d36e42ca7bde0fbebe3ad9e40de14d67b3" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;persistent&lt;/var&gt; is the value specified for &lt;var&gt;window&lt;/var&gt; with the last successful invocation of &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; if there never was one.</source>
          <target state="translated">值 &lt;var&gt;persistent&lt;/var&gt; 是指定的值 &lt;var&gt;window&lt;/var&gt; 与上次成功调用 &lt;code&gt;set-window-scroll-bars&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; 如果本来就没有一个。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
